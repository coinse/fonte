{"sha": "ca1e681ac7ce142befe950df5506e81c1935252d", "log": "Removing all new lines in every source file - priceless. Arse. Reverting by exporting the old version on top and committing  ", "commit": "\n--- a/src/java/org/apache/commons/cli2/Argument.java\n+++ b/src/java/org/apache/commons/cli2/Argument.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.ListIterator;/** * An Option that can process values passed on the command line in the form * \"--file README\". */public interface Argument extends Option {    /**     * Returns the initial separator character or     * '\\0' if no character has been set.     *     * @return char the initial separator character     */    char getInitialSeparator();    /**     * Processes the \"README\" style element of the argument.     *     * Values identified should be added to the CommandLine object in     * association with this Argument.     *     * @see WriteableCommandLine#addValue(Option,Object)     *     * @param commandLine The CommandLine object to store results in.     * @param args The arguments to process.     * @param option The option to register value against.     * @throws OptionException if any problems occur.     */    void processValues(        final WriteableCommandLine commandLine,        final ListIterator args,        final Option option)            throws OptionException;    /**     * Adds defaults to a CommandLine.     *     * @param commandLine     *            The CommandLine object to store defaults in.     * @param option     *            The Option to store the defaults against.     */    void defaultValues(final WriteableCommandLine commandLine, final Option option);    /**     * Performs any necessary validation on the values added to the     * CommandLine.     *     * Validation will typically involve using the     * CommandLine.getValues(option) method to retrieve the values     * and then either checking each value.  Optionally the String     * value can be replaced by another Object such as a Number     * instance or a File instance.     *     * @see CommandLine#getValues(Option)     *     * @param commandLine The CommandLine object to query.     * @param option The option to lookup values with.     * @throws OptionException if any problems occur.     */    void validate(final WriteableCommandLine commandLine, final Option option)        throws OptionException;    /**     * Indicates whether argument values must be present for the CommandLine to     * be valid.     *     * @see #getMinimum()     * @see #getMaximum()     * @return true iff the CommandLine will be invalid without at least one     *         value     */    boolean isRequired();    /**     * Retrieves the minimum number of values required for a valid Argument     *     * @return the minimum number of values     */    int getMinimum();    /**     * Retrieves the maximum number of values acceptable for a valid Argument     *     * @return the maximum number of values     */    int getMaximum();}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.ListIterator;\n+\n+/**\n+ * An Option that can process values passed on the command line in the form\n+ * \"--file README\".\n+ */\n+public interface Argument extends Option {\n+\n+    /**\n+     * Returns the initial separator character or\n+     * '\\0' if no character has been set.\n+     * \n+     * @return char the initial separator character\n+     */\n+    char getInitialSeparator();\n+    \n+    /**\n+     * Processes the \"README\" style element of the argument.\n+     *\n+     * Values identified should be added to the CommandLine object in\n+     * association with this Argument.\n+     *\n+     * @see WriteableCommandLine#addValue(Option,Object)\n+     *\n+     * @param commandLine The CommandLine object to store results in.\n+     * @param args The arguments to process.\n+     * @param option The option to register value against.\n+     * @throws OptionException if any problems occur.\n+     */\n+    void processValues(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator args,\n+        final Option option)\n+            throws OptionException;\n+    \n+    /**\n+     * Adds defaults to a CommandLine.\n+     * \n+     * @param commandLine\n+     *            The CommandLine object to store defaults in.\n+     * @param option\n+     *            The Option to store the defaults against.\n+     */\n+    void defaultValues(final WriteableCommandLine commandLine, final Option option);\n+\n+    /**\n+     * Performs any necessary validation on the values added to the\n+     * CommandLine.\n+     *\n+     * Validation will typically involve using the\n+     * CommandLine.getValues(option) method to retrieve the values\n+     * and then either checking each value.  Optionally the String\n+     * value can be replaced by another Object such as a Number\n+     * instance or a File instance.\n+     *\n+     * @see CommandLine#getValues(Option)\n+     *\n+     * @param commandLine The CommandLine object to query.\n+     * @param option The option to lookup values with.\n+     * @throws OptionException if any problems occur.\n+     */\n+    void validate(final WriteableCommandLine commandLine, final Option option)\n+        throws OptionException;\n+\n+    /**\n+     * Indicates whether argument values must be present for the CommandLine to\n+     * be valid.\n+     *\n+     * @see #getMinimum()\n+     * @see #getMaximum()\n+     * @return true iff the CommandLine will be invalid without at least one \n+     *         value\n+     */\n+    boolean isRequired();\n+\n+    /**\n+     * Retrieves the minimum number of values required for a valid Argument\n+     *\n+     * @return the minimum number of values\n+     */\n+    int getMinimum();\n+\n+    /**\n+     * Retrieves the maximum number of values acceptable for a valid Argument\n+     *\n+     * @return the maximum number of values\n+     */\n+    int getMaximum();\n+}\n--- a/src/java/org/apache/commons/cli2/CommandLine.java\n+++ b/src/java/org/apache/commons/cli2/CommandLine.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.List;import java.util.Set;/** * Instances of CommandLine represent a command line that has been processed * according to the definition supplied to the parser. */public interface CommandLine {    /**     * Detects the presence of an option with the specified trigger in this     * CommandLine.     *     * @param trigger the trigger to search for     * @return true iff an option with this trigger is present     */    boolean hasOption(final String trigger);    /**     * Detects the presence of an option in this CommandLine.     *     * @param option the Option to search for     * @return true iff the option is present     */    boolean hasOption(final Option option);    /**     * Finds the Option with the specified trigger     *     * @param trigger the name of the option to retrieve     * @return the Option matching the trigger or null if none exists     */    Option getOption(final String trigger);    /**     * Retrieves the Argument values associated with the specified Option     *     * @param trigger a trigger used to lookup the Option     * @return a list of values or an empty List if none are found     */    List getValues(final String trigger);    /**     * Retrieves the Argument values associated with the specified Option     *     * @param trigger a trigger used to lookup the Option     * @param defaultValues the result to return if no values are found     * @return a list of values or defaultValues if none are found     */    List getValues(final String trigger, final List defaultValues);    /**     * Retrieves the Argument values associated with the specified Option     *     * @param option the Option associated with the values     * @return a list of values or an empty List if none are found     */    List getValues(final Option option);    /**     * Retrieves the Argument values associated with the specified Option     *     * @param option the Option associated with the values     * @param defaultValues the result to return if no values are found     * @return a list of values or defaultValues if none are found     */    List getValues(final Option option, final List defaultValues);    /**     * Retrieves the single Argument value associated with the specified Option     *     * @param trigger a trigger used to lookup the Option     * @return the matching value or null if none exists     * @throws IllegalStateException if more than one values are found     */    Object getValue(final String trigger) throws IllegalStateException;    /**     * Retrieves the single Argument value associated with the specified Option     *     * @param trigger a trigger used to lookup the Option     * @param defaultValue the result to use if no values are found     * @return the matching value or defaultValue if none exists     * @throws IllegalStateException if more than one values are found     */    Object getValue(final String trigger, final Object defaultValue) throws IllegalStateException;    /**     * Retrieves the single Argument value associated with the specified Option     *     * @param option the Option associated with the value     * @return the matching value or null if none exists     * @throws IllegalStateException if more than one values are found     */    Object getValue(final Option option) throws IllegalStateException;    /**     * Retrieves the single Argument value associated with the specified Option     *     * @param option the Option associated with the value     * @param defaultValue the result to use if no values are found     * @return the matching value or defaultValue if none exists     * @throws IllegalStateException if more than one values are found     */    Object getValue(final Option option, final Object defaultValue) throws IllegalStateException;    /**     * Retrieves the Boolean value associated with the specified Switch     *     * @param trigger a trigger used to lookup the Option     * @return the Boolean associated with trigger or null if none exists     */    Boolean getSwitch(final String trigger);    /**     * Retrieves the Boolean value associated with the specified Switch     *     * @param trigger a trigger used to lookup the Option     * @param defaultValue the Boolean to use if none match     * @return the Boolean associated with trigger or defaultValue if none exists     */    Boolean getSwitch(final String trigger, final Boolean defaultValue);    /**     * Retrieves the Boolean value associated with the specified Switch     *     * @param option the Option associated with the value     * @return the Boolean associated with option or null if none exists     */    Boolean getSwitch(final Option option);    /**     * Retrieves the Boolean value associated with the specified Switch     *     * @param option the Option associated with the value     * @param defaultValue the Boolean to use if none match     * @return the Boolean associated with option or defaultValue if none exists     */    Boolean getSwitch(final Option option, final Boolean defaultValue);    /**     * Retrieves the value associated with the specified property     *     * @param property the property name to lookup     * @return the value of the property or null     */    String getProperty(final String property);    /**     * Retrieves the value associated with the specified property     *     * @param property the property name to lookup     * @param defaultValue the value to use if no other is found     * @return the value of the property or defaultValue     */    String getProperty(final String property, final String defaultValue);    /**     * Retrieves the set of all property names associated with this CommandLine     *     * @return a none null set of property names     */    Set getProperties();    /**     * Retrieves the number of times the specified Option appeared in this     * CommandLine     *     * @param trigger a trigger used to lookup the Option     * @return the number of occurrences of the option     */    int getOptionCount(final String trigger);    /**     * Retrieves the number of times the specified Option appeared in this     * CommandLine     *     * @param option the Option associated to check     * @return the number of occurrences of the option     */    int getOptionCount(final Option option);    /**     * Retrieves a list of all Options found in this CommandLine     *     * @return a none null list of Options     */    List getOptions();    /**     * Retrieves a list of all Option triggers found in this CommandLine     *     * @return a none null list of Option triggers     */    Set getOptionTriggers();}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Instances of CommandLine represent a command line that has been processed\n+ * according to the definition supplied to the parser.\n+ */\n+public interface CommandLine {\n+\t\n+    /**\n+     * Detects the presence of an option with the specified trigger in this \n+     * CommandLine.\n+     * \n+     * @param trigger the trigger to search for\n+     * @return true iff an option with this trigger is present\n+     */\n+    boolean hasOption(final String trigger);\n+    \n+    /**\n+     * Detects the presence of an option in this CommandLine.\n+     * \n+     * @param option the Option to search for\n+     * @return true iff the option is present\n+     */\n+    boolean hasOption(final Option option);\n+    \n+    /**\n+     * Finds the Option with the specified trigger\n+     * \n+     * @param trigger the name of the option to retrieve\n+     * @return the Option matching the trigger or null if none exists\n+     */\n+    Option getOption(final String trigger);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return a list of values or an empty List if none are found\n+     */\n+    List getValues(final String trigger);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @param defaultValues the result to return if no values are found\n+     * @return a list of values or defaultValues if none are found\n+     */\n+    List getValues(final String trigger, final List defaultValues);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param option the Option associated with the values\n+     * @return a list of values or an empty List if none are found\n+     */\n+    List getValues(final Option option);\n+    \n+    /**\n+     * Retrieves the Argument values associated with the specified Option\n+     * \n+     * @param option the Option associated with the values\n+     * @param defaultValues the result to return if no values are found\n+     * @return a list of values or defaultValues if none are found\n+     */\n+    List getValues(final Option option, final List defaultValues);\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return the matching value or null if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final String trigger) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @param defaultValue the result to use if no values are found\n+     * @return the matching value or defaultValue if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final String trigger, final Object defaultValue) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param option the Option associated with the value\n+     * @return the matching value or null if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final Option option) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the single Argument value associated with the specified Option\n+     * \n+     * @param option the Option associated with the value\n+     * @param defaultValue the result to use if no values are found\n+     * @return the matching value or defaultValue if none exists\n+     * @throws IllegalStateException if more than one values are found\n+     */\n+    Object getValue(final Option option, final Object defaultValue) throws IllegalStateException;\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return the Boolean associated with trigger or null if none exists\n+     */\n+    Boolean getSwitch(final String trigger);\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @param defaultValue the Boolean to use if none match\n+     * @return the Boolean associated with trigger or defaultValue if none exists\n+     */\n+    Boolean getSwitch(final String trigger, final Boolean defaultValue);\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param option the Option associated with the value\n+     * @return the Boolean associated with option or null if none exists\n+     */\n+    Boolean getSwitch(final Option option);\n+    \n+    /**\n+     * Retrieves the Boolean value associated with the specified Switch\n+     * \n+     * @param option the Option associated with the value\n+     * @param defaultValue the Boolean to use if none match\n+     * @return the Boolean associated with option or defaultValue if none exists\n+     */\n+    Boolean getSwitch(final Option option, final Boolean defaultValue);\n+    \n+    \n+    /**\n+     * Retrieves the value associated with the specified property \n+     * \n+     * @param property the property name to lookup\n+     * @return the value of the property or null\n+     */\n+    String getProperty(final String property);\n+    \n+    /**\n+     * Retrieves the value associated with the specified property \n+     * \n+     * @param property the property name to lookup\n+     * @param defaultValue the value to use if no other is found\n+     * @return the value of the property or defaultValue\n+     */\n+    String getProperty(final String property, final String defaultValue);\n+    \n+    /**\n+     * Retrieves the set of all property names associated with this CommandLine\n+     * \n+     * @return a none null set of property names \n+     */\n+    Set getProperties();\n+    \n+    /**\n+     * Retrieves the number of times the specified Option appeared in this \n+     * CommandLine\n+     * \n+     * @param trigger a trigger used to lookup the Option\n+     * @return the number of occurrences of the option\n+     */\n+    int getOptionCount(final String trigger);\n+    \n+    /**\n+     * Retrieves the number of times the specified Option appeared in this \n+     * CommandLine\n+     * \n+     * @param option the Option associated to check\n+     * @return the number of occurrences of the option\n+     */\n+    int getOptionCount(final Option option);\n+    \n+    /**\n+     * Retrieves a list of all Options found in this CommandLine\n+     * \n+     * @return a none null list of Options\n+     */\n+    List getOptions();\n+    \n+    /**\n+     * Retrieves a list of all Option triggers found in this CommandLine\n+     * \n+     * @return a none null list of Option triggers\n+     */\n+    Set getOptionTriggers();\n+}\n--- a/src/java/org/apache/commons/cli2/DisplaySetting.java\n+++ b/src/java/org/apache/commons/cli2/DisplaySetting.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Collections;import java.util.HashSet;import java.util.Set;/** * An enum of possible display settings. These settings are used to control the * presence of various features in the String representations of options, * CommandLines and usage strings.  Usually a Set of DisplaySetting instances * will be passed to a method that will lookup the presence of the values. */public class DisplaySetting {    private static final Set all = new HashSet();    /**     * A Set guarenteed to contain all possible DisplaySetting values     */    public static final Set ALL = Collections.unmodifiableSet(all);    /**     * A Set guarenteed to contain no DisplaySetting values     */    public static final Set NONE = Collections.EMPTY_SET;    /**     * Indicates that aliases should be included     */    public static final DisplaySetting DISPLAY_ALIASES =        new DisplaySetting(\"DISPLAY_ALIASES\");    /**     * Indicates that optionality should be included     */    public static final DisplaySetting DISPLAY_OPTIONAL =        new DisplaySetting(\"DISPLAY_OPTIONAL\");    /**     * Indicates that property options should be included     */    public static final DisplaySetting DISPLAY_PROPERTY_OPTION =        new DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");    /**     * Indicates that switches should be included enabled     */    public static final DisplaySetting DISPLAY_SWITCH_ENABLED =        new DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");    /**     * Indicates that switches should be included disabled     */    public static final DisplaySetting DISPLAY_SWITCH_DISABLED =        new DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");    /**     * Indicates that group names should be included     */    public static final DisplaySetting DISPLAY_GROUP_NAME =        new DisplaySetting(\"DISPLAY_GROUP_NAME\");    /**     * Indicates that groups should be included expanded     */    public static final DisplaySetting DISPLAY_GROUP_EXPANDED =        new DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");    /**     * Indicates that group arguments should be included     */    public static final DisplaySetting DISPLAY_GROUP_ARGUMENT =        new DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");    /**     * Indicates that group outer brackets should be included     */    public static final DisplaySetting DISPLAY_GROUP_OUTER =        new DisplaySetting(\"DISPLAY_GROUP_OUTER\");    /**     * Indicates that arguments should be included numbered     */    public static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =        new DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");    /**     * Indicates that arguments should be included bracketed     */    public static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =        new DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");    /**     * Indicates that arguments of Parents should be included     */    public static final DisplaySetting DISPLAY_PARENT_ARGUMENT =        new DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");    /**     * Indicates that children of Parents should be included     */    public static final DisplaySetting DISPLAY_PARENT_CHILDREN =        new DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");    /**     * The name of the setting     */    private final String name;    /**     * The hashCode of the setting     */    private final int hashCode;    /**     * Creates a new DisplaySetting with the specified name     * @param name the name of the setting     */    private DisplaySetting(final String name) {        this.name = name;        this.hashCode = name.hashCode();        all.add(this);    }    public int hashCode() {        return hashCode;    }    public boolean equals(final Object that) {        if (that instanceof DisplaySetting) {            return name.compareTo(that.toString()) == 0;        }        return false;    }    public String toString() {        return name;    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * An enum of possible display settings. These settings are used to control the\n+ * presence of various features in the String representations of options,\n+ * CommandLines and usage strings.  Usually a Set of DisplaySetting instances\n+ * will be passed to a method that will lookup the presence of the values.\n+ */\n+public class DisplaySetting {\n+\t\n+    private static final Set all = new HashSet();\n+\n+    /**\n+     * A Set guarenteed to contain all possible DisplaySetting values\n+     */\n+    public static final Set ALL = Collections.unmodifiableSet(all);\n+    \n+    /**\n+     * A Set guarenteed to contain no DisplaySetting values\n+     */\n+    public static final Set NONE = Collections.EMPTY_SET;\n+    \n+    /**\n+     * Indicates that aliases should be included\n+     */\n+    public static final DisplaySetting DISPLAY_ALIASES =\n+        new DisplaySetting(\"DISPLAY_ALIASES\");\n+    \n+    /**\n+     * Indicates that optionality should be included\n+     */\n+    public static final DisplaySetting DISPLAY_OPTIONAL =\n+        new DisplaySetting(\"DISPLAY_OPTIONAL\");\n+    \n+    /**\n+     * Indicates that property options should be included\n+     */\n+    public static final DisplaySetting DISPLAY_PROPERTY_OPTION =\n+        new DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n+    \n+    /**\n+     * Indicates that switches should be included enabled\n+     */\n+    public static final DisplaySetting DISPLAY_SWITCH_ENABLED =\n+        new DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n+    \n+    /**\n+     * Indicates that switches should be included disabled\n+     */\n+    public static final DisplaySetting DISPLAY_SWITCH_DISABLED =\n+        new DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n+    \n+    /**\n+     * Indicates that group names should be included\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_NAME =\n+        new DisplaySetting(\"DISPLAY_GROUP_NAME\");\n+    \n+    /**\n+     * Indicates that groups should be included expanded\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_EXPANDED =\n+        new DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n+    \n+    /**\n+     * Indicates that group arguments should be included\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\n+        new DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n+    \n+    /**\n+     * Indicates that group outer brackets should be included\n+     */\n+    public static final DisplaySetting DISPLAY_GROUP_OUTER =\n+        new DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n+    \n+    /**\n+     * Indicates that arguments should be included numbered\n+     */\n+    public static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\n+        new DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n+    \n+    /**\n+     * Indicates that arguments should be included bracketed\n+     */\n+    public static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\n+        new DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n+    \n+    /**\n+     * Indicates that arguments of Parents should be included\n+     */\n+    public static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\n+        new DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n+    \n+    /**\n+     * Indicates that children of Parents should be included\n+     */\n+    public static final DisplaySetting DISPLAY_PARENT_CHILDREN =\n+        new DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n+    \n+    /**\n+     * The name of the setting\n+     */\n+    private final String name;\n+    \n+    /**\n+     * The hashCode of the setting\n+     */\n+    private final int hashCode;\n+\n+    /**\n+     * Creates a new DisplaySetting with the specified name\n+     * @param name the name of the setting\n+     */\n+    private DisplaySetting(final String name) {\n+        this.name = name;\n+        this.hashCode = name.hashCode();\n+        all.add(this);\n+    }\n+\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+\n+    public boolean equals(final Object that) {\n+        if (that instanceof DisplaySetting) {\n+            return name.compareTo(that.toString()) == 0;\n+        }\n+        return false;\n+    }\n+\n+    public String toString() {\n+        return name;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/Group.java\n+++ b/src/java/org/apache/commons/cli2/Group.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Comparator;import java.util.Set;/** * An Option representing a choice or group of Options in the form \"-a|-b|-c\". */public interface Group extends Option {    /**     * Appends usage information to the specified StringBuffer     *     * @param buffer the buffer to append to     * @param helpSettings a set of display settings @see DisplaySetting     * @param comp a comparator used to sort the Options     * @param separator the String used to separate member Options     */    void appendUsage(        final StringBuffer buffer,        final Set helpSettings,        final Comparator comp,        final String separator);    /**     * Indicates whether group members must be present for the CommandLine to be     * valid.     *     * @see #getMinimum()     * @see #getMaximum()     * @return true iff the CommandLine will be invalid without at least one     *         member option     */    boolean isRequired();    /**     * Retrieves the minimum number of members required for a valid Group     *     * @return the minimum number of members     */    int getMinimum();    /**     * Retrieves the maximum number of members acceptable for a valid Group     *     * @return the maximum number of members     */    int getMaximum();}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+/**\n+ * An Option representing a choice or group of Options in the form \"-a|-b|-c\".\n+ */\n+public interface Group extends Option {\n+\n+    /**\n+     * Appends usage information to the specified StringBuffer\n+     * \n+     * @param buffer the buffer to append to\n+     * @param helpSettings a set of display settings @see DisplaySetting\n+     * @param comp a comparator used to sort the Options\n+     * @param separator the String used to separate member Options \n+     */\n+    void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp,\n+        final String separator);\n+\n+    /**\n+     * Indicates whether group members must be present for the CommandLine to be\n+     * valid.\n+     *\n+     * @see #getMinimum()\n+     * @see #getMaximum()\n+     * @return true iff the CommandLine will be invalid without at least one \n+     *         member option\n+     */\n+    boolean isRequired();\n+\n+    /**\n+     * Retrieves the minimum number of members required for a valid Group\n+     *\n+     * @return the minimum number of members\n+     */\n+    int getMinimum();\n+\n+    /**\n+     * Retrieves the maximum number of members acceptable for a valid Group\n+     *\n+     * @return the maximum number of members\n+     */\n+    int getMaximum();\n+}\n--- a/src/java/org/apache/commons/cli2/HelpLine.java\n+++ b/src/java/org/apache/commons/cli2/HelpLine.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Comparator;import java.util.Set;/** * Represents a line of help for a particular Option. */public interface HelpLine {    /**     * @return The description of the option     */    String getDescription();    /**     * @return The level of indentation for this line     */    int getIndent();    /**     * @return The Option that the help line relates to     */    Option getOption();    /**     * Builds a usage string for the option using the specified settings and     * comparator.     *     * @param helpSettings     *            the settings to apply     * @param comparator     *            a comparator to sort options when applicable     * @return the usage string     */    String usage(final Set helpSettings, final Comparator comparator);}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+/**\n+ * Represents a line of help for a particular Option.\n+ */\n+public interface HelpLine {\n+\n+    /**\n+     * @return The description of the option\n+     */\n+    String getDescription();\n+\n+    /**\n+     * @return The level of indentation for this line\n+     */\n+    int getIndent();\n+\n+    /**\n+     * @return The Option that the help line relates to\n+     */\n+    Option getOption();\n+\n+    /**\n+     * Builds a usage string for the option using the specified settings and\n+     * comparator.\n+     * \n+     * @param helpSettings\n+     *            the settings to apply\n+     * @param comparator\n+     *            a comparator to sort options when applicable\n+     * @return the usage string\n+     */\n+    String usage(final Set helpSettings, final Comparator comparator);\n+}\n--- a/src/java/org/apache/commons/cli2/Option.java\n+++ b/src/java/org/apache/commons/cli2/Option.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Comparator;import java.util.List;import java.util.ListIterator;import java.util.Set;/** * The super type of all options representing a particular element of the * command line interface. */public interface Option {    /**     * Processes String arguments into a CommandLine.     *     * The iterator will initially point at the first argument to be processed     * and at the end of the method should point to the first argument not     * processed. This method MUST process at least one argument from the     * ListIterator.     *     * @param commandLine     *            The CommandLine object to store results in     * @param args     *            The arguments to process     * @throws OptionException     *             if any problems occur     */    void process(        final WriteableCommandLine commandLine,        final ListIterator args)        throws OptionException;    /**     * Adds defaults to a CommandLine.     *     * Any defaults for this option are applied as well as the defaults for     * any contained options     *     * @param commandLine     *            The CommandLine object to store defaults in     */    void defaults(final WriteableCommandLine commandLine);    /**     * Indicates whether this Option will be able to process the particular     * argument.     *     * @param argument     *            The argument to be tested     * @return true if the argument can be processed by this Option     */    boolean canProcess(final WriteableCommandLine commandLine, final String argument);    /**     * Indicates whether this Option will be able to process the particular     * argument. The ListIterator must be restored to the initial state before     * returning the boolean.     *     * @see #canProcess(WriteableCommandLine,String)     * @param arguments     *            the ListIterator over String arguments     * @return true if the argument can be processed by this Option     */    boolean canProcess(final WriteableCommandLine commandLine, final ListIterator arguments);    /**     * Identifies the argument prefixes that should trigger this option. This     * is used to decide which of many Options should be tried when processing     * a given argument string.     *     * The returned Set must not be null.     *     * @return The set of triggers for this Option     */    Set getTriggers();    /**     * Identifies the argument prefixes that should be considered options. This     * is used to identify whether a given string looks like an option or an     * argument value. Typically an option would return the set [--,-] while     * switches might offer [-,+].     *     * The returned Set must not be null.     *     * @return The set of prefixes for this Option     */    Set getPrefixes();    /**     * Checks that the supplied CommandLine is valid with respect to this     * option.     *     * @param commandLine     *            The CommandLine to check.     * @throws OptionException     *             if the CommandLine is not valid.     */    void validate(final WriteableCommandLine commandLine)        throws OptionException;    /**     * Builds up a list of HelpLineImpl instances to be presented by HelpFormatter.     *     * @see HelpLine     * @see org.apache.commons.cli2.util.HelpFormatter     * @param depth     *            the initial indent depth     * @param helpSettings     *            the HelpSettings that should be applied     * @param comp     *            a comparator used to sort options when applicable.     * @return a List of HelpLineImpl objects     */    List helpLines(        final int depth,        final Set helpSettings,        final Comparator comp);    /**     * Appends usage information to the specified StringBuffer     *     * @param buffer the buffer to append to     * @param helpSettings a set of display settings @see DisplaySetting     * @param comp a comparator used to sort the Options     */    void appendUsage(        final StringBuffer buffer,        final Set helpSettings,        final Comparator comp);    /**     * The preferred name of an option is used for generating help and usage     * information.     *     * @return The preferred name of the option     */    String getPreferredName();    /**     * Returns a description of the option. This string is used to build help     * messages as in the HelpFormatter.     *     * @see org.apache.commons.cli2.util.HelpFormatter     * @return a description of the option.     */    String getDescription();    /**     * Returns the id of the option.  This can be used in a loop and switch     * construct:     *     * <code>     * for(Option o : cmd.getOptions()){     *     switch(o.getId()){     *         case POTENTIAL_OPTION:     *             ...     *     }     * }     * </code>     *     * The returned value is not guarenteed to be unique.     *     * @return the id of the option.     */    int getId();\t/**\t * Recursively searches for an option with the supplied trigger.\t *\t * @param trigger the trigger to search for.\t * @return the matching option or null.\t */\tOption findOption(final String trigger);    /**     * Indicates whether this option is required to be present.     * @return true iff the CommandLine will be invalid without this Option     */    boolean isRequired();}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+/**\n+ * The super type of all options representing a particular element of the\n+ * command line interface.\n+ */\n+public interface Option {\n+\n+    /**\n+     * Processes String arguments into a CommandLine.\n+     * \n+     * The iterator will initially point at the first argument to be processed\n+     * and at the end of the method should point to the first argument not\n+     * processed. This method MUST process at least one argument from the\n+     * ListIterator.\n+     * \n+     * @param commandLine\n+     *            The CommandLine object to store results in\n+     * @param args\n+     *            The arguments to process\n+     * @throws OptionException\n+     *             if any problems occur\n+     */\n+    void process(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator args)\n+        throws OptionException;\n+    \n+    /**\n+     * Adds defaults to a CommandLine.\n+     * \n+     * Any defaults for this option are applied as well as the defaults for \n+     * any contained options\n+     * \n+     * @param commandLine\n+     *            The CommandLine object to store defaults in\n+     */\n+    void defaults(final WriteableCommandLine commandLine);\n+\n+    /**\n+     * Indicates whether this Option will be able to process the particular\n+     * argument.\n+     * \n+     * @param argument\n+     *            The argument to be tested\n+     * @return true if the argument can be processed by this Option\n+     */\n+    boolean canProcess(final WriteableCommandLine commandLine, final String argument);\n+\n+    /**\n+     * Indicates whether this Option will be able to process the particular\n+     * argument. The ListIterator must be restored to the initial state before\n+     * returning the boolean.\n+     * \n+     * @see #canProcess(WriteableCommandLine,String)\n+     * @param arguments\n+     *            the ListIterator over String arguments\n+     * @return true if the argument can be processed by this Option\n+     */\n+    boolean canProcess(final WriteableCommandLine commandLine, final ListIterator arguments);\n+\n+    /**\n+     * Identifies the argument prefixes that should trigger this option. This\n+     * is used to decide which of many Options should be tried when processing\n+     * a given argument string.\n+     * \n+     * The returned Set must not be null.\n+     * \n+     * @return The set of triggers for this Option\n+     */\n+    Set getTriggers();\n+\n+    /**\n+     * Identifies the argument prefixes that should be considered options. This\n+     * is used to identify whether a given string looks like an option or an\n+     * argument value. Typically an option would return the set [--,-] while\n+     * switches might offer [-,+].\n+     * \n+     * The returned Set must not be null.\n+     * \n+     * @return The set of prefixes for this Option\n+     */\n+    Set getPrefixes();\n+\n+    /**\n+     * Checks that the supplied CommandLine is valid with respect to this\n+     * option.\n+     * \n+     * @param commandLine\n+     *            The CommandLine to check.\n+     * @throws OptionException\n+     *             if the CommandLine is not valid.\n+     */\n+    void validate(final WriteableCommandLine commandLine)\n+        throws OptionException;\n+\n+    /**\n+     * Builds up a list of HelpLineImpl instances to be presented by HelpFormatter.\n+     * \n+     * @see HelpLine\n+     * @see org.apache.commons.cli2.util.HelpFormatter\n+     * @param depth\n+     *            the initial indent depth\n+     * @param helpSettings\n+     *            the HelpSettings that should be applied\n+     * @param comp\n+     *            a comparator used to sort options when applicable.\n+     * @return a List of HelpLineImpl objects\n+     */\n+    List helpLines(\n+        final int depth,\n+        final Set helpSettings,\n+        final Comparator comp);\n+\n+    /**\n+     * Appends usage information to the specified StringBuffer\n+     * \n+     * @param buffer the buffer to append to\n+     * @param helpSettings a set of display settings @see DisplaySetting\n+     * @param comp a comparator used to sort the Options\n+     */\n+    void appendUsage(\n+        final StringBuffer buffer,\n+        final Set helpSettings,\n+        final Comparator comp);\n+\n+    /**\n+     * The preferred name of an option is used for generating help and usage\n+     * information.\n+     * \n+     * @return The preferred name of the option\n+     */\n+    String getPreferredName();\n+\n+    /**\n+     * Returns a description of the option. This string is used to build help\n+     * messages as in the HelpFormatter.\n+     * \n+     * @see org.apache.commons.cli2.util.HelpFormatter\n+     * @return a description of the option.\n+     */\n+    String getDescription();\n+\n+    /**\n+     * Returns the id of the option.  This can be used in a loop and switch \n+     * construct:\n+     * \n+     * <code>\n+     * for(Option o : cmd.getOptions()){\n+     *     switch(o.getId()){\n+     *         case POTENTIAL_OPTION:\n+     *             ...\n+     *     }\n+     * }\n+     * </code> \n+     * \n+     * The returned value is not guarenteed to be unique.\n+     * \n+     * @return the id of the option.\n+     */\n+    int getId();\n+\n+\t/**\n+\t * Recursively searches for an option with the supplied trigger.\n+\t *\n+\t * @param trigger the trigger to search for.\n+\t * @return the matching option or null.\n+\t */\n+\tOption findOption(final String trigger);\n+\n+    /**\n+     * Indicates whether this option is required to be present.\n+     * @return true iff the CommandLine will be invalid without this Option\n+     */\n+    boolean isRequired();\n+}\n--- a/src/java/org/apache/commons/cli2/OptionException.java\n+++ b/src/java/org/apache/commons/cli2/OptionException.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Collections;import java.util.Set;import org.apache.commons.cli2.resource.ResourceHelper;/** * A problem found while dealing with command line options. */public class OptionException    extends Exception {    /**     * The settings used when displaying the related Option.     *     * @see DisplaySetting     */    public static final Set HELP_SETTINGS =        Collections.unmodifiableSet(Collections.singleton(DisplaySetting.DISPLAY_PROPERTY_OPTION));    /** resource helper instance */    private static final ResourceHelper helper = ResourceHelper.getResourceHelper();    /** The Option the exception relates to */    private final Option option;    /** The message explaining the Exception */    private final String message;    /**     * Creates a new OptionException.     *     * @param option     *            The Option the exception relates to     */    public OptionException(final Option option) {        this(option, null, null);    }    /**     * Creates a new OptionException.     * @param option the Option the exception relates to     * @param messageKey the id of the message to display     */    public OptionException(final Option option,                           final String messageKey) {        this(option, messageKey, null);    }    /**     * Creates a new OptionException.     * @param option the Option the exception relates to     * @param messageKey the id of the message to display     * @param value a value to display with the message     */    public OptionException(final Option option,                           final String messageKey,                           final String value) {        this.option = option;        if (messageKey != null) {            final StringBuffer buffer = new StringBuffer();            if (value != null) {                buffer.append(helper.getMessage(messageKey, value));            } else {                buffer.append(helper.getMessage(messageKey));            }            buffer.append(\" \");            option.appendUsage(buffer, HELP_SETTINGS, null);            message = buffer.toString();        } else {            message = \"\";        }    }    /**     * Gets the Option the exception relates to     *     * @return The related Option     */    public Option getOption() {        return option;    }    public String getMessage() {        return message;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * A problem found while dealing with command line options.\n+ */\n+public class OptionException\n+    extends Exception {\n+    /**\n+     * The settings used when displaying the related Option.\n+     *\n+     * @see DisplaySetting\n+     */\n+    public static final Set HELP_SETTINGS =\n+        Collections.unmodifiableSet(Collections.singleton(DisplaySetting.DISPLAY_PROPERTY_OPTION));\n+\n+    /** resource helper instance */\n+    private static final ResourceHelper helper = ResourceHelper.getResourceHelper();\n+\n+    /** The Option the exception relates to */\n+    private final Option option;\n+\n+    /** The message explaining the Exception */\n+    private final String message;\n+\n+    /**\n+     * Creates a new OptionException.\n+     *\n+     * @param option\n+     *            The Option the exception relates to\n+     */\n+    public OptionException(final Option option) {\n+        this(option, null, null);\n+    }\n+\n+    /**\n+     * Creates a new OptionException.\n+     * @param option the Option the exception relates to\n+     * @param messageKey the id of the message to display\n+     */\n+    public OptionException(final Option option,\n+                           final String messageKey) {\n+        this(option, messageKey, null);\n+    }\n+\n+    /**\n+     * Creates a new OptionException.\n+     * @param option the Option the exception relates to\n+     * @param messageKey the id of the message to display\n+     * @param value a value to display with the message\n+     */\n+    public OptionException(final Option option,\n+                           final String messageKey,\n+                           final String value) {\n+        this.option = option;\n+\n+        if (messageKey != null) {\n+            final StringBuffer buffer = new StringBuffer();\n+\n+            if (value != null) {\n+                buffer.append(helper.getMessage(messageKey, value));\n+            } else {\n+                buffer.append(helper.getMessage(messageKey));\n+            }\n+\n+            buffer.append(\" \");\n+\n+            option.appendUsage(buffer, HELP_SETTINGS, null);\n+            message = buffer.toString();\n+        } else {\n+            message = \"\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the Option the exception relates to\n+     *\n+     * @return The related Option\n+     */\n+    public Option getOption() {\n+        return option;\n+    }\n+\n+    public String getMessage() {\n+        return message;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/Parent.java\n+++ b/src/java/org/apache/commons/cli2/Parent.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.ListIterator;/** * An Option that can have an argument and/or group of child Options in the form * \"-f &lt;arg&gt; [-a|-b|-c]\". */public interface Parent extends Option {    /**     * Processes the parent part of the Option.  The combination of parent,     * argument and children is handled by the process method.     * @see Option#process(WriteableCommandLine, ListIterator)     *     * @param commandLine the CommandLine to write results to     * @param args a ListIterator over argument strings positioned at the next     *             argument to process     * @throws OptionException if an error occurs while processing     */    void processParent(        final WriteableCommandLine commandLine,        final ListIterator args)        throws OptionException;}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.ListIterator;\n+\n+/**\n+ * An Option that can have an argument and/or group of child Options in the form \n+ * \"-f &lt;arg&gt; [-a|-b|-c]\".\n+ */\n+public interface Parent extends Option {\n+\n+    /**\n+     * Processes the parent part of the Option.  The combination of parent,\n+     * argument and children is handled by the process method.\n+     * @see Option#process(WriteableCommandLine, ListIterator)\n+     * \n+     * @param commandLine the CommandLine to write results to\n+     * @param args a ListIterator over argument strings positioned at the next\n+     *             argument to process\n+     * @throws OptionException if an error occurs while processing\n+     */\n+    void processParent(\n+        final WriteableCommandLine commandLine,\n+        final ListIterator args)\n+        throws OptionException;\n+}\n--- a/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n+++ b/src/java/org/apache/commons/cli2/WriteableCommandLine.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.List;/** * A CommandLine that detected values and options can be written to. */public interface WriteableCommandLine extends CommandLine {    /**     * Adds an Option to the CommandLine     * @param option the Option to add     */    void addOption(final Option option);    /**     * Adds a value to an Option in the CommandLine.     * @param option the Option to add to     * @param value the value to add     */    void addValue(final Option option, final Object value);    /**     * Sets the default values for an Option in the CommandLine     * @param option the Option to add to     * @param defaultValues the defaults for the option     */    void setDefaultValues(final Option option, final List defaultValues);    /**     * Adds a switch value to an Option in the CommandLine.     * @param option the Option to add to     * @param value the switch value to add     * @throws IllegalStateException if the switch has already been added     */    void addSwitch(final Option option, final boolean value) throws IllegalStateException;    /**     * Sets the default state for a Switch in the CommandLine.     * @param option the Option to add to     * @param defaultSwitch the defaults state for ths switch     */    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);    /**     * Adds a property value to a name in the CommandLine.     * Replaces any existing value for the property.     *     * @param property the name of the property     * @param value the value of the property     */    void addProperty(final String property, final String value);    /**     * Detects whether the argument looks like an Option trigger     * @param argument the argument to test     * @return true if the argument looks like an Option trigger     */    boolean looksLikeOption(final String argument);}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.List;\n+\n+/**\n+ * A CommandLine that detected values and options can be written to.\n+ */\n+public interface WriteableCommandLine extends CommandLine {\n+    \n+    /**\n+     * Adds an Option to the CommandLine\n+     * @param option the Option to add\n+     */\n+    void addOption(final Option option);\n+    \n+    /**\n+     * Adds a value to an Option in the CommandLine.\n+     * @param option the Option to add to\n+     * @param value the value to add\n+     */\n+    void addValue(final Option option, final Object value);\n+\n+    /**\n+     * Sets the default values for an Option in the CommandLine\n+     * @param option the Option to add to\n+     * @param defaultValues the defaults for the option\n+     */\n+    void setDefaultValues(final Option option, final List defaultValues);\n+    \n+    /**\n+     * Adds a switch value to an Option in the CommandLine.\n+     * @param option the Option to add to\n+     * @param value the switch value to add\n+     * @throws IllegalStateException if the switch has already been added\n+     */\n+    void addSwitch(final Option option, final boolean value) throws IllegalStateException;\n+    \n+    /**\n+     * Sets the default state for a Switch in the CommandLine.\n+     * @param option the Option to add to\n+     * @param defaultSwitch the defaults state for ths switch\n+     */\n+    void setDefaultSwitch(final Option option, final Boolean defaultSwitch);\n+    \n+    /**\n+     * Adds a property value to a name in the CommandLine.\n+     * Replaces any existing value for the property.\n+     * \n+     * @param property the name of the property\n+     * @param value the value of the property\n+     */\n+    void addProperty(final String property, final String value);\n+    \n+    /**\n+     * Detects whether the argument looks like an Option trigger \n+     * @param argument the argument to test\n+     * @return true if the argument looks like an Option trigger\n+     */\n+    boolean looksLikeOption(final String argument);\n+}\n--- a/src/java/org/apache/commons/cli2/builder/ArgumentBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/ArgumentBuilder.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.builder;import java.util.ArrayList;import java.util.List;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.option.ArgumentImpl;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;import org.apache.commons.cli2.validation.Validator;/** * Builds Argument instances. */public class ArgumentBuilder {\t/** i18n */\tprivate final static ResourceHelper resources = ResourceHelper.getResourceHelper();    /** name of the argument. Used for display and lookups in CommandLine */    private String name;    /** description of the argument. Used in the automated online help */    private String description;    /** minimum number of values required */    private int minimum;    /** maximum number of values permitted */    private int maximum;    /** character used to separate the values from the option */    private char initialSeparator;    /** character used to separate the values from each other */    private char subsequentSeparator;    /** object that should be used to ensure the values are valid */    private Validator validator;    /** used to identify the consume remaining option, typically \"--\" */    private String consumeRemaining;    /** default values for argument */    private List defaultValues;    /** id of the argument */    private int id;    /**     * Creates a new ArgumentBuilder instance     */    public ArgumentBuilder() {        reset();    }    /**     * Creates a new Argument instance using the options specified in this     * ArgumentBuilder.     *     * @return A new Argument instance using the options specified in this     * ArgumentBuilder.     */    public final Argument create() {        final Argument argument =            new ArgumentImpl(                name,                description,                minimum,                maximum,                initialSeparator,                subsequentSeparator,                validator,                consumeRemaining,                defaultValues,                id);        reset();        return argument;    }    /**     * Resets the ArgumentBuilder to the defaults for a new Argument. The     * method is called automatically at the end of a create() call.     */    public final ArgumentBuilder reset() {        name = \"arg\";        description = null;        minimum = 0;        maximum = Integer.MAX_VALUE;        initialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;        subsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;        validator = null;        consumeRemaining = \"--\";        defaultValues = null;        id = 0;        return this;    }    /**     * Sets the name of the argument. The name is used when displaying usage     * information and to allow lookups in the CommandLine object.     *     * @see org.apache.commons.cli2.CommandLine#getValue(String)     *     * @param newName the name of the argument     * @return this ArgumentBuilder     */    public final ArgumentBuilder withName(final String newName) {    \tif (newName == null) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));    \t}    \tif (\"\".equals(newName)) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));    \t}        this.name = newName;        return this;    }    /**     * Sets the description of the argument.     *     * The description is used when displaying online help.     *     * @param newDescription a description of the argument     * @return this ArgumentBuilder     */    public final ArgumentBuilder withDescription(final String newDescription) {        this.description = newDescription;        return this;    }    /**     * Sets the minimum number of values needed for the argument to be valid.     *     * @param newMinimum the number of values needed     * @return this ArgumentBuilder     */    public final ArgumentBuilder withMinimum(final int newMinimum) {    \tif (newMinimum < 0) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM));    \t}        this.minimum = newMinimum;        return this;    }    /**     * Sets the maximum number of values allowed for the argument to be valid.     *     * @param newMaximum the number of values allowed     * @return this ArgumentBuilder     */    public final ArgumentBuilder withMaximum(final int newMaximum) {    \tif (newMaximum < 0) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM));    \t}        this.maximum = newMaximum;        return this;    }    /**     * Sets the character used to separate the values from the option. When an     * argument is of the form -libs:dir1,dir2,dir3 the initialSeparator would     * be ':'.     *     * @param newInitialSeparator the character used to separate the values     * from the option     * @return this ArgumentBuilder     */    public final ArgumentBuilder withInitialSeparator(        final char newInitialSeparator) {        this.initialSeparator = newInitialSeparator;        return this;    }    /**     * Sets the character used to separate the values from each other. When an     * argument is of the form -libs:dir1,dir2,dir3 the subsequentSeparator     * would be ','.     *     * @param newSubsequentSeparator the character used to separate the values     * from each other     * @return this ArgumentBuilder     */    public final ArgumentBuilder withSubsequentSeparator(        final char newSubsequentSeparator) {        this.subsequentSeparator = newSubsequentSeparator;        return this;    }    /**     * Sets the validator instance used to perform validation on the Argument     * values.     *     * @param newValidator a Validator instance     * @return this ArgumentBuilder     */    public final ArgumentBuilder withValidator(final Validator newValidator) {    \tif (newValidator == null) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_VALIDATOR));    \t}        this.validator = newValidator;        return this;    }    /**     * Sets the \"consume remaining\" option, defaults to \"--\". Use this if you     * want to allow values that might be confused with option strings.     *     * @param newConsumeRemaining the string to use for the consume     * remaining option     * @return this ArgumentBuilder     */    public final ArgumentBuilder withConsumeRemaining(final String newConsumeRemaining) {    \tif (newConsumeRemaining == null) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_CONSUME_REMAINING));    \t}    \tif ( \"\".equals(newConsumeRemaining)) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_CONSUME_REMAINING));    \t}        this.consumeRemaining = newConsumeRemaining;        return this;    }    /**     * Sets the default value.     *     * @param defaultValue the default value for the Argument     * @return this ArgumentBuilder     */    public final ArgumentBuilder withDefault(final Object defaultValue) {    \tif (defaultValue == null) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULT));    \t}        if (this.defaultValues == null) {            this.defaultValues = new ArrayList(1);        }        this.defaultValues.add(defaultValue);        return this;    }    /**     * Sets the default values.     *     * @param newDefaultValues the default values for the Argument     * @return this ArgumentBuilder     */    public final ArgumentBuilder withDefaults(final List newDefaultValues) {    \tif (newDefaultValues == null) {    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULTS));    \t}        this.defaultValues = newDefaultValues;        return this;    }    /**     * Sets the id     *     * @param newId the id of the Argument     * @return this ArgumentBuilder     */    public final ArgumentBuilder withId(final int newId) {        this.id = newId;        return this;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.option.ArgumentImpl;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * Builds Argument instances.\n+ */\n+public class ArgumentBuilder {\n+\n+\t/** i18n */\n+\tprivate final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\t\n+    /** name of the argument. Used for display and lookups in CommandLine */\n+    private String name;\n+\n+    /** description of the argument. Used in the automated online help */\n+    private String description;\n+\n+    /** minimum number of values required */\n+    private int minimum;\n+\n+    /** maximum number of values permitted */\n+    private int maximum;\n+\n+    /** character used to separate the values from the option */\n+    private char initialSeparator;\n+\n+    /** character used to separate the values from each other */\n+    private char subsequentSeparator;\n+\n+    /** object that should be used to ensure the values are valid */\n+    private Validator validator;\n+\n+    /** used to identify the consume remaining option, typically \"--\" */\n+    private String consumeRemaining;\n+\n+    /** default values for argument */\n+    private List defaultValues;\n+\n+    /** id of the argument */\n+    private int id;\n+\n+    /**\n+     * Creates a new ArgumentBuilder instance\n+     */\n+    public ArgumentBuilder() {\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a new Argument instance using the options specified in this\n+     * ArgumentBuilder.\n+     * \n+     * @return A new Argument instance using the options specified in this\n+     * ArgumentBuilder.\n+     */\n+    public final Argument create() {\n+        final Argument argument =\n+            new ArgumentImpl(\n+                name,\n+                description,\n+                minimum,\n+                maximum,\n+                initialSeparator,\n+                subsequentSeparator,\n+                validator,\n+                consumeRemaining,\n+                defaultValues,\n+                id);\n+\n+        reset();\n+\n+        return argument;\n+    }\n+\n+    /**\n+     * Resets the ArgumentBuilder to the defaults for a new Argument. The\n+     * method is called automatically at the end of a create() call.\n+     */\n+    public final ArgumentBuilder reset() {\n+        name = \"arg\";\n+        description = null;\n+        minimum = 0;\n+        maximum = Integer.MAX_VALUE;\n+        initialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\n+        subsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\n+        validator = null;\n+        consumeRemaining = \"--\";\n+        defaultValues = null;\n+        id = 0;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the name of the argument. The name is used when displaying usage\n+     * information and to allow lookups in the CommandLine object.\n+     * \n+     * @see org.apache.commons.cli2.CommandLine#getValue(String)\n+     * \n+     * @param newName the name of the argument\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withName(final String newName) {\n+    \tif (newName == null) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n+    \t}\n+    \tif (\"\".equals(newName)) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n+    \t}\n+        this.name = newName;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the description of the argument.\n+     * \n+     * The description is used when displaying online help.\n+     * \n+     * @param newDescription a description of the argument\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the minimum number of values needed for the argument to be valid.\n+     * \n+     * @param newMinimum the number of values needed\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withMinimum(final int newMinimum) {\n+    \tif (newMinimum < 0) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM));\n+    \t}\n+        this.minimum = newMinimum;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the maximum number of values allowed for the argument to be valid.\n+     * \n+     * @param newMaximum the number of values allowed\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withMaximum(final int newMaximum) {\n+    \tif (newMaximum < 0) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM));\n+    \t}\n+        this.maximum = newMaximum;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the character used to separate the values from the option. When an\n+     * argument is of the form -libs:dir1,dir2,dir3 the initialSeparator would\n+     * be ':'.\n+     * \n+     * @param newInitialSeparator the character used to separate the values \n+     * from the option\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withInitialSeparator(\n+        final char newInitialSeparator) {\n+\n+        this.initialSeparator = newInitialSeparator;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the character used to separate the values from each other. When an\n+     * argument is of the form -libs:dir1,dir2,dir3 the subsequentSeparator\n+     * would be ','.\n+     * \n+     * @param newSubsequentSeparator the character used to separate the values \n+     * from each other\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withSubsequentSeparator(\n+        final char newSubsequentSeparator) {\n+\n+        this.subsequentSeparator = newSubsequentSeparator;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the validator instance used to perform validation on the Argument\n+     * values.\n+     * \n+     * @param newValidator a Validator instance\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withValidator(final Validator newValidator) {\n+    \tif (newValidator == null) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_VALIDATOR));\n+    \t}\n+        this.validator = newValidator;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the \"consume remaining\" option, defaults to \"--\". Use this if you\n+     * want to allow values that might be confused with option strings.\n+     * \n+     * @param newConsumeRemaining the string to use for the consume \n+     * remaining option\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withConsumeRemaining(final String newConsumeRemaining) {\n+    \tif (newConsumeRemaining == null) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_CONSUME_REMAINING));\n+    \t} \n+    \tif ( \"\".equals(newConsumeRemaining)) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_CONSUME_REMAINING));\n+    \t}\n+        this.consumeRemaining = newConsumeRemaining;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default value.\n+     * \n+     * @param defaultValue the default value for the Argument\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withDefault(final Object defaultValue) {\n+    \tif (defaultValue == null) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULT));\n+    \t}\n+    \t\n+        if (this.defaultValues == null) {\n+            this.defaultValues = new ArrayList(1);\n+        }\n+        this.defaultValues.add(defaultValue);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default values.\n+     * \n+     * @param newDefaultValues the default values for the Argument\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withDefaults(final List newDefaultValues) {\n+    \tif (newDefaultValues == null) {\n+    \t\tthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULTS));\n+    \t}\n+        this.defaultValues = newDefaultValues;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the id\n+     * \n+     * @param newId the id of the Argument\n+     * @return this ArgumentBuilder\n+     */\n+    public final ArgumentBuilder withId(final int newId) {\n+        this.id = newId;\n+        return this;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/builder/CommandBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/CommandBuilder.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.builder;import java.util.HashSet;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.option.Command;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * Builds Command instances */public class CommandBuilder {    /** the preferred name of the command */    private String preferredName;    /** the description of the command */    private String description;    /** the aliases of the command */    private Set aliases;    /** whether the command is required or not */    private boolean required;    /** the argument of the command */    private Argument argument;    /** the children of the command */    private Group children;    /** the id of the command */    private int id;    /**     * Creates a new <code>CommandBuilder</code> instance.     */    public CommandBuilder() {        reset();    }    /**     * Creates a new <code>Command</code> instance using the properties of the     * <code>CommandBuilder</code>.     *     * @return the new Command instance     */    public Command create() {        // check we have a valid name        if (preferredName == null) {            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));        }        // build the command        final Command option =            new Command(preferredName, description, aliases, required, argument, children, id);        // reset the builder        reset();        return option;    }    /**     * Resets the CommandBuilder to the defaults for a new Command.     *     * This method is called automatically at the end of the     * {@link #create() create} method.     */    public CommandBuilder reset() {        preferredName = null;        description = null;        aliases = new HashSet();        required = false;        argument = null;        children = null;        id = 0;        return this;    }    /**     * Specifies the name for the next <code>Command</code>     * that is created.  The first name is used as the preferred     * display name for the <code>Command</code> and then     * later names are used as aliases.     *     * @param name the name for the next <code>Command</code>     * that is created.     * @return this <code>CommandBuilder</code>.     */    public CommandBuilder withName(final String name) {        if (preferredName == null) {            preferredName = name;        } else {            aliases.add(name);        }        return this;    }    /**     * Specifies the description for the next <code>Command</code>     * that is created.  This description is used to produce     * help documentation for the <code>Command</code>.     *     * @param newDescription the description for the next     * <code>Command</code> that is created.     * @return this <code>CommandBuilder</code>.     */    public CommandBuilder withDescription(final String newDescription) {        this.description = newDescription;        return this;    }    /**     * Specifies whether the next <code>Command</code> created is     * required or not.     * @param newRequired whether the next <code>Command</code> created is     * required or not.     * @return this <code>CommandBuilder</code>.     */    public CommandBuilder withRequired(final boolean newRequired) {        this.required = newRequired;        return this;    }    /**     * Specifies the children for the next <code>Command</code>     * that is created.     *     * @param newChildren the child options for the next <code>Command</code>     * that is created.     * @return this <code>CommandBuilder</code>.     */    public CommandBuilder withChildren(final Group newChildren) {        this.children = newChildren;        return this;    }    /**     * Specifies the argument for the next <code>Command</code>     * that is created.     *     * @param newArgument the argument for the next <code>Command</code>     * that is created.     * @return this <code>CommandBuilder</code>.     */    public CommandBuilder withArgument(final Argument newArgument) {        this.argument = newArgument;        return this;    }    /**     * Specifies the id for the next <code>Command</code> that is created.     *     * @param newId the id for the next <code>Command</code> that is created.     * @return this <code>CommandBuilder</code>.     */    public final CommandBuilder withId(final int newId) {        this.id = newId;        return this;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.Command;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * Builds Command instances\n+ */\n+public class CommandBuilder {\n+    /** the preferred name of the command */\n+    private String preferredName;\n+\n+    /** the description of the command */\n+    private String description;\n+\n+    /** the aliases of the command */\n+    private Set aliases;\n+\n+    /** whether the command is required or not */\n+    private boolean required;\n+\n+    /** the argument of the command */\n+    private Argument argument;\n+\n+    /** the children of the command */\n+    private Group children;\n+\n+    /** the id of the command */\n+    private int id;\n+\n+    /**\n+     * Creates a new <code>CommandBuilder</code> instance.\n+     */\n+    public CommandBuilder() {\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a new <code>Command</code> instance using the properties of the\n+     * <code>CommandBuilder</code>.\n+     *\n+     * @return the new Command instance\n+     */\n+    public Command create() {\n+        // check we have a valid name\n+        if (preferredName == null) {\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n+        }\n+\n+        // build the command\n+        final Command option =\n+            new Command(preferredName, description, aliases, required, argument, children, id);\n+\n+        // reset the builder\n+        reset();\n+\n+        return option;\n+    }\n+\n+    /**\n+     * Resets the CommandBuilder to the defaults for a new Command.\n+     *\n+     * This method is called automatically at the end of the\n+     * {@link #create() create} method.\n+     */\n+    public CommandBuilder reset() {\n+        preferredName = null;\n+        description = null;\n+        aliases = new HashSet();\n+        required = false;\n+        argument = null;\n+        children = null;\n+        id = 0;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies the name for the next <code>Command</code>\n+     * that is created.  The first name is used as the preferred\n+     * display name for the <code>Command</code> and then\n+     * later names are used as aliases.\n+     *\n+     * @param name the name for the next <code>Command</code>\n+     * that is created.\n+     * @return this <code>CommandBuilder</code>.\n+     */\n+    public CommandBuilder withName(final String name) {\n+        if (preferredName == null) {\n+            preferredName = name;\n+        } else {\n+            aliases.add(name);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies the description for the next <code>Command</code>\n+     * that is created.  This description is used to produce\n+     * help documentation for the <code>Command</code>.\n+     *\n+     * @param newDescription the description for the next\n+     * <code>Command</code> that is created.\n+     * @return this <code>CommandBuilder</code>.\n+     */\n+    public CommandBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies whether the next <code>Command</code> created is\n+     * required or not.\n+     * @param newRequired whether the next <code>Command</code> created is\n+     * required or not.\n+     * @return this <code>CommandBuilder</code>.\n+     */\n+    public CommandBuilder withRequired(final boolean newRequired) {\n+        this.required = newRequired;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies the children for the next <code>Command</code>\n+     * that is created.\n+     *\n+     * @param newChildren the child options for the next <code>Command</code>\n+     * that is created.\n+     * @return this <code>CommandBuilder</code>.\n+     */\n+    public CommandBuilder withChildren(final Group newChildren) {\n+        this.children = newChildren;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies the argument for the next <code>Command</code>\n+     * that is created.\n+     *\n+     * @param newArgument the argument for the next <code>Command</code>\n+     * that is created.\n+     * @return this <code>CommandBuilder</code>.\n+     */\n+    public CommandBuilder withArgument(final Argument newArgument) {\n+        this.argument = newArgument;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies the id for the next <code>Command</code> that is created.\n+     *\n+     * @param newId the id for the next <code>Command</code> that is created.\n+     * @return this <code>CommandBuilder</code>.\n+     */\n+    public final CommandBuilder withId(final int newId) {\n+        this.id = newId;\n+\n+        return this;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/builder/DefaultOptionBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/DefaultOptionBuilder.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.builder;import java.util.HashSet;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.option.DefaultOption;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * Builds DefaultOption instances. */public class DefaultOptionBuilder {    private final String shortPrefix;    private final String longPrefix;    private final boolean burstEnabled;    private String preferredName;    private Set aliases;    private Set burstAliases;    private boolean required;    private String description;    private Argument argument;    private Group children;    private int id;    /**     * Creates a new DefaultOptionBuilder using defaults     * @see DefaultOption#DEFAULT_SHORT_PREFIX     * @see DefaultOption#DEFAULT_LONG_PREFIX     * @see DefaultOption#DEFAULT_BURST_ENABLED     */    public DefaultOptionBuilder() {        this(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,             DefaultOption.DEFAULT_BURST_ENABLED);    }    /**     * Creates a new DefaultOptionBuilder     * @param shortPrefix the prefix to use for short options     * @param longPrefix the prefix to use for long options     * @param burstEnabled whether to allow gnu style bursting     * @throws IllegalArgumentException if either prefix is less than on     *                                  character long     */    public DefaultOptionBuilder(final String shortPrefix,                                final String longPrefix,                                final boolean burstEnabled)        throws IllegalArgumentException {        if ((shortPrefix == null) || (shortPrefix.length() == 0)) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));        }        if ((longPrefix == null) || (longPrefix.length() == 0)) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));        }        this.shortPrefix = shortPrefix;        this.longPrefix = longPrefix;        this.burstEnabled = burstEnabled;        reset();    }    /**     * Creates a DefaultOption instance     * @return the new instance     * @throws IllegalStateException if no names have been supplied     */    public DefaultOption create()        throws IllegalStateException {        if (preferredName == null) {            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));        }        final DefaultOption option =            new DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,                              aliases, burstAliases, required, argument, children, id);        reset();        return option;    }    /**     * Resets the builder     */    public DefaultOptionBuilder reset() {        preferredName = null;        description = null;        aliases = new HashSet();        burstAliases = new HashSet();        required = false;        argument = null;        children = null;        id = 0;        return this;    }    /**     * Use this short option name. The first name is used as the preferred     * display name for the Command and then later names are used as aliases.     *     * @param shortName the name to use     * @return this builder     */    public DefaultOptionBuilder withShortName(final String shortName) {        final String name = shortPrefix + shortName;        if (preferredName == null) {            preferredName = name;        } else {            aliases.add(name);        }        if (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {            burstAliases.add(name);        }        return this;    }    /**     * Use this long option name.  The first name is used as the preferred     * display name for the Command and then later names are used as aliases.     *     * @param longName the name to use     * @return this builder     */    public DefaultOptionBuilder withLongName(final String longName) {        final String name = longPrefix + longName;        if (preferredName == null) {            preferredName = name;        } else {            aliases.add(name);        }        return this;    }    /**     * Use this option description     * @param newDescription the description to use     * @return this builder     */    public DefaultOptionBuilder withDescription(final String newDescription) {        this.description = newDescription;        return this;    }    /**     * Use this optionality     * @param newRequired true iff the Option is required     * @return this builder     */    public DefaultOptionBuilder withRequired(final boolean newRequired) {        this.required = newRequired;        return this;    }    /**     * Use this child Group     * @param newChildren the child Group to use     * @return this builder     */    public DefaultOptionBuilder withChildren(final Group newChildren) {        this.children = newChildren;        return this;    }    /**     * Use this Argument     * @param newArgument the argument to use     * @return this builder     */    public DefaultOptionBuilder withArgument(final Argument newArgument) {        this.argument = newArgument;        return this;    }    /**     * Sets the id     *     * @param newId     *            the id of the DefaultOption     * @return this DefaultOptionBuilder     */    public final DefaultOptionBuilder withId(final int newId) {        this.id = newId;        return this;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * Builds DefaultOption instances.\n+ */\n+public class DefaultOptionBuilder {\n+    private final String shortPrefix;\n+    private final String longPrefix;\n+    private final boolean burstEnabled;\n+    private String preferredName;\n+    private Set aliases;\n+    private Set burstAliases;\n+    private boolean required;\n+    private String description;\n+    private Argument argument;\n+    private Group children;\n+    private int id;\n+\n+    /**\n+     * Creates a new DefaultOptionBuilder using defaults\n+     * @see DefaultOption#DEFAULT_SHORT_PREFIX\n+     * @see DefaultOption#DEFAULT_LONG_PREFIX\n+     * @see DefaultOption#DEFAULT_BURST_ENABLED\n+     */\n+    public DefaultOptionBuilder() {\n+        this(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\n+             DefaultOption.DEFAULT_BURST_ENABLED);\n+    }\n+\n+    /**\n+     * Creates a new DefaultOptionBuilder\n+     * @param shortPrefix the prefix to use for short options\n+     * @param longPrefix the prefix to use for long options\n+     * @param burstEnabled whether to allow gnu style bursting\n+     * @throws IllegalArgumentException if either prefix is less than on\n+     *                                  character long\n+     */\n+    public DefaultOptionBuilder(final String shortPrefix,\n+                                final String longPrefix,\n+                                final boolean burstEnabled)\n+        throws IllegalArgumentException {\n+        if ((shortPrefix == null) || (shortPrefix.length() == 0)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n+        }\n+\n+        if ((longPrefix == null) || (longPrefix.length() == 0)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n+        }\n+\n+        this.shortPrefix = shortPrefix;\n+        this.longPrefix = longPrefix;\n+        this.burstEnabled = burstEnabled;\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a DefaultOption instance\n+     * @return the new instance\n+     * @throws IllegalStateException if no names have been supplied\n+     */\n+    public DefaultOption create()\n+        throws IllegalStateException {\n+        if (preferredName == null) {\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n+        }\n+\n+        final DefaultOption option =\n+            new DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\n+                              aliases, burstAliases, required, argument, children, id);\n+\n+        reset();\n+\n+        return option;\n+    }\n+\n+    /**\n+     * Resets the builder\n+     */\n+    public DefaultOptionBuilder reset() {\n+        preferredName = null;\n+        description = null;\n+        aliases = new HashSet();\n+        burstAliases = new HashSet();\n+        required = false;\n+        argument = null;\n+        children = null;\n+        id = 0;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this short option name. The first name is used as the preferred\n+     * display name for the Command and then later names are used as aliases.\n+     *\n+     * @param shortName the name to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withShortName(final String shortName) {\n+        final String name = shortPrefix + shortName;\n+\n+        if (preferredName == null) {\n+            preferredName = name;\n+        } else {\n+            aliases.add(name);\n+        }\n+\n+        if (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\n+            burstAliases.add(name);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this long option name.  The first name is used as the preferred\n+     * display name for the Command and then later names are used as aliases.\n+     *\n+     * @param longName the name to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withLongName(final String longName) {\n+        final String name = longPrefix + longName;\n+\n+        if (preferredName == null) {\n+            preferredName = name;\n+        } else {\n+            aliases.add(name);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option description\n+     * @param newDescription the description to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this optionality\n+     * @param newRequired true iff the Option is required\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withRequired(final boolean newRequired) {\n+        this.required = newRequired;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this child Group\n+     * @param newChildren the child Group to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withChildren(final Group newChildren) {\n+        this.children = newChildren;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this Argument\n+     * @param newArgument the argument to use\n+     * @return this builder\n+     */\n+    public DefaultOptionBuilder withArgument(final Argument newArgument) {\n+        this.argument = newArgument;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the id\n+     *\n+     * @param newId\n+     *            the id of the DefaultOption\n+     * @return this DefaultOptionBuilder\n+     */\n+    public final DefaultOptionBuilder withId(final int newId) {\n+        this.id = newId;\n+\n+        return this;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/builder/GroupBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/GroupBuilder.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.builder;import java.util.ArrayList;import java.util.List;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.option.GroupImpl;/** * Builds Group instances */public class GroupBuilder {    private String name;    private String description;    private List options;    private int minimum;    private int maximum;    /**     * Creates a new GroupBuilder     */    public GroupBuilder() {        reset();    }    /**     * Creates a new Group instance     * @return the new Group instance     */    public Group create() {        final GroupImpl group =            new GroupImpl(options, name, description, minimum, maximum);        reset();        return group;    }    /**     * Resets the builder     */    public GroupBuilder reset() {        name = null;        description = null;        options = new ArrayList();        minimum = 0;        maximum = Integer.MAX_VALUE;        return this;    }    /**     * Use this option description     * @param newDescription the description to use     * @return this builder     */    public GroupBuilder withDescription(final String newDescription) {        this.description = newDescription;        return this;    }    /**     * Use this option name     * @param newName the name to use     * @return this builder     */    public GroupBuilder withName(final String newName) {        this.name = newName;        return this;    }    /**     * A valid group requires at least this many options present     * @param newMinimum the minimum Options required     * @return this builder     */    public GroupBuilder withMinimum(final int newMinimum) {        this.minimum = newMinimum;        return this;    }    /**     * A valid group requires at most this many options present     * @param newMaximum the maximum Options allowed     * @return this builder     */    public GroupBuilder withMaximum(final int newMaximum) {        this.maximum = newMaximum;        return this;    }    /**     * Add this option to the group     * @param option the Option to add     * @return this builder     */    public GroupBuilder withOption(final Option option) {        this.options.add(option);        return this;    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.option.GroupImpl;\n+\n+/**\n+ * Builds Group instances\n+ */\n+public class GroupBuilder {\n+\n+    private String name;\n+    private String description;\n+    private List options;\n+    private int minimum;\n+    private int maximum;\n+\n+    /**\n+     * Creates a new GroupBuilder\n+     */\n+    public GroupBuilder() {\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a new Group instance\n+     * @return the new Group instance\n+     */\n+    public Group create() {\n+        final GroupImpl group =\n+            new GroupImpl(options, name, description, minimum, maximum);\n+\n+        reset();\n+\n+        return group;\n+    }\n+\n+    /**\n+     * Resets the builder\n+     */\n+    public GroupBuilder reset() {\n+        name = null;\n+        description = null;\n+        options = new ArrayList();\n+        minimum = 0;\n+        maximum = Integer.MAX_VALUE;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option description\n+     * @param newDescription the description to use\n+     * @return this builder\n+     */\n+    public GroupBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option name\n+     * @param newName the name to use\n+     * @return this builder\n+     */\n+    public GroupBuilder withName(final String newName) {\n+        this.name = newName;\n+        return this;\n+    }\n+\n+    /**\n+     * A valid group requires at least this many options present\n+     * @param newMinimum the minimum Options required\n+     * @return this builder\n+     */\n+    public GroupBuilder withMinimum(final int newMinimum) {\n+        this.minimum = newMinimum;\n+        return this;\n+    }\n+\n+    /**\n+     * A valid group requires at most this many options present\n+     * @param newMaximum the maximum Options allowed\n+     * @return this builder\n+     */\n+    public GroupBuilder withMaximum(final int newMaximum) {\n+        this.maximum = newMaximum;\n+        return this;\n+    }\n+\n+    /**\n+     * Add this option to the group\n+     * @param option the Option to add\n+     * @return this builder\n+     */\n+    public GroupBuilder withOption(final Option option) {\n+        this.options.add(option);\n+        return this;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/builder/PatternBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/PatternBuilder.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.builder;import java.util.Iterator;import java.util.LinkedHashSet;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.validation.ClassValidator;import org.apache.commons.cli2.validation.DateValidator;import org.apache.commons.cli2.validation.FileValidator;import org.apache.commons.cli2.validation.NumberValidator;import org.apache.commons.cli2.validation.UrlValidator;import org.apache.commons.cli2.validation.Validator;/** * Builds Options using a String pattern *///TODO Document and link to the acceptable patternspublic class PatternBuilder {    private final GroupBuilder gbuilder;    private final DefaultOptionBuilder obuilder;    private final ArgumentBuilder abuilder;    /**     * Creates a new PatternBuilder     */    public PatternBuilder() {        this(            new GroupBuilder(),            new DefaultOptionBuilder(),            new ArgumentBuilder());    }    /**     * Creates a new PatternBuilder     * @param gbuilder the GroupBuilder to use     * @param obuilder the DefaultOptionBuilder to use     * @param abuilder the ArgumentBuilder to use     */    public PatternBuilder(        final GroupBuilder gbuilder,        final DefaultOptionBuilder obuilder,        final ArgumentBuilder abuilder) {        this.gbuilder = gbuilder;        this.obuilder = obuilder;        this.abuilder = abuilder;    }    private final Set options = new LinkedHashSet();    /**     * Creates a new Option instance.     * @return a new Option instance     */    public Option create() {        final Option option;        if (options.size() == 1) {            option = (Option)options.iterator().next();        }        else {            gbuilder.reset();            for (final Iterator i = options.iterator(); i.hasNext();) {                gbuilder.withOption((Option)i.next());            }            option = gbuilder.create();        }        reset();        return option;    }    /**     * Resets this builder     */    public PatternBuilder reset() {        options.clear();        return this;    }    private void createOption(        final char type,        final boolean required,        final char opt) {        final Argument argument;        if (type != ' ') {            abuilder.reset();            abuilder.withValidator(validator(type));            if (required) {                abuilder.withMinimum(1);            }            if (type != '*') {                abuilder.withMaximum(1);            }            argument = abuilder.create();        }        else {            argument = null;        }        obuilder.reset();        obuilder.withArgument(argument);        obuilder.withShortName(String.valueOf(opt));        obuilder.withRequired(required);        options.add(obuilder.create());    }    /**     * Builds an Option using a pattern string.     * @param pattern the pattern to build from     */    public void withPattern(final String pattern) {        int sz = pattern.length();        char opt = ' ';        char ch = ' ';        char type = ' ';        boolean required = false;        for (int i = 0; i < sz; i++) {            ch = pattern.charAt(i);            switch (ch) {                case '!' :                    required = true;                    break;                case '@' :                case ':' :                case '%' :                case '+' :                case '#' :                case '<' :                case '>' :                case '*' :                case '/' :                    type = ch;                    break;                default :                    if (opt != ' ') {                        createOption(type, required, opt);                        required = false;                        type = ' ';                    }                    opt = ch;            }        }        if (opt != ' ') {            createOption(type, required, opt);        }    }    private static Validator validator(final char c) {        switch (c) {            case '@' :                final ClassValidator classv = new ClassValidator();                classv.setInstance(true);                return classv;            case '+' :                final ClassValidator instancev = new ClassValidator();                return instancev;                //case ':':// no validator needed for a string            case '%' :                return NumberValidator.getNumberInstance();            case '#' :                return DateValidator.getDateInstance();            case '<' :                final FileValidator existingv = new FileValidator();                existingv.setExisting(true);                existingv.setFile(true);                return existingv;            case '>' :            case '*' :                return new FileValidator();            case '/' :                return new UrlValidator();            default :                return null;        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.validation.ClassValidator;\n+import org.apache.commons.cli2.validation.DateValidator;\n+import org.apache.commons.cli2.validation.FileValidator;\n+import org.apache.commons.cli2.validation.NumberValidator;\n+import org.apache.commons.cli2.validation.UrlValidator;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * Builds Options using a String pattern\n+ */\n+//TODO Document and link to the acceptable patterns\n+public class PatternBuilder {\n+\n+    private final GroupBuilder gbuilder;\n+    private final DefaultOptionBuilder obuilder;\n+    private final ArgumentBuilder abuilder;\n+\n+    /**\n+     * Creates a new PatternBuilder\n+     */\n+    public PatternBuilder() {\n+        this(\n+            new GroupBuilder(),\n+            new DefaultOptionBuilder(),\n+            new ArgumentBuilder());\n+    }\n+\n+    /**\n+     * Creates a new PatternBuilder\n+     * @param gbuilder the GroupBuilder to use\n+     * @param obuilder the DefaultOptionBuilder to use\n+     * @param abuilder the ArgumentBuilder to use\n+     */\n+    public PatternBuilder(\n+        final GroupBuilder gbuilder,\n+        final DefaultOptionBuilder obuilder,\n+        final ArgumentBuilder abuilder) {\n+        this.gbuilder = gbuilder;\n+        this.obuilder = obuilder;\n+        this.abuilder = abuilder;\n+    }\n+\n+    private final Set options = new LinkedHashSet();\n+\n+    /**\n+     * Creates a new Option instance.\n+     * @return a new Option instance\n+     */\n+    public Option create() {\n+        final Option option;\n+\n+        if (options.size() == 1) {\n+            option = (Option)options.iterator().next();\n+        }\n+        else {\n+            gbuilder.reset();\n+            for (final Iterator i = options.iterator(); i.hasNext();) {\n+                gbuilder.withOption((Option)i.next());\n+            }\n+            option = gbuilder.create();\n+        }\n+\n+        reset();\n+\n+        return option;\n+    }\n+\n+    /**\n+     * Resets this builder\n+     */\n+    public PatternBuilder reset() {\n+        options.clear();\n+        return this;\n+    }\n+\n+    private void createOption(\n+        final char type,\n+        final boolean required,\n+        final char opt) {\n+        final Argument argument;\n+        if (type != ' ') {\n+            abuilder.reset();\n+            abuilder.withValidator(validator(type));\n+            if (required) {\n+                abuilder.withMinimum(1);\n+            }\n+            if (type != '*') {\n+                abuilder.withMaximum(1);\n+            }\n+            argument = abuilder.create();\n+        }\n+        else {\n+            argument = null;\n+        }\n+\n+        obuilder.reset();\n+        obuilder.withArgument(argument);\n+        obuilder.withShortName(String.valueOf(opt));\n+        obuilder.withRequired(required);\n+\n+        options.add(obuilder.create());\n+    }\n+\n+    /**\n+     * Builds an Option using a pattern string.\n+     * @param pattern the pattern to build from\n+     */\n+    public void withPattern(final String pattern) {\n+        int sz = pattern.length();\n+\n+        char opt = ' ';\n+        char ch = ' ';\n+        char type = ' ';\n+        boolean required = false;\n+\n+        for (int i = 0; i < sz; i++) {\n+            ch = pattern.charAt(i);\n+\n+            switch (ch) {\n+                case '!' :\n+                    required = true;\n+                    break;\n+                case '@' :\n+                case ':' :\n+                case '%' :\n+                case '+' :\n+                case '#' :\n+                case '<' :\n+                case '>' :\n+                case '*' :\n+                case '/' :\n+                    type = ch;\n+                    break;\n+                default :\n+                    if (opt != ' ') {\n+                        createOption(type, required, opt);\n+                        required = false;\n+                        type = ' ';\n+                    }\n+\n+                    opt = ch;\n+            }\n+        }\n+\n+        if (opt != ' ') {\n+            createOption(type, required, opt);\n+        }\n+    }\n+\n+    private static Validator validator(final char c) {\n+        switch (c) {\n+            case '@' :\n+                final ClassValidator classv = new ClassValidator();\n+                classv.setInstance(true);\n+                return classv;\n+            case '+' :\n+                final ClassValidator instancev = new ClassValidator();\n+                return instancev;\n+                //case ':':// no validator needed for a string\n+            case '%' :\n+                return NumberValidator.getNumberInstance();\n+            case '#' :\n+                return DateValidator.getDateInstance();\n+            case '<' :\n+                final FileValidator existingv = new FileValidator();\n+                existingv.setExisting(true);\n+                existingv.setFile(true);\n+                return existingv;\n+            case '>' :\n+            case '*' :\n+                return new FileValidator();\n+            case '/' :\n+                return new UrlValidator();\n+            default :\n+                return null;\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/builder/SwitchBuilder.java\n+++ b/src/java/org/apache/commons/cli2/builder/SwitchBuilder.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.builder;import java.util.HashSet;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.option.Switch;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * Builds Switch instance. */public class SwitchBuilder {    private final String enabledPrefix;    private final String disabledPrefix;    private String description;    private String preferredName;    private Set aliases;    private boolean required;    private Argument argument;    private Group children;    private int id;    private Boolean switchDefault;    /**     * Creates a new SwitchBuilder using defaults.     * @see Switch#DEFAULT_ENABLED_PREFIX     * @see Switch#DEFAULT_DISABLED_PREFIX     */    public SwitchBuilder() {        this(Switch.DEFAULT_ENABLED_PREFIX, Switch.DEFAULT_DISABLED_PREFIX);    }    /**     * Creates a new SwitchBuilder     * @param enabledPrefix the prefix to use for enabling the option     * @param disabledPrefix the prefix to use for disabling the option     * @throws IllegalArgumentException if either prefix is less than 1     *                                  character long or the prefixes match     */    public SwitchBuilder(final String enabledPrefix,                         final String disabledPrefix)        throws IllegalArgumentException {        if ((enabledPrefix == null) || (enabledPrefix.length() < 1)) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ILLEGAL_ENABLED_PREFIX));        }        if ((disabledPrefix == null) || (disabledPrefix.length() < 1)) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ILLEGAL_DISABLED_PREFIX));        }        if (enabledPrefix.equals(disabledPrefix)) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_IDENTICAL_PREFIXES));        }        this.enabledPrefix = enabledPrefix;        this.disabledPrefix = disabledPrefix;        reset();    }    /**     * Creates a new Switch instance     * @return a new Switch instance     */    public Switch create() {        final Switch option =            new Switch(enabledPrefix, disabledPrefix, preferredName, aliases, description,                       required, argument, children, id, switchDefault);        reset();        return option;    }    /**     * Resets the builder     */    public SwitchBuilder reset() {        description = null;        preferredName = null;        required = false;        aliases = new HashSet();        argument = null;        children = null;        id = 0;        switchDefault = null;        return this;    }    /**     * Use this option description     * @param newDescription the description to use     * @return this builder     */    public SwitchBuilder withDescription(final String newDescription) {        this.description = newDescription;        return this;    }    /**     * Use this option name. The first name is used as the preferred     * display name for the Command and then later names are used as aliases.     *     * @param name the name to use     * @return this builder     */    public SwitchBuilder withName(final String name) {        if (preferredName == null) {            preferredName = name;        } else {            aliases.add(name);        }        return this;    }    /**     * Use this optionality     * @param newRequired true iff the Option is required     * @return this builder     */    public SwitchBuilder withRequired(final boolean newRequired) {        this.required = newRequired;        return this;    }    /**     * Use this Argument     * @param newArgument the argument to use     * @return this builder     */    public SwitchBuilder withArgument(final Argument newArgument) {        this.argument = newArgument;        return this;    }    /**     * Use this child Group     * @param newChildren the child Group to use     * @return this builder     */    public SwitchBuilder withChildren(final Group newChildren) {        this.children = newChildren;        return this;    }    /**     * Sets the id     *     * @param newId     *            the id of the Switch     * @return this SwitchBuilder     */    public final SwitchBuilder withId(final int newId) {        this.id = newId;        return this;    }    /**     * Sets the default state for this switch     *     * @param newSwitchDefault the default state     * @return this SwitchBuilder     */    public final SwitchBuilder withSwitchDefault(final Boolean newSwitchDefault) {        this.switchDefault = newSwitchDefault;        return this;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.Switch;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * Builds Switch instance.\n+ */\n+public class SwitchBuilder {\n+    private final String enabledPrefix;\n+    private final String disabledPrefix;\n+    private String description;\n+    private String preferredName;\n+    private Set aliases;\n+    private boolean required;\n+    private Argument argument;\n+    private Group children;\n+    private int id;\n+    private Boolean switchDefault;\n+\n+    /**\n+     * Creates a new SwitchBuilder using defaults.\n+     * @see Switch#DEFAULT_ENABLED_PREFIX\n+     * @see Switch#DEFAULT_DISABLED_PREFIX\n+     */\n+    public SwitchBuilder() {\n+        this(Switch.DEFAULT_ENABLED_PREFIX, Switch.DEFAULT_DISABLED_PREFIX);\n+    }\n+\n+    /**\n+     * Creates a new SwitchBuilder\n+     * @param enabledPrefix the prefix to use for enabling the option\n+     * @param disabledPrefix the prefix to use for disabling the option\n+     * @throws IllegalArgumentException if either prefix is less than 1\n+     *                                  character long or the prefixes match\n+     */\n+    public SwitchBuilder(final String enabledPrefix,\n+                         final String disabledPrefix)\n+        throws IllegalArgumentException {\n+        if ((enabledPrefix == null) || (enabledPrefix.length() < 1)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ILLEGAL_ENABLED_PREFIX));\n+        }\n+\n+        if ((disabledPrefix == null) || (disabledPrefix.length() < 1)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ILLEGAL_DISABLED_PREFIX));\n+        }\n+\n+        if (enabledPrefix.equals(disabledPrefix)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_IDENTICAL_PREFIXES));\n+        }\n+\n+        this.enabledPrefix = enabledPrefix;\n+        this.disabledPrefix = disabledPrefix;\n+        reset();\n+    }\n+\n+    /**\n+     * Creates a new Switch instance\n+     * @return a new Switch instance\n+     */\n+    public Switch create() {\n+        final Switch option =\n+            new Switch(enabledPrefix, disabledPrefix, preferredName, aliases, description,\n+                       required, argument, children, id, switchDefault);\n+\n+        reset();\n+\n+        return option;\n+    }\n+\n+    /**\n+     * Resets the builder\n+     */\n+    public SwitchBuilder reset() {\n+        description = null;\n+        preferredName = null;\n+        required = false;\n+        aliases = new HashSet();\n+        argument = null;\n+        children = null;\n+        id = 0;\n+        switchDefault = null;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option description\n+     * @param newDescription the description to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withDescription(final String newDescription) {\n+        this.description = newDescription;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this option name. The first name is used as the preferred\n+     * display name for the Command and then later names are used as aliases.\n+     *\n+     * @param name the name to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withName(final String name) {\n+        if (preferredName == null) {\n+            preferredName = name;\n+        } else {\n+            aliases.add(name);\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this optionality\n+     * @param newRequired true iff the Option is required\n+     * @return this builder\n+     */\n+    public SwitchBuilder withRequired(final boolean newRequired) {\n+        this.required = newRequired;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this Argument\n+     * @param newArgument the argument to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withArgument(final Argument newArgument) {\n+        this.argument = newArgument;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Use this child Group\n+     * @param newChildren the child Group to use\n+     * @return this builder\n+     */\n+    public SwitchBuilder withChildren(final Group newChildren) {\n+        this.children = newChildren;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the id\n+     *\n+     * @param newId\n+     *            the id of the Switch\n+     * @return this SwitchBuilder\n+     */\n+    public final SwitchBuilder withId(final int newId) {\n+        this.id = newId;\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the default state for this switch\n+     *\n+     * @param newSwitchDefault the default state\n+     * @return this SwitchBuilder\n+     */\n+    public final SwitchBuilder withSwitchDefault(final Boolean newSwitchDefault) {\n+        this.switchDefault = newSwitchDefault;\n+\n+        return this;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/commandline/CommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/CommandLineImpl.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.Collections;import java.util.Iterator;import java.util.List;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * Instances of CommandLine represent a command line that has been processed * according to the definition supplied to the parser. */public abstract class CommandLineImpl implements CommandLine {    public final boolean hasOption(final String trigger) {        return hasOption(getOption(trigger));    }    public final List getValues(final String trigger) {        return getValues(getOption(trigger), Collections.EMPTY_LIST);    }    public final List getValues(final String trigger,                                final List defaultValues) {        return getValues(getOption(trigger), defaultValues);    }    public final List getValues(final Option option) {        return getValues(option, Collections.EMPTY_LIST);    }    public final Object getValue(final String trigger) {        return getValue(getOption(trigger), null);    }    public final Object getValue(final String trigger,                                 final Object defaultValue) {        return getValue(getOption(trigger), defaultValue);    }    public final Object getValue(final Option option) {        return getValue(option, null);    }    public final Object getValue(final Option option,                                 final Object defaultValue) {        final List values;        if (defaultValue == null) {            values = getValues(option);        } else {            values = getValues(option, Collections.singletonList(defaultValue));        }        if (values.size() > 1) {            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES));        }        if (values.isEmpty()) {            return defaultValue;        }        return values.get(0);    }    public final Boolean getSwitch(final String trigger) {        return getSwitch(getOption(trigger), null);    }    public final Boolean getSwitch(final String trigger,                                   final Boolean defaultValue) {        return getSwitch(getOption(trigger), defaultValue);    }    public final Boolean getSwitch(final Option option) {        return getSwitch(option, null);    }    public final String getProperty(final String property) {        return getProperty(property, null);    }    public final int getOptionCount(final String trigger) {        return getOptionCount(getOption(trigger));    }    public final int getOptionCount(final Option option) {        if (option == null) {            return 0;        }        int count = 0;        for (Iterator i = getOptions().iterator(); i.hasNext();) {            if (option.equals(i.next())) {                ++count;            }        }        return count;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * Instances of CommandLine represent a command line that has been processed\n+ * according to the definition supplied to the parser.\n+ */\n+public abstract class CommandLineImpl implements CommandLine {\n+    public final boolean hasOption(final String trigger) {\n+        return hasOption(getOption(trigger));\n+    }\n+\n+    public final List getValues(final String trigger) {\n+        return getValues(getOption(trigger), Collections.EMPTY_LIST);\n+    }\n+\n+    public final List getValues(final String trigger,\n+                                final List defaultValues) {\n+        return getValues(getOption(trigger), defaultValues);\n+    }\n+\n+    public final List getValues(final Option option) {\n+        return getValues(option, Collections.EMPTY_LIST);\n+    }\n+\n+    public final Object getValue(final String trigger) {\n+        return getValue(getOption(trigger), null);\n+    }\n+\n+    public final Object getValue(final String trigger,\n+                                 final Object defaultValue) {\n+        return getValue(getOption(trigger), defaultValue);\n+    }\n+\n+    public final Object getValue(final Option option) {\n+        return getValue(option, null);\n+    }\n+\n+    public final Object getValue(final Option option,\n+                                 final Object defaultValue) {\n+        final List values;\n+\n+        if (defaultValue == null) {\n+            values = getValues(option);\n+        } else {\n+            values = getValues(option, Collections.singletonList(defaultValue));\n+        }\n+\n+        if (values.size() > 1) {\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES));\n+        }\n+\n+        if (values.isEmpty()) {\n+            return defaultValue;\n+        }\n+\n+        return values.get(0);\n+    }\n+\n+    public final Boolean getSwitch(final String trigger) {\n+        return getSwitch(getOption(trigger), null);\n+    }\n+\n+    public final Boolean getSwitch(final String trigger,\n+                                   final Boolean defaultValue) {\n+        return getSwitch(getOption(trigger), defaultValue);\n+    }\n+\n+    public final Boolean getSwitch(final Option option) {\n+        return getSwitch(option, null);\n+    }\n+\n+    public final String getProperty(final String property) {\n+        return getProperty(property, null);\n+    }\n+\n+    public final int getOptionCount(final String trigger) {\n+        return getOptionCount(getOption(trigger));\n+    }\n+\n+    public final int getOptionCount(final Option option) {\n+        if (option == null) {\n+            return 0;\n+        }\n+\n+        int count = 0;\n+\n+        for (Iterator i = getOptions().iterator(); i.hasNext();) {\n+            if (option.equals(i.next())) {\n+                ++count;\n+            }\n+        }\n+\n+        return count;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/commandline/DefaultingCommandLine.java\n+++ b/src/java/org/apache/commons/cli2/commandline/DefaultingCommandLine.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Option;/** * Manages a queue of default CommandLines. This CommandLine implementation is * backed by a queue of CommandLine instances which are queried in turn until a * suitable result is found. * * CommandLine instances can either be added to the back of the queue or can be * pushed in at a specific position. * * @see #appendCommandLine(CommandLine) * @see #insertCommandLine(int, CommandLine) */public class DefaultingCommandLine extends CommandLineImpl {    /**     * The list of default CommandLine instances     */    private final List commandLines = new ArrayList();    /**     * Adds a CommandLine instance to the back of the queue. The supplied     * CommandLine will be used as defaults when all other CommandLines produce     * no result     *     * @param commandLine     *            the default values to use if all CommandLines     */    public void appendCommandLine(final CommandLine commandLine) {        commandLines.add(commandLine);    }    /**     * Adds a CommandLine instance to a specified position in the queue.     *     * @param index ths position at which to insert     * @param commandLine the CommandLine to insert     */    public void insertCommandLine(        final int index,        final CommandLine commandLine) {        commandLines.add(index, commandLine);    }    /**     * Builds an iterator over the build in CommandLines.     *     * @return an unmodifiable iterator     */    public Iterator commandLines(){    \treturn Collections.unmodifiableList(commandLines).iterator();    }    public Option getOption(String trigger) {        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            final Option actual = commandLine.getOption(trigger);            if (actual != null) {                return actual;            }        }        return null;    }    public List getOptions() {        final List options = new ArrayList();        final List temp = new ArrayList();        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            temp.clear();            temp.addAll(commandLine.getOptions());            temp.removeAll(options);            options.addAll(temp);        }        return Collections.unmodifiableList(options);    }    public Set getOptionTriggers() {        final Set all = new HashSet();        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            all.addAll(commandLine.getOptionTriggers());        }        return Collections.unmodifiableSet(all);    }    public boolean hasOption(Option option) {        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            if (commandLine.hasOption(option)) {                return true;            }        }        return false;    }    public List getValues(Option option, List defaultValues) {        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            final List actual = commandLine.getValues(option);            if (actual != null && !actual.isEmpty()) {                return actual;            }        }        if(defaultValues==null){        \treturn Collections.EMPTY_LIST;        }        else{        \treturn defaultValues;        }    }    public Boolean getSwitch(Option option, Boolean defaultValue) {        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            final Boolean actual = commandLine.getSwitch(option);            if (actual != null) {                return actual;            }        }        return defaultValue;    }    public String getProperty(String property, String defaultValue) {        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            final String actual = commandLine.getProperty(property);            if (actual != null) {                return actual;            }        }        return defaultValue;    }    public Set getProperties() {        final Set all = new HashSet();        for (final Iterator i = commandLines.iterator(); i.hasNext();) {            final CommandLine commandLine = (CommandLine)i.next();            all.addAll(commandLine.getProperties());        }        return Collections.unmodifiableSet(all);    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * Manages a queue of default CommandLines. This CommandLine implementation is\n+ * backed by a queue of CommandLine instances which are queried in turn until a\n+ * suitable result is found.\n+ * \n+ * CommandLine instances can either be added to the back of the queue or can be\n+ * pushed in at a specific position.\n+ * \n+ * @see #appendCommandLine(CommandLine)\n+ * @see #insertCommandLine(int, CommandLine)\n+ */\n+public class DefaultingCommandLine extends CommandLineImpl {\n+\n+    /**\n+     * The list of default CommandLine instances\n+     */\n+    private final List commandLines = new ArrayList();\n+\n+    /**\n+     * Adds a CommandLine instance to the back of the queue. The supplied\n+     * CommandLine will be used as defaults when all other CommandLines produce\n+     * no result\n+     * \n+     * @param commandLine\n+     *            the default values to use if all CommandLines\n+     */\n+    public void appendCommandLine(final CommandLine commandLine) {\n+        commandLines.add(commandLine);\n+    }\n+    \n+    /**\n+     * Adds a CommandLine instance to a specified position in the queue.\n+     * \n+     * @param index ths position at which to insert\n+     * @param commandLine the CommandLine to insert\n+     */\n+    public void insertCommandLine(\n+        final int index,\n+        final CommandLine commandLine) {\n+        commandLines.add(index, commandLine);\n+    }\n+    \n+    /**\n+     * Builds an iterator over the build in CommandLines.\n+     * \n+     * @return an unmodifiable iterator\n+     */\n+    public Iterator commandLines(){\n+    \treturn Collections.unmodifiableList(commandLines).iterator();\n+    }\n+\n+    public Option getOption(String trigger) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final Option actual = commandLine.getOption(trigger);\n+            if (actual != null) {\n+                return actual;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public List getOptions() {\n+        final List options = new ArrayList();\n+\n+        final List temp = new ArrayList();\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            temp.clear();\n+            temp.addAll(commandLine.getOptions());\n+            temp.removeAll(options);\n+            options.addAll(temp);\n+        }\n+\n+        return Collections.unmodifiableList(options);\n+    }\n+\n+    public Set getOptionTriggers() {\n+        final Set all = new HashSet();\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            all.addAll(commandLine.getOptionTriggers());\n+        }\n+\n+        return Collections.unmodifiableSet(all);\n+    }\n+\n+    public boolean hasOption(Option option) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            if (commandLine.hasOption(option)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public List getValues(Option option, List defaultValues) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final List actual = commandLine.getValues(option);\n+            if (actual != null && !actual.isEmpty()) {\n+                return actual;\n+            }\n+        }\n+        if(defaultValues==null){\n+        \treturn Collections.EMPTY_LIST;\n+        }\n+        else{\n+        \treturn defaultValues;\n+        }\n+    }\n+\n+    public Boolean getSwitch(Option option, Boolean defaultValue) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final Boolean actual = commandLine.getSwitch(option);\n+            if (actual != null) {\n+                return actual;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    public String getProperty(String property, String defaultValue) {\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            final String actual = commandLine.getProperty(property);\n+            if (actual != null) {\n+                return actual;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    public Set getProperties() {\n+        final Set all = new HashSet();\n+        for (final Iterator i = commandLines.iterator(); i.hasNext();) {\n+            final CommandLine commandLine = (CommandLine)i.next();\n+            all.addAll(commandLine.getProperties());\n+        }\n+        return Collections.unmodifiableSet(all);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/commandline/Parser.java\n+++ b/src/java/org/apache/commons/cli2/commandline/Parser.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.LinkedList;import java.util.List;import java.util.ListIterator;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.util.HelpFormatter;/** * A class that implements the <code>Parser</code> interface can parse a * String array according to the {@link Group}specified and return a * {@link CommandLine}. * * @author John Keyes (john at integralsource.com) */public class Parser {    private HelpFormatter helpFormatter = new HelpFormatter();    private Option helpOption = null;    private String helpTrigger = null;    private Group group = null;    /**     * Parse the arguments according to the specified options and properties.     *     * @param arguments     *            the command line arguments     *     * @return the list of atomic option and value tokens     * @throws OptionException     *             if there are any problems encountered while parsing the     *             command line tokens.     */    public CommandLine parse(final String[] arguments)        throws OptionException {        // build a mutable list for the arguments        final List argumentList = new LinkedList();        // copy the arguments into the new list        for (int i = 0; i < arguments.length; i++) {            final String argument = arguments[i];            // ensure non intern'd strings are used            // so that == comparisons work as expected            argumentList.add(new String(argument));        }        // wet up a command line for this group        final WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);        // pick up any defaults from the model        group.defaults(commandLine);        // process the options as far as possible        final ListIterator iterator = argumentList.listIterator();        Object previous = null;        while (group.canProcess(commandLine, iterator)) {            // peek at the next item and backtrack            final Object next = iterator.next();            iterator.previous();            // if we have just tried to process this instance            if (next == previous) {                // abort                break;            }            // remember previous            previous = next;            group.process(commandLine, iterator);        }        // if there are more arguments we have a problem        if (iterator.hasNext()) {            final String arg = (String) iterator.next();            throw new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);        }        // no need to validate if the help option is present        if (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {            group.validate(commandLine);        }        return commandLine;    }    /**     * Parse the arguments according to the specified options and properties and     * displays the usage screen if the CommandLine is not valid or the help     * option was specified.     *     * @param arguments the command line arguments     * @return a valid CommandLine or null if the parse was unsuccessful     * @throws IOException if an error occurs while formatting help     */    public CommandLine parseAndHelp(final String[] arguments) {        helpFormatter.setGroup(group);        try {            // attempt to parse the command line            final CommandLine commandLine = parse(arguments);            if (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {                return commandLine;            }        } catch (final OptionException oe) {            // display help regarding the exception            helpFormatter.setException(oe);        }        // print help        helpFormatter.print();        return null;    }    /**     * Sets the Group of options to parse against     * @param group the group of options to parse against     */    public void setGroup(final Group group) {        this.group = group;    }    /**     * Sets the HelpFormatter to use with the simplified parsing.     * @see #parseAndHelp(String[])     * @param helpFormatter the HelpFormatter to use with the simplified parsing     */    public void setHelpFormatter(final HelpFormatter helpFormatter) {        this.helpFormatter = helpFormatter;    }    /**     * Sets the help option to use with the simplified parsing.  For example     * <code>--help</code>, <code>-h</code> and <code>-?</code> are often used.     * @see #parseAndHelp(String[])     * @param helpOption the help Option     */    public void setHelpOption(final Option helpOption) {        this.helpOption = helpOption;    }    /**     * Sets the help option to use with the simplified parsing.  For example     * <code>--help</code>, <code>-h</code> and <code>-?</code> are often used.     * @see #parseAndHelp(String[])     * @param helpTrigger the trigger of the help Option     */    public void setHelpTrigger(final String helpTrigger) {        this.helpTrigger = helpTrigger;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+/**\n+ * A class that implements the <code>Parser</code> interface can parse a\n+ * String array according to the {@link Group}specified and return a\n+ * {@link CommandLine}.\n+ *\n+ * @author John Keyes (john at integralsource.com)\n+ */\n+public class Parser {\n+    private HelpFormatter helpFormatter = new HelpFormatter();\n+    private Option helpOption = null;\n+    private String helpTrigger = null;\n+    private Group group = null;\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties.\n+     *\n+     * @param arguments\n+     *            the command line arguments\n+     *\n+     * @return the list of atomic option and value tokens\n+     * @throws OptionException\n+     *             if there are any problems encountered while parsing the\n+     *             command line tokens.\n+     */\n+    public CommandLine parse(final String[] arguments)\n+        throws OptionException {\n+        // build a mutable list for the arguments\n+        final List argumentList = new LinkedList();\n+\n+        // copy the arguments into the new list\n+        for (int i = 0; i < arguments.length; i++) {\n+            final String argument = arguments[i];\n+\n+            // ensure non intern'd strings are used \n+            // so that == comparisons work as expected\n+            argumentList.add(new String(argument));\n+        }\n+\n+        // wet up a command line for this group\n+        final WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n+\n+        // pick up any defaults from the model\n+        group.defaults(commandLine);\n+\n+        // process the options as far as possible\n+        final ListIterator iterator = argumentList.listIterator();\n+        Object previous = null;\n+\n+        while (group.canProcess(commandLine, iterator)) {\n+            // peek at the next item and backtrack\n+            final Object next = iterator.next();\n+            iterator.previous();\n+\n+            // if we have just tried to process this instance\n+            if (next == previous) {\n+                // abort\n+                break;\n+            }\n+\n+            // remember previous\n+            previous = next;\n+\n+            group.process(commandLine, iterator);\n+        }\n+\n+        // if there are more arguments we have a problem\n+        if (iterator.hasNext()) {\n+            final String arg = (String) iterator.next();\n+            throw new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n+        }\n+\n+        // no need to validate if the help option is present\n+        if (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\n+            group.validate(commandLine);\n+        }\n+\n+        return commandLine;\n+    }\n+\n+    /**\n+     * Parse the arguments according to the specified options and properties and\n+     * displays the usage screen if the CommandLine is not valid or the help\n+     * option was specified.\n+     *\n+     * @param arguments the command line arguments\n+     * @return a valid CommandLine or null if the parse was unsuccessful\n+     * @throws IOException if an error occurs while formatting help\n+     */\n+    public CommandLine parseAndHelp(final String[] arguments) {\n+        helpFormatter.setGroup(group);\n+\n+        try {\n+            // attempt to parse the command line\n+            final CommandLine commandLine = parse(arguments);\n+\n+            if (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\n+                return commandLine;\n+            }\n+        } catch (final OptionException oe) {\n+            // display help regarding the exception\n+            helpFormatter.setException(oe);\n+        }\n+\n+        // print help\n+        helpFormatter.print();\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Sets the Group of options to parse against\n+     * @param group the group of options to parse against\n+     */\n+    public void setGroup(final Group group) {\n+        this.group = group;\n+    }\n+\n+    /**\n+     * Sets the HelpFormatter to use with the simplified parsing.\n+     * @see #parseAndHelp(String[])\n+     * @param helpFormatter the HelpFormatter to use with the simplified parsing\n+     */\n+    public void setHelpFormatter(final HelpFormatter helpFormatter) {\n+        this.helpFormatter = helpFormatter;\n+    }\n+\n+    /**\n+     * Sets the help option to use with the simplified parsing.  For example\n+     * <code>--help</code>, <code>-h</code> and <code>-?</code> are often used.\n+     * @see #parseAndHelp(String[])\n+     * @param helpOption the help Option\n+     */\n+    public void setHelpOption(final Option helpOption) {\n+        this.helpOption = helpOption;\n+    }\n+\n+    /**\n+     * Sets the help option to use with the simplified parsing.  For example\n+     * <code>--help</code>, <code>-h</code> and <code>-?</code> are often used.\n+     * @see #parseAndHelp(String[])\n+     * @param helpTrigger the trigger of the help Option\n+     */\n+    public void setHelpTrigger(final String helpTrigger) {\n+        this.helpTrigger = helpTrigger;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/commandline/PreferencesCommandLine.java\n+++ b/src/java/org/apache/commons/cli2/commandline/PreferencesCommandLine.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;import java.util.StringTokenizer;import java.util.prefs.BackingStoreException;import java.util.prefs.Preferences;import org.apache.commons.cli2.Option;/** * A CommandLine implementation using the Preferences API, useful when * constructing a complex DefaultingCommandLine * * This implementation uses the children of a single preference node to populate * the CommandLine.  Options are keyed from their preferred name and presence in * the Preferences object is taken as presence in the CommandLine.  Argument * values are taken from the Preference value and are optionally separated using * the separator char defined, at construction time.  Switch values can be * specified using a simple value of <code>true</code> or <code>false</code>; * obviously this means that Switches with Arguments are not supported by this * implementation. * * @see java.util.prefs.Preferences * @see org.apache.commons.cli2.commandline.DefaultingCommandLine * @see org.apache.commons.cli2.Option#getPreferredName() */public class PreferencesCommandLine extends CommandLineImpl {\tprivate static final char NUL = '\\0';\tprivate final Preferences preferences;\tprivate final Option root;\tprivate final char separator;\t/**     * Creates a new PreferencesCommandLine using the specified root Option and     * Preferences node.  Argument values will be separated using the char 0.     *\t * @param root the CommandLine's root Option\t * @param preferences the Preferences node to get values from\t */\tpublic PreferencesCommandLine(final Option root, final Preferences preferences){\t\tthis(root,preferences,NUL);\t}    /**     * Creates a new PreferencesCommandLine using the specified root Option,     * Preferences node and value separator.     *     * @param root the CommandLine's root Option     * @param preferences the Preferences node to get values from     * @param separator the character to split argument values     */\tpublic PreferencesCommandLine(final Option root, final Preferences preferences, final char separator){\t\tthis.root = root;\t\tthis.preferences = preferences;\t\tthis.separator = separator;\t}\tpublic boolean hasOption(Option option) {\t\tif(option==null){\t\t\treturn false;\t\t}\t\telse{\t\t\ttry {\t\t\t\treturn Arrays.asList(preferences.keys()).contains(option.getPreferredName());\t\t\t} catch (BackingStoreException e) {\t\t\t\treturn false;\t\t\t}\t\t}\t}\tpublic Option getOption(String trigger) {\t\treturn root.findOption(trigger);\t}\tpublic List getValues(final Option option, final List defaultValues) {\t\tfinal String value = preferences.get(option.getPreferredName(),null);\t\tif(value==null){\t\t\treturn defaultValues;\t\t}\t\telse if(separator>NUL){\t\t\tfinal List values = new ArrayList();\t\t\tfinal StringTokenizer tokens = new StringTokenizer(value,String.valueOf(separator));\t\t\twhile(tokens.hasMoreTokens()){\t\t\t\tvalues.add(tokens.nextToken());\t\t\t}\t\t\treturn values;\t\t}\t\telse{\t\t\treturn Collections.singletonList(value);\t\t}\t}\tpublic Boolean getSwitch(final Option option, final Boolean defaultValue) {\t\tfinal String value = preferences.get(option.getPreferredName(),null);\t\tif(\"true\".equals(value)){\t\t\treturn Boolean.TRUE;\t\t}\t\telse if(\"false\".equals(value)){\t\t\treturn Boolean.FALSE;\t\t}\t\telse{\t\t\treturn defaultValue;\t\t}\t}\tpublic String getProperty(final String property, final String defaultValue) {\t\treturn preferences.get(property, defaultValue);\t}\tpublic Set getProperties() {\t\ttry {\t\t\treturn new HashSet(Arrays.asList(preferences.keys()));\t\t} catch (BackingStoreException e) {\t\t\treturn Collections.EMPTY_SET;\t\t}\t}\tpublic List getOptions() {\t\ttry {\t\t\tfinal List options = new ArrayList();\t\t\tfinal Iterator keys = Arrays.asList(preferences.keys()).iterator();\t\t\twhile (keys.hasNext()) {\t\t\t\tfinal String trigger = (String) keys.next();\t\t\t\tfinal Option option = root.findOption(trigger);\t\t\t\tif (option != null) {\t\t\t\t\toptions.add(option);\t\t\t\t}\t\t\t}\t\t\treturn Collections.unmodifiableList(options);\t\t} catch (BackingStoreException e) {\t\t\treturn Collections.EMPTY_LIST;\t\t}\t}\tpublic Set getOptionTriggers() {\t\tfinal Set triggers = new HashSet();\t\tfinal Iterator options = getOptions().iterator();\t\twhile(options.hasNext()){\t\t\tfinal Option option = (Option)options.next();\t\t\ttriggers.addAll(option.getTriggers());\t\t}\t\treturn Collections.unmodifiableSet(triggers);\t}}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+import java.util.prefs.BackingStoreException;\n+import java.util.prefs.Preferences;\n+\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * A CommandLine implementation using the Preferences API, useful when\n+ * constructing a complex DefaultingCommandLine\n+ *\n+ * This implementation uses the children of a single preference node to populate\n+ * the CommandLine.  Options are keyed from their preferred name and presence in\n+ * the Preferences object is taken as presence in the CommandLine.  Argument\n+ * values are taken from the Preference value and are optionally separated using\n+ * the separator char defined, at construction time.  Switch values can be\n+ * specified using a simple value of <code>true</code> or <code>false</code>;\n+ * obviously this means that Switches with Arguments are not supported by this\n+ * implementation.\n+ *\n+ * @see java.util.prefs.Preferences\n+ * @see org.apache.commons.cli2.commandline.DefaultingCommandLine\n+ * @see org.apache.commons.cli2.Option#getPreferredName() \n+ */\n+public class PreferencesCommandLine extends CommandLineImpl {\n+\t\n+\tprivate static final char NUL = '\\0';\n+\tprivate final Preferences preferences;\n+\tprivate final Option root;\n+\tprivate final char separator;\n+\t\n+\t/**\n+     * Creates a new PreferencesCommandLine using the specified root Option and\n+     * Preferences node.  Argument values will be separated using the char 0.\n+     * \n+\t * @param root the CommandLine's root Option\n+\t * @param preferences the Preferences node to get values from\n+\t */\n+\tpublic PreferencesCommandLine(final Option root, final Preferences preferences){\n+\t\tthis(root,preferences,NUL);\n+\t}\n+\t\n+    /**\n+     * Creates a new PreferencesCommandLine using the specified root Option,\n+     * Preferences node and value separator.\n+     * \n+     * @param root the CommandLine's root Option\n+     * @param preferences the Preferences node to get values from\n+     * @param separator the character to split argument values\n+     */\n+\tpublic PreferencesCommandLine(final Option root, final Preferences preferences, final char separator){\n+\t\tthis.root = root;\n+\t\tthis.preferences = preferences;\n+\t\tthis.separator = separator;\n+\t}\n+\t\n+\tpublic boolean hasOption(Option option) {\n+\t\tif(option==null){\n+\t\t\treturn false;\n+\t\t}\n+\t\telse{\n+\t\t\ttry {\n+\t\t\t\treturn Arrays.asList(preferences.keys()).contains(option.getPreferredName());\n+\t\t\t} catch (BackingStoreException e) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic Option getOption(String trigger) {\n+\t\treturn root.findOption(trigger);\n+\t}\n+\n+\tpublic List getValues(final Option option, final List defaultValues) {\n+\t\tfinal String value = preferences.get(option.getPreferredName(),null);\n+\t\t\n+\t\tif(value==null){\n+\t\t\treturn defaultValues;\n+\t\t}\n+\t\telse if(separator>NUL){\n+\t\t\tfinal List values = new ArrayList();\n+\t\t\tfinal StringTokenizer tokens = new StringTokenizer(value,String.valueOf(separator));\n+\t\t\t\n+\t\t\twhile(tokens.hasMoreTokens()){\n+\t\t\t\tvalues.add(tokens.nextToken());\n+\t\t\t}\n+\t\t\t\n+\t\t\treturn values;\n+\t\t}\n+\t\telse{\n+\t\t\treturn Collections.singletonList(value);\n+\t\t}\n+\t}\n+\n+\tpublic Boolean getSwitch(final Option option, final Boolean defaultValue) {\n+\t\tfinal String value = preferences.get(option.getPreferredName(),null);\n+\t\tif(\"true\".equals(value)){\n+\t\t\treturn Boolean.TRUE;\n+\t\t}\n+\t\telse if(\"false\".equals(value)){\n+\t\t\treturn Boolean.FALSE;\n+\t\t}\n+\t\telse{\n+\t\t\treturn defaultValue;\n+\t\t}\n+\t}\n+\t\n+\tpublic String getProperty(final String property, final String defaultValue) {\n+\t\treturn preferences.get(property, defaultValue);\n+\t}\n+\n+\tpublic Set getProperties() {\n+\t\ttry {\n+\t\t\treturn new HashSet(Arrays.asList(preferences.keys()));\n+\t\t} catch (BackingStoreException e) {\n+\t\t\treturn Collections.EMPTY_SET;\n+\t\t}\n+\t}\n+\n+\tpublic List getOptions() {\n+\t\ttry {\n+\t\t\tfinal List options = new ArrayList();\n+\t\t\tfinal Iterator keys = Arrays.asList(preferences.keys()).iterator();\n+\t\t\twhile (keys.hasNext()) {\n+\t\t\t\tfinal String trigger = (String) keys.next();\n+\t\t\t\tfinal Option option = root.findOption(trigger);\n+\t\t\t\tif (option != null) {\n+\t\t\t\t\toptions.add(option);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn Collections.unmodifiableList(options);\n+\t\t} catch (BackingStoreException e) {\n+\t\t\treturn Collections.EMPTY_LIST;\n+\t\t}\n+\t}\n+\n+\tpublic Set getOptionTriggers() {\n+\t\tfinal Set triggers = new HashSet();\n+\t\tfinal Iterator options = getOptions().iterator();\n+\t\twhile(options.hasNext()){\n+\t\t\tfinal Option option = (Option)options.next();\n+\t\t\ttriggers.addAll(option.getTriggers());\n+\t\t}\n+\t\treturn Collections.unmodifiableSet(triggers);\n+\t}\n+}\n--- a/src/java/org/apache/commons/cli2/commandline/PropertiesCommandLine.java\n+++ b/src/java/org/apache/commons/cli2/commandline/PropertiesCommandLine.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.ArrayList;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Properties;import java.util.Set;import java.util.StringTokenizer;import org.apache.commons.cli2.Option;/** * A CommandLine implementation using a java Properties instance, useful for * constructing a complex DefaultingCommandLine * * Options are keyed from their property name and presence in the Properties * instance is taken as presence in the CommandLine.  Argument values are taken * from the property value and are optionally separated using the separator * char, defined at construction time.  Switch values can be specified using a * simple value of <code>true</code> or <code>false</code>; obviously this means * that Switches with Arguments are not supported by this implementation. * * @see java.util.Properties * @see org.apache.commons.cli2.commandline.DefaultingCommandLine * @see org.apache.commons.cli2.Option#getPreferredName() */public class PropertiesCommandLine extends CommandLineImpl {\tprivate static final char NUL = '\\0';\tprivate final Properties properties;\tprivate final Option root;\tprivate final char separator;    /**     * Creates a new PropertiesCommandLine using the specified root Option,     * Properties instance.  The character 0 is used as the value separator.     *     * @param root the CommandLine's root Option     * @param properties the Properties instance to get values from     */\tpublic PropertiesCommandLine(final Option root, final Properties properties){\t\tthis(root,properties,NUL);\t}    /**     * Creates a new PropertiesCommandLine using the specified root Option,     * Properties instance and value separator.     *     * @param root the CommandLine's root Option     * @param properties the Properties instance to get values from     * @param separator the character to split argument values     */\tpublic PropertiesCommandLine(final Option root, final Properties properties, final char separator){\t\tthis.root = root;\t\tthis.properties = properties;\t\tthis.separator = separator;\t}\tpublic boolean hasOption(Option option) {\t\tif(option==null){\t\t\treturn false;\t\t}\t\telse{\t\t\treturn properties.containsKey(option.getPreferredName());\t\t}\t}\tpublic Option getOption(String trigger) {\t\treturn root.findOption(trigger);\t}\tpublic List getValues(final Option option, final List defaultValues) {\t\tfinal String value = properties.getProperty(option.getPreferredName());\t\tif(value==null){\t\t\treturn defaultValues;\t\t}\t\telse if(separator>NUL){\t\t\tfinal List values = new ArrayList();\t\t\tfinal StringTokenizer tokens = new StringTokenizer(value,String.valueOf(separator));\t\t\twhile(tokens.hasMoreTokens()){\t\t\t\tvalues.add(tokens.nextToken());\t\t\t}\t\t\treturn values;\t\t}\t\telse{\t\t\treturn Collections.singletonList(value);\t\t}\t}\tpublic Boolean getSwitch(final Option option, final Boolean defaultValue) {\t\tfinal String value = properties.getProperty(option.getPreferredName());\t\tif(\"true\".equals(value)){\t\t\treturn Boolean.TRUE;\t\t}\t\telse if(\"false\".equals(value)){\t\t\treturn Boolean.FALSE;\t\t}\t\telse{\t\t\treturn defaultValue;\t\t}\t}\tpublic String getProperty(final String property, final String defaultValue) {\t\treturn properties.getProperty(property,defaultValue);\t}\tpublic Set getProperties() {\t\treturn properties.keySet();\t}\tpublic List getOptions() {\t\tfinal List options = new ArrayList();\t\tfinal Iterator keys = properties.keySet().iterator();\t\twhile(keys.hasNext()){\t\t\tfinal String trigger = (String)keys.next();\t\t\tfinal Option option = root.findOption(trigger);\t\t\tif(option!=null){\t\t\t\toptions.add(option);\t\t\t}\t\t}\t\treturn Collections.unmodifiableList(options);\t}\tpublic Set getOptionTriggers() {\t\tfinal Set triggers = new HashSet();\t\tfinal Iterator options = getOptions().iterator();\t\twhile(options.hasNext()){\t\t\tfinal Option option = (Option)options.next();\t\t\ttriggers.addAll(option.getTriggers());\t\t}\t\treturn Collections.unmodifiableSet(triggers);\t}}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * A CommandLine implementation using a java Properties instance, useful for\n+ * constructing a complex DefaultingCommandLine\n+ *\n+ * Options are keyed from their property name and presence in the Properties\n+ * instance is taken as presence in the CommandLine.  Argument values are taken\n+ * from the property value and are optionally separated using the separator\n+ * char, defined at construction time.  Switch values can be specified using a\n+ * simple value of <code>true</code> or <code>false</code>; obviously this means\n+ * that Switches with Arguments are not supported by this implementation.\n+ *\n+ * @see java.util.Properties\n+ * @see org.apache.commons.cli2.commandline.DefaultingCommandLine\n+ * @see org.apache.commons.cli2.Option#getPreferredName() \n+ */\n+public class PropertiesCommandLine extends CommandLineImpl {\n+\t\n+\tprivate static final char NUL = '\\0';\n+\tprivate final Properties properties;\n+\tprivate final Option root;\n+\tprivate final char separator;\n+\t\n+    /**\n+     * Creates a new PropertiesCommandLine using the specified root Option,\n+     * Properties instance.  The character 0 is used as the value separator.\n+     *\n+     * @param root the CommandLine's root Option\n+     * @param properties the Properties instance to get values from\n+     */\n+\tpublic PropertiesCommandLine(final Option root, final Properties properties){\n+\t\tthis(root,properties,NUL);\n+\t}\n+\t\n+    /**\n+     * Creates a new PropertiesCommandLine using the specified root Option,\n+     * Properties instance and value separator.\n+     *\n+     * @param root the CommandLine's root Option\n+     * @param properties the Properties instance to get values from\n+     * @param separator the character to split argument values\n+     */\n+\tpublic PropertiesCommandLine(final Option root, final Properties properties, final char separator){\n+\t\tthis.root = root;\n+\t\tthis.properties = properties;\n+\t\tthis.separator = separator;\n+\t}\n+\t\n+\n+\tpublic boolean hasOption(Option option) {\n+\t\tif(option==null){\n+\t\t\treturn false;\n+\t\t}\n+\t\telse{\n+\t\t\treturn properties.containsKey(option.getPreferredName());\n+\t\t}\n+\t}\n+\n+\tpublic Option getOption(String trigger) {\n+\t\treturn root.findOption(trigger);\n+\t}\n+\n+\tpublic List getValues(final Option option, final List defaultValues) {\n+\t\tfinal String value = properties.getProperty(option.getPreferredName());\n+\t\t\n+\t\tif(value==null){\n+\t\t\treturn defaultValues;\n+\t\t}\n+\t\telse if(separator>NUL){\n+\t\t\tfinal List values = new ArrayList();\n+\t\t\tfinal StringTokenizer tokens = new StringTokenizer(value,String.valueOf(separator));\n+\t\t\t\n+\t\t\twhile(tokens.hasMoreTokens()){\n+\t\t\t\tvalues.add(tokens.nextToken());\n+\t\t\t}\n+\t\t\t\n+\t\t\treturn values;\n+\t\t}\n+\t\telse{\n+\t\t\treturn Collections.singletonList(value);\n+\t\t}\n+\t}\n+\n+\tpublic Boolean getSwitch(final Option option, final Boolean defaultValue) {\n+\t\tfinal String value = properties.getProperty(option.getPreferredName());\n+\t\tif(\"true\".equals(value)){\n+\t\t\treturn Boolean.TRUE;\n+\t\t}\n+\t\telse if(\"false\".equals(value)){\n+\t\t\treturn Boolean.FALSE;\n+\t\t}\n+\t\telse{\n+\t\t\treturn defaultValue;\n+\t\t}\n+\t}\n+\t\n+\tpublic String getProperty(final String property, final String defaultValue) {\n+\t\treturn properties.getProperty(property,defaultValue);\n+\t}\n+\n+\tpublic Set getProperties() {\n+\t\treturn properties.keySet();\n+\t}\n+\n+\tpublic List getOptions() {\n+\t\tfinal List options = new ArrayList();\n+\t\tfinal Iterator keys = properties.keySet().iterator();\n+\t\twhile(keys.hasNext()){\n+\t\t\tfinal String trigger = (String)keys.next();\n+\t\t\tfinal Option option = root.findOption(trigger);\n+\t\t\tif(option!=null){\n+\t\t\t\toptions.add(option);\n+\t\t\t}\n+\t\t}\n+\t\treturn Collections.unmodifiableList(options);\n+\t}\n+\n+\tpublic Set getOptionTriggers() {\n+\t\tfinal Set triggers = new HashSet();\n+\t\tfinal Iterator options = getOptions().iterator();\n+\t\twhile(options.hasNext()){\n+\t\t\tfinal Option option = (Option)options.next();\n+\t\t\ttriggers.addAll(option.getTriggers());\n+\t\t}\n+\t\treturn Collections.unmodifiableSet(triggers);\n+\t}\n+}\n--- a/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * A WriteableCommandLine implementation allowing Options to write their * processed information to a CommandLine. */public class WriteableCommandLineImpl    extends CommandLineImpl implements WriteableCommandLine {    private final Properties properties = new Properties();    private final List options = new ArrayList();    private final Map nameToOption = new HashMap();    private final Map values = new HashMap();    private final Map switches = new HashMap();    private final Map defaultValues = new HashMap();    private final Map defaultSwitches = new HashMap();    private final List normalised;    private final Set prefixes;    /**     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to     * hold the parsed arguments.     *     * @param rootOption the CommandLine's root Option     * @param arguments the arguments this CommandLine represents     */    public WriteableCommandLineImpl(final Option rootOption,                                    final List arguments) {        this.prefixes = rootOption.getPrefixes();        this.normalised = arguments;    }    public void addOption(Option option) {        options.add(option);        nameToOption.put(option.getPreferredName(), option);        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {            nameToOption.put(i.next(), option);        }    }    public void addValue(final Option option,                         final Object value) {        if (option instanceof Argument) {            addOption(option);        }        List valueList = (List) values.get(option);        if (valueList == null) {            valueList = new ArrayList();            values.put(option, valueList);        }        valueList.add(value);    }    public void addSwitch(final Option option,                          final boolean value) {        addOption(option);        if (switches.containsKey(option)) {            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));        } else {            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);        }    }    public boolean hasOption(final Option option) {        final boolean present = options.contains(option);        return present;    }    public Option getOption(final String trigger) {        return (Option) nameToOption.get(trigger);    }    public List getValues(final Option option,                          final List defaultValues) {        // First grab the command line values        List valueList = (List) values.get(option);        // Secondly try the defaults supplied to the method        if ((valueList == null) || valueList.isEmpty()) {            valueList = defaultValues;        }        // Thirdly try the option's default values        if ((valueList == null) || valueList.isEmpty()) {            valueList = (List) this.defaultValues.get(option);        }        // Finally use an empty list        if (valueList == null) {            valueList = Collections.EMPTY_LIST;        }        return valueList;    }    public Boolean getSwitch(final Option option,                             final Boolean defaultValue) {        // First grab the command line values        Boolean bool = (Boolean) switches.get(option);        // Secondly try the defaults supplied to the method        if (bool == null) {            bool = defaultValue;        }        // Thirdly try the option's default values        if (bool == null) {            bool = (Boolean) this.defaultSwitches.get(option);        }        return bool;    }    public void addProperty(final String property,                            final String value) {        properties.setProperty(property, value);    }    public String getProperty(final String property,                              final String defaultValue) {        return properties.getProperty(property, defaultValue);    }    public Set getProperties() {        return Collections.unmodifiableSet(properties.keySet());    }    public boolean looksLikeOption(final String trigger) {        for (final Iterator i = prefixes.iterator(); i.hasNext();) {            final String prefix = (String) i.next();            if (trigger.startsWith(prefix)) {                return true;            }        }        return false;    }    public String toString() {        final StringBuffer buffer = new StringBuffer();        // need to add group header        for (final Iterator i = normalised.iterator(); i.hasNext();) {            final String arg = (String) i.next();            if (arg.indexOf(' ') >= 0) {                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");            } else {                buffer.append(arg);            }            if (i.hasNext()) {                buffer.append(' ');            }        }        return buffer.toString();    }    public List getOptions() {        return Collections.unmodifiableList(options);    }    public Set getOptionTriggers() {        return Collections.unmodifiableSet(nameToOption.keySet());    }    public void setDefaultValues(final Option option,                                 final List defaults) {        if (defaults == null) {            defaultValues.remove(option);        } else {            defaultValues.put(option, defaults);        }    }    public void setDefaultSwitch(final Option option,                                 final Boolean defaultSwitch) {        if (defaultSwitch == null) {            defaultSwitches.remove(option);        } else {            defaultSwitches.put(option, defaultSwitch);        }    }    public List getNormalised() {        return Collections.unmodifiableList(normalised);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * A WriteableCommandLine implementation allowing Options to write their\n+ * processed information to a CommandLine.\n+ */\n+public class WriteableCommandLineImpl\n+    extends CommandLineImpl implements WriteableCommandLine {\n+    private final Properties properties = new Properties();\n+    private final List options = new ArrayList();\n+    private final Map nameToOption = new HashMap();\n+    private final Map values = new HashMap();\n+    private final Map switches = new HashMap();\n+    private final Map defaultValues = new HashMap();\n+    private final Map defaultSwitches = new HashMap();\n+    private final List normalised;\n+    private final Set prefixes;\n+\n+    /**\n+     * Creates a new WriteableCommandLineImpl rooted on the specified Option, to\n+     * hold the parsed arguments.\n+     *\n+     * @param rootOption the CommandLine's root Option\n+     * @param arguments the arguments this CommandLine represents\n+     */\n+    public WriteableCommandLineImpl(final Option rootOption,\n+                                    final List arguments) {\n+        this.prefixes = rootOption.getPrefixes();\n+        this.normalised = arguments;\n+    }\n+\n+    public void addOption(Option option) {\n+        options.add(option);\n+        nameToOption.put(option.getPreferredName(), option);\n+\n+        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n+            nameToOption.put(i.next(), option);\n+        }\n+    }\n+\n+    public void addValue(final Option option,\n+                         final Object value) {\n+        if (option instanceof Argument) {\n+            addOption(option);\n+        }\n+\n+        List valueList = (List) values.get(option);\n+\n+        if (valueList == null) {\n+            valueList = new ArrayList();\n+            values.put(option, valueList);\n+        }\n+\n+        valueList.add(value);\n+    }\n+\n+    public void addSwitch(final Option option,\n+                          final boolean value) {\n+        addOption(option);\n+\n+        if (switches.containsKey(option)) {\n+            throw new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n+        } else {\n+            switches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n+        }\n+    }\n+\n+    public boolean hasOption(final Option option) {\n+        final boolean present = options.contains(option);\n+\n+        return present;\n+    }\n+\n+    public Option getOption(final String trigger) {\n+        return (Option) nameToOption.get(trigger);\n+    }\n+\n+    public List getValues(final Option option,\n+                          final List defaultValues) {\n+        // First grab the command line values\n+        List valueList = (List) values.get(option);\n+\n+        // Secondly try the defaults supplied to the method\n+        if ((valueList == null) || valueList.isEmpty()) {\n+            valueList = defaultValues;\n+        }\n+\n+        // Thirdly try the option's default values\n+        if ((valueList == null) || valueList.isEmpty()) {\n+            valueList = (List) this.defaultValues.get(option);\n+        }\n+\n+        // Finally use an empty list\n+        if (valueList == null) {\n+            valueList = Collections.EMPTY_LIST;\n+        }\n+\n+        return valueList;\n+    }\n+\n+    public Boolean getSwitch(final Option option,\n+                             final Boolean defaultValue) {\n+        // First grab the command line values\n+        Boolean bool = (Boolean) switches.get(option);\n+\n+        // Secondly try the defaults supplied to the method\n+        if (bool == null) {\n+            bool = defaultValue;\n+        }\n+\n+        // Thirdly try the option's default values\n+        if (bool == null) {\n+            bool = (Boolean) this.defaultSwitches.get(option);\n+        }\n+\n+        return bool;\n+    }\n+\n+    public void addProperty(final String property,\n+                            final String value) {\n+        properties.setProperty(property, value);\n+    }\n+\n+    public String getProperty(final String property,\n+                              final String defaultValue) {\n+        return properties.getProperty(property, defaultValue);\n+    }\n+\n+    public Set getProperties() {\n+        return Collections.unmodifiableSet(properties.keySet());\n+    }\n+\n+    public boolean looksLikeOption(final String trigger) {\n+        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n+            final String prefix = (String) i.next();\n+\n+            if (trigger.startsWith(prefix)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    public String toString() {\n+        final StringBuffer buffer = new StringBuffer();\n+\n+        // need to add group header\n+        for (final Iterator i = normalised.iterator(); i.hasNext();) {\n+            final String arg = (String) i.next();\n+\n+            if (arg.indexOf(' ') >= 0) {\n+                buffer.append(\"\\\"\").append(arg).append(\"\\\"\");\n+            } else {\n+                buffer.append(arg);\n+            }\n+\n+            if (i.hasNext()) {\n+                buffer.append(' ');\n+            }\n+        }\n+\n+        return buffer.toString();\n+    }\n+\n+    public List getOptions() {\n+        return Collections.unmodifiableList(options);\n+    }\n+\n+    public Set getOptionTriggers() {\n+        return Collections.unmodifiableSet(nameToOption.keySet());\n+    }\n+\n+    public void setDefaultValues(final Option option,\n+                                 final List defaults) {\n+        if (defaults == null) {\n+            defaultValues.remove(option);\n+        } else {\n+            defaultValues.put(option, defaults);\n+        }\n+    }\n+\n+    public void setDefaultSwitch(final Option option,\n+                                 final Boolean defaultSwitch) {\n+        if (defaultSwitch == null) {\n+            defaultSwitches.remove(option);\n+        } else {\n+            defaultSwitches.put(option, defaultSwitch);\n+        }\n+    }\n+\n+    public List getNormalised() {\n+        return Collections.unmodifiableList(normalised);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/ArgumentImpl.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.ListIterator;import java.util.Set;import java.util.StringTokenizer;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;import org.apache.commons.cli2.validation.InvalidArgumentException;import org.apache.commons.cli2.validation.Validator;/** * An implementation of an Argument. */public class ArgumentImpl    extends OptionImpl implements Argument {    private static final char NUL = '\\0';    /**     * The default value for the initial separator char.     */    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;    /**     * The default value for the subsequent separator char.     */    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;    /**     * The default token to indicate that remaining arguments should be consumed     * as values.     */    public static final String DEFAULT_CONSUME_REMAINING = \"--\";    private final String name;    private final String description;    private final int minimum;    private final int maximum;    private final char initialSeparator;    private final char subsequentSeparator;    private final boolean subsequentSplit;    private final Validator validator;    private final String consumeRemaining;    private final List defaultValues;    private final ResourceHelper resources = ResourceHelper.getResourceHelper();    /**     * Creates a new Argument instance.     *     * @param name     *            The name of the argument     * @param description     *            A description of the argument     * @param minimum     *            The minimum number of values needed to be valid     * @param maximum     *            The maximum number of values allowed to be valid     * @param initialSeparator     *            The char separating option from value     * @param subsequentSeparator     *            The char separating values from each other     * @param validator     *            The object responsible for validating the values     * @param consumeRemaining     *            The String used for the \"consuming option\" group     * @param valueDefaults     *            The values to be used if none are specified.     * @param id     *            The id of the option, 0 implies automatic assignment.     *     * @see OptionImpl#OptionImpl(int,boolean)     */    public ArgumentImpl(final String name,                        final String description,                        final int minimum,                        final int maximum,                        final char initialSeparator,                        final char subsequentSeparator,                        final Validator validator,                        final String consumeRemaining,                        final List valueDefaults,                        final int id) {        super(id, false);        this.name = (name == null) ? \"arg\" : name;        this.description = description;        this.minimum = minimum;        this.maximum = maximum;        this.initialSeparator = initialSeparator;        this.subsequentSeparator = subsequentSeparator;        this.subsequentSplit = subsequentSeparator != NUL;        this.validator = validator;        this.consumeRemaining = consumeRemaining;        this.defaultValues = valueDefaults;        if (minimum > maximum) {            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));        }        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {            if (valueDefaults.size() < minimum) {                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));            }            if (valueDefaults.size() > maximum) {                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));            }        }    }    public String getPreferredName() {        return name;    }    public void processValues(final WriteableCommandLine commandLine,                              final ListIterator arguments,                              final Option option)        throws OptionException {        int argumentCount = commandLine.getValues(option, Collections.EMPTY_LIST).size();        while (arguments.hasNext() && (argumentCount < maximum)) {            final String allValuesQuoted = (String) arguments.next();            final String allValues = stripBoundaryQuotes(allValuesQuoted);            // should we ignore things that look like options?            if (allValuesQuoted.equals(consumeRemaining)) {                while (arguments.hasNext() && (argumentCount < maximum)) {                    ++argumentCount;                    commandLine.addValue(option, arguments.next());                }            }            // does it look like an option?            else if (commandLine.looksLikeOption(allValuesQuoted)) {                arguments.previous();                break;            }            // should we split the string up?            else if (subsequentSplit) {                final StringTokenizer values =                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));                arguments.remove();                while (values.hasMoreTokens() && (argumentCount < maximum)) {                    ++argumentCount;                    final String token = values.nextToken();                    commandLine.addValue(option, token);                    arguments.add(token);                }                if (values.hasMoreTokens()) {                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,                                              values.nextToken());                }            }            // it must be a value as it is            else {                ++argumentCount;                commandLine.addValue(option, allValues);            }        }    }    public boolean canProcess(final WriteableCommandLine commandLine,                              final String arg) {        return true;    }    public Set getPrefixes() {        return Collections.EMPTY_SET;    }    public void process(WriteableCommandLine commandLine,                        ListIterator args)        throws OptionException {        processValues(commandLine, args, this);    }    public char getInitialSeparator() {        return this.initialSeparator;    }    public char getSubsequentSeparator() {        return this.subsequentSeparator;    }    public Set getTriggers() {        return Collections.EMPTY_SET;    }    public String getConsumeRemaining() {    \treturn this.consumeRemaining;    }    public List getDefaultValues() {    \treturn this.defaultValues;    }    public Validator getValidator() {    \treturn this.validator;    }    public void validate(final WriteableCommandLine commandLine)        throws OptionException {        validate(commandLine, this);    }    public void validate(final WriteableCommandLine commandLine,                         final Option option)        throws OptionException {        final List values = commandLine.getValues(option);        if (values.size() < minimum) {            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);        }        if (values.size() > maximum) {            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,                                      (String) values.get(maximum));        }        if (validator != null) {            try {                validator.validate(values);            } catch (InvalidArgumentException ive) {                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,                                          ive.getMessage());            }        }    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        // do we display the outer optionality        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);        // allow numbering if multiple args        final boolean numbered =            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);        // if infinite args are allowed then crop the list        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;        int i = 0;        // for each argument        while (i < max) {            // if we're past the first add a space            if (i > 0) {                buffer.append(' ');            }            // if the next arg is optional            if ((i >= minimum) && (optional || (i > 0))) {                buffer.append('[');            }            if (bracketed) {                buffer.append('<');            }            // add name            buffer.append(name);            ++i;            // if numbering            if (numbered) {                buffer.append(i);            }            if (bracketed) {                buffer.append('>');            }        }        // if infinite args are allowed        if (maximum == Integer.MAX_VALUE) {            // append elipsis            buffer.append(\" ...\");        }        // for each argument        while (i > 0) {            --i;            // if the next arg is optional            if ((i >= minimum) && (optional || (i > 0))) {                buffer.append(']');            }        }    }    public String getDescription() {        return description;    }    public List helpLines(final int depth,                          final Set helpSettings,                          final Comparator comp) {        final HelpLine helpLine = new HelpLineImpl(this, depth);        return Collections.singletonList(helpLine);    }    public int getMaximum() {        return maximum;    }    public int getMinimum() {        return minimum;    }    /**     * If there are any leading or trailing quotes remove them from the     * specified token.     *     * @param token     *            the token to strip leading and trailing quotes     *     * @return String the possibly modified token     */    public String stripBoundaryQuotes(String token) {        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {            return token;        }        token = token.substring(1, token.length() - 1);        return token;    }    public boolean isRequired() {        return getMinimum() > 0;    }    public void defaults(final WriteableCommandLine commandLine) {        super.defaults(commandLine);        defaultValues(commandLine, this);    }    public void defaultValues(final WriteableCommandLine commandLine,                              final Option option) {        commandLine.setDefaultValues(option, defaultValues);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+import org.apache.commons.cli2.validation.InvalidArgumentException;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+/**\n+ * An implementation of an Argument.\n+ */\n+public class ArgumentImpl\n+    extends OptionImpl implements Argument {\n+    private static final char NUL = '\\0';\n+\n+    /**\n+     * The default value for the initial separator char.\n+     */\n+    public static final char DEFAULT_INITIAL_SEPARATOR = NUL;\n+\n+    /**\n+     * The default value for the subsequent separator char.\n+     */\n+    public static final char DEFAULT_SUBSEQUENT_SEPARATOR = NUL;\n+\n+    /**\n+     * The default token to indicate that remaining arguments should be consumed\n+     * as values.\n+     */\n+    public static final String DEFAULT_CONSUME_REMAINING = \"--\";\n+    private final String name;\n+    private final String description;\n+    private final int minimum;\n+    private final int maximum;\n+    private final char initialSeparator;\n+    private final char subsequentSeparator;\n+    private final boolean subsequentSplit;\n+    private final Validator validator;\n+    private final String consumeRemaining;\n+    private final List defaultValues;\n+    private final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    /**\n+     * Creates a new Argument instance.\n+     *\n+     * @param name\n+     *            The name of the argument\n+     * @param description\n+     *            A description of the argument\n+     * @param minimum\n+     *            The minimum number of values needed to be valid\n+     * @param maximum\n+     *            The maximum number of values allowed to be valid\n+     * @param initialSeparator\n+     *            The char separating option from value\n+     * @param subsequentSeparator\n+     *            The char separating values from each other\n+     * @param validator\n+     *            The object responsible for validating the values\n+     * @param consumeRemaining\n+     *            The String used for the \"consuming option\" group\n+     * @param valueDefaults\n+     *            The values to be used if none are specified.\n+     * @param id\n+     *            The id of the option, 0 implies automatic assignment.\n+     *\n+     * @see OptionImpl#OptionImpl(int,boolean)\n+     */\n+    public ArgumentImpl(final String name,\n+                        final String description,\n+                        final int minimum,\n+                        final int maximum,\n+                        final char initialSeparator,\n+                        final char subsequentSeparator,\n+                        final Validator validator,\n+                        final String consumeRemaining,\n+                        final List valueDefaults,\n+                        final int id) {\n+        super(id, false);\n+\n+        this.name = (name == null) ? \"arg\" : name;\n+        this.description = description;\n+        this.minimum = minimum;\n+        this.maximum = maximum;\n+        this.initialSeparator = initialSeparator;\n+        this.subsequentSeparator = subsequentSeparator;\n+        this.subsequentSplit = subsequentSeparator != NUL;\n+        this.validator = validator;\n+        this.consumeRemaining = consumeRemaining;\n+        this.defaultValues = valueDefaults;\n+\n+        if (minimum > maximum) {\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n+        }\n+\n+        if ((valueDefaults != null) && (valueDefaults.size() > 0)) {\n+            if (valueDefaults.size() < minimum) {\n+                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n+            }\n+\n+            if (valueDefaults.size() > maximum) {\n+                throw new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n+            }\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return name;\n+    }\n+\n+    public void processValues(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments,\n+                              final Option option)\n+        throws OptionException {\n+        int argumentCount = commandLine.getValues(option, Collections.EMPTY_LIST).size();\n+\n+        while (arguments.hasNext() && (argumentCount < maximum)) {\n+            final String allValuesQuoted = (String) arguments.next();\n+            final String allValues = stripBoundaryQuotes(allValuesQuoted);\n+\n+            // should we ignore things that look like options?\n+            if (allValuesQuoted.equals(consumeRemaining)) {\n+                while (arguments.hasNext() && (argumentCount < maximum)) {\n+                    ++argumentCount;\n+                    commandLine.addValue(option, arguments.next());\n+                }\n+            }\n+            // does it look like an option?\n+            else if (commandLine.looksLikeOption(allValuesQuoted)) {\n+                arguments.previous();\n+\n+                break;\n+            }\n+            // should we split the string up?\n+            else if (subsequentSplit) {\n+                final StringTokenizer values =\n+                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n+\n+                arguments.remove();\n+\n+                while (values.hasMoreTokens() && (argumentCount < maximum)) {\n+                    ++argumentCount;\n+\n+                    final String token = values.nextToken();\n+                    commandLine.addValue(option, token);\n+                    arguments.add(token);\n+                }\n+\n+                if (values.hasMoreTokens()) {\n+                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n+                                              values.nextToken());\n+                }\n+            }\n+            // it must be a value as it is\n+            else {\n+                ++argumentCount;\n+                commandLine.addValue(option, allValues);\n+            }\n+        }\n+    }\n+\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String arg) {\n+        return true;\n+    }\n+\n+    public Set getPrefixes() {\n+        return Collections.EMPTY_SET;\n+    }\n+\n+    public void process(WriteableCommandLine commandLine,\n+                        ListIterator args)\n+        throws OptionException {\n+        processValues(commandLine, args, this);\n+    }\n+\n+    public char getInitialSeparator() {\n+        return this.initialSeparator;\n+    }\n+\n+    public char getSubsequentSeparator() {\n+        return this.subsequentSeparator;\n+    }\n+\n+    public Set getTriggers() {\n+        return Collections.EMPTY_SET;\n+    }\n+\n+    public String getConsumeRemaining() {\n+    \treturn this.consumeRemaining;\n+    }\n+    \n+    public List getDefaultValues() {\n+    \treturn this.defaultValues;\n+    }\n+    \n+    public Validator getValidator() {\n+    \treturn this.validator;\n+    }\n+    \n+    public void validate(final WriteableCommandLine commandLine)\n+        throws OptionException {\n+        validate(commandLine, this);\n+    }\n+\n+    public void validate(final WriteableCommandLine commandLine,\n+                         final Option option)\n+        throws OptionException {\n+        final List values = commandLine.getValues(option);\n+\n+        if (values.size() < minimum) {\n+            throw new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n+        }\n+\n+        if (values.size() > maximum) {\n+            throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n+                                      (String) values.get(maximum));\n+        }\n+\n+        if (validator != null) {\n+            try {\n+                validator.validate(values);\n+            } catch (InvalidArgumentException ive) {\n+                throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n+                                          ive.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        // do we display the outer optionality\n+        final boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+\n+        // allow numbering if multiple args\n+        final boolean numbered =\n+            (maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+\n+        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+\n+        // if infinite args are allowed then crop the list\n+        final int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n+\n+        int i = 0;\n+\n+        // for each argument\n+        while (i < max) {\n+            // if we're past the first add a space\n+            if (i > 0) {\n+                buffer.append(' ');\n+            }\n+\n+            // if the next arg is optional\n+            if ((i >= minimum) && (optional || (i > 0))) {\n+                buffer.append('[');\n+            }\n+\n+            if (bracketed) {\n+                buffer.append('<');\n+            }\n+\n+            // add name\n+            buffer.append(name);\n+            ++i;\n+\n+            // if numbering\n+            if (numbered) {\n+                buffer.append(i);\n+            }\n+\n+            if (bracketed) {\n+                buffer.append('>');\n+            }\n+        }\n+\n+        // if infinite args are allowed\n+        if (maximum == Integer.MAX_VALUE) {\n+            // append elipsis\n+            buffer.append(\" ...\");\n+        }\n+\n+        // for each argument\n+        while (i > 0) {\n+            --i;\n+\n+            // if the next arg is optional\n+            if ((i >= minimum) && (optional || (i > 0))) {\n+                buffer.append(']');\n+            }\n+        }\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public List helpLines(final int depth,\n+                          final Set helpSettings,\n+                          final Comparator comp) {\n+        final HelpLine helpLine = new HelpLineImpl(this, depth);\n+\n+        return Collections.singletonList(helpLine);\n+    }\n+\n+    public int getMaximum() {\n+        return maximum;\n+    }\n+\n+    public int getMinimum() {\n+        return minimum;\n+    }\n+\n+    /**\n+     * If there are any leading or trailing quotes remove them from the\n+     * specified token.\n+     *\n+     * @param token\n+     *            the token to strip leading and trailing quotes\n+     *\n+     * @return String the possibly modified token\n+     */\n+    public String stripBoundaryQuotes(String token) {\n+        if (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\n+            return token;\n+        }\n+\n+        token = token.substring(1, token.length() - 1);\n+\n+        return token;\n+    }\n+\n+    public boolean isRequired() {\n+        return getMinimum() > 0;\n+    }\n+\n+    public void defaults(final WriteableCommandLine commandLine) {\n+        super.defaults(commandLine);\n+        defaultValues(commandLine, this);\n+    }\n+\n+    public void defaultValues(final WriteableCommandLine commandLine,\n+                              final Option option) {\n+        commandLine.setDefaultValues(option, defaultValues);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/Command.java\n+++ b/src/java/org/apache/commons/cli2/option/Command.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * Represents a cvs \"update\" style command line option. * * Like all Parents, Commands can have child options and can be part of * Arguments */public class Command    extends ParentImpl {    /** The display name for the command */    private final String preferredName;    /** The aliases for this command */    private final Set aliases;    /** All the names for this command */    private final Set triggers;    /**     * Creates a new Command instance.     *     * @param preferredName     *            The name normally used to refer to the Command     * @param description     *            A description of the Command     * @param aliases     *            Alternative names for the Command     * @param required     *            Whether the Command is required     * @param argument     *            An Argument that the command takes     * @param children     *            The Group of child options for this Command     * @param id     *            A unique id for the Command     *     * @see ParentImpl#ParentImpl(Argument, Group, String, int, boolean)     */    public Command(final String preferredName,                   final String description,                   final Set aliases,                   final boolean required,                   final Argument argument,                   final Group children,                   final int id) {        super(argument, children, description, id, required);        // check the preferred name is valid        if ((preferredName == null) || (preferredName.length() < 1)) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT));        }        this.preferredName = preferredName;        // gracefully and defensively handle aliases        this.aliases =            (aliases == null) ? Collections.EMPTY_SET                              : Collections.unmodifiableSet(new HashSet(aliases));        // populate the triggers Set        final Set newTriggers = new HashSet();        newTriggers.add(preferredName);        newTriggers.addAll(this.aliases);        this.triggers = Collections.unmodifiableSet(newTriggers);    }    public void processParent(final WriteableCommandLine commandLine,                              final ListIterator arguments)        throws OptionException {        // grab the argument to process        final String arg = (String) arguments.next();        // if we can process it        if (canProcess(commandLine, arg)) {            // then note the option            commandLine.addOption(this);            // normalise the argument list            arguments.set(preferredName);        } else {            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);        }    }    public Set getTriggers() {        return triggers;    }    public void validate(WriteableCommandLine commandLine)        throws OptionException {        if (isRequired() && !commandLine.hasOption(this)) {            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,                                      getPreferredName());        }        super.validate(commandLine);    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        // do we display optionality        final boolean optional =            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);        if (optional) {            buffer.append('[');        }        buffer.append(preferredName);        if (displayAliases && !aliases.isEmpty()) {            buffer.append(\" (\");            final List list = new ArrayList(aliases);            Collections.sort(list);            for (final Iterator i = list.iterator(); i.hasNext();) {                final String alias = (String) i.next();                buffer.append(alias);                if (i.hasNext()) {                    buffer.append(',');                }            }            buffer.append(')');        }        super.appendUsage(buffer, helpSettings, comp);        if (optional) {            buffer.append(']');        }    }    public String getPreferredName() {        return preferredName;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * Represents a cvs \"update\" style command line option.\n+ *\n+ * Like all Parents, Commands can have child options and can be part of\n+ * Arguments\n+ */\n+public class Command\n+    extends ParentImpl {\n+    /** The display name for the command */\n+    private final String preferredName;\n+\n+    /** The aliases for this command */\n+    private final Set aliases;\n+\n+    /** All the names for this command */\n+    private final Set triggers;\n+\n+    /**\n+     * Creates a new Command instance.\n+     *\n+     * @param preferredName\n+     *            The name normally used to refer to the Command\n+     * @param description\n+     *            A description of the Command\n+     * @param aliases\n+     *            Alternative names for the Command\n+     * @param required\n+     *            Whether the Command is required\n+     * @param argument\n+     *            An Argument that the command takes\n+     * @param children\n+     *            The Group of child options for this Command\n+     * @param id\n+     *            A unique id for the Command\n+     *\n+     * @see ParentImpl#ParentImpl(Argument, Group, String, int, boolean)\n+     */\n+    public Command(final String preferredName,\n+                   final String description,\n+                   final Set aliases,\n+                   final boolean required,\n+                   final Argument argument,\n+                   final Group children,\n+                   final int id) {\n+        super(argument, children, description, id, required);\n+\n+        // check the preferred name is valid\n+        if ((preferredName == null) || (preferredName.length() < 1)) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT));\n+        }\n+\n+        this.preferredName = preferredName;\n+\n+        // gracefully and defensively handle aliases\n+        this.aliases =\n+            (aliases == null) ? Collections.EMPTY_SET\n+                              : Collections.unmodifiableSet(new HashSet(aliases));\n+\n+        // populate the triggers Set\n+        final Set newTriggers = new HashSet();\n+        newTriggers.add(preferredName);\n+        newTriggers.addAll(this.aliases);\n+        this.triggers = Collections.unmodifiableSet(newTriggers);\n+    }\n+\n+    public void processParent(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments)\n+        throws OptionException {\n+        // grab the argument to process\n+        final String arg = (String) arguments.next();\n+\n+        // if we can process it\n+        if (canProcess(commandLine, arg)) {\n+            // then note the option\n+            commandLine.addOption(this);\n+\n+            // normalise the argument list\n+            arguments.set(preferredName);\n+        } else {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n+        }\n+    }\n+\n+    public Set getTriggers() {\n+        return triggers;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (isRequired() && !commandLine.hasOption(this)) {\n+            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\n+                                      getPreferredName());\n+        }\n+\n+        super.validate(commandLine);\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        // do we display optionality\n+        final boolean optional =\n+            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+\n+        buffer.append(preferredName);\n+\n+        if (displayAliases && !aliases.isEmpty()) {\n+            buffer.append(\" (\");\n+\n+            final List list = new ArrayList(aliases);\n+            Collections.sort(list);\n+\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final String alias = (String) i.next();\n+                buffer.append(alias);\n+\n+                if (i.hasNext()) {\n+                    buffer.append(',');\n+                }\n+            }\n+\n+            buffer.append(')');\n+        }\n+\n+        super.appendUsage(buffer, helpSettings, comp);\n+\n+        if (optional) {\n+            buffer.append(']');\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return preferredName;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/DefaultOption.java\n+++ b/src/java/org/apache/commons/cli2/option/DefaultOption.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;/** * A Parent implementation representing normal options. */public class DefaultOption    extends ParentImpl {    /**     * The default token used to prefix a short option     */    public static final String DEFAULT_SHORT_PREFIX = \"-\";    /**     * The default token used to prefix a long option     */    public static final String DEFAULT_LONG_PREFIX = \"--\";    /**     * The default value for the burstEnabled constructor parameter     */    public static final boolean DEFAULT_BURST_ENABLED = true;    private final String preferredName;    private final Set aliases;    private final Set burstAliases;    private final Set triggers;    private final Set prefixes;    private final String shortPrefix;    private final boolean burstEnabled;    private final int burstLength;    /**     * Creates a new DefaultOption     *     * @param shortPrefix the prefix used for short options     * @param longPrefix the prefix used for long options     * @param burstEnabled should option bursting be enabled     * @param preferredName the preferred name for this Option, this should begin with either shortPrefix or longPrefix     * @param description a description of this Option     * @param aliases the alternative names for this Option     * @param burstAliases the aliases that can be burst     * @param required whether the Option is strictly required     * @param argument the Argument belonging to this Parent, or null     * @param children the Group children belonging to this Parent, ot null     * @param id the unique identifier for this Option     * @throws IllegalArgumentException if the preferredName or an alias isn't     *     prefixed with shortPrefix or longPrefix     */    public DefaultOption(final String shortPrefix,                         final String longPrefix,                         final boolean burstEnabled,                         final String preferredName,                         final String description,                         final Set aliases,                         final Set burstAliases,                         final boolean required,                         final Argument argument,                         final Group children,                         final int id) {        super(argument, children, description, id, required);        this.shortPrefix = shortPrefix;        this.burstEnabled = burstEnabled;        this.burstLength = shortPrefix.length() + 1;        this.preferredName = preferredName;        this.aliases =            (aliases == null) ? Collections.EMPTY_SET                              : Collections.unmodifiableSet(new HashSet(aliases));        this.burstAliases =            (burstAliases == null) ? Collections.EMPTY_SET                                   : Collections.unmodifiableSet(new HashSet(burstAliases));        final Set newTriggers = new HashSet();        newTriggers.add(preferredName);        newTriggers.addAll(this.aliases);        newTriggers.addAll(this.burstAliases);        this.triggers = Collections.unmodifiableSet(newTriggers);        final Set newPrefixes = new HashSet(super.getPrefixes());        newPrefixes.add(shortPrefix);        newPrefixes.add(longPrefix);        this.prefixes = Collections.unmodifiableSet(newPrefixes);        checkPrefixes(newPrefixes);    }    public boolean canProcess(final WriteableCommandLine commandLine,                              final String argument) {        return (argument != null) &&               (super.canProcess(commandLine, argument) ||               ((argument.length() >= burstLength) &&               burstAliases.contains(argument.substring(0, burstLength))));    }    public void processParent(WriteableCommandLine commandLine,                              ListIterator arguments)        throws OptionException {        final String argument = (String) arguments.next();        if (triggers.contains(argument)) {            commandLine.addOption(this);            arguments.set(preferredName);        } else if (burstEnabled && (argument.length() >= burstLength)) {            final String burst = argument.substring(0, burstLength);            if (burstAliases.contains(burst)) {                commandLine.addOption(this);                //HMM test bursting all vs bursting one by one.                arguments.set(preferredName);                if (getArgument() == null) {                    arguments.add(shortPrefix + argument.substring(burstLength));                } else {                    arguments.add(argument.substring(burstLength));                }                arguments.previous();            } else {                throw new OptionException(this, ResourceConstants.CANNOT_BURST, argument);            }        } else {            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);        }    }    public Set getTriggers() {        return triggers;    }    public Set getPrefixes() {        return prefixes;    }    public void validate(WriteableCommandLine commandLine)        throws OptionException {        if (isRequired() && !commandLine.hasOption(this)) {            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,                                      getPreferredName());        }        super.validate(commandLine);    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        // do we display optionality        final boolean optional =            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);        if (optional) {            buffer.append('[');        }        buffer.append(preferredName);        if (displayAliases && !aliases.isEmpty()) {            buffer.append(\" (\");            final List list = new ArrayList(aliases);            Collections.sort(list);            for (final Iterator i = list.iterator(); i.hasNext();) {                final String alias = (String) i.next();                buffer.append(alias);                if (i.hasNext()) {                    buffer.append(',');                }            }            buffer.append(')');        }        super.appendUsage(buffer, helpSettings, comp);        if (optional) {            buffer.append(']');        }    }    public String getPreferredName() {        return preferredName;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+\n+/**\n+ * A Parent implementation representing normal options.\n+ */\n+public class DefaultOption\n+    extends ParentImpl {\n+    /**\n+     * The default token used to prefix a short option\n+     */\n+    public static final String DEFAULT_SHORT_PREFIX = \"-\";\n+\n+    /**\n+     * The default token used to prefix a long option\n+     */\n+    public static final String DEFAULT_LONG_PREFIX = \"--\";\n+\n+    /**\n+     * The default value for the burstEnabled constructor parameter\n+     */\n+    public static final boolean DEFAULT_BURST_ENABLED = true;\n+    private final String preferredName;\n+    private final Set aliases;\n+    private final Set burstAliases;\n+    private final Set triggers;\n+    private final Set prefixes;\n+    private final String shortPrefix;\n+    private final boolean burstEnabled;\n+    private final int burstLength;\n+\n+    /**\n+     * Creates a new DefaultOption\n+     *\n+     * @param shortPrefix the prefix used for short options\n+     * @param longPrefix the prefix used for long options\n+     * @param burstEnabled should option bursting be enabled\n+     * @param preferredName the preferred name for this Option, this should begin with either shortPrefix or longPrefix\n+     * @param description a description of this Option\n+     * @param aliases the alternative names for this Option\n+     * @param burstAliases the aliases that can be burst\n+     * @param required whether the Option is strictly required\n+     * @param argument the Argument belonging to this Parent, or null\n+     * @param children the Group children belonging to this Parent, ot null\n+     * @param id the unique identifier for this Option\n+     * @throws IllegalArgumentException if the preferredName or an alias isn't\n+     *     prefixed with shortPrefix or longPrefix\n+     */\n+    public DefaultOption(final String shortPrefix,\n+                         final String longPrefix,\n+                         final boolean burstEnabled,\n+                         final String preferredName,\n+                         final String description,\n+                         final Set aliases,\n+                         final Set burstAliases,\n+                         final boolean required,\n+                         final Argument argument,\n+                         final Group children,\n+                         final int id) {\n+        super(argument, children, description, id, required);\n+\n+        this.shortPrefix = shortPrefix;\n+        this.burstEnabled = burstEnabled;\n+\n+        this.burstLength = shortPrefix.length() + 1;\n+\n+        this.preferredName = preferredName;\n+        this.aliases =\n+            (aliases == null) ? Collections.EMPTY_SET\n+                              : Collections.unmodifiableSet(new HashSet(aliases));\n+\n+        this.burstAliases =\n+            (burstAliases == null) ? Collections.EMPTY_SET\n+                                   : Collections.unmodifiableSet(new HashSet(burstAliases));\n+\n+        final Set newTriggers = new HashSet();\n+        newTriggers.add(preferredName);\n+        newTriggers.addAll(this.aliases);\n+        newTriggers.addAll(this.burstAliases);\n+        this.triggers = Collections.unmodifiableSet(newTriggers);\n+\n+        final Set newPrefixes = new HashSet(super.getPrefixes());\n+        newPrefixes.add(shortPrefix);\n+        newPrefixes.add(longPrefix);\n+        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n+\n+        checkPrefixes(newPrefixes);\n+    }\n+\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String argument) {\n+        return (argument != null) &&\n+               (super.canProcess(commandLine, argument) ||\n+               ((argument.length() >= burstLength) &&\n+               burstAliases.contains(argument.substring(0, burstLength))));\n+    }\n+\n+    public void processParent(WriteableCommandLine commandLine,\n+                              ListIterator arguments)\n+        throws OptionException {\n+        final String argument = (String) arguments.next();\n+\n+        if (triggers.contains(argument)) {\n+            commandLine.addOption(this);\n+            arguments.set(preferredName);\n+        } else if (burstEnabled && (argument.length() >= burstLength)) {\n+            final String burst = argument.substring(0, burstLength);\n+\n+            if (burstAliases.contains(burst)) {\n+                commandLine.addOption(this);\n+\n+                //HMM test bursting all vs bursting one by one.\n+                arguments.set(preferredName);\n+\n+                if (getArgument() == null) {\n+                    arguments.add(shortPrefix + argument.substring(burstLength));\n+                } else {\n+                    arguments.add(argument.substring(burstLength));\n+                }\n+\n+                arguments.previous();\n+            } else {\n+                throw new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n+            }\n+        } else {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n+        }\n+    }\n+\n+    public Set getTriggers() {\n+        return triggers;\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (isRequired() && !commandLine.hasOption(this)) {\n+            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\n+                                      getPreferredName());\n+        }\n+\n+        super.validate(commandLine);\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        // do we display optionality\n+        final boolean optional =\n+            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+\n+        buffer.append(preferredName);\n+\n+        if (displayAliases && !aliases.isEmpty()) {\n+            buffer.append(\" (\");\n+\n+            final List list = new ArrayList(aliases);\n+            Collections.sort(list);\n+\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final String alias = (String) i.next();\n+                buffer.append(alias);\n+\n+                if (i.hasNext()) {\n+                    buffer.append(',');\n+                }\n+            }\n+\n+            buffer.append(')');\n+        }\n+\n+        super.appendUsage(buffer, helpSettings, comp);\n+\n+        if (optional) {\n+            buffer.append(']');\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return preferredName;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/GroupImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/GroupImpl.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Map;import java.util.Set;import java.util.SortedMap;import java.util.TreeMap;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;/** * An implementation of Group */public class GroupImpl    extends OptionImpl implements Group {    private final String name;    private final String description;    private final List options;    private final int minimum;    private final int maximum;    private final List anonymous;    private final SortedMap optionMap;    private final Set prefixes;    /**     * Creates a new GroupImpl using the specified parameters.     *     * @param options the Options and Arguments that make up the Group     * @param name the name of this Group, or null     * @param description a description of this Group     * @param minimum the minimum number of Options for a valid CommandLine     * @param maximum the maximum number of Options for a valid CommandLine     */    public GroupImpl(final List options,                     final String name,                     final String description,                     final int minimum,                     final int maximum) {        super(0, false);        this.name = name;        this.description = description;        this.minimum = minimum;        this.maximum = maximum;        // store a copy of the options to be used by the        // help methods        this.options = Collections.unmodifiableList(options);        // anonymous Argument temporary storage        final List newAnonymous = new ArrayList();        // map (key=trigger & value=Option) temporary storage        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());        // prefixes temporary storage        final Set newPrefixes = new HashSet();        // process the options        for (final Iterator i = options.iterator(); i.hasNext();) {            final Option option = (Option) i.next();            if (option instanceof Argument) {                i.remove();                newAnonymous.add(option);            } else {                final Set triggers = option.getTriggers();                for (Iterator j = triggers.iterator(); j.hasNext();) {                    newOptionMap.put(j.next(), option);                }                // store the prefixes                newPrefixes.addAll(option.getPrefixes());            }        }        this.anonymous = Collections.unmodifiableList(newAnonymous);        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);        this.prefixes = Collections.unmodifiableSet(newPrefixes);    }    public boolean canProcess(final WriteableCommandLine commandLine,                              final String arg) {        if (arg == null) {            return false;        }        // if arg does not require bursting        if (optionMap.containsKey(arg)) {            return true;        }        // filter        final Map tailMap = optionMap.tailMap(arg);        // check if bursting is required        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {            final Option option = (Option) iter.next();            if (option.canProcess(commandLine, arg)) {                return true;            }        }        if (commandLine.looksLikeOption(arg)) {            return false;        }        // anonymous argument(s) means we can process it        if (anonymous.size() > 0) {            return true;        }        return false;    }    public Set getPrefixes() {        return prefixes;    }    public Set getTriggers() {        return optionMap.keySet();    }    public void process(final WriteableCommandLine commandLine,                        final ListIterator arguments)        throws OptionException {        String previous = null;        // [START process each command line token        while (arguments.hasNext()) {            // grab the next argument            final String arg = (String) arguments.next();            // if we have just tried to process this instance            if (arg == previous) {                // rollback and abort                arguments.previous();                break;            }            // remember last processed instance            previous = arg;            final Option opt = (Option) optionMap.get(arg);            // option found            if (opt != null) {                arguments.previous();                opt.process(commandLine, arguments);            }            // [START option NOT found            else {                // it might be an anonymous argument continue search                // [START argument may be anonymous                if (commandLine.looksLikeOption(arg)) {                    // narrow the search                    final Collection values = optionMap.tailMap(arg).values();                    boolean foundMemberOption = false;                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {                        final Option option = (Option) i.next();                        if (option.canProcess(commandLine, arg)) {                            foundMemberOption = true;                            arguments.previous();                            option.process(commandLine, arguments);                        }                    }                    // back track and abort this group if necessary                    if (!foundMemberOption) {                        arguments.previous();                        return;                    }                } // [END argument may be anonymous                // [START argument is NOT anonymous                else {                    // move iterator back, current value not used                    arguments.previous();                    // if there are no anonymous arguments then this group can't                    // process the argument                    if (anonymous.isEmpty()) {                        break;                    }                    // TODO: why do we iterate over all anonymous arguments?                    // canProcess will always return true?                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {                        final Argument argument = (Argument) i.next();                        if (argument.canProcess(commandLine, arguments)) {                            argument.process(commandLine, arguments);                        }                    }                } // [END argument is NOT anonymous            } // [END option NOT found        } // [END process each command line token    }    public void validate(final WriteableCommandLine commandLine)        throws OptionException {        // number of options found        int present = 0;        // reference to first unexpected option        Option unexpected = null;        for (final Iterator i = options.iterator(); i.hasNext();) {            final Option option = (Option) i.next();            // if the child option is required then validate it            if (option.isRequired()) {                option.validate(commandLine);            }            if (option instanceof Group) {                option.validate(commandLine);            }            // if the child option is present then validate it            if (commandLine.hasOption(option)) {                if (++present > maximum) {                    unexpected = option;                    break;                }                option.validate(commandLine);            }        }        // too many options        if (unexpected != null) {            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,                                      unexpected.getPreferredName());        }        // too few option        if (present < minimum) {            throw new OptionException(this, ResourceConstants.MISSING_OPTION);        }        // validate each anonymous argument        for (final Iterator i = anonymous.iterator(); i.hasNext();) {            final Option option = (Option) i.next();            option.validate(commandLine);        }    }    public String getPreferredName() {        return name;    }    public String getDescription() {        return description;    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        appendUsage(buffer, helpSettings, comp, \"|\");    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp,                            final String separator) {        final Set helpSettingsCopy = new HashSet(helpSettings);        final boolean optional =            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);        final boolean expanded =            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);        final boolean named =            !expanded ||            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);        final boolean both = named && expanded;        if (optional) {            buffer.append('[');        }        if (named) {            buffer.append(name);        }        if (both) {            buffer.append(\" (\");        }        if (expanded) {            final Set childSettings;            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {                childSettings = DisplaySetting.NONE;            } else {                childSettings = new HashSet(helpSettingsCopy);                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);            }            // grab a list of the group's options.            final List list;            if (comp == null) {                // default to using the initial order                list = options;            } else {                // sort options if comparator is supplied                list = new ArrayList(options);                Collections.sort(list, comp);            }            // for each option.            for (final Iterator i = list.iterator(); i.hasNext();) {                final Option option = (Option) i.next();                // append usage information                option.appendUsage(buffer, childSettings, comp);                // add separators as needed                if (i.hasNext()) {                    buffer.append(separator);                }            }        }        if (both) {            buffer.append(')');        }        if (optional && outer) {            buffer.append(']');        }        if (arguments) {            for (final Iterator i = anonymous.iterator(); i.hasNext();) {                buffer.append(' ');                final Option option = (Option) i.next();                option.appendUsage(buffer, helpSettingsCopy, comp);            }        }        if (optional && !outer) {            buffer.append(']');        }    }    public List helpLines(final int depth,                          final Set helpSettings,                          final Comparator comp) {        final List helpLines = new ArrayList();        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {            final HelpLine helpLine = new HelpLineImpl(this, depth);            helpLines.add(helpLine);        }        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {            // grab a list of the group's options.            final List list;            if (comp == null) {                // default to using the initial order                list = options;            } else {                // sort options if comparator is supplied                list = new ArrayList(options);                Collections.sort(list, comp);            }            // for each option            for (final Iterator i = list.iterator(); i.hasNext();) {                final Option option = (Option) i.next();                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));            }        }        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {            for (final Iterator i = anonymous.iterator(); i.hasNext();) {                final Option option = (Option) i.next();                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));            }        }        return helpLines;    }    /**     * Gets the member Options of thie Group.     * Note this does not include any Arguments     * @return only the non Argument Options of the Group     */    public List getOptions() {        return options;    }    /**     * Gets the anonymous Arguments of this Group.     * @return the Argument options of this Group     */    public List getAnonymous() {        return anonymous;    }    public Option findOption(final String trigger) {        final Iterator i = getOptions().iterator();        while (i.hasNext()) {            final Option option = (Option) i.next();            final Option found = option.findOption(trigger);            if (found != null) {                return found;            }        }        return null;    }    public int getMinimum() {        return minimum;    }    public int getMaximum() {        return maximum;    }    public boolean isRequired() {        return getMinimum() > 0;    }    public void defaults(final WriteableCommandLine commandLine) {        super.defaults(commandLine);        for (final Iterator i = options.iterator(); i.hasNext();) {            final Option option = (Option) i.next();            option.defaults(commandLine);        }        for (final Iterator i = anonymous.iterator(); i.hasNext();) {            final Option option = (Option) i.next();            option.defaults(commandLine);        }    }}class ReverseStringComparator implements Comparator {    private static final Comparator instance = new ReverseStringComparator();    private ReverseStringComparator() {        // just making sure nobody else creates one    }    /**     * Gets a singleton instance of a ReverseStringComparator     * @return the singleton instance     */    public static final Comparator getInstance() {        return instance;    }    public int compare(final Object o1,                       final Object o2) {        final String s1 = (String) o1;        final String s2 = (String) o2;        return -s1.compareTo(s2);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+\n+/**\n+ * An implementation of Group\n+ */\n+public class GroupImpl\n+    extends OptionImpl implements Group {\n+    private final String name;\n+    private final String description;\n+    private final List options;\n+    private final int minimum;\n+    private final int maximum;\n+    private final List anonymous;\n+    private final SortedMap optionMap;\n+    private final Set prefixes;\n+\n+    /**\n+     * Creates a new GroupImpl using the specified parameters.\n+     *\n+     * @param options the Options and Arguments that make up the Group\n+     * @param name the name of this Group, or null\n+     * @param description a description of this Group\n+     * @param minimum the minimum number of Options for a valid CommandLine\n+     * @param maximum the maximum number of Options for a valid CommandLine\n+     */\n+    public GroupImpl(final List options,\n+                     final String name,\n+                     final String description,\n+                     final int minimum,\n+                     final int maximum) {\n+        super(0, false);\n+\n+        this.name = name;\n+        this.description = description;\n+        this.minimum = minimum;\n+        this.maximum = maximum;\n+\n+        // store a copy of the options to be used by the \n+        // help methods\n+        this.options = Collections.unmodifiableList(options);\n+\n+        // anonymous Argument temporary storage\n+        final List newAnonymous = new ArrayList();\n+\n+        // map (key=trigger & value=Option) temporary storage\n+        final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n+\n+        // prefixes temporary storage\n+        final Set newPrefixes = new HashSet();\n+\n+        // process the options\n+        for (final Iterator i = options.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+\n+            if (option instanceof Argument) {\n+                i.remove();\n+                newAnonymous.add(option);\n+            } else {\n+                final Set triggers = option.getTriggers();\n+\n+                for (Iterator j = triggers.iterator(); j.hasNext();) {\n+                    newOptionMap.put(j.next(), option);\n+                }\n+\n+                // store the prefixes\n+                newPrefixes.addAll(option.getPrefixes());\n+            }\n+        }\n+\n+        this.anonymous = Collections.unmodifiableList(newAnonymous);\n+        this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n+        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n+    }\n+\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String arg) {\n+        if (arg == null) {\n+            return false;\n+        }\n+\n+        // if arg does not require bursting\n+        if (optionMap.containsKey(arg)) {\n+            return true;\n+        }\n+\n+        // filter\n+        final Map tailMap = optionMap.tailMap(arg);\n+\n+        // check if bursting is required\n+        for (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\n+            final Option option = (Option) iter.next();\n+\n+            if (option.canProcess(commandLine, arg)) {\n+                return true;\n+            }\n+        }\n+\n+        if (commandLine.looksLikeOption(arg)) {\n+            return false;\n+        }\n+\n+        // anonymous argument(s) means we can process it\n+        if (anonymous.size() > 0) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public Set getTriggers() {\n+        return optionMap.keySet();\n+    }\n+\n+    public void process(final WriteableCommandLine commandLine,\n+                        final ListIterator arguments)\n+        throws OptionException {\n+        String previous = null;\n+\n+        // [START process each command line token\n+        while (arguments.hasNext()) {\n+            // grab the next argument\n+            final String arg = (String) arguments.next();\n+\n+            // if we have just tried to process this instance\n+            if (arg == previous) {\n+                // rollback and abort\n+                arguments.previous();\n+\n+                break;\n+            }\n+\n+            // remember last processed instance\n+            previous = arg;\n+\n+            final Option opt = (Option) optionMap.get(arg);\n+\n+            // option found\n+            if (opt != null) {\n+                arguments.previous();\n+                opt.process(commandLine, arguments);\n+            }\n+            // [START option NOT found\n+            else {\n+                // it might be an anonymous argument continue search\n+                // [START argument may be anonymous\n+                if (commandLine.looksLikeOption(arg)) {\n+                    // narrow the search\n+                    final Collection values = optionMap.tailMap(arg).values();\n+\n+                    boolean foundMemberOption = false;\n+\n+                    for (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\n+                        final Option option = (Option) i.next();\n+\n+                        if (option.canProcess(commandLine, arg)) {\n+                            foundMemberOption = true;\n+                            arguments.previous();\n+                            option.process(commandLine, arguments);\n+                        }\n+                    }\n+\n+                    // back track and abort this group if necessary\n+                    if (!foundMemberOption) {\n+                        arguments.previous();\n+\n+                        return;\n+                    }\n+                } // [END argument may be anonymous\n+\n+                // [START argument is NOT anonymous\n+                else {\n+                    // move iterator back, current value not used\n+                    arguments.previous();\n+\n+                    // if there are no anonymous arguments then this group can't\n+                    // process the argument\n+                    if (anonymous.isEmpty()) {\n+                        break;\n+                    }\n+\n+                    // TODO: why do we iterate over all anonymous arguments?\n+                    // canProcess will always return true?\n+                    for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+                        final Argument argument = (Argument) i.next();\n+\n+                        if (argument.canProcess(commandLine, arguments)) {\n+                            argument.process(commandLine, arguments);\n+                        }\n+                    }\n+                } // [END argument is NOT anonymous\n+            } // [END option NOT found\n+        } // [END process each command line token\n+    }\n+\n+    public void validate(final WriteableCommandLine commandLine)\n+        throws OptionException {\n+        // number of options found\n+        int present = 0;\n+\n+        // reference to first unexpected option\n+        Option unexpected = null;\n+\n+        for (final Iterator i = options.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+\n+            // if the child option is required then validate it\n+            if (option.isRequired()) {\n+                option.validate(commandLine);\n+            }\n+\n+            if (option instanceof Group) {\n+                option.validate(commandLine);\n+            }\n+\n+            // if the child option is present then validate it\n+            if (commandLine.hasOption(option)) {\n+                if (++present > maximum) {\n+                    unexpected = option;\n+\n+                    break;\n+                }\n+\n+                option.validate(commandLine);\n+            }\n+        }\n+\n+        // too many options\n+        if (unexpected != null) {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n+                                      unexpected.getPreferredName());\n+        }\n+\n+        // too few option\n+        if (present < minimum) {\n+            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n+        }\n+\n+        // validate each anonymous argument\n+        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+            option.validate(commandLine);\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        appendUsage(buffer, helpSettings, comp, \"|\");\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp,\n+                            final String separator) {\n+        final Set helpSettingsCopy = new HashSet(helpSettings);\n+\n+        final boolean optional =\n+            (minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+\n+        final boolean expanded =\n+            (name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+\n+        final boolean named =\n+            !expanded ||\n+            ((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n+\n+        final boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+\n+        final boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n+\n+        helpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+\n+        final boolean both = named && expanded;\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+\n+        if (named) {\n+            buffer.append(name);\n+        }\n+\n+        if (both) {\n+            buffer.append(\" (\");\n+        }\n+\n+        if (expanded) {\n+            final Set childSettings;\n+\n+            if (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n+                childSettings = DisplaySetting.NONE;\n+            } else {\n+                childSettings = new HashSet(helpSettingsCopy);\n+                childSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+            }\n+\n+            // grab a list of the group's options.\n+            final List list;\n+\n+            if (comp == null) {\n+                // default to using the initial order\n+                list = options;\n+            } else {\n+                // sort options if comparator is supplied\n+                list = new ArrayList(options);\n+                Collections.sort(list, comp);\n+            }\n+\n+            // for each option.\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final Option option = (Option) i.next();\n+\n+                // append usage information\n+                option.appendUsage(buffer, childSettings, comp);\n+\n+                // add separators as needed\n+                if (i.hasNext()) {\n+                    buffer.append(separator);\n+                }\n+            }\n+        }\n+\n+        if (both) {\n+            buffer.append(')');\n+        }\n+\n+        if (optional && outer) {\n+            buffer.append(']');\n+        }\n+\n+        if (arguments) {\n+            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+                buffer.append(' ');\n+\n+                final Option option = (Option) i.next();\n+                option.appendUsage(buffer, helpSettingsCopy, comp);\n+            }\n+        }\n+\n+        if (optional && !outer) {\n+            buffer.append(']');\n+        }\n+    }\n+\n+    public List helpLines(final int depth,\n+                          final Set helpSettings,\n+                          final Comparator comp) {\n+        final List helpLines = new ArrayList();\n+\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_NAME)) {\n+            final HelpLine helpLine = new HelpLineImpl(this, depth);\n+            helpLines.add(helpLine);\n+        }\n+\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\n+            // grab a list of the group's options.\n+            final List list;\n+\n+            if (comp == null) {\n+                // default to using the initial order\n+                list = options;\n+            } else {\n+                // sort options if comparator is supplied\n+                list = new ArrayList(options);\n+                Collections.sort(list, comp);\n+            }\n+\n+            // for each option\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final Option option = (Option) i.next();\n+                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n+            }\n+        }\n+\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT)) {\n+            for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+                final Option option = (Option) i.next();\n+                helpLines.addAll(option.helpLines(depth + 1, helpSettings, comp));\n+            }\n+        }\n+\n+        return helpLines;\n+    }\n+\n+    /**\n+     * Gets the member Options of thie Group.\n+     * Note this does not include any Arguments\n+     * @return only the non Argument Options of the Group\n+     */\n+    public List getOptions() {\n+        return options;\n+    }\n+\n+    /**\n+     * Gets the anonymous Arguments of this Group.\n+     * @return the Argument options of this Group\n+     */\n+    public List getAnonymous() {\n+        return anonymous;\n+    }\n+\n+    public Option findOption(final String trigger) {\n+        final Iterator i = getOptions().iterator();\n+\n+        while (i.hasNext()) {\n+            final Option option = (Option) i.next();\n+            final Option found = option.findOption(trigger);\n+\n+            if (found != null) {\n+                return found;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    public int getMinimum() {\n+        return minimum;\n+    }\n+\n+    public int getMaximum() {\n+        return maximum;\n+    }\n+\n+    public boolean isRequired() {\n+        return getMinimum() > 0;\n+    }\n+\n+    public void defaults(final WriteableCommandLine commandLine) {\n+        super.defaults(commandLine);\n+\n+        for (final Iterator i = options.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+            option.defaults(commandLine);\n+        }\n+\n+        for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n+            final Option option = (Option) i.next();\n+            option.defaults(commandLine);\n+        }\n+    }\n+}\n+\n+\n+class ReverseStringComparator implements Comparator {\n+    private static final Comparator instance = new ReverseStringComparator();\n+\n+    private ReverseStringComparator() {\n+        // just making sure nobody else creates one\n+    }\n+\n+    /**\n+     * Gets a singleton instance of a ReverseStringComparator\n+     * @return the singleton instance\n+     */\n+    public static final Comparator getInstance() {\n+        return instance;\n+    }\n+\n+    public int compare(final Object o1,\n+                       final Object o2) {\n+        final String s1 = (String) o1;\n+        final String s2 = (String) o2;\n+\n+        return -s1.compareTo(s2);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/HelpLineImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/HelpLineImpl.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.Comparator;import java.util.Set;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;/** * Represents a line in the help screen. */public class HelpLineImpl implements HelpLine {    /** The option that this HelpLineImpl describes */    private final Option option;    /** The level of indenting for this item */    private final int indent;    /** The help settings used to obtain the previous usage */    private transient Set cachedHelpSettings;    /** The comparator used to obtain the previous usage */    private transient Comparator cachedComparator;    /** The previously obtained usage */    private transient String cachedUsage;    /**     * Creates a new HelpLineImpl to represent a particular Option in the online     * help.     *     * @param option     *            Option that the HelpLineImpl describes     * @param indent     *            Level of indentation for this line     */    public HelpLineImpl(final Option option, final int indent) {        this.option = option;        this.indent = indent;    }    /**     * @return The description of the option     */    public String getDescription() {        return option.getDescription();    }    /**     * @return The level of indentation for this line     */    public int getIndent() {        return indent;    }    /**     * @return The Option that the help line relates to     */    public Option getOption() {        return option;    }    /**     * Builds a usage string for the option using the specified settings and     * comparator.     *     *     * @param helpSettings the settings to apply     * @param comparator a comparator to sort options when applicable     * @return the usage string     */    public String usage(final Set helpSettings, final Comparator comparator) {        if (cachedUsage == null            || cachedHelpSettings != helpSettings            || cachedComparator != comparator) {            // cache the arguments to avoid redoing work            cachedHelpSettings = helpSettings;            cachedComparator = comparator;            // build the new buffer            final StringBuffer buffer = new StringBuffer();            for (int i = 0; i < indent; ++i) {                buffer.append(\"  \");            }            option.appendUsage(buffer, helpSettings, comparator);            // cache the usage string            cachedUsage = buffer.toString();        }        return cachedUsage;    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+\n+/**\n+ * Represents a line in the help screen.\n+ */\n+public class HelpLineImpl implements HelpLine {\n+\n+    /** The option that this HelpLineImpl describes */\n+    private final Option option;\n+\n+    /** The level of indenting for this item */\n+    private final int indent;\n+\n+    /** The help settings used to obtain the previous usage */\n+    private transient Set cachedHelpSettings;\n+    \n+    /** The comparator used to obtain the previous usage */\n+    private transient Comparator cachedComparator;\n+    \n+    /** The previously obtained usage */\n+    private transient String cachedUsage;\n+    \n+    /**\n+     * Creates a new HelpLineImpl to represent a particular Option in the online\n+     * help.\n+     * \n+     * @param option\n+     *            Option that the HelpLineImpl describes\n+     * @param indent\n+     *            Level of indentation for this line\n+     */\n+    public HelpLineImpl(final Option option, final int indent) {\n+        this.option = option;\n+        this.indent = indent;\n+    }\n+\n+    /**\n+     * @return The description of the option\n+     */\n+    public String getDescription() {\n+        return option.getDescription();\n+    }\n+\n+    /**\n+     * @return The level of indentation for this line\n+     */\n+    public int getIndent() {\n+        return indent;\n+    }\n+\n+    /**\n+     * @return The Option that the help line relates to\n+     */\n+    public Option getOption() {\n+        return option;\n+    }\n+    \n+    /**\n+     * Builds a usage string for the option using the specified settings and \n+     * comparator.\n+     * \n+     *  \n+     * @param helpSettings the settings to apply\n+     * @param comparator a comparator to sort options when applicable\n+     * @return the usage string\n+     */\n+    public String usage(final Set helpSettings, final Comparator comparator) {\n+        if (cachedUsage == null\n+            || cachedHelpSettings != helpSettings\n+            || cachedComparator != comparator) {\n+            \n+            // cache the arguments to avoid redoing work\n+            cachedHelpSettings = helpSettings;\n+            cachedComparator = comparator;\n+            \n+            // build the new buffer\n+            final StringBuffer buffer = new StringBuffer();\n+            for (int i = 0; i < indent; ++i) {\n+                buffer.append(\"  \");\n+            }\n+            option.appendUsage(buffer, helpSettings, comparator);\n+            \n+            // cache the usage string\n+            cachedUsage = buffer.toString();\n+        }\n+        return cachedUsage;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/OptionImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/OptionImpl.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.Iterator;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * A base implementation of Option providing limited ground work for further * Option implementations. */public abstract class OptionImpl implements Option {    private final int id;    private final boolean required;    /**     * Creates an OptionImpl with the specified id     * @param id the unique id of this Option     * @param required true iff this Option must be present     */    public OptionImpl(final int id,                      final boolean required) {        this.id = id;        this.required = required;    }    public boolean canProcess(final WriteableCommandLine commandLine,                              final ListIterator arguments) {        if (arguments.hasNext()) {            final String argument = (String) arguments.next();            arguments.previous();            return canProcess(commandLine, argument);        } else {            return false;        }    }    public String toString() {        final StringBuffer buffer = new StringBuffer();        appendUsage(buffer, DisplaySetting.ALL, null);        return buffer.toString();    }    public int getId() {        return id;    }    public boolean equals(final Object thatObj) {        if (thatObj instanceof OptionImpl) {            final OptionImpl that = (OptionImpl) thatObj;            return (getId() == that.getId()) &&                   equals(getPreferredName(), that.getPreferredName()) &&                   equals(getDescription(), that.getDescription()) &&                   equals(getPrefixes(), that.getPrefixes()) &&                   equals(getTriggers(), that.getTriggers());        } else {            return false;        }    }    private boolean equals(Object left,                           Object right) {        if ((left == null) && (right == null)) {            return true;        } else if ((left == null) || (right == null)) {            return false;        } else {            return left.equals(right);        }    }    public int hashCode() {        int hashCode = getId();        hashCode = (hashCode * 37) + getPreferredName().hashCode();        if (getDescription() != null) {            hashCode = (hashCode * 37) + getDescription().hashCode();        }        hashCode = (hashCode * 37) + getPrefixes().hashCode();        hashCode = (hashCode * 37) + getTriggers().hashCode();        return hashCode;    }    public Option findOption(String trigger) {        if (getTriggers().contains(trigger)) {            return this;        } else {            return null;        }    }    public boolean isRequired() {        return required;    }    public void defaults(final WriteableCommandLine commandLine) {        // nothing to do normally    }    protected void checkPrefixes(final Set prefixes) {        // nothing to do if empty prefix list        if (prefixes.isEmpty()) {            return;        }        // check preferred name        checkPrefix(prefixes, getPreferredName());        // check triggers        this.getTriggers();        for (final Iterator i = getTriggers().iterator(); i.hasNext();) {            checkPrefix(prefixes, (String) i.next());        }    }    private void checkPrefix(final Set prefixes,                             final String trigger) {        for (final Iterator i = prefixes.iterator(); i.hasNext();) {            String prefix = (String) i.next();            if (trigger.startsWith(prefix)) {                return;            }        }        final ResourceHelper helper = ResourceHelper.getResourceHelper();        final String message =            helper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,                              prefixes.toString());        throw new IllegalArgumentException(message);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * A base implementation of Option providing limited ground work for further\n+ * Option implementations.\n+ */\n+public abstract class OptionImpl implements Option {\n+    private final int id;\n+    private final boolean required;\n+\n+    /**\n+     * Creates an OptionImpl with the specified id\n+     * @param id the unique id of this Option\n+     * @param required true iff this Option must be present\n+     */\n+    public OptionImpl(final int id,\n+                      final boolean required) {\n+        this.id = id;\n+        this.required = required;\n+    }\n+\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments) {\n+        if (arguments.hasNext()) {\n+            final String argument = (String) arguments.next();\n+            arguments.previous();\n+\n+            return canProcess(commandLine, argument);\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public String toString() {\n+        final StringBuffer buffer = new StringBuffer();\n+        appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        return buffer.toString();\n+    }\n+\n+    public int getId() {\n+        return id;\n+    }\n+\n+    public boolean equals(final Object thatObj) {\n+        if (thatObj instanceof OptionImpl) {\n+            final OptionImpl that = (OptionImpl) thatObj;\n+\n+            return (getId() == that.getId()) &&\n+                   equals(getPreferredName(), that.getPreferredName()) &&\n+                   equals(getDescription(), that.getDescription()) &&\n+                   equals(getPrefixes(), that.getPrefixes()) &&\n+                   equals(getTriggers(), that.getTriggers());\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private boolean equals(Object left,\n+                           Object right) {\n+        if ((left == null) && (right == null)) {\n+            return true;\n+        } else if ((left == null) || (right == null)) {\n+            return false;\n+        } else {\n+            return left.equals(right);\n+        }\n+    }\n+\n+    public int hashCode() {\n+        int hashCode = getId();\n+        hashCode = (hashCode * 37) + getPreferredName().hashCode();\n+\n+        if (getDescription() != null) {\n+            hashCode = (hashCode * 37) + getDescription().hashCode();\n+        }\n+\n+        hashCode = (hashCode * 37) + getPrefixes().hashCode();\n+        hashCode = (hashCode * 37) + getTriggers().hashCode();\n+\n+        return hashCode;\n+    }\n+\n+    public Option findOption(String trigger) {\n+        if (getTriggers().contains(trigger)) {\n+            return this;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public boolean isRequired() {\n+        return required;\n+    }\n+\n+    public void defaults(final WriteableCommandLine commandLine) {\n+        // nothing to do normally\n+    }\n+\n+    protected void checkPrefixes(final Set prefixes) {\n+        // nothing to do if empty prefix list\n+        if (prefixes.isEmpty()) {\n+            return;\n+        }\n+\n+        // check preferred name\n+        checkPrefix(prefixes, getPreferredName());\n+\n+        // check triggers\n+        this.getTriggers();\n+\n+        for (final Iterator i = getTriggers().iterator(); i.hasNext();) {\n+            checkPrefix(prefixes, (String) i.next());\n+        }\n+    }\n+\n+    private void checkPrefix(final Set prefixes,\n+                             final String trigger) {\n+        for (final Iterator i = prefixes.iterator(); i.hasNext();) {\n+            String prefix = (String) i.next();\n+\n+            if (trigger.startsWith(prefix)) {\n+                return;\n+            }\n+        }\n+\n+        final ResourceHelper helper = ResourceHelper.getResourceHelper();\n+        final String message =\n+            helper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\n+                              prefixes.toString());\n+        throw new IllegalArgumentException(message);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/ParentImpl.java\n+++ b/src/java/org/apache/commons/cli2/option/ParentImpl.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.Parent;import org.apache.commons.cli2.WriteableCommandLine;/** * A base implementation of Parent providing limited ground work for further * Parent implementations. */public abstract class ParentImpl    extends OptionImpl implements Parent {    private static final char NUL = '\\0';    private final Group children;    private final Argument argument;    private final String description;    protected ParentImpl(final Argument argument,                         final Group children,                         final String description,                         final int id,                         final boolean required) {        super(id, required);        this.children = children;        this.argument = argument;        this.description = description;    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.Option#process(org.apache.commons.cli2.CommandLine,     *      java.util.ListIterator)     */    public void process(final WriteableCommandLine commandLine,                        final ListIterator arguments)        throws OptionException {        if (argument != null) {            handleInitialSeparator(arguments, argument.getInitialSeparator());        }        processParent(commandLine, arguments);        if (argument != null) {            argument.processValues(commandLine, arguments, this);        }        if ((children != null) && children.canProcess(commandLine, arguments)) {            children.process(commandLine, arguments);        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.Option#canProcess(java.lang.String)     */    public boolean canProcess(final WriteableCommandLine commandLine,                              final String arg) {        final Set triggers = getTriggers();        if (argument != null) {            final char separator = argument.getInitialSeparator();            // if there is a valid separator character            if (separator != NUL) {                final int initialIndex = arg.indexOf(separator);                // if there is a separator present                if (initialIndex > 0) {                    return triggers.contains(arg.substring(0, initialIndex));                }            }        }        return triggers.contains(arg);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.Option#prefixes()     */    public Set getPrefixes() {        return (children == null) ? Collections.EMPTY_SET : children.getPrefixes();    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.Option#validate(org.apache.commons.cli2.CommandLine)     */    public void validate(WriteableCommandLine commandLine)        throws OptionException {        if (commandLine.hasOption(this)) {            if (argument != null) {                argument.validate(commandLine, this);            }            if (children != null) {                children.validate(commandLine);            }        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.Option#appendUsage(java.lang.StringBuffer,     *      java.util.Set, java.util.Comparator)     */    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        final boolean displayArgument =            (this.argument != null) &&            helpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        final boolean displayChildren =            (this.children != null) &&            helpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);        if (displayArgument) {            buffer.append(' ');            argument.appendUsage(buffer, helpSettings, comp);        }        if (displayChildren) {            buffer.append(' ');            children.appendUsage(buffer, helpSettings, comp);        }    }    /**     * @return a description of this parent option     */    public String getDescription() {        return description;    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.Option#helpLines(int, java.util.Set,     *      java.util.Comparator)     */    public List helpLines(final int depth,                          final Set helpSettings,                          final Comparator comp) {        final List helpLines = new ArrayList();        helpLines.add(new HelpLineImpl(this, depth));        if (helpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT) && (argument != null)) {            helpLines.addAll(argument.helpLines(depth + 1, helpSettings, comp));        }        if (helpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN) && (children != null)) {            helpLines.addAll(children.helpLines(depth + 1, helpSettings, comp));        }        return helpLines;    }    /**     * @return Returns the argument.     */    public Argument getArgument() {        return argument;    }    /**     * @return Returns the children.     */    public Group getChildren() {        return children;    }    /**     * Split the token using the specified separator character.     * @param arguments the current position in the arguments iterator     * @param separator the separator char to split on     */    private void handleInitialSeparator(final ListIterator arguments,                                        final char separator) {        // next token        final String newArgument = (String) arguments.next();        // split the token        final int initialIndex = newArgument.indexOf(separator);        if (initialIndex > 0) {            arguments.remove();            arguments.add(newArgument.substring(0, initialIndex));            String value = newArgument.substring(initialIndex + 1);            // The value obviously isn't an option, so we need to quote it if looks like an option.            // The quotes will be removed later            if (value.startsWith(\"-\")) {                value = '\"' + value + '\"';            }            arguments.add(value);            arguments.previous();        }        arguments.previous();    }    /*     * @see org.apache.commons.cli2.Option#findOption(java.lang.String)     */    public Option findOption(final String trigger) {        final Option found = super.findOption(trigger);        if ((found == null) && (children != null)) {            return children.findOption(trigger);        } else {            return found;        }    }    public void defaults(final WriteableCommandLine commandLine) {        super.defaults(commandLine);        if (argument != null) {            argument.defaultValues(commandLine, this);        }        if (children != null) {            children.defaults(commandLine);        }    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+\n+/**\n+ * A base implementation of Parent providing limited ground work for further\n+ * Parent implementations.\n+ */\n+public abstract class ParentImpl\n+    extends OptionImpl implements Parent {\n+    private static final char NUL = '\\0';\n+    private final Group children;\n+    private final Argument argument;\n+    private final String description;\n+\n+    protected ParentImpl(final Argument argument,\n+                         final Group children,\n+                         final String description,\n+                         final int id,\n+                         final boolean required) {\n+        super(id, required);\n+        this.children = children;\n+        this.argument = argument;\n+        this.description = description;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.Option#process(org.apache.commons.cli2.CommandLine,\n+     *      java.util.ListIterator)\n+     */\n+    public void process(final WriteableCommandLine commandLine,\n+                        final ListIterator arguments)\n+        throws OptionException {\n+        if (argument != null) {\n+            handleInitialSeparator(arguments, argument.getInitialSeparator());\n+        }\n+\n+        processParent(commandLine, arguments);\n+\n+        if (argument != null) {\n+            argument.processValues(commandLine, arguments, this);\n+        }\n+\n+        if ((children != null) && children.canProcess(commandLine, arguments)) {\n+            children.process(commandLine, arguments);\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.Option#canProcess(java.lang.String)\n+     */\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String arg) {\n+        final Set triggers = getTriggers();\n+\n+        if (argument != null) {\n+            final char separator = argument.getInitialSeparator();\n+\n+            // if there is a valid separator character\n+            if (separator != NUL) {\n+                final int initialIndex = arg.indexOf(separator);\n+\n+                // if there is a separator present\n+                if (initialIndex > 0) {\n+                    return triggers.contains(arg.substring(0, initialIndex));\n+                }\n+            }\n+        }\n+\n+        return triggers.contains(arg);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.Option#prefixes()\n+     */\n+    public Set getPrefixes() {\n+        return (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.Option#validate(org.apache.commons.cli2.CommandLine)\n+     */\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (commandLine.hasOption(this)) {\n+            if (argument != null) {\n+                argument.validate(commandLine, this);\n+            }\n+\n+            if (children != null) {\n+                children.validate(commandLine);\n+            }\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.Option#appendUsage(java.lang.StringBuffer,\n+     *      java.util.Set, java.util.Comparator)\n+     */\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        final boolean displayArgument =\n+            (this.argument != null) &&\n+            helpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        final boolean displayChildren =\n+            (this.children != null) &&\n+            helpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+\n+        if (displayArgument) {\n+            buffer.append(' ');\n+            argument.appendUsage(buffer, helpSettings, comp);\n+        }\n+\n+        if (displayChildren) {\n+            buffer.append(' ');\n+            children.appendUsage(buffer, helpSettings, comp);\n+        }\n+    }\n+\n+    /**\n+     * @return a description of this parent option\n+     */\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.Option#helpLines(int, java.util.Set,\n+     *      java.util.Comparator)\n+     */\n+    public List helpLines(final int depth,\n+                          final Set helpSettings,\n+                          final Comparator comp) {\n+        final List helpLines = new ArrayList();\n+        helpLines.add(new HelpLineImpl(this, depth));\n+\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT) && (argument != null)) {\n+            helpLines.addAll(argument.helpLines(depth + 1, helpSettings, comp));\n+        }\n+\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN) && (children != null)) {\n+            helpLines.addAll(children.helpLines(depth + 1, helpSettings, comp));\n+        }\n+\n+        return helpLines;\n+    }\n+\n+    /**\n+     * @return Returns the argument.\n+     */\n+    public Argument getArgument() {\n+        return argument;\n+    }\n+\n+    /**\n+     * @return Returns the children.\n+     */\n+    public Group getChildren() {\n+        return children;\n+    }\n+\n+    /**\n+     * Split the token using the specified separator character.\n+     * @param arguments the current position in the arguments iterator\n+     * @param separator the separator char to split on\n+     */\n+    private void handleInitialSeparator(final ListIterator arguments,\n+                                        final char separator) {\n+        // next token\n+        final String newArgument = (String) arguments.next();\n+\n+        // split the token\n+        final int initialIndex = newArgument.indexOf(separator);\n+\n+        if (initialIndex > 0) {\n+            arguments.remove();\n+            arguments.add(newArgument.substring(0, initialIndex));\n+            String value = newArgument.substring(initialIndex + 1);\n+            // The value obviously isn't an option, so we need to quote it if looks like an option.\n+            // The quotes will be removed later\n+            if (value.startsWith(\"-\")) {\n+                value = '\"' + value + '\"';\n+            }\n+            arguments.add(value);\n+            arguments.previous();\n+        }\n+\n+        arguments.previous();\n+    }\n+\n+    /*\n+     * @see org.apache.commons.cli2.Option#findOption(java.lang.String)\n+     */\n+    public Option findOption(final String trigger) {\n+        final Option found = super.findOption(trigger);\n+\n+        if ((found == null) && (children != null)) {\n+            return children.findOption(trigger);\n+        } else {\n+            return found;\n+        }\n+    }\n+\n+    public void defaults(final WriteableCommandLine commandLine) {\n+        super.defaults(commandLine);\n+\n+        if (argument != null) {\n+            argument.defaultValues(commandLine, this);\n+        }\n+\n+        if (children != null) {\n+            children.defaults(commandLine);\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/PropertyOption.java\n+++ b/src/java/org/apache/commons/cli2/option/PropertyOption.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;/** * Handles the java style \"-Dprop=value\" opions */public class PropertyOption    extends OptionImpl {    public static final String DEFAULT_OPTION_STRING = \"-D\";    public static final String DEFAULT_DESCRIPTION =        \"Passes properties and values to the application\";    /**     * A default PropertyOption instance     */    public static final PropertyOption INSTANCE = new PropertyOption();    private final String optionString;    private final String description;    private final Set prefixes;    /**     * Creates a new PropertyOption using the default settings of a \"-D\" trigger     * and an id of 'D'     */    public PropertyOption() {        this(DEFAULT_OPTION_STRING, DEFAULT_DESCRIPTION, 'D');    }    /**     * Creates a new PropertyOption using the specified parameters     * @param optionString the trigger for the Option     * @param description the description of the Option     * @param id the id of the Option     */    public PropertyOption(final String optionString,                          final String description,                          final int id) {        super(id, false);        this.optionString = optionString;        this.description = description;        this.prefixes = Collections.singleton(optionString);    }    public boolean canProcess(final WriteableCommandLine commandLine,                              final String argument) {        return (argument != null) && argument.startsWith(optionString) &&               (argument.length() > optionString.length());    }    public Set getPrefixes() {        return prefixes;    }    public void process(final WriteableCommandLine commandLine,                        final ListIterator arguments)        throws OptionException {        final String arg = (String) arguments.next();        if (!canProcess(commandLine, arg)) {            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);        }        final int propertyStart = optionString.length();        final int equalsIndex = arg.indexOf('=', propertyStart);        final String property;        final String value;        if (equalsIndex < 0) {            property = arg.substring(propertyStart);            value = \"true\";        } else {            property = arg.substring(propertyStart, equalsIndex);            value = arg.substring(equalsIndex + 1);        }        commandLine.addProperty(property, value);    }    public Set getTriggers() {        return Collections.singleton(optionString);    }    public void validate(WriteableCommandLine commandLine) {        // PropertyOption needs no validation    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        final boolean display = helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION);        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);        if (display) {            buffer.append(optionString);            if (bracketed) {                buffer.append('<');            }            buffer.append(\"property\");            if (bracketed) {                buffer.append('>');            }            buffer.append(\"=\");            if (bracketed) {                buffer.append('<');            }            buffer.append(\"value\");            if (bracketed) {                buffer.append('>');            }        }    }    public String getPreferredName() {        return optionString;    }    public String getDescription() {        return description;    }    public List helpLines(final int depth,                          final Set helpSettings,                          final Comparator comp) {        if (helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION)) {            final HelpLine helpLine = new HelpLineImpl(this, depth);            return Collections.singletonList(helpLine);        } else {            return Collections.EMPTY_LIST;        }    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+\n+/**\n+ * Handles the java style \"-Dprop=value\" opions\n+ */\n+public class PropertyOption\n+    extends OptionImpl {\n+    public static final String DEFAULT_OPTION_STRING = \"-D\";\n+    public static final String DEFAULT_DESCRIPTION =\n+        \"Passes properties and values to the application\";\n+\n+    /**\n+     * A default PropertyOption instance\n+     */\n+    public static final PropertyOption INSTANCE = new PropertyOption();\n+    private final String optionString;\n+    private final String description;\n+    private final Set prefixes;\n+\n+    /**\n+     * Creates a new PropertyOption using the default settings of a \"-D\" trigger\n+     * and an id of 'D'\n+     */\n+    public PropertyOption() {\n+        this(DEFAULT_OPTION_STRING, DEFAULT_DESCRIPTION, 'D');\n+    }\n+\n+    /**\n+     * Creates a new PropertyOption using the specified parameters\n+     * @param optionString the trigger for the Option\n+     * @param description the description of the Option\n+     * @param id the id of the Option\n+     */\n+    public PropertyOption(final String optionString,\n+                          final String description,\n+                          final int id) {\n+        super(id, false);\n+        this.optionString = optionString;\n+        this.description = description;\n+        this.prefixes = Collections.singleton(optionString);\n+    }\n+\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String argument) {\n+        return (argument != null) && argument.startsWith(optionString) &&\n+               (argument.length() > optionString.length());\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public void process(final WriteableCommandLine commandLine,\n+                        final ListIterator arguments)\n+        throws OptionException {\n+        final String arg = (String) arguments.next();\n+\n+        if (!canProcess(commandLine, arg)) {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n+        }\n+\n+        final int propertyStart = optionString.length();\n+        final int equalsIndex = arg.indexOf('=', propertyStart);\n+        final String property;\n+        final String value;\n+\n+        if (equalsIndex < 0) {\n+            property = arg.substring(propertyStart);\n+            value = \"true\";\n+        } else {\n+            property = arg.substring(propertyStart, equalsIndex);\n+            value = arg.substring(equalsIndex + 1);\n+        }\n+\n+        commandLine.addProperty(property, value);\n+    }\n+\n+    public Set getTriggers() {\n+        return Collections.singleton(optionString);\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine) {\n+        // PropertyOption needs no validation\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        final boolean display = helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+\n+        final boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+\n+        if (display) {\n+            buffer.append(optionString);\n+\n+            if (bracketed) {\n+                buffer.append('<');\n+            }\n+\n+            buffer.append(\"property\");\n+\n+            if (bracketed) {\n+                buffer.append('>');\n+            }\n+\n+            buffer.append(\"=\");\n+\n+            if (bracketed) {\n+                buffer.append('<');\n+            }\n+\n+            buffer.append(\"value\");\n+\n+            if (bracketed) {\n+                buffer.append('>');\n+            }\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return optionString;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public List helpLines(final int depth,\n+                          final Set helpSettings,\n+                          final Comparator comp) {\n+        if (helpSettings.contains(DisplaySetting.DISPLAY_PROPERTY_OPTION)) {\n+            final HelpLine helpLine = new HelpLineImpl(this, depth);\n+\n+            return Collections.singletonList(helpLine);\n+        } else {\n+            return Collections.EMPTY_LIST;\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/SourceDestArgument.java\n+++ b/src/java/org/apache/commons/cli2/option/SourceDestArgument.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.ArrayList;import java.util.Comparator;import java.util.Iterator;import java.util.List;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * An Argument implementation that allows a variable size Argument to precede a * fixed size argument.  The canonical example of it's use is in the unix * <code>cp</code> command where a number of source can be specified with * exactly one destination specfied at the end. */public class SourceDestArgument    extends ArgumentImpl {    private final Argument source;    private final Argument dest;    /**     * Creates a SourceDestArgument using defaults where possible.     *     * @param source the variable size Argument     * @param dest the fixed size Argument     */    public SourceDestArgument(final Argument source,                              final Argument dest) {        this(source, dest, DEFAULT_INITIAL_SEPARATOR, DEFAULT_SUBSEQUENT_SEPARATOR,             DEFAULT_CONSUME_REMAINING, null);    }    /**     * Creates a SourceDestArgument using the specified parameters.     *     * @param source the variable size Argument     * @param dest the fixed size Argument     * @param initialSeparator the inistial separator to use     * @param subsequentSeparator the subsequent separator to use     * @param consumeRemaining the token triggering consume remaining behaviour     * @param defaultValues the default values for the SourceDestArgument     */    public SourceDestArgument(final Argument source,                              final Argument dest,                              final char initialSeparator,                              final char subsequentSeparator,                              final String consumeRemaining,                              final List defaultValues) {        super(\"SourceDestArgument\", null, sum(source.getMinimum(), dest.getMinimum()),              sum(source.getMaximum(), dest.getMaximum()), initialSeparator, subsequentSeparator,              null, consumeRemaining, defaultValues, 0);        this.source = source;        this.dest = dest;        if (dest.getMinimum() != dest.getMaximum()) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SOURCE_DEST_MUST_ENFORCE_VALUES));        }    }    private static int sum(final int a,                           final int b) {        return Math.max(a, Math.max(b, a + b));    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        final int length = buffer.length();        source.appendUsage(buffer, helpSettings, comp);        if (buffer.length() != length) {            buffer.append(' ');        }        dest.appendUsage(buffer, helpSettings, comp);    }    public List helpLines(int depth,                          Set helpSettings,                          Comparator comp) {        final List helpLines = new ArrayList();        helpLines.addAll(source.helpLines(depth, helpSettings, comp));        helpLines.addAll(dest.helpLines(depth, helpSettings, comp));        return helpLines;    }    public void validate(WriteableCommandLine commandLine,                         Option option)        throws OptionException {        final List values = commandLine.getValues(option);        final int limit = values.size() - dest.getMinimum();        int count = 0;        final Iterator i = values.iterator();        while (count++ < limit) {            commandLine.addValue(source, i.next());        }        while (i.hasNext()) {            commandLine.addValue(dest, i.next());        }        source.validate(commandLine, source);        dest.validate(commandLine, dest);    }    public boolean canProcess(final WriteableCommandLine commandLine,                              final String arg) {        return source.canProcess(commandLine, arg) || dest.canProcess(commandLine, arg);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * An Argument implementation that allows a variable size Argument to precede a\n+ * fixed size argument.  The canonical example of it's use is in the unix\n+ * <code>cp</code> command where a number of source can be specified with\n+ * exactly one destination specfied at the end.\n+ */\n+public class SourceDestArgument\n+    extends ArgumentImpl {\n+    private final Argument source;\n+    private final Argument dest;\n+\n+    /**\n+     * Creates a SourceDestArgument using defaults where possible.\n+     *\n+     * @param source the variable size Argument\n+     * @param dest the fixed size Argument\n+     */\n+    public SourceDestArgument(final Argument source,\n+                              final Argument dest) {\n+        this(source, dest, DEFAULT_INITIAL_SEPARATOR, DEFAULT_SUBSEQUENT_SEPARATOR,\n+             DEFAULT_CONSUME_REMAINING, null);\n+    }\n+\n+    /**\n+     * Creates a SourceDestArgument using the specified parameters.\n+     *\n+     * @param source the variable size Argument\n+     * @param dest the fixed size Argument\n+     * @param initialSeparator the inistial separator to use\n+     * @param subsequentSeparator the subsequent separator to use\n+     * @param consumeRemaining the token triggering consume remaining behaviour\n+     * @param defaultValues the default values for the SourceDestArgument\n+     */\n+    public SourceDestArgument(final Argument source,\n+                              final Argument dest,\n+                              final char initialSeparator,\n+                              final char subsequentSeparator,\n+                              final String consumeRemaining,\n+                              final List defaultValues) {\n+        super(\"SourceDestArgument\", null, sum(source.getMinimum(), dest.getMinimum()),\n+              sum(source.getMaximum(), dest.getMaximum()), initialSeparator, subsequentSeparator,\n+              null, consumeRemaining, defaultValues, 0);\n+\n+        this.source = source;\n+        this.dest = dest;\n+\n+        if (dest.getMinimum() != dest.getMaximum()) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SOURCE_DEST_MUST_ENFORCE_VALUES));\n+        }\n+    }\n+\n+    private static int sum(final int a,\n+                           final int b) {\n+        return Math.max(a, Math.max(b, a + b));\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        final int length = buffer.length();\n+\n+        source.appendUsage(buffer, helpSettings, comp);\n+\n+        if (buffer.length() != length) {\n+            buffer.append(' ');\n+        }\n+\n+        dest.appendUsage(buffer, helpSettings, comp);\n+    }\n+\n+    public List helpLines(int depth,\n+                          Set helpSettings,\n+                          Comparator comp) {\n+        final List helpLines = new ArrayList();\n+        helpLines.addAll(source.helpLines(depth, helpSettings, comp));\n+        helpLines.addAll(dest.helpLines(depth, helpSettings, comp));\n+\n+        return helpLines;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine,\n+                         Option option)\n+        throws OptionException {\n+        final List values = commandLine.getValues(option);\n+\n+        final int limit = values.size() - dest.getMinimum();\n+        int count = 0;\n+\n+        final Iterator i = values.iterator();\n+\n+        while (count++ < limit) {\n+            commandLine.addValue(source, i.next());\n+        }\n+\n+        while (i.hasNext()) {\n+            commandLine.addValue(dest, i.next());\n+        }\n+\n+        source.validate(commandLine, source);\n+        dest.validate(commandLine, dest);\n+    }\n+\n+    public boolean canProcess(final WriteableCommandLine commandLine,\n+                              final String arg) {\n+        return source.canProcess(commandLine, arg) || dest.canProcess(commandLine, arg);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/option/Switch.java\n+++ b/src/java/org/apache/commons/cli2/option/Switch.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * A Parent implementation representing normal switch options. * For example: <code>+d|-d</code> or <code>--enable-x|--disable-x</code>. */public class Switch    extends ParentImpl {    /** i18n */    public static final ResourceHelper resources = ResourceHelper.getResourceHelper();    /**     * The default prefix for enabled switches     */    public static final String DEFAULT_ENABLED_PREFIX = \"+\";    /**     * The default prefix for disabled switches     */    public static final String DEFAULT_DISABLED_PREFIX = \"-\";    private final String enabledPrefix;    private final String disabledPrefix;    private final Set triggers;    private final String preferredName;    private final Set aliases;    private final Set prefixes;    private final Boolean defaultSwitch;    /**     * Creates a new Switch with the specified parameters     * @param enabledPrefix the prefix used for enabled switches     * @param disabledPrefix the prefix used for disabled switches     * @param preferredName the preferred name of the switch     * @param aliases the aliases by which the Switch is known     * @param description a description of the Switch     * @param required whether the Option is strictly required     * @param argument the Argument belonging to this Parent, or null     * @param children the Group children belonging to this Parent, ot null     * @param id the unique identifier for this Option     * @throws IllegalArgumentException if the preferredName or an alias isn't     *     prefixed with enabledPrefix or disabledPrefix     */    public Switch(final String enabledPrefix,                  final String disabledPrefix,                  final String preferredName,                  final Set aliases,                  final String description,                  final boolean required,                  final Argument argument,                  final Group children,                  final int id,                  final Boolean switchDefault) {        super(argument, children, description, id, required);        if (enabledPrefix == null) {            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_NO_ENABLED_PREFIX));        }        if (disabledPrefix == null) {            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_NO_DISABLED_PREFIX));        }        if (enabledPrefix.startsWith(disabledPrefix)) {            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_ENABLED_STARTS_WITH_DISABLED));        }        if (disabledPrefix.startsWith(enabledPrefix)) {            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_DISABLED_STARTWS_WITH_ENABLED));        }        this.enabledPrefix = enabledPrefix;        this.disabledPrefix = disabledPrefix;        this.preferredName = preferredName;        if ((preferredName == null) || (preferredName.length() < 1)) {            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT));        }        final Set newTriggers = new HashSet();        newTriggers.add(enabledPrefix + preferredName);        newTriggers.add(disabledPrefix + preferredName);        this.triggers = Collections.unmodifiableSet(newTriggers);        if (aliases == null) {            this.aliases = Collections.EMPTY_SET;        } else {            this.aliases = Collections.unmodifiableSet(new HashSet(aliases));            for (final Iterator i = aliases.iterator(); i.hasNext();) {                final String alias = (String) i.next();                newTriggers.add(enabledPrefix + alias);                newTriggers.add(disabledPrefix + alias);            }        }        final Set newPrefixes = new HashSet(super.getPrefixes());        newPrefixes.add(enabledPrefix);        newPrefixes.add(disabledPrefix);        this.prefixes = Collections.unmodifiableSet(newPrefixes);        this.defaultSwitch = switchDefault;        checkPrefixes(newPrefixes);    }    public void processParent(final WriteableCommandLine commandLine,                              final ListIterator arguments)        throws OptionException {        final String arg = (String) arguments.next();        if (canProcess(commandLine, arg)) {            if (arg.startsWith(enabledPrefix)) {                commandLine.addSwitch(this, true);                arguments.set(enabledPrefix + preferredName);            }            if (arg.startsWith(disabledPrefix)) {                commandLine.addSwitch(this, false);                arguments.set(disabledPrefix + preferredName);            }        } else {            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);        }    }    public Set getTriggers() {        return triggers;    }    public Set getPrefixes() {        return prefixes;    }    public void validate(WriteableCommandLine commandLine)        throws OptionException {        if (isRequired() && !commandLine.hasOption(this)) {            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,                                      getPreferredName());        }        super.validate(commandLine);    }    public void appendUsage(final StringBuffer buffer,                            final Set helpSettings,                            final Comparator comp) {        // do we display optionality        final boolean optional =            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);        final boolean disabled = helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_DISABLED);        final boolean enabled =            !disabled || helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_ENABLED);        final boolean both = disabled && enabled;        if (optional) {            buffer.append('[');        }        if (enabled) {            buffer.append(enabledPrefix).append(preferredName);        }        if (both) {            buffer.append('|');        }        if (disabled) {            buffer.append(disabledPrefix).append(preferredName);        }        if (displayAliases && !aliases.isEmpty()) {            buffer.append(\" (\");            final List list = new ArrayList(aliases);            Collections.sort(list);            for (final Iterator i = list.iterator(); i.hasNext();) {                final String alias = (String) i.next();                if (enabled) {                    buffer.append(enabledPrefix).append(alias);                }                if (both) {                    buffer.append('|');                }                if (disabled) {                    buffer.append(disabledPrefix).append(alias);                }                if (i.hasNext()) {                    buffer.append(',');                }            }            buffer.append(')');        }        super.appendUsage(buffer, helpSettings, comp);        if (optional) {            buffer.append(']');        }    }    public String getPreferredName() {        return enabledPrefix + preferredName;    }    public void defaults(final WriteableCommandLine commandLine) {        commandLine.setDefaultSwitch(this, defaultSwitch);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * A Parent implementation representing normal switch options.\n+ * For example: <code>+d|-d</code> or <code>--enable-x|--disable-x</code>.\n+ */\n+public class Switch\n+    extends ParentImpl {\n+    /** i18n */\n+    public static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    /**\n+     * The default prefix for enabled switches\n+     */\n+    public static final String DEFAULT_ENABLED_PREFIX = \"+\";\n+\n+    /**\n+     * The default prefix for disabled switches\n+     */\n+    public static final String DEFAULT_DISABLED_PREFIX = \"-\";\n+    private final String enabledPrefix;\n+    private final String disabledPrefix;\n+    private final Set triggers;\n+    private final String preferredName;\n+    private final Set aliases;\n+    private final Set prefixes;\n+    private final Boolean defaultSwitch;\n+\n+    /**\n+     * Creates a new Switch with the specified parameters\n+     * @param enabledPrefix the prefix used for enabled switches\n+     * @param disabledPrefix the prefix used for disabled switches\n+     * @param preferredName the preferred name of the switch\n+     * @param aliases the aliases by which the Switch is known\n+     * @param description a description of the Switch\n+     * @param required whether the Option is strictly required\n+     * @param argument the Argument belonging to this Parent, or null\n+     * @param children the Group children belonging to this Parent, ot null\n+     * @param id the unique identifier for this Option\n+     * @throws IllegalArgumentException if the preferredName or an alias isn't\n+     *     prefixed with enabledPrefix or disabledPrefix\n+     */\n+    public Switch(final String enabledPrefix,\n+                  final String disabledPrefix,\n+                  final String preferredName,\n+                  final Set aliases,\n+                  final String description,\n+                  final boolean required,\n+                  final Argument argument,\n+                  final Group children,\n+                  final int id,\n+                  final Boolean switchDefault) {\n+        super(argument, children, description, id, required);\n+\n+        if (enabledPrefix == null) {\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_NO_ENABLED_PREFIX));\n+        }\n+\n+        if (disabledPrefix == null) {\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_NO_DISABLED_PREFIX));\n+        }\n+\n+        if (enabledPrefix.startsWith(disabledPrefix)) {\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_ENABLED_STARTS_WITH_DISABLED));\n+        }\n+\n+        if (disabledPrefix.startsWith(enabledPrefix)) {\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_DISABLED_STARTWS_WITH_ENABLED));\n+        }\n+\n+        this.enabledPrefix = enabledPrefix;\n+        this.disabledPrefix = disabledPrefix;\n+        this.preferredName = preferredName;\n+\n+        if ((preferredName == null) || (preferredName.length() < 1)) {\n+            throw new IllegalArgumentException(resources.getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT));\n+        }\n+\n+        final Set newTriggers = new HashSet();\n+        newTriggers.add(enabledPrefix + preferredName);\n+        newTriggers.add(disabledPrefix + preferredName);\n+        this.triggers = Collections.unmodifiableSet(newTriggers);\n+\n+        if (aliases == null) {\n+            this.aliases = Collections.EMPTY_SET;\n+        } else {\n+            this.aliases = Collections.unmodifiableSet(new HashSet(aliases));\n+\n+            for (final Iterator i = aliases.iterator(); i.hasNext();) {\n+                final String alias = (String) i.next();\n+                newTriggers.add(enabledPrefix + alias);\n+                newTriggers.add(disabledPrefix + alias);\n+            }\n+        }\n+\n+        final Set newPrefixes = new HashSet(super.getPrefixes());\n+        newPrefixes.add(enabledPrefix);\n+        newPrefixes.add(disabledPrefix);\n+        this.prefixes = Collections.unmodifiableSet(newPrefixes);\n+\n+        this.defaultSwitch = switchDefault;\n+\n+        checkPrefixes(newPrefixes);\n+    }\n+\n+    public void processParent(final WriteableCommandLine commandLine,\n+                              final ListIterator arguments)\n+        throws OptionException {\n+        final String arg = (String) arguments.next();\n+\n+        if (canProcess(commandLine, arg)) {\n+            if (arg.startsWith(enabledPrefix)) {\n+                commandLine.addSwitch(this, true);\n+                arguments.set(enabledPrefix + preferredName);\n+            }\n+\n+            if (arg.startsWith(disabledPrefix)) {\n+                commandLine.addSwitch(this, false);\n+                arguments.set(disabledPrefix + preferredName);\n+            }\n+        } else {\n+            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n+        }\n+    }\n+\n+    public Set getTriggers() {\n+        return triggers;\n+    }\n+\n+    public Set getPrefixes() {\n+        return prefixes;\n+    }\n+\n+    public void validate(WriteableCommandLine commandLine)\n+        throws OptionException {\n+        if (isRequired() && !commandLine.hasOption(this)) {\n+            throw new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\n+                                      getPreferredName());\n+        }\n+\n+        super.validate(commandLine);\n+    }\n+\n+    public void appendUsage(final StringBuffer buffer,\n+                            final Set helpSettings,\n+                            final Comparator comp) {\n+        // do we display optionality\n+        final boolean optional =\n+            !isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n+        final boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n+        final boolean disabled = helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        final boolean enabled =\n+            !disabled || helpSettings.contains(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+        final boolean both = disabled && enabled;\n+\n+        if (optional) {\n+            buffer.append('[');\n+        }\n+\n+        if (enabled) {\n+            buffer.append(enabledPrefix).append(preferredName);\n+        }\n+\n+        if (both) {\n+            buffer.append('|');\n+        }\n+\n+        if (disabled) {\n+            buffer.append(disabledPrefix).append(preferredName);\n+        }\n+\n+        if (displayAliases && !aliases.isEmpty()) {\n+            buffer.append(\" (\");\n+\n+            final List list = new ArrayList(aliases);\n+            Collections.sort(list);\n+\n+            for (final Iterator i = list.iterator(); i.hasNext();) {\n+                final String alias = (String) i.next();\n+\n+                if (enabled) {\n+                    buffer.append(enabledPrefix).append(alias);\n+                }\n+\n+                if (both) {\n+                    buffer.append('|');\n+                }\n+\n+                if (disabled) {\n+                    buffer.append(disabledPrefix).append(alias);\n+                }\n+\n+                if (i.hasNext()) {\n+                    buffer.append(',');\n+                }\n+            }\n+\n+            buffer.append(')');\n+        }\n+\n+        super.appendUsage(buffer, helpSettings, comp);\n+\n+        if (optional) {\n+            buffer.append(']');\n+        }\n+    }\n+\n+    public String getPreferredName() {\n+        return enabledPrefix + preferredName;\n+    }\n+\n+    public void defaults(final WriteableCommandLine commandLine) {\n+        commandLine.setDefaultSwitch(this, defaultSwitch);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/resource/ResourceConstants.java\n+++ b/src/java/org/apache/commons/cli2/resource/ResourceConstants.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */package org.apache.commons.cli2.resource;public abstract class ResourceConstants {    public static final String CLASSVALIDATOR_BAD_CLASSNAME = \"ClassValidator.bad.classname\";    public static final String CLASSVALIDATOR_CLASS_NOTFOUND = \"ClassValidator.class.notfound\";    public static final String CLASSVALIDATOR_CLASS_ACCESS = \"ClassValidator.class.access\";    public static final String CLASSVALIDATOR_CLASS_CREATE = \"ClassValidator.class.create\";    public static final String DATEVALIDATOR_DATE_OUTOFRANGE = \"DateValidator.date.OutOfRange\";    public static final String URLVALIDATOR_MALFORMED_URL = \"URLValidator.malformed.URL\";    public static final String NUMBERVALIDATOR_NUMBER_OUTOFRANGE =        \"NumberValidator.number.OutOfRange\";    public static final String ARGUMENT_UNEXPECTED_VALUE = \"Argument.unexpected.value\";    public static final String ARGUMENT_MIN_EXCEEDS_MAX = \"Argument.minimum.exceeds.maximum\";    public static final String ARGUMENT_TOO_FEW_DEFAULTS = \"Argument.too.few.defaults\";    public static final String ARGUMENT_TOO_MANY_DEFAULTS = \"Argument.too.many.defaults\";    public static final String ARGUMENT_MISSING_VALUES = \"Argument.missing.values\";    public static final String ARGUMENT_TOO_MANY_VALUES = \"Argument.too.many.values\";    public static final String OPTION_TRIGGER_NEEDS_PREFIX = \"Option.trigger.needs.prefix\";    public static final String OPTION_MISSING_REQUIRED = \"Option.missing.required\";    public static final String OPTION_NO_NAME = \"Option.no.name\";    public static final String OPTION_ILLEGAL_LONG_PREFIX = \"Option.illegal.long.prefix\";    public static final String OPTION_ILLEGAL_SHORT_PREFIX = \"Option.illegal.short.prefix\";    public static final String UNEXPECTED_TOKEN = \"Unexpected.token\";    public static final String MISSING_OPTION = \"Missing.option\";    public static final String CANNOT_BURST = \"Cannot.burst\";    public static final String COMMAND_PREFERRED_NAME_TOO_SHORT = \"Command.preferredName.too.short\";    public static final String SWITCH_ILLEGAL_ENABLED_PREFIX = \"Option.illegal.enabled.prefix\";    public static final String SWITCH_ILLEGAL_DISABLED_PREFIX = \"Option.illegal.disabled.prefix\";    public static final String SWITCH_IDENTICAL_PREFIXES = \"Option.identical.prefixes\";    public static final String SWITCH_ALREADY_SET = \"Switch.already.set\";    public static final String SWITCH_NO_ENABLED_PREFIX = \"Switch.no.enabledPrefix\";    public static final String SWITCH_NO_DISABLED_PREFIX = \"Switch.no.disabledPrefix\";    public static final String SWITCH_ENABLED_STARTS_WITH_DISABLED =        \"Switch.enabled.startsWith.disabled\";    public static final String SWITCH_DISABLED_STARTWS_WITH_ENABLED =        \"Switch.disabled.startsWith.enabled\";    public static final String SWITCH_PREFERRED_NAME_TOO_SHORT = \"Switch.preferredName.too.short\";    public static final String SOURCE_DEST_MUST_ENFORCE_VALUES = \"SourceDest.must.enforce.values\";    public static final String HELPFORMATTER_GUTTER_TOO_LONG = \"HelpFormatter.gutter.too.long\";    public static final String HELPFORMATTER_WIDTH_TOO_NARROW = \"HelpFormatter.width.too.narrow\";    public static final String ENUM_ILLEGAL_VALUE = \"Enum.illegal.value\";    public static final String ARGUMENT_BUILDER_NULL_CONSUME_REMAINING = \"ArgumentBuilder.null.consume.remaining\";    public static final String ARGUMENT_BUILDER_EMPTY_CONSUME_REMAINING = \"ArgumentBuilder.empty.consume.remaining\";    public static final String ARGUMENT_BUILDER_NULL_DEFAULT = \"ArgumentBuilder.null.default\";    public static final String ARGUMENT_BUILDER_NULL_DEFAULTS = \"ArgumentBuilder.null.defaults\";    public static final String ARGUMENT_BUILDER_NEGATIVE_MAXIMUM = \"ArgumentBuilder.negative.maximum\";    public static final String ARGUMENT_BUILDER_NEGATIVE_MINIMUM = \"ArgumentBuilder.negative.minimum\";    public static final String ARGUMENT_BUILDER_NULL_NAME = \"ArgumentBuilder.null.name\";    public static final String ARGUMENT_BUILDER_EMPTY_NAME = \"ArgumentBuilder.empty.name\";    public static final String ARGUMENT_BUILDER_NULL_VALIDATOR = \"ArgumentBuilder.null.validator\";}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.cli2.resource;\n+\n+public abstract class ResourceConstants {\n+    public static final String CLASSVALIDATOR_BAD_CLASSNAME = \"ClassValidator.bad.classname\";\n+    public static final String CLASSVALIDATOR_CLASS_NOTFOUND = \"ClassValidator.class.notfound\";\n+    public static final String CLASSVALIDATOR_CLASS_ACCESS = \"ClassValidator.class.access\";\n+    public static final String CLASSVALIDATOR_CLASS_CREATE = \"ClassValidator.class.create\";\n+    public static final String DATEVALIDATOR_DATE_OUTOFRANGE = \"DateValidator.date.OutOfRange\";\n+    public static final String URLVALIDATOR_MALFORMED_URL = \"URLValidator.malformed.URL\";\n+    public static final String NUMBERVALIDATOR_NUMBER_OUTOFRANGE =\n+        \"NumberValidator.number.OutOfRange\";\n+    public static final String ARGUMENT_UNEXPECTED_VALUE = \"Argument.unexpected.value\";\n+    public static final String ARGUMENT_MIN_EXCEEDS_MAX = \"Argument.minimum.exceeds.maximum\";\n+    public static final String ARGUMENT_TOO_FEW_DEFAULTS = \"Argument.too.few.defaults\";\n+    public static final String ARGUMENT_TOO_MANY_DEFAULTS = \"Argument.too.many.defaults\";\n+    public static final String ARGUMENT_MISSING_VALUES = \"Argument.missing.values\";\n+    public static final String ARGUMENT_TOO_MANY_VALUES = \"Argument.too.many.values\";\n+    public static final String OPTION_TRIGGER_NEEDS_PREFIX = \"Option.trigger.needs.prefix\";\n+    public static final String OPTION_MISSING_REQUIRED = \"Option.missing.required\";\n+    public static final String OPTION_NO_NAME = \"Option.no.name\";\n+    public static final String OPTION_ILLEGAL_LONG_PREFIX = \"Option.illegal.long.prefix\";\n+    public static final String OPTION_ILLEGAL_SHORT_PREFIX = \"Option.illegal.short.prefix\";\n+    public static final String UNEXPECTED_TOKEN = \"Unexpected.token\";\n+    public static final String MISSING_OPTION = \"Missing.option\";\n+    public static final String CANNOT_BURST = \"Cannot.burst\";\n+    public static final String COMMAND_PREFERRED_NAME_TOO_SHORT = \"Command.preferredName.too.short\";\n+    public static final String SWITCH_ILLEGAL_ENABLED_PREFIX = \"Option.illegal.enabled.prefix\";\n+    public static final String SWITCH_ILLEGAL_DISABLED_PREFIX = \"Option.illegal.disabled.prefix\";\n+    public static final String SWITCH_IDENTICAL_PREFIXES = \"Option.identical.prefixes\";\n+    public static final String SWITCH_ALREADY_SET = \"Switch.already.set\";\n+    public static final String SWITCH_NO_ENABLED_PREFIX = \"Switch.no.enabledPrefix\";\n+    public static final String SWITCH_NO_DISABLED_PREFIX = \"Switch.no.disabledPrefix\";\n+    public static final String SWITCH_ENABLED_STARTS_WITH_DISABLED =\n+        \"Switch.enabled.startsWith.disabled\";\n+    public static final String SWITCH_DISABLED_STARTWS_WITH_ENABLED =\n+        \"Switch.disabled.startsWith.enabled\";\n+    public static final String SWITCH_PREFERRED_NAME_TOO_SHORT = \"Switch.preferredName.too.short\";\n+    public static final String SOURCE_DEST_MUST_ENFORCE_VALUES = \"SourceDest.must.enforce.values\";\n+    public static final String HELPFORMATTER_GUTTER_TOO_LONG = \"HelpFormatter.gutter.too.long\";\n+    public static final String HELPFORMATTER_WIDTH_TOO_NARROW = \"HelpFormatter.width.too.narrow\";\n+    public static final String ENUM_ILLEGAL_VALUE = \"Enum.illegal.value\";\n+    public static final String ARGUMENT_BUILDER_NULL_CONSUME_REMAINING = \"ArgumentBuilder.null.consume.remaining\";\n+    public static final String ARGUMENT_BUILDER_EMPTY_CONSUME_REMAINING = \"ArgumentBuilder.empty.consume.remaining\";\n+    public static final String ARGUMENT_BUILDER_NULL_DEFAULT = \"ArgumentBuilder.null.default\";\n+    public static final String ARGUMENT_BUILDER_NULL_DEFAULTS = \"ArgumentBuilder.null.defaults\";\n+    public static final String ARGUMENT_BUILDER_NEGATIVE_MAXIMUM = \"ArgumentBuilder.negative.maximum\";\n+    public static final String ARGUMENT_BUILDER_NEGATIVE_MINIMUM = \"ArgumentBuilder.negative.minimum\";\n+    public static final String ARGUMENT_BUILDER_NULL_NAME = \"ArgumentBuilder.null.name\";\n+    public static final String ARGUMENT_BUILDER_EMPTY_NAME = \"ArgumentBuilder.empty.name\";\n+    public static final String ARGUMENT_BUILDER_NULL_VALIDATOR = \"ArgumentBuilder.null.validator\";\n+\n+}\n--- a/src/java/org/apache/commons/cli2/resource/ResourceHelper.java\n+++ b/src/java/org/apache/commons/cli2/resource/ResourceHelper.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.resource;import java.text.MessageFormat;import java.util.Locale;import java.util.MissingResourceException;import java.util.ResourceBundle;/** * A utility class used to provide internationalisation support. * * @author John Keyes */public class ResourceHelper {    /** system property */    private static final String PROP_LOCALE = \"org.apache.commons.cli2.resource.bundle\";    /** default package name */    private static final String DEFAULT_BUNDLE =        \"org.apache.commons.cli2.resource.CLIMessageBundle_en_US\";    private static ResourceHelper helper;    /** resource bundle */    private ResourceBundle bundle;    private String prop;    /**     * Create a new ResourceHelper for the current locale.     */    private ResourceHelper() {        String bundleName = System.getProperty(PROP_LOCALE);        if (bundleName == null) {            bundleName = DEFAULT_BUNDLE;        }        this.prop = bundleName;        int firstUnderscore = bundleName.indexOf('_');        int secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);        Locale locale;        if (firstUnderscore != -1) {        String language = bundleName.substring(firstUnderscore + 1, secondUnderscore);        String country = bundleName.substring(secondUnderscore + 1);        \tlocale = new Locale(language, country);        }        else {        \tlocale = Locale.getDefault();        }        // initialize the bundle        try {            bundle = ResourceBundle.getBundle(bundleName, locale);        } catch (MissingResourceException exp) {            bundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);        }    }    public String getBundleName() {    \treturn this.prop;    }    /**     * Gets the ResourceHelper appropriate to the current locale.     * @return a ResourceHelper     */    public static ResourceHelper getResourceHelper() {        String bundleName = System.getProperty(PROP_LOCALE);        if (helper == null || !helper.getBundleName().equals(bundleName)) {            helper = new ResourceHelper();        }        return helper;    }    /**     * Returns the message for the specified key.     *     * @param key the unique identifier of the message     * @return String the formatted String     */    public String getMessage(final String key) {        return getMessage(key, new Object[] {  });    }    /**     * Returns the message for the specified key and argument.     *     * @param key the unique identifier of the message     * @param value the argument value     * @return String the formatted String     */    public String getMessage(final String key,                             final Object value) {        return getMessage(key, new Object[] { value });    }    /**     * Returns the message for the specified key and arguments.     *     * @param key the unique identifier of the message     * @param value1 an argument value     * @param value2 an argument value     * @return String the formatted String     */    public String getMessage(final String key,                             final Object value1,                             final Object value2) {        return getMessage(key, new Object[] { value1, value2 });    }    /**     * Returns the message for the specified key and arguments.     *     * @param key the unique identifier of the message     * @param value1 an argument value     * @param value2 an argument value     * @param value3 an argument value     *     * @return String the formatted String     */    public String getMessage(final String key,                             final Object value1,                             final Object value2,                             final Object value3) {        return getMessage(key, new Object[] { value1, value2, value3 });    }    /**     * Returns the message for the specified key and arguments.     *     * @param key the unique identifier of the message     * @param values argument values     * @return String the formatted String     */    public String getMessage(final String key,                             final Object[] values) {        final String msgFormatStr = bundle.getString(key);        final MessageFormat msgFormat = new MessageFormat(msgFormatStr);        return msgFormat.format(values);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.resource;\n+\n+import java.text.MessageFormat;\n+\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+/**\n+ * A utility class used to provide internationalisation support.\n+ *\n+ * @author John Keyes\n+ */\n+public class ResourceHelper {\n+    /** system property */\n+    private static final String PROP_LOCALE = \"org.apache.commons.cli2.resource.bundle\";\n+\n+    /** default package name */\n+    private static final String DEFAULT_BUNDLE =\n+        \"org.apache.commons.cli2.resource.CLIMessageBundle_en_US\";\n+    private static ResourceHelper helper;\n+\n+    /** resource bundle */\n+    private ResourceBundle bundle;\n+\n+    private String prop;\n+    \n+    /**\n+     * Create a new ResourceHelper for the current locale.\n+     */\n+    private ResourceHelper() {\n+        String bundleName = System.getProperty(PROP_LOCALE);\n+\n+        if (bundleName == null) {\n+            bundleName = DEFAULT_BUNDLE;\n+        }\n+\n+        this.prop = bundleName;\n+        \n+        int firstUnderscore = bundleName.indexOf('_');\n+        int secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n+\n+        Locale locale;\n+        if (firstUnderscore != -1) { \n+        String language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\n+        String country = bundleName.substring(secondUnderscore + 1);\n+        \tlocale = new Locale(language, country);\n+        }\n+        else {\n+        \tlocale = Locale.getDefault();\n+        }\n+        // initialize the bundle\n+        try {\n+            bundle = ResourceBundle.getBundle(bundleName, locale);\n+        } catch (MissingResourceException exp) {\n+            bundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n+        }\n+    }\n+\n+    public String getBundleName() {\n+    \treturn this.prop;\n+    }\n+    \n+    /**\n+     * Gets the ResourceHelper appropriate to the current locale.\n+     * @return a ResourceHelper\n+     */\n+    public static ResourceHelper getResourceHelper() {\n+        String bundleName = System.getProperty(PROP_LOCALE);\n+        if (helper == null || !helper.getBundleName().equals(bundleName)) {\n+            helper = new ResourceHelper();\n+        }\n+\n+        return helper;\n+    }\n+\n+    /**\n+     * Returns the message for the specified key.\n+     *\n+     * @param key the unique identifier of the message\n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key) {\n+        return getMessage(key, new Object[] {  });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and argument.\n+     *\n+     * @param key the unique identifier of the message\n+     * @param value the argument value\n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key,\n+                             final Object value) {\n+        return getMessage(key, new Object[] { value });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and arguments.\n+     *\n+     * @param key the unique identifier of the message\n+     * @param value1 an argument value\n+     * @param value2 an argument value\n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key,\n+                             final Object value1,\n+                             final Object value2) {\n+        return getMessage(key, new Object[] { value1, value2 });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and arguments.\n+     *\n+     * @param key the unique identifier of the message\n+     * @param value1 an argument value\n+     * @param value2 an argument value\n+     * @param value3 an argument value\n+     *\n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key,\n+                             final Object value1,\n+                             final Object value2,\n+                             final Object value3) {\n+        return getMessage(key, new Object[] { value1, value2, value3 });\n+    }\n+\n+    /**\n+     * Returns the message for the specified key and arguments.\n+     *\n+     * @param key the unique identifier of the message\n+     * @param values argument values\n+     * @return String the formatted String\n+     */\n+    public String getMessage(final String key,\n+                             final Object[] values) {\n+        final String msgFormatStr = bundle.getString(key);\n+        final MessageFormat msgFormat = new MessageFormat(msgFormatStr);\n+\n+        return msgFormat.format(values);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/util/Comparators.java\n+++ b/src/java/org/apache/commons/cli2/util/Comparators.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.util;import java.util.Comparator;import java.util.List;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.option.Command;import org.apache.commons.cli2.option.DefaultOption;import org.apache.commons.cli2.option.Switch;/** * A collection of Comparators suitable for use with Option instances. */public class Comparators {\tprivate Comparators(){\t\t// constructor hiden from potential users\t}    /**     * Chains comparators together.     *     * @see #chain(Comparator[])     * @param c0     *            a comparator     * @param c1     *            a comparator     * @return a chained comparator     */    public static Comparator chain(final Comparator c0, final Comparator c1) {        return chain(new Comparator[] { c0, c1 });    }    /**     * Chains comparators together.     *     * @see #chain(Comparator[])     * @param c0     *            a comparator     * @param c1     *            a comparator     * @param c2     *            a comparator     * @return a chained comparator     */    public static Comparator chain(        final Comparator c0,        final Comparator c1,        final Comparator c2) {        return chain(new Comparator[] { c0, c1, c2 });    }    /**     * Chains comparators together.     *     * @see #chain(Comparator[])     * @param c0     *            a comparator     * @param c1     *            a comparator     * @param c2     *            a comparator     * @param c3     *            a comparator     * @return a chained comparator     */    public static Comparator chain(        final Comparator c0,        final Comparator c1,        final Comparator c2,        final Comparator c3) {        return chain(new Comparator[] { c0, c1, c2, c3 });    }    /**     * Chains comparators together.     *     * @see #chain(Comparator[])     * @param c0     *            a comparator     * @param c1     *            a comparator     * @param c2     *            a comparator     * @param c3     *            a comparator     * @param c4     *            a comparator     * @return a chained comparator     */    public static Comparator chain(        final Comparator c0,        final Comparator c1,        final Comparator c2,        final Comparator c3,        final Comparator c4) {        return chain(new Comparator[] { c0, c1, c2, c3, c4 });    }    /**     * Chains comparators together.     *     * @see #chain(Comparator[])     * @param comparators     *            a List of comparators to chain together     * @return a chained comparator     */    public static Comparator chain(final List comparators) {        return new Chain(            (Comparator[])comparators.toArray(                new Comparator[comparators.size()]));    }    /**     * Chains an array of comparators together. Each Comparator will be called     * in turn until one of them return a non-zero value, this value will be     * returned.     *     * @param comparators     *            the array of comparators     * @return a chained comparator     */    public static Comparator chain(final Comparator[] comparators) {        return new Chain(comparators);    }    /**     * Chains a series of Comparators together.     */    private static class Chain implements Comparator {        final Comparator[] chain;        /**         * Creates a Comparator chain using the specified array of Comparators         * @param chain the Comparators in the chain         */        public Chain(final Comparator[] chain) {            this.chain = new Comparator[chain.length];            System.arraycopy(chain, 0, this.chain, 0, chain.length);        }        public int compare(final Object left, final Object right) {            int result = 0;            for (int i = 0; result == 0 && i < chain.length; ++i) {                result = chain[i].compare(left, right);            }            return result;        }    }    /**     * Reverses a comparator's logic.     *     * @param wrapped     *            the Comparator to reverse the logic of     * @return a comparator with reverse logic     */    private static Comparator reverse(final Comparator wrapped) {        return new Reverse(wrapped);    }    private static class Reverse implements Comparator {        private final Comparator wrapped;        /**         * Creates a Comparator with reverse logic         * @param wrapped the original logic         */        public Reverse(final Comparator wrapped) {            this.wrapped = wrapped;        }        public int compare(final Object left, final Object right) {            return -wrapped.compare(left, right);        }    }    /**     * Forces Group instances to appear at the beginning of lists     *     * @see Group     * @return a new comparator     */    public static Comparator groupFirst() {        return new GroupFirst();    }    /**     * Forces Group instances to appear at the end of lists     *     * @see Group     * @return a new comparator     */    public static Comparator groupLast() {        return reverse(groupFirst());    }    private static class GroupFirst implements Comparator {        public int compare(final Object left, final Object right) {            final boolean l = left instanceof Group;            final boolean r = right instanceof Group;            if (l ^ r) {                if (l) {                    return -1;                }                return 1;            }            return 0;        }    }    /**     * Forces Switch instances to appear at the beginning of lists     *     * @see Switch     * @return a new comparator     */    public static Comparator switchFirst() {        return new SwitchFirst();    }    /**     * Forces Switch instances to appear at the end of lists     *     * @see Switch     * @return a new comparator     */    public static Comparator switchLast() {        return reverse(switchFirst());    }    private static class SwitchFirst implements Comparator {        public int compare(final Object left, final Object right) {            final boolean l = left instanceof Switch;            final boolean r = right instanceof Switch;            if (l ^ r) {                if (l) {                    return -1;                }                return 1;            }            return 0;        }    }    /**     * Forces Command instances to appear at the beginning of lists     *     * @see Command     * @return a new comparator     */    public static Comparator commandFirst() {        return new CommandFirst();    }    /**     * Forces Command instances to appear at the end of lists     *     * @see Command     * @return a new comparator     */    public static Comparator commandLast() {        return reverse(commandFirst());    }    private static class CommandFirst implements Comparator {        public int compare(final Object left, final Object right) {            final boolean l = left instanceof Command;            final boolean r = right instanceof Command;            if (l ^ r) {                if (l) {                    return -1;                }                return 1;            }            return 0;        }    }    /**     * Forces DefaultOption instances to appear at the beginning of lists     *     * @see DefaultOption     * @return a new comparator     */    public static Comparator defaultOptionFirst() {        return new DefaultOptionFirst();    }    /**     * Forces DefaultOption instances to appear at the end of lists     *     * @see DefaultOption     * @return a new comparator     */    public static Comparator defaultOptionLast() {        return reverse(defaultOptionFirst());    }    private static class DefaultOptionFirst implements Comparator {        public int compare(final Object left, final Object right) {            final boolean l = left instanceof DefaultOption;            final boolean r = right instanceof DefaultOption;            if (l ^ r) {                if (l) {                    return -1;                }                return 1;            }            return 0;        }    }    /**     * Forces Comparators with a particular trigger to appear at the beginning     * of lists     *     * @param name     *            the trigger name to select     * @see Option#getTriggers()     * @return a new comparator     */    public static Comparator namedFirst(final String name) {        return new Named(name);    }    /**     * Forces Comparators with a particular trigger to appear at the end of     * lists     *     * @param name     *            the trigger name to select     * @see Option#getTriggers()     * @return a new comparator     */    public static Comparator namedLast(final String name) {        return reverse(new Named(name));    }    private static class Named implements Comparator {        private final String name;        /**         * Creates a Comparator that sorts a particular name high in order         * @param name the trigger name to select         */        public Named(final String name) {            this.name = name;        }        public int compare(final Object oleft, final Object oright) {            final Option left = (Option)oleft;            final Option right = (Option)oright;            final boolean l = left.getTriggers().contains(name);            final boolean r = right.getTriggers().contains(name);            if (l ^ r) {                if (l) {                    return -1;                }                return 1;            }            return 0;        }    }    /**     * Orders Options by preferredName     *     * @see Option#getPreferredName()     * @return a new comparator     */    public static Comparator preferredNameFirst() {        return new PreferredName();    }    /**     * Orders Options by preferredName, reversed     *     * @see Option#getPreferredName()     * @return a new comparator     */    public static Comparator preferredNameLast() {        return reverse(preferredNameFirst());    }    private static class PreferredName implements Comparator {        public int compare(final Object oleft, final Object oright) {            final Option left = (Option)oleft;            final Option right = (Option)oright;            return left.getPreferredName().compareTo(right.getPreferredName());        }    }    /**     * Orders Options grouping required Options first     *     * @see Option#isRequired()     * @return a new comparator     */    public static Comparator requiredFirst() {        return new Required();    }    /**     * Orders Options grouping required Options last     *     * @see Option#isRequired()     * @return a new comparator     */    public static Comparator requiredLast() {        return reverse(requiredFirst());    }    private static class Required implements Comparator {        public int compare(final Object oleft, final Object oright) {            final Option left = (Option)oleft;            final Option right = (Option)oright;            final boolean l = left.isRequired();            final boolean r = right.isRequired();            if (l ^ r) {                if (l) {                    return -1;                }                return 1;            }            return 0;        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.option.Command;\n+import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.option.Switch;\n+\n+/**\n+ * A collection of Comparators suitable for use with Option instances.\n+ */\n+public class Comparators {\n+\t\n+\tprivate Comparators(){\n+\t\t// constructor hiden from potential users\n+\t}\n+\t\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(final Comparator c0, final Comparator c1) {\n+        return chain(new Comparator[] { c0, c1 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @param c2\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(\n+        final Comparator c0,\n+        final Comparator c1,\n+        final Comparator c2) {\n+        return chain(new Comparator[] { c0, c1, c2 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @param c2\n+     *            a comparator\n+     * @param c3\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(\n+        final Comparator c0,\n+        final Comparator c1,\n+        final Comparator c2,\n+        final Comparator c3) {\n+        return chain(new Comparator[] { c0, c1, c2, c3 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param c0\n+     *            a comparator\n+     * @param c1\n+     *            a comparator\n+     * @param c2\n+     *            a comparator\n+     * @param c3\n+     *            a comparator\n+     * @param c4\n+     *            a comparator\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(\n+        final Comparator c0,\n+        final Comparator c1,\n+        final Comparator c2,\n+        final Comparator c3,\n+        final Comparator c4) {\n+        return chain(new Comparator[] { c0, c1, c2, c3, c4 });\n+    }\n+\n+    /**\n+     * Chains comparators together.\n+     * \n+     * @see #chain(Comparator[])\n+     * @param comparators\n+     *            a List of comparators to chain together\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(final List comparators) {\n+        return new Chain(\n+            (Comparator[])comparators.toArray(\n+                new Comparator[comparators.size()]));\n+    }\n+\n+    /**\n+     * Chains an array of comparators together. Each Comparator will be called\n+     * in turn until one of them return a non-zero value, this value will be\n+     * returned.\n+     * \n+     * @param comparators\n+     *            the array of comparators\n+     * @return a chained comparator\n+     */\n+    public static Comparator chain(final Comparator[] comparators) {\n+        return new Chain(comparators);\n+    }\n+\n+    /**\n+     * Chains a series of Comparators together.\n+     */\n+    private static class Chain implements Comparator {\n+\n+        final Comparator[] chain;\n+\n+        /**\n+         * Creates a Comparator chain using the specified array of Comparators\n+         * @param chain the Comparators in the chain\n+         */\n+        public Chain(final Comparator[] chain) {\n+            this.chain = new Comparator[chain.length];\n+            System.arraycopy(chain, 0, this.chain, 0, chain.length);\n+        }\n+\n+        public int compare(final Object left, final Object right) {\n+            int result = 0;\n+            for (int i = 0; result == 0 && i < chain.length; ++i) {\n+                result = chain[i].compare(left, right);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Reverses a comparator's logic.\n+     * \n+     * @param wrapped\n+     *            the Comparator to reverse the logic of\n+     * @return a comparator with reverse logic\n+     */\n+    private static Comparator reverse(final Comparator wrapped) {\n+        return new Reverse(wrapped);\n+    }\n+\n+    private static class Reverse implements Comparator {\n+        private final Comparator wrapped;\n+\n+        /**\n+         * Creates a Comparator with reverse logic\n+         * @param wrapped the original logic\n+         */\n+        public Reverse(final Comparator wrapped) {\n+            this.wrapped = wrapped;\n+        }\n+\n+        public int compare(final Object left, final Object right) {\n+            return -wrapped.compare(left, right);\n+        }\n+    }\n+\n+    /**\n+     * Forces Group instances to appear at the beginning of lists\n+     * \n+     * @see Group\n+     * @return a new comparator\n+     */\n+    public static Comparator groupFirst() {\n+        return new GroupFirst();\n+    }\n+\n+    /**\n+     * Forces Group instances to appear at the end of lists\n+     * \n+     * @see Group\n+     * @return a new comparator\n+     */\n+    public static Comparator groupLast() {\n+        return reverse(groupFirst());\n+    }\n+\n+    private static class GroupFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof Group;\n+            final boolean r = right instanceof Group;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Forces Switch instances to appear at the beginning of lists\n+     * \n+     * @see Switch\n+     * @return a new comparator\n+     */\n+    public static Comparator switchFirst() {\n+        return new SwitchFirst();\n+    }\n+\n+    /**\n+     * Forces Switch instances to appear at the end of lists\n+     * \n+     * @see Switch\n+     * @return a new comparator\n+     */\n+    public static Comparator switchLast() {\n+        return reverse(switchFirst());\n+    }\n+\n+    private static class SwitchFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof Switch;\n+            final boolean r = right instanceof Switch;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Forces Command instances to appear at the beginning of lists\n+     * \n+     * @see Command\n+     * @return a new comparator\n+     */\n+    public static Comparator commandFirst() {\n+        return new CommandFirst();\n+    }\n+\n+    /**\n+     * Forces Command instances to appear at the end of lists\n+     * \n+     * @see Command\n+     * @return a new comparator\n+     */\n+    public static Comparator commandLast() {\n+        return reverse(commandFirst());\n+    }\n+\n+    private static class CommandFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof Command;\n+            final boolean r = right instanceof Command;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Forces DefaultOption instances to appear at the beginning of lists\n+     * \n+     * @see DefaultOption\n+     * @return a new comparator\n+     */\n+    public static Comparator defaultOptionFirst() {\n+        return new DefaultOptionFirst();\n+    }\n+\n+    /**\n+     * Forces DefaultOption instances to appear at the end of lists\n+     * \n+     * @see DefaultOption\n+     * @return a new comparator\n+     */\n+    public static Comparator defaultOptionLast() {\n+        return reverse(defaultOptionFirst());\n+    }\n+\n+    private static class DefaultOptionFirst implements Comparator {\n+        public int compare(final Object left, final Object right) {\n+            final boolean l = left instanceof DefaultOption;\n+            final boolean r = right instanceof DefaultOption;\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Forces Comparators with a particular trigger to appear at the beginning\n+     * of lists\n+     * \n+     * @param name\n+     *            the trigger name to select\n+     * @see Option#getTriggers()\n+     * @return a new comparator\n+     */\n+    public static Comparator namedFirst(final String name) {\n+        return new Named(name);\n+    }\n+\n+    /**\n+     * Forces Comparators with a particular trigger to appear at the end of\n+     * lists\n+     * \n+     * @param name\n+     *            the trigger name to select\n+     * @see Option#getTriggers()\n+     * @return a new comparator\n+     */\n+    public static Comparator namedLast(final String name) {\n+        return reverse(new Named(name));\n+    }\n+\n+    private static class Named implements Comparator {\n+        private final String name;\n+        \n+        /**\n+         * Creates a Comparator that sorts a particular name high in order\n+         * @param name the trigger name to select\n+         */\n+        public Named(final String name) {\n+            this.name = name;\n+        }\n+        public int compare(final Object oleft, final Object oright) {\n+            final Option left = (Option)oleft;\n+            final Option right = (Option)oright;\n+\n+            final boolean l = left.getTriggers().contains(name);\n+            final boolean r = right.getTriggers().contains(name);\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Orders Options by preferredName\n+     * \n+     * @see Option#getPreferredName()\n+     * @return a new comparator\n+     */\n+    public static Comparator preferredNameFirst() {\n+        return new PreferredName();\n+    }\n+\n+    /**\n+     * Orders Options by preferredName, reversed\n+     * \n+     * @see Option#getPreferredName()\n+     * @return a new comparator\n+     */\n+    public static Comparator preferredNameLast() {\n+        return reverse(preferredNameFirst());\n+    }\n+\n+    private static class PreferredName implements Comparator {\n+        public int compare(final Object oleft, final Object oright) {\n+            final Option left = (Option)oleft;\n+            final Option right = (Option)oright;\n+\n+            return left.getPreferredName().compareTo(right.getPreferredName());\n+        }\n+    }\n+\n+    /**\n+     * Orders Options grouping required Options first\n+     * \n+     * @see Option#isRequired()\n+     * @return a new comparator\n+     */\n+    public static Comparator requiredFirst() {\n+        return new Required();\n+    }\n+    \n+    /**\n+     * Orders Options grouping required Options last\n+     * \n+     * @see Option#isRequired()\n+     * @return a new comparator\n+     */\n+    public static Comparator requiredLast() {\n+        return reverse(requiredFirst());\n+    }\n+    \n+    private static class Required implements Comparator {\n+        public int compare(final Object oleft, final Object oright) {\n+            final Option left = (Option)oleft;\n+            final Option right = (Option)oright;\n+            \n+            final boolean l = left.isRequired();\n+            final boolean r = right.isRequired();\n+\n+            if (l ^ r) {\n+                if (l) {\n+                    return -1;\n+                }\n+                return 1;\n+            }\n+            return 0;\n+        }\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/util/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli2/util/HelpFormatter.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.util;import java.io.PrintWriter;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * Presents on screen help based on the application's Options */public class HelpFormatter {    /**     * The default screen width     */    public static final int DEFAULT_FULL_WIDTH = 80;    /**     * The default screen furniture left of screen     */    public static final String DEFAULT_GUTTER_LEFT = \"\";    /**     * The default screen furniture right of screen     */    public static final String DEFAULT_GUTTER_CENTER = \"    \";    /**     * The default screen furniture between columns     */    public static final String DEFAULT_GUTTER_RIGHT = \"\";    /**     * The default DisplaySettings used to select the elements to display in the     * displayed line of full usage information.     *     * @see DisplaySetting     */    public static final Set DEFAULT_FULL_USAGE_SETTINGS;    /**     * The default DisplaySettings used to select the elements of usage per help     * line in the main body of help     *     * @see DisplaySetting     */    public static final Set DEFAULT_LINE_USAGE_SETTINGS;    /**     * The default DisplaySettings used to select the help lines in the main     * body of help     */    public static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;    static {        final Set fullUsage = new HashSet(DisplaySetting.ALL);        fullUsage.remove(DisplaySetting.DISPLAY_ALIASES);        fullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);        DEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);        final Set lineUsage = new HashSet();        lineUsage.add(DisplaySetting.DISPLAY_ALIASES);        lineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);        lineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        DEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);        final Set displayUsage = new HashSet(DisplaySetting.ALL);        displayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        DEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);    }    private Set fullUsageSettings = new HashSet(DEFAULT_FULL_USAGE_SETTINGS);    private Set lineUsageSettings = new HashSet(DEFAULT_LINE_USAGE_SETTINGS);    private Set displaySettings = new HashSet(DEFAULT_DISPLAY_USAGE_SETTINGS);    private OptionException exception = null;    private Group group;    private Comparator comparator = null;    private String divider = null;    private String header = null;    private String footer = null;    private String shellCommand = \"\";    private PrintWriter out = new PrintWriter(System.out);    //or should this default to .err?    private final String gutterLeft;    private final String gutterCenter;    private final String gutterRight;    private final int pageWidth;    /**     * Creates a new HelpFormatter using the defaults     */    public HelpFormatter() {        this(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);    }    /**     * Creates a new HelpFormatter using the specified parameters     * @param gutterLeft the string marking left of screen     * @param gutterCenter the string marking center of screen     * @param gutterRight the string marking right of screen     * @param fullWidth the width of the screen     */    public HelpFormatter(final String gutterLeft,                         final String gutterCenter,                         final String gutterRight,                         final int fullWidth) {        // default the left gutter to empty string        this.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;        // default the center gutter to a single space        this.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;        // default the right gutter to empty string        this.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;        // calculate the available page width        this.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();        // check available page width is valid        int availableWidth = fullWidth - pageWidth + this.gutterCenter.length();        if (availableWidth < 2) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));        }    }    /**     * Prints the Option help.     */    public void print() {        printHeader();        printException();        printUsage();        printHelp();        printFooter();        out.flush();    }    /**     * Prints any error message.     */    public void printException() {        if (exception != null) {            printDivider();            printWrapped(exception.getMessage());        }    }    /**     * Prints detailed help per option.     */    public void printHelp() {        printDivider();        final Option option;        if ((exception != null) && (exception.getOption() != null)) {            option = exception.getOption();        } else {            option = group;        }        // grab the HelpLines to display        final List helpLines = option.helpLines(0, displaySettings, comparator);        // calculate the maximum width of the usage strings        int usageWidth = 0;        for (final Iterator i = helpLines.iterator(); i.hasNext();) {            final HelpLine helpLine = (HelpLine) i.next();            final String usage = helpLine.usage(lineUsageSettings, comparator);            usageWidth = Math.max(usageWidth, usage.length());        }        // build a blank string to pad wrapped descriptions        final StringBuffer blankBuffer = new StringBuffer();        for (int i = 0; i < usageWidth; i++) {            blankBuffer.append(' ');        }        // determine the width available for descriptions        final int descriptionWidth = Math.max(1, pageWidth - gutterCenter.length() - usageWidth);        // display each HelpLine        for (final Iterator i = helpLines.iterator(); i.hasNext();) {            // grab the HelpLine            final HelpLine helpLine = (HelpLine) i.next();            // wrap the description            final List descList = wrap(helpLine.getDescription(), descriptionWidth);            final Iterator descriptionIterator = descList.iterator();            // display usage + first line of description            printGutterLeft();            pad(helpLine.usage(lineUsageSettings, comparator), usageWidth, out);            out.print(gutterCenter);            pad((String) descriptionIterator.next(), descriptionWidth, out);            printGutterRight();            out.println();            // display padding + remaining lines of description            while (descriptionIterator.hasNext()) {                printGutterLeft();                //pad(helpLine.getUsage(),usageWidth,out);                out.print(blankBuffer);                out.print(gutterCenter);                pad((String) descriptionIterator.next(), descriptionWidth, out);                printGutterRight();                out.println();            }        }        printDivider();    }    /**     * Prints a single line of usage information (wrapping if necessary)     */    public void printUsage() {        printDivider();        final StringBuffer buffer = new StringBuffer(\"Usage:\\n\");        buffer.append(shellCommand).append(' ');        group.appendUsage(buffer, fullUsageSettings, comparator, \" \");        printWrapped(buffer.toString());    }    /**     * Prints a header string if necessary     */    public void printHeader() {        if (header != null) {            printDivider();            printWrapped(header);        }    }    /**     * Prints a footer string if necessary     */    public void printFooter() {        if (footer != null) {            printWrapped(footer);            printDivider();        }    }    /**     * Prints a string wrapped if necessary     * @param text the string to wrap     */    public void printWrapped(final String text) {        for (final Iterator i = wrap(text, pageWidth).iterator(); i.hasNext();) {            printGutterLeft();            pad((String) i.next(), pageWidth, out);            printGutterRight();            out.println();        }        out.flush();    }    /**     * Prints the left gutter string     */    public void printGutterLeft() {        if (gutterLeft != null) {            out.print(gutterLeft);        }    }    /**     * Prints the right gutter string     */    public void printGutterRight() {        if (gutterRight != null) {            out.print(gutterRight);        }    }    /**     * Prints the divider text     */    public void printDivider() {        if (divider != null) {            out.println(divider);        }    }    protected static void pad(final String text,                              final int width,                              final PrintWriter writer) {        final int left;        // write the text and record how many characters written        if (text == null) {            left = 0;        } else {            writer.write(text);            left = text.length();        }        // pad remainder with spaces        for (int i = left; i < width; ++i) {            writer.write(' ');        }    }    protected static List wrap(final String text,                               final int width) {        // check for valid width        if (width < 1) {            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_WIDTH_TOO_NARROW,                                                                                             new Object[] {                                                                                                 new Integer(width)                                                                                             }));        }        // handle degenerate case        if (text == null) {            return Collections.singletonList(\"\");        }        final List lines = new ArrayList();        final char[] chars = text.toCharArray();        int left = 0;        // for each character in the string        while (left < chars.length) {            // sync left and right indeces            int right = left;            // move right until we run out of characters, width or find a newline            while ((right < chars.length) && (chars[right] != '\\n') &&                       (right < (left + width + 1))) {                right++;            }            // if a newline was found            if ((right < chars.length) && (chars[right] == '\\n')) {                // record the substring                final String line = new String(chars, left, right - left);                lines.add(line);                // move to the end of the substring                left = right + 1;                if (left == chars.length) {                    lines.add(\"\");                }                // restart the loop                continue;            }            // move to the next ideal wrap point            right = (left + width) - 1;            // if we have run out of characters            if (chars.length <= right) {                // record the substring                final String line = new String(chars, left, chars.length - left);                lines.add(line);                // abort the loop                break;            }            // back track the substring end until a space is found            while ((right >= left) && (chars[right] != ' ')) {                right--;            }            // if a space was found            if (right >= left) {                // record the substring to space                final String line = new String(chars, left, right - left);                lines.add(line);                // absorb all the spaces before next substring                while ((right < chars.length) && (chars[right] == ' ')) {                    right++;                }                left = right;                // restart the loop                continue;            }            // move to the wrap position irrespective of spaces            right = Math.min(left + width, chars.length);            // record the substring            final String line = new String(chars, left, right - left);            lines.add(line);            // absorb any the spaces before next substring            while ((right < chars.length) && (chars[right] == ' ')) {                right++;            }            left = right;        }        return lines;    }    /**     * The Comparator to use when sorting Options     * @param comparator Comparator to use when sorting Options     */    public void setComparator(Comparator comparator) {        this.comparator = comparator;    }    /**     * The DisplaySettings used to select the help lines in the main body of     * help     *     * @param displaySettings the settings to use     * @see DisplaySetting     */    public void setDisplaySettings(Set displaySettings) {        this.displaySettings = displaySettings;    }    /**     * Sets the string to use as a divider between sections of help     * @param divider the dividing string     */    public void setDivider(String divider) {        this.divider = divider;    }    /**     * Sets the exception to document     * @param exception the exception that occured     */    public void setException(OptionException exception) {        this.exception = exception;    }    /**     * Sets the footer text of the help screen     * @param footer the footer text     */    public void setFooter(String footer) {        this.footer = footer;    }    /**     * The DisplaySettings used to select the elements to display in the     * displayed line of full usage information.     * @see DisplaySetting     * @param fullUsageSettings     */    public void setFullUsageSettings(Set fullUsageSettings) {        this.fullUsageSettings = fullUsageSettings;    }    /**     * Sets the Group of Options to document     * @param group the options to document     */    public void setGroup(Group group) {        this.group = group;    }    /**     * Sets the footer text of the help screen     * @param header the footer text     */    public void setHeader(String header) {        this.header = header;    }    /**     * Sets the DisplaySettings used to select elements in the per helpline     * usage strings.     * @see DisplaySetting     * @param lineUsageSettings the DisplaySettings to use     */    public void setLineUsageSettings(Set lineUsageSettings) {        this.lineUsageSettings = lineUsageSettings;    }    /**     * Sets the command string used to invoke the application     * @param shellCommand the invokation command     */    public void setShellCommand(String shellCommand) {        this.shellCommand = shellCommand;    }    /**     * @return the Comparator used to sort the Group     */    public Comparator getComparator() {        return comparator;    }    /**     * @return the DisplaySettings used to select HelpLines     */    public Set getDisplaySettings() {        return displaySettings;    }    /**     * @return the String used as a horizontal section divider     */    public String getDivider() {        return divider;    }    /**     * @return the Exception being documented by this HelpFormatter     */    public OptionException getException() {        return exception;    }    /**     * @return the help screen footer text     */    public String getFooter() {        return footer;    }    /**     * @return the DisplaySettings used in the full usage string     */    public Set getFullUsageSettings() {        return fullUsageSettings;    }    /**     * @return the group documented by this HelpFormatter     */    public Group getGroup() {        return group;    }    /**     * @return the String used as the central gutter     */    public String getGutterCenter() {        return gutterCenter;    }    /**     * @return the String used as the left gutter     */    public String getGutterLeft() {        return gutterLeft;    }    /**     * @return the String used as the right gutter     */    public String getGutterRight() {        return gutterRight;    }    /**     * @return the help screen header text     */    public String getHeader() {        return header;    }    /**     * @return the DisplaySettings used in the per help line usage strings     */    public Set getLineUsageSettings() {        return lineUsageSettings;    }    /**     * @return the width of the screen in characters     */    public int getPageWidth() {        return pageWidth;    }    /**     * @return the command used to execute the application     */    public String getShellCommand() {        return shellCommand;    }    /**     * @param out the PrintWriter to write to     */    public void setPrintWriter(PrintWriter out) {        this.out = out;    }    /**     * @return the PrintWriter that will be written to     */    public PrintWriter getPrintWriter() {        return out;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.io.PrintWriter;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * Presents on screen help based on the application's Options\n+ */\n+public class HelpFormatter {\n+    /**\n+     * The default screen width\n+     */\n+    public static final int DEFAULT_FULL_WIDTH = 80;\n+\n+    /**\n+     * The default screen furniture left of screen\n+     */\n+    public static final String DEFAULT_GUTTER_LEFT = \"\";\n+\n+    /**\n+     * The default screen furniture right of screen\n+     */\n+    public static final String DEFAULT_GUTTER_CENTER = \"    \";\n+\n+    /**\n+     * The default screen furniture between columns\n+     */\n+    public static final String DEFAULT_GUTTER_RIGHT = \"\";\n+\n+    /**\n+     * The default DisplaySettings used to select the elements to display in the\n+     * displayed line of full usage information.\n+     *\n+     * @see DisplaySetting\n+     */\n+    public static final Set DEFAULT_FULL_USAGE_SETTINGS;\n+\n+    /**\n+     * The default DisplaySettings used to select the elements of usage per help\n+     * line in the main body of help\n+     *\n+     * @see DisplaySetting\n+     */\n+    public static final Set DEFAULT_LINE_USAGE_SETTINGS;\n+\n+    /**\n+     * The default DisplaySettings used to select the help lines in the main\n+     * body of help\n+     */\n+    public static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n+\n+    static {\n+        final Set fullUsage = new HashSet(DisplaySetting.ALL);\n+        fullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\n+        fullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+        DEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n+\n+        final Set lineUsage = new HashSet();\n+        lineUsage.add(DisplaySetting.DISPLAY_ALIASES);\n+        lineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\n+        lineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        DEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n+\n+        final Set displayUsage = new HashSet(DisplaySetting.ALL);\n+        displayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        DEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n+    }\n+\n+    private Set fullUsageSettings = new HashSet(DEFAULT_FULL_USAGE_SETTINGS);\n+    private Set lineUsageSettings = new HashSet(DEFAULT_LINE_USAGE_SETTINGS);\n+    private Set displaySettings = new HashSet(DEFAULT_DISPLAY_USAGE_SETTINGS);\n+    private OptionException exception = null;\n+    private Group group;\n+    private Comparator comparator = null;\n+    private String divider = null;\n+    private String header = null;\n+    private String footer = null;\n+    private String shellCommand = \"\";\n+    private PrintWriter out = new PrintWriter(System.out);\n+\n+    //or should this default to .err?\n+    private final String gutterLeft;\n+    private final String gutterCenter;\n+    private final String gutterRight;\n+    private final int pageWidth;\n+\n+    /**\n+     * Creates a new HelpFormatter using the defaults\n+     */\n+    public HelpFormatter() {\n+        this(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n+    }\n+\n+    /**\n+     * Creates a new HelpFormatter using the specified parameters\n+     * @param gutterLeft the string marking left of screen\n+     * @param gutterCenter the string marking center of screen\n+     * @param gutterRight the string marking right of screen\n+     * @param fullWidth the width of the screen\n+     */\n+    public HelpFormatter(final String gutterLeft,\n+                         final String gutterCenter,\n+                         final String gutterRight,\n+                         final int fullWidth) {\n+        // default the left gutter to empty string\n+        this.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n+\n+        // default the center gutter to a single space\n+        this.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n+\n+        // default the right gutter to empty string\n+        this.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n+\n+        // calculate the available page width\n+        this.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n+\n+        // check available page width is valid\n+        int availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n+\n+        if (availableWidth < 2) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n+        }\n+    }\n+\n+    /**\n+     * Prints the Option help.\n+     */\n+    public void print() {\n+        printHeader();\n+        printException();\n+        printUsage();\n+        printHelp();\n+        printFooter();\n+        out.flush();\n+    }\n+\n+    /**\n+     * Prints any error message.\n+     */\n+    public void printException() {\n+        if (exception != null) {\n+            printDivider();\n+            printWrapped(exception.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Prints detailed help per option.\n+     */\n+    public void printHelp() {\n+        printDivider();\n+\n+        final Option option;\n+\n+        if ((exception != null) && (exception.getOption() != null)) {\n+            option = exception.getOption();\n+        } else {\n+            option = group;\n+        }\n+\n+        // grab the HelpLines to display\n+        final List helpLines = option.helpLines(0, displaySettings, comparator);\n+\n+        // calculate the maximum width of the usage strings\n+        int usageWidth = 0;\n+\n+        for (final Iterator i = helpLines.iterator(); i.hasNext();) {\n+            final HelpLine helpLine = (HelpLine) i.next();\n+            final String usage = helpLine.usage(lineUsageSettings, comparator);\n+            usageWidth = Math.max(usageWidth, usage.length());\n+        }\n+\n+        // build a blank string to pad wrapped descriptions\n+        final StringBuffer blankBuffer = new StringBuffer();\n+\n+        for (int i = 0; i < usageWidth; i++) {\n+            blankBuffer.append(' ');\n+        }\n+\n+        // determine the width available for descriptions\n+        final int descriptionWidth = Math.max(1, pageWidth - gutterCenter.length() - usageWidth);\n+\n+        // display each HelpLine\n+        for (final Iterator i = helpLines.iterator(); i.hasNext();) {\n+            // grab the HelpLine\n+            final HelpLine helpLine = (HelpLine) i.next();\n+\n+            // wrap the description\n+            final List descList = wrap(helpLine.getDescription(), descriptionWidth);\n+            final Iterator descriptionIterator = descList.iterator();\n+\n+            // display usage + first line of description\n+            printGutterLeft();\n+            pad(helpLine.usage(lineUsageSettings, comparator), usageWidth, out);\n+            out.print(gutterCenter);\n+            pad((String) descriptionIterator.next(), descriptionWidth, out);\n+            printGutterRight();\n+            out.println();\n+\n+            // display padding + remaining lines of description\n+            while (descriptionIterator.hasNext()) {\n+                printGutterLeft();\n+\n+                //pad(helpLine.getUsage(),usageWidth,out);\n+                out.print(blankBuffer);\n+                out.print(gutterCenter);\n+                pad((String) descriptionIterator.next(), descriptionWidth, out);\n+                printGutterRight();\n+                out.println();\n+            }\n+        }\n+\n+        printDivider();\n+    }\n+\n+    /**\n+     * Prints a single line of usage information (wrapping if necessary)\n+     */\n+    public void printUsage() {\n+        printDivider();\n+\n+        final StringBuffer buffer = new StringBuffer(\"Usage:\\n\");\n+        buffer.append(shellCommand).append(' ');\n+        group.appendUsage(buffer, fullUsageSettings, comparator, \" \");\n+        printWrapped(buffer.toString());\n+    }\n+\n+    /**\n+     * Prints a header string if necessary\n+     */\n+    public void printHeader() {\n+        if (header != null) {\n+            printDivider();\n+            printWrapped(header);\n+        }\n+    }\n+\n+    /**\n+     * Prints a footer string if necessary\n+     */\n+    public void printFooter() {\n+        if (footer != null) {\n+            printWrapped(footer);\n+            printDivider();\n+        }\n+    }\n+\n+    /**\n+     * Prints a string wrapped if necessary\n+     * @param text the string to wrap\n+     */\n+    public void printWrapped(final String text) {\n+        for (final Iterator i = wrap(text, pageWidth).iterator(); i.hasNext();) {\n+            printGutterLeft();\n+            pad((String) i.next(), pageWidth, out);\n+            printGutterRight();\n+            out.println();\n+        }\n+\n+        out.flush();\n+    }\n+\n+    /**\n+     * Prints the left gutter string\n+     */\n+    public void printGutterLeft() {\n+        if (gutterLeft != null) {\n+            out.print(gutterLeft);\n+        }\n+    }\n+\n+    /**\n+     * Prints the right gutter string\n+     */\n+    public void printGutterRight() {\n+        if (gutterRight != null) {\n+            out.print(gutterRight);\n+        }\n+    }\n+\n+    /**\n+     * Prints the divider text\n+     */\n+    public void printDivider() {\n+        if (divider != null) {\n+            out.println(divider);\n+        }\n+    }\n+\n+    protected static void pad(final String text,\n+                              final int width,\n+                              final PrintWriter writer) {\n+        final int left;\n+\n+        // write the text and record how many characters written\n+        if (text == null) {\n+            left = 0;\n+        } else {\n+            writer.write(text);\n+            left = text.length();\n+        }\n+\n+        // pad remainder with spaces\n+        for (int i = left; i < width; ++i) {\n+            writer.write(' ');\n+        }\n+    }\n+\n+    protected static List wrap(final String text,\n+                               final int width) {\n+        // check for valid width\n+        if (width < 1) {\n+            throw new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_WIDTH_TOO_NARROW,\n+                                                                                             new Object[] {\n+                                                                                                 new Integer(width)\n+                                                                                             }));\n+        }\n+\n+        // handle degenerate case\n+        if (text == null) {\n+            return Collections.singletonList(\"\");\n+        }\n+\n+        final List lines = new ArrayList();\n+        final char[] chars = text.toCharArray();\n+        int left = 0;\n+\n+        // for each character in the string\n+        while (left < chars.length) {\n+            // sync left and right indeces\n+            int right = left;\n+\n+            // move right until we run out of characters, width or find a newline\n+            while ((right < chars.length) && (chars[right] != '\\n') &&\n+                       (right < (left + width + 1))) {\n+                right++;\n+            }\n+\n+            // if a newline was found\n+            if ((right < chars.length) && (chars[right] == '\\n')) {\n+                // record the substring\n+                final String line = new String(chars, left, right - left);\n+                lines.add(line);\n+\n+                // move to the end of the substring\n+                left = right + 1;\n+\n+                if (left == chars.length) {\n+                    lines.add(\"\");\n+                }\n+\n+                // restart the loop\n+                continue;\n+            }\n+\n+            // move to the next ideal wrap point \n+            right = (left + width) - 1;\n+\n+            // if we have run out of characters\n+            if (chars.length <= right) {\n+                // record the substring\n+                final String line = new String(chars, left, chars.length - left);\n+                lines.add(line);\n+\n+                // abort the loop\n+                break;\n+            }\n+\n+            // back track the substring end until a space is found\n+            while ((right >= left) && (chars[right] != ' ')) {\n+                right--;\n+            }\n+\n+            // if a space was found\n+            if (right >= left) {\n+                // record the substring to space\n+                final String line = new String(chars, left, right - left);\n+                lines.add(line);\n+\n+                // absorb all the spaces before next substring\n+                while ((right < chars.length) && (chars[right] == ' ')) {\n+                    right++;\n+                }\n+\n+                left = right;\n+\n+                // restart the loop\n+                continue;\n+            }\n+\n+            // move to the wrap position irrespective of spaces\n+            right = Math.min(left + width, chars.length);\n+\n+            // record the substring\n+            final String line = new String(chars, left, right - left);\n+            lines.add(line);\n+\n+            // absorb any the spaces before next substring\n+            while ((right < chars.length) && (chars[right] == ' ')) {\n+                right++;\n+            }\n+\n+            left = right;\n+        }\n+\n+        return lines;\n+    }\n+\n+    /**\n+     * The Comparator to use when sorting Options\n+     * @param comparator Comparator to use when sorting Options\n+     */\n+    public void setComparator(Comparator comparator) {\n+        this.comparator = comparator;\n+    }\n+\n+    /**\n+     * The DisplaySettings used to select the help lines in the main body of\n+     * help\n+     *\n+     * @param displaySettings the settings to use\n+     * @see DisplaySetting\n+     */\n+    public void setDisplaySettings(Set displaySettings) {\n+        this.displaySettings = displaySettings;\n+    }\n+\n+    /**\n+     * Sets the string to use as a divider between sections of help\n+     * @param divider the dividing string\n+     */\n+    public void setDivider(String divider) {\n+        this.divider = divider;\n+    }\n+\n+    /**\n+     * Sets the exception to document\n+     * @param exception the exception that occured\n+     */\n+    public void setException(OptionException exception) {\n+        this.exception = exception;\n+    }\n+\n+    /**\n+     * Sets the footer text of the help screen\n+     * @param footer the footer text\n+     */\n+    public void setFooter(String footer) {\n+        this.footer = footer;\n+    }\n+\n+    /**\n+     * The DisplaySettings used to select the elements to display in the\n+     * displayed line of full usage information.\n+     * @see DisplaySetting\n+     * @param fullUsageSettings\n+     */\n+    public void setFullUsageSettings(Set fullUsageSettings) {\n+        this.fullUsageSettings = fullUsageSettings;\n+    }\n+\n+    /**\n+     * Sets the Group of Options to document\n+     * @param group the options to document\n+     */\n+    public void setGroup(Group group) {\n+        this.group = group;\n+    }\n+\n+    /**\n+     * Sets the footer text of the help screen\n+     * @param header the footer text\n+     */\n+    public void setHeader(String header) {\n+        this.header = header;\n+    }\n+\n+    /**\n+     * Sets the DisplaySettings used to select elements in the per helpline\n+     * usage strings.\n+     * @see DisplaySetting\n+     * @param lineUsageSettings the DisplaySettings to use\n+     */\n+    public void setLineUsageSettings(Set lineUsageSettings) {\n+        this.lineUsageSettings = lineUsageSettings;\n+    }\n+\n+    /**\n+     * Sets the command string used to invoke the application\n+     * @param shellCommand the invokation command\n+     */\n+    public void setShellCommand(String shellCommand) {\n+        this.shellCommand = shellCommand;\n+    }\n+\n+    /**\n+     * @return the Comparator used to sort the Group\n+     */\n+    public Comparator getComparator() {\n+        return comparator;\n+    }\n+\n+    /**\n+     * @return the DisplaySettings used to select HelpLines\n+     */\n+    public Set getDisplaySettings() {\n+        return displaySettings;\n+    }\n+\n+    /**\n+     * @return the String used as a horizontal section divider\n+     */\n+    public String getDivider() {\n+        return divider;\n+    }\n+\n+    /**\n+     * @return the Exception being documented by this HelpFormatter\n+     */\n+    public OptionException getException() {\n+        return exception;\n+    }\n+\n+    /**\n+     * @return the help screen footer text\n+     */\n+    public String getFooter() {\n+        return footer;\n+    }\n+\n+    /**\n+     * @return the DisplaySettings used in the full usage string\n+     */\n+    public Set getFullUsageSettings() {\n+        return fullUsageSettings;\n+    }\n+\n+    /**\n+     * @return the group documented by this HelpFormatter\n+     */\n+    public Group getGroup() {\n+        return group;\n+    }\n+\n+    /**\n+     * @return the String used as the central gutter\n+     */\n+    public String getGutterCenter() {\n+        return gutterCenter;\n+    }\n+\n+    /**\n+     * @return the String used as the left gutter\n+     */\n+    public String getGutterLeft() {\n+        return gutterLeft;\n+    }\n+\n+    /**\n+     * @return the String used as the right gutter\n+     */\n+    public String getGutterRight() {\n+        return gutterRight;\n+    }\n+\n+    /**\n+     * @return the help screen header text\n+     */\n+    public String getHeader() {\n+        return header;\n+    }\n+\n+    /**\n+     * @return the DisplaySettings used in the per help line usage strings\n+     */\n+    public Set getLineUsageSettings() {\n+        return lineUsageSettings;\n+    }\n+\n+    /**\n+     * @return the width of the screen in characters\n+     */\n+    public int getPageWidth() {\n+        return pageWidth;\n+    }\n+\n+    /**\n+     * @return the command used to execute the application\n+     */\n+    public String getShellCommand() {\n+        return shellCommand;\n+    }\n+\n+    /**\n+     * @param out the PrintWriter to write to\n+     */\n+    public void setPrintWriter(PrintWriter out) {\n+        this.out = out;\n+    }\n+\n+    /**\n+     * @return the PrintWriter that will be written to\n+     */\n+    public PrintWriter getPrintWriter() {\n+        return out;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/ClassValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/ClassValidator.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.util.List;import java.util.ListIterator;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * The <code>ClassValidator</code> validates the string argument * values are class names. * * The following example shows how to validate the 'logger' * argument value is a class name, that can be instantiated. * * <pre> * ... * ClassValidator validator = new ClassValidator(); * validator.setInstance(true); * * ArgumentBuilder builder = new ArgumentBuilder(); * Argument logger = *     builder.withName(\"logger\"); *            .withValidator(validator); * </pre> * * @author John Keyes */public class ClassValidator implements Validator {    /** i18n */    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    /** whether the class argument is loadable */    private boolean loadable;    /** whether to create an instance of the class */    private boolean instance;    /** the classloader to load classes from */    private ClassLoader loader;    /**     * Validate each argument value in the specified List against this instances     * permitted attributes.     *     * If a value is valid then it's <code>String</code> value in the list is     * replaced with it's <code>Class</code> value or instance.     *     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)     */    public void validate(final List values)        throws InvalidArgumentException {        for (final ListIterator i = values.listIterator(); i.hasNext();) {            final String name = (String) i.next();            if (!isPotentialClassName(name)) {                throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_BAD_CLASSNAME,                                                                        name));            }            if (loadable || instance) {                final ClassLoader theLoader = getClassLoader();                try {                    final Class clazz = theLoader.loadClass(name);                    if (instance) {                        i.set(clazz.newInstance());                    } else {                        i.set(clazz);                    }                } catch (final ClassNotFoundException exp) {                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_NOTFOUND,                                                                            name));                } catch (final IllegalAccessException exp) {                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_ACCESS,                                                                            name, exp.getMessage()));                } catch (final InstantiationException exp) {                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_CREATE,                                                                            name));                }            }        }    }    /**     * Returns whether the argument value must represent a     * class that is loadable.     *     * @return whether the argument value must represent a     * class that is loadable.     */    public boolean isLoadable() {        return loadable;    }    /**     * Specifies whether the argument value must represent a     * class that is loadable.     *     * @param loadable whether the argument value must     * represent a class that is loadable.     */    public void setLoadable(boolean loadable) {        this.loadable = loadable;    }    /**     * Returns the {@link ClassLoader} used to resolve and load     * the classes specified by the argument values.     *     * @return the {@link ClassLoader} used to resolve and load     * the classes specified by the argument values.     */    public ClassLoader getClassLoader() {        if (loader == null) {            loader = getClass().getClassLoader();        }        return loader;    }    /**     * Specifies the {@link ClassLoader} used to resolve and load     * the classes specified by the argument values.     *     * @param loader the {@link ClassLoader} used to resolve and load     * the classes specified by the argument values.     */    public void setClassLoader(ClassLoader loader) {        this.loader = loader;    }    /**     * Returns whether the argument value must represent a     * class that can be instantiated.     *     * @return whether the argument value must represent a     * class that can be instantiated.     */    public boolean isInstance() {        return instance;    }    /**     * Specifies whether the argument value must represent a     * class that can be instantiated.     *     * @param instance whether the argument value must     * represent a class that can be instantiated.     */    public void setInstance(boolean instance) {        this.instance = instance;    }    /**     * Returns whether the specified name is allowed as     * a Java class name.     */    protected boolean isPotentialClassName(final String name) {        final char[] chars = name.toCharArray();        boolean expectingStart = true;        for (int i = 0; i < chars.length; ++i) {            final char c = chars[i];            if (expectingStart) {                if (!Character.isJavaIdentifierStart(c)) {                    return false;                }                expectingStart = false;            } else {                if (c == '.') {                    expectingStart = true;                } else if (!Character.isJavaIdentifierPart(c)) {                    return false;                }            }        }        return !expectingStart;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * The <code>ClassValidator</code> validates the string argument\n+ * values are class names.\n+ *\n+ * The following example shows how to validate the 'logger'\n+ * argument value is a class name, that can be instantiated.\n+ *\n+ * <pre>\n+ * ...\n+ * ClassValidator validator = new ClassValidator();\n+ * validator.setInstance(true);\n+ *\n+ * ArgumentBuilder builder = new ArgumentBuilder();\n+ * Argument logger =\n+ *     builder.withName(\"logger\");\n+ *            .withValidator(validator);\n+ * </pre>\n+ *\n+ * @author John Keyes\n+ */\n+public class ClassValidator implements Validator {\n+    /** i18n */\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    /** whether the class argument is loadable */\n+    private boolean loadable;\n+\n+    /** whether to create an instance of the class */\n+    private boolean instance;\n+\n+    /** the classloader to load classes from */\n+    private ClassLoader loader;\n+\n+    /**\n+     * Validate each argument value in the specified List against this instances\n+     * permitted attributes.\n+     *\n+     * If a value is valid then it's <code>String</code> value in the list is\n+     * replaced with it's <code>Class</code> value or instance.\n+     *\n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String name = (String) i.next();\n+\n+            if (!isPotentialClassName(name)) {\n+                throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_BAD_CLASSNAME,\n+                                                                        name));\n+            }\n+\n+            if (loadable || instance) {\n+                final ClassLoader theLoader = getClassLoader();\n+\n+                try {\n+                    final Class clazz = theLoader.loadClass(name);\n+\n+                    if (instance) {\n+                        i.set(clazz.newInstance());\n+                    } else {\n+                        i.set(clazz);\n+                    }\n+                } catch (final ClassNotFoundException exp) {\n+                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_NOTFOUND,\n+                                                                            name));\n+                } catch (final IllegalAccessException exp) {\n+                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_ACCESS,\n+                                                                            name, exp.getMessage()));\n+                } catch (final InstantiationException exp) {\n+                    throw new InvalidArgumentException(resources.getMessage(ResourceConstants.CLASSVALIDATOR_CLASS_CREATE,\n+                                                                            name));\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the argument value must represent a\n+     * class that is loadable.\n+     *\n+     * @return whether the argument value must represent a\n+     * class that is loadable.\n+     */\n+    public boolean isLoadable() {\n+        return loadable;\n+    }\n+\n+    /**\n+     * Specifies whether the argument value must represent a\n+     * class that is loadable.\n+     *\n+     * @param loadable whether the argument value must\n+     * represent a class that is loadable.\n+     */\n+    public void setLoadable(boolean loadable) {\n+        this.loadable = loadable;\n+    }\n+\n+    /**\n+     * Returns the {@link ClassLoader} used to resolve and load\n+     * the classes specified by the argument values.\n+     *\n+     * @return the {@link ClassLoader} used to resolve and load\n+     * the classes specified by the argument values.\n+     */\n+    public ClassLoader getClassLoader() {\n+        if (loader == null) {\n+            loader = getClass().getClassLoader();\n+        }\n+\n+        return loader;\n+    }\n+\n+    /**\n+     * Specifies the {@link ClassLoader} used to resolve and load\n+     * the classes specified by the argument values.\n+     *\n+     * @param loader the {@link ClassLoader} used to resolve and load\n+     * the classes specified by the argument values.\n+     */\n+    public void setClassLoader(ClassLoader loader) {\n+        this.loader = loader;\n+    }\n+\n+    /**\n+     * Returns whether the argument value must represent a\n+     * class that can be instantiated.\n+     *\n+     * @return whether the argument value must represent a\n+     * class that can be instantiated.\n+     */\n+    public boolean isInstance() {\n+        return instance;\n+    }\n+\n+    /**\n+     * Specifies whether the argument value must represent a\n+     * class that can be instantiated.\n+     *\n+     * @param instance whether the argument value must\n+     * represent a class that can be instantiated.\n+     */\n+    public void setInstance(boolean instance) {\n+        this.instance = instance;\n+    }\n+\n+    /**\n+     * Returns whether the specified name is allowed as\n+     * a Java class name.\n+     */\n+    protected boolean isPotentialClassName(final String name) {\n+        final char[] chars = name.toCharArray();\n+\n+        boolean expectingStart = true;\n+\n+        for (int i = 0; i < chars.length; ++i) {\n+            final char c = chars[i];\n+\n+            if (expectingStart) {\n+                if (!Character.isJavaIdentifierStart(c)) {\n+                    return false;\n+                }\n+\n+                expectingStart = false;\n+            } else {\n+                if (c == '.') {\n+                    expectingStart = true;\n+                } else if (!Character.isJavaIdentifierPart(c)) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return !expectingStart;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/DateValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/DateValidator.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.text.DateFormat;import java.text.ParsePosition;import java.util.Date;import java.util.List;import java.util.ListIterator;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * The <code>DateValidator</code> validates the argument values * are date or time value(s). * * The following example shows how to validate that * an argument value(s) is a Date of the following * type: d/M/yy (see {@link java.text.DateFormat}). * * <pre> * DateFormat date = new SimpleDateFormat(\"d/M/yy\"); * ... * ArgumentBuilder builder = new ArgumentBuilder(); * Argument dateFormat = *     builder.withName(\"date\"); *            .withValidator(new DateValidator(dateFormat)); * </pre> * * The following example shows how to validate that * an argument value(s) is a time of the following * type: HH:mm:ss (see {@link java.text.DateFormat}). * * <pre> * DateFormat timeFormat = new SimpleDateFormat(\"HH:mm:ss\"); * ... * ArgumentBuilder builder = new ArgumentBuilder(); * Argument time = *     builder.withName(\"time\"); *            .withValidator(new DateValidator(timeFormat)); * </pre> * * @author John Keyes * * @see java.text.DateFormat */public class DateValidator implements Validator {    /** i18n */    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    /** an array of permitted DateFormats */    private DateFormat[] formats;    /** minimum Date allowed i.e: a valid date occurs later than this date */    private Date minimum;    /** maximum Date allowed i.e: a valid date occurs earlier than this date */    private Date maximum;    /** leniant parsing */    private boolean isLenient;    /**     * Creates a Validator for the default date/time format     */    public DateValidator() {        this(DateFormat.getInstance());    }    /**     * Creates a Validator for the specified DateFormat.     *     * @param format     *            a DateFormat which dates must conform to     */    public DateValidator(final DateFormat format) {        setFormat(format);    }    /**     * Creates a Validator for the List of specified DateFormats.     *     * @param formats     *            a List of DateFormats which dates must conform to     */    public DateValidator(final List formats) {        setFormats(formats);    }    /**     * Creates a Validator for dates.     *     * @return DateValidator a Validator for dates     */    public static DateValidator getDateInstance() {        return new DateValidator(DateFormat.getDateInstance());    }    /**     * Creates a Validator for times.     *     * @return DateValidator a Validator for times     */    public static DateValidator getTimeInstance() {        return new DateValidator(DateFormat.getTimeInstance());    }    /**     * Creates a Validator for date/times     *     * @return DateValidator a Validator for date/times     */    public static DateValidator getDateTimeInstance() {        return new DateValidator(DateFormat.getDateTimeInstance());    }    /**     * Validate each String value in the specified List against this instances     * permitted DateFormats.     *     * If a value is valid then it's <code>String</code> value in the list is     * replaced with it's <code>Date</code> value.     *     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)     */    public void validate(final List values)        throws InvalidArgumentException {        // for each value        for (final ListIterator i = values.listIterator(); i.hasNext();) {            final String value = (String) i.next();            Date date = null;            // create a resuable ParsePosition instance            final ParsePosition pp = new ParsePosition(0);            // for each permitted DateFormat            for (int f = 0; (f < this.formats.length) && (date == null); ++f) {                // reset the parse position                pp.setIndex(0);                date = this.formats[f].parse(value, pp);                // if the wrong number of characters have been parsed                if (pp.getIndex() < value.length()) {                    date = null;                }            }            // if date has not been set throw an InvalidArgumentException            if (date == null) {                throw new InvalidArgumentException(value);            }            // if the date is outside the bounds            if (isDateEarlier(date) || isDateLater(date)) {                throw new InvalidArgumentException(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,                                                                        value));            }            // replace the value in the list with the actual Date            i.set(date);        }    }    /**     * Sets whether this validator uses lenient parsing.     *     * @param lenient whether this validator uses lenient parsing     */    public void setLenient(final boolean lenient) {        for (int i = 0; i < this.formats.length; i++) {            this.formats[i].setLenient(lenient);        }        this.isLenient = lenient;    }    /**     * Returns whether this validator uses lenient parsing.     *     * @return whether this validator uses lenient parsing     */    public boolean isLenient() {        return this.isLenient;    }    /**     * Returns the maximum date permitted.     *     * @return Date the maximum date permitted. If no maximum date has been     *         specified then return <code>null</code>.     */    public Date getMaximum() {        return maximum;    }    /**     * Sets the maximum Date to the specified value.     *     * @param maximum     *            the maximum Date permitted     */    public void setMaximum(final Date maximum) {        this.maximum = maximum;    }    /**     * Returns the minimum date permitted.     *     * @return Date the minimum date permitted. If no minimum date has been     *         specified then return <code>null</code>.     */    public Date getMinimum() {        return minimum;    }    /**     * Sets the minimum Date to the specified value.     *     * @param minimum     *            the minimum Date permitted     */    public void setMinimum(Date minimum) {        this.minimum = minimum;    }    /**     * Returns whether the specified Date is later than the maximum date.     *     * @param date     *            the Date to evaluate     *     * @return boolean whether <code>date</code> is earlier than the maximum     *         date     */    private boolean isDateLater(Date date) {        return (maximum != null) && (date.getTime() > maximum.getTime());    }    /**     * Returns whether the specified Date is earlier than the minimum date.     *     * @param date     *            the Date to evaluate     *     * @return boolean whether <code>date</code> is earlier than the minimum     *         date     */    private boolean isDateEarlier(Date date) {        return (minimum != null) && (date.getTime() < minimum.getTime());    }    /**     * Sets the date format permitted.     *     * @param format     *              the format to use     */    public void setFormat(final DateFormat format) {        setFormats(new DateFormat[] { format });    }    /**     * Sets the date formats permitted.     *     * @param formats     *               the List of DateFormats to use     */    public void setFormats(final List formats) {        setFormats((DateFormat[]) formats.toArray(new DateFormat[formats.size()]));    }    /**     * Sets the date formats permitted.     *     * @param formats     *               the array of DateFormats to use     */    public void setFormats(final DateFormat[] formats) {        this.formats = formats;        setLenient(this.isLenient);    }    /**     * Gets the date formats permitted.     *     * @return the permitted formats     */    public DateFormat[] getFormats() {        return this.formats;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.DateFormat;\n+import java.text.ParsePosition;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * The <code>DateValidator</code> validates the argument values\n+ * are date or time value(s).\n+ *\n+ * The following example shows how to validate that\n+ * an argument value(s) is a Date of the following\n+ * type: d/M/yy (see {@link java.text.DateFormat}).\n+ *\n+ * <pre>\n+ * DateFormat date = new SimpleDateFormat(\"d/M/yy\");\n+ * ...\n+ * ArgumentBuilder builder = new ArgumentBuilder();\n+ * Argument dateFormat =\n+ *     builder.withName(\"date\");\n+ *            .withValidator(new DateValidator(dateFormat));\n+ * </pre>\n+ *\n+ * The following example shows how to validate that\n+ * an argument value(s) is a time of the following\n+ * type: HH:mm:ss (see {@link java.text.DateFormat}).\n+ *\n+ * <pre>\n+ * DateFormat timeFormat = new SimpleDateFormat(\"HH:mm:ss\");\n+ * ...\n+ * ArgumentBuilder builder = new ArgumentBuilder();\n+ * Argument time =\n+ *     builder.withName(\"time\");\n+ *            .withValidator(new DateValidator(timeFormat));\n+ * </pre>\n+ *\n+ * @author John Keyes\n+ *\n+ * @see java.text.DateFormat\n+ */\n+public class DateValidator implements Validator {\n+    /** i18n */\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    /** an array of permitted DateFormats */\n+    private DateFormat[] formats;\n+\n+    /** minimum Date allowed i.e: a valid date occurs later than this date */\n+    private Date minimum;\n+\n+    /** maximum Date allowed i.e: a valid date occurs earlier than this date */\n+    private Date maximum;\n+\n+    /** leniant parsing */\n+    private boolean isLenient;\n+\n+    /**\n+     * Creates a Validator for the default date/time format\n+     */\n+    public DateValidator() {\n+        this(DateFormat.getInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for the specified DateFormat.\n+     *\n+     * @param format\n+     *            a DateFormat which dates must conform to\n+     */\n+    public DateValidator(final DateFormat format) {\n+        setFormat(format);\n+    }\n+\n+    /**\n+     * Creates a Validator for the List of specified DateFormats.\n+     *\n+     * @param formats\n+     *            a List of DateFormats which dates must conform to\n+     */\n+    public DateValidator(final List formats) {\n+        setFormats(formats);\n+    }\n+\n+    /**\n+     * Creates a Validator for dates.\n+     *\n+     * @return DateValidator a Validator for dates\n+     */\n+    public static DateValidator getDateInstance() {\n+        return new DateValidator(DateFormat.getDateInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for times.\n+     *\n+     * @return DateValidator a Validator for times\n+     */\n+    public static DateValidator getTimeInstance() {\n+        return new DateValidator(DateFormat.getTimeInstance());\n+    }\n+\n+    /**\n+     * Creates a Validator for date/times\n+     *\n+     * @return DateValidator a Validator for date/times\n+     */\n+    public static DateValidator getDateTimeInstance() {\n+        return new DateValidator(DateFormat.getDateTimeInstance());\n+    }\n+\n+    /**\n+     * Validate each String value in the specified List against this instances\n+     * permitted DateFormats.\n+     *\n+     * If a value is valid then it's <code>String</code> value in the list is\n+     * replaced with it's <code>Date</code> value.\n+     *\n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n+        // for each value\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String value = (String) i.next();\n+\n+            Date date = null;\n+\n+            // create a resuable ParsePosition instance\n+            final ParsePosition pp = new ParsePosition(0);\n+\n+            // for each permitted DateFormat\n+            for (int f = 0; (f < this.formats.length) && (date == null); ++f) {\n+                // reset the parse position\n+                pp.setIndex(0);\n+                date = this.formats[f].parse(value, pp);\n+\n+                // if the wrong number of characters have been parsed\n+                if (pp.getIndex() < value.length()) {\n+                    date = null;\n+                }\n+            }\n+\n+            // if date has not been set throw an InvalidArgumentException\n+            if (date == null) {\n+                throw new InvalidArgumentException(value);\n+            }\n+\n+            // if the date is outside the bounds\n+            if (isDateEarlier(date) || isDateLater(date)) {\n+                throw new InvalidArgumentException(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,\n+                                                                        value));\n+            }\n+\n+            // replace the value in the list with the actual Date\n+            i.set(date);\n+        }\n+    }\n+\n+    /**\n+     * Sets whether this validator uses lenient parsing.\n+     *\n+     * @param lenient whether this validator uses lenient parsing\n+     */\n+    public void setLenient(final boolean lenient) {\n+        for (int i = 0; i < this.formats.length; i++) {\n+            this.formats[i].setLenient(lenient);\n+        }\n+\n+        this.isLenient = lenient;\n+    }\n+\n+    /**\n+     * Returns whether this validator uses lenient parsing.\n+     *\n+     * @return whether this validator uses lenient parsing\n+     */\n+    public boolean isLenient() {\n+        return this.isLenient;\n+    }\n+\n+    /**\n+     * Returns the maximum date permitted.\n+     *\n+     * @return Date the maximum date permitted. If no maximum date has been\n+     *         specified then return <code>null</code>.\n+     */\n+    public Date getMaximum() {\n+        return maximum;\n+    }\n+\n+    /**\n+     * Sets the maximum Date to the specified value.\n+     *\n+     * @param maximum\n+     *            the maximum Date permitted\n+     */\n+    public void setMaximum(final Date maximum) {\n+        this.maximum = maximum;\n+    }\n+\n+    /**\n+     * Returns the minimum date permitted.\n+     *\n+     * @return Date the minimum date permitted. If no minimum date has been\n+     *         specified then return <code>null</code>.\n+     */\n+    public Date getMinimum() {\n+        return minimum;\n+    }\n+\n+    /**\n+     * Sets the minimum Date to the specified value.\n+     *\n+     * @param minimum\n+     *            the minimum Date permitted\n+     */\n+    public void setMinimum(Date minimum) {\n+        this.minimum = minimum;\n+    }\n+\n+    /**\n+     * Returns whether the specified Date is later than the maximum date.\n+     *\n+     * @param date\n+     *            the Date to evaluate\n+     *\n+     * @return boolean whether <code>date</code> is earlier than the maximum\n+     *         date\n+     */\n+    private boolean isDateLater(Date date) {\n+        return (maximum != null) && (date.getTime() > maximum.getTime());\n+    }\n+\n+    /**\n+     * Returns whether the specified Date is earlier than the minimum date.\n+     *\n+     * @param date\n+     *            the Date to evaluate\n+     *\n+     * @return boolean whether <code>date</code> is earlier than the minimum\n+     *         date\n+     */\n+    private boolean isDateEarlier(Date date) {\n+        return (minimum != null) && (date.getTime() < minimum.getTime());\n+    }\n+\n+    /**\n+     * Sets the date format permitted.\n+     *\n+     * @param format\n+     *              the format to use\n+     */\n+    public void setFormat(final DateFormat format) {\n+        setFormats(new DateFormat[] { format });\n+    }\n+\n+    /**\n+     * Sets the date formats permitted.\n+     *\n+     * @param formats\n+     *               the List of DateFormats to use\n+     */\n+    public void setFormats(final List formats) {\n+        setFormats((DateFormat[]) formats.toArray(new DateFormat[formats.size()]));\n+    }\n+\n+    /**\n+     * Sets the date formats permitted.\n+     *\n+     * @param formats\n+     *               the array of DateFormats to use\n+     */\n+    public void setFormats(final DateFormat[] formats) {\n+        this.formats = formats;\n+        setLenient(this.isLenient);\n+    }\n+\n+    /**\n+     * Gets the date formats permitted.\n+     *\n+     * @return the permitted formats\n+     */\n+    public DateFormat[] getFormats() {\n+        return this.formats;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/EnumValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/EnumValidator.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.util.Iterator;import java.util.List;import java.util.Set;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * The <code>EnumValidator</code> validates the string argument * values are valid. * * The following example shows how to limit the valid values * for the color argument to 'red', 'green', or 'blue'. * * <pre> * Set values = new HashSet(); * values.add(\"red\"); * values.add(\"green\"); * values.add(\"blue\"); * ... * ArgumentBuilder builder = new ArgumentBuilder(); * Argument color = *     builder.withName(\"color\"); *            .withValidator(new EnumValidator(values)); * </pre> * * @author John Keyes */public class EnumValidator implements Validator {    /** List of permitted values */    private Set validValues;    /**     * Creates a new EnumValidator for the specified values.     *     * @param values The list of permitted values     */    public EnumValidator(final Set values) {        setValidValues(values);    }    /**     * Validate the list of values against the list of permitted values.     *     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)     */    public void validate(final List values)        throws InvalidArgumentException {        for (final Iterator iter = values.iterator(); iter.hasNext();) {            final String value = (String) iter.next();            if (!this.validValues.contains(value)) {                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ENUM_ILLEGAL_VALUE,                                                                                                 new Object[] {                                                                                                     value,                                                                                                     getValuesAsString()                                                                                                 }));            }        }    }    /**     * Returns the permitted values in a comma separated String     *     * @return String formatted list of values     */    String getValuesAsString() {        final StringBuffer buff = new StringBuffer();        buff.append(\"[\");        for (final Iterator iter = this.validValues.iterator(); iter.hasNext();) {            buff.append(\"'\").append(iter.next()).append(\"'\");            if (iter.hasNext()) {                buff.append(\", \");            }        }        buff.append(\"]\");        return buff.toString();    }    /**     * Returns the Set of valid argument values.     *     * @return Returns the Set of valid argument values.     */    public Set getValidValues() {        return validValues;    }    /**     * Specifies the Set of valid argument values.     *     * @param validValues The Set of valid argument values.     */    protected void setValidValues(Set validValues) {        this.validValues = validValues;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * The <code>EnumValidator</code> validates the string argument\n+ * values are valid.\n+ *\n+ * The following example shows how to limit the valid values\n+ * for the color argument to 'red', 'green', or 'blue'.\n+ *\n+ * <pre>\n+ * Set values = new HashSet();\n+ * values.add(\"red\");\n+ * values.add(\"green\");\n+ * values.add(\"blue\");\n+ * ...\n+ * ArgumentBuilder builder = new ArgumentBuilder();\n+ * Argument color =\n+ *     builder.withName(\"color\");\n+ *            .withValidator(new EnumValidator(values));\n+ * </pre>\n+ *\n+ * @author John Keyes\n+ */\n+public class EnumValidator implements Validator {\n+    /** List of permitted values */\n+    private Set validValues;\n+\n+    /**\n+     * Creates a new EnumValidator for the specified values.\n+     *\n+     * @param values The list of permitted values\n+     */\n+    public EnumValidator(final Set values) {\n+        setValidValues(values);\n+    }\n+\n+    /**\n+     * Validate the list of values against the list of permitted values.\n+     *\n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n+        for (final Iterator iter = values.iterator(); iter.hasNext();) {\n+            final String value = (String) iter.next();\n+\n+            if (!this.validValues.contains(value)) {\n+                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ENUM_ILLEGAL_VALUE,\n+                                                                                                 new Object[] {\n+                                                                                                     value,\n+                                                                                                     getValuesAsString()\n+                                                                                                 }));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the permitted values in a comma separated String\n+     *\n+     * @return String formatted list of values\n+     */\n+    String getValuesAsString() {\n+        final StringBuffer buff = new StringBuffer();\n+\n+        buff.append(\"[\");\n+\n+        for (final Iterator iter = this.validValues.iterator(); iter.hasNext();) {\n+            buff.append(\"'\").append(iter.next()).append(\"'\");\n+\n+            if (iter.hasNext()) {\n+                buff.append(\", \");\n+            }\n+        }\n+\n+        buff.append(\"]\");\n+\n+        return buff.toString();\n+    }\n+\n+    /**\n+     * Returns the Set of valid argument values.\n+     *\n+     * @return Returns the Set of valid argument values.\n+     */\n+    public Set getValidValues() {\n+        return validValues;\n+    }\n+\n+    /**\n+     * Specifies the Set of valid argument values.\n+     *\n+     * @param validValues The Set of valid argument values.\n+     */\n+    protected void setValidValues(Set validValues) {\n+        this.validValues = validValues;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/FileValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/FileValidator.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.io.File;import java.util.List;import java.util.ListIterator;/** * The <code>FileValidator</code> validates the string argument * values are files.  If the value is a file, the string value in * the {@link java.util.List} of values is replaced with the * {@link java.io.File} instance. * * The following attributes can also be specified using the * appropriate settors: * <ul> *  <li>writable</li> *  <li>readable</li> *  <li>hidden</li> *  <li>existing</li> *  <li>is a file</li> *  <li>is a directory</li> * </ul> * * The following example shows how to limit the valid values * for the config attribute to files that are readable, writeable, * and that already existing. * * <pre> * ... * ArgumentBuilder builder = new ArgumentBuilder(); * FileValidator validator = FileValidator.getExistingFileInstance(); * validator.setReadable(true); * validator.setWritable(true); * * Argument age = *     builder.withName(\"config\"); *            .withValidator(validator); * </pre> * * @author Rob Oxspring * @author John Keyes */public class FileValidator implements Validator {    /**     * Returns a <code>FileValidator</code> for existing files/directories.     *     * @return a <code>FileValidator</code> for existing files/directories.     */    public static FileValidator getExistingInstance() {        final FileValidator validator = new FileValidator();        validator.setExisting(true);        return validator;    }    /**     * Returns a <code>FileValidator</code> for existing files.     *     * @return a <code>FileValidator</code> for existing files.     */    public static FileValidator getExistingFileInstance() {        final FileValidator validator = new FileValidator();        validator.setExisting(true);        validator.setFile(true);        return validator;    }    /**     * Returns a <code>FileValidator</code> for existing directories.     *     * @return a <code>FileValidator</code> for existing directories.     */    public static FileValidator getExistingDirectoryInstance() {        final FileValidator validator = new FileValidator();        validator.setExisting(true);        validator.setDirectory(true);        return validator;    }    /** whether the argument value is readable */    private boolean readable = false;    /** whether the argument value is writable */    private boolean writable = false;    /** whether the argument value exists */    private boolean existing = false;    /** whether the argument value is a directory */    private boolean directory = false;    /** whether the argument value is a file */    private boolean file = false;    /** whether the argument value is a hidden file or directory */    private boolean hidden = false;    /**     * Validate the list of values against the list of permitted values.     * If a value is valid, replace the string in the <code>values</code>     * {@link java.util.List} with the {@link java.io.File} instance.     *     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)     */    public void validate(final List values) throws InvalidArgumentException {        for (final ListIterator i = values.listIterator(); i.hasNext();) {            final String name = (String)i.next();            final File f = new File(name);            if ((existing && !f.exists())                || (file && !f.isFile())                || (directory && !f.isDirectory())                || (hidden && !f.isHidden())                || (readable && !f.canRead())                || (writable && !f.canWrite())) {                throw new InvalidArgumentException(name);            }            i.set(f);        }    }    /**     * Returns whether the argument values must represent directories.     *     * @return whether the argument values must represent directories.     */    public boolean isDirectory() {        return directory;    }    /**     * Specifies whether the argument values must represent directories.     *     * @param directory specifies whether the argument values must     * represent directories.     */    public void setDirectory(boolean directory) {        this.directory = directory;    }    /**     * Returns whether the argument values must represent existing     * files/directories.     *     * @return whether the argument values must represent existing     * files/directories.     */    public boolean isExisting() {        return existing;    }    /**     * Specifies whether the argument values must represent existing     * files/directories.     *     * @param existing specifies whether the argument values must     * represent existing files/directories.     */    public void setExisting(boolean existing) {        this.existing = existing;    }    /**     * Returns whether the argument values must represent directories.     *     * @return whether the argument values must represent directories.     */    public boolean isFile() {        return file;    }    /**     * Specifies whether the argument values must represent files.     *     * @param file specifies whether the argument values must     * represent files.     */    public void setFile(boolean file) {        this.file = file;    }    /**     * Returns whether the argument values must represent hidden     * files/directories.     *     * @return whether the argument values must represent hidden     * files/directories.     */    public boolean isHidden() {        return hidden;    }    /**     * Specifies whether the argument values must represent hidden     * files/directories.     *     * @param hidden specifies whether the argument values must     * represent hidden files/directories.     */    public void setHidden(boolean hidden) {        this.hidden = hidden;    }    /**     * Returns whether the argument values must represent readable     * files/directories.     *     * @return whether the argument values must represent readable     * files/directories.     */    public boolean isReadable() {        return readable;    }    /**     * Specifies whether the argument values must represent readable     * files/directories.     *     * @param readable specifies whether the argument values must     * represent readable files/directories.     */    public void setReadable(boolean readable) {        this.readable = readable;    }    /**     * Returns whether the argument values must represent writable     * files/directories.     *     * @return whether the argument values must represent writable     * files/directories.     */    public boolean isWritable() {        return writable;    }    /**     * Specifies whether the argument values must represent writable     * files/directories.     *     * @param writable specifies whether the argument values must     * represent writable files/directories.     */    public void setWritable(boolean writable) {        this.writable = writable;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * The <code>FileValidator</code> validates the string argument\n+ * values are files.  If the value is a file, the string value in\n+ * the {@link java.util.List} of values is replaced with the\n+ * {@link java.io.File} instance.\n+ *\n+ * The following attributes can also be specified using the \n+ * appropriate settors:\n+ * <ul>\n+ *  <li>writable</li>\n+ *  <li>readable</li>\n+ *  <li>hidden</li>\n+ *  <li>existing</li>\n+ *  <li>is a file</li>\n+ *  <li>is a directory</li>\n+ * </ul>\n+ *\n+ * The following example shows how to limit the valid values\n+ * for the config attribute to files that are readable, writeable,\n+ * and that already existing.\n+ *\n+ * <pre>\n+ * ...\n+ * ArgumentBuilder builder = new ArgumentBuilder();\n+ * FileValidator validator = FileValidator.getExistingFileInstance();\n+ * validator.setReadable(true);\n+ * validator.setWritable(true);\n+ * \n+ * Argument age = \n+ *     builder.withName(\"config\");\n+ *            .withValidator(validator);\n+ * </pre>\n+ * \n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class FileValidator implements Validator {\n+\n+    /**\n+     * Returns a <code>FileValidator</code> for existing files/directories.\n+     *\n+     * @return a <code>FileValidator</code> for existing files/directories.\n+     */\n+    public static FileValidator getExistingInstance() {\n+        final FileValidator validator = new FileValidator();\n+        validator.setExisting(true);\n+        return validator;\n+    }\n+\n+    /**\n+     * Returns a <code>FileValidator</code> for existing files.\n+     *\n+     * @return a <code>FileValidator</code> for existing files.\n+     */\n+    public static FileValidator getExistingFileInstance() {\n+        final FileValidator validator = new FileValidator();\n+        validator.setExisting(true);\n+        validator.setFile(true);\n+        return validator;\n+    }\n+\n+    /**\n+     * Returns a <code>FileValidator</code> for existing directories.\n+     *\n+     * @return a <code>FileValidator</code> for existing directories.\n+     */\n+    public static FileValidator getExistingDirectoryInstance() {\n+        final FileValidator validator = new FileValidator();\n+        validator.setExisting(true);\n+        validator.setDirectory(true);\n+        return validator;\n+    }\n+\n+    /** whether the argument value is readable */\n+    private boolean readable = false;\n+    \n+    /** whether the argument value is writable */\n+    private boolean writable = false;\n+    \n+    /** whether the argument value exists */\n+    private boolean existing = false;\n+    \n+    /** whether the argument value is a directory */\n+    private boolean directory = false;\n+    \n+    /** whether the argument value is a file */\n+    private boolean file = false;\n+\n+    /** whether the argument value is a hidden file or directory */\n+    private boolean hidden = false;\n+\n+    /**\n+     * Validate the list of values against the list of permitted values.\n+     * If a value is valid, replace the string in the <code>values</code>\n+     * {@link java.util.List} with the {@link java.io.File} instance.\n+     * \n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values) throws InvalidArgumentException {\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String name = (String)i.next();\n+            final File f = new File(name);\n+\n+            if ((existing && !f.exists())\n+                || (file && !f.isFile())\n+                || (directory && !f.isDirectory())\n+                || (hidden && !f.isHidden())\n+                || (readable && !f.canRead())\n+                || (writable && !f.canWrite())) {\n+\n+                throw new InvalidArgumentException(name);\n+            }\n+            \n+            i.set(f);\n+        }\n+    }\n+\n+    /**\n+     * Returns whether the argument values must represent directories.\n+     *\n+     * @return whether the argument values must represent directories.\n+     */\n+    public boolean isDirectory() {\n+        return directory;\n+    }\n+\n+    /**\n+     * Specifies whether the argument values must represent directories.\n+     *\n+     * @param directory specifies whether the argument values must \n+     * represent directories.\n+     */\n+    public void setDirectory(boolean directory) {\n+        this.directory = directory;\n+    }\n+\n+    /**\n+     * Returns whether the argument values must represent existing \n+     * files/directories.\n+     *\n+     * @return whether the argument values must represent existing \n+     * files/directories.\n+     */\n+    public boolean isExisting() {\n+        return existing;\n+    }\n+\n+    /**\n+     * Specifies whether the argument values must represent existing \n+     * files/directories.\n+     *\n+     * @param existing specifies whether the argument values must \n+     * represent existing files/directories.\n+     */\n+    public void setExisting(boolean existing) {\n+        this.existing = existing;\n+    }\n+\n+    /**\n+     * Returns whether the argument values must represent directories.\n+     *\n+     * @return whether the argument values must represent directories.\n+     */\n+    public boolean isFile() {\n+        return file;\n+    }\n+\n+    /**\n+     * Specifies whether the argument values must represent files.\n+     *\n+     * @param file specifies whether the argument values must \n+     * represent files.\n+     */\n+    public void setFile(boolean file) {\n+        this.file = file;\n+    }\n+\n+    /**\n+     * Returns whether the argument values must represent hidden \n+     * files/directories.\n+     *\n+     * @return whether the argument values must represent hidden \n+     * files/directories.\n+     */\n+    public boolean isHidden() {\n+        return hidden;\n+    }\n+\n+    /**\n+     * Specifies whether the argument values must represent hidden \n+     * files/directories.\n+     *\n+     * @param hidden specifies whether the argument values must \n+     * represent hidden files/directories.\n+     */\n+    public void setHidden(boolean hidden) {\n+        this.hidden = hidden;\n+    }\n+\n+    /**\n+     * Returns whether the argument values must represent readable \n+     * files/directories.\n+     *\n+     * @return whether the argument values must represent readable \n+     * files/directories.\n+     */\n+    public boolean isReadable() {\n+        return readable;\n+    }\n+\n+    /**\n+     * Specifies whether the argument values must represent readable \n+     * files/directories.\n+     *\n+     * @param readable specifies whether the argument values must \n+     * represent readable files/directories.\n+     */\n+    public void setReadable(boolean readable) {\n+        this.readable = readable;\n+    }\n+\n+    /**\n+     * Returns whether the argument values must represent writable \n+     * files/directories.\n+     *\n+     * @return whether the argument values must represent writable \n+     * files/directories.\n+     */\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    /**\n+     * Specifies whether the argument values must represent writable \n+     * files/directories.\n+     *\n+     * @param writable specifies whether the argument values must \n+     * represent writable files/directories.\n+     */\n+    public void setWritable(boolean writable) {\n+        this.writable = writable;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/InvalidArgumentException.java\n+++ b/src/java/org/apache/commons/cli2/validation/InvalidArgumentException.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;/** * An exception indicating validation failure. * * @author Rob Oxspring * @author John Keyes */public class InvalidArgumentException extends Exception {    /**     * Creates a new exception     * @param message the reason for failure     */    public InvalidArgumentException(final String message) {        super(message);    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+/**\n+ * An exception indicating validation failure.\n+ *\n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class InvalidArgumentException extends Exception {\n+\n+    /**\n+     * Creates a new exception\n+     * @param message the reason for failure\n+     */\n+    public InvalidArgumentException(final String message) {\n+        super(message);\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/NumberValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/NumberValidator.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.text.NumberFormat;import java.text.ParsePosition;import java.util.List;import java.util.ListIterator;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * The <code>NumberValidator</code> validates the string argument * values are numbers.  If the value is a number, the string value in * the {@link java.util.List} of values is replaced with the * {@link java.lang.Number} instance. * * A maximum and minimum value can also be specified using * the {@link #setMaximum setMaximum}, and the * {@link #setMinimum setMinimum} methods. * * The following example shows how to limit the valid values * for the age attribute to integers less than 100. * * <pre> * ... * ArgumentBuilder builder = new ArgumentBuilder(); * NumberValidator validator = NumberValidator.getIntegerInstance(); * validator.setMaximum(new Integer(100)); * * Argument age = *     builder.withName(\"age\"); *            .withValidator(validator); * </pre> * * @author Rob Oxspring * @author John Keyes */public class NumberValidator implements Validator {    /** the <code>NumberFormat</code> being used. */    private NumberFormat format;    /** the lower bound for argument values. */    private Number minimum = null;    /** the upper bound for argument values */    private Number maximum = null;    /**     * Creates a new NumberValidator based on the specified NumberFormat     * @param format the format of numbers to accept     */    public NumberValidator(final NumberFormat format) {        setFormat(format);    }    /**     * Returns a <code>NumberValidator</code> for a currency format     * for the current default locale.     * @return a <code>NumberValidator</code> for a currency format     * for the current default locale.     */    public static NumberValidator getCurrencyInstance() {        return new NumberValidator(NumberFormat.getCurrencyInstance());    }    /**     * Returns a <code>NumberValidator</code> for an integer number format     * for the current default locale.     * @return a <code>NumberValidator</code> for an integer number format     * for the current default locale.     */    public static NumberValidator getIntegerInstance() {        final NumberFormat format = NumberFormat.getNumberInstance();        format.setParseIntegerOnly(true);        return new NumberValidator(format);    }    /**     * Returns a <code>NumberValidator</code> for a percentage format     * for the current default locale.     * @return a <code>NumberValidator</code> for a percentage format     * for the current default locale.     */    public static NumberValidator getPercentInstance() {        return new NumberValidator(NumberFormat.getPercentInstance());    }    /**     * Returns a <code>NumberValidator</code> for a general-purpose     * number format for the current default locale.     * @return a <code>NumberValidator</code> for a general-purpose     * number format for the current default locale.     */    public static NumberValidator getNumberInstance() {        return new NumberValidator(NumberFormat.getNumberInstance());    }    /**     * Validate the list of values against the list of permitted values.     * If a value is valid, replace the string in the <code>values</code>     * {@link java.util.List} with the {@link java.lang.Number} instance.     *     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)     */    public void validate(final List values)        throws InvalidArgumentException {        for (final ListIterator i = values.listIterator(); i.hasNext();) {            final String value = (String) i.next();            final ParsePosition pp = new ParsePosition(0);            final Number number = format.parse(value, pp);            if (pp.getIndex() < value.length()) {                throw new InvalidArgumentException(value);            }            if (((minimum != null) && (number.doubleValue() < minimum.doubleValue())) ||                    ((maximum != null) && (number.doubleValue() > maximum.doubleValue()))) {                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,                                                                                                 new Object[] {                                                                                                     value                                                                                                 }));            }            i.set(number);        }    }    /**     * Return the format being used to validate argument values against.     *     * @return the format being used to validate argument values against.     */    public NumberFormat getFormat() {        return format;    }    /**     * Specify the format being used to validate argument values against.     *     * @param format the format being used to validate argument values against.     */    protected void setFormat(NumberFormat format) {        this.format = format;    }    /**     * Return the maximum value allowed for an argument value.     *     * @return the maximum value allowed for an argument value.     */    public Number getMaximum() {        return maximum;    }    /**     * Specify the maximum value allowed for an argument value.     *     * @param maximum the maximum value allowed for an argument value.     */    public void setMaximum(Number maximum) {        this.maximum = maximum;    }    /**     * Return the minimum value allowed for an argument value.     *     * @return the minimum value allowed for an argument value.     */    public Number getMinimum() {        return minimum;    }    /**     * Specify the minimum value allowed for an argument value.     *     * @param minimum the minimum value allowed for an argument value.     */    public void setMinimum(Number minimum) {        this.minimum = minimum;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * The <code>NumberValidator</code> validates the string argument\n+ * values are numbers.  If the value is a number, the string value in\n+ * the {@link java.util.List} of values is replaced with the\n+ * {@link java.lang.Number} instance.\n+ *\n+ * A maximum and minimum value can also be specified using\n+ * the {@link #setMaximum setMaximum}, and the\n+ * {@link #setMinimum setMinimum} methods.\n+ *\n+ * The following example shows how to limit the valid values\n+ * for the age attribute to integers less than 100.\n+ *\n+ * <pre>\n+ * ...\n+ * ArgumentBuilder builder = new ArgumentBuilder();\n+ * NumberValidator validator = NumberValidator.getIntegerInstance();\n+ * validator.setMaximum(new Integer(100));\n+ *\n+ * Argument age =\n+ *     builder.withName(\"age\");\n+ *            .withValidator(validator);\n+ * </pre>\n+ *\n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class NumberValidator implements Validator {\n+    /** the <code>NumberFormat</code> being used. */\n+    private NumberFormat format;\n+\n+    /** the lower bound for argument values. */\n+    private Number minimum = null;\n+\n+    /** the upper bound for argument values */\n+    private Number maximum = null;\n+\n+    /**\n+     * Creates a new NumberValidator based on the specified NumberFormat\n+     * @param format the format of numbers to accept\n+     */\n+    public NumberValidator(final NumberFormat format) {\n+        setFormat(format);\n+    }\n+\n+    /**\n+     * Returns a <code>NumberValidator</code> for a currency format\n+     * for the current default locale.\n+     * @return a <code>NumberValidator</code> for a currency format\n+     * for the current default locale.\n+     */\n+    public static NumberValidator getCurrencyInstance() {\n+        return new NumberValidator(NumberFormat.getCurrencyInstance());\n+    }\n+\n+    /**\n+     * Returns a <code>NumberValidator</code> for an integer number format\n+     * for the current default locale.\n+     * @return a <code>NumberValidator</code> for an integer number format\n+     * for the current default locale.\n+     */\n+    public static NumberValidator getIntegerInstance() {\n+        final NumberFormat format = NumberFormat.getNumberInstance();\n+        format.setParseIntegerOnly(true);\n+\n+        return new NumberValidator(format);\n+    }\n+\n+    /**\n+     * Returns a <code>NumberValidator</code> for a percentage format\n+     * for the current default locale.\n+     * @return a <code>NumberValidator</code> for a percentage format\n+     * for the current default locale.\n+     */\n+    public static NumberValidator getPercentInstance() {\n+        return new NumberValidator(NumberFormat.getPercentInstance());\n+    }\n+\n+    /**\n+     * Returns a <code>NumberValidator</code> for a general-purpose\n+     * number format for the current default locale.\n+     * @return a <code>NumberValidator</code> for a general-purpose\n+     * number format for the current default locale.\n+     */\n+    public static NumberValidator getNumberInstance() {\n+        return new NumberValidator(NumberFormat.getNumberInstance());\n+    }\n+\n+    /**\n+     * Validate the list of values against the list of permitted values.\n+     * If a value is valid, replace the string in the <code>values</code>\n+     * {@link java.util.List} with the {@link java.lang.Number} instance.\n+     *\n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String value = (String) i.next();\n+\n+            final ParsePosition pp = new ParsePosition(0);\n+            final Number number = format.parse(value, pp);\n+\n+            if (pp.getIndex() < value.length()) {\n+                throw new InvalidArgumentException(value);\n+            }\n+\n+            if (((minimum != null) && (number.doubleValue() < minimum.doubleValue())) ||\n+                    ((maximum != null) && (number.doubleValue() > maximum.doubleValue()))) {\n+                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,\n+                                                                                                 new Object[] {\n+                                                                                                     value\n+                                                                                                 }));\n+            }\n+\n+            i.set(number);\n+        }\n+    }\n+\n+    /**\n+     * Return the format being used to validate argument values against.\n+     *\n+     * @return the format being used to validate argument values against.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Specify the format being used to validate argument values against.\n+     *\n+     * @param format the format being used to validate argument values against.\n+     */\n+    protected void setFormat(NumberFormat format) {\n+        this.format = format;\n+    }\n+\n+    /**\n+     * Return the maximum value allowed for an argument value.\n+     *\n+     * @return the maximum value allowed for an argument value.\n+     */\n+    public Number getMaximum() {\n+        return maximum;\n+    }\n+\n+    /**\n+     * Specify the maximum value allowed for an argument value.\n+     *\n+     * @param maximum the maximum value allowed for an argument value.\n+     */\n+    public void setMaximum(Number maximum) {\n+        this.maximum = maximum;\n+    }\n+\n+    /**\n+     * Return the minimum value allowed for an argument value.\n+     *\n+     * @return the minimum value allowed for an argument value.\n+     */\n+    public Number getMinimum() {\n+        return minimum;\n+    }\n+\n+    /**\n+     * Specify the minimum value allowed for an argument value.\n+     *\n+     * @param minimum the minimum value allowed for an argument value.\n+     */\n+    public void setMinimum(Number minimum) {\n+        this.minimum = minimum;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/UrlValidator.java\n+++ b/src/java/org/apache/commons/cli2/validation/UrlValidator.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.net.MalformedURLException;import java.net.URL;import java.util.List;import java.util.ListIterator;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * The <code>UrlValidator</code> validates the string argument * values are URLs.  If the value is a URL, the string value in * the {@link java.util.List} of values is replaced with the * {@link java.net.URL} instance. * * URLs can also be validated based on their scheme by using * the {@link #setProtocol setProtocol} method, or by using the specified * {@link #UrlValidator(java.lang.String) constructor}. * * The following example shows how to limit the valid values * for the site argument to 'https' URLs. * * <pre> * ... * ArgumentBuilder builder = new ArgumentBuilder(); * Argument site = *     builder.withName(\"site\"); *            .withValidator(new URLValidator(\"https\")); * </pre> * * @author Rob Oxspring * @author John Keyes */public class UrlValidator implements Validator {    /** allowed protocol */    private String protocol = null;    /**     * Creates a UrlValidator.     */    public UrlValidator() {    }    /**     * Creates a UrlValidator for the specified protocol.     */    public UrlValidator(final String protocol) {        setProtocol(protocol);    }    /**     * Validate the list of values against the list of permitted values.     * If a value is valid, replace the string in the <code>values</code>     * {@link java.util.List} with the { java.net.URL} instance.     *     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)     */    public void validate(final List values)        throws InvalidArgumentException {        for (final ListIterator i = values.listIterator(); i.hasNext();) {            final String name = (String) i.next();            try {                final URL url = new URL(name);                if ((protocol != null) && !protocol.equals(url.getProtocol())) {                    throw new InvalidArgumentException(name);                }                i.set(url);            } catch (final MalformedURLException mue) {                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.URLVALIDATOR_MALFORMED_URL,                                                                                                 new Object[] {                                                                                                     name                                                                                                 }));            }        }    }    /**     * Returns the protocol that must be used by a valid URL.     *     * @return the protocol that must be used by a valid URL.     */    public String getProtocol() {        return protocol;    }    /**     * Specifies the protocol that a URL must have to be valid.     *     * @param protocol the protocol that a URL must have to be valid.     */    public void setProtocol(String protocol) {        this.protocol = protocol;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * The <code>UrlValidator</code> validates the string argument\n+ * values are URLs.  If the value is a URL, the string value in\n+ * the {@link java.util.List} of values is replaced with the\n+ * {@link java.net.URL} instance.\n+ *\n+ * URLs can also be validated based on their scheme by using\n+ * the {@link #setProtocol setProtocol} method, or by using the specified\n+ * {@link #UrlValidator(java.lang.String) constructor}.\n+ *\n+ * The following example shows how to limit the valid values\n+ * for the site argument to 'https' URLs.\n+ *\n+ * <pre>\n+ * ...\n+ * ArgumentBuilder builder = new ArgumentBuilder();\n+ * Argument site =\n+ *     builder.withName(\"site\");\n+ *            .withValidator(new URLValidator(\"https\"));\n+ * </pre>\n+ *\n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class UrlValidator implements Validator {\n+    /** allowed protocol */\n+    private String protocol = null;\n+\n+    /**\n+     * Creates a UrlValidator.\n+     */\n+    public UrlValidator() {\n+    }\n+\n+    /**\n+     * Creates a UrlValidator for the specified protocol.\n+     */\n+    public UrlValidator(final String protocol) {\n+        setProtocol(protocol);\n+    }\n+\n+    /**\n+     * Validate the list of values against the list of permitted values.\n+     * If a value is valid, replace the string in the <code>values</code>\n+     * {@link java.util.List} with the { java.net.URL} instance.\n+     *\n+     * @see org.apache.commons.cli2.validation.Validator#validate(java.util.List)\n+     */\n+    public void validate(final List values)\n+        throws InvalidArgumentException {\n+        for (final ListIterator i = values.listIterator(); i.hasNext();) {\n+            final String name = (String) i.next();\n+\n+            try {\n+                final URL url = new URL(name);\n+\n+                if ((protocol != null) && !protocol.equals(url.getProtocol())) {\n+                    throw new InvalidArgumentException(name);\n+                }\n+\n+                i.set(url);\n+            } catch (final MalformedURLException mue) {\n+                throw new InvalidArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.URLVALIDATOR_MALFORMED_URL,\n+                                                                                                 new Object[] {\n+                                                                                                     name\n+                                                                                                 }));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the protocol that must be used by a valid URL.\n+     *\n+     * @return the protocol that must be used by a valid URL.\n+     */\n+    public String getProtocol() {\n+        return protocol;\n+    }\n+\n+    /**\n+     * Specifies the protocol that a URL must have to be valid.\n+     *\n+     * @param protocol the protocol that a URL must have to be valid.\n+     */\n+    public void setProtocol(String protocol) {\n+        this.protocol = protocol;\n+    }\n+}\n--- a/src/java/org/apache/commons/cli2/validation/Validator.java\n+++ b/src/java/org/apache/commons/cli2/validation/Validator.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.util.List;/** * The validation interface for validating argument values(s). * * A validator can replace the argument string value with a * specific class instance e.g. the {@link UrlValidator} replaces * the string value with a {@link java.net.URL} instance. * * @author Rob Oxspring * @author John Keyes */public interface Validator {    /**     * Validate the specified values (List of Strings).     *     * @param values The values to validate.     *     * @throws InvalidArgumentException If any of the     * specified values are not valid.     */    void validate(final List values) throws InvalidArgumentException;}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.List;\n+\n+/**\n+ * The validation interface for validating argument values(s).\n+ *\n+ * A validator can replace the argument string value with a\n+ * specific class instance e.g. the {@link UrlValidator} replaces\n+ * the string value with a {@link java.net.URL} instance.\n+ *\n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public interface Validator {\n+\n+    /**\n+     * Validate the specified values (List of Strings).\n+     * \n+     * @param values The values to validate.\n+     * \n+     * @throws InvalidArgumentException If any of the \n+     * specified values are not valid.\n+     */\n+    void validate(final List values) throws InvalidArgumentException;\n+\n+}\n--- a/src/test/org/apache/commons/cli2/CLITestCase.java\n+++ b/src/test/org/apache/commons/cli2/CLITestCase.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import junit.framework.TestCase;public abstract class CLITestCase extends TestCase {\tpublic static List list() {\t    return Collections.EMPTY_LIST;\t}\tpublic static List list(final Object args[]) {\t    return new LinkedList(Arrays.asList(args));\t}\tpublic static List list(final Object arg0) {\t    return list(new Object[] { arg0 });\t}\tpublic static List list(final Object arg0, final Object arg1) {\t    return list(new Object[] { arg0, arg1 });\t}\tpublic static List list(final Object arg0, final Object arg1, final Object arg2) {\t    return list(new Object[] { arg0, arg1, arg2 });\t}\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3) {\t    return list(new Object[] { arg0, arg1, arg2, arg3 });\t}\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3, final Object arg4) {\t    return list(new Object[] { arg0, arg1, arg2, arg3, arg4 });\t}\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3, final Object arg4, final Object arg5) {\t    return list(new Object[] { arg0, arg1, arg2, arg3, arg4, arg5 });\t}\tpublic static void assertListContentsEqual(final List expected, final List found) {\t    final Iterator e = expected.iterator();\t    final Iterator f = found.iterator();\t    while (e.hasNext() && f.hasNext()) {\t        assertEquals(e.next(), f.next());\t    }\t    if (e.hasNext()) {\t        fail(\"Expected more elements\");\t    }\t    if (f.hasNext()) {\t        fail(\"Found more elements\");\t    }\t}\tpublic static void assertContentsEqual(final Collection expected, final Collection found) {\t    assertTrue(expected.containsAll(found));\t    assertTrue(found.containsAll(expected));\t    assertEquals(expected.size(), found.size());\t}}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+public abstract class CLITestCase extends TestCase {\n+\n+\tpublic static List list() {\n+\t    return Collections.EMPTY_LIST;\n+\t}\n+\n+\tpublic static List list(final Object args[]) {\n+\t    return new LinkedList(Arrays.asList(args));\n+\t}\n+\n+\tpublic static List list(final Object arg0) {\n+\t    return list(new Object[] { arg0 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1) {\n+\t    return list(new Object[] { arg0, arg1 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2) {\n+\t    return list(new Object[] { arg0, arg1, arg2 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3) {\n+\t    return list(new Object[] { arg0, arg1, arg2, arg3 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3, final Object arg4) {\n+\t    return list(new Object[] { arg0, arg1, arg2, arg3, arg4 });\n+\t}\n+\n+\tpublic static List list(final Object arg0, final Object arg1, final Object arg2, final Object arg3, final Object arg4, final Object arg5) {\n+\t    return list(new Object[] { arg0, arg1, arg2, arg3, arg4, arg5 });\n+\t}\n+\n+\tpublic static void assertListContentsEqual(final List expected, final List found) {\n+\t\n+\t    final Iterator e = expected.iterator();\n+\t    final Iterator f = found.iterator();\n+\t\n+\t    while (e.hasNext() && f.hasNext()) {\n+\t        assertEquals(e.next(), f.next());\n+\t    }\n+\t\n+\t    if (e.hasNext()) {\n+\t        fail(\"Expected more elements\");\n+\t    }\n+\t\n+\t    if (f.hasNext()) {\n+\t        fail(\"Found more elements\");\n+\t    }\n+\t}\n+\n+\tpublic static void assertContentsEqual(final Collection expected, final Collection found) {\n+\t    assertTrue(expected.containsAll(found));\n+\t    assertTrue(found.containsAll(expected));\n+\t    assertEquals(expected.size(), found.size());\n+\t}\n+}\n--- a/src/test/org/apache/commons/cli2/CommandLineDefaultsTest.java\n+++ b/src/test/org/apache/commons/cli2/CommandLineDefaultsTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Arrays;import java.util.Collections;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.SwitchBuilder;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;/** * Tests the interaction of command line values and defaults supplied in different ways. * * Tests marked _Parsed involve values parsed from a command line. * * Tests marked _Method involve defaults supplied in the query method. * * Tests marked _Option involce defaults specified in the model. * * @author Rob Oxspring */public class CommandLineDefaultsTest extends TestCase {    /*     * utils to grab the default from the method     */    private Object methodSwitch(WriteableCommandLine cl, Option o, Boolean bool) {        return cl.getSwitch(o, bool);    }    private Object methodSwitchNull(WriteableCommandLine cl, Option o) {        return methodSwitch(cl, o, null);    }    private Object methodSwitchOff(WriteableCommandLine cl, Option o) {        return methodSwitch(cl, o, Boolean.FALSE);    }    private Object methodSwitchOn(WriteableCommandLine cl, Option o) {        return methodSwitch(cl, o, Boolean.TRUE);    }    private Object methodValueMissing(WriteableCommandLine cl, Option o) {        return cl.getValue(o);    }    private Object methodValuePresent(WriteableCommandLine cl, Option o) {        return cl.getValue(o, \"method\");    }    /*     * utils to grab the default from the option model     */    private Option optionSwitch(Boolean bool) {        return new SwitchBuilder().withName(\"switch\").withSwitchDefault(bool)                .create();    }    private Option optionSwitchNull() {        return optionSwitch(null);    }    private Option optionSwitchOff() {        return optionSwitch(Boolean.FALSE);    }    private Option optionSwitchOn() {        return optionSwitch(Boolean.TRUE);    }    private Option optionValueMissing() {        return new ArgumentBuilder().create();    }    private Option optionValuePresent() {        return new ArgumentBuilder().withDefaults(                Arrays.asList(new String[] { \"option\" })).create();    }    /*     * utils to grab the input from the command line     */    private WriteableCommandLine parsedSwitch(Option o, Boolean bool) {        final List args;        if (bool == null) {            args = Collections.EMPTY_LIST;        } else {            args = Collections                    .singletonList(String.valueOf(bool).toLowerCase());        }        WriteableCommandLine cl = new WriteableCommandLineImpl(o, args);        o.defaults(cl);        if (bool != null) {            cl.addSwitch(o, bool.booleanValue());        }        return cl;    }    private WriteableCommandLine parsedSwitchNull(Option o) {        return parsedSwitch(o, null);    }    private WriteableCommandLine parsedSwitchOn(Option o) {        return parsedSwitch(o, Boolean.TRUE);    }    private WriteableCommandLine parsedValueMissing(Option o) {        WriteableCommandLine cl = new WriteableCommandLineImpl(o,                Collections.EMPTY_LIST);        o.defaults(cl);        return cl;    }    private WriteableCommandLine parsedValuePresent(Option o) {        WriteableCommandLine cl = new WriteableCommandLineImpl(o, Arrays                .asList(new String[] { \"parsed\" }));        o.defaults(cl);        cl.addValue(o, \"parsed\");        return cl;    }    /*     * tests     */    public void testSwitch_Method() {        final Option o = optionSwitchNull();        final WriteableCommandLine cl = parsedSwitchNull(o);        final Object v = methodSwitchOn(cl, o);        assertEquals(Boolean.TRUE, v);    }    public void testSwitch_Method_Option() {        final Option o = optionSwitchOff();        final WriteableCommandLine cl = parsedSwitchNull(o);        final Object v = methodSwitchOn(cl, o);        assertEquals(Boolean.TRUE, v);    }    public void testSwitch_Option() {        final Option o = optionSwitchOn();        final WriteableCommandLine cl = parsedSwitchNull(o);        final Object v = methodSwitchNull(cl, o);        assertEquals(Boolean.TRUE, v);    }    public void testSwitch_Parsed() {        final Option o = optionSwitchNull();        final WriteableCommandLine cl = parsedSwitchOn(o);        final Object v = methodSwitchNull(cl, o);        assertEquals(Boolean.TRUE, v);    }    public void testSwitch_Parsed_Method() {        final Option o = optionSwitchOff();        final WriteableCommandLine cl = parsedSwitchOn(o);        final Object v = methodSwitchNull(cl, o);        assertEquals(Boolean.TRUE, v);    }    public void testSwitch_Parsed_Method_Option() {        final Option o = optionSwitchOff();        final WriteableCommandLine cl = parsedSwitchOn(o);        final Object v = methodSwitchOff(cl, o);        assertEquals(Boolean.TRUE, v);    }    public void testSwitch_Parsed_Option() {        final Option o = optionSwitchOff();        final WriteableCommandLine cl = parsedSwitchOn(o);        final Object v = methodSwitchNull(cl, o);        assertEquals(Boolean.TRUE, v);    }    public void testValues() {        final Option o = optionValueMissing();        final WriteableCommandLine cl = parsedValueMissing(o);        final Object v = methodValueMissing(cl, o);        assertNull(v);    }    public void testValues_Method() {        final Option o = optionValueMissing();        final WriteableCommandLine cl = parsedValueMissing(o);        final Object v = methodValuePresent(cl, o);        assertEquals(\"method\", v);    }    public void testValues_Method_Option() {        final Option o = optionValuePresent();        final WriteableCommandLine cl = parsedValueMissing(o);        final Object v = methodValuePresent(cl, o);        assertEquals(\"method\", v);    }    public void testValues_Option() {        final Option o = optionValuePresent();        final WriteableCommandLine cl = parsedValueMissing(o);        final Object v = methodValueMissing(cl, o);        assertEquals(\"option\", v);    }    public void testValues_Parsed() {        final Option o = optionValueMissing();        final WriteableCommandLine cl = parsedValuePresent(o);        final Object v = methodValueMissing(cl, o);        assertEquals(\"parsed\", v);    }    public void testValues_Parsed_Method() {        final Option o = optionValueMissing();        final WriteableCommandLine cl = parsedValuePresent(o);        final Object v = methodValuePresent(cl, o);        assertEquals(\"parsed\", v);    }    public void testValues_Parsed_Method_Option() {        final Option o = optionValuePresent();        final WriteableCommandLine cl = parsedValuePresent(o);        final Object v = methodValuePresent(cl, o);        assertEquals(\"parsed\", v);    }    public void testValues_Parsed_Option() {        final Option o = optionValuePresent();        final WriteableCommandLine cl = parsedValuePresent(o);        final Object v = methodValueMissing(cl, o);        assertEquals(\"parsed\", v);    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.SwitchBuilder;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+\n+/**\n+ * Tests the interaction of command line values and defaults supplied in different ways.\n+ * \n+ * Tests marked _Parsed involve values parsed from a command line.\n+ * \n+ * Tests marked _Method involve defaults supplied in the query method.\n+ * \n+ * Tests marked _Option involce defaults specified in the model.\n+ * \n+ * @author Rob Oxspring\n+ */\n+public class CommandLineDefaultsTest extends TestCase {\n+    \n+    /*\n+     * utils to grab the default from the method \n+     */\n+    \n+    private Object methodSwitch(WriteableCommandLine cl, Option o, Boolean bool) {\n+        return cl.getSwitch(o, bool);\n+    }\n+\n+    private Object methodSwitchNull(WriteableCommandLine cl, Option o) {\n+        return methodSwitch(cl, o, null);\n+    }\n+\n+    private Object methodSwitchOff(WriteableCommandLine cl, Option o) {\n+        return methodSwitch(cl, o, Boolean.FALSE);\n+    }\n+\n+    private Object methodSwitchOn(WriteableCommandLine cl, Option o) {\n+        return methodSwitch(cl, o, Boolean.TRUE);\n+    }\n+\n+    private Object methodValueMissing(WriteableCommandLine cl, Option o) {\n+        return cl.getValue(o);\n+    }\n+\n+    private Object methodValuePresent(WriteableCommandLine cl, Option o) {\n+        return cl.getValue(o, \"method\");\n+    }\n+\n+    /*\n+     * utils to grab the default from the option model \n+     */\n+    \n+    private Option optionSwitch(Boolean bool) {\n+        return new SwitchBuilder().withName(\"switch\").withSwitchDefault(bool)\n+                .create();\n+    }\n+\n+    private Option optionSwitchNull() {\n+        return optionSwitch(null);\n+    }\n+\n+    private Option optionSwitchOff() {\n+        return optionSwitch(Boolean.FALSE);\n+    }\n+\n+    private Option optionSwitchOn() {\n+        return optionSwitch(Boolean.TRUE);\n+    }\n+\n+    private Option optionValueMissing() {\n+        return new ArgumentBuilder().create();\n+    }\n+\n+    private Option optionValuePresent() {\n+        return new ArgumentBuilder().withDefaults(\n+                Arrays.asList(new String[] { \"option\" })).create();\n+    }\n+\n+    /*\n+     * utils to grab the input from the command line \n+     */\n+    \n+    private WriteableCommandLine parsedSwitch(Option o, Boolean bool) {\n+        final List args;\n+        if (bool == null) {\n+            args = Collections.EMPTY_LIST;\n+        } else {\n+            args = Collections\n+                    .singletonList(String.valueOf(bool).toLowerCase());\n+        }\n+        WriteableCommandLine cl = new WriteableCommandLineImpl(o, args);\n+        o.defaults(cl);\n+        if (bool != null) {\n+            cl.addSwitch(o, bool.booleanValue());\n+        }\n+        return cl;\n+    }\n+\n+    private WriteableCommandLine parsedSwitchNull(Option o) {\n+        return parsedSwitch(o, null);\n+    }\n+\n+    private WriteableCommandLine parsedSwitchOn(Option o) {\n+        return parsedSwitch(o, Boolean.TRUE);\n+    }\n+\n+    private WriteableCommandLine parsedValueMissing(Option o) {\n+        WriteableCommandLine cl = new WriteableCommandLineImpl(o,\n+                Collections.EMPTY_LIST);\n+        o.defaults(cl);\n+        return cl;\n+    }\n+\n+    private WriteableCommandLine parsedValuePresent(Option o) {\n+        WriteableCommandLine cl = new WriteableCommandLineImpl(o, Arrays\n+                .asList(new String[] { \"parsed\" }));\n+        o.defaults(cl);\n+        cl.addValue(o, \"parsed\");\n+        return cl;\n+    }\n+    \n+    /*\n+     * tests\n+     */\n+\n+    public void testSwitch_Method() {\n+        final Option o = optionSwitchNull();\n+        final WriteableCommandLine cl = parsedSwitchNull(o);\n+        final Object v = methodSwitchOn(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Method_Option() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchNull(o);\n+        final Object v = methodSwitchOn(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Option() {\n+        final Option o = optionSwitchOn();\n+        final WriteableCommandLine cl = parsedSwitchNull(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed() {\n+        final Option o = optionSwitchNull();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed_Method() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed_Method_Option() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchOff(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testSwitch_Parsed_Option() {\n+        final Option o = optionSwitchOff();\n+        final WriteableCommandLine cl = parsedSwitchOn(o);\n+        final Object v = methodSwitchNull(cl, o);\n+        assertEquals(Boolean.TRUE, v);\n+    }\n+\n+    public void testValues() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertNull(v);\n+    }\n+\n+    public void testValues_Method() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"method\", v);\n+    }\n+\n+    public void testValues_Method_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"method\", v);\n+    }\n+\n+    public void testValues_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValueMissing(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertEquals(\"option\", v);\n+    }\n+\n+    public void testValues_Parsed() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+\n+    public void testValues_Parsed_Method() {\n+        final Option o = optionValueMissing();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+\n+    public void testValues_Parsed_Method_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValuePresent(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+\n+    public void testValues_Parsed_Option() {\n+        final Option o = optionValuePresent();\n+        final WriteableCommandLine cl = parsedValuePresent(o);\n+        final Object v = methodValueMissing(cl, o);\n+        assertEquals(\"parsed\", v);\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/CommandLineTestCase.java\n+++ b/src/test/org/apache/commons/cli2/CommandLineTestCase.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Collections;import java.util.Iterator;import java.util.List;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.option.ArgumentTest;import org.apache.commons.cli2.option.CommandTest;import org.apache.commons.cli2.option.DefaultOptionTest;import org.apache.commons.cli2.option.OptionTestCase;import org.apache.commons.cli2.option.PropertyOption;import org.apache.commons.cli2.option.SwitchTest;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;public abstract class CommandLineTestCase    extends CLITestCase {    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    public final Option present =        new DefaultOptionBuilder().withLongName(\"present\").withLongName(\"alsopresent\").create();    public final Option missing = new DefaultOptionBuilder().withLongName(\"missing\").create();    public final Option multiple = new DefaultOptionBuilder().withLongName(\"multiple\").create();    public final Option bool = new DefaultOptionBuilder().withLongName(\"bool\").create();    public final Option root =        new GroupBuilder().withOption(present).withOption(missing).withOption(multiple)                          .withOption(bool).create();    private CommandLine commandLine;    protected abstract CommandLine createCommandLine();    /*     * @see TestCase#setUp()     */    public void setUp()        throws Exception {        super.setUp();        commandLine = createCommandLine();    }    /*     * Class to test for boolean hasOption(String)     */    public final void testHasOptionString() {        assertTrue(commandLine.hasOption(\"--present\"));        assertTrue(commandLine.hasOption(\"--alsopresent\"));        assertFalse(commandLine.hasOption(\"--missing\"));    }    /*     * Class to test for boolean hasOption(Option)     */    public final void testHasOptionOption() {        assertTrue(commandLine.hasOption(present));        assertFalse(commandLine.hasOption(missing));    }    public final void testGetOption() {        assertSame(present, commandLine.getOption(\"--present\"));        assertSame(present, commandLine.getOption(\"--alsopresent\"));        //TODO decide whether the following assertion is valid        //assertSame(missing,commandLine.getOption(\"--missing\"));    }    /*     * Class to test for List getValues(String)     */    public final void testGetValuesString() {        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--present\"));        assertListContentsEqual(list(\"value 1\", \"value 2\", \"value 3\"),                                commandLine.getValues(\"--multiple\"));        assertTrue(commandLine.getValues(\"--missing\").isEmpty());    }    /*     * Class to test for List getValues(String, List)     */    public final void testGetValuesStringList() {        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--present\", null));        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--alsopresent\", null));        assertSame(commandLine.getValues(\"--missing\", Collections.EMPTY_LIST),                   Collections.EMPTY_LIST);        final List def = Collections.singletonList(\"default value\");        assertSame(def, commandLine.getValues(\"--missing\", def));    }    /*     * Class to test for List getValues(Option)     */    public final void testGetValuesOption() {        assertListContentsEqual(list(\"present value\"), commandLine.getValues(present));        assertTrue(commandLine.getValues(missing).isEmpty());    }    /*     * Class to test for List getValues(Option, List)     */    public final void testGetValuesOptionList() {        assertListContentsEqual(list(\"present value\"), commandLine.getValues(present));        assertSame(commandLine.getValues(missing, Collections.EMPTY_LIST), Collections.EMPTY_LIST);        final List defs = Collections.singletonList(\"custom default\");        assertSame(defs, commandLine.getValues(missing, defs));    }    /*     * Class to test for Object getValue(String)     */    public final void testGetValueString() {        assertEquals(\"present value\", commandLine.getValue(\"--present\"));        assertEquals(\"present value\", commandLine.getValue(\"--alsopresent\"));        assertNull(commandLine.getValue(\"--missing\"));        try {            commandLine.getValue(\"--multiple\");            fail(\"expected IllegalStateException\");        } catch (IllegalStateException e) {            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),                         e.getMessage());        }    }    /*     * Class to test for Object getValue(String, Object)     */    public final void testGetValueStringObject() {        assertEquals(\"present value\", commandLine.getValue(\"--present\", \"default value\"));        assertEquals(\"present value\", commandLine.getValue(\"--alsopresent\", \"default value\"));        assertEquals(\"default value\", commandLine.getValue(\"--missing\", \"default value\"));        try {            commandLine.getValue(\"--multiple\");            fail(\"expected IllegalStateException\");        } catch (IllegalStateException e) {            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),                         e.getMessage());        }    }    /*     * Class to test for Object getValue(Option)     */    public final void testGetValueOption() {        assertEquals(\"present value\", commandLine.getValue(present));        assertNull(commandLine.getValue(missing));        try {            commandLine.getValue(multiple);            fail(\"expected IllegalStateException\");        } catch (IllegalStateException e) {            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),                         e.getMessage());        }    }    /*     * Class to test for Object getValue(Option, Object)     */    public final void testGetValueOptionObject() {        assertEquals(\"present value\", commandLine.getValue(present, \"default value\"));        assertEquals(\"default value\", commandLine.getValue(missing, \"default value\"));        try {            commandLine.getValue(multiple);            fail(\"expected IllegalStateException\");        } catch (IllegalStateException e) {            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),                         e.getMessage());        }    }    /*     * Class to test for Boolean getSwitch(String)     */    public final void testGetSwitchString() {        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"--bool\"));        assertNull(commandLine.getSwitch(\"--missing\"));    }    /*     * Class to test for Boolean getSwitch(String, Boolean)     */    public final void testGetSwitchStringBoolean() {        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"--bool\", Boolean.FALSE));        assertEquals(Boolean.FALSE, commandLine.getSwitch(\"--missing\", Boolean.FALSE));    }    /*     * Class to test for Boolean getSwitch(Option)     */    public final void testGetSwitchOption() {        assertEquals(Boolean.TRUE, commandLine.getSwitch(bool));        assertNull(commandLine.getSwitch(missing));    }    /*     * Class to test for Boolean getSwitch(Option, Boolean)     */    public final void testGetSwitchOptionBoolean() {        assertEquals(Boolean.TRUE, commandLine.getSwitch(bool, Boolean.FALSE));        assertEquals(Boolean.FALSE, commandLine.getSwitch(missing, Boolean.FALSE));    }    /*     * Class to test for String getProperty(String)     */    public final void testGetPropertyString() {        assertEquals(\"present property\", commandLine.getProperty(\"present\"));        assertNull(commandLine.getProperty(\"missing\"));    }    /*     * Class to test for String getProperty(String, String)     */    public final void testGetPropertyStringString() {        assertEquals(\"present property\", commandLine.getProperty(\"present\", \"default property\"));        assertEquals(\"default property\", commandLine.getProperty(\"missing\", \"default property\"));    }    public final void testGetProperties() {        assertTrue(commandLine.getProperties().containsAll(list(\"present\")));    }    /*     * Class to test for int getOptionCount(String)     */    public final void testGetOptionCountString() {        // one option, one switch        assertTrue(1 <= commandLine.getOptionCount(\"--present\"));        assertTrue(1 <= commandLine.getOptionCount(\"--bool\"));        assertEquals(0, commandLine.getOptionCount(\"--missing\"));    }    /*     * Class to test for int getOptionCount(Option)     */    public final void testGetOptionCountOption() {        // one option, one switch        assertTrue(1 <= commandLine.getOptionCount(present));        assertTrue(1 <= commandLine.getOptionCount(bool));        assertEquals(0, commandLine.getOptionCount(missing));    }    public final void testGetOptions() {        //TODO Implement getOptions().    }    public final void testGetOptionTriggers() {        //TODO Implement getOptionTriggers().    }    // OLD TESTS FOLLOW    public final void testProperties() {        final Option option = new PropertyOption();        final List args = CLITestCase.list();        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);        assertTrue(writeable.getProperties().isEmpty());        writeable.addProperty(\"myprop\", \"myval\");        assertEquals(1, writeable.getProperties().size());        assertEquals(\"myval\", writeable.getProperty(\"myprop\"));        writeable.addProperty(\"myprop\", \"myval2\");        assertEquals(1, writeable.getProperties().size());        assertEquals(\"myval2\", writeable.getProperty(\"myprop\"));        writeable.addProperty(\"myprop2\", \"myval3\");        assertEquals(2, writeable.getProperties().size());        assertEquals(\"myval3\", writeable.getProperty(\"myprop2\"));    }    public final void testOptions() {        final Option option = new PropertyOption();        final List args = CLITestCase.list();        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);        final Option start = CommandTest.buildStartCommand();        assertFalse(writeable.hasOption(start));        assertFalse(writeable.hasOption(\"start\"));        assertFalse(writeable.hasOption(\"go\"));        writeable.addOption(start);        assertTrue(writeable.hasOption(start));        assertTrue(writeable.hasOption(\"start\"));        assertTrue(writeable.hasOption(\"go\"));    }    public final void testValues() {        final Option option = new PropertyOption();        final List args = CLITestCase.list();        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);        final Option start = CommandTest.buildStartCommand();        assertNull(writeable.getValue(start));        assertTrue(writeable.getValues(start).isEmpty());        writeable.addOption(start);        assertTrue(writeable.getValues(start).isEmpty());        writeable.addValue(start, \"file1\");        assertEquals(\"file1\", writeable.getValue(start));        assertEquals(\"file1\", writeable.getValue(\"start\"));        assertEquals(\"file1\", writeable.getValue(\"go\"));        assertEquals(1, writeable.getValues(start).size());        assertEquals(1, writeable.getValues(\"start\").size());        assertEquals(1, writeable.getValues(\"go\").size());        assertTrue(writeable.getValues(start).contains(\"file1\"));        assertTrue(writeable.getValues(\"start\").contains(\"file1\"));        assertTrue(writeable.getValues(\"go\").contains(\"file1\"));        writeable.addValue(start, \"file2\");        try {            writeable.getValue(start);            fail(\"Cannot get single value if multiple are present\");        } catch (IllegalStateException ise) {            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),                         ise.getMessage());        }        try {            writeable.getValue(\"start\");            fail(\"Cannot get single value if multiple are present\");        } catch (IllegalStateException ise) {            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),                         ise.getMessage());        }        writeable.getValues(start).add(\"file3\");    }    public final void testSwitches() {        final Option option = new PropertyOption();        final List args = CLITestCase.list();        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);        final Option start = CommandTest.buildStartCommand();        assertNull(writeable.getSwitch(start));        assertNull(writeable.getSwitch(\"start\"));        assertNull(writeable.getSwitch(\"go\"));        writeable.addSwitch(start, true);        try {            writeable.addSwitch(start, false);            fail(\"Switch cannot be changed\");        } catch (IllegalStateException ise) {            assertEquals(resources.getMessage(ResourceConstants.SWITCH_ALREADY_SET),                         ise.getMessage());        }    }    public final void testSwitches_True() {        final Option option = new PropertyOption();        final List args = CLITestCase.list();        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);        final Option start = CommandTest.buildStartCommand();        writeable.addSwitch(start, true);        assertSame(Boolean.TRUE, writeable.getSwitch(start));    }    public final void testSwitches_False() {        final Option option = new PropertyOption();        final List args = CLITestCase.list();        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);        final Option start = CommandTest.buildStartCommand();        writeable.addSwitch(start, false);        assertSame(Boolean.FALSE, writeable.getSwitch(start));    }    //    public final void testLooksLikeOption() {    //        final Option option = new PropertyOption();    //        final List args = OptionTestCase.list();    //        final WriteableCommandLine commandLine =    //            OptionTestCase.commandLine(option, args);    //    //        assertTrue(commandLine.looksLikeOption(\"-D\"));    //        assertFalse(commandLine.looksLikeOption(\"--help\"));    //        assertFalse(commandLine.looksLikeOption(\"+display\"));    //        assertFalse(commandLine.looksLikeOption(\"myprefix\"));    //        assertFalse(commandLine.looksLikeOption(\"myprefix2\"));    //        assertFalse(commandLine.looksLikeOption(\"myprefference\"));    //        assertFalse(commandLine.looksLikeOption(\"/SCANDISK\"));    //        assertFalse(commandLine.looksLikeOption(\"update\"));    //    }    public final void testGetOptions_Order()        throws OptionException {        final Option help = DefaultOptionTest.buildHelpOption();        final Option login = CommandTest.buildLoginCommand();        final Option targets = ArgumentTest.buildTargetsArgument();        final Group group =            new GroupBuilder().withOption(help).withOption(login).withOption(targets).create();        final Parser parser = new Parser();        parser.setGroup(group);        final CommandLine cl =            parser.parse(new String[] { \"login\", \"rob\", \"--help\", \"target1\", \"target2\" });        final Iterator i = cl.getOptions().iterator();        assertSame(login, i.next());        assertSame(help, i.next());        assertSame(targets, i.next());        assertSame(targets, i.next());        assertFalse(i.hasNext());    }    public final void testGetOptionCount()        throws OptionException {        final Option help = DefaultOptionTest.buildHelpOption();        final Option login = CommandTest.buildLoginCommand();        final Option targets = ArgumentTest.buildTargetsArgument();        final Option display = SwitchTest.buildDisplaySwitch();        final Group group =            new GroupBuilder().withOption(help).withOption(login).withOption(targets)                              .withOption(display).create();        final Parser parser = new Parser();        parser.setGroup(group);        final CommandLine cl =            parser.parse(new String[] {                             \"--help\", \"login\", \"rob\", \"+display\", \"--help\", \"--help\", \"target1\",                             \"target2\"                         });        assertEquals(1, cl.getOptionCount(login));        assertEquals(3, cl.getOptionCount(help));        assertEquals(2, cl.getOptionCount(targets));        assertEquals(1, cl.getOptionCount(display));    }    public final void testGetOptionCount_Strings()        throws OptionException {        final Option help = DefaultOptionTest.buildHelpOption();        final Option login = CommandTest.buildLoginCommand();        final Option targets = ArgumentTest.buildTargetsArgument();        final Option display = SwitchTest.buildDisplaySwitch();        final Group group =            new GroupBuilder().withOption(help).withOption(login).withOption(targets)                              .withOption(display).create();        final Parser parser = new Parser();        parser.setGroup(group);        final CommandLine cl =            parser.parse(new String[] {                             \"--help\", \"login\", \"rob\", \"+display\", \"--help\", \"--help\", \"target1\",                             \"target2\"                         });        assertEquals(1, cl.getOptionCount(\"login\"));        assertEquals(3, cl.getOptionCount(\"-?\"));        assertEquals(1, cl.getOptionCount(\"+display\"));    }    public final void testOptionAsArgument()        throws OptionException {        final Option p = new DefaultOptionBuilder().withShortName(\"p\").create();        final Argument argument = new ArgumentBuilder().create();        final Option withArgument =            new DefaultOptionBuilder().withShortName(\"attr\").withArgument(argument).create();        final Group group = new GroupBuilder().withOption(p).withOption(withArgument).create();        final Parser parser = new Parser();        parser.setGroup(group);        final CommandLine cl = parser.parse(new String[] { \"-p\", \"-attr\", \"p\" });        assertEquals(1, cl.getOptionCount(\"-p\"));        assertTrue(cl.hasOption(\"-p\"));        assertTrue(cl.hasOption(\"-attr\"));        assertTrue(cl.getValue(\"-attr\").equals(\"p\"));    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.ArgumentTest;\n+import org.apache.commons.cli2.option.CommandTest;\n+import org.apache.commons.cli2.option.DefaultOptionTest;\n+import org.apache.commons.cli2.option.OptionTestCase;\n+import org.apache.commons.cli2.option.PropertyOption;\n+import org.apache.commons.cli2.option.SwitchTest;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public abstract class CommandLineTestCase\n+    extends CLITestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    public final Option present =\n+        new DefaultOptionBuilder().withLongName(\"present\").withLongName(\"alsopresent\").create();\n+    public final Option missing = new DefaultOptionBuilder().withLongName(\"missing\").create();\n+    public final Option multiple = new DefaultOptionBuilder().withLongName(\"multiple\").create();\n+    public final Option bool = new DefaultOptionBuilder().withLongName(\"bool\").create();\n+    public final Option root =\n+        new GroupBuilder().withOption(present).withOption(missing).withOption(multiple)\n+                          .withOption(bool).create();\n+    private CommandLine commandLine;\n+\n+    protected abstract CommandLine createCommandLine();\n+\n+    /*\n+     * @see TestCase#setUp()\n+     */\n+    public void setUp()\n+        throws Exception {\n+        super.setUp();\n+        commandLine = createCommandLine();\n+    }\n+\n+    /*\n+     * Class to test for boolean hasOption(String)\n+     */\n+    public final void testHasOptionString() {\n+        assertTrue(commandLine.hasOption(\"--present\"));\n+        assertTrue(commandLine.hasOption(\"--alsopresent\"));\n+        assertFalse(commandLine.hasOption(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for boolean hasOption(Option)\n+     */\n+    public final void testHasOptionOption() {\n+        assertTrue(commandLine.hasOption(present));\n+        assertFalse(commandLine.hasOption(missing));\n+    }\n+\n+    public final void testGetOption() {\n+        assertSame(present, commandLine.getOption(\"--present\"));\n+        assertSame(present, commandLine.getOption(\"--alsopresent\"));\n+\n+        //TODO decide whether the following assertion is valid\n+        //assertSame(missing,commandLine.getOption(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for List getValues(String)\n+     */\n+    public final void testGetValuesString() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--present\"));\n+        assertListContentsEqual(list(\"value 1\", \"value 2\", \"value 3\"),\n+                                commandLine.getValues(\"--multiple\"));\n+        assertTrue(commandLine.getValues(\"--missing\").isEmpty());\n+    }\n+\n+    /*\n+     * Class to test for List getValues(String, List)\n+     */\n+    public final void testGetValuesStringList() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--present\", null));\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(\"--alsopresent\", null));\n+        assertSame(commandLine.getValues(\"--missing\", Collections.EMPTY_LIST),\n+                   Collections.EMPTY_LIST);\n+\n+        final List def = Collections.singletonList(\"default value\");\n+        assertSame(def, commandLine.getValues(\"--missing\", def));\n+    }\n+\n+    /*\n+     * Class to test for List getValues(Option)\n+     */\n+    public final void testGetValuesOption() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(present));\n+        assertTrue(commandLine.getValues(missing).isEmpty());\n+    }\n+\n+    /*\n+     * Class to test for List getValues(Option, List)\n+     */\n+    public final void testGetValuesOptionList() {\n+        assertListContentsEqual(list(\"present value\"), commandLine.getValues(present));\n+        assertSame(commandLine.getValues(missing, Collections.EMPTY_LIST), Collections.EMPTY_LIST);\n+\n+        final List defs = Collections.singletonList(\"custom default\");\n+        assertSame(defs, commandLine.getValues(missing, defs));\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(String)\n+     */\n+    public final void testGetValueString() {\n+        assertEquals(\"present value\", commandLine.getValue(\"--present\"));\n+        assertEquals(\"present value\", commandLine.getValue(\"--alsopresent\"));\n+        assertNull(commandLine.getValue(\"--missing\"));\n+\n+        try {\n+            commandLine.getValue(\"--multiple\");\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(String, Object)\n+     */\n+    public final void testGetValueStringObject() {\n+        assertEquals(\"present value\", commandLine.getValue(\"--present\", \"default value\"));\n+        assertEquals(\"present value\", commandLine.getValue(\"--alsopresent\", \"default value\"));\n+        assertEquals(\"default value\", commandLine.getValue(\"--missing\", \"default value\"));\n+\n+        try {\n+            commandLine.getValue(\"--multiple\");\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(Option)\n+     */\n+    public final void testGetValueOption() {\n+        assertEquals(\"present value\", commandLine.getValue(present));\n+        assertNull(commandLine.getValue(missing));\n+\n+        try {\n+            commandLine.getValue(multiple);\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Object getValue(Option, Object)\n+     */\n+    public final void testGetValueOptionObject() {\n+        assertEquals(\"present value\", commandLine.getValue(present, \"default value\"));\n+        assertEquals(\"default value\", commandLine.getValue(missing, \"default value\"));\n+\n+        try {\n+            commandLine.getValue(multiple);\n+            fail(\"expected IllegalStateException\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(String)\n+     */\n+    public final void testGetSwitchString() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"--bool\"));\n+        assertNull(commandLine.getSwitch(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(String, Boolean)\n+     */\n+    public final void testGetSwitchStringBoolean() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"--bool\", Boolean.FALSE));\n+        assertEquals(Boolean.FALSE, commandLine.getSwitch(\"--missing\", Boolean.FALSE));\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(Option)\n+     */\n+    public final void testGetSwitchOption() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(bool));\n+        assertNull(commandLine.getSwitch(missing));\n+    }\n+\n+    /*\n+     * Class to test for Boolean getSwitch(Option, Boolean)\n+     */\n+    public final void testGetSwitchOptionBoolean() {\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(bool, Boolean.FALSE));\n+        assertEquals(Boolean.FALSE, commandLine.getSwitch(missing, Boolean.FALSE));\n+    }\n+\n+    /*\n+     * Class to test for String getProperty(String)\n+     */\n+    public final void testGetPropertyString() {\n+        assertEquals(\"present property\", commandLine.getProperty(\"present\"));\n+        assertNull(commandLine.getProperty(\"missing\"));\n+    }\n+\n+    /*\n+     * Class to test for String getProperty(String, String)\n+     */\n+    public final void testGetPropertyStringString() {\n+        assertEquals(\"present property\", commandLine.getProperty(\"present\", \"default property\"));\n+        assertEquals(\"default property\", commandLine.getProperty(\"missing\", \"default property\"));\n+    }\n+\n+    public final void testGetProperties() {\n+        assertTrue(commandLine.getProperties().containsAll(list(\"present\")));\n+    }\n+\n+    /*\n+     * Class to test for int getOptionCount(String)\n+     */\n+    public final void testGetOptionCountString() {\n+        // one option, one switch\n+        assertTrue(1 <= commandLine.getOptionCount(\"--present\"));\n+        assertTrue(1 <= commandLine.getOptionCount(\"--bool\"));\n+        assertEquals(0, commandLine.getOptionCount(\"--missing\"));\n+    }\n+\n+    /*\n+     * Class to test for int getOptionCount(Option)\n+     */\n+    public final void testGetOptionCountOption() {\n+        // one option, one switch\n+        assertTrue(1 <= commandLine.getOptionCount(present));\n+        assertTrue(1 <= commandLine.getOptionCount(bool));\n+        assertEquals(0, commandLine.getOptionCount(missing));\n+    }\n+\n+    public final void testGetOptions() {\n+        //TODO Implement getOptions().\n+    }\n+\n+    public final void testGetOptionTriggers() {\n+        //TODO Implement getOptionTriggers().\n+    }\n+\n+    // OLD TESTS FOLLOW\n+    public final void testProperties() {\n+        final Option option = new PropertyOption();\n+        final List args = CLITestCase.list();\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n+\n+        assertTrue(writeable.getProperties().isEmpty());\n+\n+        writeable.addProperty(\"myprop\", \"myval\");\n+        assertEquals(1, writeable.getProperties().size());\n+        assertEquals(\"myval\", writeable.getProperty(\"myprop\"));\n+\n+        writeable.addProperty(\"myprop\", \"myval2\");\n+        assertEquals(1, writeable.getProperties().size());\n+        assertEquals(\"myval2\", writeable.getProperty(\"myprop\"));\n+\n+        writeable.addProperty(\"myprop2\", \"myval3\");\n+        assertEquals(2, writeable.getProperties().size());\n+        assertEquals(\"myval3\", writeable.getProperty(\"myprop2\"));\n+    }\n+\n+    public final void testOptions() {\n+        final Option option = new PropertyOption();\n+        final List args = CLITestCase.list();\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        assertFalse(writeable.hasOption(start));\n+        assertFalse(writeable.hasOption(\"start\"));\n+        assertFalse(writeable.hasOption(\"go\"));\n+\n+        writeable.addOption(start);\n+\n+        assertTrue(writeable.hasOption(start));\n+        assertTrue(writeable.hasOption(\"start\"));\n+        assertTrue(writeable.hasOption(\"go\"));\n+    }\n+\n+    public final void testValues() {\n+        final Option option = new PropertyOption();\n+        final List args = CLITestCase.list();\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        assertNull(writeable.getValue(start));\n+        assertTrue(writeable.getValues(start).isEmpty());\n+\n+        writeable.addOption(start);\n+\n+        assertTrue(writeable.getValues(start).isEmpty());\n+\n+        writeable.addValue(start, \"file1\");\n+\n+        assertEquals(\"file1\", writeable.getValue(start));\n+        assertEquals(\"file1\", writeable.getValue(\"start\"));\n+        assertEquals(\"file1\", writeable.getValue(\"go\"));\n+        assertEquals(1, writeable.getValues(start).size());\n+        assertEquals(1, writeable.getValues(\"start\").size());\n+        assertEquals(1, writeable.getValues(\"go\").size());\n+        assertTrue(writeable.getValues(start).contains(\"file1\"));\n+        assertTrue(writeable.getValues(\"start\").contains(\"file1\"));\n+        assertTrue(writeable.getValues(\"go\").contains(\"file1\"));\n+\n+        writeable.addValue(start, \"file2\");\n+\n+        try {\n+            writeable.getValue(start);\n+            fail(\"Cannot get single value if multiple are present\");\n+        } catch (IllegalStateException ise) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         ise.getMessage());\n+        }\n+\n+        try {\n+            writeable.getValue(\"start\");\n+            fail(\"Cannot get single value if multiple are present\");\n+        } catch (IllegalStateException ise) {\n+            assertEquals(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_VALUES),\n+                         ise.getMessage());\n+        }\n+\n+        writeable.getValues(start).add(\"file3\");\n+    }\n+\n+    public final void testSwitches() {\n+        final Option option = new PropertyOption();\n+        final List args = CLITestCase.list();\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        assertNull(writeable.getSwitch(start));\n+        assertNull(writeable.getSwitch(\"start\"));\n+        assertNull(writeable.getSwitch(\"go\"));\n+\n+        writeable.addSwitch(start, true);\n+\n+        try {\n+            writeable.addSwitch(start, false);\n+            fail(\"Switch cannot be changed\");\n+        } catch (IllegalStateException ise) {\n+            assertEquals(resources.getMessage(ResourceConstants.SWITCH_ALREADY_SET),\n+                         ise.getMessage());\n+        }\n+    }\n+\n+    public final void testSwitches_True() {\n+        final Option option = new PropertyOption();\n+        final List args = CLITestCase.list();\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        writeable.addSwitch(start, true);\n+        assertSame(Boolean.TRUE, writeable.getSwitch(start));\n+    }\n+\n+    public final void testSwitches_False() {\n+        final Option option = new PropertyOption();\n+        final List args = CLITestCase.list();\n+        final WriteableCommandLine writeable = OptionTestCase.commandLine(option, args);\n+\n+        final Option start = CommandTest.buildStartCommand();\n+\n+        writeable.addSwitch(start, false);\n+        assertSame(Boolean.FALSE, writeable.getSwitch(start));\n+    }\n+\n+    //    public final void testLooksLikeOption() {\n+    //        final Option option = new PropertyOption();\n+    //        final List args = OptionTestCase.list();\n+    //        final WriteableCommandLine commandLine =\n+    //            OptionTestCase.commandLine(option, args);\n+    //\n+    //        assertTrue(commandLine.looksLikeOption(\"-D\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"--help\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"+display\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"myprefix\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"myprefix2\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"myprefference\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"/SCANDISK\"));\n+    //        assertFalse(commandLine.looksLikeOption(\"update\"));\n+    //    }\n+    public final void testGetOptions_Order()\n+        throws OptionException {\n+        final Option help = DefaultOptionTest.buildHelpOption();\n+        final Option login = CommandTest.buildLoginCommand();\n+        final Option targets = ArgumentTest.buildTargetsArgument();\n+\n+        final Group group =\n+            new GroupBuilder().withOption(help).withOption(login).withOption(targets).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(group);\n+\n+        final CommandLine cl =\n+            parser.parse(new String[] { \"login\", \"rob\", \"--help\", \"target1\", \"target2\" });\n+\n+        final Iterator i = cl.getOptions().iterator();\n+\n+        assertSame(login, i.next());\n+        assertSame(help, i.next());\n+        assertSame(targets, i.next());\n+        assertSame(targets, i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public final void testGetOptionCount()\n+        throws OptionException {\n+        final Option help = DefaultOptionTest.buildHelpOption();\n+        final Option login = CommandTest.buildLoginCommand();\n+        final Option targets = ArgumentTest.buildTargetsArgument();\n+        final Option display = SwitchTest.buildDisplaySwitch();\n+\n+        final Group group =\n+            new GroupBuilder().withOption(help).withOption(login).withOption(targets)\n+                              .withOption(display).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(group);\n+\n+        final CommandLine cl =\n+            parser.parse(new String[] {\n+                             \"--help\", \"login\", \"rob\", \"+display\", \"--help\", \"--help\", \"target1\",\n+                             \"target2\"\n+                         });\n+\n+        assertEquals(1, cl.getOptionCount(login));\n+        assertEquals(3, cl.getOptionCount(help));\n+        assertEquals(2, cl.getOptionCount(targets));\n+        assertEquals(1, cl.getOptionCount(display));\n+    }\n+\n+    public final void testGetOptionCount_Strings()\n+        throws OptionException {\n+        final Option help = DefaultOptionTest.buildHelpOption();\n+        final Option login = CommandTest.buildLoginCommand();\n+        final Option targets = ArgumentTest.buildTargetsArgument();\n+        final Option display = SwitchTest.buildDisplaySwitch();\n+\n+        final Group group =\n+            new GroupBuilder().withOption(help).withOption(login).withOption(targets)\n+                              .withOption(display).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(group);\n+\n+        final CommandLine cl =\n+            parser.parse(new String[] {\n+                             \"--help\", \"login\", \"rob\", \"+display\", \"--help\", \"--help\", \"target1\",\n+                             \"target2\"\n+                         });\n+\n+        assertEquals(1, cl.getOptionCount(\"login\"));\n+        assertEquals(3, cl.getOptionCount(\"-?\"));\n+        assertEquals(1, cl.getOptionCount(\"+display\"));\n+    }\n+\n+    public final void testOptionAsArgument()\n+        throws OptionException {\n+        final Option p = new DefaultOptionBuilder().withShortName(\"p\").create();\n+        final Argument argument = new ArgumentBuilder().create();\n+        final Option withArgument =\n+            new DefaultOptionBuilder().withShortName(\"attr\").withArgument(argument).create();\n+\n+        final Group group = new GroupBuilder().withOption(p).withOption(withArgument).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(group);\n+\n+        final CommandLine cl = parser.parse(new String[] { \"-p\", \"-attr\", \"p\" });\n+\n+        assertEquals(1, cl.getOptionCount(\"-p\"));\n+        assertTrue(cl.hasOption(\"-p\"));\n+        assertTrue(cl.hasOption(\"-attr\"));\n+        assertTrue(cl.getValue(\"-attr\").equals(\"p\"));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/DocumentationTest.java\n+++ b/src/test/org/apache/commons/cli2/DocumentationTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.io.IOException;import java.io.PrintWriter;import java.io.StringWriter;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;import org.apache.commons.cli2.option.DefaultOption;import org.apache.commons.cli2.option.PropertyOption;import org.apache.commons.cli2.util.HelpFormatter;/** * @author Rob */public class DocumentationTest extends TestCase {    public void testBasicUsage() throws IOException, OptionException {        HelpFormatter helpFormatter = new HelpFormatter();        //ignore all printed        helpFormatter.setPrintWriter(new PrintWriter(new StringWriter()));        /*         * --version -? -h --help -log file -s|-q|-v|-d Bursting File/Num/Date         * validation Switches Commands Auto help Auto exception help         *         */        DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        Option version =            obuilder                .withLongName(\"version\")                .withDescription(\"Displays version information and then exits\")                .create();        Option help =            obuilder                .withShortName(\"h\")                .withShortName(\"?\")                .withLongName(\"help\")                .withDescription(\"Displays help on usage and then exits\")                .create();        ArgumentBuilder abuilder = new ArgumentBuilder();        Argument logFile =            abuilder                .withDescription(\"The log file to write to\")                .withName(\"file\")                .withMinimum(1)                .withMaximum(1)                .create();        Option log =            obuilder                .withArgument(logFile)                .withShortName(\"log\")                .withDescription(\"Log progress information to a file\")                .create();        GroupBuilder gbuilder = new GroupBuilder();        Group outputQuality =            gbuilder                .withName(\"quality\")                .withDescription(\"Controls the quality of console output\")                .withMaximum(1)                .withOption(                    obuilder                        .withShortName(\"s\")                        .withDescription(\"Silent\")                        .create())                .withOption(                    obuilder                        .withShortName(\"q\")                        .withDescription(\"Quiet\")                        .create())                .withOption(                    obuilder                        .withShortName(\"n\")                        .withDescription(\"Normal\")                        .create())                .withOption(                    obuilder                        .withShortName(\"v\")                        .withDescription(\"Verbose\")                        .create())                .withOption(                    obuilder                        .withShortName(\"d\")                        .withDescription(\"Debug\")                        .create())                .create();        Group options =            new GroupBuilder()                .withName(\"options\")                .withOption(version)                .withOption(help)                .withOption(log)                .withOption(outputQuality)                .create();        final String[] args = new String[] { \"--bad-option\" };        Parser parser = new Parser();        parser.setHelpFormatter(helpFormatter);        parser.setGroup(options);        parser.setHelpOption(help);        CommandLine commandLine = parser.parseAndHelp(args);        if (commandLine != null) {            if (commandLine.hasOption(version)) {                System.out.println(\"MyApp ver 1.0\");                return;            }            if (commandLine.hasOption(\"-log\")) {                String filename = (String)commandLine.getValue(\"-log\");                //...            }        }        try {            commandLine = parser.parse(args);            fail(\"Unexpected Option!\");        }        catch (OptionException uoe) {            assertEquals(                \"Unexpected --bad-option while processing options\",                uoe.getMessage());        }    }    public void testManualIntroduction() {        DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        ArgumentBuilder aBuilder = new ArgumentBuilder();        GroupBuilder gBuilder = new GroupBuilder();        DefaultOption xmlOption =            oBuilder                .withLongName(\"xml\")                .withDescription(\"Output using xml format\")                .create();        Argument pathArgument =            aBuilder                .withName(\"path\")                .withMinimum(1)                .withMaximum(1)                .create();        Group outputChildren =            gBuilder                .withOption(xmlOption)                .create();        Option outputOption =            oBuilder                .withLongName(\"output\")                .withDescription(\"Outputs to a file\")                .withArgument(pathArgument)                .withChildren(outputChildren)                .create();        ///////////////////////////////////////////////////        Group options = outputChildren;        HelpFormatter hf = new HelpFormatter();        Parser p = new Parser();        p.setGroup(options);        p.setHelpFormatter(hf);        p.setHelpTrigger(\"--help\");        CommandLine cl = p.parseAndHelp(new String[]{});        if(cl==null) {            System.exit(-1);        }        //////////////////////////////////////////////////        cl = new WriteableCommandLineImpl(outputChildren,new ArrayList());        // if we have --output option        if(cl.hasOption(\"--output\")) {            // grab the path            String path = (String)cl.getValue(\"--output\");            // grab the format            boolean xml = cl.hasOption(\"--xml\");            // configure the application's output            configureOutput(path,xml);        }    }    private void configureOutput(String path, boolean xml) {        // TODO Auto-generated method stub    }    public void testExampleAnt() throws IOException, OptionException {        // Apache Ant version 1.6.1 compiled on February 12 2004        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        final ArgumentBuilder abuilder = new ArgumentBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        Option help =            obuilder                .withShortName(\"help\")                .withShortName(\"h\")                .withDescription(\"print this message\")                .create();        Option projecthelp =            obuilder                .withShortName(\"projecthelp\")                .withShortName(\"p\")                .withDescription(\"print project help information\")                .create();        Option version =            obuilder                .withShortName(\"version\")                .withDescription(\"print the version information and exit\")                .create();        Option diagnostics =            obuilder                .withShortName(\"diagnostics\")                .withDescription(\"print information that might be helpful to diagnose or report problems.\")                .create();        Option quiet =            obuilder                .withShortName(\"quiet\")                .withShortName(\"q\")                .withDescription(\"be extra quiet\")                .create();        Option verbose =            obuilder                .withShortName(\"verbose\")                .withShortName(\"v\")                .withDescription(\"be extra verbose\")                .create();        Option debug =            obuilder                .withShortName(\"debug\")                .withShortName(\"d\")                .withDescription(\"print debugging information\")                .create();        Option emacs =            obuilder                .withShortName(\"emacs\")                .withShortName(\"e\")                .withDescription(\"produce logging information without adornments\")                .create();        Option lib =            obuilder                .withShortName(\"lib\")                .withDescription(\"specifies a path to search for jars and classes\")                .withArgument(                    abuilder                        .withName(\"path\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option logfile =            obuilder                .withShortName(\"logfile\")                .withShortName(\"l\")                .withDescription(\"use given file for log\")                .withArgument(                    abuilder                        .withName(\"file\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option logger =            obuilder                .withShortName(\"logger\")                .withDescription(\"the class which is to perform logging\")                .withArgument(                    abuilder                        .withName(\"classname\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option listener =            obuilder                .withShortName(\"listener\")                .withDescription(\"add an instance of class as a project listener\")                .withArgument(                    abuilder                        .withName(\"classname\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option noinput =            obuilder                .withShortName(\"noinput\")                .withDescription(\"do not allow interactive input\")                .create();        Option buildfile =            obuilder                .withShortName(\"buildfile\")                .withShortName(\"file\")                .withShortName(\"f\")                .withDescription(\"use given buildfile\")                .withArgument(                    abuilder                        .withName(\"file\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option property = new PropertyOption();        Option propertyfile =            obuilder                .withShortName(\"propertyfile\")                .withDescription(\"load all properties from file with -D properties taking precedence\")                .withArgument(                    abuilder                        .withName(\"name\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option inputhandler =            obuilder                .withShortName(\"inputhandler\")                .withDescription(\"the class which will handle input requests\")                .withArgument(                    abuilder                        .withName(\"class\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option find =            obuilder                .withShortName(\"find\")                .withShortName(\"s\")                .withDescription(\"search for buildfile towards the root of the filesystem and use it\")                .withArgument(                    abuilder                        .withName(\"file\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        Option targets = abuilder.withName(\"target\").create();        Group options =            gbuilder                .withName(\"options\")                .withOption(help)                .withOption(projecthelp)                .withOption(version)                .withOption(diagnostics)                .withOption(quiet)                .withOption(verbose)                .withOption(debug)                .withOption(emacs)                .withOption(lib)                .withOption(logfile)                .withOption(logger)                .withOption(listener)                .withOption(noinput)                .withOption(buildfile)                .withOption(property)                .withOption(propertyfile)                .withOption(inputhandler)                .withOption(find)                .withOption(targets)                .create();        /////////////////////////////////////        String[] args = new String[]{};        Parser parser = new Parser();        parser.setGroup(options);        CommandLine cl = parser.parse(args);        if(cl.hasOption(help)) {            //displayHelp();            return;        }        if(cl.hasOption(\"-version\")) {            //displayVersion();            return;        }        if(cl.hasOption(logfile)) {            String file = (String)cl.getValue(logfile);            //setLogFile();        }        List targetList = cl.getValues(targets);        for (Iterator i = targetList.iterator(); i.hasNext();) {            String target = (String) i.next();            //doTarget(target);        }        /////////////////////////////////////        HelpFormatter hf = new HelpFormatter();        hf.setShellCommand(\"ant\");        hf.getFullUsageSettings().add(DisplaySetting.DISPLAY_GROUP_NAME);        hf.getFullUsageSettings().add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);        hf.getFullUsageSettings().remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_PROPERTY_OPTION);        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);        hf.getDisplaySettings().remove(DisplaySetting.DISPLAY_GROUP_ARGUMENT);        hf.setGroup(options);        // redirect printed stuff to a string        hf.setPrintWriter(new PrintWriter(new StringWriter()));        hf.print();    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.option.PropertyOption;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+/**\n+ * @author Rob\n+ */\n+public class DocumentationTest extends TestCase {\n+\n+    public void testBasicUsage() throws IOException, OptionException {\n+        HelpFormatter helpFormatter = new HelpFormatter();\n+        //ignore all printed\n+        helpFormatter.setPrintWriter(new PrintWriter(new StringWriter()));\n+\n+        /*\n+         * --version -? -h --help -log file -s|-q|-v|-d Bursting File/Num/Date\n+         * validation Switches Commands Auto help Auto exception help\n+         *  \n+         */\n+        DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        Option version =\n+            obuilder\n+                .withLongName(\"version\")\n+                .withDescription(\"Displays version information and then exits\")\n+                .create();\n+\n+        Option help =\n+            obuilder\n+                .withShortName(\"h\")\n+                .withShortName(\"?\")\n+                .withLongName(\"help\")\n+                .withDescription(\"Displays help on usage and then exits\")\n+                .create();\n+\n+        ArgumentBuilder abuilder = new ArgumentBuilder();\n+        Argument logFile =\n+            abuilder\n+                .withDescription(\"The log file to write to\")\n+                .withName(\"file\")\n+                .withMinimum(1)\n+                .withMaximum(1)\n+                .create();\n+        Option log =\n+            obuilder\n+                .withArgument(logFile)\n+                .withShortName(\"log\")\n+                .withDescription(\"Log progress information to a file\")\n+                .create();\n+\n+        GroupBuilder gbuilder = new GroupBuilder();\n+        Group outputQuality =\n+            gbuilder\n+                .withName(\"quality\")\n+                .withDescription(\"Controls the quality of console output\")\n+                .withMaximum(1)\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"s\")\n+                        .withDescription(\"Silent\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"q\")\n+                        .withDescription(\"Quiet\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"n\")\n+                        .withDescription(\"Normal\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"v\")\n+                        .withDescription(\"Verbose\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"d\")\n+                        .withDescription(\"Debug\")\n+                        .create())\n+                .create();\n+\n+        Group options =\n+            new GroupBuilder()\n+                .withName(\"options\")\n+                .withOption(version)\n+                .withOption(help)\n+                .withOption(log)\n+                .withOption(outputQuality)\n+                .create();\n+\n+        final String[] args = new String[] { \"--bad-option\" };\n+\n+        Parser parser = new Parser();\n+        parser.setHelpFormatter(helpFormatter);\n+        parser.setGroup(options);\n+        parser.setHelpOption(help);\n+        CommandLine commandLine = parser.parseAndHelp(args);\n+        if (commandLine != null) {\n+            if (commandLine.hasOption(version)) {\n+                System.out.println(\"MyApp ver 1.0\");\n+                return;\n+            }\n+            if (commandLine.hasOption(\"-log\")) {\n+                String filename = (String)commandLine.getValue(\"-log\");\n+                //...\n+            }\n+        }\n+\n+        try {\n+            commandLine = parser.parse(args);\n+            fail(\"Unexpected Option!\");\n+        }\n+        catch (OptionException uoe) {\n+            assertEquals(\n+                \"Unexpected --bad-option while processing options\",\n+                uoe.getMessage());\n+        }\n+    }\n+    \n+    public void testManualIntroduction() {\n+        \n+        DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        ArgumentBuilder aBuilder = new ArgumentBuilder();\n+        GroupBuilder gBuilder = new GroupBuilder();\n+        \n+        DefaultOption xmlOption = \n+            oBuilder\n+                .withLongName(\"xml\")\n+                .withDescription(\"Output using xml format\")\n+                .create();\n+        \n+        Argument pathArgument = \n+            aBuilder\n+                .withName(\"path\")\n+                .withMinimum(1)\n+                .withMaximum(1)\n+                .create();\n+        \n+        Group outputChildren = \n+            gBuilder\n+                .withOption(xmlOption)\n+                .create();\n+        \n+        Option outputOption = \n+            oBuilder\n+                .withLongName(\"output\")\n+                .withDescription(\"Outputs to a file\")\n+                .withArgument(pathArgument)\n+                .withChildren(outputChildren)\n+                .create();\n+        \n+        ///////////////////////////////////////////////////\n+        \n+        Group options = outputChildren;\n+        HelpFormatter hf = new HelpFormatter();\n+\n+        Parser p = new Parser();\n+        p.setGroup(options);\n+        p.setHelpFormatter(hf);\n+        p.setHelpTrigger(\"--help\");\n+        CommandLine cl = p.parseAndHelp(new String[]{});\n+        if(cl==null) {\n+            System.exit(-1);\n+        }\n+        \n+        //////////////////////////////////////////////////\n+        \n+        cl = new WriteableCommandLineImpl(outputChildren,new ArrayList());\n+        \n+        // if we have --output option\n+        if(cl.hasOption(\"--output\")) {\n+            // grab the path\n+            String path = (String)cl.getValue(\"--output\");\n+            // grab the format\n+            boolean xml = cl.hasOption(\"--xml\");\n+            // configure the application's output\n+            configureOutput(path,xml);\n+        }\n+        \n+        \n+                \n+        \n+    }\n+\n+    private void configureOutput(String path, boolean xml) {\n+        // TODO Auto-generated method stub\n+        \n+    }\n+\n+    public void testExampleAnt() throws IOException, OptionException {\n+        // Apache Ant version 1.6.1 compiled on February 12 2004\n+\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        Option help =\n+            obuilder\n+                .withShortName(\"help\")\n+                .withShortName(\"h\")\n+                .withDescription(\"print this message\")\n+                .create();\n+        Option projecthelp =\n+            obuilder\n+                .withShortName(\"projecthelp\")\n+                .withShortName(\"p\")\n+                .withDescription(\"print project help information\")\n+                .create();\n+        Option version =\n+            obuilder\n+                .withShortName(\"version\")\n+                .withDescription(\"print the version information and exit\")\n+                .create();\n+        Option diagnostics =\n+            obuilder\n+                .withShortName(\"diagnostics\")\n+                .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                .create();\n+        Option quiet =\n+            obuilder\n+                .withShortName(\"quiet\")\n+                .withShortName(\"q\")\n+                .withDescription(\"be extra quiet\")\n+                .create();\n+        Option verbose =\n+            obuilder\n+                .withShortName(\"verbose\")\n+                .withShortName(\"v\")\n+                .withDescription(\"be extra verbose\")\n+                .create();\n+        Option debug =\n+            obuilder\n+                .withShortName(\"debug\")\n+                .withShortName(\"d\")\n+                .withDescription(\"print debugging information\")\n+                .create();\n+        Option emacs =\n+            obuilder\n+                .withShortName(\"emacs\")\n+                .withShortName(\"e\")\n+                .withDescription(\"produce logging information without adornments\")\n+                .create();\n+        Option lib =\n+            obuilder\n+                .withShortName(\"lib\")\n+                .withDescription(\"specifies a path to search for jars and classes\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"path\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option logfile =\n+            obuilder\n+                .withShortName(\"logfile\")\n+                .withShortName(\"l\")\n+                .withDescription(\"use given file for log\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"file\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option logger =\n+            obuilder\n+                .withShortName(\"logger\")\n+                .withDescription(\"the class which is to perform logging\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"classname\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option listener =\n+            obuilder\n+                .withShortName(\"listener\")\n+                .withDescription(\"add an instance of class as a project listener\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"classname\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option noinput =\n+            obuilder\n+                .withShortName(\"noinput\")\n+                .withDescription(\"do not allow interactive input\")\n+                .create();\n+        Option buildfile =\n+            obuilder\n+                .withShortName(\"buildfile\")\n+                .withShortName(\"file\")\n+                .withShortName(\"f\")\n+                .withDescription(\"use given buildfile\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"file\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option property = new PropertyOption();\n+        Option propertyfile =\n+            obuilder\n+                .withShortName(\"propertyfile\")\n+                .withDescription(\"load all properties from file with -D properties taking precedence\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"name\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option inputhandler =\n+            obuilder\n+                .withShortName(\"inputhandler\")\n+                .withDescription(\"the class which will handle input requests\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"class\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option find =\n+            obuilder\n+                .withShortName(\"find\")\n+                .withShortName(\"s\")\n+                .withDescription(\"search for buildfile towards the root of the filesystem and use it\")\n+                .withArgument(\n+                    abuilder\n+                        .withName(\"file\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+        Option targets = abuilder.withName(\"target\").create();\n+\n+        Group options =\n+            gbuilder\n+                .withName(\"options\")\n+                .withOption(help)\n+                .withOption(projecthelp)\n+                .withOption(version)\n+                .withOption(diagnostics)\n+                .withOption(quiet)\n+                .withOption(verbose)\n+                .withOption(debug)\n+                .withOption(emacs)\n+                .withOption(lib)\n+                .withOption(logfile)\n+                .withOption(logger)\n+                .withOption(listener)\n+                .withOption(noinput)\n+                .withOption(buildfile)\n+                .withOption(property)\n+                .withOption(propertyfile)\n+                .withOption(inputhandler)\n+                .withOption(find)\n+                .withOption(targets)\n+                .create();\n+        \n+        /////////////////////////////////////\n+        String[] args = new String[]{};\n+        \n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        CommandLine cl = parser.parse(args);\n+        \n+        if(cl.hasOption(help)) {\n+            //displayHelp();\n+            return;\n+        }\n+        if(cl.hasOption(\"-version\")) {\n+            //displayVersion();\n+            return;\n+        }\n+        if(cl.hasOption(logfile)) {\n+            String file = (String)cl.getValue(logfile);\n+            //setLogFile();\n+        }\n+        List targetList = cl.getValues(targets);\n+        for (Iterator i = targetList.iterator(); i.hasNext();) {\n+            String target = (String) i.next();\n+            //doTarget(target);\n+        }\n+        \n+        /////////////////////////////////////\n+\n+        HelpFormatter hf = new HelpFormatter();\n+        hf.setShellCommand(\"ant\");\n+        hf.getFullUsageSettings().add(DisplaySetting.DISPLAY_GROUP_NAME);\n+        hf.getFullUsageSettings().add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+        hf.getFullUsageSettings().remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+\n+        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        hf.getLineUsageSettings().add(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+\n+        hf.getDisplaySettings().remove(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+\n+        hf.setGroup(options);\n+        // redirect printed stuff to a string\n+        hf.setPrintWriter(new PrintWriter(new StringWriter()));\n+        hf.print();\n+\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/PrecedenceTest.java\n+++ b/src/test/org/apache/commons/cli2/PrecedenceTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import java.util.Arrays;import java.util.List;import java.util.Set;import junit.framework.TestCase;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;/** * @author Rob Oxspring */public class PrecedenceTest extends TestCase {    private final String[] args = new String[] { \"-file\" };    public void testSimple() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final Group options =            new GroupBuilder()                .withOption(oBuilder.withShortName(\"file\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-file\" }, cl);    }    public void testArgument() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group options =            new GroupBuilder()                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withArgument(aBuilder.create())                        .create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public void testBurst() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"f\").create())                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);    }    public void testChildren() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final Group children =            gBuilder                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final Group options =            gBuilder                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);    }    public void XtestSimpleVsArgument() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"file\").create())                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withArgument(aBuilder.create())                        .create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public void XtestSimpleVsBurst() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"file\").create())                .withOption(oBuilder.withShortName(\"f\").create())                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);    }    public void XtestSimpleVsChildren() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final Group children =            gBuilder                .withOption(                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())                .withOption(                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())                .withOption(                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())                .create();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"file\").create())                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(            new String[] { \"-f\", \"-i\", \"--ci\", \"-l\", \"--cl\", \"-e\", \"--ce\" },            cl);    }    public void testArgumentVsBurst() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group options =            gBuilder                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withArgument(aBuilder.create())                        .create())                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public void testArgumentVsChildren() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group children =            gBuilder                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final Group options =            gBuilder                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .withArgument(aBuilder.create())                        .create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public void testBurstVsChildren() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final Group children =            gBuilder                .withOption(                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())                .withOption(                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())                .withOption(                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())                .create();        final Group options =            gBuilder                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .create())                .withOption(                    oBuilder.withShortName(\"i\").withLongName(\"bi\").create())                .withOption(                    oBuilder.withShortName(\"l\").withLongName(\"bl\").create())                .withOption(                    oBuilder.withShortName(\"e\").withLongName(\"be\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(            new String[] { \"-f\", \"-i\", \"--ci\", \"-l\", \"--cl\", \"-e\", \"--ce\" },            cl);    }    public void XtestSimpleVsArgumentVsBurst() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"file\").create())                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withArgument(aBuilder.create())                        .create())                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public void XtestSimpleVsArgumentVsChildren() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group children =            gBuilder                .withOption(                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())                .withOption(                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())                .withOption(                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())                .create();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"file\").create())                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .withArgument(aBuilder.create())                        .create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public void XtestSimpleVsBurstVsChildren() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final Group children =            gBuilder                .withOption(                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())                .withOption(                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())                .withOption(                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())                .create();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"file\").create())                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .create())                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);    }    public void testArgumentVsBurstVsChildren() throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group children =            gBuilder                .withOption(                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())                .withOption(                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())                .withOption(                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())                .create();        final Group options =            gBuilder                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .withArgument(aBuilder.create())                        .create())                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public void XtestSimpleVsArgumentVsBurstVsChildren()        throws OptionException {        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        final GroupBuilder gBuilder = new GroupBuilder();        final ArgumentBuilder aBuilder = new ArgumentBuilder();        final Group children =            gBuilder                .withOption(                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())                .withOption(                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())                .withOption(                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())                .create();        final Group options =            gBuilder                .withOption(oBuilder.withShortName(\"file\").create())                .withOption(                    oBuilder                        .withShortName(\"f\")                        .withChildren(children)                        .withArgument(aBuilder.create())                        .create())                .withOption(oBuilder.withShortName(\"i\").create())                .withOption(oBuilder.withShortName(\"l\").create())                .withOption(oBuilder.withShortName(\"e\").create())                .create();        final CommandLine cl = buildCommandLine(options, args);        assertEquals(new String[] { \"-f\" }, cl);    }    public CommandLine buildCommandLine(final Group group, final String[] arguments)        throws OptionException {        Parser p = new Parser();        p.setGroup(group);        return p.parse(arguments);    }    public void assertEquals(final String options[], final CommandLine line) {        final List expected = Arrays.asList(options);        final Set actual = line.getOptionTriggers();        assertTrue(expected.containsAll(actual));        assertTrue(actual.containsAll(expected));    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class PrecedenceTest extends TestCase {\n+    private final String[] args = new String[] { \"-file\" };\n+\n+    public void testSimple() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+\n+        final Group options =\n+            new GroupBuilder()\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-file\" }, cl);\n+    }\n+\n+    public void testArgument() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            new GroupBuilder()\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void testBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"f\").create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void testChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsArgument() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(oBuilder.withShortName(\"f\").create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(\n+            new String[] { \"-f\", \"-i\", \"--ci\", \"-l\", \"--cl\", \"-e\", \"--ce\" },\n+            cl);\n+    }\n+\n+    public void testArgumentVsBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void testArgumentVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void testBurstVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"bi\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"bl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"be\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(\n+            new String[] { \"-f\", \"-i\", \"--ci\", \"-l\", \"--cl\", \"-e\", \"--ce\" },\n+            cl);\n+    }\n+\n+    public void XtestSimpleVsArgumentVsBurst() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsArgumentVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsBurstVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\", \"-i\", \"-l\", \"-e\" }, cl);\n+    }\n+\n+    public void testArgumentVsBurstVsChildren() throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public void XtestSimpleVsArgumentVsBurstVsChildren()\n+        throws OptionException {\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+        final Group children =\n+            gBuilder\n+                .withOption(\n+                    oBuilder.withShortName(\"i\").withLongName(\"ci\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"l\").withLongName(\"cl\").create())\n+                .withOption(\n+                    oBuilder.withShortName(\"e\").withLongName(\"ce\").create())\n+                .create();\n+\n+        final Group options =\n+            gBuilder\n+                .withOption(oBuilder.withShortName(\"file\").create())\n+                .withOption(\n+                    oBuilder\n+                        .withShortName(\"f\")\n+                        .withChildren(children)\n+                        .withArgument(aBuilder.create())\n+                        .create())\n+                .withOption(oBuilder.withShortName(\"i\").create())\n+                .withOption(oBuilder.withShortName(\"l\").create())\n+                .withOption(oBuilder.withShortName(\"e\").create())\n+                .create();\n+\n+        final CommandLine cl = buildCommandLine(options, args);\n+        assertEquals(new String[] { \"-f\" }, cl);\n+    }\n+\n+    public CommandLine buildCommandLine(final Group group, final String[] arguments)\n+        throws OptionException {\n+        Parser p = new Parser();\n+        p.setGroup(group);\n+        return p.parse(arguments);\n+    }\n+\n+    public void assertEquals(final String options[], final CommandLine line) {\n+        final List expected = Arrays.asList(options);\n+        final Set actual = line.getOptionTriggers();\n+\n+        assertTrue(expected.containsAll(actual));\n+        assertTrue(actual.containsAll(expected));\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/cli2/WriteableCommandLineTestCase.java\n+++ b/src/test/org/apache/commons/cli2/WriteableCommandLineTestCase.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2;import org.apache.commons.cli2.option.ArgumentTest;/** * @author Rob Oxspring */public abstract class WriteableCommandLineTestCase extends CommandLineTestCase {\tprivate WriteableCommandLine writeable;\tprotected abstract WriteableCommandLine createWriteableCommandLine();\t/* (non-Javadoc)\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\t */\tprotected final CommandLine createCommandLine() {\t\tfinal WriteableCommandLine cl = createWriteableCommandLine();\t\tcl.addOption(present);\t\tcl.addProperty(\"present\",\"present property\");\t\tcl.addSwitch(bool,true);\t\tcl.addValue(present,\"present value\");\t\tcl.addOption(multiple);\t\tcl.addValue(multiple,\"value 1\");\t\tcl.addValue(multiple,\"value 2\");\t\tcl.addValue(multiple,\"value 3\");\t\treturn cl;\t}\t/*\t * @see CommandLineTest#setUp()\t */\tpublic void setUp() throws Exception {\t\tsuper.setUp();\t\twriteable = createWriteableCommandLine();\t}\tpublic final void testAddOption() {\t\tassertFalse(writeable.hasOption(present));\t\twriteable.addOption(present);\t\tassertTrue(writeable.hasOption(present));\t}\tpublic final void testAddValue() {\t\tassertFalse(writeable.hasOption(present));\t\tassertTrue(writeable.getValues(present).isEmpty());\t\twriteable.addValue(present,\"value\");\t\tassertContentsEqual(list(\"value\"),writeable.getValues(present));\t\t// most options shouldn't appear due to adding values\t\tassertFalse(writeable.hasOption(present));\t\tfinal Argument arg = ArgumentTest.buildHostArgument();\t\tassertFalse(writeable.hasOption(arg));\t\tassertTrue(writeable.getValues(arg).isEmpty());\t\twriteable.addValue(arg,\"value\");\t\tassertContentsEqual(list(\"value\"),writeable.getValues(arg));\t\t// Arguments should force the option present\t\tassertTrue(writeable.hasOption(arg));\t}\tpublic final void testAddSwitch() {\t\tassertFalse(writeable.hasOption(present));\t\tassertNull(writeable.getSwitch(present));\t\twriteable.addSwitch(present,true);\t\tassertEquals(Boolean.TRUE,writeable.getSwitch(present));\t\tassertTrue(writeable.hasOption(present));\t}\tpublic final void testAddProperty() {\t\tassertNull(writeable.getProperty(\"present\"));\t\twriteable.addProperty(\"present\",\"present value\");\t\tassertEquals(\"present value\",writeable.getProperty(\"present\"));\t}\tpublic final void testLooksLikeOption() {\t\t//TODO Implement looksLikeOption().\t}}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2;\n+\n+import org.apache.commons.cli2.option.ArgumentTest;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class WriteableCommandLineTestCase extends CommandLineTestCase {\n+\t\n+\tprivate WriteableCommandLine writeable;\n+\t\n+\tprotected abstract WriteableCommandLine createWriteableCommandLine();\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+\t */\n+\tprotected final CommandLine createCommandLine() {\n+\t\tfinal WriteableCommandLine cl = createWriteableCommandLine();\n+\t\tcl.addOption(present);\n+\t\tcl.addProperty(\"present\",\"present property\");\n+\t\tcl.addSwitch(bool,true);\n+\t\tcl.addValue(present,\"present value\");\n+\t\tcl.addOption(multiple);\n+\t\tcl.addValue(multiple,\"value 1\");\n+\t\tcl.addValue(multiple,\"value 2\");\n+\t\tcl.addValue(multiple,\"value 3\");\n+\t\treturn cl;\n+\t}\n+\t\n+\t/*\n+\t * @see CommandLineTest#setUp()\n+\t */\n+\tpublic void setUp() throws Exception {\n+\t\tsuper.setUp();\n+\t\twriteable = createWriteableCommandLine();\n+\t}\n+\tpublic final void testAddOption() {\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\twriteable.addOption(present);\n+\t\tassertTrue(writeable.hasOption(present));\n+\t}\n+\tpublic final void testAddValue() {\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\tassertTrue(writeable.getValues(present).isEmpty());\n+\t\twriteable.addValue(present,\"value\");\n+\t\tassertContentsEqual(list(\"value\"),writeable.getValues(present));\n+\t\t\n+\t\t// most options shouldn't appear due to adding values\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\t\n+\t\tfinal Argument arg = ArgumentTest.buildHostArgument();\n+\t\t\n+\t\tassertFalse(writeable.hasOption(arg));\n+\t\tassertTrue(writeable.getValues(arg).isEmpty());\n+\t\twriteable.addValue(arg,\"value\");\n+\t\tassertContentsEqual(list(\"value\"),writeable.getValues(arg));\n+\t\t\n+\t\t// Arguments should force the option present\n+\t\tassertTrue(writeable.hasOption(arg));\n+\t}\n+\tpublic final void testAddSwitch() {\n+\t\tassertFalse(writeable.hasOption(present));\n+\t\tassertNull(writeable.getSwitch(present));\n+\t\twriteable.addSwitch(present,true);\n+\t\tassertEquals(Boolean.TRUE,writeable.getSwitch(present));\n+\t\tassertTrue(writeable.hasOption(present));\n+\t}\n+\tpublic final void testAddProperty() {\n+\t\tassertNull(writeable.getProperty(\"present\"));\n+\t\twriteable.addProperty(\"present\",\"present value\");\n+\t\tassertEquals(\"present value\",writeable.getProperty(\"present\"));\n+\t}\n+\tpublic final void testLooksLikeOption() {\n+\t\t//TODO Implement looksLikeOption().\n+\t}\n+}\n--- a/src/test/org/apache/commons/cli2/application/AntTest.java\n+++ b/src/test/org/apache/commons/cli2/application/AntTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.application;import java.util.ArrayList;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.option.PropertyOption;//TODO Build up AntTest like CpTestpublic class AntTest extends TestCase {    public void testAnt() throws OptionException {        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        final ArgumentBuilder abuilder = new ArgumentBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Group options =            gbuilder                .withName(\"ant\")                .withOption(                    obuilder                        .withShortName(\"help\")                        .withDescription(\"print this message\")                        .create())                .withOption(                    obuilder                        .withShortName(\"projecthelp\")                        .withDescription(\"print project help information\")                        .create())                .withOption(                    obuilder                        .withShortName(\"version\")                        .withDescription(\"print the version information and exit\")                        .create())                .withOption(                    obuilder                        .withShortName(\"diagnostics\")                        .withDescription(\"print information that might be helpful to diagnose or report problems.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"quiet\")                        .withShortName(\"q\")                        .withDescription(\"be extra quiet\")                        .create())                .withOption(                    obuilder                        .withShortName(\"verbose\")                        .withShortName(\"v\")                        .withDescription(\"be extra verbose\")                        .create())                .withOption(                    obuilder                        .withShortName(\"debug\")                        .withDescription(\"print debugging information\")                        .create())                .withOption(                    obuilder                        .withShortName(\"emacs\")                        .withDescription(\"produce logging information without adornments\")                        .create())                .withOption(                    obuilder                        .withShortName(\"logfile\")                        .withShortName(\"l\")                        .withDescription(\"use given file for log\")                        .withArgument(                            abuilder                                .withName(\"file\")                                .withMinimum(1)                                .withMaximum(1)                                .create())                        .create())                .withOption(                    obuilder                        .withShortName(\"logger\")                        .withDescription(\"the class which is to perform logging\")                        .withArgument(                            abuilder                                .withName(\"classname\")                                .withMinimum(1)                                .withMaximum(1)                                .create())                        .create())                .withOption(                    obuilder                        .withShortName(\"listener\")                        .withDescription(\"add an instance of class as a project listener\")                        .withArgument(                            abuilder                                .withName(\"classname\")                                .withMinimum(1)                                .withMaximum(1)                                .create())                        .create())                .withOption(                    obuilder                        .withShortName(\"buildfile\")                        .withShortName(\"file\")                        .withShortName(\"f\")                        .withDescription(\"use given buildfile\")                        .withArgument(                            abuilder                                .withName(\"file\")                                .withMinimum(1)                                .withMaximum(1)                                .create())                        .create())                .withOption(PropertyOption.INSTANCE)                .withOption(                    obuilder                        .withShortName(\"propertyfile\")                        .withDescription(\"load all properties from file with -D properties taking precedence\")                        .withArgument(                            abuilder                                .withName(\"name\")                                .withMinimum(1)                                .withMaximum(1)                                .create())                        .create())                .withOption(                    obuilder                        .withShortName(\"inputhandler\")                        .withDescription(\"the class which will handle input requests\")                        .withArgument(                            abuilder                                .withName(\"class\")                                .withMinimum(1)                                .withMaximum(1)                                .create())                        .create())                .withOption(                    obuilder                        .withShortName(\"find\")                        .withDescription(\"search for buildfile towards the root of the filesystem and use it\")                        .withArgument(                            abuilder                                .withName(\"file\")                                .withMinimum(1)                                .withMaximum(1)                                .create())                        .create())                .withOption(abuilder.withName(\"target\").create())                .create();        Parser parser = new Parser();        parser.setGroup(options);        CommandLine line =            parser.parse(                new String[] {                    \"-buildfile\",                    \"mybuild.xml\",                    \"-Dproperty=value\",                    \"-Dproperty1=value1\",                    \"-projecthelp\",                    \"compile\",                    \"docs\" });        // check properties        assertEquals(2, line.getProperties().size());        assertEquals(\"value\", line.getProperty(\"property\"));        assertEquals(\"value1\", line.getProperty(\"property1\"));        // check single values        assertEquals(\"mybuild.xml\", line.getValue(\"-buildfile\"));        assertTrue(line.hasOption(\"-projecthelp\"));        assertFalse(line.hasOption(\"-help\"));        assertTrue(line.hasOption(\"target\"));        final List targets = new ArrayList();        targets.add(\"compile\");        targets.add(\"docs\");        assertEquals(targets, line.getValues(\"target\"));    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.PropertyOption;\n+\n+//TODO Build up AntTest like CpTest\n+public class AntTest extends TestCase {\n+    public void testAnt() throws OptionException {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Group options =\n+            gbuilder\n+                .withName(\"ant\")\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"help\")\n+                        .withDescription(\"print this message\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"projecthelp\")\n+                        .withDescription(\"print project help information\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"version\")\n+                        .withDescription(\"print the version information and exit\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"diagnostics\")\n+                        .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"quiet\")\n+                        .withShortName(\"q\")\n+                        .withDescription(\"be extra quiet\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"verbose\")\n+                        .withShortName(\"v\")\n+                        .withDescription(\"be extra verbose\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"debug\")\n+                        .withDescription(\"print debugging information\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"emacs\")\n+                        .withDescription(\"produce logging information without adornments\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"logfile\")\n+                        .withShortName(\"l\")\n+                        .withDescription(\"use given file for log\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"file\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"logger\")\n+                        .withDescription(\"the class which is to perform logging\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"classname\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"listener\")\n+                        .withDescription(\"add an instance of class as a project listener\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"classname\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"buildfile\")\n+                        .withShortName(\"file\")\n+                        .withShortName(\"f\")\n+                        .withDescription(\"use given buildfile\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"file\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(PropertyOption.INSTANCE)\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"propertyfile\")\n+                        .withDescription(\"load all properties from file with -D properties taking precedence\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"name\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"inputhandler\")\n+                        .withDescription(\"the class which will handle input requests\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"class\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"find\")\n+                        .withDescription(\"search for buildfile towards the root of the filesystem and use it\")\n+                        .withArgument(\n+                            abuilder\n+                                .withName(\"file\")\n+                                .withMinimum(1)\n+                                .withMaximum(1)\n+                                .create())\n+                        .create())\n+                .withOption(abuilder.withName(\"target\").create())\n+                .create();\n+\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        CommandLine line =\n+            parser.parse(\n+                new String[] {\n+                    \"-buildfile\",\n+                    \"mybuild.xml\",\n+                    \"-Dproperty=value\",\n+                    \"-Dproperty1=value1\",\n+                    \"-projecthelp\",\n+                    \"compile\",\n+                    \"docs\" });\n+\n+        // check properties\n+        assertEquals(2, line.getProperties().size());\n+        assertEquals(\"value\", line.getProperty(\"property\"));\n+        assertEquals(\"value1\", line.getProperty(\"property1\"));\n+\n+        // check single values\n+        assertEquals(\"mybuild.xml\", line.getValue(\"-buildfile\"));\n+        assertTrue(line.hasOption(\"-projecthelp\"));\n+        assertFalse(line.hasOption(\"-help\"));\n+\n+        assertTrue(line.hasOption(\"target\"));\n+        final List targets = new ArrayList();\n+        targets.add(\"compile\");\n+        targets.add(\"docs\");\n+        assertEquals(targets, line.getValues(\"target\"));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/application/CpTest.java\n+++ b/src/test/org/apache/commons/cli2/application/CpTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.application;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.io.StringReader;import java.io.StringWriter;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.option.ArgumentImpl;import org.apache.commons.cli2.option.SourceDestArgument;import org.apache.commons.cli2.util.HelpFormatter;/** * <p>Test the <code>cp</code> command. Duplicated Option types are not * tested e.g. -a and -d are the same Option type.</p> * * <p>The following is the man output for 'cp'. See * <a href=\"http://www.rt.com/man/cp.1.html\">http://www.rt.com/man/cp.1.html</a>.</p> * * <pre> *  CP(1) FSF CP(1) * *  NAME cp - copy files and directories * *  SYNOPSIS cp [OPTION]... SOURCE DEST cp [OPTION]... SOURCE... DIRECTORY * *  DESCRIPTION Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY. * *  -a, --archive same as -dpR * *  -b, --backup make backup before removal * *  -d, --no-dereference preserve links * *  -f, --force remove existing destinations, never prompt * *  -i, --interactive prompt before overwrite * *  -l, --link link files instead of copying * *  -p, --preserve preserve file attributes if possible * *  -P, --parents append source path to DIRECTORY * -r copy recursively, non-directories as files * *  --sparse=WHEN control creation of sparse files * *  -R, --recursive copy directories recursively * *  -s, --symbolic-link make symbolic links instead of copying * *  -S, --suffix=SUFFIX override the usual backup suffix * *  -u, --update copy only when the SOURCE file is newer than the destination file or when the destination file is missing * *  -v, --verbose explain what is being done * *  -V, --version-control=WORD override the usual version control * *  -x, --one-file-system stay on this file system * *  --help display this help and exit * *  --version output version information and exit * *  By default, sparse SOURCE files are detected by a crude heuristic and the corresponding DEST file is made sparse as well. That is the behavior selected by --sparse=auto. Specify --sparse=always to create a sparse DEST file when- ever the SOURCE file contains a long enough sequence of zero bytes. Use --sparse=never to inhibit creation of sparse files. * *  The backup suffix is ~, unless set with SIMPLE_BACKUP_SUF- FIX. The version control may be set with VERSION_CONTROL, values are: * t, numbered make numbered backups * *  nil, existing numbered if numbered backups exist, simple other- wise * *  never, simple always make simple backups * *  As a special case, cp makes a backup of SOURCE when the force and backup options are given and SOURCE and DEST are the same name for an existing, regular file. * </pre> * </pre> * * @author Rob Oxspring * @author John Keyes */public class CpTest extends TestCase {    /** Option Builder */    private static final DefaultOptionBuilder oBuilder =        new DefaultOptionBuilder();    /** Argument Builder */    private static final ArgumentBuilder aBuilder = new ArgumentBuilder();    /** Group Builder */    private static final GroupBuilder gBuilder = new GroupBuilder();    private Group options;    public static Test suite() {        return new TestSuite(CpTest.class);    }    private ArgumentImpl source;    private ArgumentImpl dest;    private Argument targets;    private Option archive;    private Option backup;    private Option noDereference;    private Option force;    private Option interactive;    private Option link;    private Option preserve;    private Option parents;    private Option recursive1;    private Option sparse;    private Option recursive2;    private Option symbolicLink;    private Option suffix;    private Option update;    private Option verbose;    private Option versionControl;    private Option oneFileSystem;    private Option help;    private Option version;    public void setUp() {        source =            (ArgumentImpl)aBuilder.withName(\"SOURCE\").withMinimum(1).create();        dest =            (ArgumentImpl)aBuilder                .withName(\"DEST\")                .withMinimum(1)                .withMaximum(1)                .create();        targets = new SourceDestArgument(source, dest);        archive =            oBuilder                .withShortName(\"a\")                .withLongName(\"archive\")                .withDescription(\"same as -dpR\")                .create();        backup =            oBuilder                .withShortName(\"b\")                .withLongName(\"backup\")                .withDescription(\"make backup before removal\")                .create();        noDereference =            oBuilder                .withShortName(\"d\")                .withLongName(\"no-dereference\")                .withDescription(\"preserve links\")                .create();        force =            oBuilder                .withShortName(\"f\")                .withLongName(\"force\")                .withDescription(\"remove existing destinations, never prompt\")                .create();        interactive =            oBuilder                .withShortName(\"i\")                .withLongName(\"interactive\")                .withDescription(\"prompt before overwrite\")                .create();        link =            oBuilder                .withShortName(\"l\")                .withLongName(\"link\")                .withDescription(\"link files instead of copying\")                .create();        preserve =            oBuilder                .withShortName(\"p\")                .withLongName(\"preserve\")                .withDescription(\"preserve file attributes if possible\")                .create();        parents =            oBuilder                .withShortName(\"P\")                .withLongName(\"parents\")                .withDescription(\"append source path to DIRECTORY\")                .create();        recursive1 =            oBuilder                .withShortName(\"r\")                .withDescription(\"copy recursively, non-directories as files\")                .create();        sparse =            oBuilder                .withLongName(\"sparse\")                .withDescription(\"control creation of sparse files\")                .withArgument(                    aBuilder                        .withName(\"WHEN\")                        .withMinimum(1)                        .withMaximum(1)                        .withInitialSeparator('=')                        .create())                .create();        recursive2 =            oBuilder                .withShortName(\"R\")                .withLongName(\"recursive\")                .withDescription(\"copy directories recursively\")                .create();        symbolicLink =            oBuilder                .withShortName(\"s\")                .withLongName(\"symbolic-link\")                .withDescription(\"make symbolic links instead of copying\")                .create();        suffix =            oBuilder                .withShortName(\"S\")                .withLongName(\"suffix\")                .withDescription(\"override the usual backup suffix\")                .withArgument(                    aBuilder                        .withName(\"SUFFIX\")                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        update =            oBuilder                .withShortName(\"u\")                .withLongName(\"update\")                .withDescription(\"copy only when the SOURCE file is newer than the destination file or when the destination file is missing\")                .create();        verbose =            oBuilder                .withShortName(\"v\")                .withLongName(\"verbose\")                .withDescription(\"explain what is being done\")                .create();        versionControl =            oBuilder                .withShortName(\"V\")                .withLongName(\"version-contol\")                .withDescription(\"explain what is being done\")                .withArgument(                    aBuilder                        .withName(\"WORD\")                        .withInitialSeparator('=')                        .withMinimum(1)                        .withMaximum(1)                        .create())                .create();        oneFileSystem =            oBuilder                .withShortName(\"x\")                .withLongName(\"one-file-system\")                .withDescription(\"stay on this file system\")                .create();        help =            oBuilder                .withLongName(\"help\")                .withDescription(\"display this help and exit\")                .create();        version =            oBuilder                .withLongName(\"version\")                .withDescription(\"output version information and exit\")                .create();        options =            gBuilder                .withOption(archive)                .withOption(backup)                .withOption(noDereference)                .withOption(force)                .withOption(interactive)                .withOption(link)                .withOption(preserve)                .withOption(parents)                .withOption(recursive1)                .withOption(sparse)                .withOption(recursive2)                .withOption(symbolicLink)                .withOption(suffix)                .withOption(update)                .withOption(verbose)                .withOption(versionControl)                .withOption(oneFileSystem)                .withOption(help)                .withOption(version)                .withOption(targets)                .withName(\"OPTIONS\")                .create();    }    public void testNoSource() {        Parser parser = new Parser();        parser.setGroup(options);        try {            parser.parse(new String[0]);        }        catch (OptionException mve) {            assertEquals(                \"Missing value(s) SOURCE [SOURCE ...]\",                mve.getMessage());        }    }    public void testOneSource() throws OptionException {        final String[] args = new String[] { \"source1\", \"dest1\" };        final Parser parser = new Parser();        parser.setGroup(options);        final CommandLine commandLine = parser.parse(args);        assertTrue(commandLine.getValues(source).contains(\"source1\"));        assertEquals(1, commandLine.getValues(source).size());        assertTrue(commandLine.getValues(dest).contains(\"dest1\"));        assertEquals(1, commandLine.getValues(dest).size());    }    public void testMultiSource() throws OptionException {        final String[] args =            new String[] { \"source1\", \"source2\", \"source3\", \"dest1\" };        final Parser parser = new Parser();        parser.setGroup(options);        final CommandLine commandLine = parser.parse(args);        assertTrue(commandLine.getValues(source).contains(\"source1\"));        assertTrue(commandLine.getValues(source).contains(\"source2\"));        assertTrue(commandLine.getValues(source).contains(\"source3\"));        assertEquals(3, commandLine.getValues(source).size());        assertTrue(commandLine.getValues(dest).contains(\"dest1\"));        assertEquals(1, commandLine.getValues(dest).size());    }    public void testHelp() throws IOException {        final StringWriter out = new StringWriter();        final HelpFormatter helpFormatter = new HelpFormatter();        helpFormatter.setGroup(options);        helpFormatter.setPrintWriter(new PrintWriter(out));        helpFormatter.print();        final BufferedReader in =            new BufferedReader(new StringReader(out.toString()));        assertEquals(            \"Usage:                                                                          \",            in.readLine());        assertEquals(            \" [-a -b -d -f -i -l -p -P -r --sparse <WHEN> -R -s -S <SUFFIX> -u -v -V <WORD>  \",            in.readLine());        assertEquals(            \"-x --help --version] <SOURCE1> [<SOURCE2> ...] <DEST>                           \",            in.readLine());        assertEquals(            \"OPTIONS                                                                         \",            in.readLine());        assertEquals(            \"  -a (--archive)                same as -dpR                                    \",            in.readLine());        assertEquals(            \"  -b (--backup)                 make backup before removal                      \",            in.readLine());        assertEquals(            \"  -d (--no-dereference)         preserve links                                  \",            in.readLine());        assertEquals(            \"  -f (--force)                  remove existing destinations, never prompt      \",            in.readLine());        assertEquals(            \"  -i (--interactive)            prompt before overwrite                         \",            in.readLine());        assertEquals(            \"  -l (--link)                   link files instead of copying                   \",            in.readLine());        assertEquals(            \"  -p (--preserve)               preserve file attributes if possible            \",            in.readLine());        assertEquals(            \"  -P (--parents)                append source path to DIRECTORY                 \",            in.readLine());        assertEquals(            \"  -r                            copy recursively, non-directories as files      \",            in.readLine());        assertEquals(            \"  --sparse WHEN                 control creation of sparse files                \",            in.readLine());        assertEquals(            \"  -R (--recursive)              copy directories recursively                    \",            in.readLine());        assertEquals(            \"  -s (--symbolic-link)          make symbolic links instead of copying          \",            in.readLine());        assertEquals(            \"  -S (--suffix) SUFFIX          override the usual backup suffix                \",            in.readLine());        assertEquals(            \"  -u (--update)                 copy only when the SOURCE file is newer than    \",            in.readLine());        assertEquals(            \"                                the destination file or when the destination    \",            in.readLine());        assertEquals(            \"                                file is missing                                 \",            in.readLine());        assertEquals(            \"  -v (--verbose)                explain what is being done                      \",            in.readLine());        assertEquals(            \"  -V (--version-contol) WORD    explain what is being done                      \",            in.readLine());        assertEquals(            \"  -x (--one-file-system)        stay on this file system                        \",            in.readLine());        assertEquals(            \"  --help                        display this help and exit                      \",            in.readLine());        assertEquals(            \"  --version                     output version information and exit             \",            in.readLine());        assertEquals(            \"  SOURCE [SOURCE ...]                                                           \",            in.readLine());        assertEquals(            \"  DEST                                                                          \",            in.readLine());        assertNull(in.readLine());    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.ArgumentImpl;\n+import org.apache.commons.cli2.option.SourceDestArgument;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+/**\n+ * <p>Test the <code>cp</code> command. Duplicated Option types are not\n+ * tested e.g. -a and -d are the same Option type.</p>\n+ * \n+ * <p>The following is the man output for 'cp'. See\n+ * <a href=\"http://www.rt.com/man/cp.1.html\">http://www.rt.com/man/cp.1.html</a>.</p>\n+ * \n+ * <pre>\n+ *  CP(1) FSF CP(1)\n+ * \n+ *  NAME cp - copy files and directories\n+ * \n+ *  SYNOPSIS cp [OPTION]... SOURCE DEST cp [OPTION]... SOURCE... DIRECTORY\n+ * \n+ *  DESCRIPTION Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n+ * \n+ *  -a, --archive same as -dpR\n+ * \n+ *  -b, --backup make backup before removal\n+ * \n+ *  -d, --no-dereference preserve links\n+ * \n+ *  -f, --force remove existing destinations, never prompt\n+ * \n+ *  -i, --interactive prompt before overwrite\n+ * \n+ *  -l, --link link files instead of copying\n+ * \n+ *  -p, --preserve preserve file attributes if possible\n+ * \n+ *  -P, --parents append source path to DIRECTORY\n+ * -r copy recursively, non-directories as files\n+ * \n+ *  --sparse=WHEN control creation of sparse files\n+ * \n+ *  -R, --recursive copy directories recursively\n+ * \n+ *  -s, --symbolic-link make symbolic links instead of copying\n+ * \n+ *  -S, --suffix=SUFFIX override the usual backup suffix\n+ * \n+ *  -u, --update copy only when the SOURCE file is newer than the destination file or when the destination file is missing\n+ * \n+ *  -v, --verbose explain what is being done\n+ * \n+ *  -V, --version-control=WORD override the usual version control\n+ * \n+ *  -x, --one-file-system stay on this file system\n+ * \n+ *  --help display this help and exit\n+ * \n+ *  --version output version information and exit\n+ * \n+ *  By default, sparse SOURCE files are detected by a crude heuristic and the corresponding DEST file is made sparse as well. That is the behavior selected by --sparse=auto. Specify --sparse=always to create a sparse DEST file when- ever the SOURCE file contains a long enough sequence of zero bytes. Use --sparse=never to inhibit creation of sparse files.\n+ * \n+ *  The backup suffix is ~, unless set with SIMPLE_BACKUP_SUF- FIX. The version control may be set with VERSION_CONTROL, values are:\n+ * t, numbered make numbered backups\n+ * \n+ *  nil, existing numbered if numbered backups exist, simple other- wise\n+ * \n+ *  never, simple always make simple backups\n+ * \n+ *  As a special case, cp makes a backup of SOURCE when the force and backup options are given and SOURCE and DEST are the same name for an existing, regular file. * </pre>\n+ * </pre>\n+ * \n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class CpTest extends TestCase {\n+\n+    /** Option Builder */\n+    private static final DefaultOptionBuilder oBuilder =\n+        new DefaultOptionBuilder();\n+\n+    /** Argument Builder */\n+    private static final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+    /** Group Builder */\n+    private static final GroupBuilder gBuilder = new GroupBuilder();\n+\n+    private Group options;\n+\n+    public static Test suite() {\n+        return new TestSuite(CpTest.class);\n+    }\n+\n+    private ArgumentImpl source;\n+    private ArgumentImpl dest;\n+    private Argument targets;\n+\n+    private Option archive;\n+    private Option backup;\n+    private Option noDereference;\n+    private Option force;\n+    private Option interactive;\n+    private Option link;\n+    private Option preserve;\n+    private Option parents;\n+    private Option recursive1;\n+    private Option sparse;\n+    private Option recursive2;\n+    private Option symbolicLink;\n+    private Option suffix;\n+    private Option update;\n+    private Option verbose;\n+    private Option versionControl;\n+    private Option oneFileSystem;\n+    private Option help;\n+    private Option version;\n+\n+    public void setUp() {\n+        source =\n+            (ArgumentImpl)aBuilder.withName(\"SOURCE\").withMinimum(1).create();\n+        dest =\n+            (ArgumentImpl)aBuilder\n+                .withName(\"DEST\")\n+                .withMinimum(1)\n+                .withMaximum(1)\n+                .create();\n+        targets = new SourceDestArgument(source, dest);\n+\n+        archive =\n+            oBuilder\n+                .withShortName(\"a\")\n+                .withLongName(\"archive\")\n+                .withDescription(\"same as -dpR\")\n+                .create();\n+\n+        backup =\n+            oBuilder\n+                .withShortName(\"b\")\n+                .withLongName(\"backup\")\n+                .withDescription(\"make backup before removal\")\n+                .create();\n+\n+        noDereference =\n+            oBuilder\n+                .withShortName(\"d\")\n+                .withLongName(\"no-dereference\")\n+                .withDescription(\"preserve links\")\n+                .create();\n+\n+        force =\n+            oBuilder\n+                .withShortName(\"f\")\n+                .withLongName(\"force\")\n+                .withDescription(\"remove existing destinations, never prompt\")\n+                .create();\n+\n+        interactive =\n+            oBuilder\n+                .withShortName(\"i\")\n+                .withLongName(\"interactive\")\n+                .withDescription(\"prompt before overwrite\")\n+                .create();\n+\n+        link =\n+            oBuilder\n+                .withShortName(\"l\")\n+                .withLongName(\"link\")\n+                .withDescription(\"link files instead of copying\")\n+                .create();\n+\n+        preserve =\n+            oBuilder\n+                .withShortName(\"p\")\n+                .withLongName(\"preserve\")\n+                .withDescription(\"preserve file attributes if possible\")\n+                .create();\n+\n+        parents =\n+            oBuilder\n+                .withShortName(\"P\")\n+                .withLongName(\"parents\")\n+                .withDescription(\"append source path to DIRECTORY\")\n+                .create();\n+\n+        recursive1 =\n+            oBuilder\n+                .withShortName(\"r\")\n+                .withDescription(\"copy recursively, non-directories as files\")\n+                .create();\n+\n+        sparse =\n+            oBuilder\n+                .withLongName(\"sparse\")\n+                .withDescription(\"control creation of sparse files\")\n+                .withArgument(\n+                    aBuilder\n+                        .withName(\"WHEN\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .withInitialSeparator('=')\n+                        .create())\n+                .create();\n+\n+        recursive2 =\n+            oBuilder\n+                .withShortName(\"R\")\n+                .withLongName(\"recursive\")\n+                .withDescription(\"copy directories recursively\")\n+                .create();\n+\n+        symbolicLink =\n+            oBuilder\n+                .withShortName(\"s\")\n+                .withLongName(\"symbolic-link\")\n+                .withDescription(\"make symbolic links instead of copying\")\n+                .create();\n+\n+        suffix =\n+            oBuilder\n+                .withShortName(\"S\")\n+                .withLongName(\"suffix\")\n+                .withDescription(\"override the usual backup suffix\")\n+                .withArgument(\n+                    aBuilder\n+                        .withName(\"SUFFIX\")\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+\n+        update =\n+            oBuilder\n+                .withShortName(\"u\")\n+                .withLongName(\"update\")\n+                .withDescription(\"copy only when the SOURCE file is newer than the destination file or when the destination file is missing\")\n+                .create();\n+\n+        verbose =\n+            oBuilder\n+                .withShortName(\"v\")\n+                .withLongName(\"verbose\")\n+                .withDescription(\"explain what is being done\")\n+                .create();\n+\n+        versionControl =\n+            oBuilder\n+                .withShortName(\"V\")\n+                .withLongName(\"version-contol\")\n+                .withDescription(\"explain what is being done\")\n+                .withArgument(\n+                    aBuilder\n+                        .withName(\"WORD\")\n+                        .withInitialSeparator('=')\n+                        .withMinimum(1)\n+                        .withMaximum(1)\n+                        .create())\n+                .create();\n+\n+        oneFileSystem =\n+            oBuilder\n+                .withShortName(\"x\")\n+                .withLongName(\"one-file-system\")\n+                .withDescription(\"stay on this file system\")\n+                .create();\n+\n+        help =\n+            oBuilder\n+                .withLongName(\"help\")\n+                .withDescription(\"display this help and exit\")\n+                .create();\n+\n+        version =\n+            oBuilder\n+                .withLongName(\"version\")\n+                .withDescription(\"output version information and exit\")\n+                .create();\n+\n+        options =\n+            gBuilder\n+                .withOption(archive)\n+                .withOption(backup)\n+                .withOption(noDereference)\n+                .withOption(force)\n+                .withOption(interactive)\n+                .withOption(link)\n+                .withOption(preserve)\n+                .withOption(parents)\n+                .withOption(recursive1)\n+                .withOption(sparse)\n+                .withOption(recursive2)\n+                .withOption(symbolicLink)\n+                .withOption(suffix)\n+                .withOption(update)\n+                .withOption(verbose)\n+                .withOption(versionControl)\n+                .withOption(oneFileSystem)\n+                .withOption(help)\n+                .withOption(version)\n+                .withOption(targets)\n+                .withName(\"OPTIONS\")\n+                .create();\n+    }\n+\n+    public void testNoSource() {\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        try {\n+            parser.parse(new String[0]);\n+        }\n+        catch (OptionException mve) {\n+            assertEquals(\n+                \"Missing value(s) SOURCE [SOURCE ...]\",\n+                mve.getMessage());\n+        }\n+    }\n+\n+    public void testOneSource() throws OptionException {\n+        final String[] args = new String[] { \"source1\", \"dest1\" };\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+        final CommandLine commandLine = parser.parse(args);\n+\n+        assertTrue(commandLine.getValues(source).contains(\"source1\"));\n+        assertEquals(1, commandLine.getValues(source).size());\n+        assertTrue(commandLine.getValues(dest).contains(\"dest1\"));\n+        assertEquals(1, commandLine.getValues(dest).size());\n+    }\n+\n+    public void testMultiSource() throws OptionException {\n+        final String[] args =\n+            new String[] { \"source1\", \"source2\", \"source3\", \"dest1\" };\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+        final CommandLine commandLine = parser.parse(args);\n+\n+        assertTrue(commandLine.getValues(source).contains(\"source1\"));\n+        assertTrue(commandLine.getValues(source).contains(\"source2\"));\n+        assertTrue(commandLine.getValues(source).contains(\"source3\"));\n+        assertEquals(3, commandLine.getValues(source).size());\n+\n+        assertTrue(commandLine.getValues(dest).contains(\"dest1\"));\n+        assertEquals(1, commandLine.getValues(dest).size());\n+    }\n+\n+    public void testHelp() throws IOException {\n+        final StringWriter out = new StringWriter();\n+        final HelpFormatter helpFormatter = new HelpFormatter();\n+        helpFormatter.setGroup(options);\n+        helpFormatter.setPrintWriter(new PrintWriter(out));\n+        helpFormatter.print();\n+\n+        final BufferedReader in =\n+            new BufferedReader(new StringReader(out.toString()));\n+        assertEquals(\n+            \"Usage:                                                                          \",\n+            in.readLine());\n+        assertEquals(\n+            \" [-a -b -d -f -i -l -p -P -r --sparse <WHEN> -R -s -S <SUFFIX> -u -v -V <WORD>  \",\n+            in.readLine());\n+        assertEquals(\n+            \"-x --help --version] <SOURCE1> [<SOURCE2> ...] <DEST>                           \",\n+            in.readLine());\n+        assertEquals(\n+            \"OPTIONS                                                                         \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -a (--archive)                same as -dpR                                    \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -b (--backup)                 make backup before removal                      \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -d (--no-dereference)         preserve links                                  \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -f (--force)                  remove existing destinations, never prompt      \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -i (--interactive)            prompt before overwrite                         \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -l (--link)                   link files instead of copying                   \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -p (--preserve)               preserve file attributes if possible            \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -P (--parents)                append source path to DIRECTORY                 \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -r                            copy recursively, non-directories as files      \",\n+            in.readLine());\n+        assertEquals(\n+            \"  --sparse WHEN                 control creation of sparse files                \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -R (--recursive)              copy directories recursively                    \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -s (--symbolic-link)          make symbolic links instead of copying          \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -S (--suffix) SUFFIX          override the usual backup suffix                \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -u (--update)                 copy only when the SOURCE file is newer than    \",\n+            in.readLine());\n+        assertEquals(\n+            \"                                the destination file or when the destination    \",\n+            in.readLine());\n+        assertEquals(\n+            \"                                file is missing                                 \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -v (--verbose)                explain what is being done                      \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -V (--version-contol) WORD    explain what is being done                      \",\n+            in.readLine());\n+        assertEquals(\n+            \"  -x (--one-file-system)        stay on this file system                        \",\n+            in.readLine());\n+        assertEquals(\n+            \"  --help                        display this help and exit                      \",\n+            in.readLine());\n+        assertEquals(\n+            \"  --version                     output version information and exit             \",\n+            in.readLine());\n+        assertEquals(\n+            \"  SOURCE [SOURCE ...]                                                           \",\n+            in.readLine());\n+        assertEquals(\n+            \"  DEST                                                                          \",\n+            in.readLine());\n+        assertNull(in.readLine());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/application/CvsTest.java\n+++ b/src/test/org/apache/commons/cli2/application/CvsTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.application;import junit.framework.TestCase;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.CommandBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.option.ArgumentTest;//TODO Build up CvsTest like CpTestpublic class CvsTest extends TestCase {    public void testCVS() {        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        final ArgumentBuilder abuilder = new ArgumentBuilder();        final CommandBuilder cbuilder = new CommandBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Group commands =            gbuilder                .withName(\"commands\")                .withOption(                    cbuilder                        .withName(\"add\")                        .withName(\"ad\")                        .withName(\"new\")                        .withDescription(\"Add a new file/directory to the repository\")                        .create())                .withOption(                    cbuilder                        .withName(\"admin\")                        .withName(\"adm\")                        .withName(\"rcs\")                        .withDescription(\"Administration front end for rcs\")                        .create())                .withOption(                    cbuilder                        .withName(\"annotate\")                        .withName(\"ann\")                        .withDescription(\"Show last revision where each line was modified\")                        .create())                .withOption(                    cbuilder                        .withName(\"checkout\")                        .withName(\"co\")                        .withName(\"get\")                        .withDescription(\"Checkout sources for editing\")                        .create())                .withOption(                    cbuilder                        .withName(\"commit\")                        .withName(\"ci\")                        .withName(\"com\")                        .withDescription(\"Check files into the repository\")                        .create())                .withOption(                    cbuilder                        .withName(\"diff\")                        .withName(\"di\")                        .withName(\"dif\")                        .withDescription(\"Show differences between revisions\")                        .create())                .withOption(                    cbuilder                        .withName(\"edit\")                        .withDescription(\"Get ready to edit a watched file\")                        .create())                .withOption(                    cbuilder                        .withName(\"editors\")                        .withDescription(\"See who is editing a watched file\")                        .create())                .withOption(                    cbuilder                        .withName(\"export\")                        .withName(\"exp\")                        .withName(\"ex\")                        .withDescription(\"Export sources from CVS, similar to checkout\")                        .create())                .withOption(                    cbuilder                        .withName(\"history\")                        .withName(\"hi\")                        .withName(\"his\")                        .withDescription(\"Show repository access history\")                        .create())                .withOption(                    cbuilder                        .withName(\"import\")                        .withName(\"im\")                        .withName(\"imp\")                        .withDescription(\"Import sources into CVS, using vendor branches\")                        .create())                .withOption(                    cbuilder                        .withName(\"init\")                        .withDescription(\"Create a CVS repository if it doesn't exist\")                        .create())                .withOption(                    cbuilder                        .withName(\"log\")                        .withName(\"lo\")                        .withName(\"rlog\")                        .withDescription(\"Print out history information for files\")                        .create())                .withOption(                    cbuilder                        .withName(\"login\")                        .withName(\"logon\")                        .withName(\"lgn\")                        .withDescription(\"Prompt for password for authenticating server\")                        .create())                .withOption(                    cbuilder                        .withName(\"logout\")                        .withDescription(\"Removes entry in .cvspass for remote repository\")                        .create())                .withOption(                    cbuilder                        .withName(\"rdiff\")                        .withName(\"patch\")                        .withName(\"pa\")                        .withDescription(\"Create 'patch' format diffs between releases\")                        .create())                .withOption(                    cbuilder                        .withName(\"release\")                        .withName(\"re\")                        .withName(\"rel\")                        .withDescription(\"Indicate that a Module is no longer in use\")                        .create())                .withOption(                    cbuilder                        .withName(\"remove\")                        .withName(\"rm\")                        .withName(\"delete\")                        .withDescription(\"Remove an entry from the repository\")                        .create())                .withOption(                    cbuilder                        .withName(\"rtag\")                        .withName(\"rt\")                        .withName(\"rfreeze\")                        .withDescription(\"Add a symbolic tag to a module\")                        .create())                .withOption(                    cbuilder                        .withName(\"status\")                        .withName(\"st\")                        .withName(\"stat\")                        .withDescription(\"Display status information on checked out files\")                        .create())                .withOption(                    cbuilder                        .withName(\"tag\")                        .withName(\"ta\")                        .withName(\"freeze\")                        .withDescription(\"Add a symbolic tag to checked out version of files\")                        .create())                .withOption(                    cbuilder                        .withName(\"unedit\")                        .withDescription(\"Undo an edit command\")                        .create())                .withOption(                    cbuilder                        .withName(\"update\")                        .withName(\"up\")                        .withName(\"upd\")                        .withDescription(\"Bring work tree in sync with repository\")                        .create())                .withOption(                    cbuilder                        .withName(\"watch\")                        .withDescription(\"Set watches\")                        .create())                .withOption(                    cbuilder                        .withName(\"watchers\")                        .withDescription(\"See who is watching a file\")                        .create())                .withOption(                    cbuilder                        .withName(\"version\")                        .withName(\"ve\")                        .withName(\"ver\")                        .withDescription(\"????\")                        .create())                .withOption(ArgumentTest.buildTargetsArgument())                .create();        final Group cvsOptions =            new GroupBuilder()                .withName(\"cvs-options\")                .withOption(                    obuilder                        .withShortName(\"H\")                        .withDescription(\"Displays usage information for command.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"Q\")                        .withDescription(\"Cause CVS to be really quiet.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"q\")                        .withDescription(\"Cause CVS to be somewhat quiet.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"r\")                        .withDescription(\"Make checked-out files read-only.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"w\")                        .withDescription(\"Make checked-out files read-write (default).\")                        .create())                .withOption(                    obuilder                        .withShortName(\"l\")                        .withDescription(\"Turn history logging off.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"n\")                        .withDescription(\"Do not execute anything that will change the disk.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"t\")                        .withDescription(\"Show trace of program execution -- try with -n.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"v\")                        .withDescription(\"CVS version and copyright.\")                        .create())                .withOption(                    obuilder                        .withLongName(\"crlf\")                        .withDescription(\"Use the Dos line feed for text files (default).\")                        .create())                .withOption(                    obuilder                        .withLongName(\"lf\")                        .withDescription(\"Use the Unix line feed for text files.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"T\")                        .withDescription(\"Use 'tmpdir' for temporary files.\")                        .withArgument(abuilder.withName(\"tmpdir\").create())                        .create())                .withOption(                    obuilder                        .withShortName(\"e\")                        .withDescription(\"Use 'editor' for editing log information.\")                        .withArgument(abuilder.withName(\"editor\").create())                        .create())                .withOption(                    obuilder                        .withShortName(\"d\")                        .withDescription(\"Overrides $CVSROOT as the root of the CVS tree.\")                        .withArgument(abuilder.withName(\"CVS_root\").create())                        .create())                .withOption(                    obuilder                        .withShortName(\"f\")                        .withDescription(\"Do not use the ~/.cvsrc file.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"z\")                        .withDescription(\"Use compression level '#' for net traffic.\")                        .withArgument(abuilder.withName(\"#\").create())                        .create())                .withOption(                    obuilder                        .withShortName(\"a\")                        .withDescription(\"Authenticate all net traffic.\")                        .create())                .withOption(                    obuilder                        .withShortName(\"s\")                        .withDescription(\"Set CVS user variable.\")                        .withArgument(abuilder.withName(\"VAR=VAL\").create())                        .create())                .withOption(commands)                .create();        assertNotNull(cvsOptions);    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.CommandBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.option.ArgumentTest;\n+\n+//TODO Build up CvsTest like CpTest\n+public class CvsTest extends TestCase {\n+    public void testCVS() {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final CommandBuilder cbuilder = new CommandBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Group commands =\n+            gbuilder\n+                .withName(\"commands\")\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"add\")\n+                        .withName(\"ad\")\n+                        .withName(\"new\")\n+                        .withDescription(\"Add a new file/directory to the repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"admin\")\n+                        .withName(\"adm\")\n+                        .withName(\"rcs\")\n+                        .withDescription(\"Administration front end for rcs\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"annotate\")\n+                        .withName(\"ann\")\n+                        .withDescription(\"Show last revision where each line was modified\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"checkout\")\n+                        .withName(\"co\")\n+                        .withName(\"get\")\n+                        .withDescription(\"Checkout sources for editing\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"commit\")\n+                        .withName(\"ci\")\n+                        .withName(\"com\")\n+                        .withDescription(\"Check files into the repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"diff\")\n+                        .withName(\"di\")\n+                        .withName(\"dif\")\n+                        .withDescription(\"Show differences between revisions\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"edit\")\n+                        .withDescription(\"Get ready to edit a watched file\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"editors\")\n+                        .withDescription(\"See who is editing a watched file\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"export\")\n+                        .withName(\"exp\")\n+                        .withName(\"ex\")\n+                        .withDescription(\"Export sources from CVS, similar to checkout\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"history\")\n+                        .withName(\"hi\")\n+                        .withName(\"his\")\n+                        .withDescription(\"Show repository access history\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"import\")\n+                        .withName(\"im\")\n+                        .withName(\"imp\")\n+                        .withDescription(\"Import sources into CVS, using vendor branches\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"init\")\n+                        .withDescription(\"Create a CVS repository if it doesn't exist\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"log\")\n+                        .withName(\"lo\")\n+                        .withName(\"rlog\")\n+                        .withDescription(\"Print out history information for files\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"login\")\n+                        .withName(\"logon\")\n+                        .withName(\"lgn\")\n+                        .withDescription(\"Prompt for password for authenticating server\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"logout\")\n+                        .withDescription(\"Removes entry in .cvspass for remote repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"rdiff\")\n+                        .withName(\"patch\")\n+                        .withName(\"pa\")\n+                        .withDescription(\"Create 'patch' format diffs between releases\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"release\")\n+                        .withName(\"re\")\n+                        .withName(\"rel\")\n+                        .withDescription(\"Indicate that a Module is no longer in use\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"remove\")\n+                        .withName(\"rm\")\n+                        .withName(\"delete\")\n+                        .withDescription(\"Remove an entry from the repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"rtag\")\n+                        .withName(\"rt\")\n+                        .withName(\"rfreeze\")\n+                        .withDescription(\"Add a symbolic tag to a module\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"status\")\n+                        .withName(\"st\")\n+                        .withName(\"stat\")\n+                        .withDescription(\"Display status information on checked out files\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"tag\")\n+                        .withName(\"ta\")\n+                        .withName(\"freeze\")\n+                        .withDescription(\"Add a symbolic tag to checked out version of files\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"unedit\")\n+                        .withDescription(\"Undo an edit command\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"update\")\n+                        .withName(\"up\")\n+                        .withName(\"upd\")\n+                        .withDescription(\"Bring work tree in sync with repository\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"watch\")\n+                        .withDescription(\"Set watches\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"watchers\")\n+                        .withDescription(\"See who is watching a file\")\n+                        .create())\n+                .withOption(\n+                    cbuilder\n+                        .withName(\"version\")\n+                        .withName(\"ve\")\n+                        .withName(\"ver\")\n+                        .withDescription(\"????\")\n+                        .create())\n+                .withOption(ArgumentTest.buildTargetsArgument())\n+                .create();\n+\n+        final Group cvsOptions =\n+            new GroupBuilder()\n+                .withName(\"cvs-options\")\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"H\")\n+                        .withDescription(\"Displays usage information for command.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"Q\")\n+                        .withDescription(\"Cause CVS to be really quiet.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"q\")\n+                        .withDescription(\"Cause CVS to be somewhat quiet.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"r\")\n+                        .withDescription(\"Make checked-out files read-only.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"w\")\n+                        .withDescription(\"Make checked-out files read-write (default).\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"l\")\n+                        .withDescription(\"Turn history logging off.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"n\")\n+                        .withDescription(\"Do not execute anything that will change the disk.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"t\")\n+                        .withDescription(\"Show trace of program execution -- try with -n.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"v\")\n+                        .withDescription(\"CVS version and copyright.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withLongName(\"crlf\")\n+                        .withDescription(\"Use the Dos line feed for text files (default).\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withLongName(\"lf\")\n+                        .withDescription(\"Use the Unix line feed for text files.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"T\")\n+                        .withDescription(\"Use 'tmpdir' for temporary files.\")\n+                        .withArgument(abuilder.withName(\"tmpdir\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"e\")\n+                        .withDescription(\"Use 'editor' for editing log information.\")\n+                        .withArgument(abuilder.withName(\"editor\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"d\")\n+                        .withDescription(\"Overrides $CVSROOT as the root of the CVS tree.\")\n+                        .withArgument(abuilder.withName(\"CVS_root\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"f\")\n+                        .withDescription(\"Do not use the ~/.cvsrc file.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"z\")\n+                        .withDescription(\"Use compression level '#' for net traffic.\")\n+                        .withArgument(abuilder.withName(\"#\").create())\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"a\")\n+                        .withDescription(\"Authenticate all net traffic.\")\n+                        .create())\n+                .withOption(\n+                    obuilder\n+                        .withShortName(\"s\")\n+                        .withDescription(\"Set CVS user variable.\")\n+                        .withArgument(abuilder.withName(\"VAR=VAL\").create())\n+                        .create())\n+                .withOption(commands)\n+                .create();\n+\n+        assertNotNull(cvsOptions);\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/application/LsTest.java\n+++ b/src/test/org/apache/commons/cli2/application/LsTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.application;import java.util.HashSet;import java.util.Set;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.validation.EnumValidator;/** * <p>Test the <code>ls</code> command. Duplicated Option types are not * tested e.g. -a and -d are the same Option type.</p> * * <p>The following is the man output for 'ls'. See * <a href=\"http://www.rt.com/man/ls.1.html\">http://www.rt.com/man/ls.1.html</a>.</p> * * <pre> *  LS(1) FSF LS(1) * *  NAME ls - list directory contents * *  SYNOPSIS ls [OPTION]... [FILE]... * *  DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuSUX nor --sort. * *  -a, --all do not hide entries starting with . * *  -A, --almost-all do not list implied . and .. * *  -b, --escape print octal escapes for nongraphic characters * *  --block-size=SIZE use SIZE-byte blocks * *  -B, --ignore-backups do not list implied entries ending with ~ -c sort by change time; with -l: show ctime -C list entries by columns * *  --color[=WHEN] control whether color is used to distinguish file types. WHEN may be `never', `always', or `auto' * *  -d, --directory list directory entries instead of contents * *  -D, --dired generate output designed for Emacs' dired mode -f do not sort, enable -aU, disable -lst * *  -F, --classify append indicator (one of /=@|*) to entries * *  --format=WORD across -x, commas -m, horizontal -x, long -l, sin- gle-column -1, verbose -l, vertical -C * *  --full-time list both full date and full time -g (ignored) * *  -G, --no-group inhibit display of group information * *  -h, --human-readable print sizes in human readable format (e.g., 1K 234M 2G) * *  -H, --si likewise, but use powers of 1000 not 1024 * *  --indicator-style=WORD append indicator with style WORD to entry names: none (default), classify (-F), file-type (-p) * *  -i, --inode print index number of each file * *  -I, --ignore=PATTERN do not list implied entries matching shell PATTERN * *  -k, --kilobytes like --block-size=1024 -l use a long listing format * *  -L, --dereference list entries pointed to by symbolic links -m fill width with a comma separated list of entries * *  -n, --numeric-uid-gid list numeric UIDs and GIDs instead of names * *  -N, --literal print raw entry names (don't treat e.g. control characters specially) -o use long listing format without group info * *  -p, --file-type append indicator (one of /=@|) to entries * *  -q, --hide-control-chars print ? instead of non graphic characters * *  --show-control-chars show non graphic characters as-is (default) * *  -Q, --quote-name enclose entry names in double quotes * *  --quoting-style=WORD use quoting style WORD for entry names: literal, shell, shell-always, c, escape * *  -r, --reverse reverse order while sorting * *  -R, --recursive list subdirectories recursively * *  -s, --size print size of each file, in blocks -S sort by file size * *  --sort=WORD extension -X, none -U, size -S, time -t, version -v status -c, time -t, atime -u, access -u, use -u * *  --time=WORD show time as WORD instead of modification time: atime, access, use, ctime or status; use specified time as sort key if --sort=time -t sort by modification time * *  -T, --tabsize=COLS assume tab stops at each COLS instead of 8 -u sort by last access time; with -l: show atime -U do not sort; list entries in directory order -v sort by version * *  -w, --width=COLS assume screen width instead of current value -x list entries by lines instead of by columns -X sort alphabetically by entry extension -1 list one file per line * *  --help display this help and exit * *  --version output version information and exit * *  By default, color is not used to distinguish types of files. That is equivalent to using --color=none. Using the --color option without the optional WHEN argument is equivalent to using --color=always. With --color=auto, color codes are output only if standard output is con- nected to a terminal (tty). * </pre> * * @author Rob Oxspring * @author John Keyes */public class LsTest extends TestCase {    /** Option Builder */    private static final DefaultOptionBuilder oBuilder =        new DefaultOptionBuilder();    /** Argument Builder */    private static final ArgumentBuilder aBuilder = new ArgumentBuilder();    /** Group Builder */    private static final GroupBuilder gBuilder = new GroupBuilder();    private static Group options;    public static Test suite() {        return new TestSuite(LsTest.class);    }    /**     * Required ctor.     *     * @param name     *            the name of the TestCase     */    public LsTest(final String name) {        super(name);    }    public void setUp() {        if (LsTest.options == null) {            final Option a =                oBuilder                    .withShortName(\"a\")                    .withLongName(\"all\")                    .withDescription(\"do not hide entries starting with .\")                    .create();            final Option blockSize =                oBuilder                    .withLongName(\"block-size\")                    .withRequired(false)                    .withDescription(\"use SIZE-byte blocks\")                    .withArgument(                        aBuilder                            .withMaximum(1)                            .withMinimum(1)                            .withInitialSeparator('=')                            .create())                    .create();            final Option c =                oBuilder                    .withShortName(\"c\")                    .withRequired(false)                    .withDescription(\"with -lt: sort by, and show, ctime (time of last modification of file status information) with -l:show ctime and sort by name otherwise: sort by ctime\")                    .create();            final Set colors = new HashSet();            colors.add(\"never\");            colors.add(\"always\");            colors.add(\"auto\");            final Option color =                oBuilder                    .withLongName(\"color\")                    .withRequired(false)                    .withDescription(\"control  whether  color is used to distinguish file types.  WHEN may be `never', `always', or `auto'\")                    .withArgument(                        aBuilder                            .withMaximum(1)                            .withMinimum(1)                            .withInitialSeparator('=')                            .withValidator(new EnumValidator(colors))                            .create())                    .create();            LsTest.options =                gBuilder                    .withOption(a)                    .withOption(blockSize)                    .withOption(c)                    .withOption(color)                    .create();        }    }    public void testLs() throws OptionException {        // create the command line parser        Parser parser = new Parser();        parser.setGroup(options);        CommandLine line =            parser.parse(new String[] { \"--block-size=10\", \"--color=never\" });        assertTrue(line.hasOption(\"--block-size\"));        assertEquals(line.getValue(\"--block-size\"), \"10\");        assertFalse(line.hasOption(\"--ignore-backups\"));    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.application;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.validation.EnumValidator;\n+\n+/**\n+ * <p>Test the <code>ls</code> command. Duplicated Option types are not\n+ * tested e.g. -a and -d are the same Option type.</p>\n+ * \n+ * <p>The following is the man output for 'ls'. See\n+ * <a href=\"http://www.rt.com/man/ls.1.html\">http://www.rt.com/man/ls.1.html</a>.</p>\n+ * \n+ * <pre>\n+ *  LS(1) FSF LS(1)\n+ * \n+ *  NAME ls - list directory contents\n+ * \n+ *  SYNOPSIS ls [OPTION]... [FILE]...\n+ * \n+ *  DESCRIPTION List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuSUX nor --sort.\n+ * \n+ *  -a, --all do not hide entries starting with .\n+ * \n+ *  -A, --almost-all do not list implied . and ..\n+ * \n+ *  -b, --escape print octal escapes for nongraphic characters\n+ * \n+ *  --block-size=SIZE use SIZE-byte blocks\n+ * \n+ *  -B, --ignore-backups do not list implied entries ending with ~ -c sort by change time; with -l: show ctime -C list entries by columns\n+ * \n+ *  --color[=WHEN] control whether color is used to distinguish file types. WHEN may be `never', `always', or `auto'\n+ * \n+ *  -d, --directory list directory entries instead of contents\n+ * \n+ *  -D, --dired generate output designed for Emacs' dired mode -f do not sort, enable -aU, disable -lst\n+ * \n+ *  -F, --classify append indicator (one of /=@|*) to entries\n+ * \n+ *  --format=WORD across -x, commas -m, horizontal -x, long -l, sin- gle-column -1, verbose -l, vertical -C\n+ * \n+ *  --full-time list both full date and full time -g (ignored)\n+ * \n+ *  -G, --no-group inhibit display of group information\n+ * \n+ *  -h, --human-readable print sizes in human readable format (e.g., 1K 234M 2G)\n+ * \n+ *  -H, --si likewise, but use powers of 1000 not 1024\n+ * \n+ *  --indicator-style=WORD append indicator with style WORD to entry names: none (default), classify (-F), file-type (-p)\n+ * \n+ *  -i, --inode print index number of each file\n+ * \n+ *  -I, --ignore=PATTERN do not list implied entries matching shell PATTERN\n+ * \n+ *  -k, --kilobytes like --block-size=1024 -l use a long listing format\n+ * \n+ *  -L, --dereference list entries pointed to by symbolic links -m fill width with a comma separated list of entries\n+ * \n+ *  -n, --numeric-uid-gid list numeric UIDs and GIDs instead of names\n+ * \n+ *  -N, --literal print raw entry names (don't treat e.g. control characters specially) -o use long listing format without group info\n+ * \n+ *  -p, --file-type append indicator (one of /=@|) to entries\n+ * \n+ *  -q, --hide-control-chars print ? instead of non graphic characters\n+ * \n+ *  --show-control-chars show non graphic characters as-is (default)\n+ * \n+ *  -Q, --quote-name enclose entry names in double quotes\n+ * \n+ *  --quoting-style=WORD use quoting style WORD for entry names: literal, shell, shell-always, c, escape\n+ * \n+ *  -r, --reverse reverse order while sorting\n+ * \n+ *  -R, --recursive list subdirectories recursively\n+ * \n+ *  -s, --size print size of each file, in blocks -S sort by file size\n+ * \n+ *  --sort=WORD extension -X, none -U, size -S, time -t, version -v status -c, time -t, atime -u, access -u, use -u\n+ * \n+ *  --time=WORD show time as WORD instead of modification time: atime, access, use, ctime or status; use specified time as sort key if --sort=time -t sort by modification time\n+ * \n+ *  -T, --tabsize=COLS assume tab stops at each COLS instead of 8 -u sort by last access time; with -l: show atime -U do not sort; list entries in directory order -v sort by version\n+ * \n+ *  -w, --width=COLS assume screen width instead of current value -x list entries by lines instead of by columns -X sort alphabetically by entry extension -1 list one file per line\n+ * \n+ *  --help display this help and exit\n+ * \n+ *  --version output version information and exit\n+ * \n+ *  By default, color is not used to distinguish types of files. That is equivalent to using --color=none. Using the --color option without the optional WHEN argument is equivalent to using --color=always. With --color=auto, color codes are output only if standard output is con- nected to a terminal (tty).\n+ * </pre>\n+ * \n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class LsTest extends TestCase {\n+\n+    /** Option Builder */\n+    private static final DefaultOptionBuilder oBuilder =\n+        new DefaultOptionBuilder();\n+\n+    /** Argument Builder */\n+    private static final ArgumentBuilder aBuilder = new ArgumentBuilder();\n+\n+    /** Group Builder */\n+    private static final GroupBuilder gBuilder = new GroupBuilder();\n+\n+    private static Group options;\n+\n+    public static Test suite() {\n+        return new TestSuite(LsTest.class);\n+    }\n+\n+    /**\n+     * Required ctor.\n+     * \n+     * @param name\n+     *            the name of the TestCase\n+     */\n+    public LsTest(final String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+        if (LsTest.options == null) {\n+            final Option a =\n+                oBuilder\n+                    .withShortName(\"a\")\n+                    .withLongName(\"all\")\n+                    .withDescription(\"do not hide entries starting with .\")\n+                    .create();\n+\n+            final Option blockSize =\n+                oBuilder\n+                    .withLongName(\"block-size\")\n+                    .withRequired(false)\n+                    .withDescription(\"use SIZE-byte blocks\")\n+                    .withArgument(\n+                        aBuilder\n+                            .withMaximum(1)\n+                            .withMinimum(1)\n+                            .withInitialSeparator('=')\n+                            .create())\n+                    .create();\n+\n+            final Option c =\n+                oBuilder\n+                    .withShortName(\"c\")\n+                    .withRequired(false)\n+                    .withDescription(\"with -lt: sort by, and show, ctime (time of last modification of file status information) with -l:show ctime and sort by name otherwise: sort by ctime\")\n+                    .create();\n+\n+            final Set colors = new HashSet();\n+            colors.add(\"never\");\n+            colors.add(\"always\");\n+            colors.add(\"auto\");\n+            final Option color =\n+                oBuilder\n+                    .withLongName(\"color\")\n+                    .withRequired(false)\n+                    .withDescription(\"control  whether  color is used to distinguish file types.  WHEN may be `never', `always', or `auto'\")\n+                    .withArgument(\n+                        aBuilder\n+                            .withMaximum(1)\n+                            .withMinimum(1)\n+                            .withInitialSeparator('=')\n+                            .withValidator(new EnumValidator(colors))\n+                            .create())\n+                    .create();\n+\n+            LsTest.options =\n+                gBuilder\n+                    .withOption(a)\n+                    .withOption(blockSize)\n+                    .withOption(c)\n+                    .withOption(color)\n+                    .create();\n+        }\n+    }\n+\n+    public void testLs() throws OptionException {\n+        // create the command line parser\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        CommandLine line =\n+            parser.parse(new String[] { \"--block-size=10\", \"--color=never\" });\n+\n+        assertTrue(line.hasOption(\"--block-size\"));\n+        assertEquals(line.getValue(\"--block-size\"), \"10\");\n+        assertFalse(line.hasOption(\"--ignore-backups\"));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/bug/Bug13886Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/Bug13886Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import junit.framework.TestCase;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;/** * @author John Keyes */public class Bug13886Test extends TestCase {    public Bug13886Test(final String name) {        super(name);    }    public void testMandatoryGroup() throws Exception {        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Option a = obuilder.withShortName(\"a\").create();        final Option b = obuilder.withShortName(\"b\").create();        final Group options =            gbuilder                .withOption(a)                .withOption(b)                .withMaximum(1)                .withMinimum(1)                .create();        final Parser parser = new Parser();        parser.setGroup(options);        try {            parser.parse(new String[] {            });            fail(\"Expected MissingOptionException not caught\");        }        catch (final OptionException exp) {            assertEquals(\"Missing option -a|-b\", exp.getMessage());        }        try {            parser.parse(new String[] { \"-a\" });        }        catch (final OptionException exp) {            fail(\"Unexpected MissingOptionException caught\");        }        try {            parser.parse(new String[] { \"-b\" });        }        catch (final OptionException exp) {            fail(\"Unexpected MissingOptionException caught\");        }        try {            parser.parse(new String[] { \"-a\", \"-b\" });            fail(\"Expected UnexpectedOptionException not caught\");        }        catch (final OptionException exp) {            assertEquals(                \"Unexpected -b while processing -a|-b\",                exp.getMessage());        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug13886Test extends TestCase {\n+\n+    public Bug13886Test(final String name) {\n+        super(name);\n+    }\n+\n+    public void testMandatoryGroup() throws Exception {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Option a = obuilder.withShortName(\"a\").create();\n+\n+        final Option b = obuilder.withShortName(\"b\").create();\n+\n+        final Group options =\n+            gbuilder\n+                .withOption(a)\n+                .withOption(b)\n+                .withMaximum(1)\n+                .withMinimum(1)\n+                .create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+\n+        try {\n+            parser.parse(new String[] {\n+            });\n+            fail(\"Expected MissingOptionException not caught\");\n+        }\n+        catch (final OptionException exp) {\n+            assertEquals(\"Missing option -a|-b\", exp.getMessage());\n+        }\n+\n+        try {\n+            parser.parse(new String[] { \"-a\" });\n+        }\n+        catch (final OptionException exp) {\n+            fail(\"Unexpected MissingOptionException caught\");\n+        }\n+\n+        try {\n+            parser.parse(new String[] { \"-b\" });\n+        }\n+        catch (final OptionException exp) {\n+            fail(\"Unexpected MissingOptionException caught\");\n+        }\n+\n+        try {\n+            parser.parse(new String[] { \"-a\", \"-b\" });\n+            fail(\"Expected UnexpectedOptionException not caught\");\n+        }\n+        catch (final OptionException exp) {\n+            assertEquals(\n+                \"Unexpected -b while processing -a|-b\",\n+                exp.getMessage());\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/bug/Bug13935Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/Bug13935Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import junit.framework.TestCase;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;/** * @author John Keyes */public class Bug13935Test extends TestCase {    public Bug13935Test(final String name) {        super(name);    }    public void testRequiredGroup() throws Exception {        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        final ArgumentBuilder abuilder = new ArgumentBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Option testOption =            obuilder                .withShortName(\"a\")                .withArgument(abuilder.withName(\"quoted string\").create())                .create();        final Group options = gbuilder.withOption(testOption).create();        final Parser parser = new Parser();        parser.setGroup(options);        final CommandLine cmdLine =            parser.parse(new String[] { \"-a\", \"\\\"two tokens\\\"\" });        assertTrue(cmdLine.hasOption(\"-a\"));        assertEquals(\"two tokens\", cmdLine.getValue(\"-a\"));    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug13935Test extends TestCase {\n+\n+    public Bug13935Test(final String name) {\n+        super(name);\n+    }\n+\n+    public void testRequiredGroup() throws Exception {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Option testOption =\n+            obuilder\n+                .withShortName(\"a\")\n+                .withArgument(abuilder.withName(\"quoted string\").create())\n+                .create();\n+\n+        final Group options = gbuilder.withOption(testOption).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+\n+        final CommandLine cmdLine =\n+            parser.parse(new String[] { \"-a\", \"\\\"two tokens\\\"\" });\n+\n+        assertTrue(cmdLine.hasOption(\"-a\"));\n+        assertEquals(\"two tokens\", cmdLine.getValue(\"-a\"));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/bug/Bug15046Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/Bug15046Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import junit.framework.TestCase;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;/** * @author John Keyes */public class Bug15046Test extends TestCase {    public Bug15046Test(String name) {        super(name);    }    public void testParamNamedAsOption() throws Exception {        final String[] CLI_ARGS = new String[] { \"-z\", \"c\" };        DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        ArgumentBuilder abuilder = new ArgumentBuilder();        Option option =            obuilder                .withShortName(\"z\")                .withLongName(\"timezone\")                .withDescription(\"affected option\")                .withArgument(abuilder.withName(\"timezone\").create())                .create();        GroupBuilder gbuilder = new GroupBuilder();        Group options =            gbuilder.withName(\"bug15046\").withOption(option).create();        Parser parser = new Parser();        parser.setGroup(options);        CommandLine line = parser.parse(CLI_ARGS);        assertEquals(\"c\", line.getValue(\"-z\"));        Option c =            obuilder                .withShortName(\"c\")                .withLongName(\"conflict\")                .withDescription(\"conflicting option\")                .withArgument(abuilder.withName(\"conflict\").create())                .create();        options =            gbuilder                .withName(\"bug15046\")                .withOption(option)                .withOption(c)                .create();        parser.setGroup(options);        line = parser.parse(CLI_ARGS);        assertEquals(\"c\", line.getValue(\"-z\"));    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug15046Test extends TestCase {\n+\n+    public Bug15046Test(String name) {\n+        super(name);\n+    }\n+\n+    public void testParamNamedAsOption() throws Exception {\n+        final String[] CLI_ARGS = new String[] { \"-z\", \"c\" };\n+\n+        DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        ArgumentBuilder abuilder = new ArgumentBuilder();\n+\n+        Option option =\n+            obuilder\n+                .withShortName(\"z\")\n+                .withLongName(\"timezone\")\n+                .withDescription(\"affected option\")\n+                .withArgument(abuilder.withName(\"timezone\").create())\n+                .create();\n+\n+        GroupBuilder gbuilder = new GroupBuilder();\n+        Group options =\n+            gbuilder.withName(\"bug15046\").withOption(option).create();\n+\n+        Parser parser = new Parser();\n+        parser.setGroup(options);\n+        CommandLine line = parser.parse(CLI_ARGS);\n+\n+        assertEquals(\"c\", line.getValue(\"-z\"));\n+\n+        Option c =\n+            obuilder\n+                .withShortName(\"c\")\n+                .withLongName(\"conflict\")\n+                .withDescription(\"conflicting option\")\n+                .withArgument(abuilder.withName(\"conflict\").create())\n+                .create();\n+\n+        options =\n+            gbuilder\n+                .withName(\"bug15046\")\n+                .withOption(option)\n+                .withOption(c)\n+                .create();\n+\n+        parser.setGroup(options);\n+        line = parser.parse(CLI_ARGS);\n+\n+        assertEquals(\"c\", line.getValue(\"-z\"));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/bug/Bug15648Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/Bug15648Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import junit.framework.TestCase;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;/** * @author John Keyes */public class Bug15648Test extends TestCase {    public Bug15648Test(final String name) {        super(name);    }    public void testQuotedArgumentValue() throws Exception {        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        final ArgumentBuilder abuilder = new ArgumentBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Option testOption =            obuilder                .withShortName(\"a\")                .withArgument(abuilder.withName(\"quoted string\").create())                .create();        final Group options = gbuilder.withOption(testOption).create();        final Parser parser = new Parser();        parser.setGroup(options);        final CommandLine cmdLine =            parser.parse(new String[] { \"-a\", \"\\\"two tokens\\\"\" });        assertTrue(cmdLine.hasOption(\"-a\"));        assertEquals(\"two tokens\", cmdLine.getValue(\"-a\"));    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+/**\n+ * @author John Keyes\n+ */\n+public class Bug15648Test extends TestCase {\n+\n+    public Bug15648Test(final String name) {\n+        super(name);\n+    }\n+\n+    public void testQuotedArgumentValue() throws Exception {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+\n+        final Option testOption =\n+            obuilder\n+                .withShortName(\"a\")\n+                .withArgument(abuilder.withName(\"quoted string\").create())\n+                .create();\n+\n+        final Group options = gbuilder.withOption(testOption).create();\n+\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+\n+        final CommandLine cmdLine =\n+            parser.parse(new String[] { \"-a\", \"\\\"two tokens\\\"\" });\n+\n+        assertTrue(cmdLine.hasOption(\"-a\"));\n+        assertEquals(\"two tokens\", cmdLine.getValue(\"-a\"));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/bug/Bug27575Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/Bug27575Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import java.util.Iterator;import junit.framework.TestCase;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.builder.PatternBuilder;import org.apache.commons.cli2.option.GroupImpl;public class Bug27575Test extends TestCase {\tpublic void testRequiredOptions(){\t\tPatternBuilder builder = new PatternBuilder();\t\tbuilder.withPattern(\"hc!<\");\t\tOption option = builder.create();\t\tassertTrue(option instanceof GroupImpl);\t\tGroupImpl group = (GroupImpl)option;\t\tIterator i = group.getOptions().iterator();\t\tassertEquals(\"[-h]\",i.next().toString());\t\tassertEquals(\"-c <arg>\",i.next().toString());\t\tassertFalse(i.hasNext());\t}}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import java.util.Iterator;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.PatternBuilder;\n+import org.apache.commons.cli2.option.GroupImpl;\n+\n+public class Bug27575Test extends TestCase {\n+\n+\tpublic void testRequiredOptions(){\n+\t\tPatternBuilder builder = new PatternBuilder();\n+\t\tbuilder.withPattern(\"hc!<\");\n+\t\tOption option = builder.create();\n+\t\tassertTrue(option instanceof GroupImpl);\n+\t\t\n+\t\tGroupImpl group = (GroupImpl)option;\n+\t\tIterator i = group.getOptions().iterator();\n+\t\tassertEquals(\"[-h]\",i.next().toString());\n+\t\tassertEquals(\"-c <arg>\",i.next().toString());\n+\t\tassertFalse(i.hasNext());\n+\t}\n+}\n--- a/src/test/org/apache/commons/cli2/bug/Bug28005Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/Bug28005Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.CommandBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import junit.framework.TestCase;public class Bug28005Test extends TestCase {    public void testInfiniteLoop() {        final DefaultOptionBuilder optionBuilder = new DefaultOptionBuilder();        final ArgumentBuilder argumentBuilder = new ArgumentBuilder();        final GroupBuilder groupBuilder = new GroupBuilder();        final CommandBuilder commandBuilder = new CommandBuilder();        final Option inputFormatOption =            optionBuilder                .withLongName(\"input-format\")                //.withArgument(argumentBuilder.create())                .create();        final Argument argument =            argumentBuilder                .withName(\"file\")                .create();        final Group children =            groupBuilder                .withName(\"options\")                .withOption(inputFormatOption)                .create();        final Option command =            commandBuilder                .withName(\"convert\")                .withChildren(children)                .withArgument(argument)                .create();        final Group root =            groupBuilder                .withName(\"commands\")                .withOption(command)                .create();        final Parser parser = new Parser();        parser.setGroup(root);        final String[] args = new String[]{\"convert\", \"test.txt\",                \"--input-format\", \"a\"};        try {            parser.parse(args);            fail(\"a isn't valid!!\");        } catch (OptionException e) {            assertEquals(\"Unexpected a while processing commands\",e.getMessage());        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.CommandBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import junit.framework.TestCase;\n+\n+public class Bug28005Test extends TestCase {\n+    public void testInfiniteLoop() {\n+        final DefaultOptionBuilder optionBuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder argumentBuilder = new ArgumentBuilder();\n+        final GroupBuilder groupBuilder = new GroupBuilder();\n+        final CommandBuilder commandBuilder = new CommandBuilder();\n+        \n+        final Option inputFormatOption = \n+            optionBuilder\n+                .withLongName(\"input-format\")\n+                //.withArgument(argumentBuilder.create())\n+                .create();\n+                \n+        final Argument argument = \n+            argumentBuilder\n+                .withName(\"file\")\n+                .create();\n+                \n+        final Group children = \n+            groupBuilder\n+                .withName(\"options\")\n+                .withOption(inputFormatOption)\n+                .create();\n+                \n+        final Option command = \n+            commandBuilder\n+                .withName(\"convert\")\n+                .withChildren(children)\n+                .withArgument(argument)\n+                .create();\n+                \n+        final Group root = \n+            groupBuilder\n+                .withName(\"commands\")\n+                .withOption(command)\n+                .create();\n+                \n+        final Parser parser = new Parser();\n+        parser.setGroup(root);\n+        final String[] args = new String[]{\"convert\", \"test.txt\",\n+                \"--input-format\", \"a\"};\n+                \n+        try {\n+            parser.parse(args);\n+            fail(\"a isn't valid!!\");\n+        } catch (OptionException e) {\n+            assertEquals(\"Unexpected a while processing commands\",e.getMessage());\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/bug/Bug32533Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/Bug32533Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import junit.framework.TestCase;/** * @author roxspring */public class Bug32533Test extends TestCase {    public void testBlah() throws OptionException {        Option a1 = new DefaultOptionBuilder().withLongName(\"a1\").create();        Option b1 = new DefaultOptionBuilder().withLongName(\"b1\").create();        Option c1 = new DefaultOptionBuilder().withLongName(\"c1\").create();        Group b = new GroupBuilder().withOption(b1).create();        Group c = new GroupBuilder().withOption(c1).create();        Group a = new GroupBuilder().withOption(a1).withOption(b).withOption(c).create();        Parser parser = new Parser();        parser.setGroup(a);        parser.parse(new String[]{\"--a1\",\"--b1\"});    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author roxspring\n+ */\n+public class Bug32533Test extends TestCase {\n+    \n+    public void testBlah() throws OptionException {\n+        \n+        Option a1 = new DefaultOptionBuilder().withLongName(\"a1\").create();\n+        Option b1 = new DefaultOptionBuilder().withLongName(\"b1\").create();\n+        Option c1 = new DefaultOptionBuilder().withLongName(\"c1\").create();\n+        \n+        Group b = new GroupBuilder().withOption(b1).create();\n+        Group c = new GroupBuilder().withOption(c1).create();\n+        Group a = new GroupBuilder().withOption(a1).withOption(b).withOption(c).create();\n+        \n+        Parser parser = new Parser();  \n+        parser.setGroup(a);\n+        parser.parse(new String[]{\"--a1\",\"--b1\"});\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/cli2/bug/BugCLI122Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/BugCLI122Test.java\n-package org.apache.commons.cli2.bug;import junit.framework.TestCase;import org.apache.commons.cli2.*;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.validation.FileValidator;/** * @author brianegge */public class BugCLI122Test extends TestCase {    public void testArgumentWhichStartsWithDash() throws OptionException {        Argument wdArg = new ArgumentBuilder()                .withName(\"anything\")                .withMaximum(1)                .withMinimum(1)                .withInitialSeparator('=')                .create();        Option wdOpt = new DefaultOptionBuilder().withArgument(wdArg)                .withDescription(\"anything, foo or -foo\")                .withLongName(\"argument\")                .withShortName(\"a\")                .create();        Group group = new GroupBuilder().withOption(wdOpt).create();        Parser p = new Parser();        p.setGroup(group);        CommandLine normal = p.parse (new String[]{\"-a\", \"foo\"});        assertNotNull(normal);        assertEquals(normal.getValue(wdOpt), \"foo\");        CommandLine withDash = p.parse (new String[]{\"--argument\", \"\\\"-foo\\\"\"});        assertNotNull(withDash);        assertEquals(\"-foo\", withDash.getValue(wdOpt));        CommandLine withDashAndEquals = p.parse (new String[]{\"--argument=-foo\"});        assertNotNull(withDashAndEquals);        assertEquals(\"-foo\", withDashAndEquals.getValue(wdOpt));    }}\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.cli2.*;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.validation.FileValidator;\n+\n+/**\n+ * @author brianegge\n+ */\n+public class BugCLI122Test extends TestCase {\n+    public void testArgumentWhichStartsWithDash() throws OptionException {\n+        Argument wdArg = new ArgumentBuilder()\n+                .withName(\"anything\")\n+                .withMaximum(1)\n+                .withMinimum(1)\n+                .withInitialSeparator('=')\n+                .create();\n+\n+        Option wdOpt = new DefaultOptionBuilder().withArgument(wdArg)\n+                .withDescription(\"anything, foo or -foo\")\n+                .withLongName(\"argument\")\n+                .withShortName(\"a\")\n+                .create();\n+\n+        Group group = new GroupBuilder().withOption(wdOpt).create();\n+\n+        Parser p = new Parser();\n+        p.setGroup(group);\n+        CommandLine normal = p.parse (new String[]{\"-a\", \"foo\"});\n+        assertNotNull(normal);\n+        assertEquals(normal.getValue(wdOpt), \"foo\");\n+\n+        CommandLine withDash = p.parse (new String[]{\"--argument\", \"\\\"-foo\\\"\"});\n+        assertNotNull(withDash);\n+        assertEquals(\"-foo\", withDash.getValue(wdOpt));\n+\n+        CommandLine withDashAndEquals = p.parse (new String[]{\"--argument=-foo\"});\n+        assertNotNull(withDashAndEquals);\n+        assertEquals(\"-foo\", withDashAndEquals.getValue(wdOpt));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/bug/BugCLI12Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/BugCLI12Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import junit.framework.TestCase;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.option.PropertyOption;/** * http://issues.apache.org/jira/browse/CLI-12 */public class BugCLI12Test extends TestCase {  public void testBug() {    Argument arg = new ArgumentBuilder().withName(\"file\").create();    Option option = new PropertyOption();    Group group = new GroupBuilder().withOption(option).withOption(arg).create();    Parser p = new Parser();    p.setGroup(group);    CommandLine cl = p.parseAndHelp( new String[] { \"-Dmyprop1=myval1\", \"-Dmyprop2=myval2\", \"myfile\" } );    if(cl == null) {      assertTrue(\"Couldn't parse valid commandLine\", false);    }    assertEquals( \"myval1\", cl.getProperty(\"myprop1\"));    assertEquals( \"myval2\", cl.getProperty(\"myprop2\"));    String extraArgs = (String) cl.getValue(arg);    assertEquals( \"myfile\", extraArgs);  }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.PropertyOption;\n+\n+/**\n+ * http://issues.apache.org/jira/browse/CLI-12\n+ */\n+public class BugCLI12Test extends TestCase {\n+\n+  public void testBug() {\n+    Argument arg = new ArgumentBuilder().withName(\"file\").create();\n+\n+    Option option = new PropertyOption();\n+\n+    Group group = new GroupBuilder().withOption(option).withOption(arg).create();\n+\n+    Parser p = new Parser();\n+    p.setGroup(group);\n+\n+    CommandLine cl = p.parseAndHelp( new String[] { \"-Dmyprop1=myval1\", \"-Dmyprop2=myval2\", \"myfile\" } );\n+    if(cl == null) {\n+      assertTrue(\"Couldn't parse valid commandLine\", false);\n+    }\n+\n+    assertEquals( \"myval1\", cl.getProperty(\"myprop1\"));\n+    assertEquals( \"myval2\", cl.getProperty(\"myprop2\"));\n+\n+    String extraArgs = (String) cl.getValue(arg);\n+    assertEquals( \"myfile\", extraArgs);\n+  }\n+\n+}\n--- a/src/test/org/apache/commons/cli2/bug/BugCLI18Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/BugCLI18Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import java.io.PrintWriter;import java.io.StringWriter;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.util.HelpFormatter;import junit.framework.TestCase;/** * http://issues.apache.org/jira/browse/CLI-18 */public class BugCLI18Test extends TestCase {  public BugCLI18Test() {    super();  }  public void testBug() {    Option a = new DefaultOptionBuilder().withLongName(\"aaa\").withShortName(\"a\").withDescription(\"aaaaaaa\").create();    Option b = new DefaultOptionBuilder().withLongName(\"bbb\").withDescription(\"bbbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\").create();    Option c = new DefaultOptionBuilder().withLongName(\"ccc\").withShortName(\"c\").withDescription(\"ccccccc\").create();    Group g = new GroupBuilder().withOption(a).withOption(b).withOption(c).create();    HelpFormatter formatter = new HelpFormatter();    StringWriter out = new StringWriter();    formatter.setPrintWriter(new PrintWriter(out));    formatter.setHeader(\"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\");    formatter.setFooter(\"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\");    formatter.setGroup(g);    formatter.setShellCommand(\"foobar\");    formatter.print();  }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * http://issues.apache.org/jira/browse/CLI-18\n+ */\n+public class BugCLI18Test extends TestCase {\n+\n+  public BugCLI18Test() {\n+    super();\n+  }\n+\n+\n+  public void testBug() {\n+    Option a = new DefaultOptionBuilder().withLongName(\"aaa\").withShortName(\"a\").withDescription(\"aaaaaaa\").create();\n+    Option b = new DefaultOptionBuilder().withLongName(\"bbb\").withDescription(\"bbbbbbbb dksh fkshd fkhs dkfhsdk fhskd hksdks dhfowehfsdhfkjshf skfhkshf sf jkshfk sfh skfh skf f\").create();\n+    Option c = new DefaultOptionBuilder().withLongName(\"ccc\").withShortName(\"c\").withDescription(\"ccccccc\").create();\n+\n+    Group g = new GroupBuilder().withOption(a).withOption(b).withOption(c).create();\n+\n+    HelpFormatter formatter = new HelpFormatter();\n+    StringWriter out = new StringWriter();\n+\n+    formatter.setPrintWriter(new PrintWriter(out));\n+    formatter.setHeader(\"dsfkfsh kdh hsd hsdh fkshdf ksdh fskdh fsdh fkshfk sfdkjhskjh fkjh fkjsh khsdkj hfskdhf skjdfh ksf khf s\");\n+    formatter.setFooter(\"blort j jgj j jg jhghjghjgjhgjhg jgjhgj jhg jhg hjg jgjhghjg jhg hjg jhgjg jgjhghjg jg jgjhgjgjg jhg jhgjh\" + '\\r' + '\\n' + \"rarrr\");\n+    formatter.setGroup(g);\n+    formatter.setShellCommand(\"foobar\");\n+\n+    formatter.print();\n+\n+  }\n+}\n+\n--- a/src/test/org/apache/commons/cli2/bug/BugCLI80Test.java\n+++ b/src/test/org/apache/commons/cli2/bug/BugCLI80Test.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.bug;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import junit.framework.TestCase;/** * http://issues.apache.org/jira/browse/CLI-80 */public class BugCLI80Test extends TestCase {    public void testBug() {        final String optName = \"option\";        Argument arg = new ArgumentBuilder().withName(optName)                                            .withMaximum(1)                                            .create();        Option option = new DefaultOptionBuilder().withArgument(arg)                                                  .withDescription(\"singular option\")                                                  .withLongName(optName)                                                  .withShortName(\"o\")                                                  .create();        Group group = new GroupBuilder().withOption(option).create();        Parser p = new Parser();        p.setGroup(group);        CommandLine cl = p.parseAndHelp( new String[] { \"-o\", \"yes\" } );        assertNotNull(\"Couldn't parse valid commandLine\", cl);        assertEquals(\"Couldn't look up value by short name\", \"yes\", cl.getValue(\"-o\") );        try {            cl = p.parse( new String[] { \"-o\", \"yes\", \"-o\", \"jam\" } );            fail(\"Parsed invalid commandLine\");        } catch(OptionException e) {          // ok        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * http://issues.apache.org/jira/browse/CLI-80\n+ */\n+public class BugCLI80Test extends TestCase {\n+\n+    public void testBug() {\n+        final String optName = \"option\";\n+\n+        Argument arg = new ArgumentBuilder().withName(optName)\n+                                            .withMaximum(1)\n+                                            .create();\n+\n+        Option option = new DefaultOptionBuilder().withArgument(arg)\n+                                                  .withDescription(\"singular option\")\n+                                                  .withLongName(optName)\n+                                                  .withShortName(\"o\")\n+                                                  .create();\n+\n+        Group group = new GroupBuilder().withOption(option).create();\n+\n+        Parser p = new Parser();\n+        p.setGroup(group);\n+\n+        CommandLine cl = p.parseAndHelp( new String[] { \"-o\", \"yes\" } );\n+        assertNotNull(\"Couldn't parse valid commandLine\", cl);\n+\n+        assertEquals(\"Couldn't look up value by short name\", \"yes\", cl.getValue(\"-o\") );\n+\n+        try {\n+            cl = p.parse( new String[] { \"-o\", \"yes\", \"-o\", \"jam\" } );\n+            fail(\"Parsed invalid commandLine\");\n+        } catch(OptionException e) {\n+          // ok\n+        }\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/cli2/bug/BugLoopingOptionLookAlikeTest.java\n+++ b/src/test/org/apache/commons/cli2/bug/BugLoopingOptionLookAlikeTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */package org.apache.commons.cli2.bug;import junit.framework.TestCase;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.option.SourceDestArgument;/** * The first is a loop in Parser.parse() if I set a non-declared option. This * code goes into a loop in Parser.java method parse this while loop runs * endless * * @author Steve Alberty */public class BugLoopingOptionLookAlikeTest extends TestCase {    public void testLoopingOptionLookAlike() {        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();        final ArgumentBuilder abuilder = new ArgumentBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Group options = gbuilder            .withName(\"ant\")            .withOption(obuilder.withShortName(\"help\").withDescription(\"print this message\").create())            .withOption(obuilder.withShortName(\"projecthelp\").withDescription(\"print project help information\").create())            .withOption(abuilder.withName(\"target\").create())            .create();        final Parser parser = new Parser();        parser.setGroup(options);        try {            parser.parse(new String[] { \"-abcdef\",                    \"testfile.txt \", });            fail(\"OptionException\");        } catch (OptionException e) {            assertEquals(\"Unexpected -abcdef while processing ant\",e.getMessage());        }    }    public void testLoopingOptionLookAlike2() {        final ArgumentBuilder abuilder = new ArgumentBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Argument inputfile_opt = abuilder.withName(\"input\").withMinimum(1).withMaximum(1).create();        final Argument outputfile_opt = abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();        final Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);        final Group options = gbuilder.withOption(targets).create();        final Parser parser = new Parser();        parser.setGroup(options);        try {            parser.parse(new String[] { \"testfile.txt\", \"testfile.txt\", \"testfile.txt\", \"testfile.txt\" });            fail(\"OptionException\");        } catch (OptionException e) {            assertEquals(\"Unexpected testfile.txt while processing \", e.getMessage());        }    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.cli2.bug;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.option.SourceDestArgument;\n+\n+/**\n+ * The first is a loop in Parser.parse() if I set a non-declared option. This \n+ * code goes into a loop in Parser.java method parse this while loop runs \n+ * endless\n+ * \n+ * @author Steve Alberty\n+ */\n+public class BugLoopingOptionLookAlikeTest extends TestCase {\n+\n+    public void testLoopingOptionLookAlike() {\n+        final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+        final Group options = gbuilder\n+            .withName(\"ant\")\n+            .withOption(obuilder.withShortName(\"help\").withDescription(\"print this message\").create())\n+            .withOption(obuilder.withShortName(\"projecthelp\").withDescription(\"print project help information\").create())\n+            .withOption(abuilder.withName(\"target\").create())\n+            .create();\n+        \n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+        try {\n+            parser.parse(new String[] { \"-abcdef\",\n+                    \"testfile.txt \", });\n+            fail(\"OptionException\");\n+        } catch (OptionException e) {\n+            assertEquals(\"Unexpected -abcdef while processing ant\",e.getMessage());\n+        }\n+    }\n+    \n+    public void testLoopingOptionLookAlike2() {\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+        final Argument inputfile_opt = abuilder.withName(\"input\").withMinimum(1).withMaximum(1).create();\n+        final Argument outputfile_opt = abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();\n+        final Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);\n+        final Group options = gbuilder.withOption(targets).create();\n+        final Parser parser = new Parser();\n+        parser.setGroup(options);\n+        try {\n+            parser.parse(new String[] { \"testfile.txt\", \"testfile.txt\", \"testfile.txt\", \"testfile.txt\" });\n+            fail(\"OptionException\");\n+        } catch (OptionException e) {\n+            assertEquals(\"Unexpected testfile.txt while processing \", e.getMessage());\n+        }\n+    }    \n+}\n--- a/src/test/org/apache/commons/cli2/builder/ArgumentBuilderTest.java\n+++ b/src/test/org/apache/commons/cli2/builder/ArgumentBuilderTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */package org.apache.commons.cli2.builder;import java.util.ArrayList;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.option.ArgumentImpl;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;import org.apache.commons.cli2.validation.DateValidator;import org.apache.commons.cli2.validation.Validator;public class ArgumentBuilderTest    extends TestCase {    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    private ArgumentBuilder argumentBuilder;    /*     * @see TestCase#setUp()     */    protected void setUp()        throws Exception {        this.argumentBuilder = new ArgumentBuilder();    }    public void testConsumeRemaining() {        this.argumentBuilder.withConsumeRemaining(\"--\");        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect consume remaining token\", \"--\", arg.getConsumeRemaining());    }    public void testNullConsumeRemaining() {        try {            this.argumentBuilder.withConsumeRemaining(null);            fail(\"cannot use null consume remaining token\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_CONSUME_REMAINING),                         exp.getMessage());        }    }    public void testEmptyConsumeRemaining() {        try {            this.argumentBuilder.withConsumeRemaining(\"\");            fail(\"cannot use empty string consume remaining token\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_CONSUME_REMAINING),                         exp.getMessage());        }    }    public void testDefault() {        this.argumentBuilder.withDefault(\"defaultString\");        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect number of default values\", 1, arg.getDefaultValues().size());        assertEquals(\"incorrect default value\", \"defaultString\", arg.getDefaultValues().get(0));    }    public void testDefaultX2() {        this.argumentBuilder.withDefault(\"defaultString1\");        this.argumentBuilder.withDefault(\"defaultString2\");        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect number of default values\", 2, arg.getDefaultValues().size());        assertEquals(\"incorrect default value-1\", \"defaultString1\", arg.getDefaultValues().get(0));        assertEquals(\"incorrect default value-2\", \"defaultString2\", arg.getDefaultValues().get(1));    }    public void testNullDefault() {        try {            this.argumentBuilder.withDefault(null);            fail(\"cannot use null default\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULT),                         exp.getMessage());        }    }    public void testDefaults() {        final List defaults = new ArrayList();        defaults.add(\"one\");        defaults.add(\"two\");        this.argumentBuilder.withDefaults(defaults);        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect number of default values\", 2, arg.getDefaultValues().size());        assertEquals(\"incorrect default value-1\", \"one\", arg.getDefaultValues().get(0));        assertEquals(\"incorrect default value-2\", \"two\", arg.getDefaultValues().get(1));        assertEquals(\"incorrect default values list\", defaults, arg.getDefaultValues());    }    public void testNullDefaults() {        try {            this.argumentBuilder.withDefaults(null);            fail(\"cannot use null defaults\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULTS),                         exp.getMessage());        }    }    public void testId() {        this.argumentBuilder.withId(1);        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect id\", 1, arg.getId());    }    public void testInitialSeparator() {        this.argumentBuilder.withInitialSeparator(',');        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect initial separator\", ',', arg.getInitialSeparator());    }    public void testMaximum() {        this.argumentBuilder.withMaximum(1);        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect maximum\", 1, arg.getMaximum());    }    public void testNegativeMaximum() {        try {            this.argumentBuilder.withMaximum(-1);            fail(\"cannot use negative maximum\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM),                         exp.getMessage());        }    }    public void testMinimum() {        this.argumentBuilder.withMinimum(1);        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect maximum\", 1, arg.getMinimum());    }    public void testNegativeMinimum() {        try {            this.argumentBuilder.withMinimum(-1);            fail(\"cannot use negative minimum\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM),                         exp.getMessage());        }    }    public void testName() {        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect preferred name\", \"arg\", arg.getPreferredName());    }    public void testNullName() {        try {            this.argumentBuilder.withName(null);            fail(\"cannot use null name\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME),                         exp.getMessage());        }    }    public void testEmptyName() {        try {            this.argumentBuilder.withName(\"\");            fail(\"cannot use empty name\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME),                         exp.getMessage());        }    }    public void testSubsequentSeparator() {        this.argumentBuilder.withSubsequentSeparator(':');        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect subsequent separator\", ':', arg.getSubsequentSeparator());    }    public void testValidator() {        Validator validator = DateValidator.getDateInstance();        this.argumentBuilder.withValidator(validator);        this.argumentBuilder.withName(\"arg\");        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();        assertEquals(\"incorrect validator\", validator, arg.getValidator());    }    public void testNullValidator() {        try {            this.argumentBuilder.withValidator(null);            fail(\"cannot use null validator\");        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_VALIDATOR),                         exp.getMessage());        }    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.option.ArgumentImpl;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+import org.apache.commons.cli2.validation.DateValidator;\n+import org.apache.commons.cli2.validation.Validator;\n+\n+public class ArgumentBuilderTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    private ArgumentBuilder argumentBuilder;\n+\n+    /*\n+     * @see TestCase#setUp()\n+     */\n+    protected void setUp()\n+        throws Exception {\n+        this.argumentBuilder = new ArgumentBuilder();\n+    }\n+\n+    public void testConsumeRemaining() {\n+        this.argumentBuilder.withConsumeRemaining(\"--\");\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect consume remaining token\", \"--\", arg.getConsumeRemaining());\n+    }\n+\n+    public void testNullConsumeRemaining() {\n+        try {\n+            this.argumentBuilder.withConsumeRemaining(null);\n+            fail(\"cannot use null consume remaining token\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_CONSUME_REMAINING),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testEmptyConsumeRemaining() {\n+        try {\n+            this.argumentBuilder.withConsumeRemaining(\"\");\n+            fail(\"cannot use empty string consume remaining token\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_CONSUME_REMAINING),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testDefault() {\n+        this.argumentBuilder.withDefault(\"defaultString\");\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect number of default values\", 1, arg.getDefaultValues().size());\n+        assertEquals(\"incorrect default value\", \"defaultString\", arg.getDefaultValues().get(0));\n+    }\n+\n+    public void testDefaultX2() {\n+        this.argumentBuilder.withDefault(\"defaultString1\");\n+        this.argumentBuilder.withDefault(\"defaultString2\");\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect number of default values\", 2, arg.getDefaultValues().size());\n+        assertEquals(\"incorrect default value-1\", \"defaultString1\", arg.getDefaultValues().get(0));\n+        assertEquals(\"incorrect default value-2\", \"defaultString2\", arg.getDefaultValues().get(1));\n+    }\n+\n+    public void testNullDefault() {\n+        try {\n+            this.argumentBuilder.withDefault(null);\n+            fail(\"cannot use null default\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULT),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testDefaults() {\n+        final List defaults = new ArrayList();\n+        defaults.add(\"one\");\n+        defaults.add(\"two\");\n+\n+        this.argumentBuilder.withDefaults(defaults);\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect number of default values\", 2, arg.getDefaultValues().size());\n+        assertEquals(\"incorrect default value-1\", \"one\", arg.getDefaultValues().get(0));\n+        assertEquals(\"incorrect default value-2\", \"two\", arg.getDefaultValues().get(1));\n+        assertEquals(\"incorrect default values list\", defaults, arg.getDefaultValues());\n+\n+    }\n+\n+    public void testNullDefaults() {\n+        try {\n+            this.argumentBuilder.withDefaults(null);\n+            fail(\"cannot use null defaults\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULTS),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testId() {\n+        this.argumentBuilder.withId(1);\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect id\", 1, arg.getId());\n+    }\n+\n+    public void testInitialSeparator() {\n+        this.argumentBuilder.withInitialSeparator(',');\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect initial separator\", ',', arg.getInitialSeparator());\n+    }\n+\n+    public void testMaximum() {\n+        this.argumentBuilder.withMaximum(1);\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect maximum\", 1, arg.getMaximum());\n+    }\n+\n+    public void testNegativeMaximum() {\n+        try {\n+            this.argumentBuilder.withMaximum(-1);\n+            fail(\"cannot use negative maximum\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testMinimum() {\n+        this.argumentBuilder.withMinimum(1);\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect maximum\", 1, arg.getMinimum());\n+    }\n+\n+    public void testNegativeMinimum() {\n+        try {\n+            this.argumentBuilder.withMinimum(-1);\n+            fail(\"cannot use negative minimum\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testName() {\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect preferred name\", \"arg\", arg.getPreferredName());\n+    }\n+\n+    public void testNullName() {\n+        try {\n+            this.argumentBuilder.withName(null);\n+            fail(\"cannot use null name\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testEmptyName() {\n+        try {\n+            this.argumentBuilder.withName(\"\");\n+            fail(\"cannot use empty name\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testSubsequentSeparator() {\n+        this.argumentBuilder.withSubsequentSeparator(':');\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect subsequent separator\", ':', arg.getSubsequentSeparator());\n+    }\n+\n+    public void testValidator() {\n+        Validator validator = DateValidator.getDateInstance();\n+        this.argumentBuilder.withValidator(validator);\n+        this.argumentBuilder.withName(\"arg\");\n+\n+        ArgumentImpl arg = (ArgumentImpl) this.argumentBuilder.create();\n+\n+        assertEquals(\"incorrect validator\", validator, arg.getValidator());\n+    }\n+\n+    public void testNullValidator() {\n+        try {\n+            this.argumentBuilder.withValidator(null);\n+            fail(\"cannot use null validator\");\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_VALIDATOR),\n+                         exp.getMessage());\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/builder/DefaultOptionBuilderTest.java\n+++ b/src/test/org/apache/commons/cli2/builder/DefaultOptionBuilderTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.builder;import junit.framework.TestCase;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.option.DefaultOption;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;public class DefaultOptionBuilderTest    extends TestCase {    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    private DefaultOptionBuilder defaultOptionBuilder;    /*     * @see TestCase#setUp()     */    protected void setUp()        throws Exception {        this.defaultOptionBuilder = new DefaultOptionBuilder();    }    /*     * Class to test for void DefaultOptionBuilder(String, String, boolean)     */    public void testNew_NullShortPrefix() {        try {            new DefaultOptionBuilder(null, null, false);            fail(\"null short prefix is not permitted\");        } catch (IllegalArgumentException e) {            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX),                         e.getMessage());        }    }    /*     * Class to test for void DefaultOptionBuilder(String, String, boolean)     */    public void testNew_EmptyShortPrefix() {        try {            new DefaultOptionBuilder(\"\", null, false);            fail(\"empty short prefix is not permitted\");        } catch (IllegalArgumentException e) {            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX),                         e.getMessage());        }    }    /*     * Class to test for void DefaultOptionBuilder(String, String, boolean)     */    public void testNew_NullLongPrefix() {        try {            new DefaultOptionBuilder(\"-\", null, false);            fail(\"null long prefix is not permitted\");        } catch (IllegalArgumentException e) {            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX),                         e.getMessage());        }    }    /*     * Class to test for void DefaultOptionBuilder(String, String, boolean)     */    public void testNew_EmptyLongPrefix() {        try {            new DefaultOptionBuilder(\"-\", \"\", false);            fail(\"empty long prefix is not permitted\");        } catch (IllegalArgumentException e) {            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX),                         e.getMessage());        }    }    public void testCreate() {        try {            this.defaultOptionBuilder.create();            fail(\"options must have a name\");        } catch (IllegalStateException e) {            assertEquals(resources.getMessage(ResourceConstants.OPTION_NO_NAME), e.getMessage());        }        this.defaultOptionBuilder.withShortName(\"j\");        this.defaultOptionBuilder.create();        this.defaultOptionBuilder.withLongName(\"jkeyes\");        this.defaultOptionBuilder.create();        {            DefaultOptionBuilder builder = new DefaultOptionBuilder(\"-\", \"--\", true);            builder.withShortName(\"mx\");        }    }    public void testName() {        // withLongName && this.preferred != null        {            this.defaultOptionBuilder.withShortName(\"a\");            this.defaultOptionBuilder.withLongName(\"apples\");        }        // withShortName && this.preferred != null        {            this.defaultOptionBuilder.withLongName(\"apples\");            this.defaultOptionBuilder.withShortName(\"a\");        }        // withShortName && this.preferred != null        {            this.defaultOptionBuilder.withLongName(\"apples\");            this.defaultOptionBuilder.withShortName(\"a\");        }    }    public void testWithDescription() {        String description = \"desc\";        this.defaultOptionBuilder.withShortName(\"a\");        this.defaultOptionBuilder.withDescription(description);        DefaultOption opt = this.defaultOptionBuilder.create();        assertEquals(\"wrong description found\", description, opt.getDescription());    }    public void testWithRequired() {        {            boolean required = false;            this.defaultOptionBuilder.withShortName(\"a\");            this.defaultOptionBuilder.withRequired(required);            DefaultOption opt = this.defaultOptionBuilder.create();            assertEquals(\"wrong required found\", required, opt.isRequired());        }        {            boolean required = true;            this.defaultOptionBuilder.withShortName(\"a\");            this.defaultOptionBuilder.withRequired(required);            DefaultOption opt = this.defaultOptionBuilder.create();            assertEquals(\"wrong required found\", required, opt.isRequired());        }    }    public void testWithChildren() {        GroupBuilder gbuilder = new GroupBuilder();        this.defaultOptionBuilder.withShortName(\"a\");        this.defaultOptionBuilder.withRequired(true);        DefaultOption opt = this.defaultOptionBuilder.create();        Group group = gbuilder.withName(\"withchildren\").withOption(opt).create();        {            this.defaultOptionBuilder.withShortName(\"b\");            this.defaultOptionBuilder.withChildren(group);            DefaultOption option = this.defaultOptionBuilder.create();            assertEquals(\"wrong children found\", group, option.getChildren());        }    }    public void testWithArgument() {        ArgumentBuilder abuilder = new ArgumentBuilder();        abuilder.withName(\"myarg\");        Argument arg = abuilder.create();        this.defaultOptionBuilder.withShortName(\"a\");        this.defaultOptionBuilder.withRequired(true);        this.defaultOptionBuilder.withArgument(arg);        DefaultOption opt = this.defaultOptionBuilder.create();        assertEquals(\"wrong argument found\", arg, opt.getArgument());    }    public void testWithId() {        this.defaultOptionBuilder.withShortName(\"a\");        this.defaultOptionBuilder.withId(0);        DefaultOption opt = this.defaultOptionBuilder.create();        assertEquals(\"wrong id found\", 0, opt.getId());    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.builder;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class DefaultOptionBuilderTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    private DefaultOptionBuilder defaultOptionBuilder;\n+\n+    /*\n+     * @see TestCase#setUp()\n+     */\n+    protected void setUp()\n+        throws Exception {\n+        this.defaultOptionBuilder = new DefaultOptionBuilder();\n+    }\n+\n+    /*\n+     * Class to test for void DefaultOptionBuilder(String, String, boolean)\n+     */\n+    public void testNew_NullShortPrefix() {\n+        try {\n+            new DefaultOptionBuilder(null, null, false);\n+            fail(\"null short prefix is not permitted\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for void DefaultOptionBuilder(String, String, boolean)\n+     */\n+    public void testNew_EmptyShortPrefix() {\n+        try {\n+            new DefaultOptionBuilder(\"\", null, false);\n+            fail(\"empty short prefix is not permitted\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for void DefaultOptionBuilder(String, String, boolean)\n+     */\n+    public void testNew_NullLongPrefix() {\n+        try {\n+            new DefaultOptionBuilder(\"-\", null, false);\n+            fail(\"null long prefix is not permitted\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * Class to test for void DefaultOptionBuilder(String, String, boolean)\n+     */\n+    public void testNew_EmptyLongPrefix() {\n+        try {\n+            new DefaultOptionBuilder(\"-\", \"\", false);\n+            fail(\"empty long prefix is not permitted\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX),\n+                         e.getMessage());\n+        }\n+    }\n+\n+    public void testCreate() {\n+        try {\n+            this.defaultOptionBuilder.create();\n+            fail(\"options must have a name\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.OPTION_NO_NAME), e.getMessage());\n+        }\n+\n+        this.defaultOptionBuilder.withShortName(\"j\");\n+        this.defaultOptionBuilder.create();\n+        this.defaultOptionBuilder.withLongName(\"jkeyes\");\n+        this.defaultOptionBuilder.create();\n+\n+        {\n+            DefaultOptionBuilder builder = new DefaultOptionBuilder(\"-\", \"--\", true);\n+            builder.withShortName(\"mx\");\n+        }\n+    }\n+\n+    public void testName() {\n+        // withLongName && this.preferred != null\n+        {\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+            this.defaultOptionBuilder.withLongName(\"apples\");\n+        }\n+        // withShortName && this.preferred != null\n+        {\n+            this.defaultOptionBuilder.withLongName(\"apples\");\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+        }\n+        // withShortName && this.preferred != null\n+        {\n+            this.defaultOptionBuilder.withLongName(\"apples\");\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+        }\n+    }\n+\n+    public void testWithDescription() {\n+        String description = \"desc\";\n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withDescription(description);\n+\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+        assertEquals(\"wrong description found\", description, opt.getDescription());\n+    }\n+\n+    public void testWithRequired() {\n+        {\n+            boolean required = false;\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+            this.defaultOptionBuilder.withRequired(required);\n+\n+            DefaultOption opt = this.defaultOptionBuilder.create();\n+            assertEquals(\"wrong required found\", required, opt.isRequired());\n+        }\n+\n+        {\n+            boolean required = true;\n+            this.defaultOptionBuilder.withShortName(\"a\");\n+            this.defaultOptionBuilder.withRequired(required);\n+\n+            DefaultOption opt = this.defaultOptionBuilder.create();\n+            assertEquals(\"wrong required found\", required, opt.isRequired());\n+        }\n+    }\n+\n+    public void testWithChildren() {\n+        GroupBuilder gbuilder = new GroupBuilder();\n+\n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withRequired(true);\n+\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+\n+        Group group = gbuilder.withName(\"withchildren\").withOption(opt).create();\n+\n+        {\n+            this.defaultOptionBuilder.withShortName(\"b\");\n+            this.defaultOptionBuilder.withChildren(group);\n+\n+            DefaultOption option = this.defaultOptionBuilder.create();\n+            assertEquals(\"wrong children found\", group, option.getChildren());\n+        }\n+    }\n+\n+    public void testWithArgument() {\n+        ArgumentBuilder abuilder = new ArgumentBuilder();\n+        abuilder.withName(\"myarg\");\n+\n+        Argument arg = abuilder.create();\n+\n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withRequired(true);\n+        this.defaultOptionBuilder.withArgument(arg);\n+\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+\n+        assertEquals(\"wrong argument found\", arg, opt.getArgument());\n+    }\n+\n+    public void testWithId() {\n+        this.defaultOptionBuilder.withShortName(\"a\");\n+        this.defaultOptionBuilder.withId(0);\n+\n+        DefaultOption opt = this.defaultOptionBuilder.create();\n+\n+        assertEquals(\"wrong id found\", 0, opt.getId());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/commandline/DefaultingCommandLineTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/DefaultingCommandLineTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.Set;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.CommandLineTestCase;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.builder.DefaultOptionBuilder;/** * @author Rob Oxspring */public class DefaultingCommandLineTest    extends CommandLineTestCase {    private CommandLine first;    private CommandLine second;    private Option inFirst = new DefaultOptionBuilder().withLongName(\"infirst\").create();    private Option inBoth = new DefaultOptionBuilder().withLongName(\"inboth\").create();    private Option inSecond = new DefaultOptionBuilder().withLongName(\"insecond\").create();    /* (non-Javadoc)     * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()     */    protected final CommandLine createCommandLine() {        final WriteableCommandLine writeable = new WriteableCommandLineImpl(root, new ArrayList());        writeable.addOption(present);        writeable.addProperty(\"present\", \"present property\");        writeable.addSwitch(bool, true);        writeable.addValue(present, \"present value\");        writeable.addOption(multiple);        writeable.addValue(multiple, \"value 1\");        writeable.addValue(multiple, \"value 2\");        writeable.addValue(multiple, \"value 3\");        final DefaultingCommandLine defaults = new DefaultingCommandLine();        defaults.appendCommandLine(writeable);        return defaults;    }    public void setUp()        throws Exception {        super.setUp();        WriteableCommandLine writeable;        writeable = new WriteableCommandLineImpl(root, new ArrayList());        writeable.addOption(inFirst);        writeable.addOption(inBoth);        writeable.addProperty(\"infirst\", \"infirst first value\");        writeable.addProperty(\"inboth\", \"inboth first value\");        writeable.addSwitch(inFirst, true);        writeable.addSwitch(inBoth, true);        writeable.addValue(inFirst, \"infirst first value 1\");        writeable.addValue(inFirst, \"infirst first value 2\");        writeable.addValue(inBoth, \"inboth first value 1\");        writeable.addValue(inBoth, \"inboth first value 2\");        first = writeable;        writeable = new WriteableCommandLineImpl(root, new ArrayList());        writeable.addOption(inSecond);        writeable.addOption(inBoth);        writeable.addProperty(\"insecond\", \"insecond second value\");        writeable.addProperty(\"inboth\", \"inboth second value\");        writeable.addSwitch(inSecond, true);        writeable.addSwitch(inBoth, true);        writeable.addValue(inSecond, \"insecond second value 1\");        writeable.addValue(inSecond, \"insecond second value 2\");        writeable.addValue(inBoth, \"inboth second value 1\");        writeable.addValue(inBoth, \"inboth second value 2\");        second = writeable;    }    public final void testAppendCommandLine() {        final DefaultingCommandLine defaults = new DefaultingCommandLine();        Iterator i;        i = defaults.commandLines();        assertFalse(i.hasNext());        defaults.appendCommandLine(first);        i = defaults.commandLines();        assertSame(first, i.next());        assertFalse(i.hasNext());        defaults.appendCommandLine(second);        i = defaults.commandLines();        assertSame(first, i.next());        assertSame(second, i.next());        assertFalse(i.hasNext());    }    public final void testInsertCommandLine() {        final DefaultingCommandLine defaults = new DefaultingCommandLine();        Iterator i;        i = defaults.commandLines();        assertFalse(i.hasNext());        defaults.insertCommandLine(0, first);        i = defaults.commandLines();        assertSame(first, i.next());        assertFalse(i.hasNext());        defaults.insertCommandLine(0, second);        i = defaults.commandLines();        assertSame(second, i.next());        assertSame(first, i.next());        assertFalse(i.hasNext());    }    public void testTriggers() {        final DefaultingCommandLine defaults = new DefaultingCommandLine();        defaults.appendCommandLine(first);        defaults.appendCommandLine(second);        Set set = defaults.getOptionTriggers();        Iterator iter = set.iterator();        assertEquals(\"wrong # of triggers\", 3, set.size());        assertTrue(\"cannot find trigger\", set.contains(\"--insecond\"));        assertTrue(\"cannot find trigger\", set.contains(\"--inboth\"));        assertTrue(\"cannot find trigger\", set.contains(\"--infirst\"));    }    public void testDefaults() {        final DefaultingCommandLine defaults = new DefaultingCommandLine();        assertEquals(\"wrong # of defaults\", 0, defaults.getValues(\"--insecond\").size());        assertEquals(\"wrong Set of defaults\", Collections.EMPTY_LIST, defaults.getValues(\"--insecond\", null));    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.CommandLineTestCase;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class DefaultingCommandLineTest\n+    extends CommandLineTestCase {\n+    private CommandLine first;\n+    private CommandLine second;\n+    private Option inFirst = new DefaultOptionBuilder().withLongName(\"infirst\").create();\n+    private Option inBoth = new DefaultOptionBuilder().withLongName(\"inboth\").create();\n+    private Option inSecond = new DefaultOptionBuilder().withLongName(\"insecond\").create();\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+     */\n+    protected final CommandLine createCommandLine() {\n+        final WriteableCommandLine writeable = new WriteableCommandLineImpl(root, new ArrayList());\n+        writeable.addOption(present);\n+        writeable.addProperty(\"present\", \"present property\");\n+        writeable.addSwitch(bool, true);\n+        writeable.addValue(present, \"present value\");\n+        writeable.addOption(multiple);\n+        writeable.addValue(multiple, \"value 1\");\n+        writeable.addValue(multiple, \"value 2\");\n+        writeable.addValue(multiple, \"value 3\");\n+\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        defaults.appendCommandLine(writeable);\n+\n+        return defaults;\n+    }\n+\n+    public void setUp()\n+        throws Exception {\n+        super.setUp();\n+\n+        WriteableCommandLine writeable;\n+\n+        writeable = new WriteableCommandLineImpl(root, new ArrayList());\n+        writeable.addOption(inFirst);\n+        writeable.addOption(inBoth);\n+        writeable.addProperty(\"infirst\", \"infirst first value\");\n+        writeable.addProperty(\"inboth\", \"inboth first value\");\n+        writeable.addSwitch(inFirst, true);\n+        writeable.addSwitch(inBoth, true);\n+        writeable.addValue(inFirst, \"infirst first value 1\");\n+        writeable.addValue(inFirst, \"infirst first value 2\");\n+        writeable.addValue(inBoth, \"inboth first value 1\");\n+        writeable.addValue(inBoth, \"inboth first value 2\");\n+        first = writeable;\n+\n+        writeable = new WriteableCommandLineImpl(root, new ArrayList());\n+        writeable.addOption(inSecond);\n+        writeable.addOption(inBoth);\n+        writeable.addProperty(\"insecond\", \"insecond second value\");\n+        writeable.addProperty(\"inboth\", \"inboth second value\");\n+        writeable.addSwitch(inSecond, true);\n+        writeable.addSwitch(inBoth, true);\n+        writeable.addValue(inSecond, \"insecond second value 1\");\n+        writeable.addValue(inSecond, \"insecond second value 2\");\n+        writeable.addValue(inBoth, \"inboth second value 1\");\n+        writeable.addValue(inBoth, \"inboth second value 2\");\n+        second = writeable;\n+    }\n+\n+    public final void testAppendCommandLine() {\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        Iterator i;\n+\n+        i = defaults.commandLines();\n+        assertFalse(i.hasNext());\n+\n+        defaults.appendCommandLine(first);\n+        i = defaults.commandLines();\n+        assertSame(first, i.next());\n+        assertFalse(i.hasNext());\n+\n+        defaults.appendCommandLine(second);\n+        i = defaults.commandLines();\n+        assertSame(first, i.next());\n+        assertSame(second, i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public final void testInsertCommandLine() {\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        Iterator i;\n+\n+        i = defaults.commandLines();\n+        assertFalse(i.hasNext());\n+\n+        defaults.insertCommandLine(0, first);\n+        i = defaults.commandLines();\n+        assertSame(first, i.next());\n+        assertFalse(i.hasNext());\n+\n+        defaults.insertCommandLine(0, second);\n+        i = defaults.commandLines();\n+        assertSame(second, i.next());\n+        assertSame(first, i.next());\n+        assertFalse(i.hasNext());\n+    }\n+    \n+    public void testTriggers() {\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        defaults.appendCommandLine(first);\n+        defaults.appendCommandLine(second);\n+\n+        Set set = defaults.getOptionTriggers();\n+        Iterator iter = set.iterator();\n+        assertEquals(\"wrong # of triggers\", 3, set.size());\n+        assertTrue(\"cannot find trigger\", set.contains(\"--insecond\"));\n+        assertTrue(\"cannot find trigger\", set.contains(\"--inboth\"));\n+        assertTrue(\"cannot find trigger\", set.contains(\"--infirst\"));\n+    }\n+\n+    public void testDefaults() {\n+        final DefaultingCommandLine defaults = new DefaultingCommandLine();\n+        \n+        assertEquals(\"wrong # of defaults\", 0, defaults.getValues(\"--insecond\").size());\n+        assertEquals(\"wrong Set of defaults\", Collections.EMPTY_LIST, defaults.getValues(\"--insecond\", null));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/commandline/ParserTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/ParserTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.io.StringReader;import java.io.StringWriter;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.option.DefaultOption;import org.apache.commons.cli2.util.HelpFormatter;import junit.framework.TestCase;public class ParserTest extends TestCase {    private Parser parser;    private DefaultOption verboseOption;    private DefaultOption helpOption;    private Group options;    private HelpFormatter helpFormatter;    private StringWriter out;    private BufferedReader in;    public void setUp() {        parser = new Parser();        final GroupBuilder gBuilder = new GroupBuilder();        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();        helpOption = oBuilder.withLongName(\"help\").withShortName(\"h\").create();        verboseOption = oBuilder.withLongName(\"verbose\").withShortName(\"v\").create();        options = gBuilder.withOption(helpOption).withOption(verboseOption).create();        parser.setGroup(options);        helpFormatter = new HelpFormatter();        out = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(out));        parser.setHelpFormatter(helpFormatter);    }    public void testParse_Successful() throws OptionException {        final CommandLine cl = parser.parse(new String[]{\"-hv\"});        assertTrue(cl.hasOption(helpOption));        assertTrue(cl.hasOption(verboseOption));        assertEquals(\"--help --verbose\",cl.toString());        final WriteableCommandLineImpl wcli = (WriteableCommandLineImpl)cl;        assertEquals(\"[--help, --verbose]\",wcli.getNormalised().toString());    }    public void testParse_WithUnexpectedOption() {        try {            parser.parse(new String[]{\"--unexpected\"});            fail(\"OptionException\");        }        catch(OptionException e) {            assertEquals(options,e.getOption());            assertEquals(\"Unexpected --unexpected while processing --help|--verbose\",e.getMessage());        }    }    public void testParseAndHelp_Successful() throws IOException {        final CommandLine cl = parser.parseAndHelp(new String[]{\"-v\"});        assertTrue(cl.hasOption(verboseOption));        assertEquals(\"\",out.getBuffer().toString());    }    public void testParseAndHelp_ByHelpOption() throws IOException {        parser.setHelpOption(helpOption);        assertNull(parser.parseAndHelp(new String[]{\"-hv\"}));        inReader();        assertInReaderUsage();        assertInReaderEOF();    }    public void testParseAndHelp_ByHelpTrigger() throws IOException {        parser.setHelpTrigger(\"--help\");        assertNull(parser.parseAndHelp(new String[]{\"-hv\"}));        inReader();        assertInReaderUsage();        assertInReaderEOF();    }    public void testParseAndHelp_WithUnexpectedOption() throws IOException {        assertNull(parser.parseAndHelp(new String[]{\"--unexpected\"}));        inReader();        assertInReaderLine(\"Unexpected --unexpected while processing --help|--verbose\");        assertInReaderUsage();        assertInReaderEOF();    }    private void assertInReaderUsage() throws IOException {        assertInReaderLine(\"Usage:\");        assertInReaderLine(\"[--help --verbose]\");        assertInReaderLine(\"--help|--verbose\");        assertInReaderLine(\"--help (-h)\");        assertInReaderLine(\"--verbose (-v)\");    }    private void assertInReaderLine(final String string) throws IOException {        assertEquals(string,in.readLine().trim());    }    private void assertInReaderEOF() throws IOException {        assertNull(in.readLine());    }    private void inReader() {        in = new BufferedReader(new StringReader(out.getBuffer().toString()));    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.option.DefaultOption;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+import junit.framework.TestCase;\n+\n+public class ParserTest extends TestCase {\n+    \n+    private Parser parser;\n+    private DefaultOption verboseOption;\n+    private DefaultOption helpOption;\n+    private Group options;\n+    private HelpFormatter helpFormatter;\n+    private StringWriter out;\n+    private BufferedReader in;\n+\n+    public void setUp() {\n+        parser = new Parser();\n+        \n+        final GroupBuilder gBuilder = new GroupBuilder();\n+        final DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\n+        \n+        helpOption = oBuilder.withLongName(\"help\").withShortName(\"h\").create();\n+        verboseOption = oBuilder.withLongName(\"verbose\").withShortName(\"v\").create();\n+        options = gBuilder.withOption(helpOption).withOption(verboseOption).create();\n+        parser.setGroup(options);\n+        \n+        helpFormatter = new HelpFormatter();\n+        out = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(out));\n+        parser.setHelpFormatter(helpFormatter);\n+    }\n+\n+    public void testParse_Successful() throws OptionException {\n+        final CommandLine cl = parser.parse(new String[]{\"-hv\"});\n+        \n+        assertTrue(cl.hasOption(helpOption));\n+        assertTrue(cl.hasOption(verboseOption));\n+        \n+        assertEquals(\"--help --verbose\",cl.toString());\n+        \n+        final WriteableCommandLineImpl wcli = (WriteableCommandLineImpl)cl;\n+        assertEquals(\"[--help, --verbose]\",wcli.getNormalised().toString());\n+    }\n+\n+    public void testParse_WithUnexpectedOption() {\n+        try {\n+            parser.parse(new String[]{\"--unexpected\"});\n+            fail(\"OptionException\");\n+        }\n+        catch(OptionException e) {\n+            assertEquals(options,e.getOption());\n+            assertEquals(\"Unexpected --unexpected while processing --help|--verbose\",e.getMessage());\n+        }\n+    }\n+\n+    public void testParseAndHelp_Successful() throws IOException {\n+        final CommandLine cl = parser.parseAndHelp(new String[]{\"-v\"});\n+        \n+        assertTrue(cl.hasOption(verboseOption));\n+        assertEquals(\"\",out.getBuffer().toString());\n+    }\n+\n+    public void testParseAndHelp_ByHelpOption() throws IOException {\n+        parser.setHelpOption(helpOption);\n+        \n+        assertNull(parser.parseAndHelp(new String[]{\"-hv\"}));\n+        \n+        inReader();\n+        assertInReaderUsage();\n+        assertInReaderEOF();\n+    }\n+\n+    public void testParseAndHelp_ByHelpTrigger() throws IOException {\n+        parser.setHelpTrigger(\"--help\");\n+        \n+        assertNull(parser.parseAndHelp(new String[]{\"-hv\"}));\n+        \n+        inReader();\n+        assertInReaderUsage();\n+        assertInReaderEOF();\n+    }\n+\n+    public void testParseAndHelp_WithUnexpectedOption() throws IOException {\n+        assertNull(parser.parseAndHelp(new String[]{\"--unexpected\"}));\n+        \n+        inReader();\n+        assertInReaderLine(\"Unexpected --unexpected while processing --help|--verbose\");\n+        assertInReaderUsage();\n+        assertInReaderEOF();\n+    }\n+\n+    private void assertInReaderUsage() throws IOException {\n+        assertInReaderLine(\"Usage:\");\n+        assertInReaderLine(\"[--help --verbose]\");\n+        assertInReaderLine(\"--help|--verbose\");\n+        assertInReaderLine(\"--help (-h)\");\n+        assertInReaderLine(\"--verbose (-v)\");\n+    }\n+\n+    private void assertInReaderLine(final String string) throws IOException {\n+        assertEquals(string,in.readLine().trim());\n+    }\n+\n+    private void assertInReaderEOF() throws IOException {\n+        assertNull(in.readLine());\n+    }\n+\n+    private void inReader() {\n+        in = new BufferedReader(new StringReader(out.getBuffer().toString()));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/commandline/PreferencesCommandLineTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/PreferencesCommandLineTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.Iterator;import java.util.Set;import java.util.prefs.Preferences;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.CommandLineTestCase;/** * @author Rob Oxspring */public class PreferencesCommandLineTest extends CommandLineTestCase {\t/* (non-Javadoc)\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\t */\tprotected CommandLine createCommandLine() {\t\t// TODO Auto-generated method stub\t\tfinal Preferences props = Preferences.userNodeForPackage(PreferencesCommandLineTest.class);\t\tprops.put(\"--present\",\"present value\");\t\tprops.put(\"--alsopresent\",\"\");\t\tprops.put(\"--multiple\",\"value 1|value 2|value 3\");\t\tprops.put(\"--bool\",\"true\");\t\tprops.put(\"present\",\"present property\");\t\treturn new PreferencesCommandLine(root,props,'|');\t}\tprotected CommandLine createCommandLineNoSep() {\t\t// TODO Auto-generated method stub\t\tfinal Preferences props = Preferences.userNodeForPackage(PreferencesCommandLineTest.class);\t\tprops.put(\"--present\",\"present value\");\t\tprops.put(\"--alsopresent\",\"\");\t\tprops.put(\"--multiple\",\"value 1|value 2|value 3\");\t\tprops.put(\"--bool\",\"false\");\t\tprops.put(\"present\",\"present property\");\t\treturn new PreferencesCommandLine(root,props);\t}    public void testPropertyValues() {        // nothing to test    \tCommandLine cmdline = createCommandLine();    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));    \tassertEquals(\"wrong # of values\", 3, cmdline.getValues(\"--multiple\").size());    \tassertEquals(\"wrong value 1\", \"value 1\", cmdline.getValues(\"--multiple\").get(0));    \tassertEquals(\"wrong value 2\", \"value 2\", cmdline.getValues(\"--multiple\").get(1));    \tassertEquals(\"wrong value 3\", \"value 3\", cmdline.getValues(\"--multiple\").get(2));    }    public void testNoSeparator() {        // nothing to test    \tCommandLine cmdline = createCommandLineNoSep();    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));    \tassertEquals(\"wrong # of values\", 1, cmdline.getValues(\"--multiple\").size());    \tassertEquals(\"wrong value\", \"value 1|value 2|value 3\", cmdline.getValue(\"--multiple\"));    \tassertFalse(\"expected a false\", cmdline.getSwitch(\"--bool\").booleanValue());    }    public void testNullOption() {        // nothing to test    \tCommandLine cmdline = createCommandLine();    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());    }    public void testPreferenceTriggers() {        // nothing to test    \tCommandLine cmdline = createCommandLine();    \tSet triggers = cmdline.getOptionTriggers();        Iterator iter = triggers.iterator();        assertEquals(\"wrong # of triggers\", 4, triggers.size());        assertTrue(\"cannot find trigger\", triggers.contains(\"--bool\"));        assertTrue(\"cannot find trigger\", triggers.contains(\"--present\"));        assertTrue(\"cannot find trigger\", triggers.contains(\"--multiple\"));        assertTrue(\"cannot find trigger\", triggers.contains(\"--alsopresent\"));    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.prefs.Preferences;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.CommandLineTestCase;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class PreferencesCommandLineTest extends CommandLineTestCase {\n+\t\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.cli2.CommandLineTest#createCommandLine()\n+\t */\n+\tprotected CommandLine createCommandLine() {\n+\t\t// TODO Auto-generated method stub\n+\t\tfinal Preferences props = Preferences.userNodeForPackage(PreferencesCommandLineTest.class);\n+\t\tprops.put(\"--present\",\"present value\");\n+\t\tprops.put(\"--alsopresent\",\"\");\n+\t\tprops.put(\"--multiple\",\"value 1|value 2|value 3\");\n+\t\tprops.put(\"--bool\",\"true\");\n+\t\t\n+\t\tprops.put(\"present\",\"present property\");\n+\t\t\n+\t\treturn new PreferencesCommandLine(root,props,'|');\n+\t}\n+\n+\tprotected CommandLine createCommandLineNoSep() {\n+\t\t// TODO Auto-generated method stub\n+\t\tfinal Preferences props = Preferences.userNodeForPackage(PreferencesCommandLineTest.class);\n+\t\tprops.put(\"--present\",\"present value\");\n+\t\tprops.put(\"--alsopresent\",\"\");\n+\t\tprops.put(\"--multiple\",\"value 1|value 2|value 3\");\n+\t\tprops.put(\"--bool\",\"false\");\n+\t\t\n+\t\tprops.put(\"present\",\"present property\");\n+\t\t\n+\t\treturn new PreferencesCommandLine(root,props);\n+\t}\n+\t\n+    public void testPropertyValues() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLine();\n+    \t\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));\n+    \tassertEquals(\"wrong # of values\", 3, cmdline.getValues(\"--multiple\").size());\n+    \tassertEquals(\"wrong value 1\", \"value 1\", cmdline.getValues(\"--multiple\").get(0));\n+    \tassertEquals(\"wrong value 2\", \"value 2\", cmdline.getValues(\"--multiple\").get(1));\n+    \tassertEquals(\"wrong value 3\", \"value 3\", cmdline.getValues(\"--multiple\").get(2));\n+    }\n+    \n+    public void testNoSeparator() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLineNoSep();\n+    \t\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));\n+    \tassertEquals(\"wrong # of values\", 1, cmdline.getValues(\"--multiple\").size());\n+    \tassertEquals(\"wrong value\", \"value 1|value 2|value 3\", cmdline.getValue(\"--multiple\"));\n+    \tassertFalse(\"expected a false\", cmdline.getSwitch(\"--bool\").booleanValue());\n+    }\n+    \n+    public void testNullOption() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLine();\n+\n+    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));\n+    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());\n+    }\n+\n+    public void testPreferenceTriggers() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLine();\n+\n+    \tSet triggers = cmdline.getOptionTriggers();\n+        Iterator iter = triggers.iterator();\n+        assertEquals(\"wrong # of triggers\", 4, triggers.size());\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--bool\"));\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--present\"));\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--multiple\"));\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--alsopresent\"));\n+    \t\n+    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));\n+    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/commandline/PropertiesCommandLineTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/PropertiesCommandLineTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.Iterator;import java.util.Properties;import java.util.Set;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.CommandLineTestCase;/** * @author Rob Oxspring */public class PropertiesCommandLineTest    extends CommandLineTestCase {    private Properties props = null;    protected CommandLine createCommandLine() {        props = new Properties();        props.setProperty(\"--present\", \"present value\");        props.setProperty(\"--alsopresent\", \"\");        props.setProperty(\"--multiple\", \"value 1|value 2|value 3\");        props.setProperty(\"--bool\", \"true\");        props.setProperty(\"present\", \"present property\");    \treturn new PropertiesCommandLine(root, props, '|');    }    protected CommandLine createCommandLineNoSep() {        props = new Properties();        props.setProperty(\"--present\", \"present value\");        props.setProperty(\"--alsopresent\", \"\");        props.setProperty(\"--multiple\", \"value 1|value 2|value 3\");        props.setProperty(\"--bool\", \"false\");        props.setProperty(\"present\", \"present property\");    \treturn new PropertiesCommandLine(root, props);    }    public void testPropertyValues() {        // nothing to test    \tCommandLine cmdline = createCommandLine();    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));    \tassertEquals(\"wrong # of values\", 3, cmdline.getValues(\"--multiple\").size());    \tassertEquals(\"wrong value 1\", \"value 1\", cmdline.getValues(\"--multiple\").get(0));    \tassertEquals(\"wrong value 2\", \"value 2\", cmdline.getValues(\"--multiple\").get(1));    \tassertEquals(\"wrong value 3\", \"value 3\", cmdline.getValues(\"--multiple\").get(2));    }    public void testNoSeparator() {        // nothing to test    \tCommandLine cmdline = createCommandLineNoSep();    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));    \tassertEquals(\"wrong # of values\", 1, cmdline.getValues(\"--multiple\").size());    \tassertEquals(\"wrong value\", \"value 1|value 2|value 3\", cmdline.getValue(\"--multiple\"));    \tassertFalse(\"expected a false\", cmdline.getSwitch(\"--bool\").booleanValue());    }    public void testNullOption() {        // nothing to test    \tCommandLine cmdline = createCommandLine();    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());    }    public void testPropertyTriggers() {        // nothing to test    \tCommandLine cmdline = createCommandLine();    \tSet triggers = cmdline.getOptionTriggers();        Iterator iter = triggers.iterator();        assertEquals(\"wrong # of triggers\", 4, triggers.size());        assertTrue(\"cannot find trigger\", triggers.contains(\"--bool\"));        assertTrue(\"cannot find trigger\", triggers.contains(\"--present\"));        assertTrue(\"cannot find trigger\", triggers.contains(\"--multiple\"));        assertTrue(\"cannot find trigger\", triggers.contains(\"--alsopresent\"));    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.Iterator;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.CommandLineTestCase;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class PropertiesCommandLineTest\n+    extends CommandLineTestCase {\n+    private Properties props = null;\n+\n+    protected CommandLine createCommandLine() {\n+        props = new Properties();\n+        props.setProperty(\"--present\", \"present value\");\n+        props.setProperty(\"--alsopresent\", \"\");\n+        props.setProperty(\"--multiple\", \"value 1|value 2|value 3\");\n+        props.setProperty(\"--bool\", \"true\");\n+\n+        props.setProperty(\"present\", \"present property\");\n+    \treturn new PropertiesCommandLine(root, props, '|');\n+    }\n+\n+    protected CommandLine createCommandLineNoSep() {\n+        props = new Properties();\n+        props.setProperty(\"--present\", \"present value\");\n+        props.setProperty(\"--alsopresent\", \"\");\n+        props.setProperty(\"--multiple\", \"value 1|value 2|value 3\");\n+        props.setProperty(\"--bool\", \"false\");\n+\n+        props.setProperty(\"present\", \"present property\");\n+    \treturn new PropertiesCommandLine(root, props);\n+    }\n+    \n+    public void testPropertyValues() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLine();\n+    \t\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));\n+    \tassertEquals(\"wrong # of values\", 3, cmdline.getValues(\"--multiple\").size());\n+    \tassertEquals(\"wrong value 1\", \"value 1\", cmdline.getValues(\"--multiple\").get(0));\n+    \tassertEquals(\"wrong value 2\", \"value 2\", cmdline.getValues(\"--multiple\").get(1));\n+    \tassertEquals(\"wrong value 3\", \"value 3\", cmdline.getValues(\"--multiple\").get(2));\n+    }\n+    \n+    public void testNoSeparator() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLineNoSep();\n+    \t\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--present\"));\n+    \tassertEquals(\"wrong value\", \"present value\", cmdline.getValue(\"--alsopresent\"));\n+    \tassertEquals(\"wrong # of values\", 1, cmdline.getValues(\"--multiple\").size());\n+    \tassertEquals(\"wrong value\", \"value 1|value 2|value 3\", cmdline.getValue(\"--multiple\"));\n+    \tassertFalse(\"expected a false\", cmdline.getSwitch(\"--bool\").booleanValue());\n+    }\n+    \n+    public void testNullOption() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLine();\n+\n+    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));\n+    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());\n+    }\n+\n+    public void testPropertyTriggers() {\n+        // nothing to test\n+    \tCommandLine cmdline = createCommandLine();\n+\n+    \tSet triggers = cmdline.getOptionTriggers();\n+        Iterator iter = triggers.iterator();\n+        assertEquals(\"wrong # of triggers\", 4, triggers.size());\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--bool\"));\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--present\"));\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--multiple\"));\n+        assertTrue(\"cannot find trigger\", triggers.contains(\"--alsopresent\"));\n+    \t\n+    \tassertFalse(\"should not find null option\", cmdline.hasOption((String) null));\n+    \tassertTrue(\"expected a true\", cmdline.getSwitch(\"--bool\").booleanValue());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/commandline/WriteableCommandLineImplTest.java\n+++ b/src/test/org/apache/commons/cli2/commandline/WriteableCommandLineImplTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.commandline;import java.util.ArrayList;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.WriteableCommandLineTestCase;public class WriteableCommandLineImplTest    extends WriteableCommandLineTestCase {    /* (non-Javadoc)     * @see org.apache.commons.cli2.WriteableCommandLineTest#createWriteableCommandLine()     */    protected WriteableCommandLine createWriteableCommandLine() {        return new WriteableCommandLineImpl(root, new ArrayList());    }    public void testToMakeEclipseSpotTheTestCase() {        // nothing to test    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.commandline;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.WriteableCommandLineTestCase;\n+\n+public class WriteableCommandLineImplTest\n+    extends WriteableCommandLineTestCase {\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.WriteableCommandLineTest#createWriteableCommandLine()\n+     */\n+    protected WriteableCommandLine createWriteableCommandLine() {\n+        return new WriteableCommandLineImpl(root, new ArrayList());\n+    }\n+\n+    public void testToMakeEclipseSpotTheTestCase() {\n+        // nothing to test\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/jdepend/JDependTest.java\n+++ b/src/test/org/apache/commons/cli2/jdepend/JDependTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.jdepend;import java.io.IOException;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import jdepend.framework.JDepend;import jdepend.framework.JavaPackage;import junit.framework.TestCase;/** * @author Rob Oxspring */public class JDependTest extends TestCase {    private JDepend dependancies = null;    public void setUp() throws IOException {        dependancies = new JDepend();        dependancies.addDirectory(\"target/classes\");        dependancies.analyze();    }    public void testJUnitNotPresent() {        // if junit dependancy is found then jdepend has been poluted        // with test classes and all tests are meaningless        assertNull(            \"JUnit dependancy found\",            dependancies.getPackage(\"junit.framework\"));        // the same applies to jdepend        assertNull(            \"JDepend dependancy found\",            dependancies.getPackage(\"jdepend.framework\"));    }    public void testAcceptableDistance() {        Collection packages = dependancies.getPackages();        // only interested in cli2        packages = cli2Packages(packages);        // resources is well off the line        packages =            namedPackages(packages, \"org.apache.commons.cli2.resource\", false);        for (final Iterator i = packages.iterator(); i.hasNext();) {            final JavaPackage pkg = (JavaPackage)i.next();            final float distance = pkg.distance();            final String message = pkg.getName() + \" too far from line: \" + distance;            assertTrue(                message,                distance < 0.21d);        }    }    public void testNoCyclesPresent() {        assertEquals(\"Cycles exist\", false, dependancies.containsCycles());    }    public void testApiIndependance() {        dependancies.analyze();        final JavaPackage apiPackage =            dependancies.getPackage(\"org.apache.commons.cli2\");        final Collection dependsUpon = cli2Packages(apiPackage.getEfferents());        assertEquals(\"Api should depend on one package\", 1, dependsUpon.size());        JavaPackage pkg = (JavaPackage) dependsUpon.iterator().next();        assertEquals(                \"Wrong package name\",                \"org.apache.commons.cli2.resource\",                pkg.getName());    }    private Collection cli2Packages(final Collection incoming) {        return namedPackages(incoming, \"org.apache.commons.cli2\", true);    }    private Collection namedPackages(        final Collection incoming,        final String name,        final boolean include) {        final Collection outgoing = new ArrayList();        for (final Iterator i = incoming.iterator(); i.hasNext();) {            final JavaPackage pkg = (JavaPackage)i.next();            if (include ^ !pkg.getName().startsWith(name)) {                outgoing.add(pkg);            }        }        return outgoing;    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.jdepend;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import jdepend.framework.JDepend;\n+import jdepend.framework.JavaPackage;\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class JDependTest extends TestCase {\n+\n+    private JDepend dependancies = null;\n+\n+    public void setUp() throws IOException {\n+        dependancies = new JDepend();\n+        dependancies.addDirectory(\"target/classes\");\n+        dependancies.analyze();\n+    }\n+\n+    public void testJUnitNotPresent() {\n+        // if junit dependancy is found then jdepend has been poluted\n+        // with test classes and all tests are meaningless\n+        assertNull(\n+            \"JUnit dependancy found\",\n+            dependancies.getPackage(\"junit.framework\"));\n+\n+        // the same applies to jdepend\n+        assertNull(\n+            \"JDepend dependancy found\",\n+            dependancies.getPackage(\"jdepend.framework\"));\n+    }\n+\n+    public void testAcceptableDistance() {\n+        Collection packages = dependancies.getPackages();\n+        // only interested in cli2\n+        packages = cli2Packages(packages);\n+        // resources is well off the line\n+        packages =\n+            namedPackages(packages, \"org.apache.commons.cli2.resource\", false);\n+\n+        for (final Iterator i = packages.iterator(); i.hasNext();) {\n+            final JavaPackage pkg = (JavaPackage)i.next();\n+            final float distance = pkg.distance();\n+            final String message = pkg.getName() + \" too far from line: \" + distance;\n+            assertTrue(\n+                message,\n+                distance < 0.21d);\n+        }\n+    }\n+\n+    public void testNoCyclesPresent() {\n+        assertEquals(\"Cycles exist\", false, dependancies.containsCycles());\n+    }\n+\n+    public void testApiIndependance() {\n+        dependancies.analyze();\n+\n+        final JavaPackage apiPackage =\n+            dependancies.getPackage(\"org.apache.commons.cli2\");\n+        final Collection dependsUpon = cli2Packages(apiPackage.getEfferents());\n+\n+        assertEquals(\"Api should depend on one package\", 1, dependsUpon.size());\n+        \n+        JavaPackage pkg = (JavaPackage) dependsUpon.iterator().next();\n+        assertEquals(\n+                \"Wrong package name\", \n+                \"org.apache.commons.cli2.resource\",\n+                pkg.getName());\n+    }\n+\n+    private Collection cli2Packages(final Collection incoming) {\n+        return namedPackages(incoming, \"org.apache.commons.cli2\", true);\n+    }\n+\n+    private Collection namedPackages(\n+        final Collection incoming,\n+        final String name,\n+        final boolean include) {\n+        final Collection outgoing = new ArrayList();\n+        for (final Iterator i = incoming.iterator(); i.hasNext();) {\n+            final JavaPackage pkg = (JavaPackage)i.next();\n+            if (include ^ !pkg.getName().startsWith(name)) {\n+                outgoing.add(pkg);\n+            }\n+        }\n+        return outgoing;\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/ArgumentTest.java\n+++ b/src/test/org/apache/commons/cli2/option/ArgumentTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.text.ParseException;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;import org.apache.commons.cli2.validation.DateValidator;import org.apache.commons.cli2.validation.DateValidatorTest;/** * @author Rob Oxspring */public class ArgumentTest    extends ArgumentTestCase {    private ResourceHelper resources = ResourceHelper.getResourceHelper();    public static Argument buildUsernameArgument() {        return new ArgumentImpl(\"username\", \"The user to connect as\", 1, 1, '\\0', '\\0', null,                                ArgumentImpl.DEFAULT_CONSUME_REMAINING, null, 0);    }    public static Argument buildHostArgument() {        return new ArgumentImpl(\"host\", \"The host name\", 2, 3, '\\0', ',', null, null, null, 0);    }    public static Argument buildPathArgument() {        return new ArgumentImpl(\"path\", \"The place to look for files\", 1, Integer.MAX_VALUE, '=',                                ';', null, ArgumentImpl.DEFAULT_CONSUME_REMAINING, null, 0);    }    public static Argument buildDateLimitArgument() {        return new ArgumentImpl(\"limit\", \"the last acceptable date\", 0, 1, '=', '\\0',                                new DateValidator(DateValidatorTest.YYYY_MM_DD), null, null, 0);    }    public static Argument buildTargetsArgument() {        return new ArgumentImpl(\"target\", \"The targets ant should build\", 0, Integer.MAX_VALUE,                                '\\0', ',', null, null, null, 0);    }    public static Argument buildSizeArgument() {        List defaults = new ArrayList();        defaults.add(\"10\");        return new ArgumentImpl(\"size\", \"The number of units\", 1, 1, '\\0', '\\0', null,                                ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);    }    public static Argument buildBoundsArgument() {        List defaults = new ArrayList();        defaults.add(\"5\");        defaults.add(\"10\");        return new ArgumentImpl(\"size\", \"The number of units\", 2, 2, '\\0', '\\0', null,                                ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);    }    public void testNew() {        try {            new ArgumentImpl(\"limit\", \"the last acceptable date\", 10, 5, '=', '\\0',                             new DateValidator(DateValidatorTest.YYYY_MM_DD), null, null, 0);        } catch (IllegalArgumentException e) {            assertEquals(resources.getMessage(\"Argument.minimum.exceeds.maximum\"), e.getMessage());        }        {            ArgumentImpl arg =                new ArgumentImpl(null, \"the last acceptable date\", 5, 5, '=', '\\0',                                 new DateValidator(DateValidatorTest.YYYY_MM_DD), null, null, 0);            assertEquals(\"wrong arg name\", \"arg\", arg.getPreferredName());        }        {            List defaults = new ArrayList();            try {                new ArgumentImpl(null, \"the last acceptable date\", 1, 1, '=', '\\0',                                 new DateValidator(DateValidatorTest.YYYY_MM_DD), null, defaults, 0);            } catch (IllegalArgumentException exp) {                assertEquals(resources.getMessage(\"Argument.too.few.defaults\"), exp.getMessage());            }        }        try {            List defaults = new ArrayList();            defaults.add(\"1\");            defaults.add(\"2\");            new ArgumentImpl(null, \"the last acceptable date\", 1, 1, '=', '\\0',                             new DateValidator(DateValidatorTest.YYYY_MM_DD), null, defaults, 0);        } catch (IllegalArgumentException exp) {            assertEquals(resources.getMessage(\"Argument.too.many.defaults\"), exp.getMessage());        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.ArgumentTestCase#testProcessValues()     */    public void testProcessValues()        throws OptionException {        final Argument option = buildUsernameArgument();        final List args = list(\"rob\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processValues(commandLine, iterator, option);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"username\"));        assertEquals(\"rob\", commandLine.getValue(option));    }    public void testProcessValues_BoundaryQuotes()        throws OptionException {        final Argument option = buildUsernameArgument();        final List args = list(\"\\\"rob\\\"\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processValues(commandLine, iterator, option);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"username\"));        assertEquals(\"rob\", commandLine.getValue(option));    }    public void testProcessValues_SpareValues()        throws OptionException {        final Argument option = buildUsernameArgument();        final List args = list(\"rob\", \"secret\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processValues(commandLine, iterator, option);        assertTrue(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"username\"));        assertEquals(\"rob\", commandLine.getValue(option));    }    public void testProcessValues_Optional() {        final Argument option = buildTargetsArgument();        final List args = list();        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        try {            option.processValues(commandLine, iterator, option);        } catch (final OptionException mve) {            assertEquals(option, mve.getOption());            assertEquals(\"Missing value(s) target [target ...]\", mve.getMessage());        }        assertFalse(iterator.hasNext());        assertFalse(commandLine.hasOption(option));        assertFalse(commandLine.hasOption(\"username\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    public void testProcessValues_Multiple()        throws OptionException {        final Argument option = buildTargetsArgument();        final List args = list(\"compile\", \"test\", \"docs\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processValues(commandLine, iterator, option);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"target\"));        assertFalse(commandLine.getValues(option).isEmpty());        assertListContentsEqual(args, commandLine.getValues(option));    }    public void testProcessValues_Contracted()        throws OptionException {        final Argument option = buildTargetsArgument();        final List args = list(\"compile,test,javadoc\", \"checkstyle,jdepend\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processValues(commandLine, iterator, option);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"target\"));        assertListContentsEqual(list(\"compile\", \"test\", \"javadoc\", \"checkstyle\", \"jdepend\"),                                commandLine.getValues(option));    }    public void testProcessValues_ContractedTooFew() {        final Argument option = buildHostArgument();        final List args = list(\"box1\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        try {            option.processValues(commandLine, iterator, option);            option.validate(commandLine);            fail(\"Expected MissingValueException\");        } catch (OptionException mve) {            assertSame(option, mve.getOption());        }    }    public void testProcessValues_ContractedTooMany() {        final Argument option = buildHostArgument();        final List args = list(\"box1,box2,box3,box4\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        try {            option.processValues(commandLine, iterator, option);            option.validate(commandLine);            fail(\"Expected MissingValueException\");        } catch (OptionException mve) {            assertSame(option, mve.getOption());        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()     */    public void testCanProcess() {        final Argument option = buildTargetsArgument();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"any value\"));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()     */    public void testPrefixes() {        final Argument option = buildTargetsArgument();        assertTrue(option.getPrefixes().isEmpty());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testProcess()     */    public void testProcess()        throws OptionException {        final Argument option = buildPathArgument();        final List args = list(\"-path=/lib;/usr/lib;/usr/local/lib\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"path\"));        assertListContentsEqual(list(\"-path=/lib\", \"/usr/lib\", \"/usr/local/lib\"),                                commandLine.getValues(option));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()     */    public void testTriggers() {        final Argument option = buildTargetsArgument();        assertTrue(option.getTriggers().isEmpty());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testValidate()     */    public void testValidate()        throws OptionException {        final Argument option = buildUsernameArgument();        final WriteableCommandLine commandLine = commandLine(option, list());        commandLine.addValue(option, \"rob\");        option.validate(commandLine);    }    public void testValidate_Minimum() {        final Argument option = buildUsernameArgument();        final WriteableCommandLine commandLine = commandLine(option, list());        try {            option.validate(commandLine);            fail(\"UnexpectedValue\");        } catch (OptionException mve) {            assertEquals(option, mve.getOption());        }    }    public void testRequired() {        {            final Argument arg = buildBoundsArgument();            assertTrue(\"not required\", arg.isRequired());        }        {            final Argument arg = buildTargetsArgument();            assertFalse(\"should not be required\", arg.isRequired());        }    }    public void testValidate_Maximum() {        final Argument option = buildUsernameArgument();        final WriteableCommandLine commandLine = commandLine(option, list());        commandLine.addValue(option, \"rob\");        commandLine.addValue(option, \"oxspring\");        try {            option.validate(commandLine);            fail(\"UnexpectedValue\");        } catch (OptionException uve) {            assertEquals(option, uve.getOption());        }    }    public void testValidate_Validator()        throws OptionException, ParseException {        final Argument option = buildDateLimitArgument();        final WriteableCommandLine commandLine = commandLine(option, list());        commandLine.addValue(option, \"2004-01-01\");        option.validate(commandLine, option);        assertContentsEqual(Arrays.asList(new Object[] {                                              DateValidatorTest.YYYY_MM_DD.parse(\"2004-01-01\")                                          }), commandLine.getValues(option));    }    public void testValidate_ValidatorInvalidDate()        throws OptionException, ParseException {        final Argument option = buildDateLimitArgument();        final WriteableCommandLine commandLine = commandLine(option, list());        commandLine.addValue(option, \"12-12-2004\");        try {            option.validate(commandLine, option);        } catch (OptionException exp) {            OptionException e =                new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,                                    \"12-12-2004\");            assertEquals(\"wrong exception message\", e.getMessage(), exp.getMessage());        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()     */    public void testAppendUsage() {        final Option option = buildUsernameArgument();        final StringBuffer buffer = new StringBuffer();        option.appendUsage(buffer, DisplaySetting.ALL, null);        assertEquals(\"<username>\", buffer.toString());    }    public void testAppendUsage_Infinite() {        final Option option = buildTargetsArgument();        final StringBuffer buffer = new StringBuffer();        option.appendUsage(buffer, DisplaySetting.ALL, null);        assertEquals(\"[<target1> [<target2> ...]]\", buffer.toString());    }    public void testAppendUsage_InfiniteNoOptional() {        final Option option = buildTargetsArgument();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);        option.appendUsage(buffer, settings, null);        assertEquals(\"<target1> [<target2> ...]\", buffer.toString());    }    public void testAppendUsage_InfiniteNoNumbering() {        final Option option = buildTargetsArgument();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);        option.appendUsage(buffer, settings, null);        assertEquals(\"[<target> [<target> ...]]\", buffer.toString());    }    public void testAppendUsage_Minimum() {        final Option option = buildHostArgument();        final StringBuffer buffer = new StringBuffer();        option.appendUsage(buffer, DisplaySetting.ALL, null);        assertEquals(\"<host1> <host2> [<host3>]\", buffer.toString());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()     */    public void testGetPreferredName() {        final Option option = buildPathArgument();        assertEquals(\"path\", option.getPreferredName());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()     */    public void testGetDescription() {        final Option option = buildHostArgument();        assertEquals(\"The host name\", option.getDescription());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines() {        final Option option = buildHostArgument();        final List lines = option.helpLines(0, DisplaySetting.ALL, null);        final Iterator i = lines.iterator();        final HelpLine line1 = (HelpLine) i.next();        assertEquals(0, line1.getIndent());        assertEquals(option, line1.getOption());        assertFalse(i.hasNext());    }    public void testCanProcess_ConsumeRemaining() {        final Option option = buildUsernameArgument();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"--\"));    }    public void testProcess_ConsumeRemaining()        throws OptionException {        final Option option = buildPathArgument();        final List args = list(\"options\", \"--\", \"--ignored\", \"-Dprop=val\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        final List values = commandLine.getValues(option);        assertTrue(values.contains(\"options\"));        assertTrue(values.contains(\"--ignored\"));        assertTrue(values.contains(\"-Dprop=val\"));        assertEquals(3, values.size());        assertFalse(iterator.hasNext());    }    public void testProcess_ConsumeNothing() {        final Option option = buildPathArgument();        final List args = list(\"--\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        try {            option.process(commandLine, iterator);            option.validate(commandLine);            fail(\"Missing Value!\");        } catch (OptionException mve) {            assertEquals(option, mve.getOption());            assertEquals(\"Missing value(s) path [path ...]\", mve.getMessage());        }        assertTrue(commandLine.getValues(option).isEmpty());        assertFalse(iterator.hasNext());    }    //    public void testProcess_DefinedDefaultValue() throws OptionException {    //        final Option size = buildSizeArgument();    //        final List args = list();    //        final WriteableCommandLine commandLine = commandLine(size, args);    //        final ListIterator iterator = args.listIterator();    //    //        size.process(commandLine, iterator);    //    //        assertEquals(\"10\", commandLine.getValue(size));    //    }    //    //    public void testProcess_DefinedDefaultValues() throws OptionException {    //        final Option bounds = buildBoundsArgument();    //        final List args = list();    //        final WriteableCommandLine commandLine = commandLine(bounds, args);    //        final ListIterator iterator = args.listIterator();    //    //        bounds.process(commandLine, iterator);    //    //        List values = new ArrayList();    //        values.add(\"5\");    //        values.add(\"10\");    //        assertEquals(values, commandLine.getValues(bounds));    //    }    public void testProcess_InterrogatedDefaultValue()        throws OptionException {        final Option size = buildSizeArgument();        final List args = list();        final WriteableCommandLine commandLine = commandLine(size, args);        final ListIterator iterator = args.listIterator();        size.process(commandLine, iterator);        assertEquals(new Integer(20), commandLine.getValue(size, new Integer(20)));    }    public void testTooFewDefaults() {        List defaults = new ArrayList();        defaults.add(\"5\");        try {            new ArgumentImpl(\"size\", \"The number of units\", 2, 2, '\\0', '\\0', null,                             ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS),                         exp.getMessage());        }    }    public void testTooManyDefaults() {        List defaults = new ArrayList();        defaults.add(\"5\");        defaults.add(\"10\");        defaults.add(\"15\");        try {            new ArgumentImpl(\"size\", \"The number of units\", 2, 2, '\\0', '\\0', null,                             ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS),                         exp.getMessage());        }    }    public void testProcess_InterrogatedDefaultValues()        throws OptionException {        final Option bounds = buildBoundsArgument();        final List args = list();        final WriteableCommandLine commandLine = commandLine(bounds, args);        final ListIterator iterator = args.listIterator();        bounds.process(commandLine, iterator);        // test with values        List values = new ArrayList();        values.add(\"50\");        values.add(\"100\");        assertEquals(values, commandLine.getValues(bounds, values));        // test without values        assertEquals(Collections.EMPTY_LIST, commandLine.getValues(bounds, null));    }    public void testProcess_StripBoundaryQuotes()        throws OptionException {        final Option bounds = buildBoundsArgument();        final List args = list();        final WriteableCommandLine commandLine = commandLine(bounds, args);        final ListIterator iterator = args.listIterator();        bounds.process(commandLine, iterator);        List values = new ArrayList();        values.add(\"50\\\"\");        values.add(\"\\\"100\");        assertEquals(values, commandLine.getValues(bounds, values));    }    public void testSourceDestArgument() {        final ArgumentBuilder abuilder = new ArgumentBuilder();        final GroupBuilder gbuilder = new GroupBuilder();        final Argument inputfiles =            abuilder.withName(\"input\").withMinimum(0).withMaximum(0).create();        final Argument bad_outputfile =            abuilder.withName(\"output\").withMinimum(1).withMaximum(2).create();        try {            final Argument targets = new SourceDestArgument(inputfiles, bad_outputfile);        } catch (final IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SOURCE_DEST_MUST_ENFORCE_VALUES),                         exp.getMessage());        }        final Argument outputfile =            abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();        final Argument targets = new SourceDestArgument(inputfiles, outputfile);        final StringBuffer buffer = new StringBuffer(\"test content\");        targets.appendUsage(buffer, Collections.EMPTY_SET, null);        assertTrue(\"buffer not added\", buffer.toString().startsWith(\"test content\"));        assertFalse(\"space added\", buffer.charAt(12) == ' ');    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.text.ParseException;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+import org.apache.commons.cli2.validation.DateValidator;\n+import org.apache.commons.cli2.validation.DateValidatorTest;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class ArgumentTest\n+    extends ArgumentTestCase {\n+    private ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    public static Argument buildUsernameArgument() {\n+        return new ArgumentImpl(\"username\", \"The user to connect as\", 1, 1, '\\0', '\\0', null,\n+                                ArgumentImpl.DEFAULT_CONSUME_REMAINING, null, 0);\n+    }\n+\n+    public static Argument buildHostArgument() {\n+        return new ArgumentImpl(\"host\", \"The host name\", 2, 3, '\\0', ',', null, null, null, 0);\n+    }\n+\n+    public static Argument buildPathArgument() {\n+        return new ArgumentImpl(\"path\", \"The place to look for files\", 1, Integer.MAX_VALUE, '=',\n+                                ';', null, ArgumentImpl.DEFAULT_CONSUME_REMAINING, null, 0);\n+    }\n+\n+    public static Argument buildDateLimitArgument() {\n+        return new ArgumentImpl(\"limit\", \"the last acceptable date\", 0, 1, '=', '\\0',\n+                                new DateValidator(DateValidatorTest.YYYY_MM_DD), null, null, 0);\n+    }\n+\n+    public static Argument buildTargetsArgument() {\n+        return new ArgumentImpl(\"target\", \"The targets ant should build\", 0, Integer.MAX_VALUE,\n+                                '\\0', ',', null, null, null, 0);\n+    }\n+\n+    public static Argument buildSizeArgument() {\n+        List defaults = new ArrayList();\n+        defaults.add(\"10\");\n+\n+        return new ArgumentImpl(\"size\", \"The number of units\", 1, 1, '\\0', '\\0', null,\n+                                ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);\n+    }\n+\n+    public static Argument buildBoundsArgument() {\n+        List defaults = new ArrayList();\n+        defaults.add(\"5\");\n+        defaults.add(\"10\");\n+\n+        return new ArgumentImpl(\"size\", \"The number of units\", 2, 2, '\\0', '\\0', null,\n+                                ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);\n+    }\n+\n+    public void testNew() {\n+        try {\n+            new ArgumentImpl(\"limit\", \"the last acceptable date\", 10, 5, '=', '\\0',\n+                             new DateValidator(DateValidatorTest.YYYY_MM_DD), null, null, 0);\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(\"Argument.minimum.exceeds.maximum\"), e.getMessage());\n+        }\n+\n+        {\n+            ArgumentImpl arg =\n+                new ArgumentImpl(null, \"the last acceptable date\", 5, 5, '=', '\\0',\n+                                 new DateValidator(DateValidatorTest.YYYY_MM_DD), null, null, 0);\n+            assertEquals(\"wrong arg name\", \"arg\", arg.getPreferredName());\n+        }\n+\n+        {\n+            List defaults = new ArrayList();\n+\n+            try {\n+                new ArgumentImpl(null, \"the last acceptable date\", 1, 1, '=', '\\0',\n+                                 new DateValidator(DateValidatorTest.YYYY_MM_DD), null, defaults, 0);\n+            } catch (IllegalArgumentException exp) {\n+                assertEquals(resources.getMessage(\"Argument.too.few.defaults\"), exp.getMessage());\n+            }\n+        }\n+\n+        try {\n+            List defaults = new ArrayList();\n+            defaults.add(\"1\");\n+            defaults.add(\"2\");\n+\n+            new ArgumentImpl(null, \"the last acceptable date\", 1, 1, '=', '\\0',\n+                             new DateValidator(DateValidatorTest.YYYY_MM_DD), null, defaults, 0);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(resources.getMessage(\"Argument.too.many.defaults\"), exp.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.ArgumentTestCase#testProcessValues()\n+     */\n+    public void testProcessValues()\n+        throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final List args = list(\"rob\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"username\"));\n+        assertEquals(\"rob\", commandLine.getValue(option));\n+    }\n+\n+    public void testProcessValues_BoundaryQuotes()\n+        throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final List args = list(\"\\\"rob\\\"\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"username\"));\n+        assertEquals(\"rob\", commandLine.getValue(option));\n+    }\n+\n+    public void testProcessValues_SpareValues()\n+        throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final List args = list(\"rob\", \"secret\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertTrue(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"username\"));\n+        assertEquals(\"rob\", commandLine.getValue(option));\n+    }\n+\n+    public void testProcessValues_Optional() {\n+        final Argument option = buildTargetsArgument();\n+        final List args = list();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.processValues(commandLine, iterator, option);\n+        } catch (final OptionException mve) {\n+            assertEquals(option, mve.getOption());\n+            assertEquals(\"Missing value(s) target [target ...]\", mve.getMessage());\n+        }\n+\n+        assertFalse(iterator.hasNext());\n+        assertFalse(commandLine.hasOption(option));\n+        assertFalse(commandLine.hasOption(\"username\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessValues_Multiple()\n+        throws OptionException {\n+        final Argument option = buildTargetsArgument();\n+        final List args = list(\"compile\", \"test\", \"docs\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"target\"));\n+        assertFalse(commandLine.getValues(option).isEmpty());\n+        assertListContentsEqual(args, commandLine.getValues(option));\n+    }\n+\n+    public void testProcessValues_Contracted()\n+        throws OptionException {\n+        final Argument option = buildTargetsArgument();\n+        final List args = list(\"compile,test,javadoc\", \"checkstyle,jdepend\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processValues(commandLine, iterator, option);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"target\"));\n+        assertListContentsEqual(list(\"compile\", \"test\", \"javadoc\", \"checkstyle\", \"jdepend\"),\n+                                commandLine.getValues(option));\n+    }\n+\n+    public void testProcessValues_ContractedTooFew() {\n+        final Argument option = buildHostArgument();\n+        final List args = list(\"box1\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.processValues(commandLine, iterator, option);\n+            option.validate(commandLine);\n+            fail(\"Expected MissingValueException\");\n+        } catch (OptionException mve) {\n+            assertSame(option, mve.getOption());\n+        }\n+    }\n+\n+    public void testProcessValues_ContractedTooMany() {\n+        final Argument option = buildHostArgument();\n+        final List args = list(\"box1,box2,box3,box4\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.processValues(commandLine, iterator, option);\n+            option.validate(commandLine);\n+            fail(\"Expected MissingValueException\");\n+        } catch (OptionException mve) {\n+            assertSame(option, mve.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Argument option = buildTargetsArgument();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"any value\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Argument option = buildTargetsArgument();\n+        assertTrue(option.getPrefixes().isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess()\n+        throws OptionException {\n+        final Argument option = buildPathArgument();\n+        final List args = list(\"-path=/lib;/usr/lib;/usr/local/lib\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"path\"));\n+        assertListContentsEqual(list(\"-path=/lib\", \"/usr/lib\", \"/usr/local/lib\"),\n+                                commandLine.getValues(option));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Argument option = buildTargetsArgument();\n+        assertTrue(option.getTriggers().isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate()\n+        throws OptionException {\n+        final Argument option = buildUsernameArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addValue(option, \"rob\");\n+\n+        option.validate(commandLine);\n+    }\n+\n+    public void testValidate_Minimum() {\n+        final Argument option = buildUsernameArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"UnexpectedValue\");\n+        } catch (OptionException mve) {\n+            assertEquals(option, mve.getOption());\n+        }\n+    }\n+\n+    public void testRequired() {\n+        {\n+            final Argument arg = buildBoundsArgument();\n+\n+            assertTrue(\"not required\", arg.isRequired());\n+        }\n+\n+        {\n+            final Argument arg = buildTargetsArgument();\n+\n+            assertFalse(\"should not be required\", arg.isRequired());\n+        }\n+    }\n+\n+    public void testValidate_Maximum() {\n+        final Argument option = buildUsernameArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addValue(option, \"rob\");\n+        commandLine.addValue(option, \"oxspring\");\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"UnexpectedValue\");\n+        } catch (OptionException uve) {\n+            assertEquals(option, uve.getOption());\n+        }\n+    }\n+\n+    public void testValidate_Validator()\n+        throws OptionException, ParseException {\n+        final Argument option = buildDateLimitArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addValue(option, \"2004-01-01\");\n+\n+        option.validate(commandLine, option);\n+        assertContentsEqual(Arrays.asList(new Object[] {\n+                                              DateValidatorTest.YYYY_MM_DD.parse(\"2004-01-01\")\n+                                          }), commandLine.getValues(option));\n+    }\n+\n+    public void testValidate_ValidatorInvalidDate()\n+        throws OptionException, ParseException {\n+        final Argument option = buildDateLimitArgument();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addValue(option, \"12-12-2004\");\n+\n+        try {\n+            option.validate(commandLine, option);\n+        } catch (OptionException exp) {\n+            OptionException e =\n+                new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n+                                    \"12-12-2004\");\n+            assertEquals(\"wrong exception message\", e.getMessage(), exp.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildUsernameArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"<username>\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_Infinite() {\n+        final Option option = buildTargetsArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"[<target1> [<target2> ...]]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_InfiniteNoOptional() {\n+        final Option option = buildTargetsArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"<target1> [<target2> ...]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_InfiniteNoNumbering() {\n+        final Option option = buildTargetsArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[<target> [<target> ...]]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_Minimum() {\n+        final Option option = buildHostArgument();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"<host1> <host2> [<host3>]\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildPathArgument();\n+        assertEquals(\"path\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildHostArgument();\n+        assertEquals(\"The host name\", option.getDescription());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        final Option option = buildHostArgument();\n+        final List lines = option.helpLines(0, DisplaySetting.ALL, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine) i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testCanProcess_ConsumeRemaining() {\n+        final Option option = buildUsernameArgument();\n+\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"--\"));\n+    }\n+\n+    public void testProcess_ConsumeRemaining()\n+        throws OptionException {\n+        final Option option = buildPathArgument();\n+        final List args = list(\"options\", \"--\", \"--ignored\", \"-Dprop=val\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+\n+        final List values = commandLine.getValues(option);\n+        assertTrue(values.contains(\"options\"));\n+        assertTrue(values.contains(\"--ignored\"));\n+        assertTrue(values.contains(\"-Dprop=val\"));\n+        assertEquals(3, values.size());\n+        assertFalse(iterator.hasNext());\n+    }\n+\n+    public void testProcess_ConsumeNothing() {\n+        final Option option = buildPathArgument();\n+        final List args = list(\"--\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.process(commandLine, iterator);\n+            option.validate(commandLine);\n+            fail(\"Missing Value!\");\n+        } catch (OptionException mve) {\n+            assertEquals(option, mve.getOption());\n+            assertEquals(\"Missing value(s) path [path ...]\", mve.getMessage());\n+        }\n+\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+        assertFalse(iterator.hasNext());\n+    }\n+\n+    //    public void testProcess_DefinedDefaultValue() throws OptionException {\n+    //        final Option size = buildSizeArgument();\n+    //        final List args = list();\n+    //        final WriteableCommandLine commandLine = commandLine(size, args);\n+    //        final ListIterator iterator = args.listIterator();\n+    //\n+    //        size.process(commandLine, iterator);\n+    //\n+    //        assertEquals(\"10\", commandLine.getValue(size));\n+    //    }\n+    //\n+    //    public void testProcess_DefinedDefaultValues() throws OptionException {\n+    //        final Option bounds = buildBoundsArgument();\n+    //        final List args = list();\n+    //        final WriteableCommandLine commandLine = commandLine(bounds, args);\n+    //        final ListIterator iterator = args.listIterator();\n+    //\n+    //        bounds.process(commandLine, iterator);\n+    //\n+    //        List values = new ArrayList();\n+    //        values.add(\"5\");\n+    //        values.add(\"10\");\n+    //        assertEquals(values, commandLine.getValues(bounds));\n+    //    }\n+    public void testProcess_InterrogatedDefaultValue()\n+        throws OptionException {\n+        final Option size = buildSizeArgument();\n+        final List args = list();\n+        final WriteableCommandLine commandLine = commandLine(size, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        size.process(commandLine, iterator);\n+\n+        assertEquals(new Integer(20), commandLine.getValue(size, new Integer(20)));\n+    }\n+\n+    public void testTooFewDefaults() {\n+        List defaults = new ArrayList();\n+        defaults.add(\"5\");\n+\n+        try {\n+            new ArgumentImpl(\"size\", \"The number of units\", 2, 2, '\\0', '\\0', null,\n+                             ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testTooManyDefaults() {\n+        List defaults = new ArrayList();\n+        defaults.add(\"5\");\n+        defaults.add(\"10\");\n+        defaults.add(\"15\");\n+\n+        try {\n+            new ArgumentImpl(\"size\", \"The number of units\", 2, 2, '\\0', '\\0', null,\n+                             ArgumentImpl.DEFAULT_CONSUME_REMAINING, defaults, 0);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testProcess_InterrogatedDefaultValues()\n+        throws OptionException {\n+        final Option bounds = buildBoundsArgument();\n+        final List args = list();\n+        final WriteableCommandLine commandLine = commandLine(bounds, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        bounds.process(commandLine, iterator);\n+\n+        // test with values\n+        List values = new ArrayList();\n+        values.add(\"50\");\n+        values.add(\"100\");\n+        assertEquals(values, commandLine.getValues(bounds, values));\n+\n+        // test without values\n+        assertEquals(Collections.EMPTY_LIST, commandLine.getValues(bounds, null));\n+    }\n+\n+    public void testProcess_StripBoundaryQuotes()\n+        throws OptionException {\n+        final Option bounds = buildBoundsArgument();\n+        final List args = list();\n+        final WriteableCommandLine commandLine = commandLine(bounds, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        bounds.process(commandLine, iterator);\n+\n+        List values = new ArrayList();\n+        values.add(\"50\\\"\");\n+        values.add(\"\\\"100\");\n+        assertEquals(values, commandLine.getValues(bounds, values));\n+    }\n+\n+    public void testSourceDestArgument() {\n+        final ArgumentBuilder abuilder = new ArgumentBuilder();\n+        final GroupBuilder gbuilder = new GroupBuilder();\n+        final Argument inputfiles =\n+            abuilder.withName(\"input\").withMinimum(0).withMaximum(0).create();\n+        final Argument bad_outputfile =\n+            abuilder.withName(\"output\").withMinimum(1).withMaximum(2).create();\n+\n+        try {\n+            final Argument targets = new SourceDestArgument(inputfiles, bad_outputfile);\n+        } catch (final IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SOURCE_DEST_MUST_ENFORCE_VALUES),\n+                         exp.getMessage());\n+        }\n+\n+        final Argument outputfile =\n+            abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();\n+\n+        final Argument targets = new SourceDestArgument(inputfiles, outputfile);\n+        final StringBuffer buffer = new StringBuffer(\"test content\");\n+        targets.appendUsage(buffer, Collections.EMPTY_SET, null);\n+\n+        assertTrue(\"buffer not added\", buffer.toString().startsWith(\"test content\"));\n+        assertFalse(\"space added\", buffer.charAt(12) == ' ');\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/ArgumentTestCase.java\n+++ b/src/test/org/apache/commons/cli2/option/ArgumentTestCase.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import org.apache.commons.cli2.OptionException;/** * @author Rob Oxspring */public abstract class ArgumentTestCase extends OptionTestCase {    public abstract void testProcessValues() throws OptionException;}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import org.apache.commons.cli2.OptionException;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class ArgumentTestCase extends OptionTestCase {\n+\n+    public abstract void testProcessValues() throws OptionException;\n+\n+}\n--- a/src/test/org/apache/commons/cli2/option/CommandTest.java\n+++ b/src/test/org/apache/commons/cli2/option/CommandTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.Parent;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * @author Rob Oxspring * * To change the template for this generated type comment go to * Window>Preferences>Java>Code Generation>Code and Comments */public class CommandTest    extends ParentTestCase {    public static Command buildStartCommand() {        return new Command(\"start\", \"Begins the process\", Collections.singleton(\"go\"), false, null,                           null, 0);    }    public static Command buildCommitCommand() {        return new Command(\"commit\", \"Commit the changes to the database\", null, true, null, null, 0);    }    public static Command buildLoginCommand() {        return new Command(\"login\", \"Initiates a session for the user\", null, false,                           ArgumentTest.buildUsernameArgument(), null, 0);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()     */    public void testProcessParent()        throws OptionException {        final Command option = buildStartCommand();        final List args = list(\"go\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processParent(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"start\"));        assertTrue(commandLine.hasOption(\"go\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    public void testProcessParent_Spare()        throws OptionException {        final Command option = buildLoginCommand();        final List args = list(\"login\", \"rob\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processParent(commandLine, iterator);        assertEquals(\"rob\", iterator.next());        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"login\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()     */    public void testCanProcess() {        final Command option = buildStartCommand();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"start\"));    }    public void testCanProcess_BadMatch() {        final Command option = buildStartCommand();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"stop\"));    }    public void testCanProcess_Alias() {        final Command option = buildStartCommand();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"go\"));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()     */    public void testPrefixes() {        final Command option = buildStartCommand();        assertTrue(option.getPrefixes().isEmpty());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testProcess()     */    public void testProcess()        throws OptionException {        final Command option = buildLoginCommand();        final List args = list(\"login\", \"rob\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"login\"));        assertEquals(\"rob\", commandLine.getValue(option));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()     */    public void testTriggers() {        final Command option = buildStartCommand();        final Set triggers = option.getTriggers();        assertContentsEqual(list(\"start\", \"go\"), triggers);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testValidate()     */    public void testValidate() {        final Parent option = buildCommitCommand();        final WriteableCommandLine commandLine = commandLine(option, list());        try {            option.validate(commandLine);            fail(\"Missing an option\");        } catch (OptionException moe) {            assertSame(option, moe.getOption());        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()     */    public void testAppendUsage() {        final Option option = buildStartCommand();        final StringBuffer buffer = new StringBuffer();        option.appendUsage(buffer, DisplaySetting.ALL, null);        assertEquals(\"[start (go)]\", buffer.toString());    }    public void testNullPreferredName() {        try {            new Command(null, \"\", Collections.singleton(\"go\"), false, null, null, 0);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception name\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT),                         exp.getMessage());        }    }    public void testEmotyPreferredName() {        try {            new Command(\"\", \"\", Collections.singleton(\"go\"), false, null, null, 0);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception name\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT),                         exp.getMessage());        }    }    public void testAppendUsage_NoOptional() {        final Option option = buildStartCommand();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);        option.appendUsage(buffer, settings, null);        assertEquals(\"start (go)\", buffer.toString());    }    public void testAppendUsage_NoAlias() {        final Option option = buildStartCommand();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_ALIASES);        option.appendUsage(buffer, settings, null);        assertEquals(\"[start]\", buffer.toString());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()     */    public void testGetPreferredName() {        final Option option = buildStartCommand();        assertEquals(\"start\", option.getPreferredName());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()     */    public void testGetDescription() {        final Option option = buildLoginCommand();        assertEquals(\"Initiates a session for the user\", option.getDescription());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines() {        // TODO Auto-generated method stub    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * @author Rob Oxspring\n+ *\n+ * To change the template for this generated type comment go to\n+ * Window>Preferences>Java>Code Generation>Code and Comments\n+ */\n+public class CommandTest\n+    extends ParentTestCase {\n+    public static Command buildStartCommand() {\n+        return new Command(\"start\", \"Begins the process\", Collections.singleton(\"go\"), false, null,\n+                           null, 0);\n+    }\n+\n+    public static Command buildCommitCommand() {\n+        return new Command(\"commit\", \"Commit the changes to the database\", null, true, null, null, 0);\n+    }\n+\n+    public static Command buildLoginCommand() {\n+        return new Command(\"login\", \"Initiates a session for the user\", null, false,\n+                           ArgumentTest.buildUsernameArgument(), null, 0);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+     */\n+    public void testProcessParent()\n+        throws OptionException {\n+        final Command option = buildStartCommand();\n+        final List args = list(\"go\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"start\"));\n+        assertTrue(commandLine.hasOption(\"go\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessParent_Spare()\n+        throws OptionException {\n+        final Command option = buildLoginCommand();\n+        final List args = list(\"login\", \"rob\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertEquals(\"rob\", iterator.next());\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"login\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Command option = buildStartCommand();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"start\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Command option = buildStartCommand();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"stop\"));\n+    }\n+\n+    public void testCanProcess_Alias() {\n+        final Command option = buildStartCommand();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"go\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Command option = buildStartCommand();\n+        assertTrue(option.getPrefixes().isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess()\n+        throws OptionException {\n+        final Command option = buildLoginCommand();\n+        final List args = list(\"login\", \"rob\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"login\"));\n+        assertEquals(\"rob\", commandLine.getValue(option));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Command option = buildStartCommand();\n+        final Set triggers = option.getTriggers();\n+        assertContentsEqual(list(\"start\", \"go\"), triggers);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() {\n+        final Parent option = buildCommitCommand();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        } catch (OptionException moe) {\n+            assertSame(option, moe.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildStartCommand();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"[start (go)]\", buffer.toString());\n+    }\n+\n+    public void testNullPreferredName() {\n+        try {\n+            new Command(null, \"\", Collections.singleton(\"go\"), false, null, null, 0);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception name\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testEmotyPreferredName() {\n+        try {\n+            new Command(\"\", \"\", Collections.singleton(\"go\"), false, null, null, 0);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception name\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testAppendUsage_NoOptional() {\n+        final Option option = buildStartCommand();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"start (go)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoAlias() {\n+        final Option option = buildStartCommand();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ALIASES);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[start]\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildStartCommand();\n+        assertEquals(\"start\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildLoginCommand();\n+        assertEquals(\"Initiates a session for the user\", option.getDescription());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        // TODO Auto-generated method stub\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/DefaultOptionTest.java\n+++ b/src/test/org/apache/commons/cli2/option/DefaultOptionTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.HashSet;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.Parent;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;/** * @author roberto * * To change the template for this generated type comment go to * Window>Preferences>Java>Code Generation>Code and Comments */public class DefaultOptionTest extends ParentTestCase {    public static DefaultOption buildHelpOption() {        final Set aliases = new HashSet(list(\"-h\", \"-?\"));        return new DefaultOption(            \"-\",            \"--\",            true,            \"--help\",            \"Displays the help\",            aliases,            aliases,            false,            null,            null,            'h');    }    public static DefaultOption buildXOption() {        return new DefaultOption(            \"-\",            \"--\",            true,            \"-X\",            \"This is needed\",            null,            null,            true,            null,            null,            'X');    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()     */    public void testProcessParent() throws OptionException {        final DefaultOption option = buildHelpOption();        final List args = list(\"--help\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processParent(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"--help\"));        assertTrue(commandLine.hasOption(\"-?\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    public void testProcessParent_Burst() throws OptionException {        final DefaultOption option = buildHelpOption();        final List args = list(\"-help\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processParent(commandLine, iterator);        assertEquals(\"-elp\", iterator.next());        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"--help\"));        assertTrue(commandLine.hasOption(\"-?\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()     */    public void testCanProcess() {        final DefaultOption option = buildHelpOption();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option,null), \"-?\"));    }    public void testCanProcess_BadMatch() {        final DefaultOption option = buildHelpOption();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null), \"-H\"));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()     */    public void testPrefixes() {        final DefaultOption option = buildHelpOption();        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testProcess()     */    public void testProcess() {        // TODO Auto-generated method stub    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()     */    public void testTriggers() {        final DefaultOption option = buildHelpOption();        assertContentsEqual(list(\"-?\", \"-h\", \"--help\"), option.getTriggers());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testValidate()     */    public void testValidate() {        final Parent option = buildXOption();        final WriteableCommandLine commandLine = commandLine(option, list());        try {            option.validate(commandLine);            fail(\"Missing an option\");        }        catch (OptionException moe) {            assertSame(option, moe.getOption());        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()     */    public void testAppendUsage() {        final Option option = buildHelpOption();        final StringBuffer buffer = new StringBuffer();        option.appendUsage(buffer, DisplaySetting.ALL, null);        assertEquals(\"[--help (-?,-h)]\", buffer.toString());    }    public void testAppendUsage_NoOptional() {        final Option option = buildHelpOption();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);        option.appendUsage(buffer, settings, null);        assertEquals(\"--help (-?,-h)\", buffer.toString());    }    public void testAppendUsage_NoAlias() {        final Option option = buildHelpOption();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_ALIASES);        option.appendUsage(buffer, settings, null);        assertEquals(\"[--help]\", buffer.toString());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()     */    public void testGetPreferredName() {        final Option option = buildHelpOption();        assertEquals(\"--help\", option.getPreferredName());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()     */    public void testGetDescription() {        final Option option = buildHelpOption();        assertEquals(\"Displays the help\", option.getDescription());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines() {        // TODO Auto-generated method stub    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+\n+/**\n+ * @author roberto\n+ * \n+ * To change the template for this generated type comment go to\n+ * Window>Preferences>Java>Code Generation>Code and Comments\n+ */\n+public class DefaultOptionTest extends ParentTestCase {\n+\n+    public static DefaultOption buildHelpOption() {\n+        final Set aliases = new HashSet(list(\"-h\", \"-?\"));\n+        return new DefaultOption(\n+            \"-\",\n+            \"--\",\n+            true,\n+            \"--help\",\n+            \"Displays the help\",\n+            aliases,\n+            aliases,\n+            false,\n+            null,\n+            null,\n+            'h');\n+    }\n+\n+    public static DefaultOption buildXOption() {\n+        return new DefaultOption(\n+            \"-\",\n+            \"--\",\n+            true,\n+            \"-X\",\n+            \"This is needed\",\n+            null,\n+            null,\n+            true,\n+            null,\n+            null,\n+            'X');\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+     */\n+    public void testProcessParent() throws OptionException {\n+        final DefaultOption option = buildHelpOption();\n+        final List args = list(\"--help\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"--help\"));\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessParent_Burst() throws OptionException {\n+        final DefaultOption option = buildHelpOption();\n+        final List args = list(\"-help\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertEquals(\"-elp\", iterator.next());\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"--help\"));\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final DefaultOption option = buildHelpOption();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option,null), \"-?\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final DefaultOption option = buildHelpOption();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null), \"-H\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final DefaultOption option = buildHelpOption();\n+        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() {\n+        // TODO Auto-generated method stub\n+\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final DefaultOption option = buildHelpOption();\n+        assertContentsEqual(list(\"-?\", \"-h\", \"--help\"), option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() {\n+        final Parent option = buildXOption();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        }\n+        catch (OptionException moe) {\n+            assertSame(option, moe.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildHelpOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"[--help (-?,-h)]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoOptional() {\n+        final Option option = buildHelpOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"--help (-?,-h)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoAlias() {\n+        final Option option = buildHelpOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ALIASES);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[--help]\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildHelpOption();\n+        assertEquals(\"--help\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildHelpOption();\n+        assertEquals(\"Displays the help\", option.getDescription());\n+    }\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        // TODO Auto-generated method stub\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/GroupTest.java\n+++ b/src/test/org/apache/commons/cli2/option/GroupTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.ArrayList;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;/** * @author Rob Oxspring */public class GroupTest    extends GroupTestCase {    public static final Command COMMAND_START =        new Command(\"start\", \"Starts the server\", null, false, null, null, 0);    public static final Command COMMAND_STOP =        new Command(\"stop\", \"Stops the server\", null, false, null, null, 0);    public static final Command COMMAND_RESTART =        new Command(\"restart\", \"Stops and starts the server\", null, false, null, null, 0);    public static final Command COMMAND_GRACEFUL =        new Command(\"graceful\", \"Restarts the server without interruption\", null, false, null,                    null, 0);    public static Group buildApacheCommandGroup() {        final List options = new ArrayList();        options.add(COMMAND_GRACEFUL);        options.add(COMMAND_RESTART);        options.add(COMMAND_START);        options.add(COMMAND_STOP);        return new GroupImpl(options, \"httpd-cmds\", \"The command to pass to the server\", 1, 1);    }    public static Group buildApachectlGroup() {        final List options = new ArrayList();        options.add(DefaultOptionTest.buildHelpOption());        options.add(ParentTest.buildKParent());        return new GroupImpl(options, \"apachectl\", \"Controls the apache http deamon\", 0,                             Integer.MAX_VALUE);    }    public static Group buildAntGroup() {        final List options = new ArrayList();        options.add(DefaultOptionTest.buildHelpOption());        options.add(ArgumentTest.buildTargetsArgument());        return new GroupImpl(options, \"ant\", \"The options for ant\", 0, Integer.MAX_VALUE);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.GroupTestCase#testProcessAnonymousArguments()     */    public void testProcessAnonymousArguments()        throws OptionException {        final Group option = buildAntGroup();        final List args = list(\"compile,test\", \"dist\");        final ListIterator iterator = args.listIterator();        final WriteableCommandLine commandLine = commandLine(option, args);        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(\"target\"));        assertListContentsEqual(commandLine.getValues(\"target\"), args);        assertListContentsEqual(list(\"compile\", \"test\", \"dist\"), args);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.GroupTestCase#testProcessOptions()     */    public void testProcessOptions()        throws OptionException {        final Group option = buildApachectlGroup();        final List args = list(\"-?\", \"-k\");        final ListIterator iterator = args.listIterator();        final WriteableCommandLine commandLine = commandLine(option, args);        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(\"--help\"));        assertTrue(commandLine.hasOption(\"-k\"));        assertFalse(commandLine.hasOption(\"start\"));        assertListContentsEqual(list(\"--help\", \"-k\"), args);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()     */    public void testCanProcess() {        final Group option = buildApacheCommandGroup();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"start\"));    }    public void testCanProcess_BadMatch() {        final Group option = buildApacheCommandGroup();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"begin\"));    }    public void testCanProcess_NullMatch() {        final Group option = buildApacheCommandGroup();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), (String) null));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()     */    public void testPrefixes() {        final Group option = buildApachectlGroup();        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testProcess()     */    public void testProcess()        throws OptionException {        final Group option = buildAntGroup();        final List args = list(\"--help\", \"compile,test\", \"dist\");        final ListIterator iterator = args.listIterator();        final WriteableCommandLine commandLine = commandLine(option, args);        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(\"-?\"));        assertListContentsEqual(list(\"compile\", \"test\", \"dist\"), commandLine.getValues(\"target\"));    }    public void testProcess_Nested()        throws OptionException {        final Group option = buildApachectlGroup();        final List args = list(\"-h\", \"-k\", \"graceful\");        final ListIterator iterator = args.listIterator();        final WriteableCommandLine commandLine = commandLine(option, args);        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(\"-?\"));        assertTrue(commandLine.hasOption(\"-k\"));        assertTrue(commandLine.hasOption(\"graceful\"));        assertFalse(commandLine.hasOption(\"stop\"));        assertTrue(commandLine.getValues(\"start\").isEmpty());        assertListContentsEqual(list(\"--help\", \"-k\", \"graceful\"), args);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()     */    public void testTriggers() {        final Group option = buildApachectlGroup();        assertContentsEqual(list(\"--help\", \"-?\", \"-h\", \"-k\"), option.getTriggers());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testValidate()     */    public void testValidate()        throws OptionException {        final Group option = buildApacheCommandGroup();        final WriteableCommandLine commandLine = commandLine(option, list());        commandLine.addOption(COMMAND_RESTART);        option.validate(commandLine);    }    public void testValidate_UnexpectedOption() {        final Group option = buildApacheCommandGroup();        final WriteableCommandLine commandLine = commandLine(option, list());        commandLine.addOption(COMMAND_RESTART);        commandLine.addOption(COMMAND_GRACEFUL);        try {            option.validate(commandLine);            fail(\"Too many options\");        } catch (OptionException uoe) {            assertEquals(option, uoe.getOption());        }    }    public void testValidate_MissingOption() {        final Group option = buildApacheCommandGroup();        final WriteableCommandLine commandLine = commandLine(option, list());        try {            option.validate(commandLine);            fail(\"Missing an option\");        } catch (OptionException moe) {            assertEquals(option, moe.getOption());        }    }    public void testValidate_RequiredChild()        throws OptionException {        final Option required =            new DefaultOptionBuilder().withLongName(\"required\").withRequired(true).create();        final Option optional =            new DefaultOptionBuilder().withLongName(\"optional\").withRequired(false).create();        final Group group =            new GroupBuilder().withOption(required).withOption(optional).withMinimum(1).create();        WriteableCommandLine commandLine;        commandLine = commandLine(group, list());        try {            group.validate(commandLine);            fail(\"Missing option 'required'\");        } catch (OptionException moe) {            assertEquals(required, moe.getOption());        }        commandLine = commandLine(group, list());        commandLine.addOption(optional);        try {            group.validate(commandLine);            fail(\"Missing option 'required'\");        } catch (OptionException moe) {            assertEquals(required, moe.getOption());        }        commandLine = commandLine(group, list());        commandLine.addOption(required);        group.validate(commandLine);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()     */    public void testAppendUsage() {        final Option option = buildApacheCommandGroup();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        //settings.remove(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);        option.appendUsage(buffer, settings, null);        assertEquals(\"httpd-cmds (graceful|restart|start|stop)\", buffer.toString());    }    public void testAppendUsage_NoOptional() {        final Option option = buildApacheCommandGroup();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);        option.appendUsage(buffer, settings, null);        assertEquals(\"httpd-cmds (graceful|restart|start|stop)\", buffer.toString());    }    public void testAppendUsage_NoExpand() {        final Option option = buildApacheCommandGroup();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);        option.appendUsage(buffer, settings, null);        assertEquals(\"httpd-cmds\", buffer.toString());    }    public void testAppendUsage_NoExpandOrName() {        final Option option = buildApacheCommandGroup();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);        option.appendUsage(buffer, settings, null);        assertEquals(\"httpd-cmds\", buffer.toString());    }    public void testAppendUsage_NoName() {        final Option option = buildApacheCommandGroup();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);        option.appendUsage(buffer, settings, null);        assertEquals(\"graceful|restart|start|stop\", buffer.toString());    }    public void testAppendUsage_WithArgs() {        final Option option = buildAntGroup();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);        option.appendUsage(buffer, settings, null);        assertEquals(\"[ant (--help (-?,-h)) [<target1> [<target2> ...]]]\", buffer.toString());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()     */    public void testGetPreferredName() {        final Option option = buildAntGroup();        assertEquals(\"ant\", option.getPreferredName());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()     */    public void testGetDescription() {        final Option option = buildApachectlGroup();        assertEquals(\"Controls the apache http deamon\", option.getDescription());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines() {        final Option option = buildApacheCommandGroup();        final List lines = option.helpLines(0, DisplaySetting.ALL, null);        final Iterator i = lines.iterator();        final HelpLine line1 = (HelpLine) i.next();        assertEquals(0, line1.getIndent());        assertEquals(option, line1.getOption());        final HelpLine line2 = (HelpLine) i.next();        assertEquals(1, line2.getIndent());        assertEquals(COMMAND_GRACEFUL, line2.getOption());        final HelpLine line3 = (HelpLine) i.next();        assertEquals(1, line3.getIndent());        assertEquals(COMMAND_RESTART, line3.getOption());        final HelpLine line4 = (HelpLine) i.next();        assertEquals(1, line4.getIndent());        assertEquals(COMMAND_START, line4.getOption());        final HelpLine line5 = (HelpLine) i.next();        assertEquals(1, line5.getIndent());        assertEquals(COMMAND_STOP, line5.getOption());        assertFalse(i.hasNext());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines_NoExpanded() {        final Option option = buildApacheCommandGroup();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);        final List lines = option.helpLines(0, settings, null);        final Iterator i = lines.iterator();        final HelpLine line1 = (HelpLine) i.next();        assertEquals(0, line1.getIndent());        assertEquals(option, line1.getOption());        assertFalse(i.hasNext());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines_NoName() {        final Option option = buildApacheCommandGroup();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);        final List lines = option.helpLines(0, settings, null);        final Iterator i = lines.iterator();        final HelpLine line2 = (HelpLine) i.next();        assertEquals(1, line2.getIndent());        assertEquals(COMMAND_GRACEFUL, line2.getOption());        final HelpLine line3 = (HelpLine) i.next();        assertEquals(1, line3.getIndent());        assertEquals(COMMAND_RESTART, line3.getOption());        final HelpLine line4 = (HelpLine) i.next();        assertEquals(1, line4.getIndent());        assertEquals(COMMAND_START, line4.getOption());        final HelpLine line5 = (HelpLine) i.next();        assertEquals(1, line5.getIndent());        assertEquals(COMMAND_STOP, line5.getOption());        assertFalse(i.hasNext());    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class GroupTest\n+    extends GroupTestCase {\n+    public static final Command COMMAND_START =\n+        new Command(\"start\", \"Starts the server\", null, false, null, null, 0);\n+    public static final Command COMMAND_STOP =\n+        new Command(\"stop\", \"Stops the server\", null, false, null, null, 0);\n+    public static final Command COMMAND_RESTART =\n+        new Command(\"restart\", \"Stops and starts the server\", null, false, null, null, 0);\n+    public static final Command COMMAND_GRACEFUL =\n+        new Command(\"graceful\", \"Restarts the server without interruption\", null, false, null,\n+                    null, 0);\n+\n+    public static Group buildApacheCommandGroup() {\n+        final List options = new ArrayList();\n+        options.add(COMMAND_GRACEFUL);\n+        options.add(COMMAND_RESTART);\n+        options.add(COMMAND_START);\n+        options.add(COMMAND_STOP);\n+\n+        return new GroupImpl(options, \"httpd-cmds\", \"The command to pass to the server\", 1, 1);\n+    }\n+\n+    public static Group buildApachectlGroup() {\n+        final List options = new ArrayList();\n+        options.add(DefaultOptionTest.buildHelpOption());\n+        options.add(ParentTest.buildKParent());\n+\n+        return new GroupImpl(options, \"apachectl\", \"Controls the apache http deamon\", 0,\n+                             Integer.MAX_VALUE);\n+    }\n+\n+    public static Group buildAntGroup() {\n+        final List options = new ArrayList();\n+        options.add(DefaultOptionTest.buildHelpOption());\n+        options.add(ArgumentTest.buildTargetsArgument());\n+\n+        return new GroupImpl(options, \"ant\", \"The options for ant\", 0, Integer.MAX_VALUE);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.GroupTestCase#testProcessAnonymousArguments()\n+     */\n+    public void testProcessAnonymousArguments()\n+        throws OptionException {\n+        final Group option = buildAntGroup();\n+        final List args = list(\"compile,test\", \"dist\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"target\"));\n+        assertListContentsEqual(commandLine.getValues(\"target\"), args);\n+        assertListContentsEqual(list(\"compile\", \"test\", \"dist\"), args);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.GroupTestCase#testProcessOptions()\n+     */\n+    public void testProcessOptions()\n+        throws OptionException {\n+        final Group option = buildApachectlGroup();\n+        final List args = list(\"-?\", \"-k\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"--help\"));\n+        assertTrue(commandLine.hasOption(\"-k\"));\n+        assertFalse(commandLine.hasOption(\"start\"));\n+        assertListContentsEqual(list(\"--help\", \"-k\"), args);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Group option = buildApacheCommandGroup();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"start\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Group option = buildApacheCommandGroup();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"begin\"));\n+    }\n+\n+    public void testCanProcess_NullMatch() {\n+        final Group option = buildApacheCommandGroup();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), (String) null));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Group option = buildApachectlGroup();\n+        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess()\n+        throws OptionException {\n+        final Group option = buildAntGroup();\n+        final List args = list(\"--help\", \"compile,test\", \"dist\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertListContentsEqual(list(\"compile\", \"test\", \"dist\"), commandLine.getValues(\"target\"));\n+    }\n+\n+    public void testProcess_Nested()\n+        throws OptionException {\n+        final Group option = buildApachectlGroup();\n+        final List args = list(\"-h\", \"-k\", \"graceful\");\n+        final ListIterator iterator = args.listIterator();\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(\"-?\"));\n+        assertTrue(commandLine.hasOption(\"-k\"));\n+        assertTrue(commandLine.hasOption(\"graceful\"));\n+        assertFalse(commandLine.hasOption(\"stop\"));\n+        assertTrue(commandLine.getValues(\"start\").isEmpty());\n+        assertListContentsEqual(list(\"--help\", \"-k\", \"graceful\"), args);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Group option = buildApachectlGroup();\n+        assertContentsEqual(list(\"--help\", \"-?\", \"-h\", \"-k\"), option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate()\n+        throws OptionException {\n+        final Group option = buildApacheCommandGroup();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addOption(COMMAND_RESTART);\n+\n+        option.validate(commandLine);\n+    }\n+\n+    public void testValidate_UnexpectedOption() {\n+        final Group option = buildApacheCommandGroup();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        commandLine.addOption(COMMAND_RESTART);\n+        commandLine.addOption(COMMAND_GRACEFUL);\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Too many options\");\n+        } catch (OptionException uoe) {\n+            assertEquals(option, uoe.getOption());\n+        }\n+    }\n+\n+    public void testValidate_MissingOption() {\n+        final Group option = buildApacheCommandGroup();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        } catch (OptionException moe) {\n+            assertEquals(option, moe.getOption());\n+        }\n+    }\n+\n+    public void testValidate_RequiredChild()\n+        throws OptionException {\n+        final Option required =\n+            new DefaultOptionBuilder().withLongName(\"required\").withRequired(true).create();\n+        final Option optional =\n+            new DefaultOptionBuilder().withLongName(\"optional\").withRequired(false).create();\n+        final Group group =\n+            new GroupBuilder().withOption(required).withOption(optional).withMinimum(1).create();\n+\n+        WriteableCommandLine commandLine;\n+\n+        commandLine = commandLine(group, list());\n+\n+        try {\n+            group.validate(commandLine);\n+            fail(\"Missing option 'required'\");\n+        } catch (OptionException moe) {\n+            assertEquals(required, moe.getOption());\n+        }\n+\n+        commandLine = commandLine(group, list());\n+        commandLine.addOption(optional);\n+\n+        try {\n+            group.validate(commandLine);\n+            fail(\"Missing option 'required'\");\n+        } catch (OptionException moe) {\n+            assertEquals(required, moe.getOption());\n+        }\n+\n+        commandLine = commandLine(group, list());\n+        commandLine.addOption(required);\n+        group.validate(commandLine);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+\n+        //settings.remove(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"httpd-cmds (graceful|restart|start|stop)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoOptional() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"httpd-cmds (graceful|restart|start|stop)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoExpand() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"httpd-cmds\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoExpandOrName() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"httpd-cmds\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoName() {\n+        final Option option = buildApacheCommandGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"graceful|restart|start|stop\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_WithArgs() {\n+        final Option option = buildAntGroup();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[ant (--help (-?,-h)) [<target1> [<target2> ...]]]\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildAntGroup();\n+        assertEquals(\"ant\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildApachectlGroup();\n+        assertEquals(\"Controls the apache http deamon\", option.getDescription());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        final Option option = buildApacheCommandGroup();\n+        final List lines = option.helpLines(0, DisplaySetting.ALL, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine) i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        final HelpLine line2 = (HelpLine) i.next();\n+        assertEquals(1, line2.getIndent());\n+        assertEquals(COMMAND_GRACEFUL, line2.getOption());\n+\n+        final HelpLine line3 = (HelpLine) i.next();\n+        assertEquals(1, line3.getIndent());\n+        assertEquals(COMMAND_RESTART, line3.getOption());\n+\n+        final HelpLine line4 = (HelpLine) i.next();\n+        assertEquals(1, line4.getIndent());\n+        assertEquals(COMMAND_START, line4.getOption());\n+\n+        final HelpLine line5 = (HelpLine) i.next();\n+        assertEquals(1, line5.getIndent());\n+        assertEquals(COMMAND_STOP, line5.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines_NoExpanded() {\n+        final Option option = buildApacheCommandGroup();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine) i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines_NoName() {\n+        final Option option = buildApacheCommandGroup();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_NAME);\n+\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line2 = (HelpLine) i.next();\n+        assertEquals(1, line2.getIndent());\n+        assertEquals(COMMAND_GRACEFUL, line2.getOption());\n+\n+        final HelpLine line3 = (HelpLine) i.next();\n+        assertEquals(1, line3.getIndent());\n+        assertEquals(COMMAND_RESTART, line3.getOption());\n+\n+        final HelpLine line4 = (HelpLine) i.next();\n+        assertEquals(1, line4.getIndent());\n+        assertEquals(COMMAND_START, line4.getOption());\n+\n+        final HelpLine line5 = (HelpLine) i.next();\n+        assertEquals(1, line5.getIndent());\n+        assertEquals(COMMAND_STOP, line5.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/GroupTestCase.java\n+++ b/src/test/org/apache/commons/cli2/option/GroupTestCase.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import org.apache.commons.cli2.OptionException;/** * @author Rob Oxspring */public abstract class GroupTestCase    extends OptionTestCase {    public abstract void testProcessOptions()        throws OptionException;    public abstract void testProcessAnonymousArguments()        throws OptionException;}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import org.apache.commons.cli2.OptionException;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class GroupTestCase\n+    extends OptionTestCase {\n+    public abstract void testProcessOptions()\n+        throws OptionException;\n+\n+    public abstract void testProcessAnonymousArguments()\n+        throws OptionException;\n+}\n--- a/src/test/org/apache/commons/cli2/option/NestedGroupTest.java\n+++ b/src/test/org/apache/commons/cli2/option/NestedGroupTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import org.apache.commons.cli2.CLITestCase;import org.apache.commons.cli2.CommandLine;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.Parser;import org.apache.commons.cli2.util.HelpFormatter;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.io.StringReader;import java.io.StringWriter;import java.util.ArrayList;import java.util.List;/** * Test to exercise nested groups developed to demonstrate bug 32533 */public class NestedGroupTest extends CLITestCase {    final static DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    final static ArgumentBuilder abuilder = new ArgumentBuilder();    final static GroupBuilder gbuilder = new GroupBuilder();    static Group buildActionGroup() {        return gbuilder.withName(\"Action\").withDescription(\"Action\")                       .withMinimum(1).withMaximum(1)                       .withOption(obuilder.withId(5).withShortName(\"e\")                                           .withLongName(\"encrypt\")                                           .withDescription(\"Encrypt input\")                                           .create())                       .withOption(obuilder.withId(6).withShortName(\"d\")                                           .withLongName(\"decrypt\")                                           .withDescription(\"Decrypt input\")                                           .create()).create();    }    static Group buildAlgorithmGroup() {        return gbuilder.withName(\"Algorithm\")                       .withDescription(\"Encryption Algorithm\").withMaximum(1)                       .withOption(obuilder.withId(0).withShortName(\"b\")                                           .withLongName(\"blowfish\")                                           .withDescription(\"Blowfish\").create())                       .withOption(obuilder.withId(1).withShortName(\"3\")                                           .withLongName(\"3DES\")                                           .withDescription(\"Triple DES\")                                           .create()).create();    }    static Group buildInputGroup() {        return gbuilder.withName(\"Input\").withDescription(\"Input\").withMinimum(1)                       .withMaximum(1)                       .withOption(obuilder.withId(2).withShortName(\"f\")                                           .withLongName(\"file\")                                           .withDescription(\"Input file\")                                           .withArgument(abuilder.withName(                    \"file\").withMinimum(1).withMaximum(1).create()).create())                       .withOption(obuilder.withId(3).withShortName(\"s\")                                           .withLongName(\"string\")                                           .withDescription(\"Input string\")                                           .withArgument(abuilder.withName(                    \"string\").withMinimum(1).withMaximum(1).create()).create())                       .create();    }    static Group buildEncryptionServiceGroup(Group[] nestedGroups) {        gbuilder.withName(\"encryptionService\")                .withOption(obuilder.withId(4).withShortName(\"h\")                                    .withLongName(\"help\")                                    .withDescription(\"Print this message\")                                    .create()).withOption(obuilder.withShortName(                \"k\").withLongName(\"key\").withDescription(\"Encryption key\")                                                                  .create());        for (int i = 0; i < nestedGroups.length; i++) {            gbuilder.withOption(nestedGroups[i]);        }        return gbuilder.create();    }    public void testNestedGroup()        throws OptionException {        final String[] args = {                \"-eb\",                \"--file\",                \"/tmp/filename.txt\"            };        Group[] nestedGroups = {                buildActionGroup(),                buildAlgorithmGroup(),                buildInputGroup()            };        Parser parser = new Parser();        parser.setGroup(buildEncryptionServiceGroup(nestedGroups));        CommandLine commandLine = parser.parse(args);        assertTrue(\"/tmp/filename.txt\".equals(commandLine.getValue(\"-f\")));        assertTrue(commandLine.hasOption(\"-e\"));        assertTrue(commandLine.hasOption(\"-b\"));        assertFalse(commandLine.hasOption(\"-d\"));    }    public void testNestedGroupHelp() {        Group[] nestedGroups = {                buildActionGroup(),                buildAlgorithmGroup(),                buildInputGroup()            };        HelpFormatter helpFormatter = new HelpFormatter();        helpFormatter.setGroup(buildEncryptionServiceGroup(nestedGroups));        final StringWriter out = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(out));        try {            helpFormatter.print();            final BufferedReader bufferedReader = new BufferedReader(new StringReader(                        out.toString()));            final String[] expected = new String[] {                    \"Usage:                                                                          \",                    \" [-h -k -e|-d -b|-3 -f <file>|-s <string>]                                      \",                    \"encryptionService                                                               \",                    \"  -h (--help)               Print this message                                  \",                    \"  -k (--key)                Encryption key                                      \",                    \"  Action                    Action                                              \",                    \"    -e (--encrypt)          Encrypt input                                       \",                    \"    -d (--decrypt)          Decrypt input                                       \",                    \"  Algorithm                 Encryption Algorithm                                \",                    \"    -b (--blowfish)         Blowfish                                            \",                    \"    -3 (--3DES)             Triple DES                                          \",                    \"  Input                     Input                                               \",                    \"    -f (--file) file        Input file                                          \",                    \"    -s (--string) string    Input string                                        \"                };            List actual = new ArrayList(expected.length);            String input;            while ((input = bufferedReader.readLine()) != null) {                actual.add(input);            }            // Show they are the same number of lines            assertEquals(\"Help text lines should be \" + expected.length,                actual.size(), expected.length);            for (int i = 0; i < expected.length; i++) {                if (!expected[i].equals(actual.get(i))) {                    for (int x = 0; x < expected.length; i++) {                        System.out.println(\"   \" + expected[i]);                        System.out.println((expected[i].equals(actual.get(i))                            ? \"== \"                            : \"!= \") + actual.get(i));                    }                }                assertEquals(expected[i], actual.get(i));            }        }        catch (IOException e) {            fail(e.getLocalizedMessage());        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import org.apache.commons.cli2.CLITestCase;\n+import org.apache.commons.cli2.CommandLine;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.Parser;\n+import org.apache.commons.cli2.util.HelpFormatter;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * Test to exercise nested groups developed to demonstrate bug 32533\n+ */\n+public class NestedGroupTest extends CLITestCase {\n+    final static DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n+    final static ArgumentBuilder abuilder = new ArgumentBuilder();\n+    final static GroupBuilder gbuilder = new GroupBuilder();\n+\n+    static Group buildActionGroup() {\n+        return gbuilder.withName(\"Action\").withDescription(\"Action\")\n+                       .withMinimum(1).withMaximum(1)\n+                       .withOption(obuilder.withId(5).withShortName(\"e\")\n+                                           .withLongName(\"encrypt\")\n+                                           .withDescription(\"Encrypt input\")\n+                                           .create())\n+                       .withOption(obuilder.withId(6).withShortName(\"d\")\n+                                           .withLongName(\"decrypt\")\n+                                           .withDescription(\"Decrypt input\")\n+                                           .create()).create();\n+    }\n+\n+    static Group buildAlgorithmGroup() {\n+        return gbuilder.withName(\"Algorithm\")\n+                       .withDescription(\"Encryption Algorithm\").withMaximum(1)\n+                       .withOption(obuilder.withId(0).withShortName(\"b\")\n+                                           .withLongName(\"blowfish\")\n+                                           .withDescription(\"Blowfish\").create())\n+                       .withOption(obuilder.withId(1).withShortName(\"3\")\n+                                           .withLongName(\"3DES\")\n+                                           .withDescription(\"Triple DES\")\n+                                           .create()).create();\n+    }\n+\n+    static Group buildInputGroup() {\n+        return gbuilder.withName(\"Input\").withDescription(\"Input\").withMinimum(1)\n+                       .withMaximum(1)\n+                       .withOption(obuilder.withId(2).withShortName(\"f\")\n+                                           .withLongName(\"file\")\n+                                           .withDescription(\"Input file\")\n+                                           .withArgument(abuilder.withName(\n+                    \"file\").withMinimum(1).withMaximum(1).create()).create())\n+                       .withOption(obuilder.withId(3).withShortName(\"s\")\n+                                           .withLongName(\"string\")\n+                                           .withDescription(\"Input string\")\n+                                           .withArgument(abuilder.withName(\n+                    \"string\").withMinimum(1).withMaximum(1).create()).create())\n+                       .create();\n+    }\n+\n+    static Group buildEncryptionServiceGroup(Group[] nestedGroups) {\n+        gbuilder.withName(\"encryptionService\")\n+                .withOption(obuilder.withId(4).withShortName(\"h\")\n+                                    .withLongName(\"help\")\n+                                    .withDescription(\"Print this message\")\n+                                    .create()).withOption(obuilder.withShortName(\n+                \"k\").withLongName(\"key\").withDescription(\"Encryption key\")\n+                                                                  .create());\n+\n+        for (int i = 0; i < nestedGroups.length; i++) {\n+            gbuilder.withOption(nestedGroups[i]);\n+        }\n+\n+        return gbuilder.create();\n+    }\n+\n+    public void testNestedGroup()\n+        throws OptionException {\n+        final String[] args = {\n+                \"-eb\",\n+                \"--file\",\n+                \"/tmp/filename.txt\"\n+            };\n+\n+        Group[] nestedGroups = {\n+                buildActionGroup(),\n+                buildAlgorithmGroup(),\n+                buildInputGroup()\n+            };\n+\n+        Parser parser = new Parser();\n+        parser.setGroup(buildEncryptionServiceGroup(nestedGroups));\n+\n+        CommandLine commandLine = parser.parse(args);\n+\n+        assertTrue(\"/tmp/filename.txt\".equals(commandLine.getValue(\"-f\")));\n+        assertTrue(commandLine.hasOption(\"-e\"));\n+        assertTrue(commandLine.hasOption(\"-b\"));\n+        assertFalse(commandLine.hasOption(\"-d\"));\n+    }\n+\n+    public void testNestedGroupHelp() {\n+        Group[] nestedGroups = {\n+                buildActionGroup(),\n+                buildAlgorithmGroup(),\n+                buildInputGroup()\n+            };\n+\n+        HelpFormatter helpFormatter = new HelpFormatter();\n+        helpFormatter.setGroup(buildEncryptionServiceGroup(nestedGroups));\n+\n+        final StringWriter out = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(out));\n+\n+        try {\n+            helpFormatter.print();\n+\n+            final BufferedReader bufferedReader = new BufferedReader(new StringReader(\n+                        out.toString()));\n+            final String[] expected = new String[] {\n+                    \"Usage:                                                                          \",\n+                    \" [-h -k -e|-d -b|-3 -f <file>|-s <string>]                                      \",\n+                    \"encryptionService                                                               \",\n+                    \"  -h (--help)               Print this message                                  \",\n+                    \"  -k (--key)                Encryption key                                      \",\n+                    \"  Action                    Action                                              \",\n+                    \"    -e (--encrypt)          Encrypt input                                       \",\n+                    \"    -d (--decrypt)          Decrypt input                                       \",\n+                    \"  Algorithm                 Encryption Algorithm                                \",\n+                    \"    -b (--blowfish)         Blowfish                                            \",\n+                    \"    -3 (--3DES)             Triple DES                                          \",\n+                    \"  Input                     Input                                               \",\n+                    \"    -f (--file) file        Input file                                          \",\n+                    \"    -s (--string) string    Input string                                        \"\n+                };\n+\n+            List actual = new ArrayList(expected.length);\n+            String input;\n+\n+            while ((input = bufferedReader.readLine()) != null) {\n+                actual.add(input);\n+            }\n+\n+            // Show they are the same number of lines\n+            assertEquals(\"Help text lines should be \" + expected.length,\n+                actual.size(), expected.length);\n+\n+            for (int i = 0; i < expected.length; i++) {\n+                if (!expected[i].equals(actual.get(i))) {\n+                    for (int x = 0; x < expected.length; i++) {\n+                        System.out.println(\"   \" + expected[i]);\n+                        System.out.println((expected[i].equals(actual.get(i))\n+                            ? \"== \"\n+                            : \"!= \") + actual.get(i));\n+                    }\n+                }\n+\n+                assertEquals(expected[i], actual.get(i));\n+            }\n+        }\n+        catch (IOException e) {\n+            fail(e.getLocalizedMessage());\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/OptionTestCase.java\n+++ b/src/test/org/apache/commons/cli2/option/OptionTestCase.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.List;import org.apache.commons.cli2.CLITestCase;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;/** * @author Rob Oxspring */public abstract class OptionTestCase extends CLITestCase {    public static WriteableCommandLine commandLine(        final Option option,        final List args) {        return new WriteableCommandLineImpl(option, args);    }    public abstract void testTriggers();    public abstract void testPrefixes();    public abstract void testCanProcess();    public abstract void testProcess() throws OptionException;    public abstract void testValidate() throws OptionException;    public abstract void testAppendUsage() throws OptionException;    public abstract void testGetPreferredName();    public abstract void testGetDescription();    public abstract void testHelpLines();}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.List;\n+\n+import org.apache.commons.cli2.CLITestCase;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class OptionTestCase extends CLITestCase {\n+\n+    public static WriteableCommandLine commandLine(\n+        final Option option,\n+        final List args) {\n+        return new WriteableCommandLineImpl(option, args);\n+    }\n+\n+    public abstract void testTriggers();\n+\n+    public abstract void testPrefixes();\n+\n+    public abstract void testCanProcess();\n+\n+    public abstract void testProcess() throws OptionException;\n+\n+    public abstract void testValidate() throws OptionException;\n+\n+    public abstract void testAppendUsage() throws OptionException;\n+\n+    public abstract void testGetPreferredName();\n+\n+    public abstract void testGetDescription();\n+\n+    public abstract void testHelpLines();\n+}\n--- a/src/test/org/apache/commons/cli2/option/ParentTest.java\n+++ b/src/test/org/apache/commons/cli2/option/ParentTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.Argument;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.Parent;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.builder.ArgumentBuilder;import org.apache.commons.cli2.builder.CommandBuilder;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * @author Rob Oxspring */public class ParentTest    extends ParentTestCase {    public static final Argument COMPLEX_ARGUMENT =        new ArgumentBuilder().withName(\"username\").withMinimum(1).withMaximum(1).create();    public static final Option COMPLEX_CHILD_SSL =        new DefaultOptionBuilder().withLongName(\"ssl\").withShortName(\"s\").create();    public static final Option COMPLEX_CHILD_BASIC =        new DefaultOptionBuilder().withLongName(\"basic\").withShortName(\"b\").create();    public static final Option COMPLEX_CHILD_DIGEST =        new DefaultOptionBuilder().withLongName(\"digest\").withShortName(\"d\").create();    public static final Group COMPLEX_CHILDREN =        new GroupBuilder().withName(\"login-opts\").withOption(COMPLEX_CHILD_BASIC)                          .withOption(COMPLEX_CHILD_DIGEST).withOption(COMPLEX_CHILD_SSL).create();    public static Parent buildLibParent() {        final Argument argument = ArgumentTest.buildPathArgument();        return new DefaultOption(\"-\", \"--\", false, \"--lib\", \"Specifies library search path\", null,                                 null, false, argument, null, 'l');    }    public static Parent buildKParent() {        final Group children = GroupTest.buildApacheCommandGroup();        return new DefaultOption(\"-\", \"--\", false, \"-k\", \"desc\", null, null, false, null, children,                                 'k');    }    public static Parent buildComplexParent() {        return new CommandBuilder().withName(\"login\").withName(\"lo\").withName(\"l\")                                   .withArgument(COMPLEX_ARGUMENT).withChildren(COMPLEX_CHILDREN)                                   .create();    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()     */    public void testProcessParent()        throws OptionException {        final Parent option = buildKParent();        final List args = list(\"-k\", \"start\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processParent(commandLine, iterator);        assertEquals(\"start\", iterator.next());        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"-k\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()     */    public void testCanProcess() {        final Parent option = buildKParent();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"-k\"));    }    public void testCanProcess_BadMatch() {        final Parent option = buildKParent();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"-K\"));    }    public void testCanProcess_ContractedArgument() {        final Parent option = buildLibParent();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"--lib=/usr/lib\"));    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()     */    public void testPrefixes() {        final Parent option = buildKParent();        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testProcess()     */    public void testProcess()        throws OptionException {        final Parent option = CommandTest.buildStartCommand();        final List args = list(\"start\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"start\"));        assertFalse(commandLine.hasOption(\"stop\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    public void testProcess_NoMatch()        throws OptionException {        final Parent option = CommandTest.buildStartCommand();        final List args = list(\"whatever\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        try {            option.process(commandLine, iterator);            fail(\"unexpected token not thrown\");        } catch (OptionException exp) {            OptionException e =                new OptionException(option, ResourceConstants.UNEXPECTED_TOKEN, \"whatever\");            assertEquals(\"wrong exception message\", e.getMessage(), exp.getMessage());        }    }    public void testProcess_Children()        throws OptionException {        final Parent option = buildKParent();        final List args = list(\"-k\", \"start\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertNull(option.findOption(\"whatever\"));        assertNotNull(option.findOption(\"start\"));        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"-k\"));        assertTrue(commandLine.hasOption(\"start\"));        assertFalse(commandLine.hasOption(\"stop\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    public void testProcess_Argument()        throws OptionException {        final Parent option = buildLibParent();        final List args = list(\"--lib=C:\\\\WINDOWS;C:\\\\WINNT;C:\\\\\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"--lib\"));        assertContentsEqual(list(\"C:\\\\WINDOWS\", \"C:\\\\WINNT\", \"C:\\\\\"), commandLine.getValues(option));    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()     */    public void testTriggers() {        final Parent option = buildKParent();        assertContentsEqual(list(\"-k\"), option.getTriggers());    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testValidate()     */    public void testValidate()        throws OptionException {        final Parent option = CommandTest.buildStartCommand();        final WriteableCommandLine commandLine = commandLine(option, list());        option.validate(commandLine);        commandLine.addOption(option);        option.validate(commandLine);    }    public void testValidate_Children()        throws OptionException {        final Parent option = buildKParent();        final WriteableCommandLine commandLine = commandLine(option, list());        option.validate(commandLine);        commandLine.addOption(option);        try {            option.validate(commandLine);            fail(\"Missing a command\");        } catch (OptionException moe) {            assertNotNull(moe.getOption());            assertNotSame(option, moe.getOption());        }    }    public void testValidate_Argument()        throws OptionException {        final Command option = CommandTest.buildLoginCommand();        final WriteableCommandLine commandLine = commandLine(option, list());        option.validate(commandLine);        commandLine.addOption(option);        try {            option.validate(commandLine);            fail(\"Missing a value\");        } catch (OptionException moe) {            assertSame(option, moe.getOption());        }    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()     */    public void testAppendUsage() {        final Option option = buildComplexParent();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);        option.appendUsage(buffer, settings, null);        assertEquals(\"[login (l,lo) <username> [login-opts (--basic (-b)|--digest (-d)|--ssl (-s))]]\",                     buffer.toString());    }    public void testAppendUsage_NoArguments() {        final Option option = buildComplexParent();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        settings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);        option.appendUsage(buffer, settings, null);        assertEquals(\"[login (l,lo) [login-opts (--basic (-b)|--digest (-d)|--ssl (-s))]]\",                     buffer.toString());    }    public void testAppendUsage_NoChildren() {        final Option option = buildComplexParent();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);        option.appendUsage(buffer, settings, null);        assertEquals(\"[login (l,lo) <username>]\", buffer.toString());    }    public void testAppendUsage_NoArgumentsOrChildren() {        final Option option = buildComplexParent();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);        settings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        option.appendUsage(buffer, settings, null);        assertEquals(\"[login (l,lo)]\", buffer.toString());    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()     */    public void testGetPreferredName() {        final Option option = buildLibParent();        assertEquals(\"--lib\", option.getPreferredName());    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()     */    public void testGetDescription() {        final Option option = buildLibParent();        assertEquals(\"Specifies library search path\", option.getDescription());    }    /* (non-Javadoc)     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines() {        final Option option = buildComplexParent();        final List lines = option.helpLines(0, DisplaySetting.ALL, null);        final Iterator i = lines.iterator();        final HelpLine line1 = (HelpLine) i.next();        assertEquals(0, line1.getIndent());        assertEquals(option, line1.getOption());        final HelpLine line2 = (HelpLine) i.next();        assertEquals(1, line2.getIndent());        assertEquals(COMPLEX_ARGUMENT, line2.getOption());        final HelpLine line3 = (HelpLine) i.next();        assertEquals(1, line3.getIndent());        assertEquals(COMPLEX_CHILDREN, line3.getOption());        final HelpLine line4 = (HelpLine) i.next();        assertEquals(2, line4.getIndent());        assertEquals(COMPLEX_CHILD_BASIC, line4.getOption());        final HelpLine line5 = (HelpLine) i.next();        assertEquals(2, line5.getIndent());        assertEquals(COMPLEX_CHILD_DIGEST, line5.getOption());        final HelpLine line6 = (HelpLine) i.next();        assertEquals(2, line6.getIndent());        assertEquals(COMPLEX_CHILD_SSL, line6.getOption());        assertFalse(i.hasNext());    }    public void testHelpLines_NoArgument() {        final Option option = buildComplexParent();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        final List lines = option.helpLines(0, settings, null);        final Iterator i = lines.iterator();        final HelpLine line1 = (HelpLine) i.next();        assertEquals(0, line1.getIndent());        assertEquals(option, line1.getOption());        final HelpLine line3 = (HelpLine) i.next();        assertEquals(1, line3.getIndent());        assertEquals(COMPLEX_CHILDREN, line3.getOption());        final HelpLine line4 = (HelpLine) i.next();        assertEquals(2, line4.getIndent());        assertEquals(COMPLEX_CHILD_BASIC, line4.getOption());        final HelpLine line5 = (HelpLine) i.next();        assertEquals(2, line5.getIndent());        assertEquals(COMPLEX_CHILD_DIGEST, line5.getOption());        final HelpLine line6 = (HelpLine) i.next();        assertEquals(2, line6.getIndent());        assertEquals(COMPLEX_CHILD_SSL, line6.getOption());        assertFalse(i.hasNext());    }    public void testHelpLines_NoChildren() {        final Option option = buildComplexParent();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);        final List lines = option.helpLines(0, settings, null);        final Iterator i = lines.iterator();        final HelpLine line1 = (HelpLine) i.next();        assertEquals(0, line1.getIndent());        assertEquals(option, line1.getOption());        final HelpLine line2 = (HelpLine) i.next();        assertEquals(1, line2.getIndent());        assertEquals(COMPLEX_ARGUMENT, line2.getOption());        assertFalse(i.hasNext());    }    public void testNullPreferredName() {        try {        \tnew CommandBuilder().create();        } catch (IllegalStateException exp) {        \tassertEquals(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME), exp.getMessage());        }    }    public void testRequired() {    \tCommand cmd = new CommandBuilder().withRequired(true).withName(\"blah\").create();    \tassertTrue(\"cmd is not required\", cmd.isRequired());    \tassertEquals(\"id is incorrect\", 0, cmd.getId());    }    public void testID() {    \tCommand cmd = new CommandBuilder().withId('c').withName(\"blah\").create();    \tassertEquals(\"id is incorrect\", 'c', cmd.getId());    }    public void testGetId() {        assertEquals('h', DefaultOptionTest.buildHelpOption().getId());        assertEquals('X', DefaultOptionTest.buildXOption().getId());        assertEquals(0, CommandTest.buildStartCommand().getId());    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.Argument;\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.builder.ArgumentBuilder;\n+import org.apache.commons.cli2.builder.CommandBuilder;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class ParentTest\n+    extends ParentTestCase {\n+    public static final Argument COMPLEX_ARGUMENT =\n+        new ArgumentBuilder().withName(\"username\").withMinimum(1).withMaximum(1).create();\n+    public static final Option COMPLEX_CHILD_SSL =\n+        new DefaultOptionBuilder().withLongName(\"ssl\").withShortName(\"s\").create();\n+    public static final Option COMPLEX_CHILD_BASIC =\n+        new DefaultOptionBuilder().withLongName(\"basic\").withShortName(\"b\").create();\n+    public static final Option COMPLEX_CHILD_DIGEST =\n+        new DefaultOptionBuilder().withLongName(\"digest\").withShortName(\"d\").create();\n+    public static final Group COMPLEX_CHILDREN =\n+        new GroupBuilder().withName(\"login-opts\").withOption(COMPLEX_CHILD_BASIC)\n+                          .withOption(COMPLEX_CHILD_DIGEST).withOption(COMPLEX_CHILD_SSL).create();\n+\n+    public static Parent buildLibParent() {\n+        final Argument argument = ArgumentTest.buildPathArgument();\n+\n+        return new DefaultOption(\"-\", \"--\", false, \"--lib\", \"Specifies library search path\", null,\n+                                 null, false, argument, null, 'l');\n+    }\n+\n+    public static Parent buildKParent() {\n+        final Group children = GroupTest.buildApacheCommandGroup();\n+\n+        return new DefaultOption(\"-\", \"--\", false, \"-k\", \"desc\", null, null, false, null, children,\n+                                 'k');\n+    }\n+\n+    public static Parent buildComplexParent() {\n+        return new CommandBuilder().withName(\"login\").withName(\"lo\").withName(\"l\")\n+                                   .withArgument(COMPLEX_ARGUMENT).withChildren(COMPLEX_CHILDREN)\n+                                   .create();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+     */\n+    public void testProcessParent()\n+        throws OptionException {\n+        final Parent option = buildKParent();\n+        final List args = list(\"-k\", \"start\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertEquals(\"start\", iterator.next());\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"-k\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Parent option = buildKParent();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"-k\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Parent option = buildKParent();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"-K\"));\n+    }\n+\n+    public void testCanProcess_ContractedArgument() {\n+        final Parent option = buildLibParent();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"--lib=/usr/lib\"));\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Parent option = buildKParent();\n+        assertContentsEqual(list(\"-\", \"--\"), option.getPrefixes());\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess()\n+        throws OptionException {\n+        final Parent option = CommandTest.buildStartCommand();\n+        final List args = list(\"start\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"start\"));\n+        assertFalse(commandLine.hasOption(\"stop\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcess_NoMatch()\n+        throws OptionException {\n+        final Parent option = CommandTest.buildStartCommand();\n+        final List args = list(\"whatever\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.process(commandLine, iterator);\n+            fail(\"unexpected token not thrown\");\n+        } catch (OptionException exp) {\n+            OptionException e =\n+                new OptionException(option, ResourceConstants.UNEXPECTED_TOKEN, \"whatever\");\n+            assertEquals(\"wrong exception message\", e.getMessage(), exp.getMessage());\n+        }\n+    }\n+\n+    public void testProcess_Children()\n+        throws OptionException {\n+        final Parent option = buildKParent();\n+        final List args = list(\"-k\", \"start\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertNull(option.findOption(\"whatever\"));\n+        assertNotNull(option.findOption(\"start\"));\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"-k\"));\n+        assertTrue(commandLine.hasOption(\"start\"));\n+        assertFalse(commandLine.hasOption(\"stop\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcess_Argument()\n+        throws OptionException {\n+        final Parent option = buildLibParent();\n+        final List args = list(\"--lib=C:\\\\WINDOWS;C:\\\\WINNT;C:\\\\\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"--lib\"));\n+        assertContentsEqual(list(\"C:\\\\WINDOWS\", \"C:\\\\WINNT\", \"C:\\\\\"), commandLine.getValues(option));\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Parent option = buildKParent();\n+        assertContentsEqual(list(\"-k\"), option.getTriggers());\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate()\n+        throws OptionException {\n+        final Parent option = CommandTest.buildStartCommand();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        option.validate(commandLine);\n+\n+        commandLine.addOption(option);\n+\n+        option.validate(commandLine);\n+    }\n+\n+    public void testValidate_Children()\n+        throws OptionException {\n+        final Parent option = buildKParent();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        option.validate(commandLine);\n+        commandLine.addOption(option);\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing a command\");\n+        } catch (OptionException moe) {\n+            assertNotNull(moe.getOption());\n+            assertNotSame(option, moe.getOption());\n+        }\n+    }\n+\n+    public void testValidate_Argument()\n+        throws OptionException {\n+        final Command option = CommandTest.buildLoginCommand();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        option.validate(commandLine);\n+\n+        commandLine.addOption(option);\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing a value\");\n+        } catch (OptionException moe) {\n+            assertSame(option, moe.getOption());\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildComplexParent();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[login (l,lo) <username> [login-opts (--basic (-b)|--digest (-d)|--ssl (-s))]]\",\n+                     buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoArguments() {\n+        final Option option = buildComplexParent();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        settings.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[login (l,lo) [login-opts (--basic (-b)|--digest (-d)|--ssl (-s))]]\",\n+                     buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoChildren() {\n+        final Option option = buildComplexParent();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[login (l,lo) <username>]\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoArgumentsOrChildren() {\n+        final Option option = buildComplexParent();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+        settings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"[login (l,lo)]\", buffer.toString());\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildLibParent();\n+        assertEquals(\"--lib\", option.getPreferredName());\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildLibParent();\n+        assertEquals(\"Specifies library search path\", option.getDescription());\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        final Option option = buildComplexParent();\n+        final List lines = option.helpLines(0, DisplaySetting.ALL, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine) i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        final HelpLine line2 = (HelpLine) i.next();\n+        assertEquals(1, line2.getIndent());\n+        assertEquals(COMPLEX_ARGUMENT, line2.getOption());\n+\n+        final HelpLine line3 = (HelpLine) i.next();\n+        assertEquals(1, line3.getIndent());\n+        assertEquals(COMPLEX_CHILDREN, line3.getOption());\n+\n+        final HelpLine line4 = (HelpLine) i.next();\n+        assertEquals(2, line4.getIndent());\n+        assertEquals(COMPLEX_CHILD_BASIC, line4.getOption());\n+\n+        final HelpLine line5 = (HelpLine) i.next();\n+        assertEquals(2, line5.getIndent());\n+        assertEquals(COMPLEX_CHILD_DIGEST, line5.getOption());\n+\n+        final HelpLine line6 = (HelpLine) i.next();\n+        assertEquals(2, line6.getIndent());\n+        assertEquals(COMPLEX_CHILD_SSL, line6.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testHelpLines_NoArgument() {\n+        final Option option = buildComplexParent();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine) i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        final HelpLine line3 = (HelpLine) i.next();\n+        assertEquals(1, line3.getIndent());\n+        assertEquals(COMPLEX_CHILDREN, line3.getOption());\n+\n+        final HelpLine line4 = (HelpLine) i.next();\n+        assertEquals(2, line4.getIndent());\n+        assertEquals(COMPLEX_CHILD_BASIC, line4.getOption());\n+\n+        final HelpLine line5 = (HelpLine) i.next();\n+        assertEquals(2, line5.getIndent());\n+        assertEquals(COMPLEX_CHILD_DIGEST, line5.getOption());\n+\n+        final HelpLine line6 = (HelpLine) i.next();\n+        assertEquals(2, line6.getIndent());\n+        assertEquals(COMPLEX_CHILD_SSL, line6.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testHelpLines_NoChildren() {\n+        final Option option = buildComplexParent();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine) i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        final HelpLine line2 = (HelpLine) i.next();\n+        assertEquals(1, line2.getIndent());\n+        assertEquals(COMPLEX_ARGUMENT, line2.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testNullPreferredName() {\n+        try {\n+        \tnew CommandBuilder().create();\n+        } catch (IllegalStateException exp) {\n+        \tassertEquals(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME), exp.getMessage());\n+        }\n+    }\n+\n+    public void testRequired() {\n+    \tCommand cmd = new CommandBuilder().withRequired(true).withName(\"blah\").create();\n+    \tassertTrue(\"cmd is not required\", cmd.isRequired());\n+    \tassertEquals(\"id is incorrect\", 0, cmd.getId());\n+    }\n+\n+    public void testID() {\n+    \tCommand cmd = new CommandBuilder().withId('c').withName(\"blah\").create();\n+    \tassertEquals(\"id is incorrect\", 'c', cmd.getId());\n+    }\n+\n+    public void testGetId() {\n+        assertEquals('h', DefaultOptionTest.buildHelpOption().getId());\n+        assertEquals('X', DefaultOptionTest.buildXOption().getId());\n+        assertEquals(0, CommandTest.buildStartCommand().getId());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/ParentTestCase.java\n+++ b/src/test/org/apache/commons/cli2/option/ParentTestCase.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import org.apache.commons.cli2.OptionException;/** * @author Rob Oxspring */public abstract class ParentTestCase extends OptionTestCase {    public abstract void testProcessParent() throws OptionException;}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import org.apache.commons.cli2.OptionException;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public abstract class ParentTestCase extends OptionTestCase {\n+    public abstract void testProcessParent() throws OptionException;\n+}\n--- a/src/test/org/apache/commons/cli2/option/PropertyOptionTest.java\n+++ b/src/test/org/apache/commons/cli2/option/PropertyOptionTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.HelpLine;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;/** * @author Rob Oxspring */public class PropertyOptionTest extends OptionTestCase {    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()     */    public void testCanProcess() {        final Option option = new PropertyOption();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option,null), \"-Dmyprop=myval\"));    }    public void testCanProcess_Null() {        final Option option = new PropertyOption();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null), (String) null));    }    public void testCanProcess_TooShort() {        final Option option = new PropertyOption();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null), \"-D\"));    }    public void testCanProcess_BadMatch() {        final Option option = new PropertyOption();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null),\"-dump\"));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()     */    public void testPrefixes() {        final Option option = new PropertyOption();        assertContentsEqual(list(\"-D\"), option.getPrefixes());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testProcess()     */    public void testProcess() throws OptionException {        final Option option = new PropertyOption();        final List args = list(\"-Dmyprop=myvalue\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertEquals(\"myvalue\", commandLine.getProperty(\"myprop\"));        assertFalse(iterator.hasNext());        assertEquals(1, commandLine.getProperties().size());    }    public void testProcess_UnexpectedOptionException() {        final Option option = new PropertyOption();        final List args = list(\"--help\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        try {            option.process(commandLine, iterator);            fail(\"UnexpectedOption\");        }        catch (final OptionException uoe) {            assertEquals(option, uoe.getOption());            assertEquals(                \"Unexpected --help while processing -Dproperty=value\",                uoe.getMessage());        }    }    public void testProcess_BadPropertyException() throws OptionException {        final Option option = new PropertyOption();        final List args = list(\"-Dmyprop\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertEquals(\"true\", commandLine.getProperty(\"myprop\"));    }    public void testProcess_SetToEmpty() throws OptionException {        final Option option = new PropertyOption();        final List args = list(\"-Dmyprop=\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertEquals(\"\", commandLine.getProperty(\"myprop\"));        assertFalse(iterator.hasNext());        assertEquals(1, commandLine.getProperties().size());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()     */    public void testTriggers() {        final Option option = new PropertyOption();        assertContentsEqual(list(\"-D\"), option.getTriggers());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testValidate()     */    public void testValidate() throws OptionException {        final Option option = new PropertyOption();        final List args = list(\"-Dproperty=value\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        option.validate(commandLine);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()     */    public void testAppendUsage() {        final Option option = new PropertyOption();        final StringBuffer buffer = new StringBuffer();        option.appendUsage(buffer, DisplaySetting.ALL, null);        assertEquals(\"-D<property>=<value>\", buffer.toString());    }    public void testAppendUsage_Hidden() {        final Option option = new PropertyOption();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_PROPERTY_OPTION);        option.appendUsage(buffer, settings, null);        assertEquals(\"\", buffer.toString());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()     */    public void testGetPreferredName() {        final Option option = new PropertyOption();        assertEquals(\"-D\", option.getPreferredName());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()     */    public void testGetDescription() {        final Option option = new PropertyOption();        assertEquals(            \"Passes properties and values to the application\",            option.getDescription());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines() {        final Option option = new PropertyOption();        final List lines = option.helpLines(0, DisplaySetting.ALL, null);        final Iterator i = lines.iterator();        final HelpLine line1 = (HelpLine)i.next();        assertEquals(0, line1.getIndent());        assertEquals(option, line1.getOption());        assertFalse(i.hasNext());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines_NoDisplay() {        final Option option = new PropertyOption();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_PROPERTY_OPTION);        final List lines = option.helpLines(0, settings, null);        final Iterator i = lines.iterator();        assertFalse(i.hasNext());    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.HelpLine;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class PropertyOptionTest extends OptionTestCase {\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Option option = new PropertyOption();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option,null), \"-Dmyprop=myval\"));\n+    }\n+\n+    public void testCanProcess_Null() {\n+        final Option option = new PropertyOption();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null), (String) null));\n+    }\n+\n+    public void testCanProcess_TooShort() {\n+        final Option option = new PropertyOption();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null), \"-D\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Option option = new PropertyOption();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option,null),\"-dump\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Option option = new PropertyOption();\n+        assertContentsEqual(list(\"-D\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dmyprop=myvalue\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+        assertEquals(\"myvalue\", commandLine.getProperty(\"myprop\"));\n+        assertFalse(iterator.hasNext());\n+        assertEquals(1, commandLine.getProperties().size());\n+    }\n+\n+    public void testProcess_UnexpectedOptionException() {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"--help\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        try {\n+            option.process(commandLine, iterator);\n+            fail(\"UnexpectedOption\");\n+        }\n+        catch (final OptionException uoe) {\n+            assertEquals(option, uoe.getOption());\n+            assertEquals(\n+                \"Unexpected --help while processing -Dproperty=value\",\n+                uoe.getMessage());\n+        }\n+    }\n+\n+    public void testProcess_BadPropertyException() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dmyprop\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+\n+        assertEquals(\"true\", commandLine.getProperty(\"myprop\"));\n+    }\n+\n+    public void testProcess_SetToEmpty() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dmyprop=\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+        assertEquals(\"\", commandLine.getProperty(\"myprop\"));\n+        assertFalse(iterator.hasNext());\n+        assertEquals(1, commandLine.getProperties().size());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Option option = new PropertyOption();\n+\n+        assertContentsEqual(list(\"-D\"), option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() throws OptionException {\n+        final Option option = new PropertyOption();\n+        final List args = list(\"-Dproperty=value\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+\n+        option.process(commandLine, iterator);\n+\n+        option.validate(commandLine);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = new PropertyOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"-D<property>=<value>\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_Hidden() {\n+        final Option option = new PropertyOption();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = new PropertyOption();\n+        assertEquals(\"-D\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = new PropertyOption();\n+        assertEquals(\n+            \"Passes properties and values to the application\",\n+            option.getDescription());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        final Option option = new PropertyOption();\n+        final List lines = option.helpLines(0, DisplaySetting.ALL, null);\n+        final Iterator i = lines.iterator();\n+\n+        final HelpLine line1 = (HelpLine)i.next();\n+        assertEquals(0, line1.getIndent());\n+        assertEquals(option, line1.getOption());\n+\n+        assertFalse(i.hasNext());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines_NoDisplay() {\n+        final Option option = new PropertyOption();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+        final List lines = option.helpLines(0, settings, null);\n+        final Iterator i = lines.iterator();\n+\n+        assertFalse(i.hasNext());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/option/SwitchTest.java\n+++ b/src/test/org/apache/commons/cli2/option/SwitchTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.option;import java.util.HashSet;import java.util.List;import java.util.ListIterator;import java.util.Set;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.Parent;import org.apache.commons.cli2.WriteableCommandLine;import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * @author Rob Oxspring * * To change the template for this generated type comment go to * Window>Preferences>Java>Code Generation>Code and Comments */public class SwitchTest    extends ParentTestCase {    public static Switch buildDisplaySwitch() {        final Set aliases = new HashSet();        aliases.add(\"d\");        aliases.add(\"disp\");        return new Switch(\"+\", \"-\", \"display\", aliases, \"Sets whether to display to screen\", true,                          null, null, 'd', null);    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()     */    public void testProcessParent()        throws OptionException {        final Switch option = buildDisplaySwitch();        final List args = list(\"+d\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.processParent(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"+d\"));        assertTrue(commandLine.hasOption(\"-display\"));        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"-d\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    public void testProcessParent_Disabled()        throws OptionException {        final Switch option = buildDisplaySwitch();        final List args = list(\"-disp\");        final WriteableCommandLine commandLine = commandLine(option, args);        final ListIterator iterator = args.listIterator();        option.process(commandLine, iterator);        assertFalse(iterator.hasNext());        assertTrue(commandLine.hasOption(option));        assertTrue(commandLine.hasOption(\"+d\"));        assertTrue(commandLine.hasOption(\"-display\"));        assertEquals(Boolean.FALSE, commandLine.getSwitch(\"-d\"));        assertTrue(commandLine.getValues(option).isEmpty());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()     */    public void testCanProcess() {        final Switch option = buildDisplaySwitch();        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"+d\"));    }    public void testCanProcess_BadMatch() {        final Switch option = buildDisplaySwitch();        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"-dont\"));    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()     */    public void testPrefixes() {        final Switch option = buildDisplaySwitch();        assertContentsEqual(list(\"-\", \"+\"), option.getPrefixes());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testProcess()     */    public void testProcess() {        // TODO Auto-generated method stub    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()     */    public void testTriggers() {        final Switch option = buildDisplaySwitch();        assertContentsEqual(list(\"-d\", \"+d\", \"-disp\", \"+disp\", \"+display\", \"-display\"),                            option.getTriggers());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testValidate()     */    public void testValidate() {        final Parent option = buildDisplaySwitch();        final WriteableCommandLine commandLine = commandLine(option, list());        try {            option.validate(commandLine);            fail(\"Missing an option\");        } catch (OptionException moe) {            assertSame(option, moe.getOption());        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()     */    public void testAppendUsage() {        final Option option = buildDisplaySwitch();        final StringBuffer buffer = new StringBuffer();        option.appendUsage(buffer, DisplaySetting.ALL, null);        assertEquals(\"+display|-display (+d|-d,+disp|-disp)\", buffer.toString());    }    public void testAppendUsage_NoAlias() {        final Option option = buildDisplaySwitch();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_ALIASES);        option.appendUsage(buffer, settings, null);        assertEquals(\"+display|-display\", buffer.toString());    }    public void testAppendUsage_NoDisabled() {        final Option option = buildDisplaySwitch();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_SWITCH_DISABLED);        option.appendUsage(buffer, settings, null);        assertEquals(\"+display (+d,+disp)\", buffer.toString());    }    public void testAppendUsage_NoEnabled() {        final Option option = buildDisplaySwitch();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_SWITCH_ENABLED);        option.appendUsage(buffer, settings, null);        assertEquals(\"-display (-d,-disp)\", buffer.toString());    }    public void testAppendUsage_NoDisabledOrEnabled() {        final Option option = buildDisplaySwitch();        final StringBuffer buffer = new StringBuffer();        final Set settings = new HashSet(DisplaySetting.ALL);        settings.remove(DisplaySetting.DISPLAY_SWITCH_DISABLED);        settings.remove(DisplaySetting.DISPLAY_SWITCH_ENABLED);        option.appendUsage(buffer, settings, null);        assertEquals(\"+display (+d,+disp)\", buffer.toString());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()     */    public void testGetPreferredName() {        final Option option = buildDisplaySwitch();        assertEquals(\"+display\", option.getPreferredName());    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()     */    public void testGetDescription() {        final Option option = buildDisplaySwitch();        assertEquals(\"Sets whether to display to screen\", option.getDescription());    }    public void testNullPreferredName() {        try {            new Switch(\"+\", \"-\", null, null, \"Sets whether to display to screen\", true, null, null,                       'd', null);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT),                         exp.getMessage());        }    }    public void testEmptyPreferredName() {        try {            new Switch(\"+\", \"-\", \"\", null, \"Sets whether to display to screen\", true, null, null,                       'd', null);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT),                         exp.getMessage());        }    }    public void testNullAliases() {        try {            new Switch(\"+\", \"-\", \"display\", null, \"Sets whether to display to screen\", true, null,                       null, 'd', null);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT),                         exp.getMessage());        }    }    public void testNullEnablePrefix() {        try {            new Switch(null, \"-\", \"display\", null, \"Sets whether to display to screen\", true, null,                       null, 'd', null);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_NO_ENABLED_PREFIX),                         exp.getMessage());        }    }    public void testNullDisablePrefix() {        try {            new Switch(\"+\", null, \"display\", null, \"Sets whether to display to screen\", true, null,                       null, 'd', null);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_NO_DISABLED_PREFIX),                         exp.getMessage());        }    }    public void testEnabledPrefixStartsWithDisabledPrefix() {        try {            new Switch(\"-\", \"-\", \"display\", null, \"Sets whether to display to screen\", true, null,                       null, 'd', null);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ENABLED_STARTS_WITH_DISABLED),                         exp.getMessage());        }    }    public void testDisabledPrefixStartsWithEnabledPrefix() {        try {            new Switch(\"o\", \"on\", \"display\", null, \"Sets whether to display to screen\", true, null,                       null, 'd', null);        } catch (IllegalArgumentException exp) {            assertEquals(\"wrong exception message\",                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_DISABLED_STARTWS_WITH_ENABLED),                         exp.getMessage());        }    }    /*     * (non-Javadoc)     *     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()     */    public void testHelpLines() {        // TODO Auto-generated method stub    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.option;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.Parent;\n+import org.apache.commons.cli2.WriteableCommandLine;\n+import org.apache.commons.cli2.commandline.WriteableCommandLineImpl;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * @author Rob Oxspring\n+ *\n+ * To change the template for this generated type comment go to\n+ * Window>Preferences>Java>Code Generation>Code and Comments\n+ */\n+public class SwitchTest\n+    extends ParentTestCase {\n+    public static Switch buildDisplaySwitch() {\n+        final Set aliases = new HashSet();\n+        aliases.add(\"d\");\n+        aliases.add(\"disp\");\n+\n+        return new Switch(\"+\", \"-\", \"display\", aliases, \"Sets whether to display to screen\", true,\n+                          null, null, 'd', null);\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.ParentTestCase#testProcessParent()\n+     */\n+    public void testProcessParent()\n+        throws OptionException {\n+        final Switch option = buildDisplaySwitch();\n+        final List args = list(\"+d\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.processParent(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"+d\"));\n+        assertTrue(commandLine.hasOption(\"-display\"));\n+        assertEquals(Boolean.TRUE, commandLine.getSwitch(\"-d\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    public void testProcessParent_Disabled()\n+        throws OptionException {\n+        final Switch option = buildDisplaySwitch();\n+        final List args = list(\"-disp\");\n+        final WriteableCommandLine commandLine = commandLine(option, args);\n+        final ListIterator iterator = args.listIterator();\n+        option.process(commandLine, iterator);\n+\n+        assertFalse(iterator.hasNext());\n+        assertTrue(commandLine.hasOption(option));\n+        assertTrue(commandLine.hasOption(\"+d\"));\n+        assertTrue(commandLine.hasOption(\"-display\"));\n+        assertEquals(Boolean.FALSE, commandLine.getSwitch(\"-d\"));\n+        assertTrue(commandLine.getValues(option).isEmpty());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testCanProcess()\n+     */\n+    public void testCanProcess() {\n+        final Switch option = buildDisplaySwitch();\n+        assertTrue(option.canProcess(new WriteableCommandLineImpl(option, null), \"+d\"));\n+    }\n+\n+    public void testCanProcess_BadMatch() {\n+        final Switch option = buildDisplaySwitch();\n+        assertFalse(option.canProcess(new WriteableCommandLineImpl(option, null), \"-dont\"));\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testPrefixes()\n+     */\n+    public void testPrefixes() {\n+        final Switch option = buildDisplaySwitch();\n+        assertContentsEqual(list(\"-\", \"+\"), option.getPrefixes());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testProcess()\n+     */\n+    public void testProcess() {\n+        // TODO Auto-generated method stub\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testTriggers()\n+     */\n+    public void testTriggers() {\n+        final Switch option = buildDisplaySwitch();\n+        assertContentsEqual(list(\"-d\", \"+d\", \"-disp\", \"+disp\", \"+display\", \"-display\"),\n+                            option.getTriggers());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testValidate()\n+     */\n+    public void testValidate() {\n+        final Parent option = buildDisplaySwitch();\n+        final WriteableCommandLine commandLine = commandLine(option, list());\n+\n+        try {\n+            option.validate(commandLine);\n+            fail(\"Missing an option\");\n+        } catch (OptionException moe) {\n+            assertSame(option, moe.getOption());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testAppendUsage()\n+     */\n+    public void testAppendUsage() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        option.appendUsage(buffer, DisplaySetting.ALL, null);\n+\n+        assertEquals(\"+display|-display (+d|-d,+disp|-disp)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoAlias() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_ALIASES);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"+display|-display\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoDisabled() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"+display (+d,+disp)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoEnabled() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"-display (-d,-disp)\", buffer.toString());\n+    }\n+\n+    public void testAppendUsage_NoDisabledOrEnabled() {\n+        final Option option = buildDisplaySwitch();\n+        final StringBuffer buffer = new StringBuffer();\n+        final Set settings = new HashSet(DisplaySetting.ALL);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        settings.remove(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+        option.appendUsage(buffer, settings, null);\n+\n+        assertEquals(\"+display (+d,+disp)\", buffer.toString());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetPreferredName()\n+     */\n+    public void testGetPreferredName() {\n+        final Option option = buildDisplaySwitch();\n+        assertEquals(\"+display\", option.getPreferredName());\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testGetDescription()\n+     */\n+    public void testGetDescription() {\n+        final Option option = buildDisplaySwitch();\n+        assertEquals(\"Sets whether to display to screen\", option.getDescription());\n+    }\n+\n+    public void testNullPreferredName() {\n+        try {\n+            new Switch(\"+\", \"-\", null, null, \"Sets whether to display to screen\", true, null, null,\n+                       'd', null);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testEmptyPreferredName() {\n+        try {\n+            new Switch(\"+\", \"-\", \"\", null, \"Sets whether to display to screen\", true, null, null,\n+                       'd', null);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testNullAliases() {\n+        try {\n+            new Switch(\"+\", \"-\", \"display\", null, \"Sets whether to display to screen\", true, null,\n+                       null, 'd', null);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_PREFERRED_NAME_TOO_SHORT),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testNullEnablePrefix() {\n+        try {\n+            new Switch(null, \"-\", \"display\", null, \"Sets whether to display to screen\", true, null,\n+                       null, 'd', null);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_NO_ENABLED_PREFIX),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testNullDisablePrefix() {\n+        try {\n+            new Switch(\"+\", null, \"display\", null, \"Sets whether to display to screen\", true, null,\n+                       null, 'd', null);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_NO_DISABLED_PREFIX),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testEnabledPrefixStartsWithDisabledPrefix() {\n+        try {\n+            new Switch(\"-\", \"-\", \"display\", null, \"Sets whether to display to screen\", true, null,\n+                       null, 'd', null);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ENABLED_STARTS_WITH_DISABLED),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    public void testDisabledPrefixStartsWithEnabledPrefix() {\n+        try {\n+            new Switch(\"o\", \"on\", \"display\", null, \"Sets whether to display to screen\", true, null,\n+                       null, 'd', null);\n+        } catch (IllegalArgumentException exp) {\n+            assertEquals(\"wrong exception message\",\n+                         ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_DISABLED_STARTWS_WITH_ENABLED),\n+                         exp.getMessage());\n+        }\n+    }\n+\n+    /*\n+     * (non-Javadoc)\n+     *\n+     * @see org.apache.commons.cli2.OptionTestCase#testHelpLines()\n+     */\n+    public void testHelpLines() {\n+        // TODO Auto-generated method stub\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/resource/ResourceHelperTest.java\n+++ b/src/test/org/apache/commons/cli2/resource/ResourceHelperTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */package org.apache.commons.cli2.resource;import java.util.Locale;import java.util.MissingResourceException;import java.util.ResourceBundle;import junit.framework.TestCase;/** * A utility class used to provide internationalisation support. * * @author John Keyes */public class ResourceHelperTest extends TestCase {    /** system property */    private static final String PROP_LOCALE = \"org.apache.commons.cli2.resource.bundle\";    private static ResourceHelper helper;    /** resource bundle */    private ResourceBundle bundle;    public void setUp() {    \tSystem.setProperty(PROP_LOCALE, \"org.apache.commons.cli2.resource.TestBundle\");    \thelper = ResourceHelper.getResourceHelper();    }    public void tearDown() {    \tSystem.setProperty(PROP_LOCALE, \"org.apache.commons.cli2.resource.CLIMessageBundle_en_US.properties\");    }    /**     * Create a new ResourceHelper for the specified class.     *     * @param clazz the Class that requires some resources     */    public ResourceHelperTest() {    \tsuper(\"ResourceHelperTest\");    }    public void testOverridden() {    \tassertEquals(\"wrong message\", \"The class name \\\"ResourceHelper\\\" is invalid.\", helper.getMessage(\"ClassValidator.bad.classname\", \"ResourceHelper\"));    }    public void testNewMessage1Param() {    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\"));    }    public void testNewMessage2Params() {    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\", \"Some\"));    }    public void testNewMessage3Params() {    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\", \"Some\", \"might\"));    }    public void testNewMessage4Params() {    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\", \"Some\", \"might\", \"say\"));    }    public void testDefaultBundle() {    \tSystem.setProperty(PROP_LOCALE, \"madeupname.properties\");    \thelper = ResourceHelper.getResourceHelper();    \tassertEquals(\"wrong message\", \"The class name \\\"ResourceHelper\\\" is invalid.\", helper.getMessage(\"ClassValidator.bad.classname\", \"ResourceHelper\"));    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.cli2.resource;\n+\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * A utility class used to provide internationalisation support.\n+ *\n+ * @author John Keyes\n+ */\n+public class ResourceHelperTest extends TestCase {\n+    /** system property */\n+    private static final String PROP_LOCALE = \"org.apache.commons.cli2.resource.bundle\";\n+\n+    private static ResourceHelper helper;\n+\n+    /** resource bundle */\n+    private ResourceBundle bundle;\n+\n+    public void setUp() {\n+    \tSystem.setProperty(PROP_LOCALE, \"org.apache.commons.cli2.resource.TestBundle\");\n+    \thelper = ResourceHelper.getResourceHelper();\n+    }\n+    \n+    public void tearDown() {\n+    \tSystem.setProperty(PROP_LOCALE, \"org.apache.commons.cli2.resource.CLIMessageBundle_en_US.properties\");\n+    }\n+    \n+    /**\n+     * Create a new ResourceHelper for the specified class.\n+     *\n+     * @param clazz the Class that requires some resources\n+     */\n+    public ResourceHelperTest() {\n+    \tsuper(\"ResourceHelperTest\");\n+    }\n+    \n+    public void testOverridden() {\n+    \tassertEquals(\"wrong message\", \"The class name \\\"ResourceHelper\\\" is invalid.\", helper.getMessage(\"ClassValidator.bad.classname\", \"ResourceHelper\"));\n+    }\n+    \n+    public void testNewMessage1Param() {\n+    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\"));\n+    }\n+\n+    public void testNewMessage2Params() {\n+    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\", \"Some\"));\n+    }\n+\n+    public void testNewMessage3Params() {\n+    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\", \"Some\", \"might\"));\n+    }\n+\n+    public void testNewMessage4Params() {\n+    \tassertEquals(\"wrong message\", \"Some might say we will find a brighter day.\", helper.getMessage(\"test.message\", \"Some\", \"might\", \"say\"));\n+    }\n+\n+    public void testDefaultBundle() {\n+    \tSystem.setProperty(PROP_LOCALE, \"madeupname.properties\");\n+    \thelper = ResourceHelper.getResourceHelper();\n+    \tassertEquals(\"wrong message\", \"The class name \\\"ResourceHelper\\\" is invalid.\", helper.getMessage(\"ClassValidator.bad.classname\", \"ResourceHelper\"));\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/util/ComparatorsTest.java\n+++ b/src/test/org/apache/commons/cli2/util/ComparatorsTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.util;import java.util.Collections;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.CLITestCase;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.option.CommandTest;import org.apache.commons.cli2.option.DefaultOptionTest;import org.apache.commons.cli2.option.GroupTest;import org.apache.commons.cli2.option.ParentTest;import org.apache.commons.cli2.option.SwitchTest;/** * @author Rob Oxspring */public class ComparatorsTest extends TestCase {    public void testGroupFirst() {        final Option o1 = GroupTest.buildAntGroup();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.groupFirst());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o1, o2),            list);    }    public void testGroupLast() {        final Option o1 = GroupTest.buildAntGroup();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.groupLast());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o2, o1),            list);    }    public void testSwitchFirst() {        final Option o1 = SwitchTest.buildDisplaySwitch();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.switchFirst());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o1, o2),            list);    }    public void testSwitchLast() {        final Option o1 = SwitchTest.buildDisplaySwitch();        final Option o2 = ParentTest.buildLibParent();        //final Option o3 = new SwitchBuilder().withName(\"hidden\").create();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.switchLast());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o2, o1),            list);    }    public void testCommandFirst() {        final Option o1 = CommandTest.buildCommitCommand();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.commandFirst());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o1, o2),            list);    }    public void testCommandLast() {        final Option o1 = CommandTest.buildCommitCommand();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.commandLast());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o2, o1),            list);    }    public void testDefaultOptionFirst() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = CommandTest.buildCommitCommand();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.defaultOptionFirst());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o1, o2),            list);    }    public void testDefaultOptionLast() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = CommandTest.buildCommitCommand();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.defaultOptionLast());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o2, o1),            list);    }    public void testNamedFirst() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.namedFirst(\"--help\"));        CLITestCase.assertListContentsEqual(            CLITestCase.list(o1, o2),            list);    }    public void testNamedLast() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.namedLast(\"--help\"));        CLITestCase.assertListContentsEqual(            CLITestCase.list(o2, o1),            list);    }    public void testPreferredNameFirst() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.preferredNameFirst());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o1, o2),            list);    }    public void testPreferredNameLast() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = ParentTest.buildLibParent();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.preferredNameLast());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o2, o1),            list);    }    public void testRequiredFirst() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = DefaultOptionTest.buildXOption();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.requiredFirst());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o2, o1),            list);    }    public void testRequiredLast() {        final Option o1 = DefaultOptionTest.buildHelpOption();        final Option o2 = DefaultOptionTest.buildXOption();        final List list = CLITestCase.list(o1, o2);        Collections.sort(list, Comparators.requiredLast());        CLITestCase.assertListContentsEqual(            CLITestCase.list(o1, o2),            list);    }    public void testChained() {        final Option o1 = CommandTest.buildCommitCommand();        final Option o2 = SwitchTest.buildDisplaySwitch();        final Option o3 = DefaultOptionTest.buildHelpOption();        final List list = CLITestCase.list(o1, o2, o3);        Collections.sort(            list,            Comparators.chain(                Comparators.namedFirst(\"--help\"),                Comparators.commandFirst()));        CLITestCase.assertListContentsEqual(            CLITestCase.list(o3, o1, o2),            list);    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.CLITestCase;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.option.CommandTest;\n+import org.apache.commons.cli2.option.DefaultOptionTest;\n+import org.apache.commons.cli2.option.GroupTest;\n+import org.apache.commons.cli2.option.ParentTest;\n+import org.apache.commons.cli2.option.SwitchTest;\n+\n+/**\n+ * @author Rob Oxspring\n+ */\n+public class ComparatorsTest extends TestCase {\n+    public void testGroupFirst() {\n+        final Option o1 = GroupTest.buildAntGroup();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.groupFirst());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testGroupLast() {\n+        final Option o1 = GroupTest.buildAntGroup();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.groupLast());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testSwitchFirst() {\n+        final Option o1 = SwitchTest.buildDisplaySwitch();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.switchFirst());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testSwitchLast() {\n+        final Option o1 = SwitchTest.buildDisplaySwitch();\n+        final Option o2 = ParentTest.buildLibParent();\n+        //final Option o3 = new SwitchBuilder().withName(\"hidden\").create();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.switchLast());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testCommandFirst() {\n+        final Option o1 = CommandTest.buildCommitCommand();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.commandFirst());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testCommandLast() {\n+        final Option o1 = CommandTest.buildCommitCommand();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.commandLast());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testDefaultOptionFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = CommandTest.buildCommitCommand();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.defaultOptionFirst());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testDefaultOptionLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = CommandTest.buildCommitCommand();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.defaultOptionLast());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testNamedFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.namedFirst(\"--help\"));\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testNamedLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.namedLast(\"--help\"));\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testPreferredNameFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.preferredNameFirst());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o1, o2),\n+            list);\n+    }\n+\n+    public void testPreferredNameLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = ParentTest.buildLibParent();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.preferredNameLast());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testRequiredFirst() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = DefaultOptionTest.buildXOption();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.requiredFirst());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o2, o1),\n+            list);\n+    }\n+\n+    public void testRequiredLast() {\n+        final Option o1 = DefaultOptionTest.buildHelpOption();\n+        final Option o2 = DefaultOptionTest.buildXOption();\n+        final List list = CLITestCase.list(o1, o2);\n+\n+        Collections.sort(list, Comparators.requiredLast());\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o1, o2),\n+            list);\n+    }\n+    \n+    public void testChained() {\n+        final Option o1 = CommandTest.buildCommitCommand();\n+        final Option o2 = SwitchTest.buildDisplaySwitch();\n+        final Option o3 = DefaultOptionTest.buildHelpOption();\n+        final List list = CLITestCase.list(o1, o2, o3);\n+        \n+        Collections.sort(\n+            list, \n+            Comparators.chain(\n+                Comparators.namedFirst(\"--help\"),\n+                Comparators.commandFirst()));\n+\n+        CLITestCase.assertListContentsEqual(\n+            CLITestCase.list(o3, o1, o2),\n+            list);\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/util/HelpFormatterTest.java\n+++ b/src/test/org/apache/commons/cli2/util/HelpFormatterTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied.  See the License for the * specific language governing permissions and limitations * under the License. */package org.apache.commons.cli2.util;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.io.StringReader;import java.io.StringWriter;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Set;import junit.framework.TestCase;import org.apache.commons.cli2.DisplaySetting;import org.apache.commons.cli2.Group;import org.apache.commons.cli2.Option;import org.apache.commons.cli2.OptionException;import org.apache.commons.cli2.builder.DefaultOptionBuilder;import org.apache.commons.cli2.builder.GroupBuilder;import org.apache.commons.cli2.option.ArgumentTest;import org.apache.commons.cli2.option.DefaultOptionTest;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;public class HelpFormatterTest    extends TestCase {    private ResourceHelper resources = ResourceHelper.getResourceHelper();    private HelpFormatter helpFormatter;    private Option verbose;    private Group options;    public void setUp() {        helpFormatter = new HelpFormatter(\"|*\", \"*-*\", \"*|\", 80);        helpFormatter.setDivider(\"+------------------------------------------------------------------------------+\");        helpFormatter.setHeader(\"Apache Commons CLI\");        helpFormatter.setFooter(\"Copyright 2003\\nApache Software Foundation\");        helpFormatter.setShellCommand(\"ant\");        verbose =            new DefaultOptionBuilder().withLongName(\"verbose\")                                      .withDescription(\"print the version information and exit\")                                      .create();        options =            new GroupBuilder().withName(\"options\").withOption(DefaultOptionTest.buildHelpOption())                              .withOption(ArgumentTest.buildTargetsArgument())                              .withOption(new DefaultOptionBuilder().withLongName(\"diagnostics\")                                                                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")                                                                    .create())                              .withOption(new DefaultOptionBuilder().withLongName(\"projecthelp\")                                                                    .withDescription(\"print project help information\")                                                                    .create()).withOption(verbose)                              .create();        helpFormatter.setGroup(options);    }    public void testPrint()        throws IOException {        final StringWriter writer = new StringWriter();        final PrintWriter pw = new PrintWriter(writer);        helpFormatter.setPrintWriter(pw);        helpFormatter.print();        // test shell        assertEquals(\"incorrect shell command\", \"ant\", helpFormatter.getShellCommand());        // test group        assertEquals(\"incorrect group\", this.options, helpFormatter.getGroup());        // test pagewidth        assertEquals(\"incorrect page width\", 76, helpFormatter.getPageWidth());        // test pw        assertEquals(\"incorrect print writer\", pw, helpFormatter.getPrintWriter());        // test divider        assertEquals(\"incorrect divider\",                     \"+------------------------------------------------------------------------------+\",                     helpFormatter.getDivider());        // test header        assertEquals(\"incorrect header\", \"Apache Commons CLI\", helpFormatter.getHeader());        // test footer        assertEquals(\"incorrect footer\", \"Copyright 2003\\nApache Software Foundation\",                     helpFormatter.getFooter());        // test gutters        assertEquals(\"incorrect left gutter\", \"|*\", helpFormatter.getGutterLeft());        assertEquals(\"incorrect right gutter\", \"*|\", helpFormatter.getGutterRight());        assertEquals(\"incorrect center gutter\", \"*-*\", helpFormatter.getGutterCenter());        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Apache Commons CLI                                                          *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Usage:                                                                      *|\",                     reader.readLine());        assertEquals(\"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",                     reader.readLine());        assertEquals(\"|*...]]                                                                       *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*options              *-*                                                    *|\",                     reader.readLine());        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",                     reader.readLine());        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",                     reader.readLine());        assertEquals(\"|*                     *-*or report problems.                                 *|\",                     reader.readLine());        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",                     reader.readLine());        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",                     reader.readLine());        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Copyright 2003                                                              *|\",                     reader.readLine());        assertEquals(\"|*Apache Software Foundation                                                  *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testComparator()        throws IOException {        final StringWriter writer = new StringWriter();        final PrintWriter pw = new PrintWriter(writer);        helpFormatter.setPrintWriter(pw);        final Comparator comparator = new OptionComparator();        helpFormatter.setComparator(comparator);        helpFormatter.print();        // test comparator        assertEquals(\"invalid comparator\", comparator, helpFormatter.getComparator());        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Apache Commons CLI                                                          *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Usage:                                                                      *|\",                     reader.readLine());        assertEquals(\"|*ant [--verbose --projecthelp --help --diagnostics] [<target1> [<target2>    *|\",                     reader.readLine());        assertEquals(\"|*...]]                                                                       *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*options              *-*                                                    *|\",                     reader.readLine());        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",                     reader.readLine());        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",                     reader.readLine());        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",                     reader.readLine());        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",                     reader.readLine());        assertEquals(\"|*                     *-*or report problems.                                 *|\",                     reader.readLine());        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Copyright 2003                                                              *|\",                     reader.readLine());        assertEquals(\"|*Apache Software Foundation                                                  *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testPrintHelp()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.printHelp();        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*options              *-*                                                    *|\",                     reader.readLine());        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",                     reader.readLine());        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",                     reader.readLine());        assertEquals(\"|*                     *-*or report problems.                                 *|\",                     reader.readLine());        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",                     reader.readLine());        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",                     reader.readLine());        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testPrintHelp_WithException()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.setException(new OptionException(verbose));        helpFormatter.printHelp();        //System.out.println(writer);        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*--verbose*-*print the version information and exit                          *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testPrintHelp_TooNarrow()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter = new HelpFormatter(\"<\", \"=\", \">\", 4);        helpFormatter.setGroup(options);        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.printHelp();        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"<options              = >\", reader.readLine());        assertEquals(\"<  --help (-?,-h)     =D>\", reader.readLine());        assertEquals(\"<                     =i>\", reader.readLine());        // lots more lines unchecked    }    public void testPrintException()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.setException(new OptionException(verbose, ResourceConstants.MISSING_OPTION));        helpFormatter.printException();        //System.out.println(writer);        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Missing option --verbose                                                    *|\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testPrintUsage()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.printUsage();        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Usage:                                                                      *|\",                     reader.readLine());        assertEquals(\"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",                     reader.readLine());        assertEquals(\"|*...]]                                                                       *|\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testPrintHeader()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.printHeader();        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertEquals(\"|*Apache Commons CLI                                                          *|\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testPrintFooter()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.printFooter();        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"|*Copyright 2003                                                              *|\",                     reader.readLine());        assertEquals(\"|*Apache Software Foundation                                                  *|\",                     reader.readLine());        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testPrintDivider()        throws IOException {        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.printDivider();        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"+------------------------------------------------------------------------------+\",                     reader.readLine());        assertNull(reader.readLine());    }    public void testWrap() {        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 30).iterator();        assertEquals(\"Apache Software Foundation\", i.next());        assertFalse(i.hasNext());    }    public void testWrap_WrapNeeded() {        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 20).iterator();        assertEquals(\"Apache Software\", i.next());        assertEquals(\"Foundation\", i.next());        assertFalse(i.hasNext());    }    public void testWrap_BeforeSpace() {        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 16).iterator();        assertEquals(\"Apache Software\", i.next());        assertEquals(\"Foundation\", i.next());        assertFalse(i.hasNext());    }    public void testWrap_AfterSpace() {        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 17).iterator();        assertEquals(\"Apache Software\", i.next());        assertEquals(\"Foundation\", i.next());        assertFalse(i.hasNext());    }    public void testWrap_InWord() {        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 8).iterator();        assertEquals(\"Apache\", i.next());        assertEquals(\"Software\", i.next());        assertEquals(\"Foundati\", i.next());        assertEquals(\"on\", i.next());        assertFalse(i.hasNext());    }    public void testWrap_NewLine() {        final Iterator i = HelpFormatter.wrap(\"\\nApache Software Foundation\\n\", 30).iterator();        assertEquals(\"\", i.next());        assertEquals(\"Apache Software Foundation\", i.next());        assertEquals(\"\", i.next());        assertFalse(i.hasNext());    }    public void testWrap_NewLine2() {        List wrapped =            HelpFormatter.wrap(\"A really quite long general description of the option with specific alternatives documented:\\n\" +                               \"  Indented special case\\n\" + \"  Alternative scenario\", 30);        final Iterator i = wrapped.iterator();        assertEquals(\"A really quite long general\", i.next());        assertEquals(\"description of the option\", i.next());        assertEquals(\"with specific alternatives\", i.next());        assertEquals(\"documented:\", i.next());        assertEquals(\"  Indented special case\", i.next());        assertEquals(\"  Alternative scenario\", i.next());        assertFalse(i.hasNext());    }    public void testWrap_Below1Length() {        try {            HelpFormatter.wrap(\"Apache Software Foundation\", -1);            fail(\"IllegalArgumentException\");        } catch (IllegalArgumentException e) {            assertEquals(resources.getMessage(ResourceConstants.HELPFORMATTER_WIDTH_TOO_NARROW,                                              new Object[] { new Integer(-1) }), e.getMessage());        }    }    public void testPad()        throws IOException {        final StringWriter writer = new StringWriter();        HelpFormatter.pad(\"hello\", 10, new PrintWriter(writer));        assertEquals(\"hello     \", writer.toString());    }    public void testPad_Null()        throws IOException {        final StringWriter writer = new StringWriter();        HelpFormatter.pad(null, 10, new PrintWriter(writer));        assertEquals(\"          \", writer.toString());    }    public void testPad_TooLong()        throws IOException {        final StringWriter writer = new StringWriter();        HelpFormatter.pad(\"hello world\", 10, new PrintWriter(writer));        assertEquals(\"hello world\", writer.toString());    }    public void testPad_TooShort()        throws IOException {        final StringWriter writer = new StringWriter();        HelpFormatter.pad(\"hello world\", -5, new PrintWriter(writer));        assertEquals(\"hello world\", writer.toString());    }    public void testGutters()        throws IOException {        helpFormatter = new HelpFormatter(null, null, null, 80);        helpFormatter.setShellCommand(\"ant\");        final Set lusage = new HashSet();        lusage.add(DisplaySetting.DISPLAY_ALIASES);        lusage.add(DisplaySetting.DISPLAY_GROUP_NAME);        helpFormatter.setLineUsageSettings(lusage);        // test line usage        assertEquals(\"incorrect line usage\", lusage, helpFormatter.getLineUsageSettings());        final Set fusage = new HashSet();        fusage.add(DisplaySetting.DISPLAY_PARENT_CHILDREN);        fusage.add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);        fusage.add(DisplaySetting.DISPLAY_GROUP_OUTER);        fusage.add(DisplaySetting.DISPLAY_GROUP_EXPANDED);        fusage.add(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);        fusage.add(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);        fusage.add(DisplaySetting.DISPLAY_SWITCH_ENABLED);        fusage.add(DisplaySetting.DISPLAY_SWITCH_DISABLED);        fusage.add(DisplaySetting.DISPLAY_PROPERTY_OPTION);        fusage.add(DisplaySetting.DISPLAY_PARENT_CHILDREN);        fusage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);        fusage.add(DisplaySetting.DISPLAY_OPTIONAL);        helpFormatter.setFullUsageSettings(fusage);        // test line usage        assertEquals(\"incorrect full usage\", fusage, helpFormatter.getFullUsageSettings());        final Set dsettings = new HashSet();        dsettings.add(DisplaySetting.DISPLAY_GROUP_NAME);        dsettings.add(DisplaySetting.DISPLAY_GROUP_EXPANDED);        dsettings.add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);        helpFormatter.setDisplaySettings(dsettings);        verbose =            new DefaultOptionBuilder().withLongName(\"verbose\")                                      .withDescription(\"print the version information and exit\")                                      .create();        options =            new GroupBuilder().withName(\"options\").withOption(DefaultOptionTest.buildHelpOption())                              .withOption(ArgumentTest.buildTargetsArgument())                              .withOption(new DefaultOptionBuilder().withLongName(\"diagnostics\")                                                                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")                                                                    .create())                              .withOption(new DefaultOptionBuilder().withLongName(\"projecthelp\")                                                                    .withDescription(\"print project help information\")                                                                    .create()).withOption(verbose)                              .create();        helpFormatter.setGroup(options);        // test default gutters        assertEquals(\"incorrect left gutter\", HelpFormatter.DEFAULT_GUTTER_LEFT,                     helpFormatter.getGutterLeft());        assertEquals(\"incorrect right gutter\", HelpFormatter.DEFAULT_GUTTER_RIGHT,                     helpFormatter.getGutterRight());        assertEquals(\"incorrect center gutter\", HelpFormatter.DEFAULT_GUTTER_CENTER,                     helpFormatter.getGutterCenter());        final StringWriter writer = new StringWriter();        helpFormatter.setPrintWriter(new PrintWriter(writer));        helpFormatter.print();        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));        assertEquals(\"Usage:                                                                          \",                     reader.readLine());        assertEquals(\"ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2> ...]]  \",                     reader.readLine());        assertEquals(\"options                                                                         \",                     reader.readLine());        assertEquals(\"  --help (-?,-h)         Displays the help                                      \",                     reader.readLine());        assertEquals(\"  --diagnostics          print information that might be helpful to diagnose or \",                     reader.readLine());        assertEquals(\"                         report problems.                                       \",                     reader.readLine());        assertEquals(\"  --projecthelp          print project help information                         \",                     reader.readLine());        assertEquals(\"  --verbose              print the version information and exit                 \",                     reader.readLine());        assertEquals(\"  target [target ...]    The targets ant should build                           \",                     reader.readLine());        assertNull(reader.readLine());    }}class OptionComparator implements Comparator {    public int compare(Object o1,                       Object o2) {        Option opt1 = (Option) o1;        Option opt2 = (Option) o2;        return -opt1.getPreferredName().compareTo(opt2.getPreferredName());    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.cli2.util;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.DisplaySetting;\n+import org.apache.commons.cli2.Group;\n+import org.apache.commons.cli2.Option;\n+import org.apache.commons.cli2.OptionException;\n+import org.apache.commons.cli2.builder.DefaultOptionBuilder;\n+import org.apache.commons.cli2.builder.GroupBuilder;\n+import org.apache.commons.cli2.option.ArgumentTest;\n+import org.apache.commons.cli2.option.DefaultOptionTest;\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class HelpFormatterTest\n+    extends TestCase {\n+    private ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    private HelpFormatter helpFormatter;\n+    private Option verbose;\n+    private Group options;\n+\n+    public void setUp() {\n+        helpFormatter = new HelpFormatter(\"|*\", \"*-*\", \"*|\", 80);\n+        helpFormatter.setDivider(\"+------------------------------------------------------------------------------+\");\n+        helpFormatter.setHeader(\"Apache Commons CLI\");\n+        helpFormatter.setFooter(\"Copyright 2003\\nApache Software Foundation\");\n+        helpFormatter.setShellCommand(\"ant\");\n+\n+        verbose =\n+            new DefaultOptionBuilder().withLongName(\"verbose\")\n+                                      .withDescription(\"print the version information and exit\")\n+                                      .create();\n+\n+        options =\n+            new GroupBuilder().withName(\"options\").withOption(DefaultOptionTest.buildHelpOption())\n+                              .withOption(ArgumentTest.buildTargetsArgument())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"diagnostics\")\n+                                                                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                                                                    .create())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"projecthelp\")\n+                                                                    .withDescription(\"print project help information\")\n+                                                                    .create()).withOption(verbose)\n+                              .create();\n+\n+        helpFormatter.setGroup(options);\n+    }\n+\n+    public void testPrint()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        final PrintWriter pw = new PrintWriter(writer);\n+        helpFormatter.setPrintWriter(pw);\n+        helpFormatter.print();\n+\n+        // test shell\n+        assertEquals(\"incorrect shell command\", \"ant\", helpFormatter.getShellCommand());\n+\n+        // test group\n+        assertEquals(\"incorrect group\", this.options, helpFormatter.getGroup());\n+\n+        // test pagewidth\n+        assertEquals(\"incorrect page width\", 76, helpFormatter.getPageWidth());\n+\n+        // test pw\n+        assertEquals(\"incorrect print writer\", pw, helpFormatter.getPrintWriter());\n+\n+        // test divider\n+        assertEquals(\"incorrect divider\",\n+                     \"+------------------------------------------------------------------------------+\",\n+                     helpFormatter.getDivider());\n+\n+        // test header\n+        assertEquals(\"incorrect header\", \"Apache Commons CLI\", helpFormatter.getHeader());\n+\n+        // test footer\n+        assertEquals(\"incorrect footer\", \"Copyright 2003\\nApache Software Foundation\",\n+                     helpFormatter.getFooter());\n+\n+        // test gutters\n+        assertEquals(\"incorrect left gutter\", \"|*\", helpFormatter.getGutterLeft());\n+        assertEquals(\"incorrect right gutter\", \"*|\", helpFormatter.getGutterRight());\n+        assertEquals(\"incorrect center gutter\", \"*-*\", helpFormatter.getGutterCenter());\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Commons CLI                                                          *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Usage:                                                                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*...]]                                                                       *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*options              *-*                                                    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*                     *-*or report problems.                                 *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Copyright 2003                                                              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Software Foundation                                                  *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testComparator()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        final PrintWriter pw = new PrintWriter(writer);\n+        helpFormatter.setPrintWriter(pw);\n+\n+        final Comparator comparator = new OptionComparator();\n+        helpFormatter.setComparator(comparator);\n+        helpFormatter.print();\n+\n+        // test comparator\n+        assertEquals(\"invalid comparator\", comparator, helpFormatter.getComparator());\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Commons CLI                                                          *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Usage:                                                                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*ant [--verbose --projecthelp --help --diagnostics] [<target1> [<target2>    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*...]]                                                                       *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*options              *-*                                                    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*                     *-*or report problems.                                 *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Copyright 2003                                                              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Software Foundation                                                  *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printHelp();\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*options              *-*                                                    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --help (-?,-h)     *-*Displays the help                                   *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --diagnostics      *-*print information that might be helpful to diagnose *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*                     *-*or report problems.                                 *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --projecthelp      *-*print project help information                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  --verbose          *-*print the version information and exit              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*  target [target ...]*-*The targets ant should build                        *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp_WithException()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.setException(new OptionException(verbose));\n+        helpFormatter.printHelp();\n+\n+        //System.out.println(writer);\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*--verbose*-*print the version information and exit                          *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHelp_TooNarrow()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter = new HelpFormatter(\"<\", \"=\", \">\", 4);\n+        helpFormatter.setGroup(options);\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printHelp();\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"<options              = >\", reader.readLine());\n+        assertEquals(\"<  --help (-?,-h)     =D>\", reader.readLine());\n+        assertEquals(\"<                     =i>\", reader.readLine());\n+\n+        // lots more lines unchecked\n+    }\n+\n+    public void testPrintException()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.setException(new OptionException(verbose, ResourceConstants.MISSING_OPTION));\n+        helpFormatter.printException();\n+\n+        //System.out.println(writer);\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Missing option --verbose                                                    *|\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintUsage()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printUsage();\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Usage:                                                                      *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2>    *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*...]]                                                                       *|\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintHeader()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printHeader();\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Commons CLI                                                          *|\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintFooter()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printFooter();\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"|*Copyright 2003                                                              *|\",\n+                     reader.readLine());\n+        assertEquals(\"|*Apache Software Foundation                                                  *|\",\n+                     reader.readLine());\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testPrintDivider()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.printDivider();\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"+------------------------------------------------------------------------------+\",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+\n+    public void testWrap() {\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 30).iterator();\n+        assertEquals(\"Apache Software Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_WrapNeeded() {\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 20).iterator();\n+        assertEquals(\"Apache Software\", i.next());\n+        assertEquals(\"Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_BeforeSpace() {\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 16).iterator();\n+        assertEquals(\"Apache Software\", i.next());\n+        assertEquals(\"Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_AfterSpace() {\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 17).iterator();\n+        assertEquals(\"Apache Software\", i.next());\n+        assertEquals(\"Foundation\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_InWord() {\n+        final Iterator i = HelpFormatter.wrap(\"Apache Software Foundation\", 8).iterator();\n+        assertEquals(\"Apache\", i.next());\n+        assertEquals(\"Software\", i.next());\n+        assertEquals(\"Foundati\", i.next());\n+        assertEquals(\"on\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_NewLine() {\n+        final Iterator i = HelpFormatter.wrap(\"\\nApache Software Foundation\\n\", 30).iterator();\n+        assertEquals(\"\", i.next());\n+        assertEquals(\"Apache Software Foundation\", i.next());\n+        assertEquals(\"\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_NewLine2() {\n+        List wrapped =\n+            HelpFormatter.wrap(\"A really quite long general description of the option with specific alternatives documented:\\n\" +\n+                               \"  Indented special case\\n\" + \"  Alternative scenario\", 30);\n+\n+        final Iterator i = wrapped.iterator();\n+\n+        assertEquals(\"A really quite long general\", i.next());\n+        assertEquals(\"description of the option\", i.next());\n+        assertEquals(\"with specific alternatives\", i.next());\n+        assertEquals(\"documented:\", i.next());\n+        assertEquals(\"  Indented special case\", i.next());\n+        assertEquals(\"  Alternative scenario\", i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testWrap_Below1Length() {\n+        try {\n+            HelpFormatter.wrap(\"Apache Software Foundation\", -1);\n+            fail(\"IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.HELPFORMATTER_WIDTH_TOO_NARROW,\n+                                              new Object[] { new Integer(-1) }), e.getMessage());\n+        }\n+    }\n+\n+    public void testPad()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        HelpFormatter.pad(\"hello\", 10, new PrintWriter(writer));\n+        assertEquals(\"hello     \", writer.toString());\n+    }\n+\n+    public void testPad_Null()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        HelpFormatter.pad(null, 10, new PrintWriter(writer));\n+        assertEquals(\"          \", writer.toString());\n+    }\n+\n+    public void testPad_TooLong()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        HelpFormatter.pad(\"hello world\", 10, new PrintWriter(writer));\n+        assertEquals(\"hello world\", writer.toString());\n+    }\n+\n+    public void testPad_TooShort()\n+        throws IOException {\n+        final StringWriter writer = new StringWriter();\n+        HelpFormatter.pad(\"hello world\", -5, new PrintWriter(writer));\n+        assertEquals(\"hello world\", writer.toString());\n+    }\n+\n+    public void testGutters()\n+        throws IOException {\n+        helpFormatter = new HelpFormatter(null, null, null, 80);\n+        helpFormatter.setShellCommand(\"ant\");\n+\n+        final Set lusage = new HashSet();\n+        lusage.add(DisplaySetting.DISPLAY_ALIASES);\n+        lusage.add(DisplaySetting.DISPLAY_GROUP_NAME);\n+        helpFormatter.setLineUsageSettings(lusage);\n+\n+        // test line usage\n+        assertEquals(\"incorrect line usage\", lusage, helpFormatter.getLineUsageSettings());\n+\n+        final Set fusage = new HashSet();\n+        fusage.add(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+        fusage.add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+        fusage.add(DisplaySetting.DISPLAY_GROUP_OUTER);\n+        fusage.add(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+        fusage.add(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n+        fusage.add(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n+        fusage.add(DisplaySetting.DISPLAY_SWITCH_ENABLED);\n+        fusage.add(DisplaySetting.DISPLAY_SWITCH_DISABLED);\n+        fusage.add(DisplaySetting.DISPLAY_PROPERTY_OPTION);\n+        fusage.add(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n+        fusage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\n+        fusage.add(DisplaySetting.DISPLAY_OPTIONAL);\n+        helpFormatter.setFullUsageSettings(fusage);\n+\n+        // test line usage\n+        assertEquals(\"incorrect full usage\", fusage, helpFormatter.getFullUsageSettings());\n+\n+        final Set dsettings = new HashSet();\n+        dsettings.add(DisplaySetting.DISPLAY_GROUP_NAME);\n+        dsettings.add(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n+        dsettings.add(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n+\n+        helpFormatter.setDisplaySettings(dsettings);\n+\n+        verbose =\n+            new DefaultOptionBuilder().withLongName(\"verbose\")\n+                                      .withDescription(\"print the version information and exit\")\n+                                      .create();\n+\n+        options =\n+            new GroupBuilder().withName(\"options\").withOption(DefaultOptionTest.buildHelpOption())\n+                              .withOption(ArgumentTest.buildTargetsArgument())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"diagnostics\")\n+                                                                    .withDescription(\"print information that might be helpful to diagnose or report problems.\")\n+                                                                    .create())\n+                              .withOption(new DefaultOptionBuilder().withLongName(\"projecthelp\")\n+                                                                    .withDescription(\"print project help information\")\n+                                                                    .create()).withOption(verbose)\n+                              .create();\n+\n+        helpFormatter.setGroup(options);\n+\n+        // test default gutters\n+        assertEquals(\"incorrect left gutter\", HelpFormatter.DEFAULT_GUTTER_LEFT,\n+                     helpFormatter.getGutterLeft());\n+        assertEquals(\"incorrect right gutter\", HelpFormatter.DEFAULT_GUTTER_RIGHT,\n+                     helpFormatter.getGutterRight());\n+        assertEquals(\"incorrect center gutter\", HelpFormatter.DEFAULT_GUTTER_CENTER,\n+                     helpFormatter.getGutterCenter());\n+\n+        final StringWriter writer = new StringWriter();\n+        helpFormatter.setPrintWriter(new PrintWriter(writer));\n+        helpFormatter.print();\n+\n+        final BufferedReader reader = new BufferedReader(new StringReader(writer.toString()));\n+        assertEquals(\"Usage:                                                                          \",\n+                     reader.readLine());\n+        assertEquals(\"ant [--help --diagnostics --projecthelp --verbose] [<target1> [<target2> ...]]  \",\n+                     reader.readLine());\n+        assertEquals(\"options                                                                         \",\n+                     reader.readLine());\n+        assertEquals(\"  --help (-?,-h)         Displays the help                                      \",\n+                     reader.readLine());\n+        assertEquals(\"  --diagnostics          print information that might be helpful to diagnose or \",\n+                     reader.readLine());\n+        assertEquals(\"                         report problems.                                       \",\n+                     reader.readLine());\n+        assertEquals(\"  --projecthelp          print project help information                         \",\n+                     reader.readLine());\n+        assertEquals(\"  --verbose              print the version information and exit                 \",\n+                     reader.readLine());\n+        assertEquals(\"  target [target ...]    The targets ant should build                           \",\n+                     reader.readLine());\n+        assertNull(reader.readLine());\n+    }\n+}\n+\n+\n+class OptionComparator implements Comparator {\n+    public int compare(Object o1,\n+                       Object o2) {\n+        Option opt1 = (Option) o1;\n+        Option opt2 = (Option) o2;\n+\n+        return -opt1.getPreferredName().compareTo(opt2.getPreferredName());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/ClassValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/ClassValidatorTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.net.URL;import java.net.URLClassLoader;import java.util.Arrays;import java.util.Iterator;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.resource.ResourceHelper;public class ClassValidatorTest extends TestCase {    private final static ResourceHelper resources =        ResourceHelper.getResourceHelper();    private ClassValidator validator;    protected void setUp() {        validator = new ClassValidator();    }    public void testValidName() throws InvalidArgumentException {        final Object[] array = new Object[] { \"MyApp\", \"org.apache.ant.Main\" };        final List list = Arrays.asList(array);        validator.validate(list);        assertEquals(\"Name is incorrect\", \"MyApp\", list.get(0));        assertEquals(\"Name is incorrect\", \"org.apache.ant.Main\", list.get(1));    }    public void testNameBadStart() {        final String className = \"1stClass\";        final Object[] array = new Object[] { className };        final List list = Arrays.asList(array);        try {            validator.validate(list);            fail(\"Class name cannot start with a number.\");        } catch (InvalidArgumentException ive) {            assertEquals(                resources.getMessage(                    \"ClassValidator.bad.classname\",                    className),                ive.getMessage());        }    }    public void testNameBadEnd() {        final String className = \"My.Class.\";        final Object[] array = new Object[] { className };        final List list = Arrays.asList(array);        try {            validator.validate(list);            fail(\"Trailing period not permitted.\");        } catch (InvalidArgumentException ive) {            assertEquals(                resources.getMessage(                    \"ClassValidator.bad.classname\",                    className),                ive.getMessage());        }    }    public void testNameBadMiddle() {        final String className = \"My..Class\";        final Object[] array = new Object[] { className };        final List list = Arrays.asList(array);        try {            validator.validate(list);            fail(\"Two consecutive periods is not permitted.\");        } catch (InvalidArgumentException ive) {            assertEquals(                resources.getMessage(                    \"ClassValidator.bad.classname\",                    className),                ive.getMessage());        }    }    public void testIllegalNameChar() {        final String className = \"My?Class\";        final Object[] array = new Object[] { className };        final List list = Arrays.asList(array);        try {            validator.validate(list);            fail(\"Illegal character not allowed in Class name.\");        } catch (InvalidArgumentException ive) {            assertEquals(                resources.getMessage(                    \"ClassValidator.bad.classname\",                    className),                ive.getMessage());        }    }    public void testLoadable() {        assertFalse(\"Validator is loadable\", validator.isLoadable());        validator.setLoadable(true);        assertTrue(\"Validator is NOT loadable\", validator.isLoadable());        validator.setLoadable(false);        assertFalse(\"Validator is loadable\", validator.isLoadable());    }    public void testLoadValid() throws InvalidArgumentException {        final Object[] array =            new Object[] {                \"org.apache.commons.cli2.Option\",                \"java.util.Vector\" };        final List list = Arrays.asList(array);        validator.setLoadable(true);        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(            \"org.apache.commons.cli2.Option\",            ((Class) i.next()).getName());        assertEquals(\"java.util.Vector\", ((Class) i.next()).getName());        assertFalse(i.hasNext());    }    public void testLoadInvalid() {        final String className = \"org.apache.commons.cli2.NonOption\";        final Object[] array = new Object[] { className, \"java.util.Vectors\" };        final List list = Arrays.asList(array);        validator.setLoadable(true);        try {            validator.validate(list);            fail(\"Class Not Found\");        } catch (InvalidArgumentException ive) {            assertEquals(                resources.getMessage(                    \"ClassValidator.class.notfound\",                    className),                ive.getMessage());        }    }    public void testInstantiate() {        assertFalse(\"Validator creates instances\", validator.isInstance());        validator.setInstance(true);        assertTrue(            \"Validator does NOT create instances\",            validator.isInstance());        validator.setInstance(false);        assertFalse(\"Validator creates instances\", validator.isInstance());    }    public void testCreateClassInstance() throws InvalidArgumentException {        final Object[] array = new Object[] { \"java.util.Vector\" };        final List list = Arrays.asList(array);        validator.setInstance(true);        validator.validate(list);        assertTrue(            \"Vector instance NOT found\",            list.get(0) instanceof java.util.Vector);    }    public void testCreateInterfaceInstance() {        final String className = \"java.util.Map\";        final Object[] array = new Object[] { className };        final List list = Arrays.asList(array);        validator.setInstance(true);        try {            validator.validate(list);            fail(\"It's not possible to create a '\" + className + \"'\");        }        catch (final InvalidArgumentException ive) {            assertEquals(                    resources.getMessage(                            \"ClassValidator.class.create\",                            className),                            ive.getMessage());        }    }    public void testCreateProtectedInstance() {        final String className = \"org.apache.commons.cli2.validation.protect.ProtectedClass\";        final Object[] array = new Object[] { className };        final List list = Arrays.asList(array);        validator.setInstance(true);        try {            validator.validate(list);            fail(\"It's not possible to create a '\" + className + \"'\");        }        catch (final InvalidArgumentException ive) {            assertEquals(                    resources.getMessage(                            \"ClassValidator.class.access\",                            className,                            \"Class org.apache.commons.cli2.validation.ClassValidator \" +                            \"can not access a member of class \" +                            \"org.apache.commons.cli2.validation.protect.ProtectedClass \" +                            \"with modifiers \\\"protected\\\"\"),                            ive.getMessage());        }    }    public void testClassloader() {        assertEquals(            \"Wrong classloader found\",            validator.getClass().getClassLoader(),            validator.getClassLoader());        URLClassLoader classloader = new URLClassLoader(new URL[] {        });        validator.setClassLoader(classloader);        assertEquals(            \"Wrong classloader found\",            classloader,            validator.getClassLoader());    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class ClassValidatorTest extends TestCase {\n+\n+    private final static ResourceHelper resources =\n+        ResourceHelper.getResourceHelper();\n+\n+    private ClassValidator validator;\n+\n+    protected void setUp() {\n+        validator = new ClassValidator();\n+    }\n+\n+    public void testValidName() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"MyApp\", \"org.apache.ant.Main\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.validate(list);\n+\n+        assertEquals(\"Name is incorrect\", \"MyApp\", list.get(0));\n+        assertEquals(\"Name is incorrect\", \"org.apache.ant.Main\", list.get(1));\n+    }\n+\n+    public void testNameBadStart() {\n+        final String className = \"1stClass\";\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Class name cannot start with a number.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testNameBadEnd() {\n+        final String className = \"My.Class.\";\n+\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Trailing period not permitted.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testNameBadMiddle() {\n+        final String className = \"My..Class\";\n+\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Two consecutive periods is not permitted.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testIllegalNameChar() {\n+        final String className = \"My?Class\";\n+\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Illegal character not allowed in Class name.\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.bad.classname\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testLoadable() {\n+        assertFalse(\"Validator is loadable\", validator.isLoadable());\n+        validator.setLoadable(true);\n+        assertTrue(\"Validator is NOT loadable\", validator.isLoadable());\n+        validator.setLoadable(false);\n+        assertFalse(\"Validator is loadable\", validator.isLoadable());\n+    }\n+\n+    public void testLoadValid() throws InvalidArgumentException {\n+        final Object[] array =\n+            new Object[] {\n+                \"org.apache.commons.cli2.Option\",\n+                \"java.util.Vector\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setLoadable(true);\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(\n+            \"org.apache.commons.cli2.Option\",\n+            ((Class) i.next()).getName());\n+        assertEquals(\"java.util.Vector\", ((Class) i.next()).getName());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testLoadInvalid() {\n+        final String className = \"org.apache.commons.cli2.NonOption\";\n+\n+        final Object[] array = new Object[] { className, \"java.util.Vectors\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setLoadable(true);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"Class Not Found\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(\n+                resources.getMessage(\n+                    \"ClassValidator.class.notfound\",\n+                    className),\n+                ive.getMessage());\n+        }\n+    }\n+\n+    public void testInstantiate() {\n+        assertFalse(\"Validator creates instances\", validator.isInstance());\n+        validator.setInstance(true);\n+        assertTrue(\n+            \"Validator does NOT create instances\",\n+            validator.isInstance());\n+        validator.setInstance(false);\n+        assertFalse(\"Validator creates instances\", validator.isInstance());\n+    }\n+\n+    public void testCreateClassInstance() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"java.util.Vector\" };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setInstance(true);\n+\n+        validator.validate(list);\n+        assertTrue(\n+            \"Vector instance NOT found\",\n+            list.get(0) instanceof java.util.Vector);\n+    }\n+\n+    public void testCreateInterfaceInstance() {\n+        final String className = \"java.util.Map\";\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setInstance(true);\n+        \n+        try {\n+            validator.validate(list);\n+            fail(\"It's not possible to create a '\" + className + \"'\");\n+        }\n+        catch (final InvalidArgumentException ive) {\n+            assertEquals(\n+                    resources.getMessage(\n+                            \"ClassValidator.class.create\",\n+                            className),\n+                            ive.getMessage());\n+        }\n+    }\n+\n+    public void testCreateProtectedInstance() {\n+        final String className = \"org.apache.commons.cli2.validation.protect.ProtectedClass\";\n+        final Object[] array = new Object[] { className };\n+        final List list = Arrays.asList(array);\n+\n+        validator.setInstance(true);\n+        \n+        try {\n+            validator.validate(list);\n+            fail(\"It's not possible to create a '\" + className + \"'\");\n+        }\n+        catch (final InvalidArgumentException ive) {\n+            assertEquals(\n+                    resources.getMessage(\n+                            \"ClassValidator.class.access\",\n+                            className,\n+                            \"Class org.apache.commons.cli2.validation.ClassValidator \" +\n+                            \"can not access a member of class \" +\n+                            \"org.apache.commons.cli2.validation.protect.ProtectedClass \" +\n+                            \"with modifiers \\\"protected\\\"\"),\n+                            ive.getMessage());\n+        }\n+    }\n+    \n+    public void testClassloader() {\n+        assertEquals(\n+            \"Wrong classloader found\",\n+            validator.getClass().getClassLoader(),\n+            validator.getClassLoader());\n+\n+        URLClassLoader classloader = new URLClassLoader(new URL[] {\n+        });\n+        validator.setClassLoader(classloader);\n+\n+        assertEquals(\n+            \"Wrong classloader found\",\n+            classloader,\n+            validator.getClassLoader());\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/DateValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/DateValidatorTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.text.DateFormat;import java.text.DateFormatSymbols;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Calendar;import java.util.Date;import java.util.Iterator;import java.util.List;import junit.framework.Test;import junit.framework.TestCase;import junit.framework.TestSuite;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * JUnit test case for DateValidator. * * @author Rob Oxspring * @author John Keyes */public class DateValidatorTest    extends TestCase {    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    public static final DateFormat D_M_YY = new SimpleDateFormat(\"d/M/yy\");    public static final DateFormat YYYY_MM_DD = new SimpleDateFormat(\"yyyy-MM-dd\");    private List formats = Arrays.asList(new Object[] { D_M_YY, YYYY_MM_DD });    public void testSingleFormatValidate()        throws InvalidArgumentException {        final Object[] array = new Object[] { \"23/12/03\" };        final List list = Arrays.asList(array);        final Validator validator = new DateValidator(D_M_YY);        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(\"2003-12-23\", YYYY_MM_DD.format((Date) i.next()));        assertFalse(i.hasNext());    }    public void testDefaultDateFormatValidate()        throws InvalidArgumentException {        DateFormatSymbols symbols =  new DateFormatSymbols();        final Object[] array = new Object[] { \"23-\" + symbols.getShortMonths()[11] + \"-2003\" };        final List list = Arrays.asList(array);        final Validator validator = new DateValidator( new SimpleDateFormat(\"dd-MMM-yyyy\") );        validator.validate(list);        final Iterator i = list.iterator();        // CLI-40: For some reason, the YYYY_MM_DD object gets quite        // confused here and returns 2003-12-22. If we make a new one        // there is no problem.        assertEquals(\"2003-12-23\", new SimpleDateFormat(\"yyyy-MM-dd\").format((Date) i.next()));        assertFalse(i.hasNext());    }    public void testDefaultTimeFormatValidate()        throws InvalidArgumentException {        final Object[] array = new Object[] { \"18:00:00\" };        final List list = Arrays.asList(array);        final Validator validator = new DateValidator( new SimpleDateFormat(\"HH:mm:ss\") );        validator.validate(list);        final Iterator i = list.iterator();        final DateFormat df = new SimpleDateFormat(\"HH:mm:ss\");        assertEquals(\"18:00:00\", df.format((Date) i.next()));        assertFalse(i.hasNext());    }    public void testDefaultDateTimeFormatValidate()        throws InvalidArgumentException {        DateFormatSymbols symbols =  new DateFormatSymbols();        final Object[] array = new Object[] { \"23-\" + symbols.getShortMonths()[0] + \"-2003 18:00:00\" };        final List list = Arrays.asList(array);        final Validator validator = new DateValidator( new SimpleDateFormat(\"dd-MMM-yyyy HH:mm:ss\") );        validator.validate(list);        final Iterator i = list.iterator();        final DateFormat df = new SimpleDateFormat(\"yyyy/M/dd HH:mm:ss\");        assertEquals(\"2003/1/23 18:00:00\", df.format((Date) i.next()));        assertFalse(i.hasNext());    }    public void testDefaultValidator()        throws InvalidArgumentException {        final Object[] array = new Object[] { \"23/01/03 18:00\" };        final List list = Arrays.asList(array);        final Validator validator = new DateValidator(new SimpleDateFormat(\"dd/MM/yy HH:mm\"));        validator.validate(list);        final Iterator i = list.iterator();        final DateFormat df = new SimpleDateFormat(\"yyyy/M/dd HH:mm:ss\");        assertEquals(\"2003/1/23 18:00:00\", df.format((Date) i.next()));        assertFalse(i.hasNext());    }    public void testValidate()        throws InvalidArgumentException {        final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };        final List list = Arrays.asList(array);        final Validator validator = new DateValidator(formats);        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(\"2003-12-23\", YYYY_MM_DD.format((Date) i.next()));        assertEquals(\"2002-10-12\", YYYY_MM_DD.format((Date) i.next()));        assertFalse(i.hasNext());    }    public void testMinimumBounds()        throws InvalidArgumentException {        final DateValidator validator = new DateValidator(formats);        final Calendar cal = Calendar.getInstance();        {            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };            final List list = Arrays.asList(array);            cal.set(2002, 1, 12);            final Date min = cal.getTime();            validator.setMinimum(min);            assertTrue(\"maximum bound is set\", validator.getMaximum() == null);            assertEquals(\"minimum bound is incorrect\", min, validator.getMinimum());            validator.validate(list);        }        {            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };            final List list = Arrays.asList(array);            cal.set(2003, 1, 12);            final Date min = cal.getTime();            validator.setMinimum(min);            try {                validator.validate(list);                fail(\"minimum out of bounds exception not caught\");            } catch (final InvalidArgumentException exp) {                assertEquals(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,                                                  new Object[] { \"2002-10-12\" }), exp.getMessage());            }        }    }    public void testFormats()        throws InvalidArgumentException {        final DateValidator validator = new DateValidator(formats);        assertEquals(\"date format is incorrect\", ((SimpleDateFormat) formats.get(0)).toPattern(),                     ((SimpleDateFormat) validator.getFormats()[0]).toPattern());        assertEquals(\"date format is incorrect\", ((SimpleDateFormat) formats.get(1)).toPattern(),                     ((SimpleDateFormat) validator.getFormats()[1]).toPattern());    }    public void testMaximumBounds()        throws InvalidArgumentException {        final DateValidator validator = new DateValidator(formats);        final Calendar cal = Calendar.getInstance();        {            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };            final List list = Arrays.asList(array);            cal.set(2004, 1, 12);            final Date max = cal.getTime();            validator.setMaximum(max);            assertTrue(\"minimum bound is set\", validator.getMinimum() == null);            assertEquals(\"maximum bound is incorrect\", max, validator.getMaximum());            validator.validate(list);        }        {            final Object[] array = new Object[] { \"23/12/03\", \"2004-10-12\" };            final List list = Arrays.asList(array);            cal.set(2004, 1, 12);            final Date max = cal.getTime();            validator.setMaximum(max);            try {                validator.validate(list);                fail(\"maximum out of bounds exception not caught\");            } catch (final InvalidArgumentException exp) {                assertEquals(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,                                                  new Object[] { \"2004-10-12\" }), exp.getMessage());            }        }    }    public static Test suite() {        Test result = new TestSuite(DateValidatorTest.class); // default behavior        result = new TimeZoneTestSuite(\"EST\", result); // ensure it runs in EST timezone        return result;    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.DateFormat;\n+import java.text.DateFormatSymbols;\n+import java.text.SimpleDateFormat;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * JUnit test case for DateValidator.\n+ *\n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class DateValidatorTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    public static final DateFormat D_M_YY = new SimpleDateFormat(\"d/M/yy\");\n+    public static final DateFormat YYYY_MM_DD = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    private List formats = Arrays.asList(new Object[] { D_M_YY, YYYY_MM_DD });\n+\n+    public void testSingleFormatValidate()\n+        throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"23/12/03\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new DateValidator(D_M_YY);\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(\"2003-12-23\", YYYY_MM_DD.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testDefaultDateFormatValidate()\n+        throws InvalidArgumentException {\n+        DateFormatSymbols symbols =  new DateFormatSymbols();\n+        final Object[] array = new Object[] { \"23-\" + symbols.getShortMonths()[11] + \"-2003\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new DateValidator( new SimpleDateFormat(\"dd-MMM-yyyy\") );\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        // CLI-40: For some reason, the YYYY_MM_DD object gets quite \n+        // confused here and returns 2003-12-22. If we make a new one \n+        // there is no problem.\n+        assertEquals(\"2003-12-23\", new SimpleDateFormat(\"yyyy-MM-dd\").format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testDefaultTimeFormatValidate()\n+        throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"18:00:00\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new DateValidator( new SimpleDateFormat(\"HH:mm:ss\") );\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        final DateFormat df = new SimpleDateFormat(\"HH:mm:ss\");\n+        assertEquals(\"18:00:00\", df.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testDefaultDateTimeFormatValidate()\n+        throws InvalidArgumentException {\n+        DateFormatSymbols symbols =  new DateFormatSymbols();\n+        final Object[] array = new Object[] { \"23-\" + symbols.getShortMonths()[0] + \"-2003 18:00:00\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new DateValidator( new SimpleDateFormat(\"dd-MMM-yyyy HH:mm:ss\") );\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        final DateFormat df = new SimpleDateFormat(\"yyyy/M/dd HH:mm:ss\");\n+        assertEquals(\"2003/1/23 18:00:00\", df.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testDefaultValidator()\n+        throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"23/01/03 18:00\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new DateValidator(new SimpleDateFormat(\"dd/MM/yy HH:mm\"));\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        final DateFormat df = new SimpleDateFormat(\"yyyy/M/dd HH:mm:ss\");\n+        assertEquals(\"2003/1/23 18:00:00\", df.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate()\n+        throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new DateValidator(formats);\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(\"2003-12-23\", YYYY_MM_DD.format((Date) i.next()));\n+        assertEquals(\"2002-10-12\", YYYY_MM_DD.format((Date) i.next()));\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testMinimumBounds()\n+        throws InvalidArgumentException {\n+        final DateValidator validator = new DateValidator(formats);\n+        final Calendar cal = Calendar.getInstance();\n+\n+        {\n+            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n+            final List list = Arrays.asList(array);\n+            cal.set(2002, 1, 12);\n+\n+            final Date min = cal.getTime();\n+            validator.setMinimum(min);\n+            assertTrue(\"maximum bound is set\", validator.getMaximum() == null);\n+            assertEquals(\"minimum bound is incorrect\", min, validator.getMinimum());\n+            validator.validate(list);\n+        }\n+\n+        {\n+            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n+            final List list = Arrays.asList(array);\n+            cal.set(2003, 1, 12);\n+\n+            final Date min = cal.getTime();\n+            validator.setMinimum(min);\n+\n+            try {\n+                validator.validate(list);\n+                fail(\"minimum out of bounds exception not caught\");\n+            } catch (final InvalidArgumentException exp) {\n+                assertEquals(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,\n+                                                  new Object[] { \"2002-10-12\" }), exp.getMessage());\n+            }\n+        }\n+    }\n+\n+    public void testFormats()\n+        throws InvalidArgumentException {\n+        final DateValidator validator = new DateValidator(formats);\n+        assertEquals(\"date format is incorrect\", ((SimpleDateFormat) formats.get(0)).toPattern(),\n+                     ((SimpleDateFormat) validator.getFormats()[0]).toPattern());\n+        assertEquals(\"date format is incorrect\", ((SimpleDateFormat) formats.get(1)).toPattern(),\n+                     ((SimpleDateFormat) validator.getFormats()[1]).toPattern());\n+    }\n+\n+    public void testMaximumBounds()\n+        throws InvalidArgumentException {\n+        final DateValidator validator = new DateValidator(formats);\n+        final Calendar cal = Calendar.getInstance();\n+\n+        {\n+            final Object[] array = new Object[] { \"23/12/03\", \"2002-10-12\" };\n+            final List list = Arrays.asList(array);\n+            cal.set(2004, 1, 12);\n+\n+            final Date max = cal.getTime();\n+            validator.setMaximum(max);\n+            assertTrue(\"minimum bound is set\", validator.getMinimum() == null);\n+            assertEquals(\"maximum bound is incorrect\", max, validator.getMaximum());\n+            validator.validate(list);\n+        }\n+\n+        {\n+            final Object[] array = new Object[] { \"23/12/03\", \"2004-10-12\" };\n+            final List list = Arrays.asList(array);\n+            cal.set(2004, 1, 12);\n+\n+            final Date max = cal.getTime();\n+            validator.setMaximum(max);\n+\n+            try {\n+                validator.validate(list);\n+                fail(\"maximum out of bounds exception not caught\");\n+            } catch (final InvalidArgumentException exp) {\n+                assertEquals(resources.getMessage(ResourceConstants.DATEVALIDATOR_DATE_OUTOFRANGE,\n+                                                  new Object[] { \"2004-10-12\" }), exp.getMessage());\n+            }\n+        }\n+    }\n+\n+    public static Test suite() {\n+        Test result = new TestSuite(DateValidatorTest.class); // default behavior\n+        result = new TimeZoneTestSuite(\"EST\", result); // ensure it runs in EST timezone\n+\n+        return result;\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/EnumValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/EnumValidatorTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.util.Arrays;import java.util.Iterator;import java.util.List;import java.util.Set;import java.util.TreeSet;import junit.framework.TestCase;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;public class EnumValidatorTest    extends TestCase {    private final static ResourceHelper resources = ResourceHelper.getResourceHelper();    private final Set enumSet = new TreeSet(Arrays.asList(new Object[] { \"red\", \"green\", \"blue\" }));    public void testValidate()        throws InvalidArgumentException {        final Object[] array = new Object[] { \"red\", \"green\" };        {            final List list = Arrays.asList(array);            final EnumValidator validator = new EnumValidator(enumSet);            assertEquals(\"valid values are incorrect\", enumSet, validator.getValidValues());            validator.validate(list);            final Iterator i = list.iterator();            assertEquals(\"red\", i.next());            assertEquals(\"green\", i.next());            assertFalse(i.hasNext());        }    }    public void testNonMember() {        final Object[] array = new Object[] { \"red\", \"pink\" };        final List list = Arrays.asList(array);        final EnumValidator validator = new EnumValidator(enumSet);        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(resources.getMessage(ResourceConstants.ENUM_ILLEGAL_VALUE,                                              new Object[] { \"pink\", validator.getValuesAsString() }),                         e.getMessage());        }    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class EnumValidatorTest\n+    extends TestCase {\n+    private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n+    private final Set enumSet = new TreeSet(Arrays.asList(new Object[] { \"red\", \"green\", \"blue\" }));\n+\n+    public void testValidate()\n+        throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"red\", \"green\" };\n+\n+        {\n+            final List list = Arrays.asList(array);\n+            final EnumValidator validator = new EnumValidator(enumSet);\n+            assertEquals(\"valid values are incorrect\", enumSet, validator.getValidValues());\n+            validator.validate(list);\n+\n+            final Iterator i = list.iterator();\n+            assertEquals(\"red\", i.next());\n+            assertEquals(\"green\", i.next());\n+            assertFalse(i.hasNext());\n+        }\n+    }\n+\n+    public void testNonMember() {\n+        final Object[] array = new Object[] { \"red\", \"pink\" };\n+        final List list = Arrays.asList(array);\n+        final EnumValidator validator = new EnumValidator(enumSet);\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.ENUM_ILLEGAL_VALUE,\n+                                              new Object[] { \"pink\", validator.getValuesAsString() }),\n+                         e.getMessage());\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/FileValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/FileValidatorTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.io.File;import java.io.IOException;import java.util.Arrays;import java.util.Iterator;import java.util.List;import junit.framework.TestCase;/** * JUnit test case for the FileValidator. * * @author Rob Oxspring * @author John Keyes */public class FileValidatorTest extends TestCase {    public void testValidate() throws InvalidArgumentException {        final Object[] array = new Object[] { \"src\", \"project.xml\",                \"veryunlikelyfilename\" };        final List list = Arrays.asList(array);        final FileValidator validator = new FileValidator();        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(new File(\"src\"), i.next());        assertEquals(new File(\"project.xml\"), i.next());        assertEquals(new File(\"veryunlikelyfilename\"), i.next());        assertFalse(i.hasNext());    }    public void testValidate_Directory() {        final Object[] array = new Object[] { \"src\", \"project.xml\" };        final List list = Arrays.asList(array);        final FileValidator validator = FileValidator                .getExistingDirectoryInstance();        assertTrue(\"is a directory validator\", validator.isDirectory());        assertFalse(\"is not a file validator\", validator.isFile());        assertTrue(\"is an existing file validator\", validator.isExisting());        assertFalse(\"is not a hidden file validator\", validator.isHidden());        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(\"project.xml\", e.getMessage());        }    }    public void testValidate_ReadableFile() {        // make file readonly        File file = new File(\"src/test/data/readable.txt\");        file.setReadOnly();        final Object[] array = new Object[] { \"src/test/data/readable.txt\",                \"src/test/data/notreadable.txt\" };        final List list = Arrays.asList(array);        final FileValidator validator = FileValidator.getExistingFileInstance();        validator.setReadable(true);        assertFalse(\"is not a directory validator\", validator.isDirectory());        assertTrue(\"is a file validator\", validator.isFile());        assertTrue(\"is an existing file validator\", validator.isExisting());        assertFalse(\"is not a hidden file validator\", validator.isHidden());        assertTrue(\"is a readable file validator\", validator.isReadable());        assertFalse(\"is not a writable file validator\", validator.isWritable());        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(\"src/test/data/notreadable.txt\", e.getMessage());        }    }    public void testValidate_WritableFile() {        // make file readonly        File file = new File(\"src/test/data/readable.txt\");        file.setReadOnly();        final Object[] array = new Object[] { \"src/test/data/writable.txt\",                \"src/test/data/readable.txt\" };        final List list = Arrays.asList(array);        final FileValidator validator = FileValidator.getExistingFileInstance();        validator.setWritable(true);        assertFalse(\"is not a directory validator\", validator.isDirectory());        assertTrue(\"is a file validator\", validator.isFile());        assertTrue(\"is an existing file validator\", validator.isExisting());        assertFalse(\"is not a hidden file validator\", validator.isHidden());        assertFalse(\"is not a readable file validator\", validator.isReadable());        assertTrue(\"is a writable file validator\", validator.isWritable());        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(\"src/test/data/readable.txt\", e.getMessage());        }    }    public void testValidate_HiddenFile() throws InvalidArgumentException {        // make file hidden on Windows        attribute(\"H\");        final Object[] array = new Object[] { \"src/test/data/.hidden.txt\", \"src\" };        final List list = Arrays.asList(array);        final FileValidator validator = FileValidator.getExistingFileInstance();        validator.setHidden(true);        assertFalse(\"is not a directory validator\", validator.isDirectory());        assertTrue(\"is a file validator\", validator.isFile());        assertTrue(\"is an existing file validator\", validator.isExisting());        assertTrue(\"is a hidden file validator\", validator.isHidden());        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(\"src\", e.getMessage());        }    }    private void attribute(String attr) {        final String os = System.getProperty(\"os.name\").toLowerCase();        // if the test is run on windows, run the attrib program        // to set the hidden attribute        if (os.indexOf(\"windows\") != -1) {            // windows            try {                Process proc = Runtime.getRuntime().exec(                        \"attrib.exe +\" + attr + \" src/test/data/.hidden.txt\",                        null, new File(\".\"));                proc.waitFor();            } catch (InterruptedException e) {                System.out.println(e.getMessage());                e.printStackTrace();            } catch (IOException e) {                System.out.println(e.getMessage());                e.printStackTrace();            }        }    }    public void testValidate_Existing() {        final Object[] array = new Object[] { \"project.xml\",                \"veryunlikelyfilename\" };        final List list = Arrays.asList(array);        final FileValidator validator = FileValidator.getExistingInstance();        assertFalse(\"is not a directory validator\", validator.isDirectory());        assertFalse(\"is not a file validator\", validator.isFile());        assertTrue(\"is an existing file validator\", validator.isExisting());        assertFalse(\"is not a hidden file validator\", validator.isHidden());        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(\"veryunlikelyfilename\", e.getMessage());        }    }    public void testValidate_File() {        final Object[] array = new Object[] { \"project.xml\", \"src\" };        final List list = Arrays.asList(array);        final Validator validator = FileValidator.getExistingFileInstance();        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(\"src\", e.getMessage());        }    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * JUnit test case for the FileValidator.\n+ * \n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class FileValidatorTest extends TestCase {\n+\n+    public void testValidate() throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"src\", \"project.xml\",\n+                \"veryunlikelyfilename\" };\n+        final List list = Arrays.asList(array);\n+        final FileValidator validator = new FileValidator();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(new File(\"src\"), i.next());\n+        assertEquals(new File(\"project.xml\"), i.next());\n+        assertEquals(new File(\"veryunlikelyfilename\"), i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_Directory() {\n+        final Object[] array = new Object[] { \"src\", \"project.xml\" };\n+        final List list = Arrays.asList(array);\n+        final FileValidator validator = FileValidator\n+                .getExistingDirectoryInstance();\n+\n+        assertTrue(\"is a directory validator\", validator.isDirectory());\n+        assertFalse(\"is not a file validator\", validator.isFile());\n+        assertTrue(\"is an existing file validator\", validator.isExisting());\n+        assertFalse(\"is not a hidden file validator\", validator.isHidden());\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"project.xml\", e.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_ReadableFile() {\n+        // make file readonly\n+        File file = new File(\"src/test/data/readable.txt\");\n+        file.setReadOnly();\n+\n+        final Object[] array = new Object[] { \"src/test/data/readable.txt\",\n+                \"src/test/data/notreadable.txt\" };\n+        final List list = Arrays.asList(array);\n+        final FileValidator validator = FileValidator.getExistingFileInstance();\n+        validator.setReadable(true);\n+\n+        assertFalse(\"is not a directory validator\", validator.isDirectory());\n+        assertTrue(\"is a file validator\", validator.isFile());\n+        assertTrue(\"is an existing file validator\", validator.isExisting());\n+        assertFalse(\"is not a hidden file validator\", validator.isHidden());\n+        assertTrue(\"is a readable file validator\", validator.isReadable());\n+        assertFalse(\"is not a writable file validator\", validator.isWritable());\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"src/test/data/notreadable.txt\", e.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_WritableFile() {\n+        // make file readonly\n+        File file = new File(\"src/test/data/readable.txt\");\n+        file.setReadOnly();\n+\n+        final Object[] array = new Object[] { \"src/test/data/writable.txt\",\n+                \"src/test/data/readable.txt\" };\n+        final List list = Arrays.asList(array);\n+        final FileValidator validator = FileValidator.getExistingFileInstance();\n+        validator.setWritable(true);\n+\n+        assertFalse(\"is not a directory validator\", validator.isDirectory());\n+        assertTrue(\"is a file validator\", validator.isFile());\n+        assertTrue(\"is an existing file validator\", validator.isExisting());\n+        assertFalse(\"is not a hidden file validator\", validator.isHidden());\n+        assertFalse(\"is not a readable file validator\", validator.isReadable());\n+        assertTrue(\"is a writable file validator\", validator.isWritable());\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"src/test/data/readable.txt\", e.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_HiddenFile() throws InvalidArgumentException {\n+        // make file hidden on Windows\n+        attribute(\"H\");\n+\n+        final Object[] array = new Object[] { \"src/test/data/.hidden.txt\", \"src\" };\n+        final List list = Arrays.asList(array);\n+        final FileValidator validator = FileValidator.getExistingFileInstance();\n+        validator.setHidden(true);\n+\n+        assertFalse(\"is not a directory validator\", validator.isDirectory());\n+        assertTrue(\"is a file validator\", validator.isFile());\n+        assertTrue(\"is an existing file validator\", validator.isExisting());\n+        assertTrue(\"is a hidden file validator\", validator.isHidden());\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"src\", e.getMessage());\n+        }\n+    }\n+\n+    private void attribute(String attr) {\n+        final String os = System.getProperty(\"os.name\").toLowerCase();\n+\n+        // if the test is run on windows, run the attrib program\n+        // to set the hidden attribute\n+        if (os.indexOf(\"windows\") != -1) {\n+            // windows\n+            try {\n+                Process proc = Runtime.getRuntime().exec(\n+                        \"attrib.exe +\" + attr + \" src/test/data/.hidden.txt\",\n+                        null, new File(\".\"));\n+                proc.waitFor();\n+            } catch (InterruptedException e) {\n+                System.out.println(e.getMessage());\n+                e.printStackTrace();\n+            } catch (IOException e) {\n+                System.out.println(e.getMessage());\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public void testValidate_Existing() {\n+        final Object[] array = new Object[] { \"project.xml\",\n+                \"veryunlikelyfilename\" };\n+        final List list = Arrays.asList(array);\n+        final FileValidator validator = FileValidator.getExistingInstance();\n+\n+        assertFalse(\"is not a directory validator\", validator.isDirectory());\n+        assertFalse(\"is not a file validator\", validator.isFile());\n+        assertTrue(\"is an existing file validator\", validator.isExisting());\n+        assertFalse(\"is not a hidden file validator\", validator.isHidden());\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"veryunlikelyfilename\", e.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_File() {\n+        final Object[] array = new Object[] { \"project.xml\", \"src\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = FileValidator.getExistingFileInstance();\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"src\", e.getMessage());\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/NumberValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/NumberValidatorTest.java\n-/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.text.NumberFormat;import java.util.Arrays;import java.util.Iterator;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;/** * JUnit test case for NumberValidator. * * @author Rob Oxspring * @author John Keyes */public class NumberValidatorTest    extends TestCase {    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    public void testValidate_Number()        throws InvalidArgumentException {        final NumberFormat format = NumberFormat.getNumberInstance();        final Object[] array =            new Object[] { format.format(1d), format.format(1.07d), format.format(-.45d) };        {            final List list = Arrays.asList(array);            final Validator validator = NumberValidator.getNumberInstance();            validator.validate(list);            final Iterator i = list.iterator();            assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);            assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);            assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);            assertFalse(i.hasNext());        }    }    public void testValidate_Currency()        throws InvalidArgumentException {        NumberFormat format = NumberFormat.getCurrencyInstance();        final Object[] array =            new Object[] { format.format(1d), format.format(1.07), format.format(-0.45) };        final List list = Arrays.asList(array);        final NumberValidator validator = NumberValidator.getCurrencyInstance();        assertEquals(\"incorrect currency format\", format, validator.getFormat());        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);        assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);        assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);        assertFalse(i.hasNext());    }    public void testValidate_Percent()        throws InvalidArgumentException {        final NumberFormat format = NumberFormat.getPercentInstance();        final Object[] array =            new Object[] {                             format.format(.01), format.format(1.07), format.format(-.45),                             format.format(0.001)            };        final List list = Arrays.asList(array);        final Validator validator = NumberValidator.getPercentInstance();        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(0.01d, ((Number) i.next()).doubleValue(), 0.0001);        assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);        assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);        assertEquals(0.00001d, ((Number) i.next()).doubleValue(), 0.0001);        assertFalse(i.hasNext());    }    public void testValidate_Integer()        throws InvalidArgumentException {        final Object[] array = new Object[] { \"1\", \"107\", \"-45\" };        final List list = Arrays.asList(array);        final Validator validator = NumberValidator.getIntegerInstance();        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);        assertEquals(107d, ((Number) i.next()).doubleValue(), 0.0001);        assertEquals(-45d, ((Number) i.next()).doubleValue(), 0.0001);        assertFalse(i.hasNext());    }    public void testValidate_ExcessChars() {        final Object[] array = new Object[] { \"10DowningStreet\" };        final List list = Arrays.asList(array);        final Validator validator = NumberValidator.getIntegerInstance();        try {            validator.validate(list);            fail(\"InvalidArgumentException\");        } catch (InvalidArgumentException e) {            assertEquals(\"10DowningStreet\", e.getMessage());        }    }    public void testValidate_Maximum() {        final Object[] array = new Object[] { \"1\", \"107\" };        final List list = Arrays.asList(array);        final NumberValidator validator = NumberValidator.getIntegerInstance();        Integer max = new Integer(100);        validator.setMaximum(max);        assertTrue(\"no minimum set\", validator.getMinimum() == null);        assertEquals(\"incorrect maximum value\", max, validator.getMaximum());        try {            validator.validate(list);            fail(\"107 too big\");        } catch (InvalidArgumentException ive) {            assertEquals(resources.getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,                                              \"107\"), ive.getMessage());        }    }    public void testValidate_Minimum() {        final Object[] array = new Object[] { \"107\", \"1\" };        final List list = Arrays.asList(array);        final NumberValidator validator = NumberValidator.getIntegerInstance();        Integer min = new Integer(100);        validator.setMinimum(min);        assertTrue(\"no maximum set\", validator.getMaximum() == null);        assertEquals(\"incorrect minimum value\", min, validator.getMinimum());        try {            validator.validate(list);            fail(\"1 too small\");        } catch (InvalidArgumentException ive) {            assertEquals(resources.getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,                                              \"1\"), ive.getMessage());        }    }}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.text.NumberFormat;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+/**\n+ * JUnit test case for NumberValidator.\n+ *\n+ * @author Rob Oxspring\n+ * @author John Keyes\n+ */\n+public class NumberValidatorTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    public void testValidate_Number()\n+        throws InvalidArgumentException {\n+        final NumberFormat format = NumberFormat.getNumberInstance();\n+\n+        final Object[] array =\n+            new Object[] { format.format(1d), format.format(1.07d), format.format(-.45d) };\n+\n+        {\n+            final List list = Arrays.asList(array);\n+            final Validator validator = NumberValidator.getNumberInstance();\n+\n+            validator.validate(list);\n+\n+            final Iterator i = list.iterator();\n+            assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);\n+            assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);\n+            assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);\n+            assertFalse(i.hasNext());\n+        }\n+    }\n+\n+    public void testValidate_Currency()\n+        throws InvalidArgumentException {\n+        NumberFormat format = NumberFormat.getCurrencyInstance();\n+        final Object[] array =\n+            new Object[] { format.format(1d), format.format(1.07), format.format(-0.45) };\n+        final List list = Arrays.asList(array);\n+\n+        final NumberValidator validator = NumberValidator.getCurrencyInstance();\n+        assertEquals(\"incorrect currency format\", format, validator.getFormat());\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_Percent()\n+        throws InvalidArgumentException {\n+        final NumberFormat format = NumberFormat.getPercentInstance();\n+\n+        final Object[] array =\n+            new Object[] {\n+                             format.format(.01), format.format(1.07), format.format(-.45),\n+                             format.format(0.001)\n+            };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getPercentInstance();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(0.01d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(1.07d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(-.45d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(0.00001d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_Integer()\n+        throws InvalidArgumentException {\n+        final Object[] array = new Object[] { \"1\", \"107\", \"-45\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getIntegerInstance();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(1d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(107d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertEquals(-45d, ((Number) i.next()).doubleValue(), 0.0001);\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testValidate_ExcessChars() {\n+        final Object[] array = new Object[] { \"10DowningStreet\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = NumberValidator.getIntegerInstance();\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"InvalidArgumentException\");\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(\"10DowningStreet\", e.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_Maximum() {\n+        final Object[] array = new Object[] { \"1\", \"107\" };\n+        final List list = Arrays.asList(array);\n+        final NumberValidator validator = NumberValidator.getIntegerInstance();\n+        Integer max = new Integer(100);\n+\n+        validator.setMaximum(max);\n+\n+        assertTrue(\"no minimum set\", validator.getMinimum() == null);\n+        assertEquals(\"incorrect maximum value\", max, validator.getMaximum());\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"107 too big\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(resources.getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,\n+                                              \"107\"), ive.getMessage());\n+        }\n+    }\n+\n+    public void testValidate_Minimum() {\n+        final Object[] array = new Object[] { \"107\", \"1\" };\n+        final List list = Arrays.asList(array);\n+        final NumberValidator validator = NumberValidator.getIntegerInstance();\n+        Integer min = new Integer(100);\n+        validator.setMinimum(min);\n+\n+        assertTrue(\"no maximum set\", validator.getMaximum() == null);\n+        assertEquals(\"incorrect minimum value\", min, validator.getMinimum());\n+\n+        try {\n+            validator.validate(list);\n+            fail(\"1 too small\");\n+        } catch (InvalidArgumentException ive) {\n+            assertEquals(resources.getMessage(ResourceConstants.NUMBERVALIDATOR_NUMBER_OUTOFRANGE,\n+                                              \"1\"), ive.getMessage());\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/TimeZoneTestSuite.java\n+++ b/src/test/org/apache/commons/cli2/validation/TimeZoneTestSuite.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.util.TimeZone;import junit.extensions.TestDecorator;import junit.framework.Test;import junit.framework.TestResult;public class TimeZoneTestSuite    extends TestDecorator {    private final TimeZone timeZone;    private final TimeZone originalTimeZone;    public TimeZoneTestSuite(String timeZone,                             Test test) {        super(test);        this.timeZone = TimeZone.getTimeZone(timeZone);        this.originalTimeZone = TimeZone.getDefault();    }    public void run(TestResult testResult) {        try {            TimeZone.setDefault(timeZone);            super.run(testResult);        } finally {            TimeZone.setDefault(originalTimeZone); // cleanup        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.util.TimeZone;\n+\n+import junit.extensions.TestDecorator;\n+\n+import junit.framework.Test;\n+import junit.framework.TestResult;\n+\n+public class TimeZoneTestSuite\n+    extends TestDecorator {\n+    private final TimeZone timeZone;\n+    private final TimeZone originalTimeZone;\n+\n+    public TimeZoneTestSuite(String timeZone,\n+                             Test test) {\n+        super(test);\n+        this.timeZone = TimeZone.getTimeZone(timeZone);\n+        this.originalTimeZone = TimeZone.getDefault();\n+    }\n+\n+    public void run(TestResult testResult) {\n+        try {\n+            TimeZone.setDefault(timeZone);\n+            super.run(testResult);\n+        } finally {\n+            TimeZone.setDefault(originalTimeZone); // cleanup\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/UrlValidatorTest.java\n+++ b/src/test/org/apache/commons/cli2/validation/UrlValidatorTest.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation;import java.net.MalformedURLException;import java.net.URL;import java.util.Arrays;import java.util.Iterator;import java.util.List;import junit.framework.TestCase;import org.apache.commons.cli2.resource.ResourceConstants;import org.apache.commons.cli2.resource.ResourceHelper;public class UrlValidatorTest    extends TestCase {    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();    public void testValidate()        throws InvalidArgumentException, MalformedURLException {        final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };        final List list = Arrays.asList(array);        final Validator validator = new UrlValidator();        validator.validate(list);        final Iterator i = list.iterator();        assertEquals(new URL(\"http://www.apache.org/\"), i.next());        assertEquals(new URL(\"file:///etc\"), i.next());        assertFalse(i.hasNext());    }    public void testMalformedURL()        throws InvalidArgumentException, MalformedURLException {        final Object[] array = new Object[] { \"www.apache.org\" };        final List list = Arrays.asList(array);        final Validator validator = new UrlValidator();        try {            validator.validate(list);        } catch (InvalidArgumentException e) {            assertEquals(resources.getMessage(ResourceConstants.URLVALIDATOR_MALFORMED_URL,                                              new Object[] { \"www.apache.org\" }), e.getMessage());        }    }    public void testBadProtocol() {        {            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };            final List list = Arrays.asList(array);            final UrlValidator validator = new UrlValidator();            validator.setProtocol(\"http\");            assertEquals(\"incorrect protocol\", \"http\", validator.getProtocol());            try {                validator.validate(list);                fail(\"Expected InvalidArgumentException\");            } catch (InvalidArgumentException e) {                assertEquals(\"file:///etc\", e.getMessage());            }        }        {            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };            final List list = Arrays.asList(array);            final UrlValidator validator = new UrlValidator(\"http\");            try {                validator.validate(list);                fail(\"Expected InvalidArgumentException\");            } catch (InvalidArgumentException e) {                assertEquals(\"file:///etc\", e.getMessage());            }        }    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.cli2.resource.ResourceConstants;\n+import org.apache.commons.cli2.resource.ResourceHelper;\n+\n+public class UrlValidatorTest\n+    extends TestCase {\n+    private static final ResourceHelper resources = ResourceHelper.getResourceHelper();\n+\n+    public void testValidate()\n+        throws InvalidArgumentException, MalformedURLException {\n+        final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new UrlValidator();\n+\n+        validator.validate(list);\n+\n+        final Iterator i = list.iterator();\n+        assertEquals(new URL(\"http://www.apache.org/\"), i.next());\n+        assertEquals(new URL(\"file:///etc\"), i.next());\n+        assertFalse(i.hasNext());\n+    }\n+\n+    public void testMalformedURL()\n+        throws InvalidArgumentException, MalformedURLException {\n+        final Object[] array = new Object[] { \"www.apache.org\" };\n+        final List list = Arrays.asList(array);\n+        final Validator validator = new UrlValidator();\n+\n+        try {\n+            validator.validate(list);\n+        } catch (InvalidArgumentException e) {\n+            assertEquals(resources.getMessage(ResourceConstants.URLVALIDATOR_MALFORMED_URL,\n+                                              new Object[] { \"www.apache.org\" }), e.getMessage());\n+        }\n+    }\n+\n+    public void testBadProtocol() {\n+        {\n+            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };\n+            final List list = Arrays.asList(array);\n+            final UrlValidator validator = new UrlValidator();\n+            validator.setProtocol(\"http\");\n+\n+            assertEquals(\"incorrect protocol\", \"http\", validator.getProtocol());\n+\n+            try {\n+                validator.validate(list);\n+                fail(\"Expected InvalidArgumentException\");\n+            } catch (InvalidArgumentException e) {\n+                assertEquals(\"file:///etc\", e.getMessage());\n+            }\n+        }\n+\n+        {\n+            final Object[] array = new Object[] { \"http://www.apache.org/\", \"file:///etc\" };\n+            final List list = Arrays.asList(array);\n+            final UrlValidator validator = new UrlValidator(\"http\");\n+\n+            try {\n+                validator.validate(list);\n+                fail(\"Expected InvalidArgumentException\");\n+            } catch (InvalidArgumentException e) {\n+                assertEquals(\"file:///etc\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/cli2/validation/protect/ProtectedClass.java\n+++ b/src/test/org/apache/commons/cli2/validation/protect/ProtectedClass.java\n-/** * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the \"License\"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.cli2.validation.protect;class ProtectedClass {    protected ProtectedClass() {        // used to test something???    }}\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.cli2.validation.protect;\n+\n+class ProtectedClass {\n+    protected ProtectedClass() {\n+        // used to test something???\n+    }\n+}", "timestamp": 1206155303, "metainfo": ""}