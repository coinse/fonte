{"sha": "a1b5d44432c057cf675f051bb20379937565f4ef", "log": "Moving to Java 5  ", "commit": "\n--- a/src/main/java/org/apache/commons/cli/AmbiguousOptionException.java\n+++ b/src/main/java/org/apache/commons/cli/AmbiguousOptionException.java\n public class AmbiguousOptionException extends UnrecognizedOptionException\n {\n     /** The list of options matching the partial name specified */\n-    private Collection matchingOptions;\n+    private Collection<String> matchingOptions;\n \n     /**\n      * Constructs a new AmbiguousOptionException.\n      * @param option          the partial option name\n      * @param matchingOptions the options matching the name\n      */\n-    public AmbiguousOptionException(String option, Collection matchingOptions)\n+    public AmbiguousOptionException(String option, Collection<String> matchingOptions)\n     {\n         super(createMessage(option, matchingOptions), option);\n         this.matchingOptions = matchingOptions;\n     /**\n      * Returns the options matching the partial name.\n      */\n-    public Collection getMatchingOptions()\n+    public Collection<String> getMatchingOptions()\n     {\n         return matchingOptions;\n     }\n      * @param matchingOptions\n      * @return\n      */\n-    private static String createMessage(String option, Collection matchingOptions)\n+    private static String createMessage(String option, Collection<String> matchingOptions)\n     {\n         StringBuffer buff = new StringBuffer(\"Ambiguous option: '\");\n         buff.append(option);\n--- a/src/main/java/org/apache/commons/cli/CommandLine.java\n+++ b/src/main/java/org/apache/commons/cli/CommandLine.java\n     private static final long serialVersionUID = 1L;\n \n     /** the unrecognised options/arguments */\n-    private List args = new LinkedList();\n+    private List<String> args = new LinkedList<String>();\n \n     /** the processed options */\n-    private List options = new ArrayList();\n+    private List<Option> options = new ArrayList<Option>();\n \n     /**\n      * Creates a command line.\n      */\n     public String[] getOptionValues(String opt)\n     {\n-        List values = new ArrayList();\n-\n-        for (Iterator it = options.iterator(); it.hasNext();)\n-        {\n-            Option option = (Option) it.next();\n+        List<String> values = new ArrayList<String>();\n+\n+        for (Option option : options)\n+        {\n             if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n             {\n                 values.addAll(option.getValuesList());\n             }\n         }\n \n-        return values.isEmpty() ? null : (String[]) values.toArray(new String[values.size()]);\n+        return values.isEmpty() ? null : values.toArray(new String[values.size()]);\n     }\n \n     /**\n     private Option resolveOption(String opt)\n     {\n         opt = Util.stripLeadingHyphens(opt);\n-        for (Iterator it = options.iterator(); it.hasNext();)\n-        {\n-            Option option = (Option) it.next();\n+        for (Option option : options) {\n             if (opt.equals(option.getOpt()))\n             {\n                 return option;\n     {\n         Properties props = new Properties();\n \n-        for (Iterator it = options.iterator(); it.hasNext();)\n-        {\n-            Option option = (Option) it.next();\n-\n+        for (Option option : options)\n+        {\n             if (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n             {\n-                List values = option.getValuesList();\n+                List<String> values = option.getValuesList();\n                 if (values.size() >= 2)\n                 {\n                     // use the first 2 arguments as the key/value pair\n      *\n      * @return remaining items passed in but not parsed as a <code>List</code>.\n      */\n-    public List getArgList()\n+    public List<String> getArgList()\n     {\n         return args;\n     }\n      */\n     public Option[] getOptions()\n     {\n-        Collection processed = options;\n+        Collection<Option> processed = options;\n \n         // reinitialise array\n         Option[] optionsArray = new Option[processed.size()];\n \n         // return the array\n-        return (Option[]) processed.toArray(optionsArray);\n+        return processed.toArray(optionsArray);\n     }\n }\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n \n import java.util.ArrayList;\n import java.util.Enumeration;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Properties;\n \n     /** Flag indicating if tokens should no longer be analysed and simply added as arguments of the command line. */\n     protected boolean skipParsing;\n     \n-    /** The required options expected to be found when parsing the command line. */\n+    /** The required options and groups expected to be found when parsing the command line. */\n     protected List expectedOpts;\n     \n     public CommandLine parse(Options options, String[] arguments) throws ParseException\n         expectedOpts = new ArrayList(options.getRequiredOptions());\n         \n         // clear the data from the groups\n-        for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n-        {\n-            OptionGroup group = (OptionGroup) it.next();\n+        for (OptionGroup group : options.getOptionGroups())\n+        {\n             group.setSelected(null);\n         }\n         \n \n         if (arguments != null)\n         {\n-            for (int i = 0; i < arguments.length; i++)\n-            {\n-                handleToken(arguments[i]);\n+            for (String argument : arguments)\n+            {\n+                handleToken(argument);\n             }\n         }\n         \n      */\n     private void handleLongOptionWithoutEqual(String token) throws ParseException\n     {\n-        List matchingOpts = options.getMatchingOptions(token);\n+        List<String> matchingOpts = options.getMatchingOptions(token);\n         if (matchingOpts.isEmpty())\n         {\n             handleUnknownToken(currentToken);\n         }\n         else\n         {\n-            handleOption(options.getOption((String) matchingOpts.get(0)));\n+            handleOption(options.getOption(matchingOpts.get(0)));\n         }\n     }\n \n         \n         String opt = token.substring(0, pos);\n         \n-        List matchingOpts = options.getMatchingOptions(opt);\n+        List<String> matchingOpts = options.getMatchingOptions(opt);\n         if (matchingOpts.isEmpty())\n         {\n             handleUnknownToken(currentToken);\n         }\n         else\n         {\n-            Option option = options.getOption((String) matchingOpts.get(0));\n+            Option option = options.getOption(matchingOpts.get(0));\n             \n             if (option.acceptsArg())\n             {\n         }\n         else if (pos == -1)\n         {\n+            // no equal sign found (-xxx)\n             if (options.hasShortOption(t))\n             {\n                 handleOption(options.getOption(t));\n         }\n         else\n         {\n+            // equal sign found (-xxx=yyy)\n             String opt = t.substring(0, pos);\n             String value = t.substring(pos + 1);\n             \n         // check the previous option before handling the next one\n         checkRequiredArgs();\n         \n-        option = (Option) option.clone();\n+        option = option.clone();\n         \n         updateRequiredOptions(option);\n         \n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n      * \n      * Defaults to case-insensitive alphabetical sorting by option key\n      */\n-    protected Comparator optionComparator = new OptionComparator();\n+    protected Comparator<Option> optionComparator = new OptionComparator();\n     \n     /**\n      * Sets the 'width'.\n      * \n      * @since 1.2\n      */\n-    public Comparator getOptionComparator()\n+    public Comparator<Option> getOptionComparator()\n     {\n         return optionComparator;\n     }\n      * \n      * @since 1.2\n      */\n-    public void setOptionComparator(Comparator comparator)\n+    public void setOptionComparator(Comparator<Option> comparator)\n     {\n         if (comparator == null)\n         {\n         StringBuffer buff = new StringBuffer(getSyntaxPrefix()).append(app).append(\" \");\n \n         // create a list for processed option groups\n-        final Collection processedGroups = new ArrayList();\n+        final Collection<OptionGroup> processedGroups = new ArrayList<OptionGroup>();\n \n         // temp variable\n         Option option;\n \n-        List optList = new ArrayList(options.getOptions());\n+        List<Option> optList = new ArrayList<Option>(options.getOptions());\n         Collections.sort(optList, getOptionComparator());\n         // iterate over the options\n         for (Iterator i = optList.iterator(); i.hasNext();)\n             buff.append(\"[\");\n         }\n \n-        List optList = new ArrayList(group.getOptions());\n+        List<Option> optList = new ArrayList<Option>(group.getOptions());\n         Collections.sort(optList, getOptionComparator());\n         // for each option in the OptionGroup\n         for (Iterator i = optList.iterator(); i.hasNext();)\n         // sort options ascending\n         int max = 0;\n         StringBuffer optBuf;\n-        List prefixList = new ArrayList();\n-\n-        List optList = options.helpOptions();\n-\n+        List<StringBuffer> prefixList = new ArrayList<StringBuffer>();\n+        \n+        List<Option> optList = options.helpOptions();\n+        \n         Collections.sort(optList, getOptionComparator());\n-\n-        for (Iterator i = optList.iterator(); i.hasNext();)\n-        {\n-            Option option = (Option) i.next();\n+        \n+        for (Option option : optList)\n+        {\n             optBuf = new StringBuffer();\n             \n             if (option.getOpt() == null)\n      * This class implements the <code>Comparator</code> interface\n      * for comparing Options.\n      */\n-    private static class OptionComparator implements Comparator\n-    {\n-\n+    private static class OptionComparator implements Comparator<Option>\n+    {\n         /**\n          * Compares its two arguments for order. Returns a negative\n          * integer, zero, or a positive integer as the first argument\n          * is less than, equal to, or greater than the second.\n          *\n-         * @param o1 The first Option to be compared.\n-         * @param o2 The second Option to be compared.\n+         * @param opt1 The first Option to be compared.\n+         * @param opt2 The second Option to be compared.\n          * @return a negative integer, zero, or a positive integer as\n          *         the first argument is less than, equal to, or greater than the\n          *         second.\n          */\n-        public int compare(Object o1, Object o2)\n-        {\n-            Option opt1 = (Option) o1;\n-            Option opt2 = (Option) o2;\n-\n+        public int compare(Option opt1, Option opt2)\n+        {\n             return opt1.getKey().compareToIgnoreCase(opt2.getKey());\n         }\n     }\n--- a/src/main/java/org/apache/commons/cli/MissingOptionException.java\n+++ b/src/main/java/org/apache/commons/cli/MissingOptionException.java\n  */\n public class MissingOptionException extends ParseException\n {\n-    /** The list of missing options */\n+    /** The list of missing options and groups */\n     private List missingOptions;\n \n     /**\n--- a/src/main/java/org/apache/commons/cli/Option.java\n+++ b/src/main/java/org/apache/commons/cli/Option.java\n     private Class type = String.class;\n \n     /** the list of argument values **/\n-    private List values = new ArrayList();\n+    private List<String> values = new ArrayList<String>();\n \n     /** the character that is the value separator */\n     private char valuesep;\n      */\n     public String getValue()\n     {\n-        return hasNoValues() ? null : (String) values.get(0);\n+        return hasNoValues() ? null : values.get(0);\n     }\n \n     /**\n      */\n     public String getValue(int index) throws IndexOutOfBoundsException\n     {\n-        return hasNoValues() ? null : (String) values.get(index);\n+        return hasNoValues() ? null : values.get(index);\n     }\n \n     /**\n      */\n     public String[] getValues()\n     {\n-        return hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n+        return hasNoValues() ? null : values.toArray(new String[values.size()]);\n     }\n \n     /**\n      * @return the values of this Option as a List\n      * or null if there are no values\n      */\n-    public List getValuesList()\n+    public List<String> getValuesList()\n     {\n         return values;\n     }\n      *\n      * @throws RuntimeException\n      */\n-    public Object clone()\n+    public Option clone()\n     {\n         try\n         {\n             Option option = (Option) super.clone();\n-            option.values = new ArrayList(values);\n+            option.values = new ArrayList<String>(values);\n             return option;\n         }\n         catch (CloneNotSupportedException cnse)\n--- a/src/main/java/org/apache/commons/cli/OptionGroup.java\n+++ b/src/main/java/org/apache/commons/cli/OptionGroup.java\n     private static final long serialVersionUID = 1L;\n     \n     /** hold the options */\n-    private Map optionMap = new HashMap();\n+    private Map<String, Option> optionMap = new HashMap<String, Option>();\n \n     /** the name of the selected option */\n     private String selected;\n      * @return the names of the options in this group as a \n      * <code>Collection</code>\n      */\n-    public Collection getNames()\n+    public Collection<String> getNames()\n     {\n         // the key set is the collection of names\n         return optionMap.keySet();\n     /**\n      * @return the options in this group as a <code>Collection</code>\n      */\n-    public Collection getOptions()\n+    public Collection<Option> getOptions()\n     {\n         // the values are the collection of options\n         return optionMap.values();\n      */\n     public String toString()\n     {\n-        StringBuffer buff = new StringBuffer();\n-\n-        Iterator iter = getOptions().iterator();\n+        StringBuilder buff = new StringBuilder();\n+        \n+        Iterator<Option> iter = getOptions().iterator();\n \n         buff.append(\"[\");\n \n         while (iter.hasNext())\n         {\n-            Option option = (Option) iter.next();\n+            Option option = iter.next();\n \n             if (option.getOpt() != null)\n             {\n--- a/src/main/java/org/apache/commons/cli/OptionValidator.java\n+++ b/src/main/java/org/apache/commons/cli/OptionValidator.java\n         // handle the multi character opt\n         else\n         {\n-            char[] chars = opt.toCharArray();\n-\n-            for (int i = 0; i < chars.length; i++)\n+            for (char ch : opt.toCharArray())\n             {\n-                if (!isValidChar(chars[i]))\n+                if (!isValidChar(ch))\n                 {\n-                    throw new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n+                    throw new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + ch + \"'\");\n                 }\n             }\n         }\n--- a/src/main/java/org/apache/commons/cli/Options.java\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n     private static final long serialVersionUID = 1L;\n \n     /** a map of the options with the character key */\n-    private Map shortOpts = new HashMap();\n+    private Map<String, Option> shortOpts = new HashMap<String, Option>();\n \n     /** a map of the options with the long key */\n-    private Map longOpts = new HashMap();\n+    private Map<String, Option> longOpts = new HashMap<String, Option>();\n \n     /** a map of the required options */\n-    private List requiredOpts = new ArrayList();\n+    private List<Object> requiredOpts = new ArrayList<Object>();\n \n     /** a map of the option groups */\n-    private Map optionGroups = new HashMap();\n+    private Map<String, OptionGroup> optionGroups = new HashMap<String, OptionGroup>();\n \n     /**\n      * Add the specified option group.\n      *\n      * @return a Collection of OptionGroup instances.\n      */\n-    Collection getOptionGroups()\n-    {\n-        return new HashSet(optionGroups.values());\n+    Collection<OptionGroup> getOptionGroups()\n+    {\n+        return new HashSet<OptionGroup>(optionGroups.values());\n     }\n \n     /**\n      *\n      * @return read-only Collection of {@link Option} objects in this descriptor\n      */\n-    public Collection getOptions()\n+    public Collection<Option> getOptions()\n     {\n         return Collections.unmodifiableCollection(helpOptions());\n     }\n      *\n      * @return the List of Options\n      */\n-    List helpOptions()\n-    {\n-        return new ArrayList(shortOpts.values());\n+    List<Option> helpOptions()\n+    {\n+        return new ArrayList<Option>(shortOpts.values());\n     }\n \n     /**\n \n         if (shortOpts.containsKey(opt))\n         {\n-            return (Option) shortOpts.get(opt);\n-        }\n-\n-        return (Option) longOpts.get(opt);\n+            return shortOpts.get(opt);\n+        }\n+\n+        return longOpts.get(opt);\n     }\n \n     /**\n      * @return the options matching the partial name specified, or an empty list if none matches\n      * @since 1.3\n      */\n-    public List getMatchingOptions(String opt)\n+    public List<String> getMatchingOptions(String opt)\n     {\n         opt = Util.stripLeadingHyphens(opt);\n         \n-        List matchingOpts = new ArrayList();\n+        List<String> matchingOpts = new ArrayList<String>();\n         \n-        Iterator it = longOpts.keySet().iterator();\n-        while (it.hasNext())\n-        {\n-            String longOpt = (String) it.next();\n-            if (longOpt.startsWith(opt))\n-            {\n+        for (String longOpt : longOpts.keySet()) {\n+            if (longOpt.startsWith(opt)) {\n                 matchingOpts.add(longOpt);\n             }\n-        }        \n+        }\n         \n         return matchingOpts;\n     }\n      */\n     public OptionGroup getOptionGroup(Option opt)\n     {\n-        return (OptionGroup) optionGroups.get(opt.getKey());\n+        return optionGroups.get(opt.getKey());\n     }\n \n     /**", "timestamp": 1302634649, "metainfo": ""}