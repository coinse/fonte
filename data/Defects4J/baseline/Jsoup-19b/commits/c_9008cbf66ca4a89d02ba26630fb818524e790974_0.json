{"sha": "9008cbf66ca4a89d02ba26630fb818524e790974", "log": "Adding Selector parser", "commit": "\n--- a/src/main/java/org/jsoup/select/ng/AndSelector.java\n+++ b/src/main/java/org/jsoup/select/ng/AndSelector.java\n \t\tthis.selectors = selectors;\n \t}\n \t\n+\tpublic AndSelector() {\n+\t\tsuper();\n+\t\tthis.selectors = new ArrayList<Evaluator>();\n+\t}\n+\n+\t\n \tpublic AndSelector(Collection<Evaluator> selectors) {\n \t\tsuper();\n \t\tthis.selectors = new ArrayList<Evaluator>();\n \tpublic void add(Evaluator e) {\n \t\tselectors.add(e);\n \t}\n+\t\n+\tpublic void addAll(Collection<Evaluator> e) {\n+\t\tselectors.addAll(e);\n+\t}\n+\n \n \n \t@Override\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/ng/parser/Parser.java\n+package org.jsoup.select.ng.parser;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Evaluator;\n+import org.jsoup.parser.TokenQueue;\n+import org.jsoup.select.ng.AndSelector;\n+import org.jsoup.select.ng.BasicSelector;\n+import org.jsoup.select.ng.ElementContainerSelector;\n+import org.jsoup.select.ng.ParentSelector;\n+\n+public class Parser {\n+\tTokenQueue tq;\n+    private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n+    String query;\n+    Deque<Evaluator> s = new ArrayDeque<Evaluator>();\n+    \n+    \n+    \n+    public Parser(String query) {\n+    \tthis.query = query;\n+    \tthis.tq = new TokenQueue(query);\n+    }\n+    \n+    public static Evaluator select(String query) {\n+    \tParser p = new Parser(query);\n+    \treturn p.select();\n+    }\n+    \n+    public Evaluator select() {\n+        tq.consumeWhitespace();\n+        \n+        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n+            //elements.add(root);\n+            combinator(tq.consume().toString());\n+        } else if (tq.matches(\":has(\")) {\n+            //elements.addAll(root.getAllElements());\n+        } else {\n+            //addElements(findElements()); // chomp first element matcher off queue \n+        \tfindElements();\n+        }            \n+               \n+        while (!tq.isEmpty()) {\n+            // hierarchy and extras\n+            boolean seenWhite = tq.consumeWhitespace();\n+            \n+            if (tq.matchChomp(\",\")) { // group or\n+\n+            \twhile (!tq.isEmpty()) {\n+                    String subQuery = tq.chompTo(\",\");\n+                    \n+                    \n+                    \n+                    //elements.addAll(select(subQuery, root));\n+                    //select(subQuery);\n+                }\n+            } else if (tq.matchesAny(combinators)) {\n+                combinator(tq.consume().toString());\n+            } else if (seenWhite) {\n+                combinator(\" \");\n+            } else { // E.class, E#id, E[attr] etc. AND\n+                findElements(); // take next el, #. etc off queue\n+            }\n+        }\n+        \n+        if(s.size() == 1)\n+        \treturn s.getFirst();\n+        \n+        return new AndSelector(s);\n+    }\n+    \n+    private void combinator(String combinator) {\n+        tq.consumeWhitespace();\n+        String subQuery = tq.consumeToAny(combinators); // support multi > childs\n+        \n+        \n+\n+        if (combinator.equals(\">\")) {\n+            //output = filterForChildren(elements, select(subQuery, elements));\n+        } else if (combinator.equals(\" \")) {\n+        \tAndSelector a = new AndSelector();\n+        \ta.add(select(subQuery));\n+        \ta.add(new ParentSelector(new AndSelector(s)));\n+        \ts.clear();\n+        \ts.push(a);\n+        \t\n+        \t\n+            //output = filterForDescendants(elements, select(subQuery, elements));\n+        } else if (combinator.equals(\"+\")) {\n+            //output = filterForAdjacentSiblings(elements, select(subQuery, root));\n+        } else if (combinator.equals(\"~\")) {\n+            //output = filterForGeneralSiblings(elements, select(subQuery, root));\n+        } else\n+            throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n+        \n+\n+    }\n+    \n+    private void findElements() {\n+        if (tq.matchChomp(\"#\")) {\n+            byId();\n+        } else if (tq.matchChomp(\".\")) {\n+            byClass();\n+        } else if (tq.matchesWord()) {\n+            byTag();\n+        } else if (tq.matches(\"[\")) {\n+            byAttribute();\n+        } else if (tq.matchChomp(\"*\")) {\n+            allElements();\n+        } else if (tq.matchChomp(\":lt(\")) {\n+            indexLessThan();\n+        } else if (tq.matchChomp(\":gt(\")) {\n+            indexGreaterThan();\n+        } else if (tq.matchChomp(\":eq(\")) {\n+            indexEquals();\n+        } else if (tq.matches(\":has(\")) {\n+            has();\n+        } else if (tq.matches(\":contains(\")) {\n+            contains(false);\n+        } else if (tq.matches(\":containsOwn(\")) {\n+            contains(true);\n+        } else if (tq.matches(\":matches(\")) {\n+            matches(false);\n+        } else if (tq.matches(\":matchesOwn(\")) {\n+            matches(true);\n+        } else if (tq.matches(\":not(\")) {\n+            not();\n+        } else { // unhandled\n+            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n+        }\n+    }\n+    \n+\n+    private void byId() {\n+        String id = tq.consumeCssIdentifier();\n+        Validate.notEmpty(id);\n+        ecPush(new Evaluator.Id(id));\n+    }\n+\n+    private void byClass() {\n+        String className = tq.consumeCssIdentifier();\n+        Validate.notEmpty(className);\n+        ecPush(new Evaluator.Class(className));\n+    }\n+\n+    private void byTag() {\n+        String tagName = tq.consumeElementSelector();\n+        Validate.notEmpty(tagName);\n+        \n+        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n+        if (tagName.contains(\"|\"))\n+            tagName = tagName.replace(\"|\", \":\");\n+        \n+        ecPush(new Evaluator.Tag(tagName));\n+    }\n+\n+    private void byAttribute() {\n+        TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n+        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n+        Validate.notEmpty(key);\n+        cq.consumeWhitespace();\n+\n+        if (cq.isEmpty()) {\n+            if(key.startsWith(\"^\"))\n+            \tecPush(new Evaluator.AttributeStarting(key.substring(1)));\n+            else\n+            \tecPush(new Evaluator.Attribute(key));\n+        } else {\n+        \tString value = cq.remainder();\n+            if (cq.matchChomp(\"=\"))\n+            \tecPush(new Evaluator.AttributeWithValue(key, value));\n+\n+            else if (cq.matchChomp(\"!=\"))\n+                ecPush(new Evaluator.AttributeWithValueNot(key, value));\n+\n+            else if (cq.matchChomp(\"^=\"))\n+            \tecPush(new Evaluator.AttributeWithValueStarting(key, value));\n+\n+            else if (cq.matchChomp(\"$=\"))\n+            \tecPush(new Evaluator.AttributeWithValueEnding(key, value));\n+\n+            else if (cq.matchChomp(\"*=\"))\n+            \tecPush(new Evaluator.AttributeWithValueContaining(key, value));\n+            \n+            else if (cq.matchChomp(\"~=\"))\n+            \tecPush(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(value)));\n+            \n+            else\n+                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n+        }\n+    }\n+\n+    private void allElements() {\n+        //return root.getAllElements();\n+    \t// TODO: add all parsing\n+    }\n+    \n+    // pseudo selectors :lt, :gt, :eq\n+    private void indexLessThan() {\n+    \t\n+        ecPush(new Evaluator.IndexLessThan(consumeIndex()));\n+    }\n+    \n+    private void indexGreaterThan() {\n+    \tecPush(new Evaluator.IndexGreaterThan(consumeIndex()));\n+    }\n+    \n+    private void indexEquals() {\n+    \tecPush(new Evaluator.IndexEquals(consumeIndex()));\n+    }\n+\n+    private int consumeIndex() {\n+        String indexS = tq.chompTo(\")\").trim();\n+        Validate.isTrue(StringUtil.isNumeric(indexS), \"Index must be numeric\");\n+        return Integer.parseInt(indexS);\n+    }\n+\n+    // pseudo selector :has(el)\n+    private void has() {\n+        tq.consume(\":has\");\n+        String subQuery = tq.chompBalanced('(',')');\n+        Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n+        // TODO: add has parsing\n+    }\n+    \n+    // pseudo selector :contains(text), containsOwn(text)\n+    private void contains(boolean own) {\n+        tq.consume(own ? \":containsOwn\" : \":contains\");\n+        String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n+        Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n+        \n+        // TODO: add :contains parsing\n+    }\n+    \n+    // :matches(regex), matchesOwn(regex)\n+    private void matches(boolean own) {\n+        tq.consume(own? \":matchesOwn\" : \":matches\");\n+        String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n+        Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n+        \n+        // TODO: add :matches parsing\n+        \n+    }\n+\n+    // :not(selector)\n+    private void not() {\n+        tq.consume(\":not\");\n+        String subQuery = tq.chompBalanced('(', ')');\n+        Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n+\n+        // TODO: add :not parsing\n+    }\n+\n+\n+    public static class SelectorParseException extends IllegalStateException {\n+        public SelectorParseException(String msg, Object... params) {\n+            super(String.format(msg, params));\n+        }\n+    }\n+    \n+    void ecPush(Evaluator e) {\n+    \tEvaluator p = s.peek();\n+\n+    \tif(p == null || !(p instanceof ElementContainerSelector)) {\n+    \t\ts.push(new ElementContainerSelector().add(e));\n+    \t\treturn;\n+    \t}\n+    \t\n+    \tElementContainerSelector ec = (ElementContainerSelector) p;\n+    \tec.add(e);\n+    }\n+\n+    \n+    public static void main(String[] args) {\n+    \tEvaluator e = select(\"div p href\");\n+\t}\n+    \n+\n+\n+    \n+\t\n+\n+}", "timestamp": 1309605124, "metainfo": ""}