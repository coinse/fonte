{"sha": "93fc1f9363d911cb0a974f993d9266a89a63c41e", "log": "Fix Checkstyle: Format for 120 line length.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n \n /**\n  * The format specification of a CSV file.\n- *\n+ * \n  * This class is immutable.\n  */\n public class CSVFormat implements Serializable {\n     private final boolean isEncapsulating;\n \n     /**\n-     * Constant char to be used for disabling comments, escapes and encapsulation.\n-     * The value -2 is used because it won't be confused with an EOF signal (-1),\n-     * and because the unicode value FFFE would be encoded as two chars (using surrogates)\n-     * and thus there should never be a collision with a real text char.\n+     * Constant char to be used for disabling comments, escapes and encapsulation. The value -2 is used because it\n+     * won't be confused with an EOF signal (-1), and because the unicode value FFFE would be encoded as two chars\n+     * (using surrogates) and thus there should never be a collision with a real text char.\n      */\n     static final char DISABLED = '\\ufffe';\n \n             .withLineSeparator(CRLF);\n \n     /**\n-     * Excel file format (using a comma as the value delimiter).\n-     * Note that the actual value delimiter used by Excel is locale dependent,\n-     * it might be necessary to customize this format to accomodate to your\n-     * regional settings.\n+     * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n+     * locale dependent, it might be necessary to customize this format to accomodate to your regional settings.\n      * <p/>\n-     * For example for parsing or generating a CSV file on a French system\n-     * the following format will be used:\n-     *\n-     * <pre>CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');</pre>\n+     * For example for parsing or generating a CSV file on a French system the following format will be used:\n+     * \n+     * <pre>\n+     * CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');\n+     * </pre>\n      */\n     public static final CSVFormat EXCEL =\n             PRISTINE\n             .withLineSeparator(CRLF);\n \n     /**\n-     * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and\n-     * <tt>LOAD DATA INFILE</tt> operations. This is a tab-delimited\n-     * format with a LF character as the line separator. Values are not quoted\n-     * and special characters are escaped with '\\'.\n-     *\n-     * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n+     * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and <tt>LOAD DATA INFILE</tt> operations. This is\n+     * a tab-delimited format with a LF character as the line separator. Values are not quoted and special characters\n+     * are escaped with '\\'.\n+     * \n+     * @see <a\n+     *      href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n     public static final CSVFormat MYSQL =\n             PRISTINE\n \n     /**\n      * Creates a customized CSV format.\n-     *\n-     * @param delimiter                 the char used for value separation\n-     * @param encapsulator              the char used as value encapsulation marker\n-     * @param commentStart              the char used for comment identification\n-     * @param escape                    the char used to escape special characters in values\n-     * @param surroundingSpacesIgnored  <tt>true</tt> when whitespaces enclosing values should be ignored\n-     * @param emptyLinesIgnored         <tt>true</tt> when the parser should skip emtpy lines\n-     * @param lineSeparator             the line separator to use for output\n-     * @param header                    the header\n-     */\n-    CSVFormat(\n-            char delimiter,\n-            char encapsulator,\n-            char commentStart,\n-            char escape,\n-            boolean surroundingSpacesIgnored,\n-            boolean emptyLinesIgnored,\n-            String lineSeparator,\n-            String[] header) {\n+     * \n+     * @param delimiter\n+     *            the char used for value separation\n+     * @param encapsulator\n+     *            the char used as value encapsulation marker\n+     * @param commentStart\n+     *            the char used for comment identification\n+     * @param escape\n+     *            the char used to escape special characters in values\n+     * @param surroundingSpacesIgnored\n+     *            <tt>true</tt> when whitespaces enclosing values should be ignored\n+     * @param emptyLinesIgnored\n+     *            <tt>true</tt> when the parser should skip emtpy lines\n+     * @param lineSeparator\n+     *            the line separator to use for output\n+     * @param header\n+     *            the header\n+     */\n+    CSVFormat(char delimiter, char encapsulator, char commentStart, char escape, boolean surroundingSpacesIgnored,\n+            boolean emptyLinesIgnored, String lineSeparator, String[] header) {\n         this.delimiter = delimiter;\n         this.encapsulator = encapsulator;\n         this.commentStart = commentStart;\n \n     /**\n      * Returns true if the given character is a line break character.\n-     *\n-     * @param c the character to check\n-     *\n+     * \n+     * @param c\n+     *            the character to check\n+     * \n      * @return true if <code>c</code> is a line break character\n      */\n     private static boolean isLineBreak(char c) {\n      */\n     void validate() throws IllegalArgumentException {\n         if (delimiter == encapsulator) {\n-            throw new IllegalArgumentException(\"The encapsulator character and the delimiter cannot be the same (\\\"\" + encapsulator + \"\\\")\");\n+            throw new IllegalArgumentException(\"The encapsulator character and the delimiter cannot be the same (\\\"\"\n+                    + encapsulator + \"\\\")\");\n         }\n \n         if (delimiter == escape) {\n-            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same (\\\"\" + escape + \"\\\")\");\n+            throw new IllegalArgumentException(\"The escape character and the delimiter cannot be the same (\\\"\"\n+                    + escape + \"\\\")\");\n         }\n \n         if (delimiter == commentStart) {\n-            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same (\\\"\" + commentStart + \"\\\")\");\n+            throw new IllegalArgumentException(\"The comment start character and the delimiter cannot be the same (\\\"\"\n+                    + commentStart + \"\\\")\");\n         }\n \n         if (encapsulator != DISABLED && encapsulator == commentStart) {\n-            throw new IllegalArgumentException(\"The comment start character and the encapsulator cannot be the same (\\\"\" + commentStart + \"\\\")\");\n+            throw new IllegalArgumentException(\n+                    \"The comment start character and the encapsulator cannot be the same (\\\"\" + commentStart + \"\\\")\");\n         }\n \n         if (escape != DISABLED && escape == commentStart) {\n-            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same (\\\"\" + commentStart + \"\\\")\");\n+            throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same (\\\"\"\n+                    + commentStart + \"\\\")\");\n         }\n     }\n \n     /**\n      * Returns the character delimiting the values (typically ';', ',' or '\\t').\n-     *\n+     * \n      * @return the delimiter character\n      */\n     public char getDelimiter() {\n \n     /**\n      * Returns a copy of this format using the specified delimiter character.\n-     *\n-     * @param delimiter the delimiter character\n+     * \n+     * @param delimiter\n+     *            the delimiter character\n      * @return A copy of this format using the specified delimiter character\n-     * @throws IllegalArgumentException thrown if the specified character is a line break\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n      */\n     public CSVFormat withDelimiter(char delimiter) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Returns the character used to encapsulate values containing special characters.\n-     *\n+     * \n      * @return the encapsulator character\n      */\n     public char getEncapsulator() {\n \n     /**\n      * Returns a copy of this format using the specified encapsulator character.\n-     *\n-     * @param encapsulator the encapsulator character\n+     * \n+     * @param encapsulator\n+     *            the encapsulator character\n      * @return A copy of this format using the specified encapsulator character\n-     * @throws IllegalArgumentException thrown if the specified character is a line break\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n      */\n     public CSVFormat withEncapsulator(char encapsulator) {\n         if (isLineBreak(encapsulator)) {\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Returns whether an encapsulator has been defined.\n-     *\n+     * \n      * @return {@code true} if an encapsulator is defined\n      */\n     public boolean isEncapsulating() {\n \n     /**\n      * Returns the character marking the start of a line comment.\n-     *\n+     * \n      * @return the comment start marker.\n      */\n     public char getCommentStart() {\n \n     /**\n      * Returns a copy of this format using the specified character as the comment start marker.\n-     *\n-     * Note that the comment introducer character is only recognised\n-     * at the start of a line.\n-     *\n-     * @param commentStart the comment start marker\n+     * \n+     * Note that the comment introducer character is only recognised at the start of a line.\n+     * \n+     * @param commentStart\n+     *            the comment start marker\n      * @return A copy of this format using the specified character as the comment start marker\n-     * @throws IllegalArgumentException thrown if the specified character is a line break\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n      */\n     public CSVFormat withCommentStart(char commentStart) {\n         if (isLineBreak(commentStart)) {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Specifies whether comments are supported by this format.\n-     *\n-     * Note that the comment introducer character is only recognised\n-     * at the start of a line.\n-     *\n+     * \n+     * Note that the comment introducer character is only recognised at the start of a line.\n+     * \n      * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n      */\n     public boolean isCommentingEnabled() {\n \n     /**\n      * Returns the escape character.\n-     *\n+     * \n      * @return the escape character\n      */\n     public char getEscape() {\n \n     /**\n      * Returns a copy of this format using the specified escape character.\n-     *\n-     * @param escape the escape character\n+     * \n+     * @param escape\n+     *            the escape character\n      * @return A copy of this format using the specified escape character\n-     * @throws IllegalArgumentException thrown if the specified character is a line break\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n      */\n     public CSVFormat withEscape(char escape) {\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n \n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Returns whether escape are being processed.\n-     *\n+     * \n      * @return {@code true} if escapes are processed\n      */\n     public boolean isEscaping() {\n \n     /**\n      * Specifies whether spaces around values are ignored when parsing input.\n-     *\n-     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the value.\n+     * \n+     * @return <tt>true</tt> if spaces around values are ignored, <tt>false</tt> if they are treated as part of the\n+     *         value.\n      */\n     public boolean isSurroundingSpacesIgnored() {\n         return surroundingSpacesIgnored;\n \n     /**\n      * Returns a copy of this format with the specified trimming behavior.\n-     *\n-     * @param surroundingSpacesIgnored the trimming behavior, <tt>true</tt> to remove the surrounding spaces,\n-     *                                 <tt>false</tt> to leave the spaces as is.\n+     * \n+     * @param surroundingSpacesIgnored\n+     *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n+     *            spaces as is.\n      * @return A copy of this format with the specified trimming behavior.\n      */\n     public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Specifies whether empty lines between records are ignored when parsing input.\n-     *\n-     * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty records.\n+     * \n+     * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n+     *         records.\n      */\n     public boolean isEmptyLinesIgnored() {\n         return emptyLinesIgnored;\n \n     /**\n      * Returns a copy of this format with the specified empty line skipping behavior.\n-     *\n-     * @param emptyLinesIgnored the empty line skipping behavior, <tt>true</tt> to ignore the empty lines\n-     *                          between the records, <tt>false</tt> to translate empty lines to empty records.\n-     * @return A copy of this format  with the specified empty line skipping behavior.\n+     * \n+     * @param emptyLinesIgnored\n+     *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n+     *            <tt>false</tt> to translate empty lines to empty records.\n+     * @return A copy of this format with the specified empty line skipping behavior.\n      */\n     public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Returns the line separator delimiting output records.\n-     *\n+     * \n      * @return the line separator\n      */\n     public String getLineSeparator() {\n \n     /**\n      * Returns a copy of this format using the specified output line separator.\n-     *\n-     * @param lineSeparator the line separator to be used for output.\n-     *\n+     * \n+     * @param lineSeparator\n+     *            the line separator to be used for output.\n+     * \n      * @return A copy of this format using the specified output line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     String[] getHeader() {\n     }\n \n     /**\n-     * Returns a copy of this format using the specified header. The header can\n-     * either be parsed automatically from the input file with:\n-     *\n-     * <pre>CSVFormat format = aformat.withHeader();</pre>\n-     *\n+     * Returns a copy of this format using the specified header. The header can either be parsed automatically from the\n+     * input file with:\n+     * \n+     * <pre>\n+     * CSVFormat format = aformat.withHeader();\n+     * </pre>\n+     * \n      * or specified manually with:\n-     *\n-     * <pre>CSVFormat format = aformat.withHeader(\"name\", \"email\", \"phone\");</pre>\n-     *\n-     * @param header the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n-     *\n+     * \n+     * <pre>\n+     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n+     * </pre>\n+     * \n+     * @param header\n+     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n+     * \n      * @return A copy of this format using the specified header\n      */\n     public CSVFormat withHeader(String... header) {\n-        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, emptyLinesIgnored, lineSeparator, header);\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored,\n+                emptyLinesIgnored, lineSeparator, header);\n     }\n \n     /**\n      * Parses the specified content.\n-     *\n-     * @param in the input stream\n+     * \n+     * @param in\n+     *            the input stream\n      */\n     public Iterable<CSVRecord> parse(Reader in) throws IOException {\n         return new CSVParser(in, this);\n \n     /**\n      * Format the specified values.\n-     *\n-     * @param values the values to format\n+     * \n+     * @param values\n+     *            the values to format\n      */\n     public String format(String... values) {\n         StringWriter out = new StringWriter();\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n      * Returns the next token.\n      * <p/>\n      * A token corresponds to a term, a record change or an end-of-file indicator.\n-     *\n-     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the Token.\n+     * \n+     * @param tkn\n+     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n      * @return the next token found\n-     * @throws java.io.IOException on stream access error\n+     * @throws java.io.IOException\n+     *             on stream access error\n      */\n     @Override\n     Token nextToken(Token tkn) throws IOException {\n         // get the last read char (required for empty line detection)\n         int lastChar = in.readAgain();\n \n-        //  read the next char and set eol\n+        // read the next char and set eol\n         int c = in.read();\n         /*\n-         * Note:\n-         * The following call will swallow LF if c == CR.\n-         * But we don't need to know if the last char\n-         * was CR or LF - they are equivalent here.\n+         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n+         * - they are equivalent here.\n          */\n         boolean eol = isEndOfLine(c);\n \n-        //  empty line detection: eol AND (last char was EOL or beginning)\n+        // empty line detection: eol AND (last char was EOL or beginning)\n         if (emptyLinesIgnored) {\n             while (eol && isStartOfLine(lastChar)) {\n                 // go on char ahead ...\n             return tkn;\n         }\n \n-        //  important: make sure a new char gets consumed in each iteration\n+        // important: make sure a new char gets consumed in each iteration\n         while (tkn.type == INVALID) {\n             // ignore whitespaces at beginning of a token\n             if (surroundingSpacesIgnored) {\n                 tkn.type = TOKEN;\n             } else if (eol) {\n                 // empty token return EORECORD(\"\")\n-                //noop: tkn.content.append(\"\");\n+                // noop: tkn.content.append(\"\");\n                 tkn.type = EORECORD;\n             } else if (isEncapsulator(c)) {\n                 // consume encapsulated token\n                 encapsulatedTokenLexer(tkn);\n             } else if (isEndOfFile(c)) {\n                 // end of file return EOF()\n-                //noop: tkn.content.append(\"\");\n+                // noop: tkn.content.append(\"\");\n                 tkn.type = EOF;\n                 tkn.isReady = true; // there is data at EOF\n             } else {\n     /**\n      * A simple token lexer\n      * <p/>\n-     * Simple token are tokens which are not surrounded by encapsulators.\n-     * A simple token might contain escaped delimiters (as \\, or \\;). The\n-     * token is finished when one of the following conditions become true:\n+     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n+     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n      * <ul>\n-     *   <li>end of line has been reached (EORECORD)</li>\n-     *   <li>end of stream has been reached (EOF)</li>\n-     *   <li>an unescaped delimiter has been reached (TOKEN)</li>\n+     * <li>end of line has been reached (EORECORD)</li>\n+     * <li>end of stream has been reached (EOF)</li>\n+     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n      * </ul>\n-     *\n-     * @param tkn the current token\n-     * @param c   the current character\n+     * \n+     * @param tkn\n+     *            the current token\n+     * @param c\n+     *            the current character\n      * @return the filled token\n-     * @throws IOException on stream access error\n+     * @throws IOException\n+     *             on stream access error\n      */\n     private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n         // Faster to use while(true)+break than while(tkn.type == INVALID)\n     /**\n      * An encapsulated token lexer\n      * <p/>\n-     * Encapsulated tokens are surrounded by the given encapsulating-string.\n-     * The encapsulator itself might be included in the token using a\n-     * doubling syntax (as \"\", '') or using escaping (as in \\\", \\').\n-     * Whitespaces before and after an encapsulated token are ignored.\n-     * The token is finished when one of the following conditions become true:\n+     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n+     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n+     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n      * <ul>\n-     *   <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n-     *   <ul>\n-     *       <li>delimiter (TOKEN)</li>\n-     *       <li>end of line (EORECORD)</li>\n-     *   </ul>\n-     *   <li>end of stream has been reached (EOF)</li>\n+     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n+     * <ul>\n+     * <li>delimiter (TOKEN)</li>\n+     * <li>end of line (EORECORD)</li>\n      * </ul>\n-     *\n-     * @param tkn the current token\n+     * <li>end of stream has been reached (EOF)</li> </ul>\n+     * \n+     * @param tkn\n+     *            the current token\n      * @return a valid token object\n-     * @throws IOException on invalid state:\n-     *  EOF before closing encapsulator or invalid character before delimiter or EOL\n+     * @throws IOException\n+     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n      */\n     private Token encapsulatedTokenLexer(Token tkn) throws IOException {\n         // save current line number in case needed for IOE\n                             return tkn;\n                         } else if (!isWhitespace(c)) {\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                            throw new IOException(\"(line \" + getLineNumber()\n+                                    + \") invalid char between encapsulated token and delimiter\");\n                         }\n                     }\n                 }\n             } else if (isEndOfFile(c)) {\n                 // error condition (end of file before end of token)\n-                throw new IOException(\"(startline \" + startLineNumber + \") EOF reached before encapsulated token finished\");\n+                throw new IOException(\"(startline \" + startLineNumber\n+                        + \") EOF reached before encapsulated token finished\");\n             } else {\n                 // consume character\n                 tkn.content.append((char) c);", "timestamp": 1347392835, "metainfo": ""}