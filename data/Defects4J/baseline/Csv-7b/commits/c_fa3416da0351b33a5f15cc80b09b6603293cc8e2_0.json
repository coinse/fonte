{"sha": "fa3416da0351b33a5f15cc80b09b6603293cc8e2", "log": "Sort methods.  ", "commit": "\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     };\n \n     @Test\n-    public void testGetLine() throws IOException {\n-        final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n-        for (final String[] re : RESULT) {\n-            assertArrayEquals(re, parser.nextRecord().values());\n-        }\n-\n-        assertNull(parser.nextRecord());\n-    }\n-\n-    @Test\n-    public void testGetRecords() throws IOException {\n-        final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(RESULT.length, records.size());\n+    public void testBackslashEscaping() throws IOException {\n+\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+\n+        final String code =\n+                \"one,two,three\\n\" // 0\n+                        + \"'',''\\n\"       // 1) empty encapsulators\n+                        + \"/',/'\\n\"       // 2) single encapsulators\n+                        + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n+                        + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n+                        + \"/,,/,\\n\"       // 5) separator escaped\n+                        + \"//,//\\n\"       // 6) escape escaped\n+                        + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n+                        + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n+                        + \"9,   /\\n   \\n\"  // escaped newline\n+                        + \"\";\n+        final String[][] res = {\n+                {\"one\", \"two\", \"three\"}, // 0\n+                {\"\", \"\"},                // 1\n+                {\"'\", \"'\"},              // 2\n+                {\"'\", \"'\"},              // 3\n+                {\"'\", \"'\"},              // 4\n+                {\",\", \",\"},              // 5\n+                {\"/\", \"/\"},              // 6\n+                {\"/\", \"/\"},              // 7\n+                {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"},\n+                {\"9\", \"   \\n   \"},\n+        };\n+\n+\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'')\n+                               .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n+\n+        final CSVParser parser = CSVParser.parse(code, format);\n+        final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n-        for (int i = 0; i < RESULT.length; i++) {\n-            assertArrayEquals(RESULT[i], records.get(i).values());\n-        }\n-    }\n-\n-    @Test\n-    public void testExcelFormat1() throws IOException {\n-        final String code =\n-                \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n-                        + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n-        final String[][] res = {\n-                {\"value1\", \"value2\", \"value3\", \"value4\"},\n-                {\"a\", \"b\", \"c\", \"d\"},\n-                {\"  x\", \"\", \"\", \"\"},\n-                {\"\"},\n-                {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n-        };\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(res.length, records.size());\n+\n+        Utils.compare(\"Records do not match expected result\", res, records);\n+    }\n+\n+    @Test\n+    public void testBackslashEscaping2() throws IOException {\n+\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+\n+        final String code = \"\"\n+                + \" , , \\n\"           // 1)\n+                + \" \\t ,  , \\n\"       // 2)\n+                + \" // , /, , /,\\n\"   // 3)\n+                + \"\";\n+        final String[][] res = {\n+                {\" \", \" \", \" \"},         // 1\n+                {\" \\t \", \"  \", \" \"},     // 2\n+                {\" / \", \" , \", \" ,\"},    // 3\n+        };\n+\n+\n+        final CSVFormat format = CSVFormat.newFormat(',')\n+                .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n+\n+        final CSVParser parser = CSVParser.parse(code, format);\n+        final List<CSVRecord> records = parser.getRecords();\n         assertTrue(records.size() > 0);\n-        for (int i = 0; i < res.length; i++) {\n-            assertArrayEquals(res[i], records.get(i).values());\n-        }\n-    }\n-\n-    @Test\n-    public void testExcelFormat2() throws Exception {\n-        final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n-        final String[][] res = {\n-                {\"foo\", \"baar\"},\n-                {\"\"},\n-                {\"hello\", \"\"},\n-                {\"\"},\n-                {\"world\", \"\"}\n-        };\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(res.length, records.size());\n-        assertTrue(records.size() > 0);\n-        for (int i = 0; i < res.length; i++) {\n-            assertArrayEquals(res[i], records.get(i).values());\n-        }\n-    }\n-\n-    @Test\n-    public void testEndOfFileBehaviourExcel() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n-                \"hello,\\r\\n\\r\\nworld,\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"},\n-                {\"\"},  // Excel format does not ignore empty lines\n-                {\"world\", \"\"}\n-        };\n-\n-        for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testEndOfFileBehaviorCSV() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n-                \"hello,\\r\\n\\r\\nworld,\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"},  // CSV format ignores empty lines\n-                {\"world\", \"\"}\n-        };\n-        for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testEmptyLineBehaviourExcel() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\n\\n\\n\",\n-                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\\"\\\"\\n\\n\\n\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"},\n-                {\"\"},  // Excel format does not ignore empty lines\n-                {\"\"}\n-        };\n-        for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testEmptyLineBehaviourCSV() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\n\\n\\n\",\n-                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\\"\\\"\\n\\n\\n\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"}  // CSV format ignores empty lines\n-        };\n-        for (final String code : codes) {\n-            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-            final List<CSVRecord> records = parser.getRecords();\n-            assertEquals(res.length, records.size());\n-            assertTrue(records.size() > 0);\n-            for (int i = 0; i < res.length; i++) {\n-                assertArrayEquals(res[i], records.get(i).values());\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testEmptyFile() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n-        assertNull(parser.nextRecord());\n-    }\n-\n-    @Test\n-    public void testCSV57() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n-        final List<CSVRecord> list = parser.getRecords();\n-        assertNotNull(list);\n-        assertEquals(0, list.size());\n+\n+        Utils.compare(\"\", res, records);\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void testBackslashEscaping() throws IOException {\n-\n-        // To avoid confusion over the need for escaping chars in java code,\n-        // We will test with a forward slash as the escape char, and a single\n-        // quote as the encapsulator.\n-\n-        final String code =\n-                \"one,two,three\\n\" // 0\n-                        + \"'',''\\n\"       // 1) empty encapsulators\n-                        + \"/',/'\\n\"       // 2) single encapsulators\n-                        + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n-                        + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n-                        + \"/,,/,\\n\"       // 5) separator escaped\n-                        + \"//,//\\n\"       // 6) escape escaped\n-                        + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n-                        + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n-                        + \"9,   /\\n   \\n\"  // escaped newline\n-                        + \"\";\n-        final String[][] res = {\n-                {\"one\", \"two\", \"three\"}, // 0\n-                {\"\", \"\"},                // 1\n-                {\"'\", \"'\"},              // 2\n-                {\"'\", \"'\"},              // 3\n-                {\"'\", \"'\"},              // 4\n-                {\",\", \",\"},              // 5\n-                {\"/\", \"/\"},              // 6\n-                {\"/\", \"/\"},              // 7\n-                {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"},\n-                {\"9\", \"   \\n   \"},\n-        };\n-\n-\n-        final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'')\n-                               .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n-\n-        final CSVParser parser = CSVParser.parse(code, format);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertTrue(records.size() > 0);\n-\n-        Utils.compare(\"Records do not match expected result\", res, records);\n-    }\n-\n-    @Test\n-    public void testBackslashEscaping2() throws IOException {\n-\n-        // To avoid confusion over the need for escaping chars in java code,\n-        // We will test with a forward slash as the escape char, and a single\n-        // quote as the encapsulator.\n-\n-        final String code = \"\"\n-                + \" , , \\n\"           // 1)\n-                + \" \\t ,  , \\n\"       // 2)\n-                + \" // , /, , /,\\n\"   // 3)\n-                + \"\";\n-        final String[][] res = {\n-                {\" \", \" \", \" \"},         // 1\n-                {\" \\t \", \"  \", \" \"},     // 2\n-                {\" / \", \" , \", \" ,\"},    // 3\n-        };\n-\n-\n-        final CSVFormat format = CSVFormat.newFormat(',')\n-                .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n-\n-        final CSVParser parser = CSVParser.parse(code, format);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertTrue(records.size() > 0);\n-\n-        Utils.compare(\"\", res, records);\n-    }\n-\n-    @Test\n-    public void testDefaultFormat() throws IOException {\n-        final String code = \"\"\n-                + \"a,b#\\n\"           // 1)\n-                + \"\\\"\\n\\\",\\\" \\\",#\\n\"   // 2)\n-                + \"#,\\\"\\\"\\n\"         // 3)\n-                + \"# Final comment\\n\"// 4)\n-                ;\n-        final String[][] res = {\n-                {\"a\", \"b#\"},\n-                {\"\\n\", \" \", \"#\"},\n-                {\"#\", \"\"},\n-                {\"# Final comment\"}\n-        };\n-\n-        CSVFormat format = CSVFormat.DEFAULT;\n-        assertFalse(format.isCommentingEnabled());\n-\n-        CSVParser parser = CSVParser.parse(code, format);\n-        List<CSVRecord> records = parser.getRecords();\n-        assertTrue(records.size() > 0);\n-\n-        Utils.compare(\"Failed to parse without comments\", res, records);\n-\n-        final String[][] res_comments = {\n-                {\"a\", \"b#\"},\n-                {\"\\n\", \" \", \"#\"},\n-        };\n-\n-        format = CSVFormat.DEFAULT.withCommentStart('#');\n-        parser = CSVParser.parse(code, format);\n-        records = parser.getRecords();\n-\n-        Utils.compare(\"Failed to parse with comments\", res_comments, records);\n+    public void testCarriageReturnEndings() throws IOException {\n+        final String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n+        final List<CSVRecord> records = parser.getRecords();\n+        assertEquals(4, records.size());\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void testCarriageReturnEndings() throws IOException {\n-        final String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(4, records.size());\n-    }\n-\n-    @Test\n-    public void testLineFeedEndings() throws IOException {\n-        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(4, records.size());\n-    }\n-\n-    @Test\n-    public void testIgnoreEmptyLines() throws IOException {\n-        final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n-        //String code = \"world\\r\\n\\n\";\n-        //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n-        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n-        final List<CSVRecord> records = parser.getRecords();\n-        assertEquals(3, records.size());\n+    public void testCSV57() throws Exception {\n+        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n+        final List<CSVRecord> list = parser.getRecords();\n+        assertNotNull(list);\n+        assertEquals(0, list.size());\n+    }\n+\n+    @Test\n+    public void testDefaultFormat() throws IOException {\n+        final String code = \"\"\n+                + \"a,b#\\n\"           // 1)\n+                + \"\\\"\\n\\\",\\\" \\\",#\\n\"   // 2)\n+                + \"#,\\\"\\\"\\n\"         // 3)\n+                + \"# Final comment\\n\"// 4)\n+                ;\n+        final String[][] res = {\n+                {\"a\", \"b#\"},\n+                {\"\\n\", \" \", \"#\"},\n+                {\"#\", \"\"},\n+                {\"# Final comment\"}\n+        };\n+\n+        CSVFormat format = CSVFormat.DEFAULT;\n+        assertFalse(format.isCommentingEnabled());\n+\n+        CSVParser parser = CSVParser.parse(code, format);\n+        List<CSVRecord> records = parser.getRecords();\n+        assertTrue(records.size() > 0);\n+\n+        Utils.compare(\"Failed to parse without comments\", res, records);\n+\n+        final String[][] res_comments = {\n+                {\"a\", \"b#\"},\n+                {\"\\n\", \" \", \"#\"},\n+        };\n+\n+        format = CSVFormat.DEFAULT.withCommentStart('#');\n+        parser = CSVParser.parse(code, format);\n+        records = parser.getRecords();\n+\n+        Utils.compare(\"Failed to parse with comments\", res_comments, records);\n+    }\n+\n+    @Test\n+    public void testEmptyFile() throws Exception {\n+        final CSVParser parser = CSVParser.parse(\"\", CSVFormat.DEFAULT);\n+        assertNull(parser.nextRecord());\n+    }\n+\n+    @Test\n+    public void testEmptyLineBehaviourCSV() throws Exception {\n+        final String[] codes = {\n+                \"hello,\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\n\\n\\n\",\n+                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\\"\\\"\\n\\n\\n\"\n+        };\n+        final String[][] res = {\n+                {\"hello\", \"\"}  // CSV format ignores empty lines\n+        };\n+        for (final String code : codes) {\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyLineBehaviourExcel() throws Exception {\n+        final String[] codes = {\n+                \"hello,\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\n\\n\\n\",\n+                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\\"\\\"\\n\\n\\n\"\n+        };\n+        final String[][] res = {\n+                {\"hello\", \"\"},\n+                {\"\"},  // Excel format does not ignore empty lines\n+                {\"\"}\n+        };\n+        for (final String code : codes) {\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEndOfFileBehaviorCSV() throws Exception {\n+        final String[] codes = {\n+                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n+        };\n+        final String[][] res = {\n+                {\"hello\", \"\"},  // CSV format ignores empty lines\n+                {\"world\", \"\"}\n+        };\n+        for (final String code : codes) {\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testEndOfFileBehaviourExcel() throws Exception {\n+        final String[] codes = {\n+                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n+        };\n+        final String[][] res = {\n+                {\"hello\", \"\"},\n+                {\"\"},  // Excel format does not ignore empty lines\n+                {\"world\", \"\"}\n+        };\n+\n+        for (final String code : codes) {\n+            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(res.length, records.size());\n+            assertTrue(records.size() > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertArrayEquals(res[i], records.get(i).values());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelFormat1() throws IOException {\n+        final String code =\n+                \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n+                        + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n+        final String[][] res = {\n+                {\"value1\", \"value2\", \"value3\", \"value4\"},\n+                {\"a\", \"b\", \"c\", \"d\"},\n+                {\"  x\", \"\", \"\", \"\"},\n+                {\"\"},\n+                {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n+        };\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n+        final List<CSVRecord> records = parser.getRecords();\n+        assertEquals(res.length, records.size());\n+        assertTrue(records.size() > 0);\n+        for (int i = 0; i < res.length; i++) {\n+            assertArrayEquals(res[i], records.get(i).values());\n+        }\n+    }\n+\n+    @Test\n+    public void testExcelFormat2() throws Exception {\n+        final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n+        final String[][] res = {\n+                {\"foo\", \"baar\"},\n+                {\"\"},\n+                {\"hello\", \"\"},\n+                {\"\"},\n+                {\"world\", \"\"}\n+        };\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n+        final List<CSVRecord> records = parser.getRecords();\n+        assertEquals(res.length, records.size());\n+        assertTrue(records.size() > 0);\n+        for (int i = 0; i < res.length; i++) {\n+            assertArrayEquals(res[i], records.get(i).values());\n+        }\n     }\n \n     @Test\n         assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, records.get(0).values());\n         assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, records.get(1).values());\n         assertArrayEquals(new String[]{\"x\", \"y\", \"z\"}, records.get(2).values());\n-    }\n-\n-    @Test\n-    public void testRoundtrip() throws Exception {\n-        final StringWriter out = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n-        final String input = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n-        for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) {\n-            printer.printRecord(record);\n-        }\n-        assertEquals(input, out.toString());\n-        printer.close();\n-    }\n-\n-    @Test\n-    public void testIterator() throws Exception {\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n-\n-        assertTrue(iterator.hasNext());\n-        try {\n-            iterator.remove();\n-            fail(\"expected UnsupportedOperationException\");\n-        } catch (final UnsupportedOperationException expected) {\n-            // expected\n-        }\n-        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, iterator.next().values());\n-        assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, iterator.next().values());\n-        assertTrue(iterator.hasNext());\n-        assertTrue(iterator.hasNext());\n-        assertTrue(iterator.hasNext());\n-        assertArrayEquals(new String[]{\"x\", \"y\", \"z\"}, iterator.next().values());\n-        assertFalse(iterator.hasNext());\n-\n-        try {\n-            iterator.next();\n-            fail(\"NoSuchElementException expected\");\n-        } catch (final NoSuchElementException e) {\n-            // expected\n-        }\n-    }\n-\n-    @Test // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\n-    public void testMultipleIterators() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"a,b,c\" + CR + \"d,e,f\", CSVFormat.DEFAULT);\n-\n-        final Iterator<CSVRecord> itr1 = parser.iterator();\n-        final Iterator<CSVRecord> itr2 = parser.iterator();\n-\n-        final CSVRecord first = itr1.next();\n-        assertEquals(\"a\", first.get(0));\n-        assertEquals(\"b\", first.get(1));\n-        assertEquals(\"c\", first.get(2));\n-\n-        final CSVRecord second = itr2.next();\n-        assertEquals(\"d\", second.get(0));\n-        assertEquals(\"e\", second.get(1));\n-        assertEquals(\"f\", second.get(2));\n-    }\n-\n-    @Test\n-    public void testHeader() throws Exception {\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n-\n-        for (int i = 0; i < 2; i++) {\n-            assertTrue(records.hasNext());\n-            final CSVRecord record = records.next();\n-            assertEquals(record.get(0), record.get(\"a\"));\n-            assertEquals(record.get(1), record.get(\"b\"));\n-            assertEquals(record.get(2), record.get(\"c\"));\n-        }\n-\n-        assertFalse(records.hasNext());\n-    }\n-\n-    @Test\n-    public void testSkipSetHeader() throws Exception {\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord(true)\n-                .parse(in).iterator();\n-        final CSVRecord record = records.next();\n-        assertEquals(\"1\", record.get(\"a\"));\n-        assertEquals(\"2\", record.get(\"b\"));\n-        assertEquals(\"3\", record.get(\"c\"));\n-    }\n-\n-    @Test\n-    public void testSkipAutoHeader() throws Exception {\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n-        final CSVRecord record = records.next();\n-        assertEquals(\"1\", record.get(\"a\"));\n-        assertEquals(\"2\", record.get(\"b\"));\n-        assertEquals(\"3\", record.get(\"c\"));\n-    }\n-\n-    @Test\n-    public void testHeaderComment() throws Exception {\n-        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n-\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n-\n-        for (int i = 0; i < 2; i++) {\n-            assertTrue(records.hasNext());\n-            final CSVRecord record = records.next();\n-            assertEquals(record.get(0), record.get(\"a\"));\n-            assertEquals(record.get(1), record.get(\"b\"));\n-            assertEquals(record.get(2), record.get(\"c\"));\n-        }\n-\n-        assertFalse(records.hasNext());\n-    }\n-\n-    @Test\n-    public void testProvidedHeader() throws Exception {\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n-\n-        for (int i = 0; i < 3; i++) {\n-            assertTrue(records.hasNext());\n-            final CSVRecord record = records.next();\n-            assertTrue(record.isMapped(\"A\"));\n-            assertTrue(record.isMapped(\"B\"));\n-            assertTrue(record.isMapped(\"C\"));\n-            assertFalse(record.isMapped(\"NOT MAPPED\"));\n-            assertEquals(record.get(0), record.get(\"A\"));\n-            assertEquals(record.get(1), record.get(\"B\"));\n-            assertEquals(record.get(2), record.get(\"C\"));\n-        }\n-\n-        assertFalse(records.hasNext());\n-    }\n-\n-    @Test\n-    public void testProvidedHeaderAuto() throws Exception {\n-        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n-\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n-\n-        for (int i = 0; i < 2; i++) {\n-            assertTrue(records.hasNext());\n-            final CSVRecord record = records.next();\n-            assertTrue(record.isMapped(\"a\"));\n-            assertTrue(record.isMapped(\"b\"));\n-            assertTrue(record.isMapped(\"c\"));\n-            assertFalse(record.isMapped(\"NOT MAPPED\"));\n-            assertEquals(record.get(0), record.get(\"a\"));\n-            assertEquals(record.get(1), record.get(\"b\"));\n-            assertEquals(record.get(2), record.get(\"c\"));\n-        }\n-\n-        assertFalse(records.hasNext());\n-    }\n-\n-    @Test\n-    public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n-        final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord(true)\n-                .parse(in).iterator();\n-        CSVRecord record;\n-\n-        // 1st record\n-        record = records.next();\n-        assertTrue(record.isMapped(\"A\"));\n-        assertTrue(record.isMapped(\"B\"));\n-        assertTrue(record.isMapped(\"C\"));\n-        assertTrue(record.isSet(\"A\"));\n-        assertTrue(record.isSet(\"B\"));\n-        assertFalse(record.isSet(\"C\"));\n-        assertEquals(\"1\", record.get(\"A\"));\n-        assertEquals(\"2\", record.get(\"B\"));\n-        assertFalse(record.isConsistent());\n-\n-        // 2nd record\n-        record = records.next();\n-        assertTrue(record.isMapped(\"A\"));\n-        assertTrue(record.isMapped(\"B\"));\n-        assertTrue(record.isMapped(\"C\"));\n-        assertTrue(record.isSet(\"A\"));\n-        assertTrue(record.isSet(\"B\"));\n-        assertTrue(record.isSet(\"C\"));\n-        assertEquals(\"x\", record.get(\"A\"));\n-        assertEquals(\"y\", record.get(\"B\"));\n-        assertEquals(\"z\", record.get(\"C\"));\n-        assertTrue(record.isConsistent());\n-\n-        assertFalse(records.hasNext());\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void testNoHeaderMap() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n-        Assert.assertNull(parser.getHeaderMap());\n+    public void testGetLine() throws IOException {\n+        final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        for (final String[] re : RESULT) {\n+            assertArrayEquals(re, parser.nextRecord().values());\n+        }\n+\n+        assertNull(parser.nextRecord());\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithCR() throws Exception {\n+        this.validateLineNumbers(String.valueOf(CR));\n+    }\n+\n+    @Test\n+    public void testGetLineNumberWithCRLF() throws Exception {\n+        this.validateLineNumbers(CRLF);\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void testGetLineNumberWithCRLF() throws Exception {\n-        this.validateLineNumbers(CRLF);\n-    }\n-\n-    @Test\n-    public void testGetLineNumberWithCR() throws Exception {\n-        this.validateLineNumbers(String.valueOf(CR));\n+    public void testGetRecordNumberWithCR() throws Exception {\n+        this.validateRecordNumbers(String.valueOf(CR));\n+    }\n+\n+    @Test\n+    public void testGetRecordNumberWithCRLF() throws Exception {\n+        this.validateRecordNumbers(CRLF);\n     }\n \n     @Test\n     public void testGetRecordNumberWithLF() throws Exception {\n         this.validateRecordNumbers(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetRecords() throws IOException {\n+        final CSVParser parser = CSVParser.parse(CSVINPUT, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final List<CSVRecord> records = parser.getRecords();\n+        assertEquals(RESULT.length, records.size());\n+        assertTrue(records.size() > 0);\n+        for (int i = 0; i < RESULT.length; i++) {\n+            assertArrayEquals(RESULT[i], records.get(i).values());\n+        }\n     }\n \n     @Test\n     }\n \n     @Test\n-    public void testGetRecordNumberWithCRLF() throws Exception {\n-        this.validateRecordNumbers(CRLF);\n-    }\n-\n-    @Test\n-    public void testGetRecordNumberWithCR() throws Exception {\n-        this.validateRecordNumbers(String.valueOf(CR));\n+    public void testHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n+\n+        for (int i = 0; i < 2; i++) {\n+            assertTrue(records.hasNext());\n+            final CSVRecord record = records.next();\n+            assertEquals(record.get(0), record.get(\"a\"));\n+            assertEquals(record.get(1), record.get(\"b\"));\n+            assertEquals(record.get(2), record.get(\"c\"));\n+        }\n+\n+        assertFalse(records.hasNext());\n+    }\n+\n+    @Test\n+    public void testHeaderComment() throws Exception {\n+        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n+\n+        for (int i = 0; i < 2; i++) {\n+            assertTrue(records.hasNext());\n+            final CSVRecord record = records.next();\n+            assertEquals(record.get(0), record.get(\"a\"));\n+            assertEquals(record.get(1), record.get(\"b\"));\n+            assertEquals(record.get(2), record.get(\"c\"));\n+        }\n+\n+        assertFalse(records.hasNext());\n+    }\n+\n+    @Test\n+    public void testIgnoreEmptyLines() throws IOException {\n+        final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+        //String code = \"world\\r\\n\\n\";\n+        //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n+        final List<CSVRecord> records = parser.getRecords();\n+        assertEquals(3, records.size());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n         new CSVParser(null, invalidFormat).close();\n     }\n \n+    @Test\n+    public void testIterator() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();\n+\n+        assertTrue(iterator.hasNext());\n+        try {\n+            iterator.remove();\n+            fail(\"expected UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException expected) {\n+            // expected\n+        }\n+        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, iterator.next().values());\n+        assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, iterator.next().values());\n+        assertTrue(iterator.hasNext());\n+        assertTrue(iterator.hasNext());\n+        assertTrue(iterator.hasNext());\n+        assertArrayEquals(new String[]{\"x\", \"y\", \"z\"}, iterator.next().values());\n+        assertFalse(iterator.hasNext());\n+\n+        try {\n+            iterator.next();\n+            fail(\"NoSuchElementException expected\");\n+        } catch (final NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testLineFeedEndings() throws IOException {\n+        final String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n+        final List<CSVRecord> records = parser.getRecords();\n+        assertEquals(4, records.size());\n+    }\n+\n+    @Test\n+    public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").withSkipHeaderRecord(true)\n+                .parse(in).iterator();\n+        CSVRecord record;\n+\n+        // 1st record\n+        record = records.next();\n+        assertTrue(record.isMapped(\"A\"));\n+        assertTrue(record.isMapped(\"B\"));\n+        assertTrue(record.isMapped(\"C\"));\n+        assertTrue(record.isSet(\"A\"));\n+        assertTrue(record.isSet(\"B\"));\n+        assertFalse(record.isSet(\"C\"));\n+        assertEquals(\"1\", record.get(\"A\"));\n+        assertEquals(\"2\", record.get(\"B\"));\n+        assertFalse(record.isConsistent());\n+\n+        // 2nd record\n+        record = records.next();\n+        assertTrue(record.isMapped(\"A\"));\n+        assertTrue(record.isMapped(\"B\"));\n+        assertTrue(record.isMapped(\"C\"));\n+        assertTrue(record.isSet(\"A\"));\n+        assertTrue(record.isSet(\"B\"));\n+        assertTrue(record.isSet(\"C\"));\n+        assertEquals(\"x\", record.get(\"A\"));\n+        assertEquals(\"y\", record.get(\"B\"));\n+        assertEquals(\"z\", record.get(\"C\"));\n+        assertTrue(record.isConsistent());\n+\n+        assertFalse(records.hasNext());\n+    }\n+\n+    @Test // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\n+    public void testMultipleIterators() throws Exception {\n+        final CSVParser parser = CSVParser.parse(\"a,b,c\" + CR + \"d,e,f\", CSVFormat.DEFAULT);\n+\n+        final Iterator<CSVRecord> itr1 = parser.iterator();\n+        final Iterator<CSVRecord> itr2 = parser.iterator();\n+\n+        final CSVRecord first = itr1.next();\n+        assertEquals(\"a\", first.get(0));\n+        assertEquals(\"b\", first.get(1));\n+        assertEquals(\"c\", first.get(2));\n+\n+        final CSVRecord second = itr2.next();\n+        assertEquals(\"d\", second.get(0));\n+        assertEquals(\"e\", second.get(1));\n+        assertEquals(\"f\", second.get(2));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewCSVParserNullReaderFormat() throws Exception {\n+        new CSVParser(null, CSVFormat.DEFAULT);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewCSVParserReaderNullFormat() throws Exception {\n+        new CSVParser(new StringReader(\"\"), null);\n+    }\n+\n+    @Test\n+    public void testNoHeaderMap() throws Exception {\n+        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n+        Assert.assertNull(parser.getHeaderMap());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testParseFileNullFormat() throws Exception {\n+        CSVParser.parse(new File(\"\"), null);\n+    }\n+\n     @Test(expected = IllegalArgumentException.class)\n     public void testParseNullFileFormat() throws Exception {\n         CSVParser.parse((File) null, CSVFormat.DEFAULT);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testParseFileNullFormat() throws Exception {\n-        CSVParser.parse(new File(\"\"), null);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n     public void testParseNullStringFormat() throws Exception {\n         CSVParser.parse((String) null, CSVFormat.DEFAULT);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n+    public void testParseNullUrlCharsetFormat() throws Exception {\n+        CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testParserUrlNullCharsetFormat() throws Exception {\n+        CSVParser.parse(new URL(\"http://commons.apache.org\"), null, CSVFormat.DEFAULT);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testParseStringNullFormat() throws Exception {\n         CSVParser.parse(\"csv data\", null);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testParseNullUrlCharsetFormat() throws Exception {\n-        CSVParser.parse(null, Charset.defaultCharset(), CSVFormat.DEFAULT);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testParserUrlNullCharsetFormat() throws Exception {\n-        CSVParser.parse(new URL(\"http://commons.apache.org\"), null, CSVFormat.DEFAULT);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n     public void testParseUrlCharsetNullFormat() throws Exception {\n         CSVParser.parse(new URL(\"http://commons.apache.org\"), Charset.defaultCharset(), null);\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n-    public void testNewCSVParserNullReaderFormat() throws Exception {\n-        new CSVParser(null, CSVFormat.DEFAULT);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void testNewCSVParserReaderNullFormat() throws Exception {\n-        new CSVParser(new StringReader(\"\"), null);\n+    @Test\n+    public void testProvidedHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+\n+        for (int i = 0; i < 3; i++) {\n+            assertTrue(records.hasNext());\n+            final CSVRecord record = records.next();\n+            assertTrue(record.isMapped(\"A\"));\n+            assertTrue(record.isMapped(\"B\"));\n+            assertTrue(record.isMapped(\"C\"));\n+            assertFalse(record.isMapped(\"NOT MAPPED\"));\n+            assertEquals(record.get(0), record.get(\"A\"));\n+            assertEquals(record.get(1), record.get(\"B\"));\n+            assertEquals(record.get(2), record.get(\"C\"));\n+        }\n+\n+        assertFalse(records.hasNext());\n+    }\n+\n+    @Test\n+    public void testProvidedHeaderAuto() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n+\n+        for (int i = 0; i < 2; i++) {\n+            assertTrue(records.hasNext());\n+            final CSVRecord record = records.next();\n+            assertTrue(record.isMapped(\"a\"));\n+            assertTrue(record.isMapped(\"b\"));\n+            assertTrue(record.isMapped(\"c\"));\n+            assertFalse(record.isMapped(\"NOT MAPPED\"));\n+            assertEquals(record.get(0), record.get(\"a\"));\n+            assertEquals(record.get(1), record.get(\"b\"));\n+            assertEquals(record.get(2), record.get(\"c\"));\n+        }\n+\n+        assertFalse(records.hasNext());\n+    }\n+\n+    @Test\n+    public void testRoundtrip() throws Exception {\n+        final StringWriter out = new StringWriter();\n+        final CSVPrinter printer = new CSVPrinter(out, CSVFormat.DEFAULT);\n+        final String input = \"a,b,c\\r\\n1,2,3\\r\\nx,y,z\\r\\n\";\n+        for (final CSVRecord record : CSVParser.parse(input, CSVFormat.DEFAULT)) {\n+            printer.printRecord(record);\n+        }\n+        assertEquals(input, out.toString());\n+        printer.close();\n+    }\n+\n+    @Test\n+    public void testSkipAutoHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n+        final CSVRecord record = records.next();\n+        assertEquals(\"1\", record.get(\"a\"));\n+        assertEquals(\"2\", record.get(\"b\"));\n+        assertEquals(\"3\", record.get(\"c\"));\n+    }\n+\n+    @Test\n+    public void testSkipSetHeader() throws Exception {\n+        final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"a\", \"b\", \"c\").withSkipHeaderRecord(true)\n+                .parse(in).iterator();\n+        final CSVRecord record = records.next();\n+        assertEquals(\"1\", record.get(\"a\"));\n+        assertEquals(\"2\", record.get(\"b\"));\n+        assertEquals(\"3\", record.get(\"c\"));\n+    }\n+\n+    private void validateLineNumbers(final String lineSeparator) throws IOException {\n+        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        assertEquals(0, parser.getCurrentLineNumber());\n+        assertNotNull(parser.nextRecord());\n+        assertEquals(1, parser.getCurrentLineNumber());\n+        assertNotNull(parser.nextRecord());\n+        assertEquals(2, parser.getCurrentLineNumber());\n+        assertNotNull(parser.nextRecord());\n+        // Still 2 because the last line is does not have EOL chars\n+        assertEquals(2, parser.getCurrentLineNumber());\n+        assertNull(parser.nextRecord());\n+        // Still 2 because the last line is does not have EOL chars\n+        assertEquals(2, parser.getCurrentLineNumber());\n     }\n \n     private void validateRecordNumbers(final String lineSeparator) throws IOException {\n         assertEquals(3, parser.getRecordNumber());\n     }\n \n-    private void validateLineNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n-        assertEquals(0, parser.getCurrentLineNumber());\n-        assertNotNull(parser.nextRecord());\n-        assertEquals(1, parser.getCurrentLineNumber());\n-        assertNotNull(parser.nextRecord());\n-        assertEquals(2, parser.getCurrentLineNumber());\n-        assertNotNull(parser.nextRecord());\n-        // Still 2 because the last line is does not have EOL chars\n-        assertEquals(2, parser.getCurrentLineNumber());\n-        assertNull(parser.nextRecord());\n-        // Still 2 because the last line is does not have EOL chars\n-        assertEquals(2, parser.getCurrentLineNumber());\n-    }\n-\n }", "timestamp": 1395016389, "metainfo": ""}