{"sha": "58233665d03a751cbe49778b797ffd70b0eb2016", "log": "Sort methods.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n     // printing implementation\n     // ======================================================\n \n-    /**\n-     * Outputs the record separator.\n-     *\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public void println() throws IOException {\n-        out.append(format.getRecordSeparator());\n-        newRecord = true;\n+    public void close() throws IOException {\n+        if (out instanceof Closeable) {\n+            ((Closeable) out).close();\n+        }\n     }\n \n     /**\n     }\n \n     /**\n-     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n-     * characters will be escaped.\n-     *\n-     * @param values\n-     *            values to output.\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public void printRecord(final Object... values) throws IOException {\n-        for (final Object value : values) {\n-            print(value);\n-        }\n-        println();\n-    }\n-\n-    /**\n-     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n-     * characters will be escaped.\n-     *\n-     * @param values\n-     *            values to output.\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public void printRecord(final Iterable<?> values) throws IOException {\n-        for (final Object value : values) {\n-            print(value);\n-        }\n-        println();\n-    }\n-\n-    /**\n-     * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line\n-     * and occupy a least one full line. The character specified to start comments and a space will be inserted at the\n-     * beginning of each new line in the comment.\n-     * <p/>\n-     * If comments are disabled in the current CSV format this method does nothing.\n-     *\n-     * @param comment\n-     *            the comment to output\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public void printComment(final String comment) throws IOException {\n-        if (!format.isCommentingEnabled()) {\n-            return;\n-        }\n-        if (!newRecord) {\n-            println();\n-        }\n-        out.append(format.getCommentStart().charValue());\n-        out.append(SP);\n-        for (int i = 0; i < comment.length(); i++) {\n-            final char c = comment.charAt(i);\n-            switch (c) {\n-            case CR:\n-                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n-                    i++;\n-                }\n-                //$FALL-THROUGH$ break intentionally excluded.\n-            case LF:\n-                println();\n-                out.append(format.getCommentStart().charValue());\n-                out.append(SP);\n-                break;\n-            default:\n-                out.append(c);\n-                break;\n-            }\n-        }\n-        println();\n+     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n+     *\n+     * @param value\n+     *            value to be output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void print(final Object value) throws IOException {\n+        // null values are considered empty\n+        String strValue;\n+        if (value == null) {\n+            final String nullString = format.getNullString();\n+            strValue = nullString == null ? Constants.EMPTY : nullString;\n+        } else {\n+            strValue = value.toString();\n+        }\n+        this.print(value, strValue, 0, strValue.length());\n     }\n \n     private void print(final Object object, final CharSequence value,\n     }\n \n     /**\n-     * Prints the string as the next value on the line. The value will be escaped or encapsulated as needed.\n-     *\n-     * @param value\n-     *            value to be output.\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public void print(final Object value) throws IOException {\n-        // null values are considered empty\n-        String strValue;\n-        if (value == null) {\n-            final String nullString = format.getNullString();\n-            strValue = nullString == null ? Constants.EMPTY : nullString;\n-        } else {\n-            strValue = value.toString();\n-        }\n-        this.print(value, strValue, 0, strValue.length());\n+     * Prints a comment on a new line among the delimiter separated values. Comments will always begin on a new line\n+     * and occupy a least one full line. The character specified to start comments and a space will be inserted at the\n+     * beginning of each new line in the comment.\n+     * <p/>\n+     * If comments are disabled in the current CSV format this method does nothing.\n+     *\n+     * @param comment\n+     *            the comment to output\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printComment(final String comment) throws IOException {\n+        if (!format.isCommentingEnabled()) {\n+            return;\n+        }\n+        if (!newRecord) {\n+            println();\n+        }\n+        out.append(format.getCommentStart().charValue());\n+        out.append(SP);\n+        for (int i = 0; i < comment.length(); i++) {\n+            final char c = comment.charAt(i);\n+            switch (c) {\n+            case CR:\n+                if (i + 1 < comment.length() && comment.charAt(i + 1) == LF) {\n+                    i++;\n+                }\n+                //$FALL-THROUGH$ break intentionally excluded.\n+            case LF:\n+                println();\n+                out.append(format.getCommentStart().charValue());\n+                out.append(SP);\n+                break;\n+            default:\n+                out.append(c);\n+                break;\n+            }\n+        }\n+        println();\n+    }\n+\n+    /**\n+     * Outputs the record separator.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void println() throws IOException {\n+        out.append(format.getRecordSeparator());\n+        newRecord = true;\n+    }\n+\n+    /**\n+     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n+     * characters will be escaped.\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printRecord(final Iterable<?> values) throws IOException {\n+        for (final Object value : values) {\n+            print(value);\n+        }\n+        println();\n+    }\n+\n+    /**\n+     * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n+     * characters will be escaped.\n+     *\n+     * @param values\n+     *            values to output.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printRecord(final Object... values) throws IOException {\n+        for (final Object value : values) {\n+            print(value);\n+        }\n+        println();\n+    }\n+\n+    /**\n+     * Prints all the objects in the given collection.\n+     *\n+     * @param values\n+     *            the values to print.\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    public void printRecords(final Iterable<?> values) throws IOException {\n+        for (final Object value : values) {\n+            if (value instanceof Object[]) {\n+                this.printRecord((Object[]) value);\n+            } else if (value instanceof Iterable) {\n+                this.printRecord((Iterable<?>) value);\n+            } else {\n+                this.printRecord(value);\n+            }\n+        }\n     }\n \n     /**\n     }\n \n     /**\n-     * Prints all the objects in the given collection.\n-     *\n-     * @param values\n-     *            the values to print.\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public void printRecords(final Iterable<?> values) throws IOException {\n-        for (final Object value : values) {\n-            if (value instanceof Object[]) {\n-                this.printRecord((Object[]) value);\n-            } else if (value instanceof Iterable) {\n-                this.printRecord((Iterable<?>) value);\n-            } else {\n-                this.printRecord(value);\n-            }\n-        }\n-    }\n-\n-    /**\n      * Prints all the objects in the given JDBC result set.\n      *\n      * @param resultSet result set\n             println();\n         }\n     }\n-\n-    public void close() throws IOException {\n-        if (out instanceof Closeable) {\n-            ((Closeable) out).close();\n-        }\n-    }\n }", "timestamp": 1390404322, "metainfo": ""}