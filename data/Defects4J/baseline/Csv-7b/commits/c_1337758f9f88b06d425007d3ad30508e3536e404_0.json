{"sha": "1337758f9f88b06d425007d3ad30508e3536e404", "log": "Use super-class rather than specific implementation  ", "commit": "\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n \n public class CSVLexerTest {\n     \n-    private CSVLexer getLexer(String input, CSVFormat format) {\n+    private Lexer getLexer(String input, CSVFormat format) {\n         return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));\n     }\n \n     @Test\n     public void testNextToken1() throws IOException {\n         String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n+        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n         assertTokenEquals(TOKEN, \"abc\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"def\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"hijk\", parser.nextToken(new Token()));\n         String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n         \n-        CSVLexer parser = getLexer(code, format);\n+        Lexer parser = getLexer(code, format);\n \n \n         assertTokenEquals(TOKEN, \"1\", parser.nextToken(new Token()));\n         */\n         String code = \"a,\\\\,,b\\n\\\\,,\";\n         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n-        CSVLexer parser = getLexer(code, format);\n+        Lexer parser = getLexer(code, format);\n \n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         // an unquoted single backslash is not an escape char\n         *        a,  \" foo \" ,b\n         */\n         String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n+        Lexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n     @Test\n     public void testNextToken5() throws IOException {\n         String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n-        CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        Lexer parser = getLexer(code, CSVFormat.DEFAULT);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\\n\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n         */\n         String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n         CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withEncapsulator('\\'').withCommentStart('!');\n-        CSVLexer parser = getLexer(code, format);\n+        Lexer parser = getLexer(code, format);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b and ' more\\n\", parser.nextToken(new Token()));\n     }\n     @Test\n     public void testDelimiterIsWhitespace() throws IOException {\n         String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-        CSVLexer parser = getLexer(code, CSVFormat.TDF);\n+        Lexer parser = getLexer(code, CSVFormat.TDF);\n         assertTokenEquals(TOKEN, \"one\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"two\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"\", parser.nextToken(new Token()));", "timestamp": 1332889808, "metainfo": ""}