{"sha": "086f434320e68a82ce1adcac69668ffcd7f48e52", "log": "SANDBOX-206: fix whitespace handling w/ escaping, add an option to not remove trailing whitespace  ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n    * @throws IOException on stream access error\n    */\n   private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n-    wsBuf.clear();\n     for (;;) {\n       if (isEndOfLine(c)) {\n         // end of record\n         tkn.type = TT_EORECORD;\n         tkn.isReady = true;\n-        return tkn;\n+        break;\n       } else if (isEndOfFile(c)) {\n         // end of file\n         tkn.type = TT_EOF;\n         tkn.isReady = true;\n-        return tkn;\n+        break;\n       } else if (c == strategy.getDelimiter()) {\n         // end of token\n         tkn.type = TT_TOKEN;\n         tkn.isReady = true;\n-        return tkn;\n+        break;\n       } else if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n         // interpret unicode escaped chars (like \\u0070 -> p)\n         tkn.content.append((char) unicodeEscapeLexer(c));\n-      } else if (isWhitespace(c)) {\n-        // gather whitespaces \n-        // (as long as they are not at the beginning of a token)\n-        if (tkn.content.length() > 0) {\n-          wsBuf.append((char) c);\n-        }\n       } else if (c == strategy.getEscape()) {\n         tkn.content.append((char)readEscape(c));\n       } else {\n-        // prepend whitespaces (if we have)\n-        if (wsBuf.length() > 0) {\n-          tkn.content.append(wsBuf);\n-          wsBuf.clear();\n-        }\n         tkn.content.append((char) c);\n       }\n-      // get the next char\n-      if (!tkn.isReady) {\n-        c = in.read();\n-      }\n-    }\n+      \n+      c = in.read();\n+    }\n+\n+    if (strategy.getIgnoreTrailingWhitespaces()) {\n+      tkn.content.trimTrailingWhitespace();\n+    }\n+\n+    return tkn;\n   }\n   \n   \n--- a/src/java/org/apache/commons/csv/CSVStrategy.java\n+++ b/src/java/org/apache/commons/csv/CSVStrategy.java\n     private char commentStart;\n     private char escape;\n     private boolean ignoreLeadingWhitespaces;\n+    private boolean ignoreTrailingWhitespaces;\n     private boolean interpretUnicodeEscapes;\n     private boolean ignoreEmptyLines;\n \n     public static char COMMENTS_DISABLED       = (char)-2;\n     public static char ESCAPE_DISABLED         = (char)-2;\n \n-    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true,  false, true);\n-    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, false, false);\n-    public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\t', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true,  false, true);\n+    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, true,  false, true);\n+    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, false, false, false);\n+    public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\t', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, true,  false, true);\n \n \n     public CSVStrategy(char delimiter, char encapsulator, char commentStart) {\n         char commentStart,\n         char escape,\n         boolean ignoreLeadingWhitespace, \n+        boolean ignoreTrailingWhitespace, \n         boolean interpretUnicodeEscapes,\n         boolean ignoreEmptyLines) \n     {\n         setCommentStart(commentStart);\n         setEscape(escape);\n         setIgnoreLeadingWhitespaces(ignoreLeadingWhitespace);\n+        setIgnoreTrailingWhitespaces(ignoreTrailingWhitespace);\n         setUnicodeEscapeInterpretation(interpretUnicodeEscapes);\n         setIgnoreEmptyLines(ignoreEmptyLines);\n     }\n         boolean interpretUnicodeEscapes,\n         boolean ignoreEmptyLines)\n     {\n-        this(delimiter,encapsulator,commentStart,CSVStrategy.ESCAPE_DISABLED,ignoreLeadingWhitespace,interpretUnicodeEscapes,ignoreEmptyLines);\n+        this(delimiter,encapsulator,commentStart,CSVStrategy.ESCAPE_DISABLED,ignoreLeadingWhitespace,true,interpretUnicodeEscapes,ignoreEmptyLines);\n     }\n \n \n     public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) { this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces; }\n     public boolean getIgnoreLeadingWhitespaces() { return this.ignoreLeadingWhitespaces; }\n \n+    public void setIgnoreTrailingWhitespaces(boolean ignoreTrailingWhitespaces) { this.ignoreTrailingWhitespaces = ignoreTrailingWhitespaces; }\n+    public boolean getIgnoreTrailingWhitespaces() { return this.ignoreTrailingWhitespaces; }\n+\n     public void setUnicodeEscapeInterpretation(boolean interpretUnicodeEscapes) { this.interpretUnicodeEscapes = interpretUnicodeEscapes; }\n     public boolean getUnicodeEscapeInterpretation() { return this.interpretUnicodeEscapes; }\n \n--- a/src/java/org/apache/commons/csv/CharBuffer.java\n+++ b/src/java/org/apache/commons/csv/CharBuffer.java\n  * grows as necessary.\n  * This class is not thread safe.\n  * \n- * @author Ortwin Glck\n+ * @author Ortwin Gl\ufffdck\n  */\n public class CharBuffer {\n     private char[] c;\n     public int length() {\n         return length;\n     }\n-    \n+\n     /**\n      * Returns the current capacity of the buffer.\n      * @return the maximum number of characters that can be stored in this buffer without\n     public int capacity() {\n         return c.length;\n     }\n+\n     \n     /**\n      * Appends the contents of <code>cb</code> to the end of this CharBuffer.\n         char[] newc = new char[length];\n         System.arraycopy(c, 0, newc, 0, length);\n         c = newc;\n+    }\n+\n+   /**\n+    * Removes trailing whitespace.\n+    */\n+    public void trimTrailingWhitespace() {\n+      while (length>0 && Character.isWhitespace(c[length-1])) {\n+        length--;\n+      }\n     }\n \n     /**\n         System.arraycopy(c, 0, chars, 0, length);\n         return chars;\n     }\n-    \n+\n+   /**\n+    * Returns the character at the specified position.\n+    */\n+    public char charAt(int pos) {\n+      return c[pos];\n+   }\n+\n     /**\n      * Converts the contents of the buffer into a StringBuffer.\n      * This method involves copying the new data once!\n--- a/src/test/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/org/apache/commons/csv/CSVParserTest.java\n       + \"/,,/,\\n\"       // 5) separator escaped\n       + \"//,//\\n\"       // 6) escape escaped\n       + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n+      + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n+      + \"9,   /\\n   \\n\"  // escaped newline\n       + \"\";\n     String[][] res = {\n         { \"one\", \"two\", \"three\" }, // 0\n         { \",\", \",\" },              // 5\n         { \"/\", \"/\" },              // 6\n         { \"/\", \"/\" },              // 7\n+        { \"   8   \", \"   \\\"quoted \\\"\\\" \\\" / string\\\"   \" },\n+        { \"9\", \"   \\n   \" },\n       };\n \n \n-    CSVStrategy strategy = new CSVStrategy(',','\\'',CSVStrategy.COMMENTS_DISABLED,'/',true,true,true);\n+    CSVStrategy strategy = new CSVStrategy(',','\\'',CSVStrategy.COMMENTS_DISABLED,'/',false,false,true,true);\n \n     CSVParser parser = new CSVParser(new StringReader(code), strategy);\n     System.out.println(\"---------\\n\" + code + \"\\n-------------\");\n       assertTrue(Arrays.equals(res[i], tmp[i]));\n     }\n   }\n+\n \n \n     public void testUnicodeEscape() throws IOException {", "timestamp": 1199632389, "metainfo": ""}