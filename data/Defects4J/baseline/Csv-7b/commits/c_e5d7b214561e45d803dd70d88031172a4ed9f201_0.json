{"sha": "e5d7b214561e45d803dd70d88031172a4ed9f201", "log": "Checkstyle: trailing spaces  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      *            <tt>true</tt> when the parser should skip empty lines\n      * @param recordSeparator\n      *            the line separator to use for output\n-     * @param nullToString \n+     * @param nullToString\n      *            the String to use to write <code>null</code> values.\n      * @param header\n      *            the header\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n         } else {\n             out.append(value, offset, offset + len);\n         }\n-        newRecord = false;        \n+        newRecord = false;\n     }\n \n     /*\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n      * The current character must be the escape character.\n      * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n      * on the input stream.\n-     * \n-     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid. \n-     * @throws IOException if there is a problem reading the stream or the end of stream is detected: \n+     *\n+     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.\n+     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n      * the escape character is not allowed at end of strem\n      */\n     int readEscape() throws IOException {\n     boolean isCommentStart(final int c) {\n         return c == commmentStart;\n     }\n-    \n+\n     private boolean isMetaChar(final int c) {\n         return c == delimiter\n             || c == escape\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n          // first line starts with csv data file name\n         final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n         final CSVFormatBuilder builder = CSVFormat.newBuilder(',').withQuoteChar('\"');\n-        CSVFormat format = builder.build(); \n+        CSVFormat format = builder.build();\n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n--- a/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n import org.junit.Test;\n \n /**\n- * \n- * \n+ *\n+ *\n  * @version $Id$\n  */\n public class CSVFormatBuilderTest {\n     public void testCommentStart() {\n         assertEquals('?', builder.withCommentStart('?').build().getCommentStart().charValue());\n     }\n-    \n+\n     @Test\n     public void testCopiedFormatIsEqualToOriginal() {\n         final CSVFormat copyOfRCF4180 = CSVFormat.newBuilder(RFC4180).build();\n         final CSVFormat newFormat2 = RFC4180.toBuilder().withDelimiter('!').build();\n         assertTrue(newFormat2.getDelimiter() != RFC4180.getDelimiter());\n     }\n-    \n+\n     @Test\n     public void testDelimiter() {\n         assertEquals('?', builder.withDelimiter('?').build().getDelimiter());\n     }\n-    \n+\n     @Test(expected = IllegalStateException.class)\n     public void testDelimiterSameAsCommentStartThrowsException() {\n         builder.withDelimiter('!').withCommentStart('!').build();\n     public void testEscape() {\n         assertEquals('?', builder.withEscape('?').build().getEscape().charValue());\n     }\n-    \n+\n     @Test(expected = IllegalStateException.class)\n     public void testEscapeSameAsCommentStartThrowsException() {\n         builder.withEscape('!').withCommentStart('!').build();\n     public void testHeaderReferenceCannotEscape() {\n         final String[] header = new String[]{\"one\", \"tow\", \"three\"};\n         builder.withHeader(header);\n-        \n+\n         final CSVFormat firstFormat = builder.build();\n         final CSVFormat secondFormat = builder.build();\n         assertNotSame(header, firstFormat.getHeader());\n     public void testIgnoreSurroundingSpaces() {\n         assertFalse(builder.withIgnoreSurroundingSpaces(false).build().getIgnoreSurroundingSpaces());\n     }\n-    \n+\n     @Test(expected = IllegalArgumentException.class)\n     public void testNewFormatCRThrowsException() {\n         CSVFormat.newBuilder(CR);\n     public void testNewFormatLFThrowsException() {\n         CSVFormat.newBuilder(LF);\n     }\n-    \n+\n     @Test\n     public void testQuoteChar() {\n         assertEquals('?', builder.withQuoteChar('?').build().getQuoteChar().charValue());\n     public void testQuoteCharSameAsCommentStartThrowsException() {\n         builder.withQuoteChar('!').withCommentStart('!').build();\n     }\n-    \n+\n     @Test(expected = IllegalStateException.class)\n     public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n         // Cannot assume that callers won't use different Character objects\n     public void testRecoardSeparator() {\n         assertEquals(\"?\", builder.withRecordSeparator(\"?\").build().getRecordSeparator());\n     }\n-    \n+\n     @Test\n     public void testRFC4180() {\n         assertEquals(null, RFC4180.getCommentStart());\n         assertEquals(null, RFC4180.getQuotePolicy());\n         assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\n     }\n-    \n+\n     @Test(expected = IllegalArgumentException.class)\n     public void testWithCommentStartCRThrowsException() {\n         builder.withCommentStart(CR).build();\n     public void testWithEscapeCRThrowsExceptions() {\n         builder.withEscape(CR).build();\n     }\n-    \n+\n     @Test(expected = IllegalArgumentException.class)\n     public void testWithQuoteLFThrowsException() {\n         builder.withQuoteChar(LF).build();\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n import org.junit.Test;\n \n /**\n- * \n- * \n+ *\n+ *\n  * @version $Id$\n  */\n public class CSVFormatTest {\n         assertEquals(\"trim\", CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces());\n         assertEquals(\"empty lines\", CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines());\n     }\n-    \n+\n     @Test\n     public void testEquals() {\n         final CSVFormat right = CSVFormat.DEFAULT;\n         assertEquals(right, right);\n         assertEquals(right, left);\n         assertEquals(left, right);\n-        \n+\n         assertEquals(right.hashCode(), right.hashCode());\n         assertEquals(right.hashCode(), left.hashCode());\n     }\n         final CSVFormat left = CSVFormat.newBuilder(right)\n                 .withHeader(\"Three\", \"Two\", \"One\")\n                 .build();\n-        \n+\n         assertNotEquals(right, left);\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n import java.io.IOException;\n \n /**\n- * \n- * \n+ *\n+ *\n  * @version $Id$\n  */\n class CSVLexer1 extends Lexer {\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n import java.io.IOException;\n \n /**\n- * \n- * \n+ *\n+ *\n  * @version $Id$\n  */\n class CSVLexer1306663 extends Lexer {\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n import java.io.IOException;\n \n /**\n- * \n- * \n+ *\n+ *\n  * @version $Id$\n  */\n class CSVLexer1306667 extends Lexer {\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n import org.junit.Test;\n \n /**\n- * \n- * \n+ *\n+ *\n  * @version $Id$\n  */\n public class CSVPrinterTest {\n--- a/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n import org.junit.Test;\n \n /**\n- * \n- * \n+ *\n+ *\n  * @version $Id$\n  */\n public class ExtendedBufferedReaderTest {\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n             final InputStream input = new GZIPInputStream(new FileInputStream(\"src/test/resources/perf/worldcitiespop.txt.gz\"));\n             final OutputStream output = new FileOutputStream(BIG_FILE);\n             IOUtils.copy(input, output);\n-            System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));            \n+            System.out.println(String.format(\"Decompressed test fixture %s: %,d bytes.\", BIG_FILE, BIG_FILE.length()));\n         }\n         final int argc = args.length;\n         String tests[];\n--- a/src/test/java/org/apache/commons/csv/Utils.java\n+++ b/src/test/java/org/apache/commons/csv/Utils.java\n \n /**\n  * Utility methods for test cases\n- * \n+ *\n  * @version $Id$\n  */\n public class Utils {\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n \n /**\n  * Tests performance.\n- * \n+ *\n  * To run this test, use: mvn test -Dtest=PeformanceTest\n- * \n+ *\n  * @version $Id$\n  */\n public class PerformanceTest {", "timestamp": 1369333043, "metainfo": ""}