{"sha": "7b168ebbbe06468b380e6f3e25c3448df9f748b3", "log": "Merge Lexer with CSVLexer  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n \n package org.apache.commons.csv;\n \n+import static org.apache.commons.csv.Constants.BACKSPACE;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.END_OF_STREAM;\n+import static org.apache.commons.csv.Constants.FF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.TAB;\n+import static org.apache.commons.csv.Constants.UNDEFINED;\n import static org.apache.commons.csv.Token.Type.COMMENT;\n import static org.apache.commons.csv.Token.Type.EOF;\n import static org.apache.commons.csv.Token.Type.EORECORD;\n  *\n  * @version $Id$\n  */\n-final class CSVLexer extends Lexer {\n+final class CSVLexer {\n+\n+    /**\n+     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n+     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n+     * chars (using surrogates) and thus there should never be a collision with a real text char.\n+     */\n+    private static final char DISABLED = '\\ufffe';\n+\n+    private final char delimiter;\n+    private final char escape;\n+    private final char quoteChar;\n+    private final char commmentStart;\n+\n+    final boolean ignoreSurroundingSpaces;\n+    final boolean ignoreEmptyLines;\n+\n+    final CSVFormat format;\n+\n+    /** The input stream */\n+    final ExtendedBufferedReader in;\n \n     /** INTERNAL API. ctor needs to be public so can be called dynamically by PerformanceTest class */\n     CSVLexer(final CSVFormat format, final ExtendedBufferedReader in) {\n-        super(format, in);\n+        this.format = format;\n+        this.in = in;\n+        this.delimiter = format.getDelimiter();\n+        this.escape = mapNullToDisabled(format.getEscape());\n+        this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n+        this.commmentStart = mapNullToDisabled(format.getCommentStart());\n+        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n+        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n     }\n \n     /**\n      * @throws java.io.IOException\n      *             on stream access error\n      */\n-    @Override\n     Token nextToken(final Token token) throws IOException {\n \n         // get the last read char (required for empty line detection)\n         }\n     }\n \n+    private final char mapNullToDisabled(final Character c) {\n+        return c == null ? DISABLED : c.charValue();\n+    }\n+\n+    /**\n+     * Returns the current line number\n+     *\n+     * @return the current line number\n+     */\n+    long getCurrentLineNumber() {\n+        return in.getCurrentLineNumber();\n+    }\n+\n+    // TODO escape handling needs more work\n+    /**\n+     * Handle an escape sequence.\n+     * The current character must be the escape character.\n+     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n+     * on the input stream.\n+     *\n+     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.\n+     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n+     * the escape character is not allowed at end of strem\n+     */\n+    int readEscape() throws IOException {\n+        // the escape char has just been read (normally a backslash)\n+        final int ch = in.read();\n+        switch (ch) {\n+        case 'r':\n+            return CR;\n+        case 'n':\n+            return LF;\n+        case 't':\n+            return TAB;\n+        case 'b':\n+            return BACKSPACE;\n+        case 'f':\n+            return FF;\n+        case CR:\n+        case LF:\n+        case FF: // TODO is this correct?\n+        case TAB: // TODO is this correct? Do tabs need to be escaped?\n+        case BACKSPACE: // TODO is this correct?\n+            return ch;\n+        case END_OF_STREAM:\n+            throw new IOException(\"EOF whilst processing escape sequence\");\n+        default:\n+            // Now check for meta-characters\n+            if (isMetaChar(ch)) {\n+                return ch;\n+            }\n+            // indicate unexpected char - available from in.getLastChar()\n+            return END_OF_STREAM;\n+        }\n+    }\n+\n+    void trimTrailingSpaces(final StringBuilder buffer) {\n+        int length = buffer.length();\n+        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n+            length = length - 1;\n+        }\n+        if (length != buffer.length()) {\n+            buffer.setLength(length);\n+        }\n+    }\n+\n+    /**\n+     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n+     *\n+     * @return true if the given or next character is a line-terminator\n+     */\n+    boolean readEndOfLine(int ch) throws IOException {\n+        // check if we have \\r\\n...\n+        if (ch == CR && in.lookAhead() == LF) {\n+            // note: does not change ch outside of this method!\n+            ch = in.read();\n+        }\n+        return ch == LF || ch == CR;\n+    }\n+\n+    boolean isClosed() {\n+        return in.isClosed();\n+    }\n+\n+    /**\n+     * @return true if the given char is a whitespace character\n+     */\n+    boolean isWhitespace(final int ch) {\n+        return !isDelimiter(ch) && Character.isWhitespace((char) ch);\n+    }\n+\n+    /**\n+     * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n+     *\n+     * @param ch the character to check\n+     * @return true if the character is at the start of a line.\n+     */\n+    boolean isStartOfLine(final int ch) {\n+        return ch == LF || ch == CR || ch == UNDEFINED;\n+    }\n+\n+    /**\n+     * @return true if the given character indicates end of file\n+     */\n+    boolean isEndOfFile(final int ch) {\n+        return ch == END_OF_STREAM;\n+    }\n+\n+    boolean isDelimiter(final int ch) {\n+        return ch == delimiter;\n+    }\n+\n+    boolean isEscape(final int ch) {\n+        return ch == escape;\n+    }\n+\n+    boolean isQuoteChar(final int ch) {\n+        return ch == quoteChar;\n+    }\n+\n+    boolean isCommentStart(final int ch) {\n+        return ch == commmentStart;\n+    }\n+\n+    private boolean isMetaChar(final int ch) {\n+        return ch == delimiter ||\n+               ch == escape ||\n+               ch == quoteChar ||\n+               ch == commmentStart;\n+    }\n+\n+    /**\n+     * Closes resources.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    void close() throws IOException {\n+        in.close();\n+    }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     private final CSVFormat format;\n     private final Map<String, Integer> headerMap;\n \n-    private final Lexer lexer;\n+    private final CSVLexer lexer;\n \n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n         formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n     }\n \n-    private Lexer getLexer(final String input, final CSVFormat format) {\n+    private CSVLexer getLexer(final String input, final CSVFormat format) {\n         return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));\n     }\n \n     @Test\n     public void testSurroundingSpacesAreDeleted() throws IOException {\n         final String code = \"noSpaces,  leadingSpaces,trailingSpaces  ,  surroundingSpaces  ,  ,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n     @Test\n     public void testSurroundingTabsAreDeleted() throws IOException {\n         final String code = \"noTabs,\\tleadingTab,trailingTab\\t,\\tsurroundingTabs\\t,\\t\\t,,\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noTabs\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n                 \"\\n\"+\n                 \"\\n\";\n         final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines(true);\n-        final Lexer parser = getLexer(code, format);\n+        final CSVLexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n                 \"# penultimate comment\\n\"+\n                 \"# Final comment\\n\";\n         final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n-        final Lexer parser = getLexer(code, format);\n+        final CSVLexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n         final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n         assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n-        final Lexer parser = getLexer(code, format);\n+        final CSVLexer parser = getLexer(code, format);\n \n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"1\"));\n         final String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n         final CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isEscaping());\n-        final Lexer parser = getLexer(code, format);\n+        final CSVLexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         // an unquoted single backslash is not an escape char\n         final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n         final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n         assertTrue(format.isEscaping());\n-        final Lexer parser = getLexer(code, format);\n+        final CSVLexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n         *        a,  \" foo \" ,b\n         */\n         final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n     @Test\n     public void testNextToken5() throws IOException {\n         final String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\\n\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n         final CSVFormat format = CSVFormat.DEFAULT.withQuoteChar('\\'').withCommentStart('!').withDelimiter(';');\n-        final Lexer parser = getLexer(code, format);\n+        final CSVLexer parser = getLexer(code, format);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));\n     }\n     @Test\n     public void testDelimiterIsWhitespace() throws IOException {\n         final String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-        final Lexer parser = getLexer(code, CSVFormat.TDF);\n+        final CSVLexer parser = getLexer(code, CSVFormat.TDF);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"one\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"two\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n \n     @Test\n     public void testEscapedCR() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test\n     public void testCR() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n     }\n \n     @Test\n     public void testEscapedLF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + LF + \"Escaped\"));\n     }\n \n     @Test\n     public void testLF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>TAB to be unescaped?\n     public void testEscapedTab() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"Escaped\"));\n     }\n \n     @Test\n     public void testTab() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"NotEscaped\"));\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>BACKSPACE to be unescaped?\n     public void testEscapedBackspace() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"Escaped\"));\n     }\n \n     @Test\n     public void testBackspace() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"NotEscaped\"));\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>FF to be unescaped?\n     public void testEscapedFF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"Escaped\"));\n     }\n \n     @Test\n     public void testFF() throws Exception {\n-        final Lexer lexer = getLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"NotEscaped\"));\n     }\n \n     @Test\n     public void testEscapedMySqlNullValue() throws Exception {\n         // MySQL uses \\N to symbolize null values. We have to restore this\n-        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n     }\n \n     @Test\n     public void testEscapedCharacter() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n+        final CSVLexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n     }\n \n     @Test\n     public void testEscapedControlCharacter() throws Exception {\n         // we are explicitly using an escape different from \\ here\n-        final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'));\n+        final CSVLexer lexer = getLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapedControlCharacter2() throws Exception {\n-        final Lexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'));\n+        final CSVLexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test(expected = IOException.class)\n     public void testEscapingAtEOF() throws Exception {\n         final String code = \"escaping at EOF is evil\\\\\";\n-        final Lexer lexer = getLexer(code, formatWithEscaping);\n+        final CSVLexer lexer = getLexer(code, formatWithEscaping);\n \n         lexer.nextToken(new Token());\n     }\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n    }\n \n \n-   private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\n+   private static Constructor<CSVLexer> getLexerCtor(final String clazz) throws Exception {\n        @SuppressWarnings(\"unchecked\")\n-       final Class<Lexer> lexer = (Class<Lexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\n+       final Class<CSVLexer> lexer = (Class<CSVLexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\n        return lexer.getConstructor(new Class<?>[]{CSVFormat.class, ExtendedBufferedReader.class});\n    }\n \n        String dynamic = \"\";\n        for (int i = 0; i < max; i++) {\n            final ExtendedBufferedReader input = new ExtendedBufferedReader(getReader());\n-           Lexer lexer = null;\n+           CSVLexer lexer = null;\n            if (test.startsWith(\"CSVLexer\")) {\n                dynamic=\"!\";\n                lexer = getLexerCtor(test).newInstance(new Object[]{format, input});", "timestamp": 1375803881, "metainfo": ""}