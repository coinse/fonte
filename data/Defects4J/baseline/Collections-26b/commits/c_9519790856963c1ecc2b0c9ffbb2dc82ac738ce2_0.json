{"sha": "9519790856963c1ecc2b0c9ffbb2dc82ac738ce2", "log": "Javadoc  ", "commit": "\n--- a/src/java/org/apache/commons/collections/functors/AllPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/AllPredicate.java\n      * @return the <code>all</code> predicate\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n-     * @deprecated Use {@link #allPredicate(Predicate<? super T>...)} instead\n+     * @deprecated Use {@link #allPredicate(Predicate...)} instead\n      */\n     @Deprecated\n     public static <T> Predicate<T> getInstance(Predicate<? super T> ... predicates) {\n      * @return the <code>all</code> predicate\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n-     * @deprecated Use {@link #allPredicate(Collection<Predicate<? super T>>)} instead\n+     * @deprecated Use {@link #allPredicate(Collection)} instead\n      */\n     @Deprecated\n     public static <T> Predicate<T> getInstance(Collection<Predicate<T>> predicates) {\n--- a/src/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n+++ b/src/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n \t * @param comparator  the comparator to use for comparison\n \t * @param criterion  the criterion to use to evaluate comparison\n \t * @return the predicate\n-\t * @throws IllegalArgumentexception if comparator is null of criterion is invalid\n+\t * @throws IllegalArgumentException if comparator is null of criterion is invalid\n \t */\n \tpublic static <T> Predicate<T> getInstance(T object, Comparator<T> comparator, Criterion criterion) {\n         if (comparator == null) {\n \t * </ul>\n \t * \n \t * @see org.apache.commons.collections.Predicate#evaluate(java.lang.Object)\n-\t * @see java.util.Comparator.compare(java.lang.Object first, java.lang.Object second)\n+\t * @see java.util.Comparator#compare(java.lang.Object first, java.lang.Object second)\n \t * \n \t * @throws IllegalStateException if the criterion is invalid (really not possible)\n \t */\n--- a/src/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n+++ b/src/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      */\n     public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n      * specified reference types, load factor and initial capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      */\n      * specified reference types, load factor and initial capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      * @param purgeValues  should the value be automatically purged when the \n--- a/src/java/org/apache/commons/collections/map/ReferenceMap.java\n+++ b/src/java/org/apache/commons/collections/map/ReferenceMap.java\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      */\n     public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n      * use the specified types of references.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n      * capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      */\n      * capacity.\n      *\n      * @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      * @param purgeValues  should the value be automatically purged when the \n--- a/src/test/org/apache/commons/collections/AbstractTestLinkedList.java\n+++ b/src/test/org/apache/commons/collections/AbstractTestLinkedList.java\n  * Tests base {@link java.util.LinkedList} methods and contracts.\n  * <p>\n  * To use, simply extend this class, and implement\n- * the {@link #makeEmptyLinkedList()} method.\n+ * the {@link #makeObject()} method.\n  * <p>\n  * If your {@link LinkedList} fails one of these tests by design,\n  * you may still use this base set of cases.  Simply override the\n--- a/src/test/org/apache/commons/collections/bag/AbstractTestBag.java\n+++ b/src/test/org/apache/commons/collections/bag/AbstractTestBag.java\n  * Abstract test class for {@link org.apache.commons.collections.Bag Bag} methods and contracts.\n  * <p>\n  * To use, simply extend this class, and implement\n- * the {@link #makeBag} method.\n+ * the {@link #makeObject} method.\n  * <p>\n  * If your bag fails one of these tests by design,\n  * you may still use this base set of cases.  Simply override the\n--- a/src/test/org/apache/commons/collections/list/AbstractTestList.java\n+++ b/src/test/org/apache/commons/collections/list/AbstractTestList.java\n  * Abstract test class for {@link java.util.List} methods and contracts.\n  * <p>\n  * To use, simply extend this class, and implement\n- * the {@link #makeEmptyList} method.\n+ * the {@link #makeObject} method.\n  * <p>\n  * If your {@link List} fails one of these tests by design,\n  * you may still use this base set of cases.  Simply override the\n     //-----------------------------------------------------------------------\n     /**\n      *  Returns true if the collections produced by\n-     *  {@link #makeCollection()} and {@link #makeFullCollection()}\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n      *  support the <code>set operation.<p>\n      *  Default implementation returns true.  Override if your collection\n      *  class does not support set.\n     }\n \n     /**\n-     * Returns {@link #makeEmptyList()}.\n+     * Returns {@link #makeObject()}.\n      *\n      * @return an empty list to be used for testing\n      */\n--- a/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n+++ b/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n  * The forces at work here are similar to those in {@link AbstractTestCollection}.\n  * If your class implements the full Map interface, including optional\n  * operations, simply extend this class, and implement the\n- * {@link #makeEmptyMap()} method.\n+ * {@link #makeObject()} method.\n  * <p>\n  * On the other hand, if your map implementation is weird, you may have to\n  * override one or more of the other protected methods.  They're described\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * support the <code>put</code> and <code>putAll</code> operations\n      * adding new mappings.\n      * <p>\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * support the <code>put</code> and <code>putAll</code> operations\n      * changing existing mappings.\n      * <p>\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * support the <code>setValue</code> operation on entrySet entries.\n      * <p>\n      * Default implementation returns isPutChangeSupported().\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * support the <code>remove</code> and <code>clear</code> operations.\n      * <p>\n      * Default implementation returns true.\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * can cause structural modification on a get(). The example is LRUMap.\n      * <p>\n      * Default implementation returns false.\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * supports null keys.\n      * <p>\n      * Default implementation returns true.\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * supports null values.\n      * <p>\n      * Default implementation returns true.\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * supports duplicate values.\n      * <p>\n      * Default implementation returns true.\n \n     /**\n      * Returns true if the maps produced by\n-     * {@link #makeEmptyMap()} and {@link #makeFullMap()}\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n      * provide fail-fast behavior on their various iterators.\n      * <p>\n      * Default implementation returns true.", "timestamp": 1287405801, "metainfo": ""}