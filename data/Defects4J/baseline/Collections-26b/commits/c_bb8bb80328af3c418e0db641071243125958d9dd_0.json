{"sha": "bb8bb80328af3c418e0db641071243125958d9dd", "log": "[COLLECTIONS-404] moved to comparators.sequence package, cleanup.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/CommandVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+/** \n+ * This interface should be implemented by user object to walk\n+ * through {@link EditScript EditScript} objects.\n+ * <p>\n+ * Users should implement this interface in order to walk through\n+ * the {@link EditScript EditScript} object created by the comparison\n+ * of two sequences. This is a direct application of the visitor\n+ * design pattern. The {@link EditScript#visit EditScript.visit}\n+ * method takes an object implementing this interface as an argument,\n+ * it will perform the loop over all commands in the script and the\n+ * proper methods of the user class will be called as the commands are\n+ * encountered.\n+ * <p>\n+ * The implementation of the user visitor class will depend on the\n+ * need. Here are two examples.\n+ * <p>\n+ * The first example is a visitor that build the longest common\n+ * subsequence:\n+ * <pre>\n+ * import org.apache.commons.collections.list.difference.CommandVisitor;\n+ * \n+ * import java.util.ArrayList;\n+ *\n+ * public class LongestCommonSubSequence implements CommandVisitor {\n+ * \n+ *   public LongestCommonSubSequence() {\n+ *     a = new ArrayList();\n+ *   }\n+ * \n+ *   public void visitInsertCommand(Object object) {\n+ *   }\n+ * \n+ *   public void visitKeepCommand(Object object) {\n+ *     a.add(object);\n+ *   }\n+ * \n+ *   public void visitDeleteCommand(Object object) {\n+ *   }\n+ * \n+ *   public Object[] getSubSequence() {\n+ *     return a.toArray();\n+ *   }\n+ * \n+ *   private arrayList a;\n+ * \n+ * }\n+ * </pre>\n+ * <p>\n+ * The second example is a visitor that shows the commands and the way\n+ * they transform the first sequence into the second one:\n+ * <pre>\n+ * import org.apache.commons.collections.list.difference.CommandVisitor;\n+ * \n+ * import java.util.Arrays;\n+ * import java.util.ArrayList;\n+ * import java.util.Iterator;\n+ *\n+ * public class ShowVisitor implements CommandVisitor {\n+ * \n+ *   public ShowVisitor(Object[] sequence1) {\n+ *     v = new ArrayList();\n+ *     v.addAll(Arrays.asList(sequence1));\n+ *     index = 0;\n+ *   }\n+ * \n+ *   public void visitInsertCommand(Object object) {\n+ *     v.insertElementAt(object, index++);\n+ *     display(\"insert\", object);\n+ *   }\n+ * \n+ *   public void visitKeepCommand(Object object) {\n+ *     ++index;\n+ *     display(\"keep  \", object);\n+ *   }\n+ * \n+ *   public void visitDeleteCommand(Object object) {\n+ *     v.remove(index);\n+ *     display(\"delete\", object);\n+ *   }\n+ * \n+ *   private void display(String commandName, Object object) {\n+ *     System.out.println(commandName + \" \" + object + \" ->\" + this);\n+ *   }\n+ * \n+ *   public String toString() {\n+ *     StringBuffer buffer = new StringBuffer();\n+ *     for (Iterator iter = v.iterator(); iter.hasNext();) {\n+ *       buffer.append(' ').append(iter.next());\n+ *     }\n+ *     return buffer.toString();\n+ *   }\n+ * \n+ *   private ArrayList v;\n+ *   private int index;\n+ * \n+ * }\n+ * </pre>\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface CommandVisitor<T> {\n+\n+    /** \n+     * Method called when an insert command is encountered.\n+     *\n+     * @param object object to insert (this object comes from the second sequence)\n+     */\n+    void visitInsertCommand(T object);\n+\n+    /** \n+     * Method called when a keep command is encountered.\n+     *\n+     * @param object object to keep (this object comes from the first sequence)\n+     */\n+    void visitKeepCommand(T object);\n+\n+    /** \n+     * Method called when a delete command is encountered.\n+     *\n+     * @param object object to delete (this object comes from the first sequence)\n+     */\n+    void visitDeleteCommand(T object);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/DeleteCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+/**\n+ * Command representing the deletion of one object of the first sequence.\n+ * <p>\n+ * When one object of the first sequence has no corresponding object in the\n+ * second sequence at the right place, the {@link EditScript edit script}\n+ * transforming the first sequence into the second sequence uses an instance of\n+ * this class to represent the deletion of this object. The objects embedded in\n+ * these type of commands always come from the first sequence.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class DeleteCommand<T> extends EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of {@link DeleteCommand}.\n+     *\n+     * @param object  the object of the first sequence that should be deleted\n+     */\n+    public DeleteCommand(T object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * Accept a visitor. When a <code>DeleteCommand</code> accepts a visitor, it calls\n+     * its {@link CommandVisitor#visitDeleteCommand visitDeleteCommand} method.\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */    \n+    @Override\n+    public void accept(CommandVisitor<T> visitor) {\n+        visitor.visitDeleteCommand(object);\n+    }    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/EditCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+/**\n+ * Abstract base class for all commands used to transform an objects sequence\n+ * into another one.\n+ * <p>\n+ * When two objects sequences are compared through the\n+ * {@link SequencesComparator#getScript SequencesComparator.getScript} method,\n+ * the result is provided has a {@link EditScript script} containing the commands\n+ * that progressively transform the first sequence into the second one.\n+ * <p>\n+ * There are only three types of commands, all of which are subclasses of this\n+ * abstract class. Each command is associated with one object belonging to at\n+ * least one of the sequences. These commands are {@link InsertCommand\n+ * InsertCommand} which correspond to an object of the second sequence being\n+ * inserted into the first sequence, {@link DeleteCommand DeleteCommand} which\n+ * correspond to an object of the first sequence being removed and\n+ * {@link KeepCommand KeepCommand} which correspond to an object of the first\n+ * sequence which <code>equals</code> an object in the second sequence. It is\n+ * guaranteed that comparison is always performed this way (i.e. the\n+ * <code>equals</code> method of the object from the first sequence is used and\n+ * the object passed as an argument comes from the second sequence) ; this can\n+ * be important if subclassing is used for some elements in the first sequence\n+ * and the <code>equals</code> method is specialized.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of EditCommand\n+     * \n+     * @param object  reference to the object associated with this command, this\n+     *   refers to an element of one of the sequences being compared\n+     */\n+    protected EditCommand(T object) {\n+        this.object = object;\n+    }\n+\n+    /**\n+     * Accept a visitor.\n+     * <p>\n+     * This method is invoked for each commands belonging to\n+     * an {@link EditScript EditScript}, in order to implement the visitor design pattern\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */\n+    public abstract void accept(CommandVisitor<T> visitor);\n+\n+    /** Object on which the command should be applied. */\n+    protected T object;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/EditScript.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class gathers all the {@link EditCommand commands} needed to transform\n+ * one objects sequence into another objects sequence.\n+ * <p>\n+ * An edit script is the most general view of the differences between two\n+ * sequences. It is built as the result of the comparison between two sequences\n+ * by the {@link SequencesComparator SequencesComparator} class. The user can\n+ * walk through it using the <em>visitor</em> design pattern.\n+ * <p>\n+ * It is guaranteed that the objects embedded in the {@link InsertCommand insert\n+ * commands} come from the second sequence and that the objects embedded in\n+ * either the {@link DeleteCommand delete commands} or {@link KeepCommand keep\n+ * commands} come from the first sequence. This can be important if subclassing\n+ * is used for some elements in the first sequence and the <code>equals</code>\n+ * method is specialized.\n+ * \n+ * @see SequencesComparator\n+ * @see EditCommand\n+ * @see CommandVisitor\n+ * @see ReplacementsHandler\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class EditScript<T> {\n+\n+    /** Container for the commands. */\n+    private List<EditCommand<T>> commands;\n+\n+    /** Length of the longest common subsequence. */\n+    private int lcsLength;\n+\n+    /** Number of modifications. */\n+    private int modifications;\n+\n+    /**\n+     * Simple constructor. Creates a new empty script.\n+     */\n+    public EditScript() {\n+        commands = new ArrayList<EditCommand<T>>();\n+        lcsLength = 0;\n+        modifications = 0;\n+    }\n+\n+    /**\n+     * Add a keep command to the script.\n+     * \n+     * @param command  command to add\n+     */\n+    public void append(KeepCommand<T> command) {\n+        commands.add(command);\n+        ++lcsLength;\n+    }\n+\n+    /**\n+     * Add an insert command to the script.\n+     * \n+     * @param command  command to add\n+     */\n+    public void append(InsertCommand<T> command) {\n+        commands.add(command);\n+        ++modifications;\n+    }\n+\n+    /**\n+     * Add a delete command to the script.\n+     * \n+     * @param command  command to add\n+     */\n+    public void append(DeleteCommand<T> command) {\n+        commands.add(command);\n+        ++modifications;\n+    }\n+\n+    /**\n+     * Visit the script. The script implements the <em>visitor</em> design\n+     * pattern, this method is the entry point to which the user supplies its\n+     * own visitor, the script will be responsible to drive it through the\n+     * commands in order and call the appropriate method as each command is\n+     * encountered.\n+     * \n+     * @param visitor  the visitor that will visit all commands in turn\n+     */\n+    public void visit(CommandVisitor<T> visitor) {\n+        for (EditCommand<T> command : commands) {\n+            command.accept(visitor);\n+        }\n+    }\n+\n+    /**\n+     * Get the length of the Longest Common Subsequence (LCS). The length of the\n+     * longest common subsequence is the number of {@link KeepCommand keep\n+     * commands} in the script.\n+     * \n+     * @return length of the Longest Common Subsequence\n+     */\n+    public int getLCSLength() {\n+        return lcsLength;\n+    }\n+\n+    /**\n+     * Get the number of effective modifications. The number of effective\n+     * modification is the number of {@link DeleteCommand delete} and\n+     * {@link InsertCommand insert} commands in the script.\n+     * \n+     * @return number of effective modifications\n+     */\n+    public int getModifications() {\n+        return modifications;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/InsertCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+/**\n+ * Command representing the insertion of one object of the second sequence.\n+ * <p>\n+ * When one object of the second sequence has no corresponding object in the\n+ * first sequence at the right place, the {@link EditScript edit script}\n+ * transforming the first sequence into the second sequence uses an instance of\n+ * this class to represent the insertion of this object. The objects embedded in\n+ * these type of commands always come from the second sequence.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class InsertCommand<T> extends EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of InsertCommand\n+     * \n+     * @param object  the object of the second sequence that should be inserted\n+     */\n+    public InsertCommand(T object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * Accept a visitor. When an <code>InsertCommand</code> accepts a visitor,\n+     * it calls its {@link CommandVisitor#visitInsertCommand visitInsertCommand}\n+     * method.\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */\n+    @Override\n+    public void accept(CommandVisitor<T> visitor) {\n+        visitor.visitInsertCommand(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/KeepCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+/**\n+ * Command representing the keeping of one object present in both sequences.\n+ * <p>\n+ * When one object of the first sequence <code>equals</code> another objects in\n+ * the second sequence at the right place, the {@link EditScript edit script}\n+ * transforming the first sequence into the second sequence uses an instance of\n+ * this class to represent the keeping of this object. The objects embedded in\n+ * these type of commands always come from the first sequence.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class KeepCommand<T> extends EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of KeepCommand\n+     * \n+     * @param object  the object belonging to both sequences (the object is a\n+     *   reference to the instance in the first sequence which is known\n+     *   to be equal to an instance in the second sequence)\n+     */\n+    public KeepCommand(T object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * Accept a visitor. When a <code>KeepCommand</code> accepts a visitor, it\n+     * calls its {@link CommandVisitor#visitKeepCommand visitKeepCommand} method.\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */\n+    @Override\n+    public void accept(CommandVisitor<T> visitor) {\n+        visitor.visitKeepCommand(object);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/ReplacementsFinder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class handles sequences of replacements resulting from a comparison.\n+ * <p>\n+ * The comparison of two objects sequences leads to the identification of common\n+ * parts and parts which only belong to the first or to the second sequence. The\n+ * common parts appear in the edit script in the form of <em>keep</em> commands,\n+ * they can be considered as synchronization objects between the two sequences.\n+ * These synchronization objects split the two sequences in synchronized\n+ * sub-sequences. The first sequence can be transformed into the second one by\n+ * replacing each synchronized sub-sequence of the first sequence by the\n+ * corresponding sub-sequence of the second sequence. This is a synthetic way to\n+ * see an {@link EditScript edit script}, replacing individual\n+ * {@link DeleteCommand delete}, {@link KeepCommand keep} and\n+ * {@link InsertCommand insert} commands by fewer replacements acting on\n+ * complete sub-sequences.\n+ * <p>\n+ * This class is devoted to perform this interpretation. It visits an\n+ * {@link EditScript edit script} (because it implements the\n+ * {@link CommandVisitor CommandVisitor} interface) and calls a user-supplied\n+ * handler implementing the {@link ReplacementsHandler ReplacementsHandler}\n+ * interface to process the sub-sequences.\n+ * \n+ * @see ReplacementsHandler\n+ * @see EditScript\n+ * @see SequencesComparator\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ReplacementsFinder<T> implements CommandVisitor<T> {\n+\n+    private List<T> pendingInsertions;\n+    private List<T> pendingDeletions;\n+    private int     skipped;\n+\n+    /** Handler to call when synchronized sequences are found. */\n+    private ReplacementsHandler<T> handler;\n+\n+    /**\n+     * Simple constructor. Creates a new instance of {@link ReplacementsFinder}.\n+     *\n+     * @param handler  handler to call when synchronized sequences are found\n+     */\n+    public ReplacementsFinder(ReplacementsHandler<T> handler) {\n+        pendingInsertions = new ArrayList<T>();\n+        pendingDeletions  = new ArrayList<T>();\n+        skipped           = 0;\n+        this.handler      = handler;\n+    }\n+\n+    /**\n+     * Add an object to the pending insertions set.\n+     *\n+     * @param object  object to insert\n+     */\n+    public void visitInsertCommand(T object) {\n+        pendingInsertions.add(object);\n+    }\n+\n+    /**\n+     * Handle a synchronization object.\n+     * <p>\n+     * When a synchronization object is identified, the pending insertions and\n+     * pending deletions sets are provided to the user handler as subsequences.\n+     *\n+     * @param object  synchronization object detected\n+     */\n+    public void visitKeepCommand(T object) {\n+        if (pendingDeletions.isEmpty() && pendingInsertions.isEmpty()) {\n+            ++skipped;\n+        } else {\n+            handler.handleReplacement(skipped, pendingDeletions, pendingInsertions);\n+            pendingDeletions.clear();\n+            pendingInsertions.clear();\n+            skipped = 1;\n+        }\n+    }\n+\n+    /**\n+     * Add an object to the pending deletions set.\n+     *\n+     * @param object  object to delete\n+     */\n+    public void visitDeleteCommand(T object) {\n+        pendingDeletions.add(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/ReplacementsHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+import java.util.List;\n+\n+/**\n+ * This interface is devoted to handle synchronized replacement sequences.\n+ * \n+ * @see ReplacementsFinder\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface ReplacementsHandler<T> {\n+\n+    /**\n+     * Handle two synchronized sequences.\n+     * <p>\n+     * This method is called by a {@link ReplacementsFinder ReplacementsFinder}\n+     * instance when it has synchronized two sub-sequences of object arrays\n+     * being compared, and at least one of the sequences is non-empty. Since the\n+     * sequences are synchronized, the objects before the two sub-sequences are\n+     * equals (if they exist). This property also holds for the objects after\n+     * the two sub-sequences.\n+     * <p>\n+     * The replacement is defined as replacing the <code>from</code>\n+     * sub-sequence into the <code>to</code> sub-sequence.\n+     * \n+     * @param skipped  number of tokens skipped since the last call (i.e. number of\n+     *   tokens that were in both sequences), this number should be strictly positive\n+     *   except on the very first call where it can be zero (if the first object of\n+     *   the two sequences are different)\n+     * @param from  sub-sequence of objects coming from the first sequence\n+     * @param to  sub-sequence of objects coming from the second sequence\n+     */\n+    public void handleReplacement(int skipped, List<T> from, List<T> to);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/SequencesComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+import java.util.List;\n+\n+/**\n+ * This class allows to compare two objects sequences.\n+ * <p>\n+ * The two sequences can hold any object type, as only the <code>equals</code>\n+ * method is used to compare the elements of the sequences. It is guaranteed\n+ * that the comparisons will always be done as <code>o1.equals(o2)</code> where\n+ * <code>o1</code> belongs to the first sequence and <code>o2</code> belongs to\n+ * the second sequence. This can be important if subclassing is used for some\n+ * elements in the first sequence and the <code>equals</code> method is\n+ * specialized.\n+ * <p>\n+ * Comparison can be seen from two points of view: either as giving the smallest\n+ * modification allowing to transform the first sequence into the second one, or\n+ * as giving the longest sequence which is a subsequence of both initial\n+ * sequences. The <code>equals</code> method is used to compare objects, so any\n+ * object can be put into sequences. Modifications include deleting, inserting\n+ * or keeping one object, starting from the beginning of the first sequence.\n+ * <p>\n+ * This class implements the comparison algorithm, which is the very efficient\n+ * algorithm from Eugene W. Myers\n+ * <a href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">\n+ * An O(ND) Difference Algorithm and Its Variations</a>. This algorithm produces\n+ * the shortest possible\n+ * {@link org.apache.commons.collections.list.difference.EditScript edit script}\n+ * containing all the\n+ * {@link org.apache.commons.collections.list.difference.EditCommand commands}\n+ * needed to transform the first sequence into the second one.\n+ * \n+ * @see EditScript\n+ * @see EditCommand\n+ * @see CommandVisitor\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class SequencesComparator<T> {\n+\n+    /** First sequence. */\n+    private List<T> sequence1;\n+\n+    /** Second sequence. */\n+    private List<T> sequence2;\n+\n+    /** Temporary variables. */\n+    private int[] vDown;\n+    private int[] vUp;\n+\n+    /**\n+     * Simple constructor.\n+     * <p>\n+     * Creates a new instance of SequencesComparator.\n+     * <p>\n+     * It is <em>guaranteed</em> that the comparisons will always be done as\n+     * <code>o1.equals(o2)</code> where <code>o1</code> belongs to the first\n+     * sequence and <code>o2</code> belongs to the second sequence. This can be\n+     * important if subclassing is used for some elements in the first sequence\n+     * and the <code>equals</code> method is specialized.\n+     * \n+     * @param sequence1\n+     *            first sequence to be compared\n+     * @param sequence2\n+     *            second sequence to be compared\n+     */\n+    public SequencesComparator(List<T> sequence1, List<T> sequence2) {\n+        this.sequence1 = sequence1;\n+        this.sequence2 = sequence2;\n+\n+        int size = sequence1.size() + sequence2.size() + 2;\n+        vDown = new int[size];\n+        vUp   = new int[size];\n+    }\n+\n+    /**\n+     * Build a snake.\n+     *\n+     * @param start  the value of the start of the snake\n+     * @param diag  the value of the diagonal of the snake\n+     * @param end1  the value of the end of the first sequence to be compared\n+     * @param end2  the value of the end of the second sequence to be compared\n+     * @return the snake built\n+     */\n+    private Snake buildSnake(int start, int diag, int end1, int end2) {\n+        int end = start;\n+        while (((end - diag) < end2)\n+                && (end < end1)\n+                && sequence1.get(end).equals(sequence2.get(end - diag))) {\n+            ++end;\n+        }\n+        return new Snake(start, end, diag);\n+    }\n+\n+    /** \n+     * Get the middle snake corresponding to two subsequences of the\n+     * main sequences.\n+     * <p>\n+     * The snake is found using the MYERS Algorithm (this algorithms has\n+     * also been implemented in the GNU diff program). This algorithm is\n+     * explained in Eugene Myers article: \n+     * <a href=\"http://www.cs.arizona.edu/people/gene/PAPERS/diff.ps\">\n+     * An O(ND) Difference Algorithm and Its Variations</a>.\n+     *\n+     * @param start1  the begin of the first sequence to be compared\n+     * @param end1  the end of the first sequence to be compared\n+     * @param start2  the begin of the second sequence to be compared\n+     * @param end2  the end of the second sequence to be compared\n+     * @return the middle snake\n+     */\n+    private Snake getMiddleSnake(int start1, int end1, int start2, int end2) {\n+        // Myers Algorithm\n+        // Initialisations\n+        int m = end1 - start1;\n+        int n = end2 - start2;\n+        if ((m == 0) || (n == 0)) {\n+            return null;\n+        }\n+\n+        int delta  = m - n;\n+        int sum    = n + m;\n+        int offset = ((sum % 2 == 0) ? sum : (sum + 1)) / 2;\n+        vDown[1+offset] = start1;\n+        vUp[1+offset]   = end1 + 1;\n+\n+        for (int d = 0; d <= offset ; ++d) {\n+            // Down\n+            for (int k = -d; k <= d; k += 2) {\n+                // First step\n+\n+                int i = k + offset;\n+                if ((k == -d) || ((k != d) && (vDown[i-1] < vDown[i+1]))) {\n+                    vDown[i] = vDown[i+1];\n+                } else {\n+                    vDown[i] = vDown[i-1] + 1;\n+                }\n+\n+                int x = vDown[i];\n+                int y = x - start1 + start2 - k;\n+\n+                while ((x < end1) && (y < end2) && (sequence1.get(x).equals(sequence2.get(y)))) {\n+                    vDown[i] = ++x;\n+                    ++y;\n+                }\n+                // Second step\n+                if (((delta % 2) != 0 ) && ((delta - d) <= k) && (k <= (delta + d))) {\n+                    if (vUp[i-delta] <= vDown[i]) {\n+                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n+                    }\n+                }\n+            }\n+\n+            // Up\n+            for (int k = (delta - d); k <= (delta + d); k += 2) {\n+                // First step\n+                int i = k + offset - delta;\n+                if ((k == (delta - d))\n+                        || ((k != (delta + d)) && (vUp[i+1] <= vUp[i-1]))) {\n+                    vUp[i] = vUp[i+1] - 1;\n+                } else {\n+                    vUp[i] = vUp[i-1];\n+                }\n+\n+                int x = vUp[i] - 1;\n+                int y = x - start1 + start2 - k;\n+                while ((x >= start1) && (y >= start2)\n+                        && sequence1.get(x).equals(sequence2.get(y))) {\n+                    vUp[i] = x--;\n+                    y--;\n+                }\n+                // Second step\n+                if (((delta % 2) == 0) && (-d <= k) && (k <= d) ) {\n+                    if (vUp[i] <= vDown[i + delta]) {\n+                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // this should not happen\n+        throw new RuntimeException(\"Internal Error\");\n+    }\n+\n+\n+    /**\n+     * Build an edit script.\n+     *\n+     * @param start1  the begin of the first sequence to be compared\n+     * @param end1  the end of the first sequence to be compared\n+     * @param start2  the begin of the second sequence to be compared\n+     * @param end2  the end of the second sequence to be compared\n+     * @param script the edited script\n+     */\n+    private void buildScript(int start1, int end1, int start2, int end2,\n+                             EditScript<T> script) {\n+\n+        Snake middle = getMiddleSnake(start1, end1, start2, end2);\n+\n+        if ((middle == null)\n+                || ((middle.getStart() == end1) && (middle.getDiag() == (end1 - end2)))\n+                || ((middle.getEnd() == start1) && (middle.getDiag() == (start1 - start2)))) {\n+\n+            int i = start1;\n+            int j = start2;\n+            while ((i < end1) || (j < end2)) {\n+                if ((i < end1) && (j < end2) && sequence1.get(i).equals(sequence2.get(j))) {\n+                    script.append(new KeepCommand<T>(sequence1.get(i)));\n+                    ++i;\n+                    ++j;\n+                } else {\n+                    if ((end1 - start1) > (end2 - start2)) {\n+                        script.append(new DeleteCommand<T>(sequence1.get(i)));\n+                        ++i;\n+                    } else {\n+                        script.append(new InsertCommand<T>(sequence2.get(j)));\n+                        ++j;\n+                    }\n+                }\n+            }\n+\n+        } else {\n+\n+            buildScript(start1, middle.getStart(),\n+                        start2, middle.getStart() - middle.getDiag(),\n+                        script);\n+            for (int i = middle.getStart(); i < middle.getEnd(); ++i) {\n+                script.append(new KeepCommand<T>(sequence1.get(i)));\n+            }\n+            buildScript(middle.getEnd(), end1,\n+                        middle.getEnd() - middle.getDiag(), end2,\n+                        script);\n+        }\n+    }\n+\n+    /**\n+     * Get the edit script script.\n+     * <p>\n+     * It is guaranteed that the objects embedded in the {@link InsertCommand\n+     * insert commands} come from the second sequence and that the objects\n+     * embedded in either the {@link DeleteCommand delete commands} or\n+     * {@link KeepCommand keep commands} come from the first sequence. This can\n+     * be important if subclassing is used for some elements in the first\n+     * sequence and the <code>equals</code> method is specialized.\n+     * \n+     * @return the edit script resulting from the comparison of the two\n+     *         sequences\n+     */\n+    public EditScript<T> getScript() {\n+        EditScript<T> script = new EditScript<T>();\n+        buildScript(0, sequence1.size(), 0, sequence2.size(), script);\n+        return script;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/Snake.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+/**\n+ * This class is a simple placeholder to hold the end part of a path\n+ * under construction in a {@link SequencesComparator SequencesComparator}.\n+ * <p>\n+ * A snake is an internal structure used in Eugene W. Myers algorithm\n+ * (<a href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">\n+ * An O(ND) Difference Algorithm and Its Variations</a>).\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class Snake {\n+\n+    /** Start index. */\n+    private int start;\n+\n+    /** End index. */\n+    private int end;\n+\n+    /** Diagonal number. */\n+    private int diag;\n+\n+    /**\n+     * Simple constructor. Creates a new instance of Snake with default indices.\n+     */\n+    public Snake() {\n+        start = -1;\n+        end   = -1;\n+        diag  =  0;\n+    }\n+\n+    /**\n+     * Simple constructor. Creates a new instance of Snake with specified indices.\n+     *\n+     * @param start  start index of the snake\n+     * @param end  end index of the snake\n+     * @param diag  diagonal number\n+     */ \n+    public Snake(int start, int end, int diag) {\n+        this.start = start;\n+        this.end   = end;\n+        this.diag  = diag;\n+    }\n+\n+    /**\n+     * Get the start index of the snake.\n+     *\n+     * @return start index of the snake\n+     */\n+    public int getStart() {\n+        return start;\n+    }\n+\n+    /**\n+     * Get the end index of the snake.\n+     *\n+     * @return end index of the snake\n+     */\n+    public int getEnd() {\n+        return end;\n+    }\n+\n+    /**\n+     * Get the diagonal number of the snake.\n+     *\n+     * @return diagonal number of the snake\n+     */  \n+    public int getDiag() {\n+        return diag;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package provides classes to compare two objects sequences.\n+ * <p>\n+ * The two sequences can hold any object type, as only the\n+ * <code>equals</code> method is used to compare the elements of the\n+ * sequences. It is guaranteed that the comparisons will always be done\n+ * as <code>o1.equals(o2)</code> where <code>o1</code> belongs to the\n+ * first sequence and <code>o2</code> belongs to the second\n+ * sequence. This can be important if subclassing is used for some\n+ * elements in the first sequence and the <code>equals</code> method is\n+ * specialized.\n+ * <p>\n+ * Comparison can be seen from two points of view: either as giving the\n+ * smallest modification allowing to transform the first sequence into\n+ * the second one, or as giving the longest sequence which is a\n+ * subsequence of both initial sequences. The <code>equals</code> method\n+ * is used to compare objects, so any object can be put into\n+ * sequences. Modifications include deleting, inserting or keeping one\n+ * object, starting from the beginning of the first sequence. Like most\n+ * algorithms of the same type, objects transpositions are not\n+ * supported. This means that if a sequence <code>(A, B)</code> is\n+ * compared to <code>(B, A)</code>, the result will be either the\n+ * sequence of three commands <code>delete A</code>, <code>keep B</code>,\n+ * <code>insert A</code> or the sequence  <code>insert B</code>,\n+ * <code>keep A</code>, <code>delete B</code>.\n+ * <p>\n+ * The package uses a very efficient comparison algorithm designed by\n+ * Eugene W. Myers and described in his paper: <a\n+ * href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">An O(ND)\n+ * Difference Algorithm and Its Variations</a>. This algorithm produces\n+ * the shortest possible {@link\n+ * org.apache.commons.collections.list.difference.EditScript edit script} containing\n+ * all the {@link org.apache.commons.collections.list.difference.EditCommand\n+ * commands} needed to transform the first sequence into the second\n+ * one. The entry point for the user to this algorithm is the {@link\n+ * org.apache.commons.collections.list.difference.SequencesComparator\n+ * SequencesComparator} class.\n+ * <p>\n+ * As explained in Gene Myers paper, the edit script is equivalent to all\n+ * other representations and contains all the needed information either\n+ * to perform the transformation, of course, or to retrieve the longest\n+ * common subsequence for example.\n+ * <p>\n+ * If the user needs a very fine grained access to the comparison result,\n+ * he needs to go through this script by providing a visitor implementing\n+ * the {@link org.apache.commons.collections.list.difference.CommandVisitor\n+ * CommandVisitor} interface.\n+ * <p>\n+ * Sometimes however, a more synthetic approach is needed. If the user\n+ * prefers to see the differences between the two sequences as global\n+ * <code>replacement</code> operations acting on complete subsequences of\n+ * the original sequences, he will provide an object implementing the\n+ * simple {@link org.apache.commons.collections.list.difference.ReplacementsHandler\n+ * ReplacementsHandler} interface, using an instance of the {@link\n+ * org.apache.commons.collections.list.difference.ReplacementsFinder\n+ * ReplacementsFinder} class as a command converting layer between his\n+ * object and the edit script. The number of objects which are common to\n+ * both initial arrays and hence are skipped between each call to the user\n+ * {@link org.apache.commons.collections.list.difference.ReplacementsHandler#handleReplacement\n+ * handleReplacement} method is also provided. This allows the user to keep\n+ * track of the current index in both arrays if he needs so.\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/sequence/SequencesComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators.sequence;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SequencesComparatorTest {\n+\n+    private List<String> before;\n+    private List<String> after;\n+    private int[]        length;\n+\n+    @Test\n+    public void testLength() {\n+        for (int i = 0; i < before.size(); ++i) {\n+            SequencesComparator<Character> comparator =\n+                    new SequencesComparator<Character>(sequence(before.get(i)),\n+                            sequence(after.get(i)));\n+            Assert.assertEquals(length[i], comparator.getScript().getModifications());\n+        }\n+    }\n+\n+    @Test\n+    public void testExecution() {\n+        ExecutionVisitor<Character> ev = new ExecutionVisitor<Character>();\n+        for (int i = 0; i < before.size(); ++i) {\n+            ev.setList(sequence(before.get(i)));\n+            new SequencesComparator<Character>(sequence(before.get(i)),\n+                    sequence(after.get(i))).getScript().visit(ev);\n+            Assert.assertEquals(after.get(i), ev.getString());\n+        }\n+    }\n+\n+    @Test\n+    public void testMinimal() {\n+        String[] shadokAlph = new String[] {\n+            new String(\"GA\"),\n+            new String(\"BU\"),\n+            new String(\"ZO\"),\n+            new String(\"MEU\")\n+        };\n+        List<String> sentenceBefore = new ArrayList<String>();\n+        List<String> sentenceAfter  = new ArrayList<String>();\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[3]);\n+\n+        Random random = new Random(4564634237452342L);\n+\n+        for (int nbCom = 0; nbCom <= 40; nbCom+=5) {\n+            sentenceAfter.clear();\n+            sentenceAfter.addAll(sentenceBefore);\n+            for (int i = 0; i<nbCom; i++) {\n+                if (random.nextInt(2) == 0) {\n+                    sentenceAfter.add(random.nextInt(sentenceAfter.size() + 1),\n+                                      shadokAlph[random.nextInt(4)]);\n+                } else {\n+                    sentenceAfter.remove(random.nextInt(sentenceAfter.size()));\n+                }\n+            }\n+\n+            SequencesComparator<String> comparator =\n+                    new SequencesComparator<String>(sentenceBefore, sentenceAfter);\n+            Assert.assertTrue(comparator.getScript().getModifications() <= nbCom);\n+        }\n+    }\n+\n+    @Test\n+    public void testShadok() {\n+        int lgMax = 5;\n+        String[] shadokAlph = new String[] {\n+            new String(\"GA\"),\n+            new String(\"BU\"),\n+            new String(\"ZO\"),\n+            new String(\"MEU\")\n+        };\n+        List<List<String>> shadokSentences = new ArrayList<List<String>>();\n+        for (int lg=0; lg<lgMax; ++lg) {\n+            List<List<String>> newTab = new ArrayList<List<String>>();\n+            newTab.add(new ArrayList<String>());\n+            for (int k = 0; k < shadokAlph.length; k++) {\n+                for (List<String> sentence : shadokSentences) {\n+                    List<String> newSentence = new ArrayList<String>(sentence);\n+                    newSentence.add(shadokAlph[k]);\n+                    newTab.add(newSentence);\n+                }\n+            }\n+            shadokSentences = newTab;\n+        }\n+\n+        ExecutionVisitor<String> ev = new ExecutionVisitor<String>();\n+\n+        for (int i = 0; i < shadokSentences.size(); ++i) {\n+            for (int j = 0; j < shadokSentences.size(); ++j) {\n+                ev.setList(shadokSentences.get(i));\n+                new SequencesComparator<String>(shadokSentences.get(i),\n+                        shadokSentences.get(j)).getScript().visit(ev);\n+\n+                StringBuilder concat = new StringBuilder();\n+                for (final String s : shadokSentences.get(j)) {\n+                    concat.append(s);\n+                }\n+                Assert.assertEquals(concat.toString(), ev.getString());\n+            }\n+        }\n+    }\n+\n+    private List<Character> sequence(String string) {\n+        List<Character> list = new ArrayList<Character>();\n+        for (int i = 0; i < string.length(); ++i) {\n+            list.add(new Character(string.charAt(i)));\n+        }\n+        return list;\n+    }\n+\n+    private class ExecutionVisitor<T> implements CommandVisitor<T> {\n+\n+        private List<T> v;\n+        private int index;\n+\n+        public void setList(List<T> array) {\n+            v = new ArrayList<T>(array);\n+            index = 0;\n+        }\n+\n+        public void visitInsertCommand(T object) {\n+            v.add(index++, object);\n+        }\n+\n+        public void visitKeepCommand(T object) {\n+            ++index;\n+        }\n+\n+        public void visitDeleteCommand(T object) {\n+            v.remove(index);\n+        }\n+\n+        public String getString() {\n+            StringBuffer buffer = new StringBuffer();\n+            for (T c : v) {\n+                buffer.append(c);\n+            }\n+            return buffer.toString();\n+        }\n+\n+    }\n+\n+    @Before\n+    public void setUp() {\n+\n+        before = Arrays.asList(new String[] {\n+            \"bottle\",\n+            \"nematode knowledge\",\n+            \"\",\n+            \"aa\",\n+            \"prefixed string\",\n+            \"ABCABBA\",\n+            \"glop glop\",\n+            \"coq\",\n+            \"spider-man\"\n+        });\n+\n+        after = Arrays.asList(new String[] {\n+            \"noodle\",\n+            \"empty bottle\",\n+            \"\",\n+            \"C\",\n+            \"prefix\",\n+            \"CBABAC\",\n+            \"pas glop pas glop\",\n+            \"ane\",\n+            \"klingon\"\n+        });\n+\n+        length = new int[] {\n+            6,\n+            16,\n+            0,\n+            3,\n+            9,\n+            5,\n+            8,\n+            6,\n+            13\n+        };\n+\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        before = null;\n+        after  = null;\n+        length = null;\n+    }\n+\n+}", "timestamp": 1342347153, "metainfo": ""}