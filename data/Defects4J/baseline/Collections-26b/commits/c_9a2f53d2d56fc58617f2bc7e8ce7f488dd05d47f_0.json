{"sha": "9a2f53d2d56fc58617f2bc7e8ce7f488dd05d47f", "log": "Trailing spaces  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/ListUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ListUtils.java\n     private ListUtils() {}\n \n     //-----------------------------------------------------------------------\n-    \n+\n     /**\n      * Returns an immutable empty list if the argument is <code>null</code>,\n      * or the argument itself otherwise.\n-     * \n+     *\n      * @param <T> the element type\n      * @param list the list, possibly <code>null</code>\n      * @return an empty list if the argument is <code>null</code>\n     /**\n      * Returns either the passed in list, or if the list is {@code null},\n      * the value of {@code defaultList}.\n-     * \n+     *\n      * @param <T> the element type\n      * @param list  the list, possibly {@code null}\n      * @param defaultList  the returned values if list is {@code null}\n     public static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n         return list == null ? defaultList : list;\n     }\n-    \n+\n     /**\n      * Returns a new list containing all elements that are contained in\n      * both given lists.\n             smaller = list2;\n             larger = list1;\n         }\n-        \n+\n         final HashSet<E> hashSet = new HashSet<E>(smaller);\n \n         for (final E e : larger) {\n      * subtracted from their union.\n      *\n      * @param <E>  the element type\n-     * @param list1  the first list \n+     * @param list1  the first list\n      * @param list2  the second list\n      * @return  a new list containing the sum of those lists\n      * @throws NullPointerException if either list is null\n-     */ \n+     */\n     public static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n         return subtract(union(list1, list2), intersection(list1, list2));\n     }\n      * used to append the two given lists into a new list.\n      *\n      * @param <E>  the element type\n-     * @param list1  the first list \n+     * @param list1  the first list\n      * @param list2  the second list\n      * @return  a new list containing the union of those lists\n      * @throws NullPointerException if either list is null\n      * @return the elements matching the predicate (new list)\n      * @throws NullPointerException\n      *             if the input list is null\n-     *          \n+     *\n      * @since 4.0\n      * @see CollectionUtils#select(Collection, Predicate)\n      */\n      * @return the elements <b>not</b> matching the predicate (new list)\n      * @throws NullPointerException\n      *             if the input collection is null\n-     *          \n+     *\n      * @since 4.0\n      * @see CollectionUtils#selectRejected(Collection, Predicate)\n      */\n      *\n      * <b>Note:</b> The behaviour of this method is undefined if the lists are\n      * modified during the equals comparison.\n-     * \n+     *\n      * @see java.util.List\n      * @param list1  the first list, may be null\n      * @param list2  the second list, may be null\n \n         return !(it1.hasNext() || it2.hasNext());\n     }\n-    \n-    /**\n-     * Generates a hash code using the algorithm specified in \n+\n+    /**\n+     * Generates a hash code using the algorithm specified in\n      * {@link java.util.List#hashCode()}.\n      * <p>\n      * This method is useful for implementing <code>List</code> when you cannot\n      * extend AbstractList. The method takes Collection instances to enable other\n      * collection types to use the List implementation algorithm.\n-     * \n+     *\n      * @see java.util.List#hashCode()\n      * @param list  the list to generate the hashCode for, may be null\n      * @return the hash code\n         }\n         int hashCode = 1;\n         final Iterator<?> it = list.iterator();\n-        \n+\n         while (it.hasNext()) {\n             final Object obj = it.next();\n             hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n         }\n         return hashCode;\n-    }   \n+    }\n \n     //-----------------------------------------------------------------------\n     /**\n      * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n      * case the cardinality is zero. This method is useful if you do not wish to modify\n      * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n-     * <p> \n+     * <p>\n      * This implementation iterates over <code>collection</code>, checking each element in\n      * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n      * to the returned list. As a consequence, it is advised to use a collection type for\n      * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n      * {@link Collection#contains(Object)}.\n-     * \n+     *\n      * @param <E>  the element type\n      * @param collection  the collection whose contents are the target of the #retailAll operation\n      * @param retain  the collection containing the elements to be retained in the returned collection\n      * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n      * case the cardinality is zero. This method is useful if you do not wish to modify\n      * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n-     * <p> \n+     * <p>\n      * This implementation iterates over <code>collection</code>, checking each element in\n      * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n      * to the returned list. As a consequence, it is advised to use a collection type for\n      * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n      * {@link Collection#contains(Object)}.\n-     * \n+     *\n      * @param <E>  the element type\n      * @param collection  the collection from which items are removed (in the returned collection)\n      * @param remove  the items to be removed from the returned <code>collection</code>\n     /**\n      * Returns a synchronized list backed by the given list.\n      * <p>\n-     * You must manually synchronize on the returned list's iterator to \n+     * You must manually synchronize on the returned list's iterator to\n      * avoid non-deterministic behavior:\n-     *  \n+     *\n      * <pre>\n      * List list = ListUtils.synchronizedList(myList);\n      * synchronized (list) {\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n-     * \n+     *\n      * @param <E>  the element type\n      * @param list  the list to synchronize, must not be null\n      * @return a synchronized list backed by the given list\n      * Existing entries in the specified list will not be transformed.\n      * <p>\n      * Each object is passed through the transformer as it is added to the\n-     * List. It is important not to use the original list after invoking this \n+     * List. It is important not to use the original list after invoking this\n      * method, as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified list will not be transformed.\n                                               final Transformer<? super E, ? extends E> transformer) {\n         return TransformedList.transformingList(list, transformer);\n     }\n-    \n+\n     /**\n      * Returns a \"lazy\" list whose elements will be created on demand.\n      * <p>\n      *\n      * After the above code is executed, <code>date</code> will refer to\n      * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n-     * instance is the fourth element in the list.  The first, second, \n+     * instance is the fourth element in the list.  The first, second,\n      * and third element are all set to <code>null</code>.\n      *\n      * @param <E>  the element type\n \n     /**\n      * Returns a fixed-sized list backed by the given list.\n-     * Elements may not be added or removed from the returned list, but \n-     * existing elements can be changed (for instance, via the \n+     * Elements may not be added or removed from the returned list, but\n+     * existing elements can be changed (for instance, via the\n      * {@link List#set(int, Object)} method).\n      *\n      * @param <E>  the element type\n     //-----------------------------------------------------------------------\n     /**\n      * Returns the longest common subsequence (LCS) of two sequences (lists).\n-     * \n+     *\n      * @param <E>  the element type\n      * @param a  the first list\n      * @param b  the second list\n \n     /**\n      * Returns the longest common subsequence (LCS) of two sequences (lists).\n-     * \n+     *\n      * @param <E>  the element type\n      * @param a  the first list\n      * @param b  the second list\n      */\n     public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b, final Equator<? super E> equator) {\n         if (a == null || b == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");          \n+            throw new IllegalArgumentException(\"List must not be null\");\n         }\n         if (equator == null) {\n           throw new IllegalArgumentException(\"Equator must not be null\");\n      * Returns the longest common subsequence (LCS) of two {@link CharSequence} objects.\n      * <p>\n      * This is a convenience method for using {@link #longestCommonSubsequence(List, List)}\n-     * with {@link CharSequence} instances. \n-     * \n+     * with {@link CharSequence} instances.\n+     *\n      * @param a  the first sequence\n      * @param b  the second sequence\n      * @return the longest common subsequence as {@link String}\n      */\n     public static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n         if (a == null || b == null) {\n-            throw new IllegalArgumentException(\"CharSequence must not be null\");          \n+            throw new IllegalArgumentException(\"CharSequence must not be null\");\n         }\n         final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList( a ), new CharSequenceAsList( b ));\n         final StringBuilder sb = new StringBuilder();\n     private static final class CharSequenceAsList extends AbstractList<Character> {\n \n       private final CharSequence sequence;\n-      \n+\n       public CharSequenceAsList(final CharSequence sequence) {\n         this.sequence = sequence;\n       }\n-      \n+\n       @Override\n       public Character get( int index ) {\n         return Character.valueOf(sequence.charAt( index ));\n       public int size() {\n         return sequence.length();\n       }\n-      \n-    }\n-        \n+\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Returns consecutive {@link List#subList(int, int) sublists} of a\n      * to all the usual caveats about modification as explained in that API.\n      * <p>\n      * Adapted from http://code.google.com/p/guava-libraries/\n-     * \n+     *\n      * @param <T>  the element type\n      * @param list  the list to return consecutive sublists of\n      * @param size  the desired size of each sublist (the last may be smaller)\n      */\n     public static <T> List<List<T>> partition(final List<T> list, final int size) {\n         if (list == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");          \n+            throw new IllegalArgumentException(\"List must not be null\");\n         }\n         if (size <= 0) {\n-            throw new IllegalArgumentException(\"Size must be greater than 0\");            \n+            throw new IllegalArgumentException(\"Size must be greater than 0\");\n         }\n         return new Partition<T>(list, size);\n     }\n-    \n+\n     /**\n      * Provides a partition view on a {@link List}.\n      * @since 4.0\n         public List<T> get(final int index) {\n             final int listSize = size();\n             if (listSize < 0) {\n-                throw new IllegalArgumentException(\"negative size: \" + listSize);           \n+                throw new IllegalArgumentException(\"negative size: \" + listSize);\n             }\n             if (index < 0) {\n-                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");         \n+                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");\n             }\n             if (index >= listSize) {\n                 throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n-                                                    listSize);           \n-            }           \n+                                                    listSize);\n+            }\n             final int start = index * size;\n             final int end = Math.min(start + size, list.size());\n             return list.subList(start, end);", "timestamp": 1367344715, "metainfo": ""}