{"sha": "90559c49bae582697906598c735385c19daa6da6", "log": "Fix findbugs warning.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java\n             }\n             return result;\n         } else {\n-            return decorated().removeAll(coll);\n+            // let the decorated bag handle the case of null argument\n+            return decorated().removeAll(null);\n         }\n     }\n \n             }\n             return modified;\n         } else {\n-            return decorated().retainAll(coll);\n+            // let the decorated bag handle the case of null argument\n+            return decorated().retainAll(null);\n         }\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.SortedBag;\n+\n+/**\n+ * Decorates another {@link SortedBag} to comply with the Collection contract.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public final class CollectionSortedBag<E>\n+        extends AbstractSortedBagDecorator<E> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2560033712679053143L;\n+\n+    /**\n+     * Factory method to create a sorted bag that complies to the Collection contract.\n+     *\n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the sorted bag to decorate, must not be null\n+     * @return a SortedBag that complies to the Collection contract\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n+        return new CollectionSortedBag<E>(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param bag  the sorted bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public CollectionSortedBag(final SortedBag<E> bag) {\n+        super(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(decorated());\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @throws ClassCastException if deserialised object has wrong type\n+     */\n+    @SuppressWarnings(\"unchecked\") // will throw CCE, see Javadoc\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        setCollection((Collection<E>) in.readObject());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Collection interface\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public boolean containsAll(final Collection<?> coll) {\n+        final Iterator<?> e = coll.iterator();\n+        while (e.hasNext()) {\n+            if(!contains(e.next())) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        return add(object, 1);\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        boolean changed = false;\n+        final Iterator<? extends E> i = coll.iterator();\n+        while (i.hasNext()) {\n+            final boolean added = add(i.next(), 1);\n+            changed = changed || added;\n+        }\n+        return changed;\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        return remove(object, 1);\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        if (coll != null) {\n+            boolean result = false;\n+            final Iterator<?> i = coll.iterator();\n+            while (i.hasNext()) {\n+                final Object obj = i.next();\n+                final boolean changed = remove(obj, getCount(obj));\n+                result = result || changed;\n+            }\n+            return result;\n+        } else {\n+            // let the decorated bag handle the case of null argument\n+            return decorated().removeAll(null);\n+        }\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        if (coll != null) {\n+            boolean modified = false;\n+            final Iterator<E> e = iterator();\n+            while (e.hasNext()) {\n+                if (!coll.contains(e.next())) {\n+                    e.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        } else {\n+            // let the decorated bag handle the case of null argument\n+            return decorated().retainAll(null);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Bag interface\n+    //-----------------------------------------------------------------------\n+\n+    public boolean add(final E object, final int count) {\n+        decorated().add(object, count);\n+        return true;\n+    }\n+\n+}", "timestamp": 1384202166, "metainfo": ""}