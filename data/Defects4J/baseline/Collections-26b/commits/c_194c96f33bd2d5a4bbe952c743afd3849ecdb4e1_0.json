{"sha": "194c96f33bd2d5a4bbe952c743afd3849ecdb4e1", "log": "Add fully featured SingletonMap   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/SingletonMap.java\n+/*\n+ *  Copyright 2003-2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.Serializable;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.iterators.SingletonIterator;\n+import org.apache.commons.collections.keyvalue.TiedMapEntry;\n+\n+/**\n+ * A <code>Map</code> implementation that holds a single item and is fixed size.\n+ * <p>\n+ * The single key/value pair is specified at creation.\n+ * The map is fixed size so any action that would change the size is disallowed.\n+ * However, the <code>put</code> or <code>setValue</code> methods can <i>change</i>\n+ * the value associated with the key.\n+ * <p>\n+ * If trying to remove or clear the map, an UnsupportedOperationException is thrown.\n+ * If trying to put a new mapping into the map, an  IllegalArgumentException is thrown.\n+ * The put method will only suceed if the key specified is the same as the \n+ * singleton key.\n+ * <p>\n+ * The key and value can be obtained by:\n+ * <ul>\n+ * <li>normal Map methods and views\n+ * <li>the <code>MapIterator</code>, see {@link #mapIterator()}\n+ * <li>the <code>KeyValue</code> interface (just cast - no object creation)\n+ * </ul>\n+ * \n+ * @since Commons Collections 3.1\n+ * @version $Revision: 1.1 $ $Date: 2004/04/09 14:46:35 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SingletonMap\n+        implements OrderedMap, BoundedMap, KeyValue, Serializable, Cloneable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8931271118676803261L;\n+\n+    /** Singleton key */\n+    private final Object key;\n+    /** Singleton value */\n+    private Object value;\n+\n+    /**\n+     * Constructor that creates a map of <code>null</code> to <code>null</code>.\n+     */\n+    public SingletonMap() {\n+        super();\n+        this.key = null;\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value.\n+     *\n+     * @param key  the key to use\n+     * @param value  the value to use\n+     */\n+    public SingletonMap(Object key, Object value) {\n+        super();\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value as a <code>KeyValue</code>.\n+     *\n+     * @param keyValue  the key value pair to use\n+     */\n+    public SingletonMap(KeyValue keyValue) {\n+        super();\n+        this.key = keyValue.getKey();\n+        this.value = keyValue.getValue();\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value as a <code>MapEntry</code>.\n+     *\n+     * @param keyValue  the key value pair to use\n+     */\n+    public SingletonMap(Map.Entry entry) {\n+        super();\n+        this.key = entry.getKey();\n+        this.value = entry.getValue();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy, must be size 1\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the size is not 1\n+     */\n+    public SingletonMap(Map map) {\n+        super();\n+        if (map.size() != 1) {\n+            throw new IllegalArgumentException(\"The map size must be 1\");\n+        }\n+        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n+        this.key = entry.getKey();\n+        this.value = entry.getValue();\n+    }\n+\n+    // KeyValue\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key.\n+     *\n+     * @return the key \n+     */\n+    public Object getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Gets the value.\n+     *\n+     * @return the value\n+     */\n+    public Object getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Sets the value.\n+     *\n+     * @param value  the new value to set\n+     * @return the old value\n+     */\n+    public Object setValue(Object value) {\n+        Object old = this.value;\n+        this.value = value;\n+        return old;\n+    }\n+\n+    // BoundedMap\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is the map currently full, always true.\n+     *\n+     * @return true always\n+     */\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the maximum size of the map, always 1.\n+     * \n+     * @return 1 always\n+     */\n+    public int maxSize() {\n+        return 1;\n+    }\n+\n+    // Map\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key) {\n+        if (isEqualKey(key)) {\n+            return value;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map, always 1.\n+     * \n+     * @return the size of 1\n+     */\n+    public int size() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty, which it never is.\n+     * \n+     * @return false always\n+     */\n+    public boolean isEmpty() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     * \n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        return (isEqualKey(key));\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsValue(Object value) {\n+        return (isEqualValue(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map where the key must match the existing key.\n+     * <p>\n+     * An IllegalArgumentException is thrown if the key does not match as the map\n+     * is fixed size.\n+     * \n+     * @param key  the key to set, must be the key of the map\n+     * @param value  the value to set\n+     * @return the value previously mapped to this key, null if none\n+     * @throws IllegalArgumentException if the key does not match\n+     */\n+    public Object put(Object key, Object value) {\n+        if (isEqualKey(key)) {\n+            return setValue(value);\n+        }\n+        throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size singleton\");\n+    }\n+\n+    /**\n+     * Puts the values from the specified map into this map.\n+     * <p>\n+     * The map must be of size 0 or size 1.\n+     * If it is size 1, the key must match the key of this map otherwise an\n+     * IllegalArgumentException is thrown.\n+     * \n+     * @param map  the map to add, must be size 0 or 1, and the key must match\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the key does not match\n+     */\n+    public void putAll(Map map) {\n+        switch (map.size()) {\n+            case 0:\n+                return;\n+            \n+            case 1:\n+                Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n+                put(entry.getKey(), entry.getValue());\n+                return;\n+            \n+            default:\n+                throw new IllegalArgumentException(\"The map size must be 0 or 1\");\n+        }\n+    }\n+\n+    /**\n+     * Unsupported operation.\n+     * \n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     * @throws UnsupportedOperationException always\n+     */\n+    public Object remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Unsupported operation.\n+     */\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made via <code>setValue</code> affect this map.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     * \n+     * @return the entrySet view\n+     */\n+    public Set entrySet() {\n+        Map.Entry entry = new TiedMapEntry(this, getKey());\n+        return Collections.singleton(entry);\n+    }\n+    \n+    /**\n+     * Gets the unmodifiable keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     * \n+     * @return the keySet view\n+     */\n+    public Set keySet() {\n+        return Collections.singleton(key);\n+    }\n+\n+    /**\n+     * Gets the unmodifiable values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     * \n+     * @return the values view\n+     */\n+    public Collection values() {\n+        return new SingletonValues(this);\n+    }\n+\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator using <code>setValue</code> affect this map.\n+     * The <code>remove</code> method is unsupported.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Map Entry object.\n+     * \n+     * @return the map iterator\n+     */\n+    public MapIterator mapIterator() {\n+        return new SingletonMapIterator(this);\n+    }\n+\n+    // OrderedMap\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an <code>OrderedMapIterator</code> over the map.\n+     * <p>\n+     * A ordered map iterator is an efficient way of iterating over maps\n+     * in both directions.\n+     * \n+     * @return an ordered map iterator\n+     */\n+    public OrderedMapIterator orderedMapIterator() {\n+        return new SingletonMapIterator(this);\n+    }\n+\n+    /**\n+     * Gets the first (and only) key in the map.\n+     * \n+     * @return the key\n+     */\n+    public Object firstKey() {\n+        return getKey();\n+    }\n+\n+    /**\n+     * Gets the last (and only) key in the map.\n+     * \n+     * @return the key\n+     */\n+    public Object lastKey() {\n+        return getKey();\n+    }\n+\n+    /**\n+     * Gets the next key after the key specified, always null.\n+     * \n+     * @param key  the next key\n+     * @return null always\n+     */\n+    public Object nextKey(Object key) {\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous key before the key specified, always null.\n+     * \n+     * @param key  the next key\n+     * @return null always\n+     */\n+    public Object previousKey(Object key) {\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares the specified key to the stored key.\n+     * \n+     * @param key  the key to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualKey(Object key) {\n+        return (key == null ? getKey() == null : key.equals(getKey()));\n+    }\n+\n+    /**\n+     * Compares the specified value to the stored value.\n+     * \n+     * @param value  the value to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(Object value) {\n+        return (value == null ? getValue() == null : value.equals(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * SingletonMapIterator.\n+     */\n+    static class SingletonMapIterator implements OrderedMapIterator, ResettableIterator {\n+        private final SingletonMap parent;\n+        private boolean hasNext = true;\n+        private boolean canGetSet = false;\n+        \n+        SingletonMapIterator(SingletonMap parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        public boolean hasNext() {\n+            return hasNext;\n+        }\n+\n+        public Object next() {\n+            if (hasNext == false) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            hasNext = false;\n+            canGetSet = true;\n+            return parent.getKey();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (hasNext == false);\n+        }\n+\n+        public Object previous() {\n+            if (hasNext == true) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n+            }\n+            hasNext = true;\n+            return parent.getKey();\n+        }\n+\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Object getKey() {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return parent.getKey();\n+        }\n+\n+        public Object getValue() {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return parent.getValue();\n+        }\n+\n+        public Object setValue(Object value) {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return parent.setValue(value);\n+        }\n+        \n+        public void reset() {\n+            hasNext = true;\n+        }\n+        \n+        public String toString() {\n+            if (hasNext) {\n+                return \"Iterator[]\";\n+            } else {\n+                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Values implementation for the SingletonMap.\n+     * This class is needed as values is a view that must update as the map updates.\n+     */\n+    static class SingletonValues extends AbstractSet implements Serializable {\n+        private static final long serialVersionUID = -3689524741863047872L;\n+        private final SingletonMap parent;\n+\n+        SingletonValues(SingletonMap parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        public int size() {\n+            return 1;\n+        }\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+        public boolean contains(Object object) {\n+            return parent.containsValue(object);\n+        }\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+        public Iterator iterator() {\n+            return new SingletonIterator(parent.getValue(), false);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the key or value.\n+     *\n+     * @return a shallow clone\n+     */\n+    public Object clone() {\n+        try {\n+            SingletonMap cloned = (SingletonMap) super.clone();\n+            return cloned;\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Compares this map with another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map other = (Map) obj;\n+        if (other.size() != 1) {\n+            return false;\n+        }\n+        Map.Entry entry = (Map.Entry) other.entrySet().iterator().next();\n+        return isEqualKey(entry.getKey()) && isEqualValue(entry.getValue());\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     * \n+     * @return the hash code defined in the Map interface\n+     */\n+    public int hashCode() {\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (getValue() == null ? 0 : getValue().hashCode()); \n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     * \n+     * @return a string version of the map\n+     */\n+    public String toString() {\n+        return new StringBuffer(128)\n+            .append('{')\n+            .append((getKey() == this ? \"(this Map)\" : getKey()))\n+            .append('=')\n+            .append((getValue() == this ? \"(this Map)\" : getValue()))\n+            .append('}')\n+            .toString();\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/map/TestAll.java\n+++ b/src/test/org/apache/commons/collections/map/TestAll.java\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.14 $ $Date: 2004/02/18 01:20:37 $\n+ * @version $Revision: 1.15 $ $Date: 2004/04/09 14:46:35 $\n  * \n  * @author Stephen Colebourne\n  */\n         suite.addTest(TestTransformedSortedMap.suite());\n         suite.addTest(TestPredicatedMap.suite());\n         suite.addTest(TestPredicatedSortedMap.suite());\n+        suite.addTest(TestSingletonMap.suite());\n         suite.addTest(TestUnmodifiableMap.suite());\n         suite.addTest(TestUnmodifiableOrderedMap.suite());\n         suite.addTest(TestUnmodifiableSortedMap.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestSingletonMap.java\n+/*\n+ *  Copyright 2001-2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/04/09 14:46:35 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestSingletonMap extends AbstractTestOrderedMap {\n+\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final String TEN = \"10\";\n+    private static final String TWENTY = \"20\";\n+        \n+    public TestSingletonMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestSingletonMap.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Map makeEmptyMap() {\n+        // need an empty singleton map, but thats not possible\n+        // use a ridiculous fake instead to make the tests pass\n+        return UnmodifiableOrderedMap.decorate(ListOrderedMap.decorate(new HashMap()));\n+    }\n+    \n+    public String[] ignoredTests() {\n+        // the ridiculous map above still doesn't pass these tests\n+        // but its not relevant, so we ignore them\n+        return new String[] {\n+            \"TestSingletonMap.bulkTestMapIterator.testEmptyMapIterator\",\n+            \"TestSingletonMap.bulkTestOrderedMapIterator.testEmptyMapIterator\",\n+        };\n+    }\n+\n+\n+    public Map makeFullMap() {\n+        return new SingletonMap(ONE, TWO);\n+    }\n+\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    public Object[] getSampleKeys() {\n+        return new Object[] {ONE};\n+    }\n+\n+    public Object[] getSampleValues() {\n+        return new Object[] {TWO};\n+    }\n+\n+    public Object[] getNewSampleValues() {\n+        return new Object[] {TEN};\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClone() {\n+        SingletonMap map = new SingletonMap(ONE, TWO);\n+        assertEquals(1, map.size());\n+        SingletonMap cloned = (SingletonMap) map.clone();\n+        assertEquals(1, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsValue(TWO));\n+    }\n+\n+    public void testKeyValue() {\n+        SingletonMap map = new SingletonMap(ONE, TWO);\n+        assertEquals(1, map.size());\n+        assertEquals(ONE, map.getKey());\n+        assertEquals(TWO, map.getValue());\n+        assertTrue(map instanceof KeyValue);\n+    }\n+\n+    public void testBoundedMap() {\n+        SingletonMap map = new SingletonMap(ONE, TWO);\n+        assertEquals(1, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(1, map.maxSize());\n+        assertTrue(map instanceof BoundedMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    public BulkTest bulkTestMapIterator() {\n+//        return new TestFlatMapIterator();\n+//    }\n+//    \n+//    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator {\n+//        public TestFlatMapIterator() {\n+//            super(\"TestFlatMapIterator\");\n+//        }\n+//        \n+//        public Object[] addSetValues() {\n+//            return TestSingletonMap.this.getNewSampleValues();\n+//        }\n+//        \n+//        public boolean supportsRemove() {\n+//            return TestSingletonMap.this.isRemoveSupported();\n+//        }\n+//\n+//        public boolean supportsSetValue() {\n+//            return TestSingletonMap.this.isSetValueSupported();\n+//        }\n+//\n+//        public MapIterator makeEmptyMapIterator() {\n+//            resetEmpty();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//\n+//        public MapIterator makeFullMapIterator() {\n+//            resetFull();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//        \n+//        public Map getMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.map;\n+//        }\n+//        \n+//        public Map getConfirmedMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.confirmed;\n+//        }\n+//        \n+//        public void verify() {\n+//            super.verify();\n+//            TestSingletonMap.this.verify();\n+//        }\n+//    }\n+    \n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/SingletonMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/SingletonMap.fullCollection.version3.1.obj\");\n+//    }\n+}", "timestamp": 1081521995, "metainfo": ""}