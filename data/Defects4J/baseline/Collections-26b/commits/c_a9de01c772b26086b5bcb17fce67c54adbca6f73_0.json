{"sha": "a9de01c772b26086b5bcb17fce67c54adbca6f73", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r814050 | sebb | 2009-09-11 15:01:25 -0700 (Fri, 11 Sep 2009) | 1 line          Some minor Javadoc fixes     ------------------------------------------------------------------------     r813924 | mbenson | 2009-09-11 10:03:40 -0700 (Fri, 11 Sep 2009) | 1 line          javadoc     ------------------------------------------------------------------------     r593347 | skestle | 2007-11-08 14:49:02 -0800 (Thu, 08 Nov 2007) | 3 lines          Added initial IndexedCollection - still needs quite a bit of work - see TODO comments          JIRA: COLLECTIONS-275     ------------------------------------------------------------------------   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/IndexedCollection.java\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n+ * keyTransformer to define how the keys are converted from the values.\n+ * <p>\n+ * Modifications made to this decorator modify the index as well as the\n+ * decorated {@link Collection}. However, modifications to the underlying\n+ * {@link Collection} will not updated the index and it will get out of sync.\n+ * <p>\n+ * If modification to the decorated {@link Collection} is unavoidable, then a\n+ * call to {@link #reindex()} will update the index to the current contents of\n+ * the {@link Collection}.\n+ *\n+ * @param <K> the type of object in the index.\n+ * @param <C> the type of object in the collection.\n+ * @author Stephen Kestle\n+ */\n+// TODO support MultiMap/non-unique index behavior\n+// TODO add support for remove and clear\n+public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n+    /**\n+     * .\n+     */\n+    private static final long serialVersionUID = -5512610452568370038L;\n+\n+    /**\n+     * Create an {@link IndexedCollection} for a unique index.\n+     *\n+     * @param <K> the index object type.\n+     * @param <C> the collection type.\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     * @return the created {@link IndexedCollection}.\n+     */\n+    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n+        return new IndexedCollection<K, C>(coll, keyTransformer, new HashMap<K, C>());\n+    }\n+\n+    /**\n+     * The {@link Transformer} for generating index keys.\n+     */\n+    private final Transformer<C, K> keyTransformer;\n+\n+    /**\n+     * The map of indexes to collected objects.\n+     */\n+    private final HashMap<K, C> index;\n+\n+    /**\n+     * Create a {@link IndexedCollection} for a unique index.\n+     *\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     */\n+    public IndexedCollection(Collection<C> coll, Transformer<C, K> keyTransformer, HashMap<K, C> map) {\n+        super(coll);\n+        this.keyTransformer = keyTransformer;\n+        this.index = map;\n+        reindex();\n+    }\n+\n+    /**\n+     * Clears the index and re-indexes the entire decorated {@link Collection}.\n+     */\n+    public void reindex() {\n+        index.clear();\n+        for (C c : decorated()) {\n+            addIndex(c);\n+        }\n+    }\n+\n+    /**\n+     * Adds an object to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.add() fails\n+    public boolean add(C object) {\n+        addIndex(object);\n+        return super.add(object);\n+    }\n+\n+    /**\n+     * Adds an entire collection to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.addAll() fails\n+    public boolean addAll(Collection<? extends C> coll) {\n+        for (C c : coll) {\n+            addIndex(c);\n+        }\n+        return super.addAll(coll);\n+    }\n+\n+    /**\n+     * Provides checking for adding the index.\n+     *\n+     * @param object the object to index.\n+     */\n+    private void addIndex(C object) {\n+        final C existingObject = index.put(keyTransformer.transform(object), object);\n+        if (existingObject != null) {\n+            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n+        }\n+    }\n+\n+    /**\n+     * Get the element associated with the given key.\n+     * @param key to look up\n+     * @return element found\n+     */\n+    public C get(K key) {\n+        return index.get(key);\n+    }\n+}", "timestamp": 1252994121, "metainfo": ""}