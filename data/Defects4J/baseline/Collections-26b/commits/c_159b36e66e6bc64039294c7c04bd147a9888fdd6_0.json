{"sha": "159b36e66e6bc64039294c7c04bd147a9888fdd6", "log": "[COLLECTIONS-565] Add decorators for NavigableSet interface.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/SetUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java\n import java.util.Collection;\n import java.util.Collections;\n import java.util.IdentityHashMap;\n+import java.util.NavigableSet;\n import java.util.Set;\n import java.util.SortedSet;\n import java.util.TreeSet;\n \n import org.apache.commons.collections4.set.ListOrderedSet;\n+import org.apache.commons.collections4.set.PredicatedNavigableSet;\n import org.apache.commons.collections4.set.PredicatedSet;\n import org.apache.commons.collections4.set.PredicatedSortedSet;\n+import org.apache.commons.collections4.set.TransformedNavigableSet;\n import org.apache.commons.collections4.set.TransformedSet;\n import org.apache.commons.collections4.set.TransformedSortedSet;\n+import org.apache.commons.collections4.set.UnmodifiableNavigableSet;\n import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.set.UnmodifiableSortedSet;\n \n      * @return a transformed set backed by the given set\n      * @throws IllegalArgumentException  if the Set or Transformer is null\n      */\n-    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Set<E> transformedSet(final Set<E> set,\n+                                            final Transformer<? super E, ? extends E> transformer) {\n         return TransformedSet.transformingSet(set, transformer);\n     }\n \n      * @return a predicated sorted set backed by the given sorted set\n      * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n-    public static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n+    public static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set,\n+                                                       final Predicate<? super E> predicate) {\n         return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n     }\n \n         return TransformedSortedSet.transformingSortedSet(set, transformer);\n     }\n \n+    // NavigableSet\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an unmodifiable navigable set backed by the given navigable set.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <E> the element type\n+     * @param set  the navigable set to make unmodifiable, must not be null\n+     * @return an unmodifiable set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     * @since 4.1\n+     */\n+    public static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n+        return UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) navigable set backed by the given navigable set.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the set.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original set after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <E> the element type\n+     * @param set  the navigable set to predicate, must not be null\n+     * @param predicate  the predicate for the navigable set, must not be null\n+     * @return a predicated navigable set backed by the given navigable set\n+     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     * @since 4.1\n+     */\n+    public static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set,\n+                                                          final Predicate<? super E> predicate) {\n+        return PredicatedNavigableSet.predicatedNavigableSet(set, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed navigable set backed by the given navigable set.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Set. It is important not to use the original set after invoking this\n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified set will not be transformed.\n+     * If you want that behaviour, see {@link TransformedNavigableSet#transformedNavigableSet}.\n+     *\n+     * @param <E> the element type\n+     * @param set  the navigable set to transform, must not be null\n+     * @param transformer  the transformer for the set, must not be null\n+     * @return a transformed set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     * @since 4.1\n+     */\n+    public static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set,\n+                                                           final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n+    }\n+\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Iterator;\n+import java.util.NavigableSet;\n+\n+/**\n+ * Decorates another <code>NavigableSet</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated set.\n+ *\n+ * @param <E> the type of the elements in the navigable set\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractNavigableSetDecorator<E>\n+        extends AbstractSortedSetDecorator<E>\n+        implements NavigableSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 20150528L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractNavigableSetDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected AbstractNavigableSetDecorator(final NavigableSet<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Gets the set being decorated.\n+     *\n+     * @return the decorated set\n+     */\n+    @Override\n+    protected NavigableSet<E> decorated() {\n+        return (NavigableSet<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public E lower(E e) {\n+        return decorated().lower(e);\n+    }\n+\n+    @Override\n+    public E floor(E e) {\n+        return decorated().floor(e);\n+    }\n+\n+    @Override\n+    public E ceiling(E e) {\n+        return decorated().ceiling(e);\n+    }\n+\n+    @Override\n+    public E higher(E e) {\n+        return decorated().higher(e);\n+    }\n+\n+    @Override\n+    public E pollFirst() {\n+        return decorated().pollFirst();\n+    }\n+\n+    @Override\n+    public E pollLast() {\n+        return decorated().pollLast();\n+    }\n+\n+    @Override\n+    public NavigableSet<E> descendingSet() {\n+        return decorated().descendingSet();\n+    }\n+\n+    @Override\n+    public Iterator<E> descendingIterator() {\n+        return decorated().descendingIterator();\n+    }\n+\n+    @Override\n+    public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {\n+        return decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> headSet(E toElement, boolean inclusive) {\n+        return decorated().headSet(toElement, inclusive);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {\n+        return decorated().tailSet(fromElement, inclusive);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Iterator;\n+import java.util.NavigableSet;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Decorates another <code>NavigableSet</code> to validate that all additions\n+ * match a specified predicate.\n+ * <p>\n+ * This set exists to provide validation for the decorated set.\n+ * It is normally created to decorate an empty set.\n+ * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the set.\n+ * <pre>\n+ * NavigableSet set =\n+ *   PredicatedSortedSet.predicatedNavigableSet(new TreeSet(),\n+ *                                              NotNullPredicate.notNullPredicate());\n+ * </pre>\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class PredicatedNavigableSet<E> extends PredicatedSortedSet<E> implements NavigableSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 20150528L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) navigable set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated navigable set.\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     * @since 4.0\n+     */\n+    public static <E> PredicatedNavigableSet<E> predicatedNavigableSet(final NavigableSet<E> set,\n+                                                                       final Predicate<? super E> predicate) {\n+        return new PredicatedNavigableSet<E>(set, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    protected PredicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n+        super(set, predicate);\n+    }\n+\n+    /**\n+     * Gets the navigable set being decorated.\n+     *\n+     * @return the decorated navigable set\n+     */\n+    @Override\n+    protected NavigableSet<E> decorated() {\n+        return (NavigableSet<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public E lower(E e) {\n+        return decorated().lower(e);\n+    }\n+\n+    @Override\n+    public E floor(E e) {\n+        return decorated().floor(e);\n+    }\n+\n+    @Override\n+    public E ceiling(E e) {\n+        return decorated().ceiling(e);\n+    }\n+\n+    @Override\n+    public E higher(E e) {\n+        return decorated().higher(e);\n+    }\n+\n+    @Override\n+    public E pollFirst() {\n+        return decorated().pollFirst();\n+    }\n+\n+    @Override\n+    public E pollLast() {\n+        return decorated().pollLast();\n+    }\n+\n+    @Override\n+    public NavigableSet<E> descendingSet() {\n+        return predicatedNavigableSet(decorated().descendingSet(), predicate);\n+    }\n+\n+    @Override\n+    public Iterator<E> descendingIterator() {\n+        return decorated().descendingIterator();\n+    }\n+\n+    @Override\n+    public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {\n+        final NavigableSet<E> sub = decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n+        return predicatedNavigableSet(sub, predicate);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> headSet(E toElement, boolean inclusive) {\n+        final NavigableSet<E> head = decorated().headSet(toElement, inclusive);\n+        return predicatedNavigableSet(head, predicate);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {\n+        final NavigableSet<E> tail = decorated().tailSet(fromElement, inclusive);\n+        return predicatedNavigableSet(tail, predicate);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java\n  * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n  * <p>\n  * One usage would be to ensure that no null entries are added to the set.\n- * <pre>SortedSet set = PredicatedSortedSet.decorate(new TreeSet(), NotNullPredicate.INSTANCE);</pre>\n+ * <pre>\n+ * SortedSet set =\n+ *   PredicatedSortedSet.predicatedSortedSet(new TreeSet(),\n+ *                                           NotNullPredicate.notNullPredicate());\n+ * </pre>\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  *\n     }\n \n     public SortedSet<E> headSet(final E toElement) {\n-        final SortedSet<E> sub = decorated().headSet(toElement);\n-        return new PredicatedSortedSet<E>(sub, predicate);\n+        final SortedSet<E> head = decorated().headSet(toElement);\n+        return new PredicatedSortedSet<E>(head, predicate);\n     }\n \n     public SortedSet<E> tailSet(final E fromElement) {\n-        final SortedSet<E> sub = decorated().tailSet(fromElement);\n-        return new PredicatedSortedSet<E>(sub, predicate);\n+        final SortedSet<E> tail = decorated().tailSet(fromElement);\n+        return new PredicatedSortedSet<E>(tail, predicate);\n     }\n \n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Iterator;\n+import java.util.NavigableSet;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another <code>NavigableSet</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class TransformedNavigableSet<E> extends TransformedSortedSet<E> implements NavigableSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 20150528L;\n+\n+    /**\n+     * Factory method to create a transforming navigable set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedNavigableSet(NavigableSet, Transformer)}.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed {@link NavigableSet}\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    public static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set,\n+            final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedNavigableSet<E>(set, transformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming navigable set that will transform\n+     * existing contents of the specified navigable set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingNavigableSet(NavigableSet, Transformer)}.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed {@link NavigableSet}\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    public static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set,\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n+        final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);\n+        if (transformer != null && set != null && set.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // set is type E\n+            final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n+            set.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    protected TransformedNavigableSet(final NavigableSet<E> set,\n+                                      final Transformer<? super E, ? extends E> transformer) {\n+        super(set, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated navigable set.\n+     *\n+     * @return the decorated navigable set\n+     */\n+    @Override\n+    protected NavigableSet<E> decorated() {\n+        return (NavigableSet<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public E lower(E e) {\n+        return decorated().lower(e);\n+    }\n+\n+    @Override\n+    public E floor(E e) {\n+        return decorated().floor(e);\n+    }\n+\n+    @Override\n+    public E ceiling(E e) {\n+        return decorated().ceiling(e);\n+    }\n+\n+    @Override\n+    public E higher(E e) {\n+        return decorated().higher(e);\n+    }\n+\n+    @Override\n+    public E pollFirst() {\n+        return decorated().pollFirst();\n+    }\n+\n+    @Override\n+    public E pollLast() {\n+        return decorated().pollLast();\n+    }\n+\n+    @Override\n+    public NavigableSet<E> descendingSet() {\n+        return transformingNavigableSet(decorated().descendingSet(), transformer);\n+    }\n+\n+    @Override\n+    public Iterator<E> descendingIterator() {\n+        return decorated().descendingIterator();\n+    }\n+\n+    @Override\n+    public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {\n+        final NavigableSet<E> sub = decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n+        return transformingNavigableSet(sub, transformer);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> headSet(E toElement, boolean inclusive) {\n+        final NavigableSet<E> head = decorated().headSet(toElement, inclusive);\n+        return transformingNavigableSet(head, transformer);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {\n+        final NavigableSet<E> tail = decorated().tailSet(fromElement, inclusive);\n+        return transformingNavigableSet(tail, transformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NavigableSet;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>NavigableSet</code> to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public final class UnmodifiableNavigableSet<E>\n+        extends AbstractNavigableSetDecorator<E>\n+        implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 20150528L;\n+\n+    /**\n+     * Factory method to create an unmodifiable set.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @return a new unmodifiable {@link NavigableSet}\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n+        if (set instanceof Unmodifiable) {\n+            return set;\n+        }\n+        return new UnmodifiableNavigableSet<E>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    private UnmodifiableNavigableSet(final NavigableSet<E> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    // SortedSet\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(sub);\n+    }\n+\n+    @Override\n+    public SortedSet<E> headSet(final E toElement) {\n+        final SortedSet<E> head = decorated().headSet(toElement);\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(head);\n+    }\n+\n+    @Override\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        final SortedSet<E> tail = decorated().tailSet(fromElement);\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(tail);\n+    }\n+\n+    // NavigableSet\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public NavigableSet<E> descendingSet() {\n+        return unmodifiableNavigableSet(decorated().descendingSet());\n+    }\n+\n+    @Override\n+    public Iterator<E> descendingIterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().descendingIterator());\n+    }\n+\n+    @Override\n+    public NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {\n+        final NavigableSet<E> sub = decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n+        return unmodifiableNavigableSet(sub);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> headSet(E toElement, boolean inclusive) {\n+        final NavigableSet<E> head = decorated().headSet(toElement, inclusive);\n+        return unmodifiableNavigableSet(head);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> tailSet(E fromElement, boolean inclusive) {\n+        final NavigableSet<E> tail = decorated().tailSet(fromElement, inclusive);\n+        return unmodifiableNavigableSet(tail);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(decorated());\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        setCollection((Collection<E>) in.readObject()); // (1)\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Write the collection out using a custom routine.\n-     *\n-     * @param out  the output stream\n-     * @throws IOException\n-     */\n-    private void writeObject(final ObjectOutputStream out) throws IOException {\n-        out.defaultWriteObject();\n-        out.writeObject(decorated());\n-    }\n-\n-    /**\n-     * Read the collection in using a custom routine.\n-     *\n-     * @param in  the input stream\n-     * @throws IOException\n-     * @throws ClassNotFoundException\n-     */\n-    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n-    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        setCollection((Collection<E>) in.readObject()); // (1)\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n     @Override\n     public SortedSet<E> subSet(final E fromElement, final E toElement) {\n         final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n-        return new UnmodifiableSortedSet<E>(sub);\n+        return unmodifiableSortedSet(sub);\n     }\n \n     @Override\n     public SortedSet<E> headSet(final E toElement) {\n-        final SortedSet<E> sub = decorated().headSet(toElement);\n-        return new UnmodifiableSortedSet<E>(sub);\n+        final SortedSet<E> head = decorated().headSet(toElement);\n+        return unmodifiableSortedSet(head);\n     }\n \n     @Override\n     public SortedSet<E> tailSet(final E fromElement) {\n-        final SortedSet<E> sub = decorated().tailSet(fromElement);\n-        return new UnmodifiableSortedSet<E>(sub);\n+        final SortedSet<E> tail = decorated().tailSet(fromElement);\n+        return unmodifiableSortedSet(tail);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(decorated());\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        setCollection((Collection<E>) in.readObject()); // (1)\n     }\n \n }\n--- a/src/main/java/org/apache/commons/collections4/set/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/set/package-info.java\n  * limitations under the License.\n  */\n /**\n- * This package contains implementations of the {@link java.util.Set Set} and\n- * {@link java.util.SortedSet SortedSet} interfaces.\n+ * This package contains implementations of the {@link java.util.Set Set},\n+ * {@link java.util.SortedSet SortedSet} and\n+ * {@link java.util.NavigableSet NavigableSet} interfaces.\n  * <p>\n  * The implementations are in the form of direct implementations and decorators.\n  * A decorator wraps another implementation of the interface to add some\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Iterator;\n+import java.util.NavigableSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections4.BulkTest;\n+\n+/**\n+ * Abstract test class for {@link NavigableSet} methods and contracts.\n+ * <p>\n+ * To use, subclass and override the {@link #makeObject()}\n+ * method.  You may have to override other protected methods if your\n+ * set is not modifiable, or if your set restricts what kinds of\n+ * elements may be added; see {@link AbstractSetTest} for more details.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractNavigableSetTest<E> extends AbstractSortedSetTest<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param name  name for test\n+     */\n+    public AbstractNavigableSetTest(final String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract NavigableSet<E> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public NavigableSet<E> makeFullCollection() {\n+        return (NavigableSet<E>) super.makeFullCollection();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty {@link TreeSet} for use in modification testing.\n+     *\n+     * @return a confirmed empty collection\n+     */\n+    @Override\n+    public NavigableSet<E> makeConfirmedCollection() {\n+        return new TreeSet<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Verification extension, will check the order of elements,\n+     * the sets should already be verified equal.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+\n+        // Check that descending iterator returns elements in order and higher(), lower(),\n+        // floor() and ceiling() are consistent\n+        final Iterator<E> colliter = getCollection().descendingIterator();\n+        final Iterator<E> confiter = getConfirmed().descendingIterator();\n+        while (colliter.hasNext()) {\n+            final E element = colliter.next();\n+            final E confelement = confiter.next();\n+            assertEquals(\"Element appears to be out of order.\", confelement, element);\n+\n+            assertEquals(\"Incorrect element returned by higher().\", getConfirmed().higher(element),\n+                                                                    getCollection().higher(element));\n+\n+            assertEquals(\"Incorrect element returned by lower().\", getConfirmed().lower(element),\n+                                                                   getCollection().lower(element));\n+\n+            assertEquals(\"Incorrect element returned by floor().\", getConfirmed().floor(element),\n+                                                                   getCollection().floor(element));\n+\n+            assertEquals(\"Incorrect element returned by ceiling().\", getConfirmed().ceiling(element),\n+                                                                     getCollection().ceiling(element));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to return comparable objects.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        final Object[] elements = new Object[30];\n+\n+        for (int i = 0; i < 30; i++) {\n+            elements[i] = Integer.valueOf(i + i + 1);\n+        }\n+        return (E[]) elements;\n+    }\n+\n+    /**\n+     * Override to return comparable objects.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n+        final Object[] elements = new Object[30];\n+        for (int i = 0; i < 30; i++) {\n+            elements[i] = Integer.valueOf(i + i + 2);\n+        }\n+        return (E[]) elements;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Bulk test {@link NavigableSet#subSet(Object, boolean, Object, boolean)}.\n+     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractNavigableSetTest} instance for testing a subset.\n+     */\n+    public BulkTest bulkTestNavigableSetSubSet() {\n+        final int length = getFullElements().length;\n+\n+        final int lobound = length / 3;\n+        final int hibound = lobound * 2;\n+        return new TestNavigableSetSubSet(lobound, hibound, false);\n+    }\n+\n+    /**\n+     * Bulk test {@link NavigableSet#headSet(Object, boolean)}.\n+     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractNavigableSetTest} instance for testing a headset.\n+     */\n+    public BulkTest bulkTestNavigableSetHeadSet() {\n+        final int length = getFullElements().length;\n+\n+        final int lobound = length / 3;\n+        final int hibound = lobound * 2;\n+        return new TestNavigableSetSubSet(hibound, true, true);\n+    }\n+\n+    /**\n+     * Bulk test {@link NavigableSet#tailSet(Object, boolean)}.\n+     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractNavigableSetTest} instance for testing a tailset.\n+     */\n+    public BulkTest bulkTestNavigableSetTailSet() {\n+        final int length = getFullElements().length;\n+        final int lobound = length / 3;\n+        return new TestNavigableSetSubSet(lobound, false, false);\n+    }\n+\n+    public class TestNavigableSetSubSet extends AbstractNavigableSetTest<E> {\n+\n+        private int m_Type;\n+        private int m_LowBound;\n+        private int m_HighBound;\n+        private E[] m_FullElements;\n+        private E[] m_OtherElements;\n+        private boolean m_Inclusive;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public TestNavigableSetSubSet(final int bound, final boolean head, final boolean inclusive) {\n+            super(\"TestNavigableSetSubSet\");\n+            if (head) {\n+                m_Type = TYPE_HEADSET;\n+                m_Inclusive = inclusive;\n+                m_HighBound = bound;\n+\n+                final int realBound = inclusive ? bound + 1 : bound;\n+                m_FullElements = (E[]) new Object[realBound];\n+                System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), 0, m_FullElements, 0, realBound);\n+                m_OtherElements = (E[]) new Object[bound - 1];\n+                System.arraycopy(//src src_pos dst dst_pos length\n+                  AbstractNavigableSetTest.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);\n+            } else {\n+                m_Type = TYPE_TAILSET;\n+                m_Inclusive = inclusive;\n+                m_LowBound = bound;\n+                final Object[] allelements = AbstractNavigableSetTest.this.getFullElements();\n+                final int realBound = inclusive ? bound : bound + 1;\n+                m_FullElements = (E[]) new Object[allelements.length - realBound];\n+                System.arraycopy(allelements, realBound, m_FullElements, 0, allelements.length - realBound);\n+                m_OtherElements = (E[]) new Object[allelements.length - bound - 1];\n+                System.arraycopy(//src src_pos dst dst_pos length\n+                  AbstractNavigableSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);\n+            }\n+\n+        } //type\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public TestNavigableSetSubSet(final int lobound, final int hibound, final boolean inclusive) {\n+            super(\"TestNavigableSetSubSet\");\n+            m_Type = TYPE_SUBSET;\n+            m_LowBound = lobound;\n+            m_HighBound = hibound;\n+            m_Inclusive = inclusive;\n+\n+            final int fullLoBound = inclusive ? lobound : lobound + 1;\n+            final int length = hibound - lobound + 1 - (inclusive ? 0 : 2);\n+            m_FullElements = (E[]) new Object[length];\n+            System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, m_FullElements, 0, length);\n+            final int otherLength = hibound - lobound;\n+            m_OtherElements = (E[]) new Object[otherLength - 1];\n+            System.arraycopy(//src src_pos dst dst_pos length\n+              AbstractNavigableSetTest.this.getOtherElements(), lobound, m_OtherElements, 0, otherLength - 1);\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractNavigableSetTest.this.isNullSupported();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return AbstractNavigableSetTest.this.isAddSupported();\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractNavigableSetTest.this.isRemoveSupported();\n+        }\n+        @Override\n+        public boolean isFailFastSupported() {\n+            return AbstractNavigableSetTest.this.isFailFastSupported();\n+        }\n+\n+        @Override\n+        public E[] getFullElements() {\n+            return m_FullElements;\n+        }\n+        @Override\n+        public E[] getOtherElements() {\n+            return m_OtherElements;\n+        }\n+\n+        private NavigableSet<E> getSubSet(final NavigableSet<E> set) {\n+            final E[] elements = AbstractNavigableSetTest.this.getFullElements();\n+            switch (m_Type) {\n+                case TYPE_SUBSET :\n+                    return set.subSet(elements[m_LowBound], m_Inclusive, elements[m_HighBound], m_Inclusive);\n+                case TYPE_HEADSET :\n+                    return set.headSet(elements[m_HighBound], m_Inclusive);\n+                case TYPE_TAILSET :\n+                    return set.tailSet(elements[m_LowBound], m_Inclusive);\n+                default :\n+                    return null;\n+            }\n+        }\n+\n+        @Override\n+        public NavigableSet<E> makeObject() {\n+            return getSubSet(AbstractNavigableSetTest.this.makeObject());\n+        }\n+\n+        @Override\n+        public NavigableSet<E> makeFullCollection() {\n+            return getSubSet(AbstractNavigableSetTest.this.makeFullCollection());\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public BulkTest bulkTestSortedSetSubSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSortedSetHeadSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSortedSetTailSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestNavigableSetSubSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestNavigableSetHeadSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestNavigableSetTailSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+\n+        static final int TYPE_SUBSET = 0;\n+        static final int TYPE_TAILSET = 1;\n+        static final int TYPE_HEADSET = 2;\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public NavigableSet<E> getCollection() {\n+        return (NavigableSet<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public NavigableSet<E> getConfirmed() {\n+        return (NavigableSet<E>) super.getConfirmed();\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\n         final int lobound = length / 3;\n         final int hibound = lobound * 2;\n         return new TestSortedSetSubSet(hibound, true);\n-\n     }\n \n     /**\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/PredicatedNavigableSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.NavigableSet;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractNavigableSetTest} for exercising the\n+ * {@link PredicatedNavigableSet} implementation.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class PredicatedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {\n+\n+    public PredicatedNavigableSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(PredicatedNavigableSetTest.class);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    @Override\n+    public NavigableSet<E> makeObject() {\n+        return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public NavigableSet<E> makeFullCollection() {\n+        final TreeSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return PredicatedNavigableSet.predicatedNavigableSet(set, truePredicate);\n+    }\n+\n+//--------------------------------------------------------------------\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(final E o) {\n+                return o instanceof String && ((String) o).startsWith(\"A\");\n+            }\n+        };\n+\n+    protected PredicatedNavigableSet<E> makeTestSet() {\n+        return PredicatedNavigableSet.predicatedNavigableSet(new TreeSet<E>(), testPredicate);\n+    }\n+\n+    public void testGetSet() {\n+        final PredicatedNavigableSet<E> set = makeTestSet();\n+        assertTrue(\"returned set should not be null\", set.decorated() != null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        final NavigableSet<E> set = makeTestSet();\n+        final String testString = \"B\";\n+        try {\n+            set.add((E) testString);\n+            fail(\"Should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !set.contains(testString));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        final NavigableSet<E> set = makeTestSet();\n+        final Set<E> elements = new TreeSet<E>();\n+        elements.add((E) \"Aone\");\n+        elements.add((E) \"Atwo\");\n+        elements.add((E) \"Bthree\");\n+        elements.add((E) \"Afour\");\n+        try {\n+            set.addAll(elements);\n+            fail(\"Should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Aone\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Atwo\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Bthree\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Afour\"));\n+    }\n+\n+    public void testComparator() {\n+        final NavigableSet<E> set = makeTestSet();\n+        final Comparator<? super E> c = set.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedNavigableSet.emptyCollection.version4.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedNavigableSet.fullCollection.version4.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/TransformedNavigableSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.NavigableSet;\n+import java.util.TreeSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractNavigableSetTest} for exercising the\n+ * {@link TransformedNavigableSet} implementation.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class TransformedNavigableSetTest<E> extends AbstractNavigableSetTest<E> {\n+\n+    public TransformedNavigableSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TransformedNavigableSetTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public NavigableSet<E> makeObject() {\n+        return TransformedNavigableSet.transformingNavigableSet(new TreeSet<E>(),\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public NavigableSet<E> makeFullCollection() {\n+        final NavigableSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return TransformedNavigableSet.transformingNavigableSet(set,\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedSet() {\n+        final NavigableSet<E> set = TransformedNavigableSet.transformingNavigableSet(new TreeSet<E>(),\n+                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, set.size());\n+        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            set.add(els[i]);\n+            assertEquals(i + 1, set.size());\n+            assertEquals(true, set.contains(Integer.valueOf((String) els[i])));\n+        }\n+\n+        assertEquals(true, set.remove(Integer.valueOf((String) els[0])));\n+    }\n+\n+    public void testTransformedSet_decorateTransform() {\n+        final Set<Object> originalSet = new TreeSet<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        Collections.addAll(originalSet, els);\n+        final Set<?> set = TransformedSet.transformedSet(originalSet,\n+                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, set.size());\n+        for (final Object el : els) {\n+            assertEquals(true, set.contains(Integer.valueOf((String) el)));\n+        }\n+\n+        assertEquals(true, set.remove(Integer.valueOf((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedNavigableSet.emptyCollection.version4.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedNavigableSet.fullCollection.version4.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.NavigableSet;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractNavigableSetTest} for exercising the\n+ * {@link UnmodifiableNavigableSet} implementation.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class UnmodifiableNavigableSetTest<E> extends AbstractNavigableSetTest<E> {\n+    protected UnmodifiableNavigableSet<E> set = null;\n+    protected ArrayList<E> array = null;\n+\n+    public UnmodifiableNavigableSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableNavigableSetTest.class);\n+    }\n+\n+    //-------------------------------------------------------------------\n+    @Override\n+    public NavigableSet<E> makeObject() {\n+        return UnmodifiableNavigableSet.unmodifiableNavigableSet(new TreeSet<E>());\n+    }\n+\n+    @Override\n+    public UnmodifiableNavigableSet<E> makeFullCollection() {\n+        final TreeSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return (UnmodifiableNavigableSet<E>) UnmodifiableNavigableSet.unmodifiableNavigableSet(set);\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //--------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    protected void setupSet() {\n+        set = makeFullCollection();\n+        array = new ArrayList<E>();\n+        array.add((E) Integer.valueOf(1));\n+    }\n+\n+    /**\n+     * Verify that base set and subsets are not modifiable\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiable() {\n+        setupSet();\n+        verifyUnmodifiable(set);\n+        verifyUnmodifiable(set.descendingSet());\n+        verifyUnmodifiable(set.headSet((E) Integer.valueOf(1)));\n+        verifyUnmodifiable(set.headSet((E) Integer.valueOf(1), true));\n+        verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1)));\n+        verifyUnmodifiable(set.tailSet((E) Integer.valueOf(1), false));\n+        verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), (E) Integer.valueOf(3)));\n+        verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), false, (E) Integer.valueOf(3), false));\n+        verifyUnmodifiable(set.subSet((E) Integer.valueOf(1), true, (E) Integer.valueOf(3), true));\n+    }\n+\n+    public void testDecorateFactory() {\n+        final NavigableSet<E> set = makeFullCollection();\n+        assertSame(set, UnmodifiableNavigableSet.unmodifiableNavigableSet(set));\n+\n+        try {\n+            UnmodifiableNavigableSet.unmodifiableNavigableSet(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    /**\n+     * Verifies that a set is not modifiable\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void verifyUnmodifiable(final Set<E> set) {\n+        try {\n+            set.add((E) \"value\");\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.addAll(new TreeSet<E>());\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.clear();\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.remove(\"x\");\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.removeAll(array);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.retainAll(array);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testComparator() {\n+        setupSet();\n+        final Comparator<? super E> c = set.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableNavigableSet.emptyCollection.version4.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableNavigableSet.fullCollection.version4.1.obj\");\n+//    }\n+\n+}", "timestamp": 1433097318, "metainfo": ""}