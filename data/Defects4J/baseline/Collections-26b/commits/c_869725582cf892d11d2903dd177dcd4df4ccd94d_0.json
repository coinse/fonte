{"sha": "869725582cf892d11d2903dd177dcd4df4ccd94d", "log": "1.  Collection views are now backed by map. 2.  Used bit-mixing hash function. 3.  Added docs about the non-atomic nature of bulk operations. 4.  Improved performance of size() operation. 5.  Added atomic(Runnable) method.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/StaticBucketMap.java\n+++ b/src/java/org/apache/commons/collections/StaticBucketMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/StaticBucketMap.java,v 1.2 2002/07/10 03:35:32 mas Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/07/10 03:35:32 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/StaticBucketMap.java,v 1.3 2002/08/15 03:22:29 pjack Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/08/15 03:22:29 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.collections;\n \n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n import java.util.ArrayList;\n+import java.util.NoSuchElementException;\n \n /**\n  * A StaticBucketMap is an efficient, thread-safe implementation of\n  * <code>java.util.Map</code> that performs well in in a highly\n  * thread-contentious environment.  The map supports very efficient\n- * <code>get</code>, <code>put</code>, <code>contains</code>, and\n- * <code>remove</code> operations, assuming (approximate) uniform hashing and\n- * that the number of entries does not exceed the size of the map.  If the\n- * number of entries exceeds the size of the map or if the hashcodes of the\n+ * {@link #get(Object) get}, {@link #put(Object,Object) put}, \n+ * {@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\n+ * operations, assuming (approximate) uniform hashing and\n+ * that the number of entries does not exceed the number of buckets.  If the\n+ * number of entries exceeds the number of buckets or if the hashcodes of the\n  * objects are not uniformly distributed, these operations have a worst case\n  * scenario that is proportional to the number of elements in the map\n- * (<I>O(n)</I>).\n+ * (<I>O(n)</I>).<P>\n+ *\n+ * Each bucket in the hash table has its own monitor, so two threads can \n+ * safely operate on the map at the same time, often without incurring any \n+ * monitor contention.  This means that you don't have to wrap instances\n+ * of this class with {@link java.util.Collections#synchronizedMap(Map)};\n+ * instances are already thread-safe.  Unfortunately, however, this means \n+ * that this map implementation behaves in ways you may find disconcerting.  \n+ * Bulk operations, such as {@link #putAll(Map) putAll} or the\n+ * {@link Collection#retainAll(Collection) retainAll} operation in collection \n+ * views, are <I>not</I> atomic.  If two threads are simultaneously \n+ * executing \n+ *\n+ * <Pre>\n+ *   staticBucketMapInstance.putAll(map);\n+ * </Pre>\n+ *\n+ * and\n+ *\n+ * <Pre>\n+ *   staticBucketMapInstance.entrySet().removeAll(map.entrySet());\n+ * </Pre>\n+ *\n+ * then the results are generally random.  Those two statement could cancel\n+ * each other out, leaving <Code>staticBucketMapInstance</Code> essentially \n+ * unchanged, or they could leave some random subset of <Code>map</Code> in \n+ * <Code>staticBucketMapInstance</Code>.<P>\n+ *\n+ * Also, much like an encyclopedia, the results of {@link #size()} and \n+ * {@link #isEmpty()} are out-of-date as soon as they are produced.<P>\n+ *\n+ * The iterators returned by the collection views of this class are <I>not</I>\n+ * fail-fast.  They will <I>never</I> raise a \n+ * {@link java.util.ConcurrentModificationException}.  Keys and values \n+ * added to the map after the iterator is created do not necessarily appear\n+ * during iteration.  Similarly, the iterator does not necessarily fail to \n+ * return keys and values that were removed after the iterator was created.<P>\n+ *\n+ * Finally, unlike {@link java.util.HashMap}-style implementations, this\n+ * class <I>never</I> rehashes the map.  The number of buckets is fixed \n+ * at construction time and never altered.  Performance may degrade if \n+ * you do not allocate enough buckets upfront.<P>\n+ *\n+ * The {@link #atomic(Runnable)} method is provided to allow atomic iterations\n+ * and bulk operations; however, overuse of {@link #atomic(Runnable) atomic}\n+ * will basically result in a map that's slower than an ordinary synchronized\n+ * {@link java.util.HashMap}.\n+ *\n+ * Use this class if you do not require reliable bulk operations and \n+ * iterations, or if you can make your own guarantees about how bulk \n+ * operations will affect the map.<P>\n  *\n  * @author  <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n  * @author  <a href=\"mailto:g-froehlich@gmx.de\">Gerhard Froehlich</a>\n  * @author  <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n- * @version CVS $Revision: 1.2 $ $Date: 2002/07/10 03:35:32 $\n+ * @author  Paul Jack\n+ * @version CVS $Revision: 1.3 $ $Date: 2002/08/15 03:22:29 $\n  * @since Avalon 4.0\n  */\n public final class StaticBucketMap implements Map\n {\n     private static final int DEFAULT_BUCKETS = 255;\n-    private final Node[] m_buckets;\n-    private final Object[] m_locks;\n+    private Node[] m_buckets;\n+    private Lock[] m_locks;\n \n     /**\n      * Initializes the map with the default number of buckets (255).\n      * chances for thread contention.  The fewer buckets, the more chances for\n      * thread contention.  The more buckets the fewer chances for thread\n      * contention.\n+     *\n+     * @param numBuckets  the number of buckets for this map\n      */\n     public StaticBucketMap( int numBuckets )\n     {\n         }\n \n         m_buckets = new Node[ size ];\n-        m_locks = new Object[ size ];\n+        m_locks = new Lock[ size ];\n \n         for( int i = 0; i < size; i++ )\n         {\n-            m_locks[ i ] = new Object();\n+            m_locks[ i ] = new Lock();\n         }\n     }\n \n     private final int getHash( Object key )\n     {\n         if( key == null ) return 0;\n-        final int hash = key.hashCode() % m_buckets.length;\n+        int hash = key.hashCode();\n+        hash += ~(hash << 15);\n+        hash ^= (hash >>> 10);\n+        hash += (hash << 3);\n+        hash ^= (hash >>> 6);\n+        hash += ~(hash << 11);\n+        hash ^= (hash >>> 16);\n+        hash %= m_buckets.length;\n         return ( hash < 0 ) ? hash * -1 : hash;\n     }\n \n     /**\n-     * Obtain a Set for the keys.  This operation crosses bucket boundaries,\n-     * so it is less efficient, and greatly increases the chance for thread\n-     * contention.\n+     *  Returns a set view of this map's keys.\n      */\n     public Set keySet()\n     {\n-        Set keySet = new HashSet();\n+        return new KeySet();\n+    }\n+\n+    /**\n+     * Returns the current number of key, value pairs.\n+     */\n+    public int size()\n+    {\n+        int cnt = 0;\n \n         for( int i = 0; i < m_buckets.length; i++ )\n         {\n-            synchronized( m_locks[ i ] )\n-            {\n-                Node n = m_buckets[ i ];\n-\n-                while( n != null )\n-                {\n-                    keySet.add( n.key );\n-                    n = n.next;\n-                }\n-            }\n-        }\n-\n-        return keySet;\n-    }\n-\n-    /**\n-     * Returns the current number of key, value pairs.\n-     */\n-    public int size()\n-    {\n-        int cnt = 0;\n-\n-        for( int i = 0; i < m_buckets.length; i++ )\n-        {\n-            synchronized( m_locks[ i ] )\n-            {\n-                Node n = m_buckets[ i ];\n-\n-                while( n != null )\n-                {\n-                    cnt++;\n-                    n = n.next;\n-                }\n-            }\n+            cnt += m_locks[i].size;\n         }\n \n         return cnt;\n                 n.key = key;\n                 n.value = value;\n                 m_buckets[ hash ] = n;\n+                m_locks[hash].size++;\n                 return null;\n             }\n \n             newNode.key = key;\n             newNode.value = value;\n             n.next = newNode;\n+            m_locks[hash].size++;\n         }\n \n         return null;\n      */\n     public Collection values()\n     {\n-        ArrayList values = new ArrayList();\n-\n-        for( int i = 0; i < m_buckets.length; i++ )\n-        {\n-            synchronized( m_locks[ i ] )\n-            {\n-                Node n = m_buckets[ i ];\n-\n-                while( n != null )\n-                {\n-                    values.add( n.value );\n-                    n = n.next;\n-                }\n-            }\n-        }\n-\n-        return values;\n+        return new Values();\n     }\n \n     /**\n      */\n     public Set entrySet()\n     {\n-        Set entrySet = new HashSet();\n-\n-        for( int i = 0; i < m_buckets.length; i++ )\n-        {\n-            synchronized( m_locks[ i ] )\n-            {\n-                Node n = m_buckets[ i ];\n-\n-                while( n != null )\n-                {\n-                    entrySet.add( n );\n-                    n = n.next;\n-                }\n-            }\n-        }\n-\n-        return entrySet;\n+        return new EntrySet();\n     }\n \n     /**\n                         // Set the next node of the previous node to be the node after this one.\n                         prev.next = n.next;\n                     }\n-\n+                    m_locks[hash].size--;\n                     return n.value;\n                 }\n \n      */\n     public final boolean isEmpty()\n     {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Removes all the entries from the Map.\n+     */\n+    public final void clear()\n+    {\n         for( int i = 0; i < m_buckets.length; i++ )\n         {\n-            if( m_buckets[ i ] != null )\n-            {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    /**\n-     * Removes all the entries from the Map.\n-     */\n-    public final void clear()\n-    {\n-        for( int i = 0; i < m_buckets.length; i++ )\n-        {\n-            m_buckets[ i ] = null;\n-        }\n-    }\n-\n+            Lock lock = m_locks[i];\n+            synchronized (lock) {\n+                m_buckets[ i ] = null;\n+                lock.size = 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     *  Returns true if the given object is a map with the same mappings\n+     *  as this map.\n+     *\n+     *  @return true if the given object is the a map with same mappings\n+     *   as this map\n+     */\n     public final boolean equals( Object obj )\n     {\n         if( obj == null ) return false;\n         return entrySet().equals(other.entrySet());\n     }\n \n+    /**\n+     *  Returns a hash code for this map.\n+     *\n+     *  @return a hash code for this map\n+     */\n     public final int hashCode() \n     {\n         int hashCode = 0;\n             return retVal;\n         }\n     }\n+\n+    private final static class Lock {\n+\n+        public int size;\n+\n+    }\n+\n+\n+    private class EntryIterator implements Iterator {\n+\n+        private ArrayList current = new ArrayList();\n+        private int bucket;\n+        private Map.Entry last;\n+\n+\n+        public boolean hasNext() {\n+            if (current.size() > 0) return true;\n+            while (bucket < m_buckets.length) {\n+                synchronized (m_locks[bucket]) {\n+                    Node n = m_buckets[bucket];\n+                    while (n != null) {\n+                        current.add(n);\n+                        n = n.next;\n+                    }\n+                    bucket++;\n+                    if (current.size() > 0) return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        protected Map.Entry nextEntry() {\n+            if (!hasNext()) throw new NoSuchElementException();\n+            last = (Map.Entry)current.remove(current.size() - 1);\n+            return last;\n+        }\n+\n+        public Object next() {\n+            return nextEntry();\n+        }\n+\n+        public void remove() {\n+            if (last == null) throw new IllegalStateException();\n+            StaticBucketMap.this.remove(last.getKey());\n+            last = null;\n+        }\n+\n+    }\n+\n+    private class ValueIterator extends EntryIterator {\n+\n+        public Object next() {\n+            return nextEntry().getValue();\n+        }\n+\n+    }\n+\n+    private class KeyIterator extends EntryIterator {\n+\n+        public Object next() {\n+            return nextEntry().getKey();\n+        }\n+\n+    }\n+\n+    private class EntrySet extends AbstractSet {\n+\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntryIterator();\n+        }\n+\n+        public boolean contains(Object o) {\n+            Map.Entry entry = (Map.Entry)o;\n+            int hash = getHash(entry.getKey());\n+            synchronized (m_locks[hash]) {\n+                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public boolean remove(Object o) {\n+            Map.Entry entry = (Map.Entry)o;\n+            int hash = getHash(entry.getKey());\n+            synchronized (m_locks[hash]) {\n+                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) {\n+                        StaticBucketMap.this.remove(n.getKey());\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    private class KeySet extends AbstractSet {\n+\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new KeyIterator();\n+        }\n+\n+        public boolean contains(Object o) {\n+            return StaticBucketMap.this.containsKey(o);\n+        }\n+\n+        public boolean remove(Object o) {\n+            int hash = getHash(o);\n+            synchronized (m_locks[hash]) {\n+                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+                    Object k = n.getKey();\n+                    if ((k == o) || ((k != null) && k.equals(o))) {\n+                        StaticBucketMap.this.remove(k);\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+\n+        }\n+\n+    }\n+\n+\n+    private class Values extends AbstractCollection {\n+\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new ValueIterator();\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Prevents any operations from occuring on this map while the\n+     *  given {@link Runnable} executes.  This method can be used, for\n+     *  instance, to execute a bulk operation atomicly: \n+     *\n+     *  <Pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            staticBucketMapInstance.putAll(map);\n+     *        }\n+     *    });\n+     *  </Pre>\n+     *\n+     *  It can also be used if you need a reliable iterator:\n+     *\n+     *  <Pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            Iterator iterator = staticBucketMapInstance.iterator();\n+     *            while (iterator.hasNext()) {\n+     *                foo(iterator.next();\n+     *            }\n+     *        }\n+     *    });\n+     *  </Pre>\n+     *\n+     *  <B>Implementation note:</B> This method requires a lot of time\n+     *  and a ton of stack space.  Essentially a recursive algorithm is used\n+     *  to enter each bucket's monitor.  If you have twenty thousand buckets\n+     *  in your map, then the recursive method will be invoked twenty thousand\n+     *  times.  You have been warned.\n+     *\n+     *  @param r  the code to execute atomicly\n+     */\n+    public void atomic(Runnable r) {\n+        if (r == null) throw new NullPointerException();\n+        atomic(r, 0);\n+    }\n+\n+    private void atomic(Runnable r, int bucket) {\n+        if (bucket >= m_buckets.length) {\n+            r.run();\n+            return;\n+        }\n+        synchronized (m_locks[bucket]) {\n+            atomic(r, bucket + 1);\n+        }\n+    }\n+\n+\n }", "timestamp": 1029381749, "metainfo": ""}