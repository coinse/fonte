{"sha": "8ffb78ec50a5d3a79dbd0e76c36c50f3263594aa", "log": "MOve to standard Maven layout  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/ArrayStack.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.EmptyStackException;\n+\n+/**\n+ * An implementation of the {@link java.util.Stack} API that is based on an\n+ * <code>ArrayList</code> instead of a <code>Vector</code>, so it is not\n+ * synchronized to protect against multi-threaded access.  The implementation\n+ * is therefore operates faster in environments where you do not need to\n+ * worry about multiple thread contention.\n+ * <p>\n+ * The removal order of an <code>ArrayStack</code> is based on insertion \n+ * order: The most recently added element is removed first.  The iteration\n+ * order is <i>not</i> the same as the removal order.  The iterator returns\n+ * elements from the bottom up, whereas the {@link #remove()} method removes\n+ * them from the top down.\n+ * <p>\n+ * Unlike <code>Stack</code>, <code>ArrayStack</code> accepts null entries.\n+ *\n+ * @see java.util.Stack\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Craig R. McClanahan\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class ArrayStack<E> extends ArrayList<E> implements Buffer<E> {\n+\n+    /** Ensure serialization compatibility */    \n+    private static final long serialVersionUID = 2130079159931574599L;\n+\n+    /**\n+     * Constructs a new empty <code>ArrayStack</code>. The initial size\n+     * is controlled by <code>ArrayList</code> and is currently 10.\n+     */\n+    public ArrayStack() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty <code>ArrayStack</code> with an initial size.\n+     * \n+     * @param initialSize  the initial size to use\n+     * @throws IllegalArgumentException  if the specified initial size\n+     *  is negative\n+     */\n+    public ArrayStack(int initialSize) {\n+        super(initialSize);\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this stack is currently empty.\n+     * <p>\n+     * This method exists for compatibility with <code>java.util.Stack</code>.\n+     * New users of this class should use <code>isEmpty</code> instead.\n+     * \n+     * @return true if the stack is currently empty\n+     */\n+    public boolean empty() {\n+        return isEmpty();\n+    }\n+\n+    /**\n+     * Returns the top item off of this stack without removing it.\n+     *\n+     * @return the top item on the stack\n+     * @throws EmptyStackException  if the stack is empty\n+     */\n+    public E peek() throws EmptyStackException {\n+        int n = size();\n+        if (n <= 0) {\n+            throw new EmptyStackException();\n+        } else {\n+            return get(n - 1);\n+        }\n+    }\n+\n+    /**\n+     * Returns the n'th item down (zero-relative) from the top of this\n+     * stack without removing it.\n+     *\n+     * @param n  the number of items down to go\n+     * @return the n'th item on the stack, zero relative\n+     * @throws EmptyStackException  if there are not enough items on the\n+     *  stack to satisfy this request\n+     */\n+    public E peek(int n) throws EmptyStackException {\n+        int m = (size() - n) - 1;\n+        if (m < 0) {\n+            throw new EmptyStackException();\n+        } else {\n+            return get(m);\n+        }\n+    }\n+\n+    /**\n+     * Pops the top item off of this stack and return it.\n+     *\n+     * @return the top item on the stack\n+     * @throws EmptyStackException  if the stack is empty\n+     */\n+    public E pop() throws EmptyStackException {\n+        int n = size();\n+        if (n <= 0) {\n+            throw new EmptyStackException();\n+        } else {\n+            return remove(n - 1);\n+        }\n+    }\n+\n+    /**\n+     * Pushes a new item onto the top of this stack. The pushed item is also\n+     * returned. This is equivalent to calling <code>add</code>.\n+     *\n+     * @param item  the item to be added\n+     * @return the item just pushed\n+     */\n+    public E push(E item) {\n+        add(item);\n+        return item;\n+    }\n+\n+    /**\n+     * Returns the one-based position of the distance from the top that the\n+     * specified object exists on this stack, where the top-most element is\n+     * considered to be at distance <code>1</code>.  If the object is not\n+     * present on the stack, return <code>-1</code> instead.  The\n+     * <code>equals()</code> method is used to compare to the items\n+     * in this stack.\n+     *\n+     * @param object  the object to be searched for\n+     * @return the 1-based depth into the stack of the object, or -1 if not found\n+     */\n+    public int search(Object object) {\n+        int i = size() - 1;        // Current index\n+        int n = 1;                 // Current distance\n+        while (i >= 0) {\n+            Object current = get(i);\n+            if ((object == null && current == null) ||\n+                (object != null && object.equals(current))) {\n+                return n;\n+            }\n+            i--;\n+            n++;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns the element on the top of the stack.\n+     *\n+     * @return the element on the top of the stack\n+     * @throws BufferUnderflowException  if the stack is empty\n+     */\n+    public E get() {\n+        int size = size();\n+        if (size == 0) {\n+            throw new BufferUnderflowException();\n+        }\n+        return get(size - 1);\n+    }\n+\n+    /**\n+     * Removes the element on the top of the stack.\n+     *\n+     * @return the removed element \n+     * @throws BufferUnderflowException  if the stack is empty\n+     */\n+    public E remove() {\n+        int size = size();\n+        if (size == 0) {\n+            throw new BufferUnderflowException();\n+        }\n+        return remove(size - 1);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Bag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * Defines a collection that counts the number of times an object appears in\n+ * the collection.\n+ * <p>\n+ * Suppose you have a Bag that contains <code>{a, a, b, c}</code>.\n+ * Calling {@link #getCount(Object)} on <code>a</code> would return 2, while\n+ * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n+ * <p>\n+ * <i>NOTE: This interface violates the {@link Collection} contract.</i> \n+ * The behavior specified in many of these methods is <i>not</i> the same\n+ * as the behavior specified by <code>Collection</code>.\n+ * The noncompliant methods are clearly marked with \"(Violation)\".\n+ * Exercise caution when using a bag as a <code>Collection</code>.\n+ * <p>\n+ * This violation resulted from the original specification of this interface.\n+ * In an ideal world, the interface would be changed to fix the problems, however\n+ * it has been decided to maintain backwards compatibility instead.\n+ *\n+ * @param <E> the type held in the bag\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ * @author Stephen Colebourne\n+ */\n+public interface Bag<E> extends Collection<E> {\n+\n+    /**\n+     * Returns the number of occurrences (cardinality) of the given\n+     * object currently in the bag. If the object does not exist in the\n+     * bag, return 0.\n+     * \n+     * @param object  the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    int getCount(Object object);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Adds one copy the specified object to the Bag.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as 1.\n+     * <p>\n+     * Since this method always increases the size of the bag,\n+     * according to the {@link Collection#add(Object)} contract, it \n+     * should always return <code>true</code>.  Since it sometimes returns\n+     * <code>false</code>, this method violates the contract.\n+     *\n+     * @param object  the object to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    boolean add(E object);\n+\n+    /**\n+     * Adds <code>nCopies</code> copies of the specified object to the Bag.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n+     * \n+     * @param object  the object to add\n+     * @param nCopies  the number of copies to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    boolean add(E object, int nCopies);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Removes all occurrences of the given object from the bag.\n+     * <p>\n+     * This will also remove the object from the {@link #uniqueSet()}.\n+     * <p>\n+     * According to the {@link Collection#remove(Object)} method,\n+     * this method should only remove the <i>first</i> occurrence of the\n+     * given object, not <i>all</i> occurrences.\n+     *\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean remove(Object object);\n+\n+    /**\n+     * Removes <code>nCopies</code> copies of the specified object from the Bag.\n+     * <p>\n+     * If the number of copies to remove is greater than the actual number of\n+     * copies in the Bag, no error is thrown.\n+     * \n+     * @param object  the object to remove\n+     * @param nCopies  the number of copies to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean remove(Object object, int nCopies);\n+\n+    /**\n+     * Returns a {@link Set} of unique elements in the Bag.\n+     * <p>\n+     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n+     * \n+     * @return the Set of unique Bag elements\n+     */\n+    Set<E> uniqueSet();\n+\n+    /**\n+     * Returns the total number of items in the bag across all types.\n+     * \n+     * @return the total size of the Bag\n+     */\n+    int size();\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Returns <code>true</code> if the bag contains all elements in\n+     * the given collection, respecting cardinality.  That is, if the\n+     * given collection <code>coll</code> contains <code>n</code> copies\n+     * of a given object, calling {@link #getCount(Object)} on that object must\n+     * be <code>&gt;= n</code> for all <code>n</code> in <code>coll</code>.\n+     * <p>\n+     * The {@link Collection#containsAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * return true if the bag contains at least one of every object contained\n+     * in the given collection.\n+     * \n+     * @param coll  the collection to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    boolean containsAll(Collection<?> coll);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Remove all elements represented in the given collection,\n+     * respecting cardinality.  That is, if the given collection\n+     * <code>coll</code> contains <code>n</code> copies of a given object,\n+     * the bag will have <code>n</code> fewer copies, assuming the bag\n+     * had at least <code>n</code> copies to begin with.\n+     *\n+     * <P>The {@link Collection#removeAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * remove <i>all</i> occurrences of every object contained in the \n+     * given collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean removeAll(Collection<?> coll);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Remove any members of the bag that are not in the given\n+     * collection, respecting cardinality.  That is, if the given\n+     * collection <code>coll</code> contains <code>n</code> copies of a\n+     * given object and the bag has <code>m &gt; n</code> copies, then\n+     * delete <code>m - n</code> copies from the bag.  In addition, if\n+     * <code>e</code> is an object in the bag but\n+     * <code>!coll.contains(e)</code>, then remove <code>e</code> and any\n+     * of its copies.\n+     *\n+     * <P>The {@link Collection#retainAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * keep <i>all</i> occurrences of every object contained in the \n+     * given collection.\n+     *\n+     * @param coll  the collection to retain\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean retainAll(Collection<?> coll);\n+\n+    /**\n+     * Returns an {@link Iterator} over the entire set of members,\n+     * including copies due to cardinality. This iterator is fail-fast\n+     * and will not tolerate concurrent modifications.\n+     * \n+     * @return iterator over all elements in the Bag\n+     */\n+    Iterator<E> iterator();\n+\n+    // The following is not part of the formal Bag interface, however where possible\n+    // Bag implementations should follow these comments.\n+//    /**\n+//     * Compares this Bag to another.\n+//     * This Bag equals another Bag if it contains the same number of occurrences of\n+//     * the same elements.\n+//     * This equals definition is compatible with the Set interface.\n+//     * \n+//     * @param obj  the Bag to compare to\n+//     * @return true if equal\n+//     */\n+//    boolean equals(Object obj);\n+//\n+//    /**\n+//     * Gets a hash code for the Bag compatible with the definition of equals.\n+//     * The hash code is defined as the sum total of a hash code for each element.\n+//     * The per element hash code is defined as\n+//     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>.\n+//     * This hash code definition is compatible with the Set interface.\n+//     * \n+//     * @return the hash code of the Bag\n+//     */\n+//    int hashCode();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/BagUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import org.apache.commons.collections.bag.HashBag;\n+import org.apache.commons.collections.bag.PredicatedBag;\n+import org.apache.commons.collections.bag.PredicatedSortedBag;\n+import org.apache.commons.collections.bag.SynchronizedBag;\n+import org.apache.commons.collections.bag.SynchronizedSortedBag;\n+import org.apache.commons.collections.bag.TransformedBag;\n+import org.apache.commons.collections.bag.TransformedSortedBag;\n+import org.apache.commons.collections.bag.TreeBag;\n+import org.apache.commons.collections.bag.UnmodifiableBag;\n+import org.apache.commons.collections.bag.UnmodifiableSortedBag;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Bag} and {@link SortedBag}\n+ * instances.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date: 2007-07-13 05:39:24 -0500 (Fri, 13 Jul\n+ * 2007) $\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Andrew Freeman\n+ * @author Matthew Hawthorne\n+ */\n+public class BagUtils {\n+\n+    /**\n+     * An empty unmodifiable bag.\n+     */\n+    public static final Bag<Object> EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n+\n+    /**\n+     * An empty unmodifiable sorted bag.\n+     */\n+    public static final Bag<Object> EMPTY_SORTED_BAG = UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n+\n+    /**\n+     * Instantiation of BagUtils is not intended or required. However, some\n+     * tools require an instance to operate.\n+     */\n+    public BagUtils() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n+     * order to guarantee serial access, it is critical that all access to the\n+     * backing bag is accomplished through the returned bag.\n+     * <p>\n+     * It is imperative that the user manually synchronize on the returned bag\n+     * when iterating over it:\n+     * \n+     * <pre>\n+     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n+     * ...\n+     * synchronized(bag) {\n+     *     Iterator i = bag.iterator(); // Must be in synchronized block\n+     *     while (i.hasNext())\n+     *         foo(i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * Failure to follow this advice may result in non-deterministic behavior.\n+     * \n+     * @param bag the bag to synchronize, must not be null\n+     * @return a synchronized bag backed by that bag\n+     * @throws IllegalArgumentException if the Bag is null\n+     */\n+    public static <E> Bag<E> synchronizedBag(Bag<E> bag) {\n+        return SynchronizedBag.synchronizedBag(bag);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the given bag. Any modification attempts\n+     * to the returned bag will raise an {@link UnsupportedOperationException}.\n+     * \n+     * @param bag the bag whose unmodifiable view is to be returned, must not be\n+     * null\n+     * @return an unmodifiable view of that bag\n+     * @throws IllegalArgumentException if the Bag is null\n+     */\n+    public static <E> Bag<E> unmodifiableBag(Bag<E> bag) {\n+        return UnmodifiableBag.unmodifiableBag(bag);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) bag backed by the given bag.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to\n+     * the bag. Trying to add an invalid object results in an\n+     * IllegalArgumentException. It is important not to use the original bag\n+     * after invoking this method, as it is a backdoor for adding invalid\n+     * objects.\n+     * \n+     * @param bag the bag to predicate, must not be null\n+     * @param predicate the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException if the Bag or Predicate is null\n+     */\n+    public static <E> Bag<E> predicatedBag(Bag<E> bag, Predicate<? super E> predicate) {\n+        return PredicatedBag.predicatedBag(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed bag backed by the given bag.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the Bag.\n+     * It is important not to use the original bag after invoking this method,\n+     * as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified bag will not be transformed.\n+     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n+     * \n+     * @param bag the bag to predicate, must not be null\n+     * @param transformer the transformer for the bag, must not be null\n+     * @return a transformed bag backed by the given bag\n+     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     */\n+    public static <E> Bag<E> transformingBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedBag.transformingBag(bag, transformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized (thread-safe) sorted bag backed by the given\n+     * sorted bag. In order to guarantee serial access, it is critical that all\n+     * access to the backing bag is accomplished through the returned bag.\n+     * <p>\n+     * It is imperative that the user manually synchronize on the returned bag\n+     * when iterating over it:\n+     * \n+     * <pre>\n+     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n+     * ...\n+     * synchronized(bag) {\n+     *     Iterator i = bag.iterator(); // Must be in synchronized block\n+     *     while (i.hasNext())\n+     *         foo(i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * Failure to follow this advice may result in non-deterministic behavior.\n+     * \n+     * @param bag the bag to synchronize, must not be null\n+     * @return a synchronized bag backed by that bag\n+     * @throws IllegalArgumentException if the SortedBag is null\n+     */\n+    public static <E> SortedBag<E> synchronizedSortedBag(SortedBag<E> bag) {\n+        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the given sorted bag. Any modification\n+     * attempts to the returned bag will raise an\n+     * {@link UnsupportedOperationException}.\n+     * \n+     * @param bag the bag whose unmodifiable view is to be returned, must not be\n+     * null\n+     * @return an unmodifiable view of that bag\n+     * @throws IllegalArgumentException if the SortedBag is null\n+     */\n+    public static <E> SortedBag<E> unmodifiableSortedBag(SortedBag<E> bag) {\n+        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) sorted bag backed by the given sorted\n+     * bag.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to\n+     * the bag. Trying to add an invalid object results in an\n+     * IllegalArgumentException. It is important not to use the original bag\n+     * after invoking this method, as it is a backdoor for adding invalid\n+     * objects.\n+     * \n+     * @param bag the sorted bag to predicate, must not be null\n+     * @param predicate the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException if the SortedBag or Predicate is null\n+     */\n+    public static <E> SortedBag<E> predicatedSortedBag(SortedBag<E> bag,\n+            Predicate<? super E> predicate) {\n+        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed sorted bag backed by the given bag.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the Bag.\n+     * It is important not to use the original bag after invoking this method,\n+     * as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified bag will not be transformed.\n+     * If you want that behaviour, see {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n+     * \n+     * @param bag the bag to predicate, must not be null\n+     * @param transformer the transformer for the bag, must not be null\n+     * @return a transformed bag backed by the given bag\n+     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     */\n+    public static <E> SortedBag<E> transformingSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n+    }\n+\n+    /**\n+     * Get an empty <code>Bag</code>.\n+     * @param <E>\n+     * @return Bag<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Bag<E> emptyBag() {\n+        return (Bag<E>) EMPTY_BAG;        \n+    }\n+\n+    /**\n+     * Get an empty <code>SortedBag</code>.\n+     * @param <E>\n+     * @return SortedBag<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> SortedBag<E> emptySortedBag() {\n+        return (SortedBag<E>) EMPTY_SORTED_BAG;        \n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/BidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values.\n+ * <p>\n+ * This extended <code>Map</code> represents a mapping where a key may\n+ * lookup a value and a value may lookup a key with equal ease.\n+ * This interface extends <code>Map</code> and so may be used anywhere a map\n+ * is required. The interface provides an inverse map view, enabling\n+ * full access to both directions of the <code>BidiMap</code>.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ * <p>\n+ * This map enforces the restriction that there is a 1:1 relation between\n+ * keys and values, meaning that multiple keys cannot map to the same value. \n+ * This is required so that \"inverting\" the map results in a map without \n+ * duplicate keys. See the {@link #put} method description for more information.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface BidiMap<K, V> extends IterableMap<K, V> {\n+\n+    /**\n+     * Puts the key-value pair into the map, replacing any previous pair.\n+     * <p>\n+     * When adding a key-value pair, the value may already exist in the map\n+     * against a different key. That mapping is removed, to ensure that the\n+     * value only occurs once in the inverse map.\n+     * <pre>\n+     *  BidiMap map1 = new DualHashBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n+     * \n+     *  BidiMap map2 = new DualHashBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n+     * </pre>\n+     *\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the previous value mapped to this key\n+     * \n+     * @throws UnsupportedOperationException if the <code>put</code> method is not supported\n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specified value is inappropriate\n+     * @throws IllegalArgumentException (optional) if the map limits the values\n+     *  in some way and the value was invalid\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     */\n+    V put(K key, V value);\n+\n+    /**\n+     * Gets the key that is currently mapped to the specified value.\n+     * <p>\n+     * If the value is not contained in the map, <code>null</code> is returned.\n+     * <p>\n+     * Implementations should seek to make this method perform equally as well\n+     * as <code>get(Object)</code>.\n+     *\n+     * @param value  the value to find the key for\n+     * @return the mapped key, or <code>null</code> if not found\n+     * \n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specified value is inappropriate\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     */\n+    K getKey(Object value);\n+\n+    /**\n+     * Removes the key-value pair that is currently mapped to the specified\n+     * value (optional operation).\n+     * <p>\n+     * If the value is not contained in the map, <code>null</code> is returned.\n+     * <p>\n+     * Implementations should seek to make this method perform equally as well\n+     * as <code>remove(Object)</code>.\n+     *\n+     * @param value  the value to find the key-value pair for\n+     * @return the key that was removed, <code>null</code> if nothing removed\n+     * \n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specified value is inappropriate\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *  by the implementation\n+     */\n+    K removeValue(Object value);\n+\n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed as a <code>Map</code>.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    BidiMap<V, K> inverseBidiMap();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/BoundedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Defines a collection that is bounded in size.\n+ * <p>\n+ * The size of the collection can vary, but it can never exceed a preset \n+ * maximum number of elements. This interface allows the querying of details\n+ * associated with the maximum number of elements.\n+ *\n+ * @see CollectionUtils#isFull\n+ * @see CollectionUtils#maxSize\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Herve Quiroz\n+ * @author Stephen Colebourne\n+ */\n+public interface BoundedCollection<E> extends Collection<E> {\n+\n+    /**\n+     * Returns true if this collection is full and no new elements can be added.\n+     *\n+     * @return <code>true</code> if the collection is full\n+     */\n+    boolean isFull();\n+\n+    /**\n+     * Gets the maximum size of the collection (the bound).\n+     *\n+     * @return the maximum number of elements the collection can hold\n+     */\n+    int maxSize();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/BoundedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a map that is bounded in size.\n+ * <p>\n+ * The size of the map can vary, but it can never exceed a preset \n+ * maximum number of elements. This interface allows the querying of details\n+ * associated with the maximum number of elements.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface BoundedMap<K, V> extends IterableMap<K, V> {\n+\n+    /**\n+     * Returns true if this map is full and no new elements can be added.\n+     *\n+     * @return <code>true</code> if the map is full\n+     */\n+    boolean isFull();\n+\n+    /**\n+     * Gets the maximum size of the map (the bound).\n+     *\n+     * @return the maximum number of elements the map can hold\n+     */\n+    int maxSize();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Buffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Defines a collection that allows objects to be removed in some well-defined order.\n+ * <p>\n+ * The removal order can be based on insertion order (eg, a FIFO queue or a\n+ * LIFO stack), on access order (eg, an LRU cache), on some arbitrary comparator\n+ * (eg, a priority queue) or on any other well-defined ordering.\n+ * <p>\n+ * Note that the removal order is not necessarily the same as the iteration\n+ * order.  A <code>Buffer</code> implementation may have equivalent removal\n+ * and iteration orders, but this is not required.\n+ * <p>\n+ * This interface does not specify any behavior for \n+ * {@link Object#equals(Object)} and {@link Object#hashCode} methods.  It\n+ * is therefore possible for a <code>Buffer</code> implementation to also\n+ * also implement {@link java.util.List}, {@link java.util.Set} or \n+ * {@link Bag}.\n+ *\n+ * @param <E> the type of the elements in the buffer\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Avalon\n+ * @author Berin Loritsch\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public interface Buffer<E> extends Collection<E> {\n+\n+    /**\n+     * Gets and removes the next object from the buffer.\n+     *\n+     * @return the next object in the buffer, which is also removed\n+     * @throws BufferUnderflowException if the buffer is already empty\n+     */\n+    E remove();\n+\n+    /**\n+     * Gets the next object from the buffer without removing it.\n+     *\n+     * @return the next object in the buffer, which is not removed\n+     * @throws BufferUnderflowException if the buffer is empty\n+     */\n+    E get();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/BufferOverflowException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * The BufferOverflowException is used when the buffer's capacity has been\n+ * exceeded.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Avalon\n+ * @author <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n+ * @author <a href=\"mailto:jefft@apache.org\">Jeff Turner</a>\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class BufferOverflowException extends RuntimeException {\n+    \n+    /** Serialization version */\n+    private static final long serialVersionUID = -3992254982265755876L;\n+\n+    /**\n+     * Constructs a new <code>BufferOverflowException</code>.\n+     */\n+    public BufferOverflowException() {\n+        super();\n+    }\n+\n+    /** \n+     * Construct a new <code>BufferOverflowException</code>.\n+     * \n+     * @param message  the detail message for this exception\n+     */\n+    public BufferOverflowException(String message) {\n+        this(message, null);\n+    }\n+\n+    /** \n+     * Construct a new <code>BufferOverflowException</code>.\n+     * \n+     * @param message  the detail message for this exception\n+     * @param exception  the root cause of the exception\n+     */\n+    public BufferOverflowException(String message, Throwable exception) {\n+        super(message, exception);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/BufferUnderflowException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * The BufferUnderflowException is used when the buffer is already empty.\n+ * <p>\n+ * NOTE: From version 3.0, this exception extends NoSuchElementException.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Avalon\n+ * @author Berin Loritsch\n+ * @author Jeff Turner\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class BufferUnderflowException extends NoSuchElementException {\n+    \n+    /** Serialization version */\n+    private static final long serialVersionUID = 7106567570467436893L;\n+\n+    /**\n+     * Constructs a new <code>BufferUnderflowException</code>.\n+     */\n+    public BufferUnderflowException() {\n+        super();\n+    }\n+\n+    /** \n+     * Construct a new <code>BufferUnderflowException</code>.\n+     * \n+     * @param message  the detail message for this exception\n+     */\n+    public BufferUnderflowException(String message) {\n+        super(message);\n+    }\n+\n+    /** \n+     * Construct a new <code>BufferUnderflowException</code>.\n+     * \n+     * @param message  the detail message for this exception\n+     * @param exception  the root cause of the exception\n+     */\n+    public BufferUnderflowException(String message, Throwable exception) {\n+        super(message);\n+        initCause(exception);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/BufferUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import org.apache.commons.collections.buffer.BlockingBuffer;\n+import org.apache.commons.collections.buffer.BoundedBuffer;\n+import org.apache.commons.collections.buffer.PredicatedBuffer;\n+import org.apache.commons.collections.buffer.SynchronizedBuffer;\n+import org.apache.commons.collections.buffer.TransformedBuffer;\n+import org.apache.commons.collections.buffer.UnmodifiableBuffer;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Buffer} instances.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class BufferUtils {\n+\n+    /**\n+     * An empty unmodifiable buffer.\n+     */\n+    public static final Buffer<Object> EMPTY_BUFFER = UnmodifiableBuffer.unmodifiableBuffer(new ArrayStack<Object>(1));\n+\n+    /**\n+     * <code>BufferUtils</code> should not normally be instantiated.\n+     */\n+    public BufferUtils() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer.\n+     * Much like the synchronized collections returned by\n+     * {@link java.util.Collections}, you must manually synchronize on\n+     * the returned buffer's iterator to avoid non-deterministic behavior:\n+     *\n+     * <pre>\n+     * Buffer b = BufferUtils.synchronizedBuffer(myBuffer);\n+     * synchronized (b) {\n+     *     Iterator i = b.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * @param buffer  the buffer to synchronize, must not be null\n+     * @return a synchronized buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     */\n+    public static <E> Buffer<E> synchronizedBuffer(Buffer<E> buffer) {\n+        return SynchronizedBuffer.synchronizedBuffer(buffer);\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#get()} and {@link Buffer#remove()} operations.\n+     * If the buffer is empty, then the {@link Buffer#get()} and\n+     * {@link Buffer#remove()} operations will block until new elements\n+     * are added to the buffer, rather than immediately throwing a\n+     * <code>BufferUnderflowException</code>.\n+     *\n+     * @param buffer  the buffer to synchronize, must not be null\n+     * @return a blocking buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     */\n+    public static <E> Buffer<E> blockingBuffer(Buffer<E> buffer) {\n+        return BlockingBuffer.blockingBuffer(buffer);\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#get()} and {@link Buffer#remove()} operations\n+     * until <code>timeout</code> expires.  If the buffer is empty, then the\n+     * {@link Buffer#get()} and {@link Buffer#remove()} operations will block\n+     * until new elements are added to the buffer, rather than immediately\n+     * throwing a <code>BufferUnderflowException</code>.\n+     *\n+     * @param buffer  the buffer to synchronize, must not be null\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n+     * @return a blocking buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> Buffer<E> blockingBuffer(Buffer<E> buffer, long timeoutMillis) {\n+        return BlockingBuffer.blockingBuffer(buffer, timeoutMillis);\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#add(Object)} and\n+     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are\n+     * removed from the buffer to allow the object(s) to be added and still\n+     * maintain the maximum size.\n+     *\n+     * @param buffer  the buffer to make bounded,  must not be null\n+     * @param maximumSize  the maximum size\n+     * @return a bounded buffer backed by the given buffer\n+     * @throws IllegalArgumentException if the given buffer is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> Buffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize) {\n+        return BoundedBuffer.boundedBuffer(buffer, maximumSize);\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#add(Object)} and\n+     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are\n+     * removed from the buffer to allow the object(s) to be added and still\n+     * maintain the maximum size or the timeout expires.\n+     *\n+     * @param buffer the buffer to make bounded, must not be null\n+     * @param maximumSize the maximum size\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n+     * @return a bounded buffer backed by the given buffer\n+     * @throws IllegalArgumentException if the given buffer is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> Buffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize, long timeoutMillis) {\n+        return BoundedBuffer.boundedBuffer(buffer, maximumSize, timeoutMillis);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable buffer backed by the given buffer.\n+     *\n+     * @param buffer  the buffer to make unmodifiable, must not be null\n+     * @return an unmodifiable buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     */\n+    public static <E> Buffer<E> unmodifiableBuffer(Buffer<E> buffer) {\n+        return UnmodifiableBuffer.unmodifiableBuffer(buffer);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) buffer backed by the given buffer.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the buffer.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original buffer after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param buffer  the buffer to predicate, must not be null\n+     * @param predicate  the predicate used to evaluate new elements, must not be null\n+     * @return a predicated buffer\n+     * @throws IllegalArgumentException  if the Buffer or Predicate is null\n+     */\n+    public static <E> Buffer<E> predicatedBuffer(Buffer<E> buffer, Predicate<? super E> predicate) {\n+        return PredicatedBuffer.predicatedBuffer(buffer, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed buffer backed by the given buffer.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Buffer. It is important not to use the original buffer after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified buffer will not be transformed.\n+     * If you want that behaviour, see {@link TransformedBuffer#decorateTransform}.\n+     *\n+     * @param buffer  the buffer to predicate, must not be null\n+     * @param transformer  the transformer for the buffer, must not be null\n+     * @return a transformed buffer backed by the given buffer\n+     * @throws IllegalArgumentException  if the Buffer or Transformer is null\n+     */\n+    public static <E> Buffer<E> transformingBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedBuffer.transformingBuffer(buffer, transformer);\n+    }\n+\n+    /**\n+     * Get an empty <code>Buffer</code>.\n+     * @param <E>\n+     * @return Buffer<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Buffer<E> emptyBuffer() {\n+        return (Buffer<E>) EMPTY_BUFFER;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Closure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a functor interface implemented by classes that do something.\n+ * <p>\n+ * A <code>Closure</code> represents a block of code which is executed from\n+ * inside some block, function or iteration. It operates an input object.\n+ * <p>\n+ * Standard implementations of common closures are provided by\n+ * {@link ClosureUtils}. These include method invokation and for/while loops.\n+ *\n+ * @param <T> the type that the closure acts on\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Nicola Ken Barozzi\n+ * @author Stephen Colebourne\n+ */\n+public interface Closure<T> {\n+\n+    /**\n+     * Performs an action on the specified input object.\n+     *\n+     * @param input  the input to execute on\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if any other error occurs\n+     */\n+    public void execute(T input);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/ClosureUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.functors.ChainedClosure;\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionClosure;\n+import org.apache.commons.collections.functors.ForClosure;\n+import org.apache.commons.collections.functors.IfClosure;\n+import org.apache.commons.collections.functors.InvokerTransformer;\n+import org.apache.commons.collections.functors.NOPClosure;\n+import org.apache.commons.collections.functors.SwitchClosure;\n+import org.apache.commons.collections.functors.TransformerClosure;\n+import org.apache.commons.collections.functors.WhileClosure;\n+\n+/**\n+ * <code>ClosureUtils</code> provides reference implementations and utilities\n+ * for the Closure functor interface. The supplied closures are:\n+ * <ul>\n+ * <li>Invoker - invokes a method on the input object\n+ * <li>For - repeatedly calls a closure for a fixed number of times\n+ * <li>While - repeatedly calls a closure while a predicate is true\n+ * <li>DoWhile - repeatedly calls a closure while a predicate is true\n+ * <li>Chained - chains two or more closures together\n+ * <li>Switch - calls one closure based on one or more predicates\n+ * <li>SwitchMap - calls one closure looked up from a Map\n+ * <li>Transformer - wraps a Transformer as a Closure\n+ * <li>NOP - does nothing\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied closures are Serializable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class ClosureUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public ClosureUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a Closure that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections.functors.ExceptionClosure\n+     * \n+     * @return the closure\n+     */\n+    public static <E> Closure<E> exceptionClosure() {\n+        return ExceptionClosure.<E>exceptionClosure();\n+    }\n+\n+    /**\n+     * Gets a Closure that will do nothing.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections.functors.NOPClosure\n+     * \n+     * @return the closure\n+     */\n+    public static <E> Closure<E> nopClosure() {\n+        return NOPClosure.<E>nopClosure();\n+    }\n+\n+    /**\n+     * Creates a Closure that calls a Transformer each time it is called.\n+     * The transformer will be called using the closure's input object.\n+     * The transformer's result will be ignored.\n+     *\n+     * @see org.apache.commons.collections.functors.TransformerClosure\n+     * \n+     * @param transformer  the transformer to run each time in the closure, null means nop\n+     * @return the closure\n+     */\n+    public static <E> Closure<E> asClosure(Transformer<? super E, ?> transformer) {\n+        return TransformerClosure.transformerClosure(transformer);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure <code>count</code> times.\n+     * <p>\n+     * A null closure or zero count returns the <code>NOPClosure</code>.\n+     *\n+     * @see org.apache.commons.collections.functors.ForClosure\n+     * \n+     * @param count  the number of times to loop\n+     * @param closure  the closure to call repeatedly\n+     * @return the <code>for</code> closure\n+     */\n+    public static <E> Closure<E> forClosure(int count, Closure<? super E> closure) {\n+        return ForClosure.forClosure(count, closure);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure repeatedly until the \n+     * predicate returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.WhileClosure\n+     * \n+     * @param predicate  the predicate to use as an end of loop test, not null\n+     * @param closure  the closure to call repeatedly, not null\n+     * @return the <code>while</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static <E> Closure<E> whileClosure(Predicate<? super E> predicate, Closure<? super E> closure) {\n+        return WhileClosure.<E>whileClosure(predicate, closure, false);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure once and then repeatedly\n+     * until the predicate returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.WhileClosure\n+     * \n+     * @param closure  the closure to call repeatedly, not null\n+     * @param predicate  the predicate to use as an end of loop test, not null\n+     * @return the <code>do-while</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static <E> Closure<E> doWhileClosure(Closure<? super E> closure, Predicate<? super E> predicate) {\n+        return WhileClosure.<E>whileClosure(predicate, closure, true);\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the closure's\n+     * input object by reflection.\n+     *\n+     * @see org.apache.commons.collections.functors.InvokerTransformer\n+     * @see org.apache.commons.collections.functors.TransformerClosure\n+     * \n+     * @param methodName  the name of the method\n+     * @return the <code>invoker</code> closure\n+     * @throws IllegalArgumentException if the method name is null\n+     */\n+    public static <E> Closure<E> invokerClosure(String methodName) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the closure's\n+     * input object by reflection.\n+     *\n+     * @see org.apache.commons.collections.functors.InvokerTransformer\n+     * @see org.apache.commons.collections.functors.TransformerClosure\n+     * \n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the <code>invoker</code> closure\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static <E> Closure<E> invokerClosure(String methodName, Class<?>[] paramTypes, Object[] args) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    /**\n+     * Create a new Closure that calls two Closures, passing the result of\n+     * the first into the second.\n+     * \n+     * @see org.apache.commons.collections.functors.ChainedClosure\n+     * \n+     * @param closure1  the first closure\n+     * @param closure2  the second closure\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if either closure is null\n+     */\n+    public static <E> Closure<E> chainedClosure(Closure<? super E> closure1, Closure<? super E> closure2) {\n+        return ChainedClosure.<E>chainedClosure(closure1, closure2);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure.\n+     * \n+     * @see org.apache.commons.collections.functors.ChainedClosure\n+     * \n+     * @param closures  an array of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures array is null\n+     * @throws IllegalArgumentException if any closure in the array is null\n+     */\n+    public static <E> Closure<E> chainedClosure(Closure<? super E>[] closures) {\n+        return ChainedClosure.chainedClosure(closures);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @see org.apache.commons.collections.functors.ChainedClosure\n+     * \n+     * @param closures  a collection of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures collection is null\n+     * @throws IllegalArgumentException if the closures collection is empty\n+     * @throws IllegalArgumentException if any closure in the collection is null\n+     */\n+    public static <E> Closure<E> chainedClosure(Collection<Closure<E>> closures) {\n+        return ChainedClosure.chainedClosure(closures);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls another closure based on the\n+     * result of the specified predicate.\n+     * \n+     * @see org.apache.commons.collections.functors.IfClosure\n+     * \n+     * @param predicate  the validating predicate\n+     * @param trueClosure  the closure called if the predicate is true\n+     * @return the <code>if</code> closure\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if the closure is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+        return IfClosure.<E>ifClosure(predicate, trueClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of two closures depending \n+     * on the specified predicate.\n+     * \n+     * @see org.apache.commons.collections.functors.IfClosure\n+     * \n+     * @param predicate  the predicate to switch on\n+     * @param trueClosure  the closure called if the predicate is true\n+     * @param falseClosure  the closure called if the predicate is false\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either closure is null\n+     */\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n+        return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates.\n+     * <p>\n+     * The closure at array location 0 is called if the predicate at array \n+     * location 0 returned true. Each predicate is evaluated\n+     * until one returns true.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchClosure\n+     * \n+     * @param predicates  an array of predicates to check, not null\n+     * @param closures  an array of closures to call, not null\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures) {\n+        return SwitchClosure.<E>switchClosure(predicates, closures, null);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates.\n+     * <p>\n+     * The closure at array location 0 is called if the predicate at array\n+     * location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchClosure\n+     * \n+     * @param predicates  an array of predicates to check, not null\n+     * @param closures  an array of closures to call, not null\n+     * @param defaultClosure  the default to call if no predicate matches\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n+        return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n+    }\n+    \n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A closure \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called. The default closure is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchClosure\n+     * \n+     * @param predicatesAndClosures  a map of predicates to closures\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static <E> Closure<E> switchClosure(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n+        return SwitchClosure.switchClosure(predicatesAndClosures);\n+    }\n+\n+    /**\n+     * Create a new Closure that uses the input object as a key to find the\n+     * closure to call. \n+     * <p>\n+     * The Map consists of object keys and Closure values. A closure \n+     * is called if the input object equals the key. If there is no match, the\n+     * default closure is called. The default closure is set in the map\n+     * using a null key.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchClosure\n+     * \n+     * @param objectsAndClosures  a map of objects to closures\n+     * @return the closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> switchMapClosure(Map<? extends E, Closure<E>> objectsAndClosures) {\n+        Closure<? super E>[] trs = null;\n+        Predicate<E>[] preds = null;\n+        if (objectsAndClosures == null) {\n+            throw new IllegalArgumentException(\"The object and closure map must not be null\");\n+        }\n+        Closure<? super E> def = objectsAndClosures.remove(null);\n+        int size = objectsAndClosures.size();\n+        trs = new Closure[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n+            preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n+            trs[i] = entry.getValue();\n+            i++;\n+        }\n+        return ClosureUtils.<E>switchClosure(preds, trs, def);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/CollectionUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+import org.apache.commons.collections.collection.UnmodifiableBoundedCollection;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Collection} instances.\n+ * Method parameters will take {@link Iterable} objects when possible.\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Steve Downey\n+ * @author Herve Quiroz\n+ * @author Peter KoBek\n+ * @author Matthew Hawthorne\n+ * @author Janek Bogucki\n+ * @author Phil Steitz\n+ * @author Steven Melzer\n+ * @author Jon Schewe\n+ * @author Neil O'Toole\n+ * @author Stephen Smith\n+ * @author Stephen Kestle\n+ */\n+//TODO - note generic types for review in wiki - especially <?> ones\n+//TODO - doc Cardinality Helpers\n+public class CollectionUtils {\n+\n+    private static class CardinalityHelper<O> {\n+        final Map<O, Integer> cardinalityA, cardinalityB;\n+\n+        public CardinalityHelper(Iterable<? extends O> a, Iterable<? extends O> b) {\n+            cardinalityA = CollectionUtils.<O>getCardinalityMap(a);\n+            cardinalityB = CollectionUtils.<O>getCardinalityMap(b);\n+        }\n+\n+        public final int max(Object obj) {\n+            return Math.max(freqA(obj), freqB(obj));\n+        }\n+\n+        public final int min(Object obj) {\n+            return Math.min(freqA(obj), freqB(obj));\n+        }\n+\n+        public int freqA(Object obj) {\n+            return getFreq(obj, cardinalityA);\n+        }\n+\n+        public int freqB(Object obj) {\n+            return getFreq(obj, cardinalityB);\n+        }\n+\n+        private final int getFreq(final Object obj, final Map<?, Integer> freqMap) {\n+            Integer count = freqMap.get(obj);\n+            if (count != null) {\n+                return count.intValue();\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n+        private final Set<O> elements;\n+        private final List<O> newList;\n+\n+        public SetOperationCardinalityHelper(Iterable<? extends O> a, Iterable<? extends O> b) {\n+            super(a, b);\n+            elements = new HashSet<O>();\n+            addAll(elements, a);\n+            addAll(elements, b);\n+            newList = new ArrayList<O>();\n+        }\n+\n+        public Iterator<O> iterator() {\n+            return elements.iterator();\n+        }\n+\n+        public void setCardinality(O obj, int count) {\n+            for (int i = 0; i < count; i++) {\n+                newList.add(obj);\n+            }\n+        }\n+\n+        public Collection<O> list() {\n+            return newList;\n+        }\n+\n+    }\n+\n+    /**\n+     * An empty unmodifiable collection.\n+     * The JDK provides empty Set and List implementations which could be used for\n+     * this purpose. However they could be cast to Set or List which might be\n+     * undesirable. This implementation only implements Collection.\n+     */\n+    public static final Collection EMPTY_COLLECTION = UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());\n+\n+    /**\n+     * <code>CollectionUtils</code> should not normally be instantiated.\n+     */\n+    public CollectionUtils() {\n+    }\n+\n+    /**\n+     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n+     *\n+     * @see #EMPTY_COLLECTION\n+     * @since 4.0\n+     * @return immutable empty collection\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Collection<T> emptyCollection() {\n+        return EMPTY_COLLECTION;\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the union of the given\n+     * {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection} will\n+     * be equal to the maximum of the cardinality of that element in the two\n+     * given {@link Collection}s.\n+     *\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return the union of the two collections\n+     * @see Collection#addAll\n+     */\n+    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (O obj : helper) {\n+            helper.setCardinality(obj, helper.max(obj));\n+        }\n+        return helper.list();\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the intersection of the given\n+     * {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection} will\n+     * be equal to the minimum of the cardinality of that element in the two\n+     * given {@link Collection}s.\n+     *\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return the intersection of the two collections\n+     * @see Collection#retainAll\n+     * @see #containsAny\n+     */\n+    public static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (O obj : helper) {\n+            helper.setCardinality(obj, helper.min(obj));\n+        }\n+        return helper.list();\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the exclusive disjunction\n+     * (symmetric difference) of the given {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element <i>e</i> in the returned\n+     * {@link Collection} will be equal to\n+     * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>))</tt>.\n+     * <p>\n+     * This is equivalent to\n+     * <tt>{@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})</tt>\n+     * or\n+     * <tt>{@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})</tt>.\n+\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return the symmetric difference of the two collections\n+     */\n+    public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (O obj : helper) {\n+            helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n+        }\n+        return helper.list();\n+    }\n+\n+    /**\n+     * Returns a new {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n+     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n+     * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n+     * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n+     *\n+     * @param a  the collection to subtract from, must not be null\n+     * @param b  the collection to subtract, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return a new collection with the results\n+     * @see Collection#removeAll\n+     */\n+    public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        Predicate<O> p = TruePredicate.truePredicate();\n+        return subtract(a, b, p);\n+    }\n+\n+    /**\n+     * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n+     * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n+     * condition, <i>p</i> are subtracted from <i>a</i>.\n+     *\n+     * @param a  the collection to subtract from, must not be null\n+     * @param b  the collection to subtract, must not be null\n+     * @param p  the condition used to determine which elements of <i>b</i> are\n+     *        subtracted.\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return a new collection with the results\n+     * @since 4.0\n+     * @see Collection#removeAll\n+     */\n+    public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b, final Predicate<O> p) {\n+        ArrayList<O> list = new ArrayList<O>();\n+        addAll(list, a);\n+        for (O element : b) {\n+            if (p.evaluate(element)) {\n+                list.remove(element);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff at least one element is in both collections.\n+     * <p>\n+     * In other words, this method returns <code>true</code> iff the\n+     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n+     *\n+     * @param coll1  the first collection, must not be null\n+     * @param coll2  the first collection, must not be null\n+     * @return <code>true</code> iff the intersection of the collections is non-empty\n+     * @since 2.1\n+     * @see #intersection\n+     */\n+    public static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n+        if (coll1.size() < coll2.size()) {\n+            for (Object aColl1 : coll1) {\n+                if (coll2.contains(aColl1)) {\n+                    return true;\n+                }\n+            }\n+        } else {\n+            for (Object aColl2 : coll2) {\n+                if (coll1.contains(aColl2)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a {@link Map} mapping each unique element in the given\n+     * {@link Collection} to an {@link Integer} representing the number\n+     * of occurrences of that element in the {@link Collection}.\n+     * <p>\n+     * Only those elements present in the collection will appear as\n+     * keys in the map.\n+     *\n+     * @param coll\n+     *            the collection to get the cardinality map for, must not be\n+     *            null\n+     * @param <O>\n+     *            the type of object in the returned {@link Map}. This is a\n+     *            super type of <I>.\n+     * @return the populated cardinality map\n+     */\n+    public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n+        Map<O, Integer> count = new HashMap<O, Integer>();\n+        for (O obj : coll) {\n+            Integer c = count.get(obj);\n+            if (c == null) {\n+                count.put(obj, Integer.valueOf(1));\n+            } else {\n+                count.put(obj, Integer.valueOf(c.intValue() + 1));\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff <i>a</i> is a sub-collection of <i>b</i>,\n+     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n+     * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n+     * in <i>a</i>.\n+     *\n+     * @param a the first (sub?) collection, must not be null\n+     * @param b the second (super?) collection, must not be null\n+     * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n+     * @see #isProperSubCollection\n+     * @see Collection#containsAll\n+     */\n+    public static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n+        CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n+        for (Object obj : a) {\n+            if (helper.freqA(obj) > helper.freqB(obj)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n+     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n+     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i>, and there is at least one\n+     * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n+     * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n+     * <p>\n+     * The implementation assumes\n+     * <ul>\n+     *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n+     *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n+     *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n+     * </ul>\n+     *\n+     * @param a  the first (sub?) collection, must not be null\n+     * @param b  the second (super?) collection, must not be null\n+     * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n+     * @see #isSubCollection\n+     * @see Collection#containsAll\n+     */\n+    public static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n+        return (a.size() < b.size()) && CollectionUtils.isSubCollection(a, b);\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n+     * exactly the same elements with exactly the same cardinalities.\n+     * <p>\n+     * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n+     * equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n+     *\n+     * @param a  the first collection, must not be null\n+     * @param b  the second collection, must not be null\n+     * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n+     */\n+    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n+        if(a.size() != b.size()) {\n+            return false;\n+        }\n+        final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n+        if(helper.cardinalityA.size() != helper.cardinalityB.size()) {\n+            return false;\n+        }\n+        for( Object obj : helper.cardinalityA.keySet()) {\n+            if(helper.freqA(obj) != helper.freqB(obj)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n+     *\n+     * @param obj the object to find the cardinality of\n+     * @param coll the {@link Iterable} to search\n+     * @param <O> the type of object that the {@link Iterable} may contain.\n+     * @return the the number of occurrences of obj in coll\n+     */\n+    public static <O> int cardinality(O obj, final Iterable<? super O> coll) {\n+        if (coll instanceof Set<?>) {\n+            return (((Set<? super O>) coll).contains(obj) ? 1 : 0);\n+        }\n+        if (coll instanceof Bag<?>) {\n+            return ((Bag<? super O>) coll).getCount(obj);\n+        }\n+        int count = 0;\n+        if (obj == null) {\n+            for (Object element : coll) {\n+                if (element == null) {\n+                    count++;\n+                }\n+            }\n+        } else {\n+            for (Object element : coll) {\n+                if (obj.equals(element)) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Finds the first element in the given collection which matches the given predicate.\n+     * <p>\n+     * If the input collection or predicate is null, or no element of the collection\n+     * matches the predicate, null is returned.\n+     *\n+     * @param collection  the collection to search, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return the first element of the collection which matches the predicate or null if none could be found\n+     */\n+    public static <T> T find(Collection<T> collection, Predicate<? super T> predicate) {\n+        if (collection != null && predicate != null) {\n+            for (T item : collection) {\n+                if (predicate.evaluate(item)) {\n+                    return item;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Executes the given closure on each element in the collection.\n+     * <p>\n+     * If the input collection or closure is null, there is no change made.\n+     *\n+     * @param collection\n+     *            the collection to get the input from, may be null\n+     * @param closure\n+     *            the closure to perform, may be null\n+     * @return closure\n+     */\n+    public static <T, C extends Closure<? super T>> C forAllDo(Collection<T> collection, C closure) {\n+        if (collection != null && closure != null) {\n+            for (T element : collection) {\n+                closure.execute(element);\n+            }\n+        }\n+        return closure;\n+    }\n+\n+    /**\n+     * Filter the collection by applying a Predicate to each element. If the\n+     * predicate returns false, remove the element.\n+     * <p>\n+     * If the input collection or predicate is null, there is no change made.\n+     * \n+     * @param collection\n+     *            the collection to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use as a filter, may be null\n+     * @return true if the collection is modified by this call, false otherwise.\n+     */\n+    public static <T> boolean filter(Iterable<T> collection, Predicate<? super T> predicate) {\n+        boolean result = false;\n+        if (collection != null && predicate != null) {\n+            for (Iterator<T> it = collection.iterator(); it.hasNext();) {\n+                if (!predicate.evaluate(it.next())) {\n+                    it.remove();\n+                    result = true;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Transform the collection by applying a Transformer to each element.\n+     * <p>\n+     * If the input collection or transformer is null, there is no change made.\n+     * <p>\n+     * This routine is best for Lists, for which set() is used to do the\n+     * transformations \"in place.\" For other Collections, clear() and addAll()\n+     * are used to replace elements.\n+     * <p>\n+     * If the input collection controls its input, such as a Set, and the\n+     * Transformer creates duplicates (or are otherwise invalid), the collection\n+     * may reduce in size due to calling this method.\n+     *\n+     * @param collection\n+     *            the {@link Iterable} to get the input from, may be null\n+     * @param transformer\n+     *            the transformer to perform, may be null\n+     */\n+    public static <C> void transform(Collection<C> collection,\n+            Transformer<? super C, ? extends C> transformer) {\n+        if (collection != null && transformer != null) {\n+            if (collection instanceof List<?>) {\n+                List<C> list = (List<C>) collection;\n+                for (ListIterator<C> it = list.listIterator(); it.hasNext();) {\n+                    it.set(transformer.transform(it.next()));\n+                }\n+            } else {\n+                Collection<C> resultCollection = collect(collection, transformer);\n+                collection.clear();\n+                collection.addAll(resultCollection);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Counts the number of elements in the input collection that match the\n+     * predicate.\n+     * <p>\n+     * A <code>null</code> collection or predicate matches no elements.\n+     *\n+     * @param input\n+     *            the {@link Iterable} to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @return the number of matches for the predicate in the collection\n+     */\n+    public static <C> int countMatches(Iterable<C> input, Predicate<? super C> predicate) {\n+        int count = 0;\n+        if (input != null && predicate != null) {\n+            for (C o : input) {\n+                if (predicate.evaluate(o)) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Answers true if a predicate is true for at least one element of a\n+     * collection.\n+     * <p>\n+     * A <code>null</code> collection or predicate returns false.\n+     *\n+     * @param input\n+     *            the {@link Iterable} to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @return true if at least one element of the collection matches the\n+     *         predicate\n+     */\n+    public static <C> boolean exists(Iterable<C> input, Predicate<? super C> predicate) {\n+        if (input != null && predicate != null) {\n+            for (C o : input) {\n+                if (predicate.evaluate(o)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Selects all elements from input collection which match the given\n+     * predicate into an output collection.\n+     * <p>\n+     * A <code>null</code> predicate matches no elements.\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @return the elements matching the predicate (new list)\n+     * @throws NullPointerException\n+     *             if the input collection is null\n+     */\n+    public static <O> Collection<O> select(Collection<? extends O> inputCollection,\n+            Predicate<? super O> predicate) {\n+        return select(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Selects all elements from input collection which match the given\n+     * predicate and adds them to outputCollection.\n+     * <p>\n+     * If the input collection or predicate is null, there is no change to the\n+     * output collection.\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @param outputCollection\n+     *            the collection to output into, may not be null\n+     * @return outputCollection\n+     */\n+    public static <O, R extends Collection<? super O>> R select(Collection<? extends O> inputCollection,\n+            Predicate<? super O> predicate, R outputCollection) {\n+        if (inputCollection != null && predicate != null) {\n+            for (O item : inputCollection) {\n+                if (predicate.evaluate(item)) {\n+                    outputCollection.add(item);\n+                }\n+            }\n+        }\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Selects all elements from inputCollection which don't match the given\n+     * predicate into an output collection.\n+     * <p>\n+     * If the input predicate is <code>null</code>, the result is an empty\n+     * list.\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @return the elements <b>not</b> matching the predicate (new list)\n+     * @throws NullPointerException\n+     *             if the input collection is null\n+     */\n+    public static <O> Collection<O> selectRejected(Collection<? extends O> inputCollection,\n+            Predicate<? super O> predicate) {\n+        return selectRejected(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Selects all elements from inputCollection which don't match the given\n+     * predicate and adds them to outputCollection.\n+     * <p>\n+     * If the input predicate is <code>null</code>, no elements are added to\n+     * <code>outputCollection</code>.\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @param outputCollection\n+     *            the collection to output into, may not be null\n+     * @return outputCollection\n+     */\n+    public static <O, R extends Collection<? super O>> R selectRejected(\n+            Collection<? extends O> inputCollection, Predicate<? super O> predicate, R outputCollection) {\n+        if (inputCollection != null && predicate != null) {\n+            for (O item : inputCollection) {\n+                if (!predicate.evaluate(item)) {\n+                    outputCollection.add(item);\n+                }\n+            }\n+        }\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Returns a new Collection consisting of the elements of inputCollection\n+     * transformed by the given transformer.\n+     * <p>\n+     * If the input transformer is null, the result is an empty list.\n+     *\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param transformer\n+     *            the transformer to use, may be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @return the transformed result (new list)\n+     * @throws NullPointerException\n+     *             if the input collection is null\n+     */\n+    public static <I, O> Collection<O> collect(Iterable<I> inputCollection,\n+            Transformer<? super I, ? extends O> transformer) {\n+        ArrayList<O> answer = new ArrayList<O>();\n+        collect(inputCollection, transformer, answer);\n+        return answer;\n+    }\n+\n+    /**\n+     * Transforms all elements from the inputIterator with the given transformer\n+     * and adds them to the outputCollection.\n+     * <p>\n+     * If the input iterator or transformer is null, the result is an empty\n+     * list.\n+     *\n+     * @param inputIterator\n+     *            the iterator to get the input from, may be null\n+     * @param transformer\n+     *            the transformer to use, may be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @return the transformed result (new list)\n+     */\n+    public static <I, O> Collection<O> collect(Iterator<I> inputIterator,\n+            Transformer<? super I, ? extends O> transformer) {\n+        ArrayList<O> answer = new ArrayList<O>();\n+        collect(inputIterator, transformer, answer);\n+        return answer;\n+    }\n+\n+    /**\n+     * Transforms all elements from inputCollection with the given transformer\n+     * and adds them to the outputCollection.\n+     * <p>\n+     * If the input collection or transformer is null, there is no change to the\n+     * output collection.\n+     *\n+     * @param inputCollection  the collection to get the input from, may be null\n+     * @param transformer  the transformer to use, may be null\n+     * @param outputCollection  the collection to output into, may not be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @param <R> the output type of the transformer - this extends O.\n+     * @return the outputCollection with the transformed input added\n+     * @throws NullPointerException if the output collection is null\n+     */\n+    public static <I, O, R extends Collection<? super O>> R collect(Iterable<? extends I> inputCollection,\n+            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n+        if (inputCollection != null) {\n+            return collect(inputCollection.iterator(), transformer, outputCollection);\n+        }\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Transforms all elements from the inputIterator with the given transformer\n+     * and adds them to the outputCollection.\n+     * <p>\n+     * If the input iterator or transformer is null, there is no change to the\n+     * output collection.\n+     *\n+     * @param inputIterator  the iterator to get the input from, may be null\n+     * @param transformer  the transformer to use, may be null\n+     * @param outputCollection  the collection to output into, may not be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @param <R> the output type of the transformer - this extends O.\n+     * @return the outputCollection with the transformed input added\n+     * @throws NullPointerException if the output collection is null\n+     */\n+    //TODO - deprecate and replace with IteratorIterable\n+    public static <I, O, R extends Collection<? super O>> R collect(Iterator<? extends I> inputIterator,\n+            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n+        if (inputIterator != null && transformer != null) {\n+            while (inputIterator.hasNext()) {\n+                I item = inputIterator.next();\n+                O value = transformer.transform(item);\n+                outputCollection.add(value);\n+            }\n+        }\n+        return outputCollection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds an element to the collection unless the element is null.\n+     *\n+     * @param collection  the collection to add to, must not be null\n+     * @param object  the object to add, if null it will not be added\n+     * @return true if the collection changed\n+     * @throws NullPointerException if the collection is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <T> boolean addIgnoreNull(Collection<T> collection, T object) {\n+        return (object != null && collection.add(object));\n+    }\n+\n+    /**\n+     * Adds all elements in the {@link Iterable} to the given collection. If the\n+     * {@link Iterable} is a {@link Collection} then it is cast and will be\n+     * added using {@link Collection#addAll(Collection)} instead of iterating.\n+     *\n+     * @param collection\n+     *            the collection to add to, must not be null\n+     * @param iterable\n+     *            the iterable of elements to add, must not be null\n+     * @return a boolean indicating whether the collection has changed or not.\n+     * @throws NullPointerException\n+     *             if the collection or iterator is null\n+     */\n+    public static <C> boolean addAll(Collection<C> collection, Iterable<? extends C> iterable) {\n+        if (iterable instanceof Collection<?>) {\n+            return collection.addAll((Collection<? extends C>) iterable);\n+        }\n+        return addAll(collection, iterable.iterator());\n+    }\n+\n+    /**\n+     * Adds all elements in the iteration to the given collection.\n+     *\n+     * @param collection\n+     *            the collection to add to, must not be null\n+     * @param iterator\n+     *            the iterator of elements to add, must not be null\n+     * @return a boolean indicating whether the collection has changed or not.\n+     * @throws NullPointerException\n+     *             if the collection or iterator is null\n+     */\n+    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {\n+        boolean changed = false;\n+        while (iterator.hasNext()) {\n+            changed |= collection.add(iterator.next());\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Adds all elements in the enumeration to the given collection.\n+     *\n+     * @param collection  the collection to add to, must not be null\n+     * @param enumeration  the enumeration of elements to add, must not be null\n+     * @throws NullPointerException if the collection or enumeration is null\n+     */\n+    public static <C> boolean addAll(Collection<C> collection, Enumeration<? extends C> enumeration) {\n+        boolean changed = false;\n+        while (enumeration.hasMoreElements()) {\n+            changed |= collection.add(enumeration.nextElement());\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Adds all elements in the array to the given collection.\n+     *\n+     * @param collection\n+     *            the collection to add to, must not be null\n+     * @param elements\n+     *            the array of elements to add, must not be null\n+     * @throws NullPointerException\n+     *             if the collection or array is null\n+     */\n+    public static <C> boolean addAll(Collection<C> collection, C[] elements) {\n+        boolean changed = false;\n+        for (int i = 0, size = elements.length; i < size; i++) {\n+            changed |= collection.add(elements[i]);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * The Iterator is advanced to\n+     *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n+     *      number of entries) as a side effect of this method.</li>\n+     *\n+     * @param iterator  the iterator to get a value from\n+     * @param index  the index to get\n+     * @param <T> the type of object in the {@link Iterator}\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @throws IllegalArgumentException if the object type is invalid\n+     */\n+    public static <T> T get(Iterator<T> iterator, int index) {\n+        int i = index;\n+        checkIndexBounds(i);\n+            while (iterator.hasNext()) {\n+                i--;\n+                if (i == -1) {\n+                    return iterator.next();\n+                }\n+                iterator.next();\n+            }\n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+    }\n+\n+    /**\n+     * Ensures an index is not negative.\n+     * @param index the index to check.\n+     * @throws IndexOutOfBoundsException if the index is negative.\n+     */\n+    private static void checkIndexBounds(int index) {\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * <p>\n+     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n+     *\n+     * @param iterable  the {@link Iterable} to get a value from\n+     * @param index  the index to get\n+     * @param <T> the type of object in the {@link Iterable}.\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public static <T> T get(Iterable<T> iterable, int index) {\n+        checkIndexBounds(index);\n+        if (iterable instanceof List<?>) {\n+            return ((List<T>) iterable).get(index);\n+        }\n+        return get(iterable.iterator(), index);\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in <code>object</code>, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element or\n+     * <code>IllegalArgumentException</code> if <code>object</code> is not an\n+     * instance of one of the supported types.\n+     * <p>\n+     * The supported types, and associated semantics are:\n+     * <ul>\n+     * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n+     *      <code>index</code> in the map's <code>entrySet</code> iterator,\n+     *      if there is such an entry.</li>\n+     * <li> List -- this method is equivalent to the list's get method.</li>\n+     * <li> Array -- the <code>index</code>-th array entry is returned,\n+     *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n+     *      is thrown.</li>\n+     * <li> Collection -- the value returned is the <code>index</code>-th object\n+     *      returned by the collection's default iterator, if there is such an element.</li>\n+     * <li> Iterator or Enumeration -- the value returned is the\n+     *      <code>index</code>-th object in the Iterator/Enumeration, if there\n+     *      is such an element.  The Iterator/Enumeration is advanced to\n+     *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n+     *      number of entries) as a side effect of this method.</li>\n+     * </ul>\n+     *\n+     * @param object  the object to get a value from\n+     * @param index  the index to get\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @throws IllegalArgumentException if the object type is invalid\n+     */\n+    public static Object get(Object object, int index) {\n+        int i = index;\n+        if (i < 0) {\n+            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n+        }\n+        if (object instanceof Map<?,?>) {\n+            Map<?, ?> map = (Map<?, ?>) object;\n+            Iterator<?> iterator = map.entrySet().iterator();\n+            return get(iterator, i);\n+        } else if (object instanceof Object[]) {\n+            return ((Object[]) object)[i];\n+        } else if (object instanceof Iterator<?>) {\n+            Iterator<?> it = (Iterator<?>) object;\n+            while (it.hasNext()) {\n+                i--;\n+                if (i == -1) {\n+                    return it.next();\n+                }\n+                it.next();\n+            }\n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+        } else if (object instanceof Collection<?>) {\n+            Iterator<?> iterator = ((Collection<?>) object).iterator();\n+            return get(iterator, i);\n+        } else if (object instanceof Enumeration<?>) {\n+            Enumeration<?> it = (Enumeration<?>) object;\n+            while (it.hasMoreElements()) {\n+                i--;\n+                if (i == -1) {\n+                    return it.nextElement();\n+                } else {\n+                    it.nextElement();\n+                }\n+            }\n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+        } else if (object == null) {\n+            throw new IllegalArgumentException(\"Unsupported object type: null\");\n+        } else {\n+            try {\n+                return Array.get(object, i);\n+            } catch (IllegalArgumentException ex) {\n+                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     *\n+     * @param map  the object to get a value from\n+     * @param index  the index to get\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public static <K,V> Map.Entry<K, V> get(Map<K,V> map, int index) {\n+        checkIndexBounds(index);\n+        return get(map.entrySet(), index);\n+    }\n+\n+    /**\n+     * Gets the size of the collection/iterator specified.\n+     * <p>\n+     * This method can handles objects as follows\n+     * <ul>\n+     * <li>Collection - the collection size\n+     * <li>Map - the map size\n+     * <li>Array - the array size\n+     * <li>Iterator - the number of elements remaining in the iterator\n+     * <li>Enumeration - the number of elements remaining in the enumeration\n+     * </ul>\n+     *\n+     * @param object  the object to get the size of, may be null\n+     * @return the size of the specified collection or 0 if the object was null\n+     * @throws IllegalArgumentException thrown if object is not recognised\n+     * @since Commons Collections 3.1\n+     */\n+    public static int size(Object object) {\n+        if (object == null) {\n+            return 0;\n+        }\n+        int total = 0;\n+        if (object instanceof Map<?,?>) {\n+            total = ((Map<?, ?>) object).size();\n+        } else if (object instanceof Collection<?>) {\n+            total = ((Collection<?>) object).size();\n+        } else if (object instanceof Object[]) {\n+            total = ((Object[]) object).length;\n+        } else if (object instanceof Iterator<?>) {\n+            Iterator<?> it = (Iterator<?>) object;\n+            while (it.hasNext()) {\n+                total++;\n+                it.next();\n+            }\n+        } else if (object instanceof Enumeration<?>) {\n+            Enumeration<?> it = (Enumeration<?>) object;\n+            while (it.hasMoreElements()) {\n+                total++;\n+                it.nextElement();\n+            }\n+        } else {\n+            try {\n+                total = Array.getLength(object);\n+            } catch (IllegalArgumentException ex) {\n+                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n+            }\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Checks if the specified collection/array/iterator is empty.\n+     * <p>\n+     * This method can handles objects as follows\n+     * <ul>\n+     * <li>Collection - via collection isEmpty\n+     * <li>Map - via map isEmpty\n+     * <li>Array - using array size\n+     * <li>Iterator - via hasNext\n+     * <li>Enumeration - via hasMoreElements\n+     * </ul>\n+     * <p>\n+     * Note: This method is named to avoid clashing with\n+     * {@link #isEmpty(Collection)}.\n+     *\n+     * @param object  the object to get the size of, may be null\n+     * @return true if empty or null\n+     * @throws IllegalArgumentException thrown if object is not recognised\n+     * @since Commons Collections 3.2\n+     */\n+    public static boolean sizeIsEmpty(Object object) {\n+        if (object == null) {\n+            return true;\n+        } else if (object instanceof Collection<?>) {\n+            return ((Collection<?>) object).isEmpty();\n+        } else if (object instanceof Map<?, ?>) {\n+            return ((Map<?, ?>) object).isEmpty();\n+        } else if (object instanceof Object[]) {\n+            return ((Object[]) object).length == 0;\n+        } else if (object instanceof Iterator<?>) {\n+            return ((Iterator<?>) object).hasNext() == false;\n+        } else if (object instanceof Enumeration<?>) {\n+            return ((Enumeration<?>) object).hasMoreElements() == false;\n+        } else {\n+            try {\n+                return Array.getLength(object) == 0;\n+            } catch (IllegalArgumentException ex) {\n+                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Null-safe check if the specified collection is empty.\n+     * <p>\n+     * Null returns true.\n+     *\n+     * @param coll  the collection to check, may be null\n+     * @return true if empty or null\n+     * @since Commons Collections 3.2\n+     */\n+    public static boolean isEmpty(Collection<?> coll) {\n+        return (coll == null || coll.isEmpty());\n+    }\n+\n+    /**\n+     * Null-safe check if the specified collection is not empty.\n+     * <p>\n+     * Null returns false.\n+     *\n+     * @param coll  the collection to check, may be null\n+     * @return true if non-null and non-empty\n+     * @since Commons Collections 3.2\n+     */\n+    public static boolean isNotEmpty(Collection<?> coll) {\n+        return !isEmpty(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverses the order of the given array.\n+     *\n+     * @param array  the array to reverse\n+     */\n+    public static void reverseArray(Object[] array) {\n+        int i = 0;\n+        int j = array.length - 1;\n+        Object tmp;\n+\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * Returns true if no more elements can be added to the Collection.\n+     * <p>\n+     * This method uses the {@link BoundedCollection} interface to determine the\n+     * full status. If the collection does not implement this interface then\n+     * false is returned.\n+     * <p>\n+     * The collection does not have to implement this interface directly.\n+     * If the collection has been decorated using the decorators subpackage\n+     * then these will be removed to access the BoundedCollection.\n+     *\n+     * @param coll  the collection to check\n+     * @return true if the BoundedCollection is full\n+     * @throws NullPointerException if the collection is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static boolean isFull(Collection<?> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+        if (coll instanceof BoundedCollection) {\n+            return ((BoundedCollection<?>) coll).isFull();\n+        }\n+        try {\n+            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n+            return bcoll.isFull();\n+        } catch (IllegalArgumentException ex) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Get the maximum number of elements that the Collection can contain.\n+     * <p>\n+     * This method uses the {@link BoundedCollection} interface to determine the\n+     * maximum size. If the collection does not implement this interface then\n+     * -1 is returned.\n+     * <p>\n+     * The collection does not have to implement this interface directly.\n+     * If the collection has been decorated using the decorators subpackage\n+     * then these will be removed to access the BoundedCollection.\n+     *\n+     * @param coll  the collection to check\n+     * @return the maximum size of the BoundedCollection, -1 if no maximum size\n+     * @throws NullPointerException if the collection is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static int maxSize(Collection<?> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+        if (coll instanceof BoundedCollection) {\n+            return ((BoundedCollection<?>) coll).maxSize();\n+        }\n+        try {\n+            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n+            return bcoll.maxSize();\n+        } catch (IllegalArgumentException ex) {\n+            return -1;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a collection containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n+     *\n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <C> Collection<C> retainAll(Collection<C> collection, Collection<?> retain) {\n+        return ListUtils.retainAll(collection, retain);\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a collection containing all the elements in <code>c</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     *\n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.3 (method existed in 3.2 but was completely broken)\n+     */\n+    public static <E> Collection<E> removeAll(Collection<E> collection, Collection<?> remove) {\n+        return ListUtils.removeAll(collection, remove);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized collection backed by the given collection.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to\n+     * avoid non-deterministic behavior:\n+     *\n+     * <pre>\n+     * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n+     * synchronized (c) {\n+     *     Iterator i = c.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param collection  the collection to synchronize, must not be null\n+     * @return a synchronized collection backed by the given collection\n+     * @throws IllegalArgumentException  if the collection is null\n+     */\n+    public static <C> Collection<C> synchronizedCollection(Collection<C> collection) {\n+        return SynchronizedCollection.synchronizedCollection(collection);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable collection backed by the given collection.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param collection  the collection to make unmodifiable, must not be null\n+     * @return an unmodifiable collection backed by the given collection\n+     * @throws IllegalArgumentException  if the collection is null\n+     */\n+    public static <C> Collection<C> unmodifiableCollection(Collection<C> collection) {\n+        return UnmodifiableCollection.unmodifiableCollection(collection);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) collection backed by the given collection.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the collection.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original collection after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param collection  the collection to predicate, must not be null\n+     * @param predicate  the predicate for the collection, must not be null\n+     * @param <C> the type of objects in the Collection.\n+     * @return a predicated collection backed by the given collection\n+     * @throws IllegalArgumentException  if the Collection is null\n+     */\n+    public static <C> Collection<C> predicatedCollection(Collection<C> collection, Predicate<? super C> predicate) {\n+        return PredicatedCollection.predicatedCollection(collection, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed bag backed by the given collection.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Collection. It is important not to use the original collection after invoking this\n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified collection will not be transformed.\n+     * If you want that behaviour, see {@link TransformedCollection#decorateTransform}.\n+     *\n+     * @param collection  the collection to predicate, must not be null\n+     * @param transformer  the transformer for the collection, must not be null\n+     * @return a transformed collection backed by the given collection\n+     * @throws IllegalArgumentException  if the Collection or Transformer is null\n+     */\n+    public static <E> Collection<E> transformingCollection(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedCollection.transformingCollection(collection, transformer);\n+    }\n+\n+    /**\n+     * Extract the lone element of the specified Collection.\n+     * @param <E> collection type\n+     * @param collection to read\n+     * @return sole member of collection\n+     * @throws IllegalArgumentException if collection is null/empty or contains more than one element\n+     */\n+    public static <E> E extractSingleton(Collection<E> collection) {\n+        if (collection == null || collection.size() != 1) {\n+            throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n+        }\n+        return collection.iterator().next();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/ComparatorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.comparators.BooleanComparator;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ComparatorChain;\n+import org.apache.commons.collections.comparators.NullComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+import org.apache.commons.collections.comparators.TransformingComparator;\n+\n+/**\n+ * Provides convenient static utility methods for <Code>Comparator</Code>\n+ * objects.\n+ * <p>\n+ * Most of the functionality in this class can also be found in the \n+ * <code>comparators</code> package. This class merely provides a \n+ * convenient central place if you have use for more than one class\n+ * in the <code>comparators</code> subpackage.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class ComparatorUtils {\n+\n+    /**\n+     * ComparatorUtils should not normally be instantiated.\n+     */\n+    public ComparatorUtils() {\n+    }\n+\n+    /**\n+     * Comparator for natural sort order.\n+     *\n+     * @see ComparableComparator#getInstance\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();\n+\n+    /**\n+     * Gets a comparator that uses the natural order of the objects.\n+     *\n+     * @return  a comparator which uses natural order\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n+        return NATURAL_COMPARATOR;\n+    }\n+\n+    /**\n+     * Gets a comparator that compares using two {@link Comparator}s.\n+     * <p>\n+     * The second comparator is used if the first comparator returns equal.\n+     *\n+     * @param comparator1  the first comparator to use, not null\n+     * @param comparator2  the first comparator to use, not null\n+     * @return a {@link ComparatorChain} formed from the two comparators\n+     * @throws NullPointerException if either comparator is null\n+     * @see ComparatorChain\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Comparator<E> comparator1, Comparator<E> comparator2) {\n+        return chainedComparator(new Comparator[] {comparator1, comparator2});\n+    }\n+\n+    /**\n+     * Gets a comparator that compares using an array of {@link Comparator}s, applied\n+     * in sequence until one returns not equal or the array is exhausted.\n+     *\n+     * @param comparators  the comparators to use, not null or empty or containing nulls\n+     * @return a {@link ComparatorChain} formed from the input comparators\n+     * @throws NullPointerException if comparators array is null or contains a null\n+     * @see ComparatorChain\n+     */\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Comparator<E>[] comparators) {\n+        ComparatorChain<E> chain = new ComparatorChain<E>();\n+        for (int i = 0; i < comparators.length; i++) {\n+            if (comparators[i] == null) {\n+                throw new NullPointerException(\"Comparator cannot be null\");\n+            }\n+            chain.addComparator(comparators[i]);\n+        }\n+        return chain;\n+    }\n+\n+    /**\n+     * Gets a comparator that compares using a collection of {@link Comparator}s,\n+     * applied in (default iterator) sequence until one returns not equal or the \n+     * collection is exhausted.\n+     *\n+     * @param comparators  the comparators to use, not null or empty or containing nulls\n+     * @return a {@link ComparatorChain} formed from the input comparators\n+     * @throws NullPointerException if comparators collection is null or contains a null\n+     * @throws ClassCastException if the comparators collection contains the wrong object type\n+     * @see ComparatorChain\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Collection<Comparator<E>> comparators) {\n+        return chainedComparator(\n+            (Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()])\n+        );\n+    }\n+\n+    /**\n+     * Gets a comparator that reverses the order of the given comparator.\n+     *\n+     * @param comparator  the comparator to reverse\n+     * @return  a comparator that reverses the order of the input comparator\n+     * @see ReverseComparator\n+     */\n+    public static <E> Comparator<E> reversedComparator(Comparator<E> comparator) {\n+        return new ReverseComparator<E>(comparator);\n+    }\n+\n+    /**\n+     * Gets a Comparator that can sort Boolean objects.\n+     * <p>\n+     * The parameter specifies whether true or false is sorted first.\n+     * <p>\n+     * The comparator throws NullPointerException if a null value is compared.\n+     * \n+     * @param trueFirst  when <code>true</code>, sort \n+     *        <code>true</code> {@link Boolean}s before\n+     *        <code>false</code> {@link Boolean}s.\n+     * @return  a comparator that sorts booleans\n+     */\n+    public static Comparator<Boolean> booleanComparator(boolean trueFirst) {\n+        return BooleanComparator.booleanComparator(trueFirst);\n+    }\n+    \n+    /**\n+     * Gets a Comparator that controls the comparison of <code>null</code> values.\n+     * <p>\n+     * The returned comparator will consider a null value to be less than\n+     * any nonnull value, and equal to any other null value.  Two nonnull\n+     * values will be evaluated with the given comparator.\n+     *\n+     * @param comparator the comparator that wants to allow nulls\n+     * @return  a version of that comparator that allows nulls\n+     * @see NullComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new NullComparator<E>(comparator, false);\n+    }\n+\n+    /**\n+     * Gets a Comparator that controls the comparison of <code>null</code> values.\n+     * <p>\n+     * The returned comparator will consider a null value to be greater than\n+     * any nonnull value, and equal to any other null value.  Two nonnull\n+     * values will be evaluated with the given comparator.\n+     *\n+     * @param comparator the comparator that wants to allow nulls\n+     * @return  a version of that comparator that allows nulls\n+     * @see NullComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new NullComparator<E>(comparator, true);\n+    }\n+\n+    /**\n+     * Gets a Comparator that passes transformed objects to the given comparator.\n+     * <p>\n+     * Objects passed to the returned comparator will first be transformed\n+     * by the given transformer before they are compared by the given\n+     * comparator.\n+     *\n+     * @param comparator  the sort order to use\n+     * @param transformer  the transformer to use\n+     * @return  a comparator that transforms its input objects before comparing them\n+     * @see  TransformingComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> transformedComparator(Comparator<E> comparator, Transformer<? super E, ? extends E> transformer) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new TransformingComparator<E>(transformer, comparator);\n+    }\n+\n+    /**\n+     *  Returns the smaller of the given objects according to the given \n+     *  comparator, returning the second object if the comparator\n+     *  returns equal.\n+     * \n+     *  @param o1  the first object to compare\n+     *  @param o2  the second object to compare\n+     *  @param comparator  the sort order to use\n+     *  @return  the smaller of the two objects\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E min(E o1, E o2, Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        int c = comparator.compare(o1, o2);\n+        return (c < 0) ? o1 : o2;\n+    }\n+\n+    /**\n+     *  Returns the larger of the given objects according to the given \n+     *  comparator, returning the second object if the comparator \n+     *  returns equal.\n+     * \n+     *  @param o1  the first object to compare\n+     *  @param o2  the second object to compare\n+     *  @param comparator  the sort order to use\n+     *  @return  the larger of the two objects\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E max(E o1, E o2, Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        int c = comparator.compare(o1, o2);\n+        return (c > 0) ? o1 : o2;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/EnumerationUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.collections.iterators.EnumerationIterator;\n+\n+/**\n+ * Provides utility methods for {@link Enumeration} instances.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Id$\n+ *\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ */\n+public class EnumerationUtils {\n+\n+    /**\n+     * EnumerationUtils is not normally instantiated.\n+     */\n+    public EnumerationUtils() {\n+        // no init.\n+    }\n+    \n+    /**\n+     * Creates a list based on an enumeration.\n+     * \n+     * <p>As the enumeration is traversed, an ArrayList of its values is\n+     * created. The new list is returned.</p>\n+     *\n+     * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n+     * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n+     */\n+    public static <E> List<E> toList(Enumeration<E> enumeration) {\n+        return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n+    }\n+\n+    /**\n+     * Override toList(Enumeration) for StringTokenizer as it implements Enumeration<String>\n+     * for the sake of backward compatibility.\n+     * @param stringTokenizer\n+     * @return List<String>\n+     */\n+    public static List<String> toList(StringTokenizer stringTokenizer) {\n+        List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n+        while (stringTokenizer.hasMoreTokens()) {\n+            result.add(stringTokenizer.nextToken());\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/ExtendedProperties.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.LineNumberReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.UnsupportedEncodingException;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+import java.util.Vector;\n+\n+/**\n+ * This class extends normal Java properties by adding the possibility\n+ * to use the same key many times concatenating the value strings\n+ * instead of overwriting them.\n+ * <p>\n+ * <b>Please consider using the\n+ * {@link org.apache.commons.configuration.PropertiesConfiguration} class in\n+ * <a href=\"http://commons.apache.org/configuration\">Commons Configuration</a>.\n+ * It's an evolution of <code>ExtendedProperties</code> supporting more\n+ * features like automatic reloading, advanced interpolation, more type\n+ * conversions, changes notifications and file layout preservation.</b>\n+ * <p>\n+ * The Extended Properties syntax is explained here:\n+ *\n+ * <ul>\n+ *  <li>\n+ *   Each property has the syntax <code>key = value</code>\n+ *  </li>\n+ *  <li>\n+ *   The <i>key</i> may use any character but the equal sign '='.\n+ *  </li>\n+ *  <li>\n+ *   <i>value</i> may be separated on different lines if a backslash\n+ *   is placed at the end of the line that continues below.\n+ *  </li>\n+ *  <li>\n+ *   If <i>value</i> is a list of strings, each token is separated\n+ *   by a comma ','.\n+ *  </li>\n+ *  <li>\n+ *   Commas in each token are escaped placing a backslash right before\n+ *   the comma.\n+ *  </li>\n+ *  <li>\n+ *   Backslashes are escaped by using two consecutive backslashes i.e. \\\\\n+ *  </li>\n+ *  <li>\n+ *   If a <i>key</i> is used more than once, the values are appended\n+ *   as if they were on the same line separated with commas.\n+ *  </li>\n+ *  <li>\n+ *   Blank lines and lines starting with character '#' are skipped.\n+ *  </li>\n+ *  <li>\n+ *   If a property is named \"include\" (or whatever is defined by\n+ *   setInclude() and getInclude() and the value of that property is\n+ *   the full path to a file on disk, that file will be included into\n+ *   the ConfigurationsRepository. You can also pull in files relative\n+ *   to the parent configuration file. So if you have something\n+ *   like the following:\n+ *\n+ *   include = additional.properties\n+ *\n+ *   Then \"additional.properties\" is expected to be in the same\n+ *   directory as the parent configuration file.\n+ *\n+ *   Duplicate name values will be replaced, so be careful.\n+ *\n+ *  </li>\n+ * </ul>\n+ *\n+ * <p>Here is an example of a valid extended properties file:\n+ *\n+ * <p><pre>\n+ *      # lines starting with # are comments\n+ *\n+ *      # This is the simplest property\n+ *      key = value\n+ *\n+ *      # A long property may be separated on multiple lines\n+ *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n+ *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+ *\n+ *      # This is a property with many tokens\n+ *      tokens_on_a_line = first token, second token\n+ *\n+ *      # This sequence generates exactly the same result\n+ *      tokens_on_multiple_lines = first token\n+ *      tokens_on_multiple_lines = second token\n+ *\n+ *      # commas may be escaped in tokens\n+ *      commas.escaped = Hi\\, what'up?\n+ * </pre>\n+ *\n+ * <p><b>NOTE</b>: this class has <b>not</b> been written for\n+ * performance nor low memory usage.  In fact, it's way slower than it\n+ * could be and generates too much memory garbage.  But since\n+ * performance is not an issue during intialization (and there is not\n+ * much time to improve it), I wrote it this way.  If you don't like\n+ * it, go ahead and tune it up!\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n+ * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n+ * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n+ * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n+ * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n+ * @author <a href=\"mailto:kjohnson@transparent.com\">Kent Johnson</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ * @author <a href=\"mailto:ipriha@surfeu.fi\">Ilkka Priha</a>\n+ * @author Janek Bogucki\n+ * @author Mohan Kishore\n+ * @author Stephen Colebourne\n+ * @author Shinobu Kawai\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ */\n+public class ExtendedProperties extends Hashtable<String, Object> {\n+\n+    private static final long serialVersionUID = -4064305575636043822L;\n+\n+    /**\n+     * Default configurations repository.\n+     */\n+    private ExtendedProperties defaults;\n+\n+    /**\n+     * The file connected to this repository (holding comments and\n+     * such).\n+     *\n+     * @serial\n+     */\n+    protected String file;\n+\n+    /**\n+     * Base path of the configuration file used to create\n+     * this ExtendedProperties object.\n+     */\n+    protected String basePath;\n+\n+    /**\n+     * File separator.\n+     */\n+    protected String fileSeparator = System.getProperty(\"file.separator\");\n+\n+    /**\n+     * Has this configuration been intialized.\n+     */\n+    protected boolean isInitialized = false;\n+\n+    /**\n+     * This is the name of the property that can point to other\n+     * properties file for including other properties files.\n+     */\n+    private String includePropertyName = \"include\";\n+\n+    /**\n+     * These are the keys in the order they listed\n+     * in the configuration file. This is useful when\n+     * you wish to perform operations with configuration\n+     * information in a particular order.\n+     */\n+    protected ArrayList<String> keysAsListed = new ArrayList<String>();\n+\n+    protected final static String START_TOKEN=\"${\";\n+    protected final static String END_TOKEN=\"}\";\n+\n+\n+    /**\n+     * Interpolate key names to handle ${key} stuff\n+     *\n+     * @param base string to interpolate\n+     * @return returns the key name with the ${key} substituted\n+     */\n+    protected String interpolate(String base) {\n+        // COPIED from [configuration] 2003-12-29\n+        return (interpolateHelper(base, null));\n+    }\n+\n+    /**\n+     * Recursive handler for multiple levels of interpolation.\n+     *\n+     * When called the first time, priorVariables should be null.\n+     *\n+     * @param base string with the ${key} variables\n+     * @param priorVariables serves two purposes: to allow checking for\n+     * loops, and creating a meaningful exception message should a loop\n+     * occur.  It's 0'th element will be set to the value of base from\n+     * the first call.  All subsequent interpolated variables are added\n+     * afterward.\n+     *\n+     * @return the string with the interpolation taken care of\n+     */\n+    protected String interpolateHelper(String base, List<String> priorVariables) {\n+        // COPIED from [configuration] 2003-12-29\n+        if (base == null) {\n+            return null;\n+        }\n+\n+        // on the first call initialize priorVariables\n+        // and add base as the first element\n+        if (priorVariables == null) {\n+            priorVariables = new ArrayList<String>();\n+            priorVariables.add(base);\n+        }\n+\n+        int begin = -1;\n+        int end = -1;\n+        int prec = 0 - END_TOKEN.length();\n+        String variable = null;\n+        StringBuilder result = new StringBuilder();\n+\n+        // FIXME: we should probably allow the escaping of the start token\n+        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n+            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n+            result.append(base.substring(prec + END_TOKEN.length(), begin));\n+            variable = base.substring(begin + START_TOKEN.length(), end);\n+\n+            // if we've got a loop, create a useful exception message and throw\n+            if (priorVariables.contains(variable)) {\n+                String initialBase = priorVariables.remove(0).toString();\n+                priorVariables.add(variable);\n+                StringBuilder priorVariableSb = new StringBuilder();\n+\n+                // create a nice trace of interpolated variables like so:\n+                // var1->var2->var3\n+                for (Iterator<?> it = priorVariables.iterator(); it.hasNext();) {\n+                    priorVariableSb.append(it.next());\n+                    if (it.hasNext()) {\n+                        priorVariableSb.append(\"->\");\n+                    }\n+                }\n+\n+                throw new IllegalStateException(\n+                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb);\n+            }\n+            // otherwise, add this variable to the interpolation list.\n+            else {\n+                priorVariables.add(variable);\n+            }\n+\n+            //QUESTION: getProperty or getPropertyDirect\n+            Object value = getProperty(variable);\n+            if (value != null) {\n+                result.append(interpolateHelper(value.toString(), priorVariables));\n+\n+                // pop the interpolated variable off the stack\n+                // this maintains priorVariables correctness for\n+                // properties with multiple interpolations, e.g.\n+                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n+                priorVariables.remove(priorVariables.size() - 1);\n+            } else if (defaults != null && defaults.getString(variable, null) != null) {\n+                result.append(defaults.getString(variable));\n+            } else {\n+                //variable not defined - so put it back in the value\n+                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n+            }\n+            prec = end;\n+        }\n+        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n+\n+        return result.toString();\n+    }\n+    \n+    /**\n+     * Inserts a backslash before every comma and backslash. \n+     */\n+    private static String escape(String s) {\n+        StringBuilder buf = new StringBuilder(s);\n+        for (int i = 0; i < buf.length(); i++) {\n+            char c = buf.charAt(i);\n+            if (c == ',' || c == '\\\\') {\n+                buf.insert(i, '\\\\');\n+                i++;\n+            }\n+        }\n+        return buf.toString();\n+    }\n+    \n+    /**\n+     * Removes a backslash from every pair of backslashes. \n+     */\n+    private static String unescape(String s) {\n+        StringBuilder buf = new StringBuilder(s);\n+        for (int i = 0; i < buf.length() - 1; i++) {\n+            char c1 = buf.charAt(i);\n+            char c2 = buf.charAt(i + 1);\n+            if (c1 == '\\\\' && c2 == '\\\\') {\n+                buf.deleteCharAt(i);\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Counts the number of successive times 'ch' appears in the\n+     * 'line' before the position indicated by the 'index'.\n+     */\n+    private static int countPreceding(String line, int index, char ch) {\n+        int i;\n+        for (i = index - 1; i >= 0; i--) {\n+            if (line.charAt(i) != ch) {\n+                break;\n+            }\n+        }\n+        return index - 1 - i;\n+    }\n+\n+    /**\n+     * Checks if the line ends with odd number of backslashes \n+     */\n+    private static boolean endsWithSlash(String line) {\n+        if (!line.endsWith(\"\\\\\")) {\n+            return false;\n+        }\n+        return (countPreceding(line, line.length() - 1, '\\\\') % 2 == 0);\n+    }\n+\n+    /**\n+     * This class is used to read properties lines.  These lines do\n+     * not terminate with new-line chars but rather when there is no\n+     * backslash sign a the end of the line.  This is used to\n+     * concatenate multiple lines for readability.\n+     */\n+    static class PropertiesReader extends LineNumberReader {\n+        /**\n+         * Constructor.\n+         *\n+         * @param reader A Reader.\n+         */\n+        public PropertiesReader(Reader reader) {\n+            super(reader);\n+        }\n+\n+        /**\n+         * Read a property.\n+         *\n+         * @return a String property\n+         * @throws IOException if there is difficulty reading the source.\n+         */\n+        public String readProperty() throws IOException {\n+            StringBuilder buffer = new StringBuilder();\n+            String line = readLine();\n+            while (line != null) {\n+                line = line.trim();\n+                if ((line.length() != 0) && (line.charAt(0) != '#')) {\n+                    if (endsWithSlash(line)) {\n+                        line = line.substring(0, line.length() - 1);\n+                        buffer.append(line);\n+                    } else {\n+                        buffer.append(line);\n+                        return buffer.toString();  // normal method end\n+                    }\n+                }\n+                line = readLine();\n+            }\n+            return null;  // EOF reached\n+        }\n+    }\n+\n+    /**\n+     * This class divides into tokens a property value.  Token\n+     * separator is \",\" but commas into the property value are escaped\n+     * using the backslash in front.\n+     */\n+    static class PropertiesTokenizer extends StringTokenizer {\n+        /**\n+         * The property delimiter used while parsing (a comma).\n+         */\n+        static final String DELIMITER = \",\";\n+\n+        /**\n+         * Constructor.\n+         *\n+         * @param string A String.\n+         */\n+        public PropertiesTokenizer(String string) {\n+            super(string, DELIMITER);\n+        }\n+\n+        /**\n+         * Check whether the object has more tokens.\n+         *\n+         * @return True if the object has more tokens.\n+         */\n+        @Override\n+        public boolean hasMoreTokens() {\n+            return super.hasMoreTokens();\n+        }\n+\n+        /**\n+         * Get next token.\n+         *\n+         * @return A String.\n+         */\n+        @Override\n+        public String nextToken() {\n+            StringBuilder buffer = new StringBuilder();\n+\n+            while (hasMoreTokens()) {\n+                String token = super.nextToken();\n+                if (endsWithSlash(token)) {\n+                    buffer.append(token.substring(0, token.length() - 1));\n+                    buffer.append(DELIMITER);\n+                } else {\n+                    buffer.append(token);\n+                    break;\n+                }\n+            }\n+\n+            return buffer.toString().trim();\n+        }\n+    }\n+\n+    /**\n+     * Creates an empty extended properties object.\n+     */\n+    public ExtendedProperties() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates and loads the extended properties from the specified file.\n+     *\n+     * @param file  the filename to load\n+     * @throws IOException if a file error occurs\n+     */\n+    public ExtendedProperties(String file) throws IOException {\n+        this(file, null);\n+    }\n+\n+    /**\n+     * Creates and loads the extended properties from the specified file.\n+     *\n+     * @param file  the filename to load\n+     * @param defaultFile  a second filename to load default values from\n+     * @throws IOException if a file error occurs\n+     */\n+    public ExtendedProperties(String file, String defaultFile) throws IOException {\n+        this.file = file;\n+\n+        basePath = new File(file).getAbsolutePath();\n+        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n+\n+        FileInputStream in = null;\n+        try {\n+            in = new FileInputStream(file);\n+            this.load(in);\n+        } finally {\n+            try {\n+                if (in != null) {\n+                    in.close();\n+                }\n+            } catch (IOException ex) {}\n+        }\n+\n+        if (defaultFile != null) {\n+            defaults = new ExtendedProperties(defaultFile);\n+        }\n+    }\n+\n+    /**\n+     * Indicate to client code whether property\n+     * resources have been initialized or not.\n+     */\n+    public boolean isInitialized() {\n+        return isInitialized;\n+    }\n+\n+    /**\n+     * Gets the property value for including other properties files.\n+     * By default it is \"include\".\n+     *\n+     * @return the property name which includes another property\n+     */\n+    public String getInclude() {\n+        return includePropertyName;\n+    }\n+\n+    /**\n+     * Sets the property value for including other properties files.\n+     * By default it is \"include\".\n+     *\n+     * @param inc  the property name which includes another property, empty converted to null\n+     */\n+    public void setInclude(String inc) {\n+        includePropertyName = inc;\n+    }\n+\n+    /**\n+     * Load the properties from the given input stream.\n+     *\n+     * @param input  the InputStream to load from\n+     * @throws IOException if an IO error occurs\n+     */\n+    public void load(InputStream input) throws IOException {\n+        load(input, null);\n+    }\n+\n+    /**\n+     * Load the properties from the given input stream\n+     * and using the specified encoding.\n+     *\n+     * @param input  the InputStream to load from\n+     * @param enc  the encoding to use\n+     * @throws IOException if an IO error occurs\n+     */\n+    public synchronized void load(InputStream input, String enc) throws IOException {\n+        PropertiesReader reader = null;\n+        if (enc != null) {\n+            try {\n+                reader = new PropertiesReader(new InputStreamReader(input, enc));\n+                \n+            } catch (UnsupportedEncodingException ex) {\n+                // Another try coming up....\n+            }\n+        }\n+        \n+        if (reader == null) {\n+            try {\n+                reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n+                \n+            } catch (UnsupportedEncodingException ex) {\n+                // ISO8859-1 support is required on java platforms but....\n+                // If it's not supported, use the system default encoding\n+                reader = new PropertiesReader(new InputStreamReader(input));\n+            }\n+        }\n+\n+        try {\n+            String includeProperty = getInclude();\n+            while (true) {\n+                String line = reader.readProperty();\n+                if (line == null) {\n+                    return;  // EOF\n+                }\n+                int equalSign = line.indexOf('=');\n+\n+                if (equalSign > 0) {\n+                    String key = line.substring(0, equalSign).trim();\n+                    String value = line.substring(equalSign + 1).trim();\n+\n+                    /* COLLECTIONS-238 allows empty properties to exist by commenting this out\n+                    // Configure produces lines like this ... just ignore them\n+                    if (\"\".equals(value)) {\n+                        continue;\n+                    }\n+                    */\n+\n+                    if (includeProperty != null && key.equalsIgnoreCase(includeProperty)) {\n+                        // Recursively load properties files.\n+                        File file;\n+\n+                        if (value.startsWith(fileSeparator)) {\n+                            // We have an absolute path so we'll use this\n+                            file = new File(value);\n+                            \n+                        } else {\n+                            // We have a relative path, and we have two \n+                            // possible forms here. If we have the \"./\" form\n+                            // then just strip that off first before continuing.\n+                            if (value.startsWith(\".\" + fileSeparator)) {\n+                                value = value.substring(2);\n+                            }\n+\n+                            file = new File(basePath + value);\n+                        }\n+\n+                        if (file.exists() && file.canRead()) {\n+                            load(new FileInputStream(file));\n+                        }\n+                    } else {\n+                        addProperty(key, value);\n+                    }\n+                }\n+            }\n+        } finally {\n+            // Loading is initializing\n+            isInitialized = true;\n+        }\n+    }\n+\n+    /**\n+     * Gets a property from the configuration.\n+     *\n+     * @param key property to retrieve\n+     * @return value as object. Will return user value if exists,\n+     *        if not then default value if exists, otherwise null\n+     */\n+    public Object getProperty(String key) {\n+        // first, try to get from the 'user value' store\n+        Object obj = super.get(key);\n+\n+        if (obj == null) {\n+            // if there isn't a value there, get it from the\n+            // defaults if we have them\n+            if (defaults != null) {\n+                obj = defaults.get(key);\n+            }\n+        }\n+\n+        return obj;\n+    }\n+    \n+    /**\n+     * Add a property to the configuration. If it already\n+     * exists then the value stated here will be added\n+     * to the configuration entry. For example, if\n+     *\n+     * <code>resource.loader = file</code>\n+     *\n+     * is already present in the configuration and you\n+     *\n+     * <code>addProperty(\"resource.loader\", \"classpath\")</code>\n+     *\n+     * Then you will end up with a Vector like the\n+     * following:\n+     *\n+     * <code>[\"file\", \"classpath\"]</code>\n+     *\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    public void addProperty(String key, Object value) {\n+        if (value instanceof String) {\n+            String str = (String) value;\n+            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n+                // token contains commas, so must be split apart then added\n+                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n+                while (tokenizer.hasMoreTokens()) {\n+                    String token = tokenizer.nextToken();\n+                    addPropertyInternal(key, unescape(token));\n+                }\n+            } else {\n+                // token contains no commas, so can be simply added\n+                addPropertyInternal(key, unescape(str));\n+            }\n+        } else {\n+            addPropertyInternal(key, value);\n+        }\n+\n+        // Adding a property connotes initialization\n+        isInitialized = true;\n+    }\n+\n+    /**\n+     * Adds a key/value pair to the map.  This routine does\n+     * no magic morphing.  It ensures the keylist is maintained\n+     *\n+     * @param key  the key to store at\n+     * @param value  the decoded object to store\n+     */\n+    private void addPropertyDirect(String key, Object value) {\n+        // safety check\n+        if (!containsKey(key)) {\n+            keysAsListed.add(key);\n+        }\n+        super.put(key, value);\n+    }\n+\n+    /**\n+     * Adds a decoded property to the map w/o checking for commas - used\n+     * internally when a property has been broken up into\n+     * strings that could contain escaped commas to prevent\n+     * the inadvertent vectorization.\n+     * <p>\n+     * Thanks to Leon Messerschmidt for this one.\n+     *\n+     * @param key  the key to store at\n+     * @param value  the decoded object to store\n+     */\n+    private void addPropertyInternal(String key, Object value) {\n+        Object current = this.get(key);\n+\n+        if (current instanceof String) {\n+            // one object already in map - convert it to a vector\n+            List<Object> values = new Vector<Object>(2);\n+            values.add(current);\n+            values.add(value);\n+            super.put(key, values);\n+            \n+        } else if (current instanceof List) {\n+            // already a list - just add the new token\n+            @SuppressWarnings(\"unchecked\") // OK to cast to Object\n+            List<Object> list = (List<Object>) current;\n+            list.add(value);\n+            \n+        } else {\n+            // brand new key - store in keysAsListed to retain order\n+            if (!containsKey(key)) {\n+                keysAsListed.add(key);\n+            }\n+            super.put(key, value);\n+        }\n+    }\n+\n+    /**\n+     * Set a property, this will replace any previously\n+     * set values. Set values is implicitly a call\n+     * to clearProperty(key), addProperty(key,value).\n+     *\n+     * @param key  the key to set\n+     * @param value  the value to set\n+     */\n+    public void setProperty(String key, Object value) {\n+        clearProperty(key);\n+        addProperty(key, value);\n+    }\n+    \n+    /**\n+     * Save the properties to the given output stream.\n+     * <p>\n+     * The stream is not closed, but it is flushed.\n+     *\n+     * @param output  an OutputStream, may be null\n+     * @param header  a textual comment to act as a file header\n+     * @throws IOException if an IO error occurs\n+     */\n+    public synchronized void save(OutputStream output, String header) throws IOException {\n+        if (output == null) {\n+            return;\n+        }\n+        PrintWriter theWrtr = new PrintWriter(output);\n+        if (header != null) {\n+            theWrtr.println(header);\n+        }\n+        \n+        Enumeration<String> theKeys = keys();\n+        while (theKeys.hasMoreElements()) {\n+            String key = theKeys.nextElement();\n+            Object value = get(key);\n+            if (value != null) {\n+                if (value instanceof String) {\n+                    StringBuilder currentOutput = new StringBuilder();\n+                    currentOutput.append(key);\n+                    currentOutput.append(\"=\");\n+                    currentOutput.append(escape((String) value));\n+                    theWrtr.println(currentOutput.toString());\n+                    \n+                } else if (value instanceof List) {\n+                    @SuppressWarnings(\"unchecked\") // we only add Strings to the Lists\n+                    List<String> values = (List<String>) value;\n+                    for (Iterator<String> it = values.iterator(); it.hasNext(); ) {\n+                        String currentElement = it.next();\n+                        StringBuilder currentOutput = new StringBuilder();\n+                        currentOutput.append(key);\n+                        currentOutput.append(\"=\");\n+                        currentOutput.append(escape(currentElement));\n+                        theWrtr.println(currentOutput.toString());\n+                    }\n+                }\n+            }\n+            theWrtr.println();\n+            theWrtr.flush();\n+        }\n+    }\n+\n+    /**\n+     * Combines an existing Hashtable with this Hashtable.\n+     * <p>\n+     * Warning: It will overwrite previous entries without warning.\n+     *\n+     * @param props  the properties to combine\n+     */\n+    public void combine(ExtendedProperties props) {\n+        for (Iterator<String> it = props.getKeys(); it.hasNext();) {\n+            String key = it.next();\n+            clearProperty(key);\n+            addPropertyDirect(key, props.get(key));\n+        }\n+    }\n+    \n+    /**\n+     * Clear a property in the configuration.\n+     *\n+     * @param key  the property key to remove along with corresponding value\n+     */\n+    public void clearProperty(String key) {\n+        if (containsKey(key)) {\n+            // we also need to rebuild the keysAsListed or else\n+            // things get *very* confusing\n+            for (int i = 0; i < keysAsListed.size(); i++) {\n+                if (( keysAsListed.get(i)).equals(key)) {\n+                    keysAsListed.remove(i);\n+                    break;\n+                }\n+            }\n+            super.remove(key);\n+        }\n+    }\n+\n+    /**\n+     * Get the list of the keys contained in the configuration\n+     * repository.\n+     *\n+     * @return an Iterator over the keys\n+     */\n+    public Iterator<String> getKeys() {\n+        return keysAsListed.iterator();\n+    }\n+\n+    /**\n+     * Get the list of the keys contained in the configuration\n+     * repository that match the specified prefix.\n+     *\n+     * @param prefix  the prefix to match\n+     * @return an Iterator of keys that match the prefix\n+     */\n+    public Iterator<String> getKeys(String prefix) {\n+        Iterator<String> keys = getKeys();\n+        ArrayList<String> matchingKeys = new ArrayList<String>();\n+\n+        while (keys.hasNext()) {\n+            String key = keys.next();\n+            if (key.startsWith(prefix)) {\n+                matchingKeys.add(key);\n+            }\n+        }\n+        return matchingKeys.iterator();\n+    }\n+\n+    /**\n+     * Create an ExtendedProperties object that is a subset\n+     * of this one. Take into account duplicate keys\n+     * by using the setProperty() in ExtendedProperties.\n+     *\n+     * @param prefix  the prefix to get a subset for\n+     * @return a new independent ExtendedProperties\n+     * or {@code null} if no keys matched\n+     */\n+    public ExtendedProperties subset(String prefix) {\n+        ExtendedProperties c = new ExtendedProperties();\n+        Iterator<String> keys = getKeys();\n+        boolean validSubset = false;\n+\n+        while (keys.hasNext()) {\n+            String key = keys.next();\n+\n+            if (key.startsWith(prefix)) {\n+                if (!validSubset) {\n+                    validSubset = true;\n+                }\n+\n+                /*\n+                 * Check to make sure that c.subset(prefix) doesn't\n+                 * blow up when there is only a single property\n+                 * with the key prefix. This is not a useful\n+                 * subset but it is a valid subset.\n+                 */\n+                String newKey = null;\n+                if (key.length() == prefix.length()) {\n+                    newKey = prefix;\n+                } else {\n+                    newKey = key.substring(prefix.length() + 1);\n+                }\n+\n+                /*\n+                 *  use addPropertyDirect() - this will plug the data as \n+                 *  is into the Map, but will also do the right thing\n+                 *  re key accounting\n+                 */\n+                c.addPropertyDirect(newKey, get(key));\n+            }\n+        }\n+\n+        if (validSubset) {\n+            return c;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Display the configuration for debugging purposes to System.out.\n+     */\n+    public void display() {\n+        Iterator<String> i = getKeys();\n+\n+        while (i.hasNext()) {\n+            String key = i.next();\n+            Object value = get(key);\n+            System.out.println(key + \" => \" + value);\n+        }\n+    }\n+\n+    /**\n+     * Get a string associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated string.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a String.\n+     */\n+    public String getString(String key) {\n+        return getString(key, null);\n+    }\n+\n+    /**\n+     * Get a string associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated string if key is found,\n+     * default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a String.\n+     */\n+    public String getString(String key, String defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof String) {\n+            return interpolate((String) value);\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return interpolate(defaults.getString(key, defaultValue));\n+            } else {\n+                return interpolate(defaultValue);\n+            }\n+        } else if (value instanceof List) {\n+            @SuppressWarnings(\"unchecked\") // Only expecting Strings here\n+            List<String> entry = (List<String>) value;\n+            return interpolate(entry.get(0)); // requires a String\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a list of properties associated with the given\n+     * configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated properties if key is found.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a String/List.\n+     * @throws IllegalArgumentException if one of the tokens is\n+     * malformed (does not contain an equals sign).\n+     */\n+    public Properties getProperties(String key) {\n+        return getProperties(key, new Properties());\n+    }\n+\n+    /**\n+     * Get a list of properties associated with the given\n+     * configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated properties if key is found.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a String/List.\n+     * @throws IllegalArgumentException if one of the tokens is\n+     * malformed (does not contain an equals sign).\n+     */\n+    public Properties getProperties(String key, Properties defaults) {\n+        /*\n+         * Grab an array of the tokens for this key.\n+         */\n+        String[] tokens = getStringArray(key);\n+\n+        // Each token is of the form 'key=value'.\n+        Properties props = new Properties(defaults);\n+        for (int i = 0; i < tokens.length; i++) {\n+            String token = tokens[i];\n+            int equalSign = token.indexOf('=');\n+            if (equalSign > 0) {\n+                String pkey = token.substring(0, equalSign).trim();\n+                String pvalue = token.substring(equalSign + 1).trim();\n+                props.setProperty(pkey, pvalue);\n+            } else {\n+                throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n+            }\n+        }\n+        return props;\n+    }\n+\n+    /**\n+     * Get an array of strings associated with the given configuration\n+     * key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated string array if key is found.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a String/List.\n+     */\n+    public String[] getStringArray(String key) {\n+        Object value = get(key);\n+\n+        List<String> values;\n+        if (value instanceof String) {\n+            values = new Vector<String>(1);\n+            values.add((String) value);\n+            \n+        } else if (value instanceof List) {\n+            @SuppressWarnings(\"unchecked\") // We only add Strings to the Lists\n+            List<String> list = (List<String>) value;\n+            values = list;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getStringArray(key);\n+            } else {\n+                return new String[0];\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n+        }\n+\n+        String[] tokens = new String[values.size()];\n+        for (int i = 0; i < tokens.length; i++) {\n+            tokens[i] = values.get(i);\n+        }\n+\n+        return tokens;\n+    }\n+\n+    /**\n+     * Get a Vector of strings associated with the given configuration\n+     * key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated Vector.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Vector.\n+     */\n+    public Vector<String> getVector(String key) {\n+        return getVector(key, null);\n+    }\n+\n+    /**\n+     * Get a Vector of strings associated with the given configuration key.\n+     * <p>\n+     * The list is a copy of the internal data of this object, and as\n+     * such you may alter it freely.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated Vector.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Vector.\n+     */\n+    public Vector<String> getVector(String key, Vector<String> defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof List) {\n+            @SuppressWarnings(\"unchecked\") // our lists only contain Strings\n+            List<String> list = (List<String>) value;\n+            return new Vector<String>(list);\n+            \n+        } else if (value instanceof String) {\n+            Vector<String> values = new Vector<String>(1);\n+            values.add((String) value);\n+            super.put(key, values);\n+            return values;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getVector(key, defaultValue);\n+            } else {\n+                return ((defaultValue == null) ? new Vector<String>() : defaultValue);\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a List of strings associated with the given configuration key.\n+     * <p>\n+     * The list is a copy of the internal data of this object, and as\n+     * such you may alter it freely.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated List object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a List.\n+     * @since Commons Collections 3.2\n+     */\n+    public List<String> getList(String key) {\n+        return getList(key, null);\n+    }\n+\n+    /**\n+     * Get a List of strings associated with the given configuration key.\n+     * <p>\n+     * The list is a copy of the internal data of this object, and as\n+     * such you may alter it freely.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated List.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a List.\n+     * @since Commons Collections 3.2\n+     */\n+    public List<String> getList(String key, List<String> defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof List) {\n+            @SuppressWarnings(\"unchecked\") // our lists only contain strings\n+            List<String> list = (List<String>) value;\n+            return new ArrayList<String>(list);\n+            \n+        } else if (value instanceof String) {\n+            List<String> values = new ArrayList<String>(1);\n+            values.add((String) value);\n+            super.put(key, values);\n+            return values;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getList(key, defaultValue);\n+            } else {\n+                return ((defaultValue == null) ? new ArrayList<String>() : defaultValue);\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a boolean associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated boolean.\n+     * @throws NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Boolean.\n+     */\n+    public boolean getBoolean(String key) {\n+        Boolean b = getBoolean(key, null);\n+        if (b != null) {\n+            return b.booleanValue();\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a boolean associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated boolean.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Boolean.\n+     */\n+    public boolean getBoolean(String key, boolean defaultValue) {\n+        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n+    }\n+\n+    /**\n+     * Get a boolean associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated boolean if key is found and has valid\n+     * format, default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Boolean.\n+     */\n+    public Boolean getBoolean(String key, Boolean defaultValue) {\n+\n+        Object value = get(key);\n+\n+        if (value instanceof Boolean) {\n+            return (Boolean) value;\n+            \n+        } else if (value instanceof String) {\n+            String s = testBoolean((String) value);\n+            Boolean b = Boolean.valueOf(s);\n+            super.put(key, b);\n+            return b;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getBoolean(key, defaultValue);\n+            } else {\n+                return defaultValue;\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Boolean object\");\n+        }\n+    }\n+\n+    /**\n+     * Test whether the string represent by value maps to a boolean\n+     * value or not. We will allow <code>true</code>, <code>on</code>,\n+     * and <code>yes</code> for a <code>true</code> boolean value, and\n+     * <code>false</code>, <code>off</code>, and <code>no</code> for\n+     * <code>false</code> boolean values.  Case of value to test for\n+     * boolean status is ignored.\n+     *\n+     * @param value  the value to test for boolean state\n+     * @return <code>true</code> or <code>false</code> if the supplied\n+     * text maps to a boolean value, or <code>null</code> otherwise.\n+     */\n+    public String testBoolean(String value) {\n+        String s = value.toLowerCase(Locale.ENGLISH);\n+\n+        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n+            return \"true\";\n+        } else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\")) {\n+            return \"false\";\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a byte associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated byte.\n+     * @throws NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Byte.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public byte getByte(String key) {\n+        Byte b = getByte(key, null);\n+        if (b != null) {\n+            return b.byteValue();\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \" doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a byte associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated byte.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Byte.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public byte getByte(String key, byte defaultValue) {\n+        return getByte(key, new Byte(defaultValue)).byteValue();\n+    }\n+\n+    /**\n+     * Get a byte associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated byte if key is found and has valid\n+     * format, default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Byte.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Byte getByte(String key, Byte defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof Byte) {\n+            return (Byte) value;\n+            \n+        } else if (value instanceof String) {\n+            Byte b = new Byte((String) value);\n+            super.put(key, b);\n+            return b;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getByte(key, defaultValue);\n+            } else {\n+                return defaultValue;\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Byte object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a short associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated short.\n+     * @throws NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Short.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public short getShort(String key) {\n+        Short s = getShort(key, null);\n+        if (s != null) {\n+            return s.shortValue();\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a short associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated short.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Short.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public short getShort(String key, short defaultValue) {\n+        return getShort(key, new Short(defaultValue)).shortValue();\n+    }\n+\n+    /**\n+     * Get a short associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated short if key is found and has valid\n+     * format, default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Short.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Short getShort(String key, Short defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof Short) {\n+            return (Short) value;\n+            \n+        } else if (value instanceof String) {\n+            Short s = new Short((String) value);\n+            super.put(key, s);\n+            return s;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getShort(key, defaultValue);\n+            } else {\n+                return defaultValue;\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Short object\");\n+        }\n+    }\n+\n+    /**\n+     * The purpose of this method is to get the configuration resource\n+     * with the given name as an integer.\n+     *\n+     * @param name The resource name.\n+     * @return The value of the resource as an integer.\n+     */\n+    public int getInt(String name) {\n+        return getInteger(name);\n+    }\n+\n+    /**\n+     * The purpose of this method is to get the configuration resource\n+     * with the given name as an integer, or a default value.\n+     *\n+     * @param name The resource name\n+     * @param def The default value of the resource.\n+     * @return The value of the resource as an integer.\n+     */\n+    public int getInt(String name, int def) {\n+        return getInteger(name, def);\n+    }\n+\n+    /**\n+     * Get a int associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated int.\n+     * @throws NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Integer.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public int getInteger(String key) {\n+        Integer i = getInteger(key, null);\n+        if (i != null) {\n+            return i.intValue();\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a int associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated int.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Integer.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public int getInteger(String key, int defaultValue) {\n+        Integer i = getInteger(key, null);\n+\n+        if (i == null) {\n+            return defaultValue;\n+        }\n+        return i.intValue();\n+    }\n+\n+    /**\n+     * Get a int associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated int if key is found and has valid\n+     * format, default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Integer.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Integer getInteger(String key, Integer defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof Integer) {\n+            return (Integer) value;\n+            \n+        } else if (value instanceof String) {\n+            Integer i = new Integer((String) value);\n+            super.put(key, i);\n+            return i;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getInteger(key, defaultValue);\n+            } else {\n+                return defaultValue;\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Integer object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a long associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated long.\n+     * @throws NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Long.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public long getLong(String key) {\n+        Long l = getLong(key, null);\n+        if (l != null) {\n+            return l.longValue();\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a long associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated long.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Long.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public long getLong(String key, long defaultValue) {\n+        return getLong(key, new Long(defaultValue)).longValue();\n+    }\n+\n+    /**\n+     * Get a long associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated long if key is found and has valid\n+     * format, default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Long.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Long getLong(String key, Long defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof Long) {\n+            return (Long) value;\n+            \n+        } else if (value instanceof String) {\n+            Long l = new Long((String) value);\n+            super.put(key, l);\n+            return l;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getLong(key, defaultValue);\n+            } else {\n+                return defaultValue;\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Long object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a float associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated float.\n+     * @throws NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Float.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public float getFloat(String key) {\n+        Float f = getFloat(key, null);\n+        if (f != null) {\n+            return f.floatValue();\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a float associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated float.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Float.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public float getFloat(String key, float defaultValue) {\n+        return getFloat(key, new Float(defaultValue)).floatValue();\n+    }\n+\n+    /**\n+     * Get a float associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated float if key is found and has valid\n+     * format, default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Float.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Float getFloat(String key, Float defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof Float) {\n+            return (Float) value;\n+            \n+        } else if (value instanceof String) {\n+            Float f = new Float((String) value);\n+            super.put(key, f);\n+            return f;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getFloat(key, defaultValue);\n+            } else {\n+                return defaultValue;\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Float object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a double associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated double.\n+     * @throws NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Double.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public double getDouble(String key) {\n+        Double d = getDouble(key, null);\n+        if (d != null) {\n+            return d.doubleValue();\n+        } else {\n+            throw new NoSuchElementException('\\'' + key + \"' doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a double associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated double.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Double.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public double getDouble(String key, double defaultValue) {\n+        return getDouble(key, new Double(defaultValue)).doubleValue();\n+    }\n+\n+    /**\n+     * Get a double associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated double if key is found and has valid\n+     * format, default value otherwise.\n+     * @throws ClassCastException is thrown if the key maps to an\n+     * object that is not a Double.\n+     * @throws NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Double getDouble(String key, Double defaultValue) {\n+        Object value = get(key);\n+\n+        if (value instanceof Double) {\n+            return (Double) value;\n+            \n+        } else if (value instanceof String) {\n+            Double d = new Double((String) value);\n+            super.put(key, d);\n+            return d;\n+            \n+        } else if (value == null) {\n+            if (defaults != null) {\n+                return defaults.getDouble(key, defaultValue);\n+            } else {\n+                return defaultValue;\n+            }\n+        } else {\n+            throw new ClassCastException('\\'' + key + \"' doesn't map to a Double object\");\n+        }\n+    }\n+\n+    /**\n+     * Convert a standard properties class into a configuration class.\n+     * <p>\n+     * NOTE: From Commons Collections 3.2 this method will pick up\n+     * any default parent Properties of the specified input object.\n+     * <p>\n+     * As with java.util.Properties(Properties), any non-String \n+     * values will not be passed on in the new ExtendedProperties \n+     * object.\n+     *\n+     * @param props  the properties object to convert\n+     * @return new ExtendedProperties created from props\n+     */\n+    public static ExtendedProperties convertProperties(Properties props) {\n+        ExtendedProperties c = new ExtendedProperties();\n+\n+        for (@SuppressWarnings(\"unchecked\") // Properties are supposed to have string keys ...\n+        Enumeration<String> e = (Enumeration<String>) props.propertyNames(); e.hasMoreElements();) {\n+            String s = e.nextElement(); // ... if props does not, this line would fail anyway ...\n+            String value = props.getProperty(s);\n+            if(value != null) {\n+                c.setProperty(s, value);\n+            }\n+        }\n+\n+        return c;\n+    }\n+\n+    /**\n+     * Add a new property specified by the key to the \n+     * ExtendedProperties.\n+     *\n+     * @param key specifying the property\n+     * @param value for the property\n+     * @return old value of the property\n+     */\n+    @Override\n+    public Object put(String key, Object value) {\n+        Object ret = getProperty(key);\n+        addProperty(key, value);\n+        return ret;\n+    }\n+\n+    /**\n+     * Add a map full of key/value pairs to the ExtendedProperties. \n+     * If the added map is an ExtendedProperties class, then the \n+     * order of the added properties is maintained. \n+     *\n+     * @param map full of key/value pair data\n+     */\n+    @Override\n+    public void putAll(Map<? extends String, ? extends Object> map) {\n+        if (map instanceof ExtendedProperties) {\n+            for (Iterator<String> it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n+                String key = it.next();\n+                put(key, map.get(key));\n+            }\n+        } else {\n+            @SuppressWarnings(\"unchecked\") // OK to downcast here\n+            Map<String, Object> mapso = (Map<String,Object>) map;\n+            for (Iterator<Map.Entry<String, Object>> it = mapso.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry<String,Object> entry = it.next();\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Remove the property specified by the key from the \n+     * ExtendedProperties.\n+     *\n+     * @param key specifying the property\n+     * @return old value of the property\n+     */\n+    @Override\n+    public Object remove(Object key) {\n+        String strKey = String.valueOf(key);\n+        Object ret = getProperty(strKey);\n+        clearProperty(strKey);\n+        return ret;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Factory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a functor interface implemented by classes that create objects.\n+ * <p>\n+ * A <code>Factory</code> creates an object without using an input parameter.\n+ * If an input parameter is required, then {@link Transformer} is more appropriate.\n+ * <p>\n+ * Standard implementations of common factories are provided by\n+ * {@link FactoryUtils}. These include factories that return a constant,\n+ * a copy of a prototype or a new instance.\n+ *\n+ * @param <T> the type that the factory creates\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Arron Bates\n+ * @author Stephen Colebourne\n+ */\n+public interface Factory<T> {\n+\n+    /**\n+     * Create a new object.\n+     *\n+     * @return a new object\n+     * @throws FunctorException (runtime) if the factory cannot create an object\n+     */\n+    public T create();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/FactoryUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import org.apache.commons.collections.functors.ConstantFactory;\n+import org.apache.commons.collections.functors.InstantiateFactory;\n+import org.apache.commons.collections.functors.ExceptionFactory;\n+import org.apache.commons.collections.functors.PrototypeFactory;\n+\n+/**\n+ * <code>FactoryUtils</code> provides reference implementations and utilities\n+ * for the Factory functor interface. The supplied factories are:\n+ * <ul>\n+ * <li>Prototype - clones a specified object\n+ * <li>Reflection - creates objects using reflection\n+ * <li>Constant - always returns the same object\n+ * <li>Null - always returns null\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied factories are Serializable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FactoryUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public FactoryUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a Factory that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections.functors.ExceptionFactory\n+     * \n+     * @return the factory\n+     */\n+    public static <T> Factory<T> exceptionFactory() {\n+        return ExceptionFactory.<T>exceptionFactory();\n+    }\n+\n+    /**\n+     * Gets a Factory that will return null each time the factory is used.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections.functors.ConstantFactory\n+     * @param <T> the \"type\" of null object the factory should return.\n+     * @return the factory\n+     */\n+    public static <T> Factory<T> nullFactory() {\n+        return ConstantFactory.<T>constantFactory(null);\n+    }\n+\n+    /**\n+     * Creates a Factory that will return the same object each time the factory\n+     * is used. No check is made that the object is immutable. In general, only\n+     * immutable objects should use the constant factory. Mutable objects should\n+     * use the prototype factory.\n+     *\n+     * @see org.apache.commons.collections.functors.ConstantFactory\n+     * \n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    public static <T> Factory<T> constantFactory(T constantToReturn) {\n+        return ConstantFactory.constantFactory(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Factory that will return a clone of the same prototype object\n+     * each time the factory is used. The prototype will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     *\n+     * @see org.apache.commons.collections.functors.PrototypeFactory\n+     * \n+     * @param prototype  the object to clone each time in the factory\n+     * @return the <code>prototype</code> factory\n+     * @throws IllegalArgumentException if the prototype is null\n+     * @throws IllegalArgumentException if the prototype cannot be cloned\n+     */\n+    public static <T> Factory<T> prototypeFactory(T  prototype) {\n+        return PrototypeFactory.<T>prototypeFactory(prototype);\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * a no-args constructor.\n+     *\n+     * @see org.apache.commons.collections.functors.InstantiateFactory\n+     * \n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @return the <code>reflection</code> factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     */\n+    public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate) {\n+        return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * the arguments specified to this method.\n+     *\n+     * @see org.apache.commons.collections.functors.InstantiateFactory\n+     * \n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the <code>reflection</code> factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     * @throws IllegalArgumentException if the constructor doesn't exist\n+     */\n+    public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+        return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/FunctorException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Runtime exception thrown from functors.\n+ * If required, a root cause error can be wrapped within this one.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FunctorException extends RuntimeException {\n+    \n+    /** Serialization version */\n+    private static final long serialVersionUID = -4704772662059351193L;\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> without specified\n+     * detail message.\n+     */\n+    public FunctorException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public FunctorException(String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FunctorException(Throwable rootCause) {\n+        super(rootCause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FunctorException(String msg, Throwable rootCause) {\n+        super(msg, rootCause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Get.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * The \"read\" subset of the {@link Map} interface.\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ * @see Put\n+ * @author Matt Benson\n+ */\n+public interface Get<K, V> {\n+\n+    /**\n+     * @see Map#containsKey(Object)\n+     */\n+    public boolean containsKey(Object key);\n+\n+    /**\n+     * @see Map#containsValue(Object)\n+     */\n+    public boolean containsValue(Object value);\n+\n+    /**\n+     * @see Map#entrySet()\n+     */\n+    public Set<java.util.Map.Entry<K, V>> entrySet();\n+\n+    /**\n+     * @see Map#get(Object)\n+     */\n+    public V get(Object key);\n+\n+    /**\n+     * @see Map#remove(Object)\n+     */\n+    public V remove(Object key);\n+\n+    /**\n+     * @see Map#isEmpty()\n+     */\n+    public boolean isEmpty();\n+\n+    /**\n+     * @see Map#keySet()\n+     */\n+    public Set<K> keySet();\n+\n+    /**\n+     * @see Map#size()\n+     */\n+    public int size();\n+\n+    /**\n+     * @see Map#values()\n+     */\n+    public Collection<V> values();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/IndexedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n+ * keyTransformer to define how the keys are converted from the values.\n+ * <p>\n+ * Modifications made to this decorator modify the index as well as the\n+ * decorated {@link Collection}. However, modifications to the underlying\n+ * {@link Collection} will not updated the index and it will get out of sync.\n+ * <p>\n+ * If modification to the decorated {@link Collection} is unavoidable, then a\n+ * call to {@link #reindex()} will update the index to the current contents of\n+ * the {@link Collection}.\n+ *\n+ * @param <K> the type of object in the index.\n+ * @param <C> the type of object in the collection.\n+ * @author Stephen Kestle\n+ */\n+// TODO support MultiMap/non-unique index behavior\n+// TODO add support for remove and clear\n+public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n+    /**\n+     * .\n+     */\n+    private static final long serialVersionUID = -5512610452568370038L;\n+\n+    /**\n+     * Create an {@link IndexedCollection} for a unique index.\n+     *\n+     * @param <K> the index object type.\n+     * @param <C> the collection type.\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     * @return the created {@link IndexedCollection}.\n+     */\n+    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n+        return new IndexedCollection<K, C>(coll, keyTransformer, new HashMap<K, C>());\n+    }\n+\n+    /**\n+     * The {@link Transformer} for generating index keys.\n+     */\n+    private final Transformer<C, K> keyTransformer;\n+\n+    /**\n+     * The map of indexes to collected objects.\n+     */\n+    private final HashMap<K, C> index;\n+\n+    /**\n+     * Create a {@link IndexedCollection} for a unique index.\n+     *\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     */\n+    public IndexedCollection(Collection<C> coll, Transformer<C, K> keyTransformer, HashMap<K, C> map) {\n+        super(coll);\n+        this.keyTransformer = keyTransformer;\n+        this.index = map;\n+        reindex();\n+    }\n+\n+    /**\n+     * Clears the index and re-indexes the entire decorated {@link Collection}.\n+     */\n+    public void reindex() {\n+        index.clear();\n+        for (C c : decorated()) {\n+            addIndex(c);\n+        }\n+    }\n+\n+    /**\n+     * Adds an object to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.add() fails\n+    public boolean add(C object) {\n+        addIndex(object);\n+        return super.add(object);\n+    }\n+\n+    /**\n+     * Adds an entire collection to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.addAll() fails\n+    public boolean addAll(Collection<? extends C> coll) {\n+        for (C c : coll) {\n+            addIndex(c);\n+        }\n+        return super.addAll(coll);\n+    }\n+\n+    /**\n+     * Provides checking for adding the index.\n+     *\n+     * @param object the object to index.\n+     */\n+    private void addIndex(C object) {\n+        final C existingObject = index.put(keyTransformer.transform(object), object);\n+        if (existingObject != null) {\n+            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n+        }\n+    }\n+\n+    /**\n+     * Get the element associated with the given key.\n+     * @param key to look up\n+     * @return element found\n+     */\n+    public C get(K key) {\n+        return index.get(key);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/IterableGet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Map;\n+\n+/**\n+ * The \"read\" subset of the {@link Map} interface.\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ * @see Put\n+ * @author Matt Benson\n+ */\n+public interface IterableGet<K, V> extends Get<K, V> {\n+    /**\n+     * Obtains a <code>MapIterator</code> over the map.\n+     * <p>\n+     * A map iterator is an efficient way of iterating over maps.\n+     * There is no need to access the entry set or use Map Entry objects.\n+     * <pre>\n+     * IterableMap<String,Integer> map = new HashedMap<String,Integer>();\n+     * MapIterator<String,Integer> it = map.mapIterator();\n+     * while (it.hasNext()) {\n+     *   String key = it.next();\n+     *   Integer value = it.getValue();\n+     *   it.setValue(value + 1);\n+     * }\n+     * </pre>\n+     * \n+     * @return a map iterator\n+     */\n+    MapIterator<K, V> mapIterator();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/IterableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Map;\n+\n+/**\n+ * Defines a map that can be iterated directly without needing to create an entry set.\n+ * <p>\n+ * A map iterator is an efficient way of iterating over maps.\n+ * There is no need to access the entry set or use Map Entry objects.\n+ * <pre>\n+ * IterableMap<String,Integer> map = new HashedMap<String,Integer>();\n+ * MapIterator<String,Integer> it = map.mapIterator();\n+ * while (it.hasNext()) {\n+ *   String key = it.next();\n+ *   Integer value = it.getValue();\n+ *   it.setValue(value + 1);\n+ * }\n+ * </pre>\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface IterableMap<K, V> extends Map<K, V>, Put<K, V>, IterableGet<K, V> {\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/IterableSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.SortedMap;\n+\n+/**\n+ * {@link SortedMap} + {@link OrderedMap}.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matt Benson\n+ */\n+public interface IterableSortedMap<K, V> extends SortedMap<K, V>, OrderedMap<K, V> {\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/IteratorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Dictionary;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.iterators.ArrayIterator;\n+import org.apache.commons.collections.iterators.ArrayListIterator;\n+import org.apache.commons.collections.iterators.CollatingIterator;\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.EmptyListIterator;\n+import org.apache.commons.collections.iterators.EmptyMapIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n+import org.apache.commons.collections.iterators.EnumerationIterator;\n+import org.apache.commons.collections.iterators.FilterIterator;\n+import org.apache.commons.collections.iterators.FilterListIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+import org.apache.commons.collections.iterators.IteratorEnumeration;\n+import org.apache.commons.collections.iterators.IteratorIterable;\n+import org.apache.commons.collections.iterators.ListIteratorWrapper;\n+import org.apache.commons.collections.iterators.LoopingIterator;\n+import org.apache.commons.collections.iterators.LoopingListIterator;\n+import org.apache.commons.collections.iterators.ObjectArrayIterator;\n+import org.apache.commons.collections.iterators.ObjectArrayListIterator;\n+import org.apache.commons.collections.iterators.ObjectGraphIterator;\n+import org.apache.commons.collections.iterators.SingletonIterator;\n+import org.apache.commons.collections.iterators.SingletonListIterator;\n+import org.apache.commons.collections.iterators.TransformIterator;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections.iterators.UnmodifiableListIterator;\n+import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n+\n+/**\n+ * Provides static utility methods and decorators for {@link Iterator}\n+ * instances. The implementations are provided in the iterators subpackage.\n+ * <p>\n+ * WARNING: Due to human error certain binary incompatabilities were introduced\n+ * between Commons Collections 2.1 and 3.0. The class remained source and test\n+ * compatible, so if you can recompile all your classes and dependencies\n+ * everything is OK. Those methods which are binary incompatible are marked as\n+ * such, together with alternate solutions that are binary compatible\n+ * against versions 2.1.1 and 3.1.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ */\n+public class IteratorUtils {\n+    // validation is done in this class in certain cases because the\n+    // public classes allow invalid states\n+\n+    /**\n+     * An iterator over no elements.\n+     * <p>\n+     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyIterator.INSTANCE</code> for compatability with Commons Collections 2.1.1.\n+     */\n+    public static final ResettableIterator<Object> EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n+\n+    /**\n+     * A list iterator over no elements.\n+     * <p>\n+     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyListIterator.INSTANCE</code> for compatability with Commons Collections 2.1.1.\n+     */\n+    public static final ResettableListIterator<Object> EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n+\n+    /**\n+     * An ordered iterator over no elements.\n+     */\n+    public static final OrderedIterator<Object> EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n+\n+    /**\n+     * A map iterator over no elements.\n+     */\n+    public static final MapIterator<Object, Object> EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n+\n+    /**\n+     * An ordered map iterator over no elements.\n+     */\n+    public static final OrderedMapIterator<Object, Object> EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n+\n+    /**\n+     * IteratorUtils is not normally instantiated.\n+     */\n+    public IteratorUtils() {\n+    }\n+\n+    // Empty\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an empty iterator.\n+     * <p>\n+     * This iterator is a valid iterator object that will iterate over\n+     * nothing.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyIterator.INSTANCE</code> for compatability with Commons Collections 2.1.1.\n+     *\n+     * @return  an iterator over nothing\n+     */\n+    public static <E> ResettableIterator<E> emptyIterator() {\n+        return EmptyIterator.<E>resettableEmptyIterator();\n+    }\n+\n+    /**\n+     * Gets an empty list iterator.\n+     * <p>\n+     * This iterator is a valid list iterator object that will iterate\n+     * over nothing.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyListIterator.INSTANCE</code> for compatability with Commons Collections 2.1.1.\n+     *\n+     * @return  a list iterator over nothing\n+     */\n+    public static <E> ResettableListIterator<E> emptyListIterator() {\n+        return EmptyListIterator.<E>resettableEmptyListIterator();\n+    }\n+\n+    /**\n+     * Gets an empty ordered iterator.\n+     * <p>\n+     * This iterator is a valid iterator object that will iterate\n+     * over nothing.\n+     *\n+     * @return  an ordered iterator over nothing\n+     */\n+    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n+        return EmptyOrderedIterator.<E>emptyOrderedIterator();\n+    }\n+\n+    /**\n+     * Gets an empty map iterator.\n+     * <p>\n+     * This iterator is a valid map iterator object that will iterate\n+     * over nothing.\n+     *\n+     * @return  a map iterator over nothing\n+     */\n+    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n+        return EmptyMapIterator.<K, V>emptyMapIterator();\n+    }\n+\n+    /**\n+     * Gets an empty ordered map iterator.\n+     * <p>\n+     * This iterator is a valid map iterator object that will iterate\n+     * over nothing.\n+     *\n+     * @return  a map iterator over nothing\n+     */\n+    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n+        return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n+    }\n+\n+    // Singleton\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a singleton iterator.\n+     * <p>\n+     * This iterator is a valid iterator object that will iterate over\n+     * the specified object.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new SingletonIterator(object)</code> for compatability.\n+     *\n+     * @param object  the single object over which to iterate\n+     * @return  a singleton iterator over the object\n+     */\n+    public static <E> ResettableIterator<E> singletonIterator(E object) {\n+        return new SingletonIterator<E>(object);\n+    }\n+\n+    /**\n+     * Gets a singleton list iterator.\n+     * <p>\n+     * This iterator is a valid list iterator object that will iterate over\n+     * the specified object.\n+     *\n+     * @param object  the single object over which to iterate\n+     * @return  a singleton list iterator over the object\n+     */\n+    public static <E> ListIterator<E> singletonListIterator(E object) {\n+        return new SingletonListIterator<E>(object);\n+    }\n+\n+    // Arrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over an object array.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new ArrayIterator(array)</code> for compatability.\n+     *\n+     * @param array  the array over which to iterate\n+     * @return  an iterator over the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(E[] array) {\n+        return new ObjectArrayIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets an iterator over an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param array  the array over which to iterate\n+     * @return  an iterator over the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(Object array) {\n+        return new ArrayIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets an iterator over the end part of an object array.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new ArrayIterator(array,start)</code> for compatability.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return an iterator over part of the array\n+     * @throws IndexOutOfBoundsException if start is less than zero or greater\n+     *  than the length of the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(E[] array, int start) {\n+        return new ObjectArrayIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets an iterator over the end part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return an iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws IndexOutOfBoundsException if start is less than zero or greater\n+     *  than the length of the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(Object array, int start) {\n+        return new ArrayIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets an iterator over part of an object array.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new ArrayIterator(array,start,end)</code> for compatability.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return an iterator over part of the array\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws IllegalArgumentException if end is before start\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(E[] array, int start, int end) {\n+        return new ObjectArrayIterator<E>(array, start, end);\n+    }\n+\n+    /**\n+     * Gets an iterator over part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return an iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws IllegalArgumentException if end is before start\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(Object array, int start, int end) {\n+        return new ArrayIterator<E>(array, start, end);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a list iterator over an object array.\n+     *\n+     * @param array  the array over which to iterate\n+     * @return  a list iterator over the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets a list iterator over an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param array  the array over which to iterate\n+     * @return  a list iterator over the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(Object array) {\n+        return new ArrayListIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets a list iterator over the end part of an object array.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IndexOutOfBoundsException if start is less than zero\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(E[] array, int start) {\n+        return new ObjectArrayListIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets a list iterator over the end part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws IndexOutOfBoundsException if start is less than zero\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(Object array, int start) {\n+        return new ArrayListIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets a list iterator over part of an object array.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws IllegalArgumentException if end is before start\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(E[] array, int start, int end) {\n+        return new ObjectArrayListIterator<E>(array, start, end);\n+    }\n+\n+    /**\n+     * Gets a list iterator over part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws IllegalArgumentException if end is before start\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(Object array, int start, int end) {\n+        return new ArrayListIterator<E>(array, start, end);\n+    }\n+\n+    // Unmodifiable\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an immutable version of an {@link Iterator}. The returned object\n+     * will always throw an {@link UnsupportedOperationException} for\n+     * the {@link Iterator#remove} method.\n+     *\n+     * @param iterator  the iterator to make immutable\n+     * @return an immutable version of the iterator\n+     */\n+    public static <E> Iterator<E> unmodifiableIterator(Iterator<E> iterator) {\n+        return UnmodifiableIterator.unmodifiableIterator(iterator);\n+    }\n+\n+    /**\n+     * Gets an immutable version of a {@link ListIterator}. The returned object\n+     * will always throw an {@link UnsupportedOperationException} for\n+     * the {@link Iterator#remove}, {@link ListIterator#add} and\n+     * {@link ListIterator#set} methods.\n+     *\n+     * @param listIterator  the iterator to make immutable\n+     * @return an immutable version of the iterator\n+     */\n+    public static <E> ListIterator<E> unmodifiableListIterator(ListIterator<E> listIterator) {\n+        return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n+    }\n+\n+    /**\n+     * Gets an immutable version of a {@link MapIterator}. The returned object\n+     * will always throw an {@link UnsupportedOperationException} for\n+     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n+     *\n+     * @param mapIterator  the iterator to make immutable\n+     * @return an immutable version of the iterator\n+     */\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(MapIterator<K, V> mapIterator) {\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n+    }\n+\n+    // Chained\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that iterates through two {@link Iterator}s\n+     * one after another.\n+     *\n+     * @param iterator1  the first iterators to use, not null\n+     * @param iterator2  the first iterators to use, not null\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public static <E> Iterator<E> chainedIterator(Iterator<? extends E> iterator1, Iterator<? extends E> iterator2) {\n+        return new IteratorChain<E>(iterator1, iterator2);\n+    }\n+\n+    /**\n+     * Gets an iterator that iterates through an array of {@link Iterator}s\n+     * one after another.\n+     *\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators array is null or contains a null\n+     */\n+    public static <E> Iterator<E> chainedIterator(Iterator<? extends E>[] iterators) {\n+        return new IteratorChain<E>(iterators);\n+    }\n+\n+    /**\n+     * Gets an iterator that iterates through a collections of {@link Iterator}s\n+     * one after another.\n+     *\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators collection is null or contains a null\n+     * @throws ClassCastException if the iterators collection contains the wrong object type\n+     */\n+    public static <E> Iterator<E> chainedIterator(Collection<Iterator<? extends E>> iterators) {\n+        return new IteratorChain<E>(iterators);\n+    }\n+\n+    // Collated\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that provides an ordered iteration over the elements\n+     * contained in a collection of ordered {@link Iterator}s.\n+     * <p>\n+     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n+     * the {@link Iterator#next()} method will return the lesser of\n+     * <code>A.next()</code> and <code>B.next()</code>.\n+     * <p>\n+     * The comparator is optional. If null is specified then natural order is used.\n+     *\n+     * @param comparator  the comparator to use, may be null for natural order\n+     * @param iterator1  the first iterators to use, not null\n+     * @param iterator2  the first iterators to use, not null\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator, Iterator<? extends E> iterator1, Iterator<? extends E> iterator2) {\n+        return new CollatingIterator<E>(comparator, iterator1, iterator2);\n+    }\n+\n+    /**\n+     * Gets an iterator that provides an ordered iteration over the elements\n+     * contained in an array of {@link Iterator}s.\n+     * <p>\n+     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n+     * the {@link Iterator#next()} method will return the lesser of\n+     * <code>A.next()</code> and <code>B.next()</code> and so on.\n+     * <p>\n+     * The comparator is optional. If null is specified then natural order is used.\n+     *\n+     * @param comparator  the comparator to use, may be null for natural order\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators array is null or contains a null\n+     */\n+    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator, Iterator<? extends E>[] iterators) {\n+        return new CollatingIterator<E>(comparator, iterators);\n+    }\n+\n+    /**\n+     * Gets an iterator that provides an ordered iteration over the elements\n+     * contained in a collection of {@link Iterator}s.\n+     * <p>\n+     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n+     * the {@link Iterator#next()} method will return the lesser of\n+     * <code>A.next()</code> and <code>B.next()</code> and so on.\n+     * <p>\n+     * The comparator is optional. If null is specified then natural order is used.\n+     *\n+     * @param comparator  the comparator to use, may be null for natural order\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators collection is null or contains a null\n+     * @throws ClassCastException if the iterators collection contains the wrong object type\n+     */\n+    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator,\n+            Collection<Iterator<? extends E>> iterators) {\n+        return new CollatingIterator<E>(comparator, iterators);\n+    }\n+\n+    // Object Graph\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that operates over an object graph.\n+     * <p>\n+     * This iterator can extract multiple objects from a complex tree-like object graph.\n+     * The iteration starts from a single root object.\n+     * It uses a <code>Transformer</code> to extract the iterators and elements.\n+     * Its main benefit is that no intermediate <code>List</code> is created.\n+     * <p>\n+     * For example, consider an object graph:\n+     * <pre>\n+     *                 |- Branch -- Leaf\n+     *                 |         \\- Leaf\n+     *         |- Tree |         /- Leaf\n+     *         |       |- Branch -- Leaf\n+     *  Forest |                 \\- Leaf\n+     *         |       |- Branch -- Leaf\n+     *         |       |         \\- Leaf\n+     *         |- Tree |         /- Leaf\n+     *                 |- Branch -- Leaf\n+     *                 |- Branch -- Leaf</pre>\n+     * The following <code>Transformer</code>, used in this class, will extract all\n+     * the Leaf objects without creating a combined intermediate list:\n+     * <pre>\n+     * public Object transform(Object input) {\n+     *   if (input instanceof Forest) {\n+     *     return ((Forest) input).treeIterator();\n+     *   }\n+     *   if (input instanceof Tree) {\n+     *     return ((Tree) input).branchIterator();\n+     *   }\n+     *   if (input instanceof Branch) {\n+     *     return ((Branch) input).leafIterator();\n+     *   }\n+     *   if (input instanceof Leaf) {\n+     *     return input;\n+     *   }\n+     *   throw new ClassCastException();\n+     * }</pre>\n+     * <p>\n+     * Internally, iteration starts from the root object. When next is called,\n+     * the transformer is called to examine the object. The transformer will return\n+     * either an iterator or an object. If the object is an Iterator, the next element\n+     * from that iterator is obtained and the process repeats. If the element is an object\n+     * it is returned.\n+     * <p>\n+     * Under many circumstances, linking Iterators together in this manner is\n+     * more efficient (and convenient) than using nested for loops to extract a list.\n+     *\n+     * @param root  the root object to start iterating from, null results in an empty iterator\n+     * @param transformer  the transformer to use, see above, null uses no effect transformer\n+     * @return a new object graph iterator\n+     * @since Commons Collections 3.1\n+     */\n+    public static <E> Iterator<E> objectGraphIterator(E root, Transformer<? super E, ? extends E> transformer) {\n+        return new ObjectGraphIterator<E>(root, transformer);\n+    }\n+\n+    // Transformed\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that transforms the elements of another iterator.\n+     * <p>\n+     * The transformation occurs during the next() method and the underlying\n+     * iterator is unaffected by the transformation.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @param transform  the transform to use, not null\n+     * @return a new transforming iterator\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static <I, O> Iterator<O> transformedIterator(Iterator<? extends I> iterator, Transformer<? super I, ? extends O> transform) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (transform == null) {\n+            throw new NullPointerException(\"Transformer must not be null\");\n+        }\n+        return new TransformIterator<I, O>(iterator, transform);\n+    }\n+\n+    // Filtered\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that filters another iterator.\n+     * <p>\n+     * The returned iterator will only return objects that match the specified\n+     * filtering predicate.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @param predicate  the predicate to use as a filter, not null\n+     * @return a new filtered iterator\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static <E> Iterator<E> filteredIterator(Iterator<? extends E> iterator, Predicate<? super E> predicate) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new NullPointerException(\"Predicate must not be null\");\n+        }\n+        return new FilterIterator<E>(iterator, predicate);\n+    }\n+\n+    /**\n+     * Gets a list iterator that filters another list iterator.\n+     * <p>\n+     * The returned iterator will only return objects that match the specified\n+     * filtering predicate.\n+     *\n+     * @param listIterator  the list iterator to use, not null\n+     * @param predicate  the predicate to use as a filter, not null\n+     * @return a new filtered iterator\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static <E> ListIterator<E> filteredListIterator(ListIterator<? extends E> listIterator, Predicate<? super E> predicate) {\n+        if (listIterator == null) {\n+            throw new NullPointerException(\"ListIterator must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new NullPointerException(\"Predicate must not be null\");\n+        }\n+        return new FilterListIterator<E>(listIterator, predicate);\n+    }\n+\n+    // Looping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that loops continuously over the supplied collection.\n+     * <p>\n+     * The iterator will only stop looping if the remove method is called\n+     * enough times to empty the collection, or if the collection is empty\n+     * to start with.\n+     *\n+     * @param coll  the collection to iterate over, not null\n+     * @return a new looping iterator\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public static <E> ResettableIterator<E> loopingIterator(Collection<? extends E> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"Collection must not be null\");\n+        }\n+        return new LoopingIterator<E>(coll);\n+    }\n+\n+    /**\n+     * Gets an iterator that loops continuously over the supplied list.\n+     * <p>\n+     * The iterator will only stop looping if the remove method is called\n+     * enough times to empty the list, or if the list is empty to start with.\n+     *\n+     * @param list  the list to iterate over, not null\n+     * @return a new looping iterator\n+     * @throws NullPointerException if the list is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> ResettableListIterator<E> loopingListIterator(List<E> list) {\n+        if (list == null) {\n+            throw new NullPointerException(\"List must not be null\");\n+        }\n+        return new LoopingListIterator<E>(list);\n+    }\n+\n+    // Views\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that provides an iterator view of the given enumeration.\n+     *\n+     * @param enumeration  the enumeration to use\n+     * @return a new iterator\n+     */\n+    public static <E> Iterator<E> asIterator(Enumeration<? extends E> enumeration) {\n+        if (enumeration == null) {\n+            throw new NullPointerException(\"Enumeration must not be null\");\n+        }\n+        return new EnumerationIterator<E>(enumeration);\n+    }\n+\n+    /**\n+     * Gets an iterator that provides an iterator view of the given enumeration\n+     * that will remove elements from the specified collection.\n+     *\n+     * @param enumeration  the enumeration to use\n+     * @param removeCollection  the collection to remove elements from\n+     * @return a new iterator\n+     */\n+    public static <E> Iterator<E> asIterator(Enumeration<? extends E> enumeration, Collection<? super E> removeCollection) {\n+        if (enumeration == null) {\n+            throw new NullPointerException(\"Enumeration must not be null\");\n+        }\n+        if (removeCollection == null) {\n+            throw new NullPointerException(\"Collection must not be null\");\n+        }\n+        return new EnumerationIterator<E>(enumeration, removeCollection);\n+    }\n+\n+    /**\n+     * Gets an enumeration that wraps an iterator.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @return a new enumeration\n+     * @throws NullPointerException if iterator is null\n+     */\n+    public static <E> Enumeration<E> asEnumeration(Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new IteratorEnumeration<E>(iterator);\n+    }\n+\n+    /**\n+     * Gets an iterable that wraps an iterator.  The returned iterable can be\n+     * used for a single iteration.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @return a new, single use iterable\n+     * @throws NullPointerException if iterator is null\n+     */\n+    public static <E> Iterable<E> asIterable(Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new IteratorIterable<E>(iterator, false);\n+    }\n+\n+    /**\n+     * Gets an iterable that wraps an iterator.  The returned iterable can be\n+     * used for multiple iterations.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @return a new, multiple use iterable\n+     * @throws NullPointerException if iterator is null\n+     */\n+    public static <E> Iterable<E> asMultipleUseIterable(Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new IteratorIterable<E>(iterator, true);\n+    }\n+\n+    /**\n+     * Gets a list iterator based on a simple iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, a LinkedList of its values is\n+     * cached, permitting all required operations of ListIterator.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @return a new iterator\n+     * @throws NullPointerException if iterator parameter is null\n+     */\n+    public static <E> ListIterator<E> toListIterator(Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new ListIteratorWrapper<E>(iterator);\n+    }\n+\n+    /**\n+     * Gets an array based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, this is converted to an array.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @return an array of the iterator contents\n+     * @throws NullPointerException if iterator parameter is null\n+     */\n+    public static Object[] toArray(Iterator<?> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        List<?> list = toList(iterator, 100);\n+        return list.toArray();\n+    }\n+\n+    /**\n+     * Gets an array based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, this is converted to an array.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @param arrayClass  the class of array to create\n+     * @return an array of the iterator contents\n+     * @throws NullPointerException if iterator parameter is null\n+     * @throws NullPointerException if arrayClass is null\n+     * @throws ClassCastException if the arrayClass is invalid\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E[] toArray(Iterator<? extends E> iterator, Class<E> arrayClass) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (arrayClass == null) {\n+            throw new NullPointerException(\"Array class must not be null\");\n+        }\n+        List<E> list = toList(iterator, 100);\n+        return list.toArray((E[]) Array.newInstance(arrayClass, list.size()));\n+    }\n+\n+    /**\n+     * Gets a list based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, the list is returned.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @return a list of the iterator contents\n+     * @throws NullPointerException if iterator parameter is null\n+     */\n+    public static <E> List<E> toList(Iterator<? extends E> iterator) {\n+        return toList(iterator, 10);\n+    }\n+\n+    /**\n+     * Gets a list based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, the list is returned.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @param estimatedSize  the initial size of the ArrayList\n+     * @return a list of the iterator contents\n+     * @throws NullPointerException if iterator parameter is null\n+     * @throws IllegalArgumentException if the size is less than 1\n+     */\n+    public static <E> List<E> toList(Iterator<? extends E> iterator, int estimatedSize) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (estimatedSize < 1) {\n+            throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n+        }\n+        List<E> list = new ArrayList<E>(estimatedSize);\n+        while (iterator.hasNext()) {\n+            list.add(iterator.next());\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Gets a suitable Iterator for the given object.\n+     * <p>\n+     * This method can handle objects as follows\n+     * <ul>\n+     * <li>null - empty iterator\n+     * <li>Iterator - returned directly\n+     * <li>Enumeration - wrapped\n+     * <li>Collection - iterator from collection returned\n+     * <li>Map - values iterator returned\n+     * <li>Dictionary - values (elements) enumeration returned as iterator\n+     * <li>array - iterator over array returned\n+     * <li>object with iterator() public method accessed by reflection\n+     * <li>object - singleton iterator\n+     * </ul>\n+     *\n+     * @param obj  the object to convert to an iterator\n+     * @return a suitable iterator, never null\n+     */\n+    public static Iterator<?> getIterator(Object obj) {\n+        if (obj == null) {\n+            return emptyIterator();\n+        }\n+        if (obj instanceof Iterator) {\n+            return (Iterator<?>) obj;\n+        }\n+        if (obj instanceof Collection) {\n+            return ((Collection<?>) obj).iterator();\n+        }\n+        if (obj instanceof Object[]) {\n+            return new ObjectArrayIterator<Object>((Object[]) obj);\n+        }\n+        if (obj instanceof Enumeration) {\n+            return new EnumerationIterator<Object>((Enumeration<?>) obj);\n+        }\n+        if (obj instanceof Map) {\n+            return ((Map<?, ?>) obj).values().iterator();\n+        }\n+        if (obj instanceof Dictionary) {\n+            return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n+        } else if (obj.getClass().isArray()) {\n+            return new ArrayIterator<Object>(obj);\n+        }\n+        try {\n+            Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n+            if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n+                Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n+                if (it != null) {\n+                    return it;\n+                }\n+            }\n+        } catch (Exception ex) {\n+            // ignore\n+        }\n+        return singletonIterator(obj);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/KeyValue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a simple key value pair.\n+ * <p>\n+ * A Map Entry has considerable additional semantics over and above a simple\n+ * key-value pair. This interface defines the minimum key value, with just the\n+ * two get methods.\n+ *\n+ * @param <K> the type of the key\n+ * @param <V> the type of the value\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface KeyValue<K, V> {\n+\n+    /**\n+     * Gets the key from the pair.\n+     *\n+     * @return the key \n+     */\n+    K getKey();\n+\n+    /**\n+     * Gets the value from the pair.\n+     *\n+     * @return the value\n+     */\n+    V getValue();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/ListUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.list.FixedSizeList;\n+import org.apache.commons.collections.list.LazyList;\n+import org.apache.commons.collections.list.PredicatedList;\n+import org.apache.commons.collections.list.SynchronizedList;\n+import org.apache.commons.collections.list.TransformedList;\n+import org.apache.commons.collections.list.UnmodifiableList;\n+\n+/**\n+ * Provides utility methods and decorators for {@link List} instances.\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Federico Barbieri\n+ * @author Peter Donald\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Neil O'Toole\n+ * @author Matthew Hawthorne\n+ * @author Dave Meikle\n+ */\n+public class ListUtils {\n+\n+    /**\n+     * An empty unmodifiable list.\n+     * This uses the {@link Collections Collections} implementation \n+     * and is provided for completeness.\n+     */\n+    public static final List<Object> EMPTY_LIST = Collections.<Object>emptyList();\n+\n+    /**\n+     * <code>ListUtils</code> should not normally be instantiated.\n+     */\n+    public ListUtils() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new list containing all elements that are contained in\n+     * both given lists.\n+     *\n+     * @param list1  the first list\n+     * @param list2  the second list\n+     * @return  the intersection of those two lists\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n+        final List<E> result = new ArrayList<E>();\n+\n+        List<? extends E> smaller = list1;\n+        List<? extends E> larger = list2;\n+        if (list1.size() > list2.size()) {\n+            smaller = list2;\n+            larger = list1;\n+        }\n+        \n+        HashSet<E> hashSet = new HashSet<E>(smaller);\n+\n+        for (E e : larger) {\n+            if (hashSet.contains(e)) {\n+                result.add(e);\n+                hashSet.remove(e);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Subtracts all elements in the second list from the first list,\n+     * placing the results in a new list.\n+     * <p>\n+     * This differs from {@link List#removeAll(Collection)} in that\n+     * cardinality is respected; if <Code>list1</Code> contains two\n+     * occurrences of <Code>null</Code> and <Code>list2</Code> only\n+     * contains one occurrence, then the returned list will still contain\n+     * one occurrence.\n+     *\n+     * @param list1  the list to subtract from\n+     * @param list2  the list to subtract\n+     * @return  a new list containing the results\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n+        final ArrayList<E> result = new ArrayList<E>(list1);\n+        for (E e : list2) {\n+            result.remove(e);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the sum of the given lists.  This is their intersection\n+     * subtracted from their union.\n+     *\n+     * @param list1  the first list \n+     * @param list2  the second list\n+     * @return  a new list containing the sum of those lists\n+     * @throws NullPointerException if either list is null\n+     */ \n+    public static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n+        return subtract(union(list1, list2), intersection(list1, list2));\n+    }\n+\n+    /**\n+     * Returns a new list containing the second list appended to the\n+     * first list.  The {@link List#addAll(Collection)} operation is\n+     * used to append the two given lists into a new list.\n+     *\n+     * @param list1  the first list \n+     * @param list2  the second list\n+     * @return  a new list containing the union of those lists\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n+        final ArrayList<E> result = new ArrayList<E>(list1);\n+        result.addAll(list2);\n+        return result;\n+    }\n+\n+    /**\n+     * Tests two lists for value-equality as per the equality contract in\n+     * {@link java.util.List#equals(java.lang.Object)}.\n+     * <p>\n+     * This method is useful for implementing <code>List</code> when you cannot\n+     * extend AbstractList. The method takes Collection instances to enable other\n+     * collection types to use the List implementation algorithm.\n+     * <p>\n+     * The relevant text (slightly paraphrased as this is a static method) is:\n+     * <blockquote>\n+     * Compares the two list objects for equality.  Returns\n+     * <tt>true</tt> if and only if both\n+     * lists have the same size, and all corresponding pairs of elements in\n+     * the two lists are <i>equal</i>.  (Two elements <tt>e1</tt> and\n+     * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :\n+     * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n+     * equal if they contain the same elements in the same order.  This\n+     * definition ensures that the equals method works properly across\n+     * different implementations of the <tt>List</tt> interface.\n+     * </blockquote>\n+     *\n+     * <b>Note:</b> The behaviour of this method is undefined if the lists are\n+     * modified during the equals comparison.\n+     * \n+     * @see java.util.List\n+     * @param list1  the first list, may be null\n+     * @param list2  the second list, may be null\n+     * @return whether the lists are equal by value comparison\n+     */\n+    public static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n+        if (list1 == list2) {\n+            return true;\n+        }\n+        if (list1 == null || list2 == null || list1.size() != list2.size()) {\n+            return false;\n+        }\n+\n+        Iterator<?> it1 = list1.iterator();\n+        Iterator<?> it2 = list2.iterator();\n+        Object obj1 = null;\n+        Object obj2 = null;\n+\n+        while (it1.hasNext() && it2.hasNext()) {\n+            obj1 = it1.next();\n+            obj2 = it2.next();\n+\n+            if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n+                return false;\n+            }\n+        }\n+\n+        return !(it1.hasNext() || it2.hasNext());\n+    }\n+    \n+    /**\n+     * Generates a hash code using the algorithm specified in \n+     * {@link java.util.List#hashCode()}.\n+     * <p>\n+     * This method is useful for implementing <code>List</code> when you cannot\n+     * extend AbstractList. The method takes Collection instances to enable other\n+     * collection types to use the List implementation algorithm.\n+     * \n+     * @see java.util.List#hashCode()\n+     * @param list  the list to generate the hashCode for, may be null\n+     * @return the hash code\n+     */\n+    public static <E> int hashCodeForList(final Collection<E> list) {\n+        if (list == null) {\n+            return 0;\n+        }\n+        int hashCode = 1;\n+        Iterator<E> it = list.iterator();\n+        \n+        while (it.hasNext()) {\n+            E obj = it.next();\n+            hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+        }\n+        return hashCode;\n+    }   \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a List containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned list is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n+     * \n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>List</code> containing all the elements of <code>c</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> List<E> retainAll(Collection<E> collection, Collection<?> retain) {\n+        List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n+\n+        for (E obj : collection) {\n+            if (retain.contains(obj)) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a list containing all the elements in <code>c</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     * \n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>List</code> containing all the elements of <code>c</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> List<E> removeAll(Collection<E> collection, Collection<?> remove) {\n+        List<E> list = new ArrayList<E>();\n+        for (E obj : collection) {\n+            if (!remove.contains(obj)) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized list backed by the given list.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to \n+     * avoid non-deterministic behavior:\n+     *  \n+     * <pre>\n+     * List list = ListUtils.synchronizedList(myList);\n+     * synchronized (list) {\n+     *     Iterator i = list.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * This method uses the implementation in the decorators subpackage.\n+     * \n+     * @param list  the list to synchronize, must not be null\n+     * @return a synchronized list backed by the given list\n+     * @throws IllegalArgumentException  if the list is null\n+     */\n+    public static <E> List<E> synchronizedList(List<E> list) {\n+        return SynchronizedList.synchronizedList(list);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable list backed by the given list.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param list  the list to make unmodifiable, must not be null\n+     * @return an unmodifiable list backed by the given list\n+     * @throws IllegalArgumentException  if the list is null\n+     */\n+    public static <E> List<E> unmodifiableList(List<E> list) {\n+        return UnmodifiableList.unmodifiableList(list);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) list backed by the given list.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the list.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original list after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param list  the list to predicate, must not be null\n+     * @param predicate  the predicate for the list, must not be null\n+     * @return a predicated list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Predicate is null\n+     */\n+    public static <E> List<E> predicatedList(List<E> list, Predicate<E> predicate) {\n+        return PredicatedList.predicatedList(list, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed list backed by the given list.\n+     * <p>\n+     * This method returns a new list (decorating the specified list) that\n+     * will transform any new entries added to it.\n+     * Existing entries in the specified list will not be transformed.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * List. It is important not to use the original list after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified list will not be transformed.\n+     * If you want that behaviour, see {@link TransformedList#decorateTransform}.\n+     *\n+     * @param list  the list to predicate, must not be null\n+     * @param transformer  the transformer for the list, must not be null\n+     * @return a transformed list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Transformer is null\n+     */\n+    public static <E> List<E> transformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedList.transformingList(list, transformer);\n+    }\n+    \n+    /**\n+     * Returns a \"lazy\" list whose elements will be created on demand.\n+     * <p>\n+     * When the index passed to the returned list's {@link List#get(int) get}\n+     * method is greater than the list's size, then the factory will be used\n+     * to create a new object and that object will be inserted at that index.\n+     * <p>\n+     * For instance:\n+     *\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * List lazy = ListUtils.lazyList(new ArrayList(), factory);\n+     * Object obj = lazy.get(3);\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the fourth element in the list.  The first, second, \n+     * and third element are all set to <code>null</code>.\n+     *\n+     * @param list  the list to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Factory is null\n+     */\n+    public static <E> List<E> lazyList(List<E> list, Factory<? extends E> factory) {\n+        return LazyList.lazyList(list, factory);\n+    }\n+\n+    /**\n+     * Returns a fixed-sized list backed by the given list.\n+     * Elements may not be added or removed from the returned list, but \n+     * existing elements can be changed (for instance, via the \n+     * {@link List#set(int,Object)} method).\n+     *\n+     * @param list  the list whose size to fix, must not be null\n+     * @return a fixed-size list backed by that list\n+     * @throws IllegalArgumentException  if the List is null\n+     */\n+    public static <E> List<E> fixedSizeList(List<E> list) {\n+        return FixedSizeList.fixedSizeList(list);\n+    }\n+\n+    /**\n+     * Finds the first index in the given List which matches the given predicate.\n+     * <p>\n+     * If the input List or predicate is null, or no element of the List\n+     * matches the predicate, -1 is returned.\n+     *\n+     * @param list the List to search, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n+     */\n+    public static <E> int indexOf(List<E> list, Predicate<E> predicate) {\n+        if (list != null && predicate != null) {\n+            for (int i = 0; i < list.size(); i++) {\n+                E item = list.get(i);\n+                if (predicate.evaluate(item)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/MapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Defines an iterator that operates over a <code>Map</code>.\n+ * <p>\n+ * This iterator is a special version designed for maps. It can be more\n+ * efficient to use this rather than an entry set iterator where the option\n+ * is available, and it is certainly more convenient.\n+ * <p>\n+ * A map that provides this interface may not hold the data internally using\n+ * Map Entry objects, thus this interface can avoid lots of object creation.\n+ * <p>\n+ * In use, this iterator iterates through the keys in the map. After each call\n+ * to <code>next()</code>, the <code>getValue()</code> method provides direct\n+ * access to the value. The value can also be set using <code>setValue()</code>.\n+ * <pre>\n+ * MapIterator<String,Integer> it = map.mapIterator();\n+ * while (it.hasNext()) {\n+ *   String key = it.next();\n+ *   Integer value = it.getValue();\n+ *   it.setValue(value + 1);\n+ * }\n+ * </pre>\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface MapIterator<K, V> extends Iterator<K> {\n+\n+    /**\n+     * Checks to see if there are more entries still to be iterated.\n+     *\n+     * @return <code>true</code> if the iterator has more elements\n+     */\n+    boolean hasNext();\n+\n+    /**\n+     * Gets the next <em>key</em> from the <code>Map</code>.\n+     *\n+     * @return the next key in the iteration\n+     * @throws NoSuchElementException if the iteration is finished\n+     */\n+    K next();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current key, which is the key returned by the last call\n+     * to <code>next()</code>.\n+     *\n+     * @return the current key\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    K getKey();\n+\n+    /**\n+     * Gets the current value, which is the value associated with the last key\n+     * returned by <code>next()</code>.\n+     *\n+     * @return the current value\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    V getValue();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes the last returned key from the underlying <code>Map</code> (optional operation).\n+     * <p>\n+     * This method can be called once per call to <code>next()</code>.\n+     *\n+     * @throws UnsupportedOperationException if remove is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has already been called\n+     *  since the last call to <code>next()</code>\n+     */\n+    void remove();\n+\n+    /**\n+     * Sets the value associated with the current key (optional operation).\n+     *\n+     * @param value  the new value\n+     * @return the previous value\n+     * @throws UnsupportedOperationException if setValue is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has been called since the\n+     *  last call to <code>next()</code>\n+     */\n+    V setValue(V value);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/MapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.PrintStream;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.ResourceBundle;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.AbstractMapDecorator;\n+import org.apache.commons.collections.map.AbstractSortedMapDecorator;\n+import org.apache.commons.collections.map.FixedSizeMap;\n+import org.apache.commons.collections.map.FixedSizeSortedMap;\n+import org.apache.commons.collections.map.LazyMap;\n+import org.apache.commons.collections.map.LazySortedMap;\n+import org.apache.commons.collections.map.ListOrderedMap;\n+import org.apache.commons.collections.map.MultiValueMap;\n+import org.apache.commons.collections.map.PredicatedMap;\n+import org.apache.commons.collections.map.PredicatedSortedMap;\n+import org.apache.commons.collections.map.TransformedMap;\n+import org.apache.commons.collections.map.TransformedSortedMap;\n+import org.apache.commons.collections.map.UnmodifiableMap;\n+import org.apache.commons.collections.map.UnmodifiableSortedMap;\n+\n+/**\n+ * Provides utility methods and decorators for\n+ * {@link Map} and {@link SortedMap} instances.\n+ * <p>\n+ * It contains various type safe methods\n+ * as well as other useful features like deep copying.\n+ * <p>\n+ * It also provides the following decorators:\n+ *\n+ *  <ul>\n+ *  <li>{@link #fixedSizeMap(Map)}\n+ *  <li>{@link #fixedSizeSortedMap(SortedMap)}\n+ *  <li>{@link #lazyMap(Map,Factory)}\n+ *  <li>{@link #lazyMap(Map,Transformer)}\n+ *  <li>{@link #lazySortedMap(SortedMap,Factory)}\n+ *  <li>{@link #lazySortedMap(SortedMap,Transformer)}\n+ *  <li>{@link #predicatedMap(Map,Predicate,Predicate)}\n+ *  <li>{@link #predicatedSortedMap(SortedMap,Predicate,Predicate)}\n+ *  <li>{@link #transformedMap(Map, Transformer, Transformer)}\n+ *  <li>{@link #transformedSortedMap(SortedMap, Transformer, Transformer)}\n+ *  <li>{@link #multiValueMap( Map )}\n+ *  <li>{@link #multiValueMap( Map, Class )}\n+ *  <li>{@link #multiValueMap( Map, Factory )}\n+ *  </ul>\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Matthew Hawthorne\n+ * @author Arun Mammen Thomas\n+ * @author Janek Bogucki\n+ * @author Max Rydahl Andersen\n+ * @author <a href=\"mailto:equinus100@hotmail.com\">Ashwin S</a>\n+ * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n+ * @author Neil O'Toole\n+ */\n+public class MapUtils {\n+\n+    /**\n+     * An empty unmodifiable map.\n+     * This was not provided in JDK1.2.\n+     */\n+    public static final Map<Object, Object> EMPTY_MAP = UnmodifiableMap.unmodifiableMap(new HashMap<Object, Object>(1));\n+\n+    /**\n+     * An empty unmodifiable sorted map.\n+     * This is not provided in the JDK.\n+     */\n+    public static final SortedMap<Object, Object> EMPTY_SORTED_MAP = UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());\n+\n+    /**\n+     * String used to indent the verbose and debug Map prints.\n+     */\n+    private static final String INDENT_STRING = \"    \";\n+\n+    /**\n+     * <code>MapUtils</code> should not normally be instantiated.\n+     */\n+    public MapUtils() {\n+    }\n+\n+    // Type safe getters\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets from a Map in a null-safe manner.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map, <code>null</code> if null map input\n+     */\n+    public static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n+        if (map != null) {\n+            return map.get(key);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a String from a Map in a null-safe manner.\n+     * <p>\n+     * The String is obtained via <code>toString</code>.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a String, <code>null</code> if null map input\n+     */\n+    public static <K> String getString(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            Object answer = map.get(key);\n+            if (answer != null) {\n+                return answer.toString();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Boolean from a Map in a null-safe manner.\n+     * <p>\n+     * If the value is a <code>Boolean</code> it is returned directly.\n+     * If the value is a <code>String</code> and it equals 'true' ignoring case\n+     * then <code>true</code> is returned, otherwise <code>false</code>.\n+     * If the value is a <code>Number</code> an integer zero value returns\n+     * <code>false</code> and non-zero returns <code>true</code>.\n+     * Otherwise, <code>null</code> is returned.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Boolean, <code>null</code> if null map input\n+     */\n+    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            Object answer = map.get(key);\n+            if (answer != null) {\n+                if (answer instanceof Boolean) {\n+                    return (Boolean) answer;\n+                }\n+                if (answer instanceof String) {\n+                    return Boolean.valueOf((String) answer);\n+                }\n+                if (answer instanceof Number) {\n+                    Number n = (Number) answer;\n+                    return (n.intValue() != 0) ? Boolean.TRUE : Boolean.FALSE;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Number from a Map in a null-safe manner.\n+     * <p>\n+     * If the value is a <code>Number</code> it is returned directly.\n+     * If the value is a <code>String</code> it is converted using\n+     * {@link NumberFormat#parse(String)} on the system default formatter\n+     * returning <code>null</code> if the conversion fails.\n+     * Otherwise, <code>null</code> is returned.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Number, <code>null</code> if null map input\n+     */\n+    public static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            Object answer = map.get(key);\n+            if (answer != null) {\n+                if (answer instanceof Number) {\n+                    return (Number) answer;\n+                }\n+                if (answer instanceof String) {\n+                    try {\n+                        String text = (String) answer;\n+                        return NumberFormat.getInstance().parse(text);\n+                    } catch (ParseException e) {\n+                        // failure means null is returned\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Byte from a Map in a null-safe manner.\n+     * <p>\n+     * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Byte, <code>null</code> if null map input\n+     */\n+    public static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Byte) {\n+            return (Byte) answer;\n+        }\n+        return new Byte(answer.byteValue());\n+    }\n+\n+    /**\n+     * Gets a Short from a Map in a null-safe manner.\n+     * <p>\n+     * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Short, <code>null</code> if null map input\n+     */\n+    public static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Short) {\n+            return (Short) answer;\n+        }\n+        return new Short(answer.shortValue());\n+    }\n+\n+    /**\n+     * Gets a Integer from a Map in a null-safe manner.\n+     * <p>\n+     * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Integer, <code>null</code> if null map input\n+     */\n+    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Integer) {\n+            return (Integer) answer;\n+        }\n+        return new Integer(answer.intValue());\n+    }\n+\n+    /**\n+     * Gets a Long from a Map in a null-safe manner.\n+     * <p>\n+     * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Long, <code>null</code> if null map input\n+     */\n+    public static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Long) {\n+            return (Long) answer;\n+        }\n+        return new Long(answer.longValue());\n+    }\n+\n+    /**\n+     * Gets a Float from a Map in a null-safe manner.\n+     * <p>\n+     * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Float, <code>null</code> if null map input\n+     */\n+    public static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Float) {\n+            return (Float) answer;\n+        }\n+        return new Float(answer.floatValue());\n+    }\n+\n+    /**\n+     * Gets a Double from a Map in a null-safe manner.\n+     * <p>\n+     * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Double, <code>null</code> if null map input\n+     */\n+    public static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Double) {\n+            return (Double) answer;\n+        }\n+        return new Double(answer.doubleValue());\n+    }\n+\n+    /**\n+     * Gets a Map from a Map in a null-safe manner.\n+     * <p>\n+     * If the value returned from the specified map is not a Map then\n+     * <code>null</code> is returned.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Map, <code>null</code> if null map input\n+     */\n+    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            Object answer = map.get(key);\n+            if (answer != null && answer instanceof Map) {\n+                return (Map<?, ?>) answer;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Type safe getters with default values\n+    //-------------------------------------------------------------------------\n+    /**\n+     *  Looks up the given key in the given map, converting null into the\n+     *  given default value.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null\n+     *  @return  the value in the map, or defaultValue if the original value\n+     *    is null or the map is null\n+     */\n+    public static <K, V> V getObject(Map<K, V> map, K key, V defaultValue) {\n+        if (map != null) {\n+            V answer = map.get(key);\n+            if (answer != null) {\n+                return answer;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a string, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a string, or defaultValue if the\n+     *    original value is null, the map is null or the string conversion\n+     *    fails\n+     */\n+    public static <K> String getString(Map<? super K, ?> map, K key, String defaultValue) {\n+        String answer = getString(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a boolean, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a boolean, or defaultValue if the\n+     *    original value is null, the map is null or the boolean conversion\n+     *    fails\n+     */\n+    public static <K> Boolean getBoolean(Map<? super K, ?> map, K key, Boolean defaultValue) {\n+        Boolean answer = getBoolean(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a number, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the number conversion\n+     *    fails\n+     */\n+    public static <K> Number getNumber(Map<? super K, ?> map, K key, Number defaultValue) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a byte, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the number conversion\n+     *    fails\n+     */\n+    public static <K> Byte getByte(Map<? super K, ?> map, K key, Byte defaultValue) {\n+        Byte answer = getByte(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a short, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the number conversion\n+     *    fails\n+     */\n+    public static <K> Short getShort(Map<? super K, ?> map, K key, Short defaultValue) {\n+        Short answer = getShort(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  an integer, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the number conversion\n+     *    fails\n+     */\n+    public static <K> Integer getInteger(Map<? super K, ?> map, K key, Integer defaultValue) {\n+        Integer answer = getInteger(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a long, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the number conversion\n+     *    fails\n+     */\n+    public static <K> Long getLong(Map<? super K, ?> map, K key, Long defaultValue) {\n+        Long answer = getLong(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a float, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the number conversion\n+     *    fails\n+     */\n+    public static <K> Float getFloat(Map<? super K, ?> map, K key, Float defaultValue) {\n+        Float answer = getFloat(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a double, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the number conversion\n+     *    fails\n+     */\n+    public static <K> Double getDouble(Map<? super K, ?> map, K key, Double defaultValue) {\n+        Double answer = getDouble(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     *  Looks up the given key in the given map, converting the result into\n+     *  a map, using the default value if the the conversion fails.\n+     *\n+     *  @param map  the map whose value to look up\n+     *  @param key  the key of the value to look up in that map\n+     *  @param defaultValue  what to return if the value is null or if the\n+     *     conversion fails\n+     *  @return  the value in the map as a number, or defaultValue if the\n+     *    original value is null, the map is null or the map conversion\n+     *    fails\n+     */\n+    public static <K> Map<?, ?> getMap(Map<? super K, ?> map, K key, Map<?, ?> defaultValue) {\n+        Map<?, ?> answer = getMap(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    // Type safe primitive getters\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets a boolean from a Map in a null-safe manner.\n+     * <p>\n+     * If the value is a <code>Boolean</code> its value is returned.\n+     * If the value is a <code>String</code> and it equals 'true' ignoring case\n+     * then <code>true</code> is returned, otherwise <code>false</code>.\n+     * If the value is a <code>Number</code> an integer zero value returns\n+     * <code>false</code> and non-zero returns <code>true</code>.\n+     * Otherwise, <code>false</code> is returned.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Boolean, <code>false</code> if null map input\n+     */\n+    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n+        return Boolean.TRUE.equals(getBoolean(map, key));\n+    }\n+\n+    /**\n+     * Gets a byte from a Map in a null-safe manner.\n+     * <p>\n+     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a byte, <code>0</code> if null map input\n+     */\n+    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n+        Byte byteObject = getByte(map, key);\n+        if (byteObject == null) {\n+            return 0;\n+        }\n+        return byteObject.byteValue();\n+    }\n+\n+    /**\n+     * Gets a short from a Map in a null-safe manner.\n+     * <p>\n+     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a short, <code>0</code> if null map input\n+     */\n+    public static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n+        Short shortObject = getShort(map, key);\n+        if (shortObject == null) {\n+            return 0;\n+        }\n+        return shortObject.shortValue();\n+    }\n+\n+    /**\n+     * Gets an int from a Map in a null-safe manner.\n+     * <p>\n+     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as an int, <code>0</code> if null map input\n+     */\n+    public static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n+        Integer integerObject = getInteger(map, key);\n+        if (integerObject == null) {\n+            return 0;\n+        }\n+        return integerObject.intValue();\n+    }\n+\n+    /**\n+     * Gets a long from a Map in a null-safe manner.\n+     * <p>\n+     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a long, <code>0L</code> if null map input\n+     */\n+    public static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n+        Long longObject = getLong(map, key);\n+        if (longObject == null) {\n+            return 0L;\n+        }\n+        return longObject.longValue();\n+    }\n+\n+    /**\n+     * Gets a float from a Map in a null-safe manner.\n+     * <p>\n+     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a float, <code>0.0F</code> if null map input\n+     */\n+    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n+        Float floatObject = getFloat(map, key);\n+        if (floatObject == null) {\n+            return 0f;\n+        }\n+        return floatObject.floatValue();\n+    }\n+\n+    /**\n+     * Gets a double from a Map in a null-safe manner.\n+     * <p>\n+     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a double, <code>0.0</code> if null map input\n+     */\n+    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n+        Double doubleObject = getDouble(map, key);\n+        if (doubleObject == null) {\n+            return 0d;\n+        }\n+        return doubleObject.doubleValue();\n+    }\n+\n+    // Type safe primitive getters with default values\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets a boolean from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * If the value is a <code>Boolean</code> its value is returned.\n+     * If the value is a <code>String</code> and it equals 'true' ignoring case\n+     * then <code>true</code> is returned, otherwise <code>false</code>.\n+     * If the value is a <code>Number</code> an integer zero value returns\n+     * <code>false</code> and non-zero returns <code>true</code>.\n+     * Otherwise, <code>defaultValue</code> is returned.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the\n+     *     conversion fails\n+     * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, boolean defaultValue) {\n+        Boolean booleanObject = getBoolean(map, key);\n+        if (booleanObject == null) {\n+            return defaultValue;\n+        }\n+        return booleanObject.booleanValue();\n+    }\n+\n+    /**\n+     * Gets a byte from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the\n+     *     conversion fails\n+     * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key, byte defaultValue) {\n+        Byte byteObject = getByte(map, key);\n+        if (byteObject == null) {\n+            return defaultValue;\n+        }\n+        return byteObject.byteValue();\n+    }\n+\n+    /**\n+     * Gets a short from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the\n+     *     conversion fails\n+     * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> short getShortValue(final Map<? super K, ?> map, final K key, short defaultValue) {\n+        Short shortObject = getShort(map, key);\n+        if (shortObject == null) {\n+            return defaultValue;\n+        }\n+        return shortObject.shortValue();\n+    }\n+\n+    /**\n+     * Gets an int from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the\n+     *     conversion fails\n+     * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> int getIntValue(final Map<? super K, ?> map, final K key, int defaultValue) {\n+        Integer integerObject = getInteger(map, key);\n+        if (integerObject == null) {\n+            return defaultValue;\n+        }\n+        return integerObject.intValue();\n+    }\n+\n+    /**\n+     * Gets a long from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the\n+     *     conversion fails\n+     * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> long getLongValue(final Map<? super K, ?> map, final K key, long defaultValue) {\n+        Long longObject = getLong(map, key);\n+        if (longObject == null) {\n+            return defaultValue;\n+        }\n+        return longObject.longValue();\n+    }\n+\n+    /**\n+     * Gets a float from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the\n+     *     conversion fails\n+     * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key, float defaultValue) {\n+        Float floatObject = getFloat(map, key);\n+        if (floatObject == null) {\n+            return defaultValue;\n+        }\n+        return floatObject.floatValue();\n+    }\n+\n+    /**\n+     * Gets a double from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the\n+     *     conversion fails\n+     * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, double defaultValue) {\n+        Double doubleObject = getDouble(map, key);\n+        if (doubleObject == null) {\n+            return defaultValue;\n+        }\n+        return doubleObject.doubleValue();\n+    }\n+\n+    // Conversion methods\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets a new Properties object initialised with the values from a Map.\n+     * A null input will return an empty properties object.\n+     *\n+     * @param map  the map to convert to a Properties object, may not be null\n+     * @return the properties object\n+     */\n+    public static <K, V> Properties toProperties(final Map<K, V> map) {\n+        Properties answer = new Properties();\n+        if (map != null) {\n+            for (Iterator<Map.Entry<K, V>> iter = map.entrySet().iterator(); iter.hasNext();) {\n+                Map.Entry<?, ?> entry = iter.next();\n+                Object key = entry.getKey();\n+                Object value = entry.getValue();\n+                answer.put(key, value);\n+            }\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Creates a new HashMap using data copied from a ResourceBundle.\n+     *\n+     * @param resourceBundle  the resource bundle to convert, may not be null\n+     * @return the hashmap containing the data\n+     * @throws NullPointerException if the bundle is null\n+     */\n+    public static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n+        Enumeration<String> enumeration = resourceBundle.getKeys();\n+        Map<String, Object> map = new HashMap<String, Object>();\n+\n+        while (enumeration.hasMoreElements()) {\n+            String key = enumeration.nextElement();\n+            Object value = resourceBundle.getObject(key);\n+            map.put(key, value);\n+        }\n+\n+        return map;\n+    }\n+\n+    // Printing methods\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Prints the given map with nice line breaks.\n+     * <p>\n+     * This method prints a nicely formatted String describing the Map.\n+     * Each map entry will be printed with key and value.\n+     * When the value is a Map, recursive behaviour occurs.\n+     * <p>\n+     * This method is NOT thread-safe in any special way. You must manually\n+     * synchronize on either this class or the stream as required.\n+     *\n+     * @param out  the stream to print to, must not be null\n+     * @param label  The label to be used, may be <code>null</code>.\n+     *  If <code>null</code>, the label is not output.\n+     *  It typically represents the name of the property in a bean or similar.\n+     * @param map  The map to print, may be <code>null</code>.\n+     *  If <code>null</code>, the text 'null' is output.\n+     * @throws NullPointerException if the stream is <code>null</code>\n+     */\n+    public static void verbosePrint(\n+        final PrintStream out,\n+        final Object label,\n+        final Map<?, ?> map) {\n+\n+        verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), false);\n+    }\n+\n+    /**\n+     * Prints the given map with nice line breaks.\n+     * <p>\n+     * This method prints a nicely formatted String describing the Map.\n+     * Each map entry will be printed with key, value and value classname.\n+     * When the value is a Map, recursive behaviour occurs.\n+     * <p>\n+     * This method is NOT thread-safe in any special way. You must manually\n+     * synchronize on either this class or the stream as required.\n+     *\n+     * @param out  the stream to print to, must not be null\n+     * @param label  The label to be used, may be <code>null</code>.\n+     *  If <code>null</code>, the label is not output.\n+     *  It typically represents the name of the property in a bean or similar.\n+     * @param map  The map to print, may be <code>null</code>.\n+     *  If <code>null</code>, the text 'null' is output.\n+     * @throws NullPointerException if the stream is <code>null</code>\n+     */\n+    public static void debugPrint(\n+        final PrintStream out,\n+        final Object label,\n+        final Map<?, ?> map) {\n+\n+        verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), true);\n+    }\n+\n+    // Implementation methods\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Implementation providing functionality for {@link #debugPrint} and for\n+     * {@link #verbosePrint}.  This prints the given map with nice line breaks.\n+     * If the debug flag is true, it additionally prints the type of the object\n+     * value.  If the contents of a map include the map itself, then the text\n+     * <em>(this Map)</em> is printed out.  If the contents include a\n+     * parent container of the map, the the text <em>(ancestor[i] Map)</em> is\n+     * printed, where i actually indicates the number of levels which must be\n+     * traversed in the sequential list of ancestors (e.g. father, grandfather,\n+     * great-grandfather, etc).\n+     *\n+     * @param out  the stream to print to\n+     * @param label  the label to be used, may be <code>null</code>.\n+     *  If <code>null</code>, the label is not output.\n+     *  It typically represents the name of the property in a bean or similar.\n+     * @param map  the map to print, may be <code>null</code>.\n+     *  If <code>null</code>, the text 'null' is output\n+     * @param lineage  a stack consisting of any maps in which the previous\n+     *  argument is contained. This is checked to avoid infinite recursion when\n+     *  printing the output\n+     * @param debug  flag indicating whether type names should be output.\n+     * @throws NullPointerException if the stream is <code>null</code>\n+     */\n+    private static void verbosePrintInternal(\n+        final PrintStream out,\n+        final Object label,\n+        final Map<?, ?> map,\n+        final ArrayStack<Map<?, ?>> lineage,\n+        final boolean debug) {\n+\n+        printIndent(out, lineage.size());\n+\n+        if (map == null) {\n+            if (label != null) {\n+                out.print(label);\n+                out.print(\" = \");\n+            }\n+            out.println(\"null\");\n+            return;\n+        }\n+        if (label != null) {\n+            out.print(label);\n+            out.println(\" = \");\n+        }\n+\n+        printIndent(out, lineage.size());\n+        out.println(\"{\");\n+\n+        lineage.push(map);\n+\n+        for (Map.Entry<?, ?> entry : map.entrySet()) {\n+            Object childKey = entry.getKey();\n+            Object childValue = entry.getValue();\n+            if (childValue instanceof Map && !lineage.contains(childValue)) {\n+                verbosePrintInternal(\n+                    out,\n+                    (childKey == null ? \"null\" : childKey),\n+                    (Map<?, ?>) childValue,\n+                    lineage,\n+                    debug);\n+            } else {\n+                printIndent(out, lineage.size());\n+                out.print(childKey);\n+                out.print(\" = \");\n+\n+                final int lineageIndex = lineage.indexOf(childValue);\n+                if (lineageIndex == -1) {\n+                    out.print(childValue);\n+                } else if (lineage.size() - 1 == lineageIndex) {\n+                    out.print(\"(this Map)\");\n+                } else {\n+                    out.print(\n+                        \"(ancestor[\"\n+                            + (lineage.size() - 1 - lineageIndex - 1)\n+                            + \"] Map)\");\n+                }\n+\n+                if (debug && childValue != null) {\n+                    out.print(' ');\n+                    out.println(childValue.getClass().getName());\n+                } else {\n+                    out.println();\n+                }\n+            }\n+        }\n+\n+        lineage.pop();\n+\n+        printIndent(out, lineage.size());\n+        out.println(debug ? \"} \" + map.getClass().getName() : \"}\");\n+    }\n+\n+    /**\n+     * Writes indentation to the given stream.\n+     *\n+     * @param out  the stream to indent\n+     */\n+    private static void printIndent(final PrintStream out, final int indent) {\n+        for (int i = 0; i < indent; i++) {\n+            out.print(INDENT_STRING);\n+        }\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inverts the supplied map returning a new HashMap such that the keys of\n+     * the input are swapped with the values.\n+     * <p>\n+     * This operation assumes that the inverse mapping is well defined.\n+     * If the input map had multiple entries with the same value mapped to\n+     * different keys, the returned map will map one of those keys to the\n+     * value, but the exact key which will be mapped is undefined.\n+     *\n+     * @param map  the map to invert, may not be null\n+     * @return a new HashMap containing the inverted data\n+     * @throws NullPointerException if the map is null\n+     */\n+    public static <K, V> Map<V, K> invertMap(Map<K, V> map) {\n+        Map<V, K> out = new HashMap<V, K>(map.size());\n+        for (Iterator<Map.Entry<K, V>> it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry<K, V> entry = it.next();\n+            out.put(entry.getValue(), entry.getKey());\n+        }\n+        return out;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Protects against adding null values to a map.\n+     * <p>\n+     * This method checks the value being added to the map, and if it is null\n+     * it is replaced by an empty string.\n+     * <p>\n+     * This could be useful if the map does not accept null values, or for\n+     * receiving data from a source that may provide null or empty string\n+     * which should be held in the same way in the map.\n+     * <p>\n+     * Keys are not validated.\n+     * Note that this method can be used to circumvent the map's\n+     * value type at runtime.\n+     *\n+     * @param map  the map to add to, may not be null\n+     * @param key  the key\n+     * @param value  the value, null converted to \"\"\n+     * @throws NullPointerException if the map is null\n+     */\n+    public static <K> void safeAddToMap(Map<? super K, Object> map, K key, Object value) throws NullPointerException {\n+        map.put(key, value == null ? \"\" : value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts all the keys and values from the specified array into the map.\n+     * <p>\n+     * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)}\n+     * method and constructors. It allows you to build a map from an object array\n+     * of various possible styles.\n+     * <p>\n+     * If the first entry in the object array implements {@link java.util.Map.Entry}\n+     * or {@link KeyValue} then the key and value are added from that object.\n+     * If the first entry in the object array is an object array itself, then\n+     * it is assumed that index 0 in the sub-array is the key and index 1 is the value.\n+     * Otherwise, the array is treated as keys and values in alternate indices.\n+     * <p>\n+     * For example, to create a color map:\n+     * <pre>\n+     * Map colorMap = MapUtils.putAll(new HashMap(), new String[][] {\n+     *     {\"RED\", \"#FF0000\"},\n+     *     {\"GREEN\", \"#00FF00\"},\n+     *     {\"BLUE\", \"#0000FF\"}\n+     * });\n+     * </pre>\n+     * or:\n+     * <pre>\n+     * Map colorMap = MapUtils.putAll(new HashMap(), new String[] {\n+     *     \"RED\", \"#FF0000\",\n+     *     \"GREEN\", \"#00FF00\",\n+     *     \"BLUE\", \"#0000FF\"\n+     * });\n+     * </pre>\n+     * or:\n+     * <pre>\n+     * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] {\n+     *     new DefaultMapEntry(\"RED\", \"#FF0000\"),\n+     *     new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n+     *     new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n+     * });\n+     * </pre>\n+     *\n+     * @param map  the map to populate, must not be null\n+     * @param array  an array to populate from, null ignored\n+     * @return the input map\n+     * @throws NullPointerException  if map is null\n+     * @throws IllegalArgumentException  if sub-array or entry matching used and an\n+     *  entry is invalid\n+     * @throws ClassCastException if the array contents is mixed\n+     * @since Commons Collections 3.2\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> Map<K, V> putAll(Map<K, V> map, Object[] array) {\n+        map.size();  // force NPE\n+        if (array == null || array.length == 0) {\n+            return map;\n+        }\n+        Object obj = array[0];\n+        if (obj instanceof Map.Entry) {\n+            for (int i = 0; i < array.length; i++) {\n+                Map.Entry<K, V> entry = (Map.Entry<K, V>) array[i];\n+                map.put(entry.getKey(), entry.getValue());\n+            }\n+        } else if (obj instanceof KeyValue) {\n+            for (int i = 0; i < array.length; i++) {\n+                KeyValue<K, V> keyval = (KeyValue<K, V>) array[i];\n+                map.put(keyval.getKey(), keyval.getValue());\n+            }\n+        } else if (obj instanceof Object[]) {\n+            for (int i = 0; i < array.length; i++) {\n+                Object[] sub = (Object[]) array[i];\n+                if (sub == null || sub.length < 2) {\n+                    throw new IllegalArgumentException(\"Invalid array element: \" + i);\n+                }\n+                map.put((K) sub[0], (V) sub[1]);\n+            }\n+        } else {\n+            for (int i = 0; i < array.length - 1;) {\n+                map.put((K) array[i++], (V) array[i++]);\n+            }\n+        }\n+        return map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Null-safe check if the specified map is empty.\n+     * <p>\n+     * Null returns true.\n+     *\n+     * @param map  the map to check, may be null\n+     * @return true if empty or null\n+     * @since Commons Collections 3.2\n+     */\n+    public static boolean isEmpty(Map<?,?> map) {\n+        return (map == null || map.isEmpty());\n+    }\n+\n+    /**\n+     * Null-safe check if the specified map is not empty.\n+     * <p>\n+     * Null returns false.\n+     *\n+     * @param map  the map to check, may be null\n+     * @return true if non-null and non-empty\n+     * @since Commons Collections 3.2\n+     */\n+    public static boolean isNotEmpty(Map<?,?> map) {\n+        return !MapUtils.isEmpty(map);\n+    }\n+\n+    // Map decorators\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized map backed by the given map.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to\n+     * avoid non-deterministic behavior:\n+     *\n+     * <pre>\n+     * Map m = MapUtils.synchronizedMap(myMap);\n+     * Set s = m.keySet();  // outside synchronized block\n+     * synchronized (m) {  // synchronized on MAP!\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * This method uses the implementation in {@link java.util.Collections Collections}.\n+     *\n+     * @param map  the map to synchronize, must not be null\n+     * @return a synchronized map backed by the given map\n+     */\n+    public static <K, V> Map<K, V> synchronizedMap(Map<K, V> map) {\n+        return Collections.synchronizedMap(map);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable map backed by the given map.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param map  the map to make unmodifiable, must not be null\n+     * @return an unmodifiable map backed by the given map\n+     * @throws IllegalArgumentException  if the map is null\n+     */\n+    public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n+        return UnmodifiableMap.unmodifiableMap(map);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) map backed by the given map.\n+     * <p>\n+     * Only objects that pass the tests in the given predicates can be added to the map.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * Keys must pass the key predicate, values must pass the value predicate.\n+     * It is important not to use the original map after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param map  the map to predicate, must not be null\n+     * @param keyPred  the predicate for keys, null means no check\n+     * @param valuePred  the predicate for values, null means no check\n+     * @return a predicated map backed by the given map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> IterableMap<K, V> predicatedMap(Map<K, V> map, Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n+        return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n+    }\n+\n+    /**\n+     * Returns a transformed map backed by the given map.\n+     * <p>\n+     * This method returns a new map (decorating the specified map) that\n+     * will transform any new entries added to it.\n+     * Existing entries in the specified map will not be transformed.\n+     * If you want that behaviour, see {@link TransformedMap#decorateTransform}.\n+     * <p>\n+     * Each object is passed through the transformers as it is added to the\n+     * Map. It is important not to use the original map after invoking this\n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map  the map to transform, must not be null, typically empty\n+     * @param keyTransformer  the transformer for the map keys, null means no transformation\n+     * @param valueTransformer  the transformer for the map values, null means no transformation\n+     * @return a transformed map backed by the given map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> IterableMap<K, V> transformedMap(Map<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Returns a fixed-sized map backed by the given map.\n+     * Elements may not be added or removed from the returned map, but\n+     * existing elements can be changed (for instance, via the\n+     * {@link Map#put(Object,Object)} method).\n+     *\n+     * @param map  the map whose size to fix, must not be null\n+     * @return a fixed-size map backed by that map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> IterableMap<K, V> fixedSizeMap(Map<K, V> map) {\n+        return FixedSizeMap.fixedSizeMap(map);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazyMap.get(\"test\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the value for the <code>\"test\"</code> key in the map.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Factory is null\n+     */\n+    public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Factory<? extends V> factory) {\n+        return LazyMap.lazyMap(map, factory);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key. The factory is a {@link Transformer}\n+     * that will be passed the key which it must transform into the value.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Transformer factory = new Transformer() {\n+     *     public Object transform(Object mapKey) {\n+     *         return new File(mapKey);\n+     *     }\n+     * }\n+     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazyMap.get(\"C:/dev\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>File</code> instance for the C drive dev directory.\n+     * Furthermore, that <code>File</code> instance is the value for the\n+     * <code>\"C:/dev\"</code> key in the map.\n+     * <p>\n+     * If a lazy map is wrapped by a synchronized map, the result is a simple\n+     * synchronized cache. When an object is not is the cache, the cache itself\n+     * calls back to the factory Transformer to populate itself, all within the\n+     * same synchronized block.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param transformerFactory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     */\n+    public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Transformer<? super K, ? extends V> transformerFactory) {\n+        return LazyMap.lazyMap(map, transformerFactory);\n+    }\n+\n+    /**\n+     * Returns a map that maintains the order of keys that are added\n+     * backed by the given map.\n+     * <p>\n+     * If a key is added twice, the order is determined by the first add.\n+     * The order is observed through the keySet, values and entrySet.\n+     *\n+     * @param map  the map to order, must not be null\n+     * @return an ordered map backed by the given map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> OrderedMap<K, V> orderedMap(Map<K, V> map) {\n+        return ListOrderedMap.listOrderedMap(map);\n+    }\n+\n+    /**\n+     * Creates a mult-value map backed by the given map which returns\n+     * collections of type ArrayList.\n+     *\n+     * @param map  the map to decorate\n+     * @return a multi-value map backed by the given map which returns ArrayLists of values.\n+     * @see MultiValueMap\n+     * @since Commons Collections 3.2\n+     */\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n+        return MultiValueMap.<K, V>multiValueMap(map);\n+    }\n+\n+    /**\n+     * Creates a multi-value map backed by the given map which returns\n+     * collections of the specified type.\n+     *\n+     * @param map  the map to decorate\n+     * @param collectionClass  the type of collections to return from the map (must contain public no-arg constructor\n+     *  and extend Collection).\n+     * @return a multi-value map backed by the given map which returns collections of the specified type\n+     * @see MultiValueMap\n+     * @since Commons Collections 3.2\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Class<C> collectionClass) {\n+        return MultiValueMap.multiValueMap(map, collectionClass);\n+    }\n+\n+    /**\n+     * Creates a multi-value map backed by the given map which returns\n+     * collections created by the specified collection factory.\n+     *\n+     * @param map  the map to decorate\n+     * @param collectionFactory  a factor which creates collection objects\n+     * @return a multi-value map backed by the given map which returns collections\n+     * created by the specified collection factory\n+     * @see MultiValueMap\n+     * @since Commons Collections 3.2\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Factory<C> collectionFactory) {\n+        return MultiValueMap.multiValueMap(map, collectionFactory);\n+    }\n+\n+    // SortedMap decorators\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized sorted map backed by the given sorted map.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to\n+     * avoid non-deterministic behavior:\n+     *\n+     * <pre>\n+     * Map m = MapUtils.synchronizedSortedMap(myMap);\n+     * Set s = m.keySet();  // outside synchronized block\n+     * synchronized (m) {  // synchronized on MAP!\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * This method uses the implementation in {@link java.util.Collections Collections}.\n+     *\n+     * @param map  the map to synchronize, must not be null\n+     * @return a synchronized map backed by the given map\n+     * @throws IllegalArgumentException  if the map is null\n+     */\n+    public static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> map) {\n+        return Collections.synchronizedSortedMap(map);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable sorted map backed by the given sorted map.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param map  the sorted map to make unmodifiable, must not be null\n+     * @return an unmodifiable map backed by the given map\n+     * @throws IllegalArgumentException  if the map is null\n+     */\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) sorted map backed by the given map.\n+     * <p>\n+     * Only objects that pass the tests in the given predicates can be added to the map.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * Keys must pass the key predicate, values must pass the value predicate.\n+     * It is important not to use the original map after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param map  the map to predicate, must not be null\n+     * @param keyPred  the predicate for keys, null means no check\n+     * @param valuePred  the predicate for values, null means no check\n+     * @return a predicated map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap is null\n+     */\n+    public static <K, V> SortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n+            Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n+        return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n+    }\n+\n+    /**\n+     * Returns a transformed sorted map backed by the given map.\n+     * <p>\n+     * This method returns a new sorted map (decorating the specified map) that\n+     * will transform any new entries added to it.\n+     * Existing entries in the specified map will not be transformed.\n+     * If you want that behaviour, see {@link TransformedSortedMap#decorateTransform}.\n+     * <p>\n+     * Each object is passed through the transformers as it is added to the\n+     * Map. It is important not to use the original map after invoking this\n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map  the map to transform, must not be null, typically empty\n+     * @param keyTransformer  the transformer for the map keys, null means no transformation\n+     * @param valueTransformer  the transformer for the map values, null means no transformation\n+     * @return a transformed map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap is null\n+     */\n+    public static <K, V> SortedMap<K, V> transformedSortedMap(SortedMap<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Returns a fixed-sized sorted map backed by the given sorted map.\n+     * Elements may not be added or removed from the returned map, but\n+     * existing elements can be changed (for instance, via the\n+     * {@link Map#put(Object,Object)} method).\n+     *\n+     * @param map  the map whose size to fix, must not be null\n+     * @return a fixed-size map backed by that map\n+     * @throws IllegalArgumentException  if the SortedMap is null\n+     */\n+    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(SortedMap<K, V> map) {\n+        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" sorted map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key.\n+     * <p>\n+     * For instance:\n+     *\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n+     * Object obj = lazy.get(\"test\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the value for the <code>\"test\"</code> key.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap or Factory is null\n+     */\n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n+            Factory<? extends V> factory) {\n+        return LazySortedMap.lazySortedMap(map, factory);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" sorted map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key. The factory is a {@link Transformer}\n+     * that will be passed the key which it must transform into the value.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Transformer factory = new Transformer() {\n+     *     public Object transform(Object mapKey) {\n+     *         return new File(mapKey);\n+     *     }\n+     * }\n+     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n+     * Object obj = lazy.get(\"C:/dev\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>File</code> instance for the C drive dev directory.\n+     * Furthermore, that <code>File</code> instance is the value for the\n+     * <code>\"C:/dev\"</code> key in the map.\n+     * <p>\n+     * If a lazy map is wrapped by a synchronized map, the result is a simple\n+     * synchronized cache. When an object is not is the cache, the cache itself\n+     * calls back to the factory Transformer to populate itself, all within the\n+     * same synchronized block.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param transformerFactory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     */\n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n+            Transformer<? super K, ? extends V> transformerFactory) {\n+        return LazySortedMap.lazySortedMap(map, transformerFactory);\n+    }\n+\n+    /**\n+     * <p>\n+     * Populates a Map using the supplied <code>Transformer</code> to transform the collection\n+     * values into keys, using the unaltered collection value as the value in the <code>Map</code>.\n+     * </p>\n+     * @param map the <code>Map</code> to populate.\n+     * @param collection the <code>Collection</code> to use as input values for the map.\n+     * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n+     * @throws NullPointerException if the map, collection or transformer are null\n+     */\n+    public static <K, V> void populateMap(Map<K, V> map, Collection<? extends V> collection, Transformer<V, K> keyTransformer) {\n+        populateMap(map, collection, keyTransformer, TransformerUtils.<V>nopTransformer());\n+    }\n+\n+    /**\n+     * <p>\n+     * Populates a Map using the supplied <code>Transformer</code>s to transform the collection\n+     * values into keys and values.\n+     * </p>\n+     * @param map the <code>Map</code> to populate.\n+     * @param collection the <code>Collection</code> to use as input values for the map.\n+     * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n+     * @param valueTransformer the <code>Transformer</code> used to transform the collection value into a value\n+     * @throws NullPointerException if the map, collection or transformers are null\n+     */\n+    public static <K, V, E> void populateMap(Map<K, V> map, Collection<? extends E> collection, \n+            Transformer<E, K> keyTransformer, \n+            Transformer<E, V> valueTransformer) {\n+        Iterator<? extends E> iter = collection.iterator();\n+        while (iter.hasNext()) {\n+            E temp = iter.next();\n+            map.put(keyTransformer.transform(temp), valueTransformer.transform(temp));\n+        }\n+    }\n+\n+    /**\n+     * Get the specified {@link Map} as an {@link IterableMap}.\n+     * @param <K>\n+     * @param <V>\n+     * @param map to wrap if necessary.\n+     * @return IterableMap<K, V>\n+     * @since Commons Collections 5\n+     * @TODO fix version\n+     */\n+    public static <K, V> IterableMap<K, V> iterableMap(Map<K, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        return map instanceof IterableMap ? (IterableMap<K, V>) map\n+                : new AbstractMapDecorator<K, V>(map) {\n+                };\n+    }\n+\n+    /**\n+     * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n+     * @param <K>\n+     * @param <V>\n+     * @param sortedMap to wrap if necessary\n+     * @return {@link IterableSortedMap}<K, V>\n+     * @since Commons Collections 5\n+     * @TODO fix version\n+     */\n+    public static <K, V> IterableSortedMap<K, V> iterableSortedMap(SortedMap<K, V> sortedMap) {\n+        if (sortedMap == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap\n+                : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n+                };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/MultiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+\n+/** \n+ * Defines a map that holds a collection of values against each key.\n+ * <p>\n+ * A <code>MultiMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that key.\n+ * <p>\n+ * For example:\n+ * <pre>\n+ * MultiMap mhm = new MultiHashMap();\n+ * mhm.put(key, \"A\");\n+ * mhm.put(key, \"B\");\n+ * mhm.put(key, \"C\");\n+ * Collection coll = (Collection) mhm.get(key);</pre>\n+ * <p>\n+ * <code>coll</code> will be a collection containing \"A\", \"B\", \"C\".\n+ * <p>\n+ * NOTE: Additional methods were added to this interface in Commons Collections 3.1.\n+ * These were added solely for documentation purposes and do not change the interface\n+ * as they were defined in the superinterface <code>Map</code> anyway.\n+ *\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Christopher Berry\n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ */\n+public interface MultiMap<K, V> extends IterableMap<K, Object> {\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, implementations typically\n+     * return <code>null</code> from a subsequant <code>get(Object)</code>, however\n+     * they may choose to return an empty collection.\n+     * \n+     * @param key  the key to remove from\n+     * @param item  the item to remove\n+     * @return the value removed (which was passed in), null if nothing removed\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key or value is of an invalid type\n+     * @throws NullPointerException if the key or value is null and null is invalid\n+     */\n+    public V remove(K key, V item);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of keys in this map.\n+     * <p>\n+     * Implementations typically return only the count of keys in the map\n+     * This cannot be mandated due to backwards compatability of this interface.\n+     *\n+     * @return the number of key-collection mappings in this map\n+     */\n+    int size();\n+\n+    /**\n+     * Gets the collection of values associated with the specified key.\n+     * <p>\n+     * The returned value will implement <code>Collection</code>. Implementations\n+     * are free to declare that they return <code>Collection</code> subclasses\n+     * such as <code>List</code> or <code>Set</code>.\n+     * <p>\n+     * Implementations typically return <code>null</code> if no values have\n+     * been mapped to the key, however the implementation may choose to\n+     * return an empty collection.\n+     * <p>\n+     * Implementations may choose to return a clone of the internal collection.\n+     *\n+     * @param key  the key to retrieve\n+     * @return the <code>Collection</code> of values, implementations should\n+     *  return <code>null</code> for no mapping, but may return an empty collection\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Object get(K key);\n+\n+    /**\n+     * Checks whether the map contains the value specified.\n+     * <p>\n+     * Implementations typically check all collections against all keys for the value.\n+     * This cannot be mandated due to backwards compatability of this interface.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     * @throws ClassCastException if the value is of an invalid type\n+     * @throws NullPointerException if the value is null and null value are invalid\n+     */\n+    boolean containsValue(Object value);\n+\n+    /**\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     * The collection may be a <code>List</code>, <code>Set</code> or other\n+     * collection dependent on implementation.\n+     *\n+     * @param key  the key to store against\n+     * @param value  the value to add to the collection at the key\n+     * @return typically the value added if the map changed and null if the map did not change\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key or value is of an invalid type\n+     * @throws NullPointerException if the key or value is null and null is invalid\n+     * @throws IllegalArgumentException if the key or value is invalid\n+     */\n+    Object put(K key, Object value);\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * Implementations typically return <code>null</code> from a subsequant\n+     * <code>get(Object)</code>, however they may choose to return an empty collection.\n+     *\n+     * @param key  the key to remove values from\n+     * @return the <code>Collection</code> of values removed, implementations should\n+     *  return <code>null</code> for no mapping found, but may return an empty collection\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Object remove(K key);\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * Inplementations typically return a collection containing the combination\n+     * of values from all keys.\n+     * This cannot be mandated due to backwards compatability of this interface.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    Collection<Object> values();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/OrderedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values\n+ * and retains and provides access to an ordering.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface OrderedBidiMap<K, V> extends BidiMap<K, V>, OrderedMap<K, V> {\n+\n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed equally.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     * <p>\n+     * Implementations must return an <code>OrderedBidiMap</code> instance,\n+     * usually by forwarding to <code>inverseOrderedBidiMap()</code>.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public OrderedBidiMap<V, K> inverseBidiMap();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/OrderedIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Defines an iterator that operates over an ordered container. Subset of {@link ListIterator}.\n+ * <p>\n+ * This iterator allows both forward and reverse iteration through the container.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface OrderedIterator<E> extends Iterator<E> {\n+\n+    /**\n+     * Checks to see if there is a previous element that can be iterated to.\n+     *\n+     * @return <code>true</code> if the iterator has a previous element\n+     */\n+    boolean hasPrevious();\n+\n+    /**\n+     * Gets the previous element from the container.\n+     *\n+     * @return the previous element in the iteration\n+     * @throws NoSuchElementException if the iteration is finished\n+     */\n+    E previous();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/OrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a map that maintains order and allows both forward and backward\n+ * iteration through that order.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface OrderedMap<K, V> extends IterableMap<K, V> {\n+\n+    /**\n+     * Obtains an <code>OrderedMapIterator</code> over the map.\n+     * <p>\n+     * A ordered map iterator is an efficient way of iterating over maps\n+     * in both directions.\n+     * \n+     * @return a map iterator\n+     */\n+    OrderedMapIterator<K, V> mapIterator();\n+\n+    /**\n+     * Gets the first key currently in this map.\n+     *\n+     * @return the first key currently in this map\n+     * @throws java.util.NoSuchElementException if this map is empty\n+     */\n+    public K firstKey();\n+\n+    /**\n+     * Gets the last key currently in this map.\n+     *\n+     * @return the last key currently in this map\n+     * @throws java.util.NoSuchElementException if this map is empty\n+     */\n+    public K lastKey();\n+\n+    /**\n+     * Gets the next key after the one specified.\n+     *\n+     * @param key  the key to search for next from\n+     * @return the next key, null if no match or at end\n+     */\n+    public K nextKey(K key);\n+\n+    /**\n+     * Gets the previous key before the one specified.\n+     *\n+     * @param key  the key to search for previous from\n+     * @return the previous key, null if no match or at start\n+     */\n+    public K previousKey(K key);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/OrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Defines an iterator that operates over an ordered <code>Map</code>.\n+ * <p>\n+ * This iterator allows both forward and reverse iteration through the map.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface OrderedMapIterator<K, V> extends MapIterator<K, V>, OrderedIterator<K> {\n+\n+    /**\n+     * Checks to see if there is a previous entry that can be iterated to.\n+     *\n+     * @return <code>true</code> if the iterator has a previous element\n+     */\n+    boolean hasPrevious();\n+\n+    /**\n+     * Gets the previous <em>key</em> from the <code>Map</code>.\n+     *\n+     * @return the previous key in the iteration\n+     * @throws NoSuchElementException if the iteration is finished\n+     */\n+    K previous();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Predicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a functor interface implemented by classes that perform a predicate\n+ * test on an object.\n+ * <p>\n+ * A <code>Predicate</code> is the object equivalent of an <code>if</code> statement.\n+ * It uses the input object to return a true or false value, and is often used in\n+ * validation or filtering.\n+ * <p>\n+ * Standard implementations of common predicates are provided by\n+ * {@link PredicateUtils}. These include true, false, instanceof, equals, and,\n+ * or, not, method invokation and null testing.\n+ *\n+ * @param <T> the type that the predicate queries\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ */\n+public interface Predicate<T> {\n+\n+    /**\n+     * Use the specified parameter to perform a test that returns true or false.\n+     *\n+     * @param object  the object to evaluate, should not be changed\n+     * @return true or false\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if the predicate encounters a problem\n+     */\n+    public boolean evaluate(T object);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/PredicateUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.functors.AllPredicate;\n+import org.apache.commons.collections.functors.AndPredicate;\n+import org.apache.commons.collections.functors.AnyPredicate;\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionPredicate;\n+import org.apache.commons.collections.functors.FalsePredicate;\n+import org.apache.commons.collections.functors.IdentityPredicate;\n+import org.apache.commons.collections.functors.InstanceofPredicate;\n+import org.apache.commons.collections.functors.InvokerTransformer;\n+import org.apache.commons.collections.functors.NonePredicate;\n+import org.apache.commons.collections.functors.NotNullPredicate;\n+import org.apache.commons.collections.functors.NotPredicate;\n+import org.apache.commons.collections.functors.NullIsExceptionPredicate;\n+import org.apache.commons.collections.functors.NullIsFalsePredicate;\n+import org.apache.commons.collections.functors.NullIsTruePredicate;\n+import org.apache.commons.collections.functors.NullPredicate;\n+import org.apache.commons.collections.functors.OnePredicate;\n+import org.apache.commons.collections.functors.OrPredicate;\n+import org.apache.commons.collections.functors.TransformedPredicate;\n+import org.apache.commons.collections.functors.TransformerPredicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+import org.apache.commons.collections.functors.UniquePredicate;\n+\n+/**\n+ * <code>PredicateUtils</code> provides reference implementations and utilities\n+ * for the Predicate functor interface. The supplied predicates are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>InstanceOf - true if the object is an instanceof a class\n+ * <li>Equal - true if the object equals() a specified object\n+ * <li>Identity - true if the object == a specified object\n+ * <li>Null - true if the object is null\n+ * <li>NotNull - true if the object is not null\n+ * <li>Unique - true if the object has not already been evaluated\n+ * <li>And/All - true if all of the predicates are true\n+ * <li>Or/Any - true if any of the predicates is true\n+ * <li>Either/One - true if only one of the predicate is true\n+ * <li>Neither/None - true if none of the predicates are true\n+ * <li>Not - true if the predicate is false, and vice versa\n+ * <li>Transformer - wraps a Transformer as a Predicate\n+ * <li>True - always return true\n+ * <li>False - always return false\n+ * <li>Exception - always throws an exception\n+ * <li>NullIsException/NullIsFalse/NullIsTrue - check for null input\n+ * <li>Transformed - transforms the input before calling the predicate\n+ * </ul>\n+ * All the supplied predicates are Serializable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Ola Berg\n+ */\n+public class PredicateUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public PredicateUtils() {\n+        super();\n+    }\n+\n+    // Simple predicates\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a Predicate that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections.functors.ExceptionPredicate\n+     *\n+     * @return the predicate\n+     */\n+    public static <T> Predicate<T> exceptionPredicate() {\n+        return ExceptionPredicate.<T>exceptionPredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns true.\n+     *\n+     * @see org.apache.commons.collections.functors.TruePredicate\n+     *\n+     * @return the predicate\n+     * @deprecated use {@link TruePredicate#truePredicate()} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> truePredicate() {\n+        return TruePredicate.truePredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.FalsePredicate\n+     *\n+     * @return the predicate\n+     * @deprecated use {@link FalsePredicate#falsePredicate()} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> falsePredicate() {\n+        return FalsePredicate.<T> falsePredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is null.\n+     *\n+     * @see org.apache.commons.collections.functors.NullPredicate\n+     *\n+     * @return the predicate\n+     * @deprecated use {@link NullPredicate#nullPredicate()} instead\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> nullPredicate() {\n+        return NullPredicate.nullPredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is not null.\n+     *\n+     * @see org.apache.commons.collections.functors.NotNullPredicate\n+     *\n+     * @return the predicate\n+     */\n+    public static <T> Predicate<T> notNullPredicate() {\n+        return NotNullPredicate.<T>notNullPredicate();\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object using equals().\n+     *\n+     * @see org.apache.commons.collections.functors.EqualPredicate\n+     *\n+     * @param value  the value to compare against\n+     * @return the predicate\n+     * @deprecated use {@link EqualPredicate#equalPredicate(Object)} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> equalPredicate(T value) {\n+        return EqualPredicate.equalPredicate(value);\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object by identity.\n+     *\n+     * @see org.apache.commons.collections.functors.IdentityPredicate\n+     *\n+     * @param value  the value to compare against\n+     * @return the predicate\n+     */\n+    public static <T> Predicate<T> identityPredicate(T value) {\n+        return IdentityPredicate.<T>identityPredicate(value);\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the object passed in is of\n+     * a particular type, using instanceof. A <code>null</code> input\n+     * object will return <code>false</code>.\n+     *\n+     * @see org.apache.commons.collections.functors.InstanceofPredicate\n+     *\n+     * @param type  the type to check for, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Predicate<Object> instanceofPredicate(Class<?> type) {\n+        return InstanceofPredicate.instanceOfPredicate(type);\n+    }\n+\n+    /**\n+     * Creates a Predicate that returns true the first time an object is\n+     * encountered, and false if the same object is received\n+     * again. The comparison is by equals(). A <code>null</code> input object\n+     * is accepted and will return true the first time, and false subsequently\n+     * as well.\n+     *\n+     * @see org.apache.commons.collections.functors.UniquePredicate\n+     *\n+     * @return the predicate\n+     */\n+    public static <T> Predicate<T> uniquePredicate() {\n+        // must return new instance each time\n+        return UniquePredicate.<T>uniquePredicate();\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a\n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to\n+     * determine the predicate result.\n+     *\n+     * @see org.apache.commons.collections.functors.InvokerTransformer\n+     * @see org.apache.commons.collections.functors.TransformerPredicate\n+     *\n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the methodName is null.\n+     */\n+    public static <T> Predicate<T> invokerPredicate(String methodName){\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a\n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to\n+     * determine the predicate result.\n+     *\n+     * @see org.apache.commons.collections.functors.InvokerTransformer\n+     * @see org.apache.commons.collections.functors.TransformerPredicate\n+     *\n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static <T> Predicate<T> invokerPredicate(String methodName, Class<?>[] paramTypes, Object[] args){\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    // Boolean combinations\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that returns true only if both of the specified\n+     * predicates are true.\n+     *\n+     * @see org.apache.commons.collections.functors.AndPredicate\n+     *\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>and</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static <T> Predicate<T> andPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        return AndPredicate.<T>andPredicate(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns true.\n+     *\n+     * @see org.apache.commons.collections.functors.AllPredicate\n+     *\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @deprecated use {@link AllPredicate#allPredicate(Predicate...)} instead.\n+     */\n+    @Deprecated\n+    public static <T> Predicate<T> allPredicate(Predicate<? super T>[] predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns true.\n+     *\n+     * @see org.apache.commons.collections.functors.AllPredicate\n+     *\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static <T> Predicate<T> allPredicate(Collection<? extends Predicate<T>> predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if either of the specified\n+     * predicates are true.\n+     *\n+     * @see org.apache.commons.collections.functors.OrPredicate\n+     *\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>or</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static <T> Predicate<T> orPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        return OrPredicate.<T>orPredicate(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.AnyPredicate\n+     *\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> anyPredicate(Predicate<? super T>[] predicates) {\n+        return AnyPredicate.anyPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.AnyPredicate\n+     *\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static <T> Predicate<T> anyPredicate(Collection<? extends Predicate<T>> predicates) {\n+        return AnyPredicate.anyPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if one, but not both, of the\n+     * specified predicates are true. XOR\n+     *\n+     * @see org.apache.commons.collections.functors.OnePredicate\n+     *\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>either</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> eitherPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        return onePredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.OnePredicate\n+     *\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> onePredicate(Predicate<? super T>[] predicates) {\n+        return OnePredicate.onePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns false.\n+     *\n+     * @see org.apache.commons.collections.functors.OnePredicate\n+     *\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static <T> Predicate<T> onePredicate(Collection<Predicate<T>> predicates) {\n+        return OnePredicate.onePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if neither of the specified\n+     * predicates are true.\n+     *\n+     * @see org.apache.commons.collections.functors.NonePredicate\n+     *\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>neither</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> neitherPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        return nonePredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns true.\n+     *\n+     * @see org.apache.commons.collections.functors.NonePredicate\n+     *\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>none</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> nonePredicate(Predicate<? super T>[] predicates) {\n+        return NonePredicate.nonePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns true.\n+     *\n+     * @see org.apache.commons.collections.functors.NonePredicate\n+     *\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>none</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static <T> Predicate<T> nonePredicate(Collection<? extends Predicate<T>> predicates) {\n+        return NonePredicate.nonePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if the specified predicate\n+     * returns false and vice versa.\n+     *\n+     * @see org.apache.commons.collections.functors.NotPredicate\n+     *\n+     * @param predicate  the predicate to not\n+     * @return the <code>not</code> predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> notPredicate(Predicate<? super T> predicate) {\n+        return NotPredicate.notPredicate(predicate);\n+    }\n+\n+    // Adaptors\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that wraps a Transformer. The Transformer must\n+     * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n+     * will be thrown.\n+     *\n+     * @see org.apache.commons.collections.functors.TransformerPredicate\n+     *\n+     * @param transformer  the transformer to wrap, may not be null\n+     * @return the transformer wrapping predicate\n+     * @throws IllegalArgumentException if the transformer is null\n+     */\n+    public static <T> Predicate<T> asPredicate(Transformer<? super T, Boolean> transformer) {\n+        return TransformerPredicate.transformerPredicate(transformer);\n+    }\n+\n+    // Null handlers\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a Predicate that throws an exception if the input object is null,\n+     * otherwise it calls the specified Predicate. This allows null handling\n+     * behaviour to be added to Predicates that don't support nulls.\n+     *\n+     * @see org.apache.commons.collections.functors.NullIsExceptionPredicate\n+     *\n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static <T> Predicate<T> nullIsExceptionPredicate(Predicate<? super T> predicate){\n+        return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns false if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     *\n+     * @see org.apache.commons.collections.functors.NullIsFalsePredicate\n+     *\n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static <T> Predicate<T> nullIsFalsePredicate(Predicate<? super T> predicate){\n+        return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns true if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     *\n+     * @see org.apache.commons.collections.functors.NullIsTruePredicate\n+     *\n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static <T> Predicate<T> nullIsTruePredicate(Predicate<? super T> predicate){\n+        return NullIsTruePredicate.nullIsTruePredicate(predicate);\n+    }\n+\n+    // Transformed\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a predicate that transforms the input object before passing it\n+     * to the predicate.\n+     *\n+     * @see org.apache.commons.collections.functors.TransformedPredicate\n+     *\n+     * @param transformer  the transformer to call first\n+     * @param predicate  the predicate to call with the result of the transform\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the transformer or the predicate is null\n+     * @since Commons Collections 3.1\n+     */\n+    public static <T> Predicate<T> transformedPredicate(\n+            Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n+        return TransformedPredicate.<T>transformedPredicate(transformer, predicate);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Put.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Map;\n+\n+/**\n+ * The \"write\" subset of the {@link Map} interface.\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ * @see Get\n+ * @author Matt Benson\n+ */\n+public interface Put<K, V> {\n+\n+    /**\n+     * @see Map#clear()\n+     */\n+    public void clear();\n+\n+    /**\n+     * @see Map#put(Object, Object)\n+     */\n+    public Object put(K key, V value);\n+\n+    /**\n+     * @see Map#putAll(Map)\n+     */\n+    public void putAll(Map<? extends K, ? extends V> t);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/ResettableIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Iterator;\n+\n+/** \n+ * Defines an iterator that can be reset back to an initial state.\n+ * <p>\n+ * This interface allows an iterator to be repeatedly reused.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface ResettableIterator<E> extends Iterator<E> {\n+\n+    /**\n+     * Resets the iterator back to the position at which the iterator\n+     * was created.\n+     */\n+    public void reset();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/ResettableListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ListIterator;\n+\n+/** \n+ * Defines a list iterator that can be reset back to an initial state.\n+ * <p>\n+ * This interface allows an iterator to be repeatedly reused.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface ResettableListIterator<E> extends ListIterator<E>, ResettableIterator<E>, OrderedIterator<E> {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/SetUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections.set.ListOrderedSet;\n+import org.apache.commons.collections.set.PredicatedSet;\n+import org.apache.commons.collections.set.PredicatedSortedSet;\n+import org.apache.commons.collections.set.SynchronizedSet;\n+import org.apache.commons.collections.set.SynchronizedSortedSet;\n+import org.apache.commons.collections.set.TransformedSet;\n+import org.apache.commons.collections.set.TransformedSortedSet;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+import org.apache.commons.collections.set.UnmodifiableSortedSet;\n+\n+/**\n+ * Provides utility methods and decorators for\n+ * {@link Set} and {@link SortedSet} instances.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Neil O'Toole\n+ * @author Matthew Hawthorne\n+ */\n+public class SetUtils {\n+\n+    /**\n+     * An empty unmodifiable set.\n+     * This uses the {@link Collections} implementation \n+     * and is provided for completeness.\n+     */\n+    public static final Set<?> EMPTY_SET = Collections.EMPTY_SET;\n+\n+    /**\n+     * Get a typed empty unmodifiable Set.\n+     * @param <E>\n+     * @return Set<E>\n+     */\n+    public static <E> Set<E> emptySet() {\n+        return Collections.<E>emptySet();\n+    }\n+\n+    /**\n+     * An empty unmodifiable sorted set.\n+     * This is not provided in the JDK.\n+     */\n+    public static final SortedSet<?> EMPTY_SORTED_SET = UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());\n+\n+    /**\n+     * Get a typed empty unmodifiable sorted set.\n+     * @param <E>\n+     * @return SortedSet<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> SortedSet<E> emptySortedSet() {\n+        return (SortedSet<E>) EMPTY_SORTED_SET;\n+    }\n+\n+    /**\n+     * <code>SetUtils</code> should not normally be instantiated.\n+     */\n+    public SetUtils() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests two sets for equality as per the <code>equals()</code> contract\n+     * in {@link java.util.Set#equals(java.lang.Object)}.\n+     * <p>\n+     * This method is useful for implementing <code>Set</code> when you cannot\n+     * extend AbstractSet. The method takes Collection instances to enable other\n+     * collection types to use the Set implementation algorithm.\n+     * <p>\n+     * The relevant text (slightly paraphrased as this is a static method) is:\n+     * <blockquote>\n+     * <p>Two sets are considered equal if they have\n+     * the same size, and every member of the first set is contained in\n+     * the second. This ensures that the <tt>equals</tt> method works\n+     * properly across different implementations of the <tt>Set</tt>\n+     * interface.</p>\n+     * \n+     * <p>\n+     * This implementation first checks if the two sets are the same object: \n+     * if so it returns <tt>true</tt>.  Then, it checks if the two sets are\n+     * identical in size; if not, it returns false. If so, it returns\n+     * <tt>a.containsAll((Collection) b)</tt>.</p>\n+     * </blockquote>\n+     * \n+     * @see java.util.Set\n+     * @param set1  the first set, may be null\n+     * @param set2  the second set, may be null\n+     * @return whether the sets are equal by value comparison\n+     */\n+    public static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n+        if (set1 == set2) {\n+            return true;\n+        }\n+        if (set1 == null || set2 == null || set1.size() != set2.size()) {\n+            return false;\n+        }\n+\n+        return set1.containsAll(set2);\n+    }\n+\n+    /**\n+     * Generates a hash code using the algorithm specified in \n+     * {@link java.util.Set#hashCode()}.\n+     * <p>\n+     * This method is useful for implementing <code>Set</code> when you cannot\n+     * extend AbstractSet. The method takes Collection instances to enable other\n+     * collection types to use the Set implementation algorithm.\n+     * \n+     * @see java.util.Set#hashCode()\n+     * @param set  the set to calculate the hash code for, may be null\n+     * @return the hash code\n+     */\n+    public static <T> int hashCodeForSet(final Collection<T> set) {\n+        if (set == null) {\n+            return 0;\n+        }\n+\n+        int hashCode = 0;\n+        for (T obj : set) {\n+            if (obj != null) {\n+                hashCode += obj.hashCode();\n+            }\n+        }\n+        return hashCode;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized set backed by the given set.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to \n+     * avoid non-deterministic behavior:\n+     *  \n+     * <pre>\n+     * Set s = SetUtils.synchronizedSet(mySet);\n+     * synchronized (s) {\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * This method uses the implementation in the decorators subpackage.\n+     * \n+     * @param set  the set to synchronize, must not be null\n+     * @return a synchronized set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <T> Set<T> synchronizedSet(Set<T> set) {\n+        return SynchronizedSet.synchronizedSet(set);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable set backed by the given set.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param set  the set to make unmodifiable, must not be null\n+     * @return an unmodifiable set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <E> Set<E> unmodifiableSet(Set<E> set) {\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) set backed by the given set.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the set.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original set after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param set  the set to predicate, must not be null\n+     * @param predicate  the predicate for the set, must not be null\n+     * @return a predicated set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     */\n+    public static <T> Set<T> predicatedSet(Set<T> set, Predicate<? super T> predicate) {\n+        return PredicatedSet.predicatedSet(set, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed set backed by the given set.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Set. It is important not to use the original set after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified set will not be transformed.\n+     * If you want that behaviour, see {@link TransformedSet#decorateTransform}.\n+     *\n+     * @param set  the set to transform, must not be null\n+     * @param transformer  the transformer for the set, must not be null\n+     * @return a transformed set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     */\n+    public static <E> Set<E> transformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedSet.transformingSet(set, transformer);\n+    }\n+    \n+    /**\n+     * Returns a set that maintains the order of elements that are added\n+     * backed by the given set.\n+     * <p>\n+     * If an element is added twice, the order is determined by the first add.\n+     * The order is observed through the iterator or toArray.\n+     *\n+     * @param set  the set to order, must not be null\n+     * @return an ordered set backed by the given set\n+     * @throws IllegalArgumentException  if the Set is null\n+     */\n+    public static <E> Set<E> orderedSet(Set<E> set) {\n+        return ListOrderedSet.listOrderedSet(set);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized sorted set backed by the given sorted set.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to \n+     * avoid non-deterministic behavior:\n+     *  \n+     * <pre>\n+     * Set s = SetUtils.synchronizedSet(mySet);\n+     * synchronized (s) {\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * This method uses the implementation in the decorators subpackage.\n+     * \n+     * @param set  the sorted set to synchronize, must not be null\n+     * @return a synchronized set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> set) {\n+        return SynchronizedSortedSet.synchronizedSortedSet(set);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable sorted set backed by the given sorted set.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param set  the sorted set to make unmodifiable, must not be null\n+     * @return an unmodifiable set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> set) {\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) sorted set backed by the given sorted set.  \n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the set.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original set after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param set  the sorted set to predicate, must not be null\n+     * @param predicate  the predicate for the sorted set, must not be null\n+     * @return a predicated sorted set backed by the given sorted set\n+     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     */\n+    public static <T> SortedSet<T> predicatedSortedSet(SortedSet<T> set, Predicate<? super T> predicate) {\n+        return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed sorted set backed by the given set.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Set. It is important not to use the original set after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified set will not be transformed.\n+     * If you want that behaviour, see {@link TransformedSortedSet#decorateTransform}.\n+     *\n+     * @param set  the set to transform, must not be null\n+     * @param transformer  the transformer for the set, must not be null\n+     * @return a transformed set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     */\n+    public static <E> SortedSet<E> transformedSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+        return TransformedSortedSet.transformingSortedSet(set, transformer);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/SortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Comparator;\n+\n+/**\n+ * Defines a type of <code>Bag</code> that maintains a sorted order among\n+ * its unique representative members.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ */\n+public interface SortedBag<E> extends Bag<E> {\n+\n+    /**\n+     * Returns the comparator associated with this sorted set, or null\n+     * if it uses its elements' natural ordering.\n+     * \n+     * @return the comparator in use, or null if natural ordering\n+     */\n+    public Comparator<? super E> comparator();\n+\n+    /**\n+     * Returns the first (lowest) member.\n+     * \n+     * @return the first element in the sorted bag\n+     */\n+    public E first();\n+\n+    /**\n+     * Returns the last (highest) member.\n+     * \n+     * @return the last element in the sorted bag\n+     */\n+    public E last();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/SortedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values\n+ * and retains both keys and values in sorted order.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ *  \n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface SortedBidiMap<K, V> extends OrderedBidiMap<K, V>, SortedMap<K, V> {\n+\n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed equally.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     * <p>\n+     * Implementations must return a <code>SortedBidiMap</code> instance,\n+     * usually by forwarding to <code>inverseSortedBidiMap()</code>.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public SortedBidiMap<V, K> inverseBidiMap();\n+\n+    /**\n+     * Get the comparator used for the values in the value-to-key map aspect.\n+     * @return Comparator<? super V>\n+     */\n+    public Comparator<? super V> valueComparator();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Transformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Defines a functor interface implemented by classes that transform one\n+ * object into another.\n+ * <p>\n+ * A <code>Transformer</code> converts the input object to the output object.\n+ * The input object should be left unchanged.\n+ * Transformers are typically used for type conversions, or extracting data\n+ * from an object.\n+ * <p>\n+ * Standard implementations of common transformers are provided by\n+ * {@link TransformerUtils}. These include method invokation, returning a constant,\n+ * cloning and returning the string value.\n+ *\n+ * @param <I> the input type to the transformer\n+ * @param <O> the output type from the transformer\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ */\n+public interface Transformer<I, O> {\n+\n+    /**\n+     * Transforms the input object (leaving it unchanged) into some output object.\n+     *\n+     * @param input  the object to be transformed, should be left unchanged\n+     * @return a transformed object\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if the transform cannot be completed\n+     */\n+    public O transform(I input);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/TransformerUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.functors.ChainedTransformer;\n+import org.apache.commons.collections.functors.CloneTransformer;\n+import org.apache.commons.collections.functors.ClosureTransformer;\n+import org.apache.commons.collections.functors.ConstantTransformer;\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionTransformer;\n+import org.apache.commons.collections.functors.FactoryTransformer;\n+import org.apache.commons.collections.functors.InstantiateTransformer;\n+import org.apache.commons.collections.functors.InvokerTransformer;\n+import org.apache.commons.collections.functors.MapTransformer;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+import org.apache.commons.collections.functors.PredicateTransformer;\n+import org.apache.commons.collections.functors.StringValueTransformer;\n+import org.apache.commons.collections.functors.SwitchTransformer;\n+\n+/**\n+ * <code>TransformerUtils</code> provides reference implementations and \n+ * utilities for the Transformer functor interface. The supplied transformers are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>Clone - returns a clone of the input object\n+ * <li>Constant - always returns the same object\n+ * <li>Closure - performs a Closure and returns the input object\n+ * <li>Predicate - returns the result of the predicate as a Boolean\n+ * <li>Factory - returns a new object from a factory\n+ * <li>Chained - chains two or more transformers together\n+ * <li>Switch - calls one transformer based on one or more predicates\n+ * <li>SwitchMap - calls one transformer looked up from a Map\n+ * <li>Instantiate - the Class input object is instantiated\n+ * <li>Map - returns an object from a supplied Map\n+ * <li>Null - always returns null\n+ * <li>NOP - returns the input object, which should be immutable\n+ * <li>Exception - always throws an exception\n+ * <li>StringValue - returns a <code>java.lang.String</code> representation of the input object\n+ * </ul>\n+ * All the supplied transformers are Serializable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author James Carman\n+ */\n+public class TransformerUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public TransformerUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a transformer that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     * \n+     * @see org.apache.commons.collections.functors.ExceptionTransformer\n+     * \n+     * @return the transformer\n+     */\n+    public static <I, O> Transformer<I, O> exceptionTransformer() {\n+        return ExceptionTransformer.<I, O>exceptionTransformer();\n+    }\n+\n+    /**\n+     * Gets a transformer that always returns null.\n+     * \n+     * @see org.apache.commons.collections.functors.ConstantTransformer\n+     * \n+     * @return the transformer\n+     */\n+    public static <I, O> Transformer<I, O> nullTransformer() {\n+        return ConstantTransformer.<I, O>nullTransformer();\n+    }\n+\n+    /**\n+     * Gets a transformer that returns the input object.\n+     * The input object should be immutable to maintain the\n+     * contract of Transformer (although this is not checked).\n+     * \n+     * @see org.apache.commons.collections.functors.NOPTransformer\n+     * \n+     * @return the transformer\n+     */\n+    public static <T> Transformer<T, T> nopTransformer() {\n+        return NOPTransformer.<T>nopTransformer();\n+    }\n+\n+    /**\n+     * Gets a transformer that returns a clone of the input\n+     * object. The input object will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     * \n+     * @see org.apache.commons.collections.functors.CloneTransformer\n+     * \n+     * @return the transformer\n+     */\n+    public static <T> Transformer<T, T> cloneTransformer() {\n+        return CloneTransformer.<T>cloneTransformer();\n+    }\n+\n+    /**\n+     * Creates a Transformer that will return the same object each time the \n+     * transformer is used.\n+     *\n+     * @see org.apache.commons.collections.functors.ConstantTransformer\n+     * \n+     * @param constantToReturn  the constant object to return each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static <I, O> Transformer<I, O> constantTransformer(O constantToReturn) {\n+        return ConstantTransformer.constantTransformer(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Closure each time the transformer is used.\n+     * The transformer returns the input object.\n+     *\n+     * @see org.apache.commons.collections.functors.ClosureTransformer\n+     * \n+     * @param closure  the closure to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the closure is null\n+     */\n+    public static <T> Transformer<T, T> asTransformer(Closure<? super T> closure) {\n+        return ClosureTransformer.closureTransformer(closure);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Predicate each time the transformer is used.\n+     * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n+     *\n+     * @see org.apache.commons.collections.functors.PredicateTransformer\n+     * \n+     * @param predicate  the predicate to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Transformer<T, Boolean> asTransformer(Predicate<? super T> predicate) {\n+        return PredicateTransformer.predicateTransformer(predicate);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Factory each time the transformer is used.\n+     * The transformer will return the value returned by the factory.\n+     *\n+     * @see org.apache.commons.collections.functors.FactoryTransformer\n+     * \n+     * @param factory  the factory to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the factory is null\n+     */\n+    public static <I, O> Transformer<I, O> asTransformer(Factory<? extends O> factory) {\n+        return FactoryTransformer.factoryTransformer(factory);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls two transformers, passing the result of\n+     * the first into the second.\n+     * \n+     * @see org.apache.commons.collections.functors.ChainedTransformer\n+     * \n+     * @param transformer1  the first transformer\n+     * @param transformer2  the second transformer\n+     * @return the transformer\n+     * @throws IllegalArgumentException if either transformer is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic static <T> Transformer<T, T> chainedTransformer(\n+            Transformer<? super T, ? extends T> transformer1,\n+            Transformer<? super T, ? extends T> transformer2) {\n+        return ChainedTransformer.<T> chainedTransformer(transformer1, transformer2);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer.\n+     * \n+     * @see org.apache.commons.collections.functors.ChainedTransformer\n+     * \n+     * @param transformers  an array of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers array is null\n+     * @throws IllegalArgumentException if any transformer in the array is null\n+     */\n+    public static <T> Transformer<T, T> chainedTransformer(Transformer<? super T, ? extends T>[] transformers) {\n+        return ChainedTransformer.chainedTransformer(transformers);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @see org.apache.commons.collections.functors.ChainedTransformer\n+     * \n+     * @param transformers  a collection of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers collection is null\n+     * @throws IllegalArgumentException if any transformer in the collection is null\n+     */\n+    public static <T> Transformer<T, T> chainedTransformer(\n+            Collection<? extends Transformer<T, T>> transformers) {\n+        return ChainedTransformer.chainedTransformer(transformers);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of two transformers depending \n+     * on the specified predicate.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchTransformer\n+     * \n+     * @param predicate  the predicate to switch on\n+     * @param trueTransformer  the transformer called if the predicate is true\n+     * @param falseTransformer  the transformer called if the predicate is false\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either transformer is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I> predicate,\n+            Transformer<? super I, ? extends O> trueTransformer,\n+            Transformer<? super I, ? extends O> falseTransformer) {\n+        return SwitchTransformer.switchTransformer(new Predicate[] { predicate },\n+                new Transformer[] { trueTransformer }, falseTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, null is returned.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchTransformer\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n+            Transformer<? super I, ? extends O>[] transformers) {\n+        return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, null);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. If the default transformer is null, null is returned.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchTransformer\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @param defaultTransformer  the default to call if no predicate matches, null means return null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n+            Transformer<? super I, ? extends O>[] transformers,\n+            Transformer<? super I, ? extends O> defaultTransformer) {\n+        return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, defaultTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. The default transformer is set in the map with a \n+     * null key. If no default transformer is set, null will be returned in a default\n+     * case. The ordering is that of the iterator() method on the entryset collection \n+     * of the map.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchTransformer\n+     * \n+     * @param predicatesAndTransformers  a map of predicates to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static <I, O> Transformer<I, O> switchTransformer(\n+            Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n+        return SwitchTransformer.<I, O>switchTransformer(predicatesAndTransformers);\n+    }\n+\n+    /**\n+     * Create a new Transformer that uses the input object as a key to find the\n+     * transformer to call. \n+     * <p>\n+     * The Map consists of object keys and Transformer values. A transformer \n+     * is called if the input object equals the key. If there is no match, the\n+     * default transformer is called. The default transformer is set in the map\n+     * using a null key. If no default is set, null will be returned in a default case.\n+     * \n+     * @see org.apache.commons.collections.functors.SwitchTransformer\n+     * \n+     * @param objectsAndTransformers  a map of objects to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchMapTransformer(Map<I, Transformer<I, O>> objectsAndTransformers) {\n+        Transformer<? super I, ? extends O>[] trs = null;\n+        Predicate<I>[] preds = null;\n+        if (objectsAndTransformers == null) {\n+            throw new IllegalArgumentException(\"The object and transformer map must not be null\");\n+        }\n+        Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n+        int size = objectsAndTransformers.size();\n+        trs = new Transformer[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n+            preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n+            trs[i++] = entry.getValue();\n+        }\n+        return TransformerUtils.<I, O>switchTransformer(preds, trs, def);\n+    }\n+\n+    /**\n+     * Gets a Transformer that expects an input Class object that it will instantiate.\n+     * \n+     * @see org.apache.commons.collections.functors.InstantiateTransformer\n+     * \n+     * @return the transformer\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n+        return InstantiateTransformer.<T>instantiateTransformer();\n+    }\n+\n+    /** \n+     * Creates a Transformer that expects an input Class object that it will \n+     * instantiate. The constructor used is determined by the arguments specified\n+     * to this method.\n+     *\n+     * @see org.apache.commons.collections.functors.InstantiateTransformer\n+     * \n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(\n+            Class<?>[] paramTypes, Object[] args) {\n+        return InstantiateTransformer.<T>instantiateTransformer(paramTypes, args);\n+    }\n+\n+    /** \n+     * Creates a Transformer that uses the passed in Map to transform the input \n+     * object (as a simple lookup).\n+     *\n+     * @see org.apache.commons.collections.functors.MapTransformer\n+     * \n+     * @param map  the map to use to transform the objects\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {\n+        return MapTransformer.mapTransformer(map);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method must have no parameters. If the input object is null, \n+     * null is returned.\n+     * <p>\n+     * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n+     * will call the <code>getName/code> method on the input object to \n+     * determine the transformer result.\n+     * \n+     * @see org.apache.commons.collections.functors.InvokerTransformer\n+     * \n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the methodName is null.\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(String methodName){\n+        return InvokerTransformer.<I, O>invokerTransformer(methodName, null, null);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method parameters are specified. If the input object is null, \n+     * null is returned.\n+     * \n+     * @see org.apache.commons.collections.functors.InvokerTransformer\n+     * \n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args){\n+        return InvokerTransformer.<I, O>invokerTransformer(methodName, paramTypes, args);\n+    }\n+\n+    /**\n+     * Gets a transformer that returns a <code>java.lang.String</code>\n+     * representation of the input object. This is achieved via the\n+     * <code>toString</code> method, <code>null</code> returns 'null'.\n+     * \n+     * @see org.apache.commons.collections.functors.StringValueTransformer\n+     * \n+     * @return the transformer\n+     */\n+    public static <T> Transformer<T, String> stringValueTransformer() {\n+        return StringValueTransformer.<T>stringValueTransformer();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Unmodifiable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Marker interface for collections, maps and iterators that are unmodifiable.\n+ * <p>\n+ * This interface enables testing such as:\n+ * <pre>\n+ * if (coll instanceof Unmodifiable) {\n+ *   coll = new ArrayList(coll);\n+ * }\n+ * // now we know coll is modifiable\n+ * </pre>\n+ * Of course all this only works if you use the Unmodifiable classes defined\n+ * in this library. If you use the JDK unmodifiable class via java util Collections\n+ * then the interface won't be there.\n+ *  \n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public interface Unmodifiable {\n+    // marker interface - no methods to implement\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/AbstractBagDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another <code>Bag</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated bag.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractBagDecorator<E>\n+        extends AbstractCollectionDecorator<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3768146017343785417L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractBagDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractBagDecorator(Bag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected Bag<E> decorated() {\n+        return (Bag<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getCount(Object object) {\n+        return decorated().getCount(object);\n+    }\n+\n+    public boolean add(E object, int count) {\n+        return decorated().add(object, count);\n+    }\n+\n+    public boolean remove(Object object, int count) {\n+        return decorated().remove(object, count);\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        return decorated().uniqueSet();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/AbstractMapBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Abstract implementation of the {@link Bag} interface to simplify the creation\n+ * of subclass implementations.\n+ * <p>\n+ * Subclasses specify a Map implementation to use as the internal storage. The\n+ * map will be used to map bag elements to a number; the number represents the\n+ * number of occurrences of that element in the bag.\n+ *\n+ * @since Commons Collections 3.0 (previously DefaultMapBag v2.0)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ * @author Michael A. Smith\n+ * @author Stephen Colebourne\n+ * @author Janek Bogucki\n+ * @author Steve Clark\n+ */\n+public abstract class AbstractMapBag<E> implements Bag<E> {\n+\n+    /** The map to use to store the data */\n+    private transient Map<E, MutableInteger> map;\n+    /** The current total size of the bag */\n+    private int size;\n+    /** The modification count for fail fast iterators */\n+    private transient int modCount;\n+    /** The modification count for fail fast iterators */\n+    private transient Set<E> uniqueSet;\n+\n+    /**\n+     * Constructor needed for subclass serialisation.\n+     * \n+     */\n+    protected AbstractMapBag() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that assigns the specified Map as the backing store. The map\n+     * must be empty and non-null.\n+     * \n+     * @param map the map to assign\n+     */\n+    protected AbstractMapBag(Map<E, MutableInteger> map) {\n+        super();\n+        this.map = map;\n+    }\n+\n+    /**\n+     * Utility method for implementations to access the map that backs this bag.\n+     * Not intended for interactive use outside of subclasses.\n+     * \n+     * @return the map being used by the Bag\n+     */\n+    protected Map<E, MutableInteger> getMap() {\n+        return map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements in this bag.\n+     * \n+     * @return current size of the bag\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if the underlying map is empty.\n+     * \n+     * @return true if bag is empty\n+     */\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the number of occurrence of the given element in this bag by\n+     * looking up its count in the underlying map.\n+     * \n+     * @param object the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    public int getCount(Object object) {\n+        MutableInteger count = map.get(object);\n+        if (count != null) {\n+            return count.value;\n+        }\n+        return 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determines if the bag contains the given element by checking if the\n+     * underlying map contains the element as a key.\n+     * \n+     * @param object the object to search for\n+     * @return true if the bag contains the given element\n+     */\n+    public boolean contains(Object object) {\n+        return map.containsKey(object);\n+    }\n+\n+    /**\n+     * Determines if the bag contains the given elements.\n+     * \n+     * @param coll the collection to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    public boolean containsAll(Collection<?> coll) {\n+        if (coll instanceof Bag) {\n+            return containsAll((Bag<?>) coll);\n+        }\n+        return containsAll(new HashBag<Object>(coll));\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the bag contains all elements in the given\n+     * collection, respecting cardinality.\n+     * \n+     * @param other the bag to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    boolean containsAll(Bag<?> other) {\n+        boolean result = true;\n+        Iterator<?> it = other.uniqueSet().iterator();\n+        while (it.hasNext()) {\n+            Object current = it.next();\n+            boolean contains = getCount(current) >= other.getCount(current);\n+            result = result && contains;\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the bag elements. Elements present in the Bag more\n+     * than once will be returned repeatedly.\n+     * \n+     * @return the iterator\n+     */\n+    public Iterator<E> iterator() {\n+        return new BagIterator<E>(this);\n+    }\n+\n+    /**\n+     * Inner class iterator for the Bag.\n+     */\n+    static class BagIterator<E> implements Iterator<E> {\n+        private final AbstractMapBag<E> parent;\n+        private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n+        private Map.Entry<E, MutableInteger> current;\n+        private int itemCount;\n+        private final int mods;\n+        private boolean canRemove;\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param parent the parent bag\n+         */\n+        public BagIterator(AbstractMapBag<E> parent) {\n+            this.parent = parent;\n+            this.entryIterator = parent.map.entrySet().iterator();\n+            this.current = null;\n+            this.mods = parent.modCount;\n+            this.canRemove = false;\n+        }\n+\n+        public boolean hasNext() {\n+            return (itemCount > 0 || entryIterator.hasNext());\n+        }\n+\n+        public E next() {\n+            if (parent.modCount != mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (itemCount == 0) {\n+                current = entryIterator.next();\n+                itemCount = current.getValue().value;\n+            }\n+            canRemove = true;\n+            itemCount--;\n+            return current.getKey();\n+        }\n+\n+        public void remove() {\n+            if (parent.modCount != mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (canRemove == false) {\n+                throw new IllegalStateException();\n+            }\n+            MutableInteger mut = current.getValue();\n+            if (mut.value > 1) {\n+                mut.value--;\n+            } else {\n+                entryIterator.remove();\n+            }\n+            parent.size--;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new element to the bag, incrementing its count in the underlying\n+     * map.\n+     * \n+     * @param object the object to add\n+     * @return <code>true</code> if the object was not already in the\n+     * <code>uniqueSet</code>\n+     */\n+    public boolean add(E object) {\n+        return add(object, 1);\n+    }\n+\n+    /**\n+     * Adds a new element to the bag, incrementing its count in the map.\n+     * \n+     * @param object the object to search for\n+     * @param nCopies the number of copies to add\n+     * @return <code>true</code> if the object was not already in the\n+     * <code>uniqueSet</code>\n+     */\n+    public boolean add(E object, int nCopies) {\n+        modCount++;\n+        if (nCopies > 0) {\n+            MutableInteger mut = map.get(object);\n+            size += nCopies;\n+            if (mut == null) {\n+                map.put(object, new MutableInteger(nCopies));\n+                return true;\n+            }\n+            mut.value += nCopies;\n+            return false;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Invokes {@link #add(Object)} for each element in the given collection.\n+     * \n+     * @param coll the collection to add\n+     * @return <code>true</code> if this call changed the bag\n+     */\n+    public boolean addAll(Collection<? extends E> coll) {\n+        boolean changed = false;\n+        Iterator<? extends E> i = coll.iterator();\n+        while (i.hasNext()) {\n+            boolean added = add(i.next());\n+            changed = changed || added;\n+        }\n+        return changed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clears the bag by clearing the underlying map.\n+     */\n+    public void clear() {\n+        modCount++;\n+        map.clear();\n+        size = 0;\n+    }\n+\n+    /**\n+     * Removes all copies of the specified object from the bag.\n+     * \n+     * @param object the object to remove\n+     * @return true if the bag changed\n+     */\n+    public boolean remove(Object object) {\n+        MutableInteger mut = map.get(object);\n+        if (mut == null) {\n+            return false;\n+        }\n+        modCount++;\n+        map.remove(object);\n+        size -= mut.value;\n+        return true;\n+    }\n+\n+    /**\n+     * Removes a specified number of copies of an object from the bag.\n+     * \n+     * @param object the object to remove\n+     * @param nCopies the number of copies to remove\n+     * @return true if the bag changed\n+     */\n+    public boolean remove(Object object, int nCopies) {\n+        MutableInteger mut = map.get(object);\n+        if (mut == null) {\n+            return false;\n+        }\n+        if (nCopies <= 0) {\n+            return false;\n+        }\n+        modCount++;\n+        if (nCopies < mut.value) {\n+            mut.value -= nCopies;\n+            size -= nCopies;\n+        } else {\n+            map.remove(object);\n+            size -= mut.value;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Removes objects from the bag according to their count in the specified\n+     * collection.\n+     * \n+     * @param coll the collection to use\n+     * @return true if the bag changed\n+     */\n+    public boolean removeAll(Collection<?> coll) {\n+        boolean result = false;\n+        if (coll != null) {\n+            Iterator<?> i = coll.iterator();\n+            while (i.hasNext()) {\n+                boolean changed = remove(i.next(), 1);\n+                result = result || changed;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Remove any members of the bag that are not in the given bag, respecting\n+     * cardinality.\n+     * \n+     * @param coll the collection to retain\n+     * @return true if this call changed the collection\n+     */\n+    public boolean retainAll(Collection<?> coll) {\n+        if (coll instanceof Bag) {\n+            return retainAll((Bag<?>) coll);\n+        }\n+        return retainAll(new HashBag<Object>(coll));\n+    }\n+\n+    /**\n+     * Remove any members of the bag that are not in the given bag, respecting\n+     * cardinality.\n+     * @see #retainAll(Collection)\n+     * \n+     * @param other the bag to retain\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean retainAll(Bag<?> other) {\n+        boolean result = false;\n+        Bag<E> excess = new HashBag<E>();\n+        Iterator<E> i = uniqueSet().iterator();\n+        while (i.hasNext()) {\n+            E current = i.next();\n+            int myCount = getCount(current);\n+            int otherCount = other.getCount(current);\n+            if (1 <= otherCount && otherCount <= myCount) {\n+                excess.add(current, myCount - otherCount);\n+            } else {\n+                excess.add(current, myCount);\n+            }\n+        }\n+        if (!excess.isEmpty()) {\n+            result = removeAll(excess);\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Mutable integer class for storing the data.\n+     */\n+    protected static class MutableInteger {\n+        /** The value of this mutable. */\n+        protected int value;\n+\n+        /**\n+         * Constructor.\n+         * @param value the initial value\n+         */\n+        MutableInteger(int value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof MutableInteger == false) {\n+                return false;\n+            }\n+            return ((MutableInteger) obj).value == value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return value;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an array of all of this bag's elements.\n+     * \n+     * @return an array of all of this bag's elements\n+     */\n+    public Object[] toArray() {\n+        Object[] result = new Object[size()];\n+        int i = 0;\n+        Iterator<E> it = map.keySet().iterator();\n+        while (it.hasNext()) {\n+            E current = it.next();\n+            for (int index = getCount(current); index > 0; index--) {\n+                result[i++] = current;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an array of all of this bag's elements.\n+     * \n+     * @param array the array to populate\n+     * @return an array of all of this bag's elements\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n+        int size = size();\n+        if (array.length < size) {\n+            array = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n+        }\n+\n+        int i = 0;\n+        Iterator<E> it = map.keySet().iterator();\n+        while (it.hasNext()) {\n+            E current = it.next();\n+            for (int index = getCount(current); index > 0; index--) {\n+                array[i++] = (T) current;\n+            }\n+        }\n+        while (i < array.length) {\n+            array[i++] = null;\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the underlying map's key set.\n+     * \n+     * @return the set of unique elements in this bag\n+     */\n+    public Set<E> uniqueSet() {\n+        if (uniqueSet == null) {\n+            uniqueSet = UnmodifiableSet.<E> unmodifiableSet(map.keySet());\n+        }\n+        return uniqueSet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * @param out the output stream\n+     * @throws IOException\n+     */\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        out.writeInt(map.size());\n+        for (Iterator<Map.Entry<E, MutableInteger>> it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry<E, MutableInteger> entry = it.next();\n+            out.writeObject(entry.getKey());\n+            out.writeInt(entry.getValue().value);\n+        }\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * @param map the map to use\n+     * @param in the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @throws ClassCastException if the stream does not contain the correct objects\n+     */\n+    protected void doReadObject(Map<E, MutableInteger> map, ObjectInputStream in) throws IOException,\n+            ClassNotFoundException {\n+        this.map = map;\n+        int entrySize = in.readInt();\n+        for (int i = 0; i < entrySize; i++) {\n+            @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n+            E obj = (E) in.readObject();\n+            int count = in.readInt();\n+            map.put(obj, new MutableInteger(count));\n+            size += count;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this Bag to another. This Bag equals another Bag if it contains\n+     * the same number of occurrences of the same elements.\n+     * \n+     * @param object the Bag to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        if (object instanceof Bag == false) {\n+            return false;\n+        }\n+        Bag<?> other = (Bag<?>) object;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        for (Iterator<E> it = map.keySet().iterator(); it.hasNext();) {\n+            E element = it.next();\n+            if (other.getCount(element) != getCount(element)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets a hash code for the Bag compatible with the definition of equals.\n+     * The hash code is defined as the sum total of a hash code for each\n+     * element. The per element hash code is defined as\n+     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>. This hash code\n+     * is compatible with the Set interface.\n+     * \n+     * @return the hash code of the Bag\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        for (Iterator<Map.Entry<E, MutableInteger>> it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry<E, MutableInteger> entry = it.next();\n+            E element = entry.getKey();\n+            MutableInteger count = entry.getValue();\n+            total += (element == null ? 0 : element.hashCode()) ^ count.value;\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Implement a toString() method suitable for debugging.\n+     * \n+     * @return a debugging toString\n+     */\n+    @Override\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"[]\";\n+        }\n+        StringBuilder buf = new StringBuilder();\n+        buf.append('[');\n+        Iterator<E> it = uniqueSet().iterator();\n+        while (it.hasNext()) {\n+            Object current = it.next();\n+            int count = getCount(current);\n+            buf.append(count);\n+            buf.append(':');\n+            buf.append(current);\n+            if (it.hasNext()) {\n+                buf.append(',');\n+            }\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/AbstractSortedBagDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.SortedBag;\n+\n+/**\n+ * Decorates another <code>SortedBag</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated bag.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractSortedBagDecorator<E>\n+        extends AbstractBagDecorator<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8223473624050467718L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractSortedBagDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractSortedBagDecorator(SortedBag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected SortedBag<E> decorated() {\n+        return (SortedBag<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/HashBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.Bag;\n+\n+/**\n+ * Implements <code>Bag</code>, using a <code>HashMap</code> to provide the\n+ * data storage. This is the standard implementation of a bag.\n+ * <p>\n+ * A <code>Bag</code> stores each object in the collection together with a\n+ * count of occurrences. Extra methods on the interface allow multiple copies\n+ * of an object to be added or removed at once. It is important to read the\n+ * interface javadoc carefully as several methods violate the\n+ * <code>Collection</code> interface specification.\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v2.0)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ * @author Stephen Colebourne\n+ */\n+public class HashBag<E>\n+        extends AbstractMapBag<E> implements Bag<E>, Serializable {\n+\n+    /** Serial version lock */\n+    private static final long serialVersionUID = -6561115435802554013L;\n+    \n+    /**\n+     * Constructs an empty <code>HashBag</code>.\n+     */\n+    public HashBag() {\n+        super(new HashMap<E, MutableInteger>());\n+    }\n+\n+    /**\n+     * Constructs a bag containing all the members of the given collection.\n+     * \n+     * @param coll  a collection to copy into this bag\n+     */\n+    public HashBag(Collection<? extends E> coll) {\n+        this();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the bag out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the bag in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        super.doReadObject(new HashMap<E, MutableInteger>(), in);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/PredicatedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+\n+/**\n+ * Decorates another <code>Bag</code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This bag exists to provide validation for the decorated bag.\n+ * It is normally created to decorate an empty bag.\n+ * If an object cannot be added to the bag, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the bag.\n+ * <pre>Bag bag = PredicatedBag.decorate(new HashBag(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedBag<E>\n+        extends PredicatedCollection<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2575833140344736876L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated Bag\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    public static <T> Bag<T> predicatedBag(Bag<T> bag, Predicate<? super T> predicate) {\n+        return new PredicatedBag<T>(bag, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    protected PredicatedBag(Bag<E> bag, Predicate<? super E> predicate) {\n+        super(bag, predicate);\n+    }\n+\n+    /**\n+     * Gets the decorated bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected Bag<E> decorated() {\n+        return (Bag<E>) super.decorated();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public boolean add(E object, int count) {\n+        validate(object);\n+        return decorated().add(object, count);\n+    }\n+\n+    public boolean remove(Object object, int count) {\n+        return decorated().remove(object, count);\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        return decorated().uniqueSet();\n+    }\n+\n+    public int getCount(Object object) {\n+        return decorated().getCount(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/PredicatedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.SortedBag;\n+\n+/**\n+ * Decorates another <code>SortedBag</code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This bag exists to provide validation for the decorated bag.\n+ * It is normally created to decorate an empty bag.\n+ * If an object cannot be added to the bag, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the bag.\n+ * <pre>SortedBag bag = PredicatedSortedBag.decorate(new TreeBag(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedSortedBag<E>\n+        extends PredicatedBag<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3448581314086406616L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated SortedBag\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    public static <T> SortedBag<T> predicatedSortedBag(SortedBag<T> bag, Predicate<? super T> predicate) {\n+        return new PredicatedSortedBag<T>(bag, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    protected PredicatedSortedBag(SortedBag<E> bag, Predicate<? super E> predicate) {\n+        super(bag, predicate);\n+    }\n+\n+    /**\n+     * Gets the decorated sorted bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected SortedBag<E> decorated() {\n+        return (SortedBag<E>) super.decorated();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/SynchronizedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+import org.apache.commons.collections.set.SynchronizedSet;\n+\n+/**\n+ * Decorates another <code>Bag</code> to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated bag.\n+ * Iterators must be separately synchronized around the loop.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedBag<E>\n+        extends SynchronizedCollection<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8084674570753837109L;\n+\n+    /**\n+     * Factory method to create a synchronized bag.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @return a new synchronized Bag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <T> Bag<T> synchronizedBag(Bag<T> bag) {\n+        return new SynchronizedBag<T>(bag);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedBag(Bag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param lock  the lock to use, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedBag(Bag<E> bag, Object lock) {\n+        super(bag, lock);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected Bag<E> getBag() {\n+        return (Bag<E>) collection;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public boolean add(E object, int count) {\n+        synchronized (lock) {\n+            return getBag().add(object, count);\n+        }\n+    }\n+\n+    public boolean remove(Object object, int count) {\n+        synchronized (lock) {\n+            return getBag().remove(object, count);\n+        }\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        synchronized (lock) {\n+            Set<E> set = getBag().uniqueSet();\n+            return new SynchronizedBagSet(set, lock);\n+        }\n+    }\n+\n+    public int getCount(Object object) {\n+        synchronized (lock) {\n+            return getBag().getCount(object);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Synchronized Set for the Bag class.\n+     */\n+    class SynchronizedBagSet extends SynchronizedSet<E> {\n+        /** Serialization version */\n+        private static final long serialVersionUID = 2990565892366827855L;\n+\n+        /**\n+         * Constructor.\n+         * @param set  the set to decorate\n+         * @param lock  the lock to use, shared with the bag\n+         */\n+        SynchronizedBagSet(Set<E> set, Object lock) {\n+            super(set, lock);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/SynchronizedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.SortedBag;\n+\n+/**\n+ * Decorates another <code>SortedBag</code> to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated bag.\n+ * Iterators must be separately synchronized around the loop.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedSortedBag<E>\n+        extends SynchronizedBag<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 722374056718497858L;\n+\n+    /**\n+     * Factory method to create a synchronized sorted bag.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @return a new synchronized SortedBag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> SortedBag<E> synchronizedSortedBag(SortedBag<E> bag) {\n+        return new SynchronizedSortedBag<E>(bag);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedSortedBag(SortedBag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param lock  the lock to use, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedSortedBag(Bag<E> bag, Object lock) {\n+        super(bag, lock);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected SortedBag<E> getSortedBag() {\n+        return (SortedBag<E>) collection;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public synchronized E first() {\n+        synchronized (lock) {\n+            return getSortedBag().first();\n+        }\n+    }\n+\n+    public synchronized E last() {\n+        synchronized (lock) {\n+            return getSortedBag().last();\n+        }\n+    }\n+\n+    public synchronized Comparator<? super E> comparator() {\n+        synchronized (lock) {\n+            return getSortedBag().comparator();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/TransformedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+import org.apache.commons.collections.set.TransformedSet;\n+\n+/**\n+ * Decorates another <code>Bag</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedBag<E>\n+        extends TransformedCollection<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5421170911299074185L;\n+\n+    /**\n+     * Factory method to create a transforming bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedBag(Bag, Transformer)}.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Bag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    public static <E> Bag<E> transformingBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedBag<E>(bag, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming bag that will transform\n+     * existing contents of the specified bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Bag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     * @since Commons Collections 3.3\n+     */\n+    public static <E> Bag<E> transformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n+        if (transformer != null && bag != null && bag.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // Bag is of type E\n+            E[] values = (E[]) bag.toArray();\n+            bag.clear();\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+                decorated.decorated().add(transformer.transform(values[i]));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    protected TransformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        super(bag, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected Bag<E> getBag() {\n+        return (Bag<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int getCount(Object object) {\n+        return getBag().getCount(object);\n+    }\n+\n+    public boolean remove(Object object, int nCopies) {\n+        return getBag().remove(object, nCopies);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean add(E object, int nCopies) {\n+        return getBag().add(transform(object), nCopies);\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        Set<E> set = getBag().uniqueSet();\n+        return TransformedSet.<E>transformingSet(set, transformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.SortedBag;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Decorates another <code>SortedBag</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedSortedBag<E>\n+        extends TransformedBag<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -251737742649401930L;\n+\n+    /**\n+     * Factory method to create a transforming sorted bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed SortedBag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    public static <E> SortedBag<E> transformingSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSortedBag<E>(bag, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming sorted bag that will transform\n+     * existing contents of the specified sorted bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed SortedBag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     * @since Commons Collections 3.3\n+     */\n+    public static <E> SortedBag<E> transformedSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);\n+        if (transformer != null && bag != null && bag.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // bag is type E\n+            E[] values = (E[]) bag.toArray();\n+            bag.clear();\n+            for(int i=0; i<values.length; i++) {\n+                decorated.decorated().add(transformer.transform(values[i]));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    protected TransformedSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+        super(bag, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected SortedBag<E> getSortedBag() {\n+        return (SortedBag<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E first() {\n+        return getSortedBag().first();\n+    }\n+\n+    public E last() {\n+        return getSortedBag().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return getSortedBag().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/TreeBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.SortedBag;\n+\n+/**\n+ * Implements <code>SortedBag</code>, using a <code>TreeMap</code> to provide\n+ * the data storage. This is the standard implementation of a sorted bag.\n+ * <p>\n+ * Order will be maintained among the bag members and can be viewed through the\n+ * iterator.\n+ * <p>\n+ * A <code>Bag</code> stores each object in the collection together with a count\n+ * of occurrences. Extra methods on the interface allow multiple copies of an\n+ * object to be added or removed at once. It is important to read the interface\n+ * javadoc carefully as several methods violate the <code>Collection</code>\n+ * interface specification.\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v2.0)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ * @author Stephen Colebourne\n+ */\n+public class TreeBag<E> extends AbstractMapBag<E> implements SortedBag<E>, Serializable {\n+\n+    /** Serial version lock */\n+    private static final long serialVersionUID = -7740146511091606676L;\n+\n+    /**\n+     * Constructs an empty <code>TreeBag</code>.\n+     */\n+    public TreeBag() {\n+        super(new TreeMap<E, MutableInteger>());\n+    }\n+\n+    /**\n+     * Constructs an empty bag that maintains order on its unique representative\n+     * members according to the given {@link Comparator}.\n+     * \n+     * @param comparator the comparator to use\n+     */\n+    public TreeBag(Comparator<? super E> comparator) {\n+        super(new TreeMap<E, MutableInteger>(comparator));\n+    }\n+\n+    /**\n+     * Constructs a <code>TreeBag</code> containing all the members of the\n+     * specified collection.\n+     * \n+     * @param coll the collection to copy into the bag\n+     */\n+    public TreeBag(Collection<? extends E> coll) {\n+        this();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // TODO: Generics - should this be E<? extends Comparable> or some such?\n+    @Override\n+    public boolean add(E object) {\n+        if(comparator() == null && !(object instanceof Comparable)) {\n+            throw new IllegalArgumentException(\"Objects of type \" + object.getClass() + \" cannot be added to \" + \n+                                               \"a naturally ordered TreeBag as it does not implement Comparable\");\n+        }\n+        return super.add(object);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E first() {\n+        return getMap().firstKey();\n+    }\n+\n+    public E last() {\n+        return getMap().lastKey();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return getMap().comparator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected SortedMap<E, org.apache.commons.collections.bag.AbstractMapBag.MutableInteger> getMap() {\n+        return (SortedMap<E, org.apache.commons.collections.bag.AbstractMapBag.MutableInteger>) super\n+                .getMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the bag out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(comparator());\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the bag in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        @SuppressWarnings(\"unchecked\")  // This will fail at runtime if the stream is incorrect\n+        Comparator<? super E> comp = (Comparator<? super E>) in.readObject();\n+        super.doReadObject(new TreeMap<E, MutableInteger>(comp), in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/UnmodifiableBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>Bag</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableBag<E>\n+        extends AbstractBagDecorator<E> implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1873799975157099624L;\n+\n+    /**\n+     * Factory method to create an unmodifiable bag.\n+     * <p>\n+     * If the bag passed in is already unmodifiable, it is returned.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @return an unmodifiable Bag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> Bag<E> unmodifiableBag(Bag<E> bag) {\n+        if (bag instanceof Unmodifiable) {\n+            return bag;\n+        }\n+        return new UnmodifiableBag<E>(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    private UnmodifiableBag(Bag<E> bag) {\n+        super(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+\t\treturn UnmodifiableIterator.<E> unmodifiableIterator(decorated()\n+\t\t\t\t.iterator());\n+    }\n+\n+    @Override\n+    public boolean add(E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(E object, int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object, int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<E> uniqueSet() {\n+        Set<E> set = decorated().uniqueSet();\n+\t\treturn UnmodifiableSet.<E> unmodifiableSet(set);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bag/UnmodifiableSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.SortedBag;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>SortedBag</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableSortedBag<E>\n+        extends AbstractSortedBagDecorator<E> implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3190437252665717841L;\n+\n+    /**\n+     * Factory method to create an unmodifiable bag.\n+     * <p>\n+     * If the bag passed in is already unmodifiable, it is returned.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @return an unmodifiable SortedBag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> SortedBag<E> unmodifiableSortedBag(SortedBag<E> bag) {\n+        if (bag instanceof Unmodifiable) {\n+            return bag;\n+        }\n+        return new UnmodifiableSortedBag<E>(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    private UnmodifiableSortedBag(SortedBag<E> bag) {\n+        super(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(E object, int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object, int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<E> uniqueSet() {\n+        Set<E> set = decorated().uniqueSet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractBidiMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.map.AbstractMapDecorator;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a BidiMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractBidiMapDecorator<K, V> extends AbstractMapDecorator<K, V> implements\n+        BidiMap<K, V> {\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractBidiMapDecorator(BidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected BidiMap<K, V> decorated() {\n+        return (BidiMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+    public K getKey(Object value) {\n+        return decorated().getKey(value);\n+    }\n+\n+    public K removeValue(Object value) {\n+        return decorated().removeValue(value);\n+    }\n+\n+    public BidiMap<V, K> inverseBidiMap() {\n+        return decorated().inverseBidiMap();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.keyvalue.AbstractMapEntryDecorator;\n+\n+/**\n+ * Abstract <code>BidiMap</code> implemented using two maps.\n+ * <p>\n+ * An implementation can be written simply by implementing the\n+ * <code>createMap</code> method.\n+ *\n+ * @see DualHashBidiMap\n+ * @see DualTreeBidiMap\n+ * @since Commons Collections 3.0\n+ * @version $Id$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractDualBidiMap<K, V> implements BidiMap<K, V> {\n+\n+    /**\n+     * Normal delegate map.\n+     */\n+    protected transient Map<K, V> normalMap;\n+\n+    /**\n+     * Reverse delegate map.\n+     */\n+    protected transient Map<V, K> reverseMap;\n+\n+    /**\n+     * Inverse view of this map.\n+     */\n+    protected transient BidiMap<V, K> inverseBidiMap = null;\n+\n+    /**\n+     * View of the keys.\n+     */\n+    protected transient Set<K> keySet = null;\n+\n+    /**\n+     * View of the values.\n+     */\n+    protected transient Collection<V> values = null;\n+\n+    /**\n+     * View of the entries.\n+     */\n+    protected transient Set<Map.Entry<K, V>> entrySet = null;\n+\n+    /**\n+     * Creates an empty map, initialised by <code>createMap</code>.\n+     * <p>\n+     * This constructor remains in place for deserialization.\n+     * All other usage is deprecated in favour of\n+     * {@link #AbstractDualBidiMap(Map, Map)}.\n+     */\n+    protected AbstractDualBidiMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates an empty map using the two maps specified as storage.\n+     * <p>\n+     * The two maps must be a matching pair, normal and reverse.\n+     * They will typically both be empty.\n+     * <p>\n+     * Neither map is validated, so nulls may be passed in.\n+     * If you choose to do this then the subclass constructor must populate\n+     * the <code>maps[]</code> instance variable itself.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractDualBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap) {\n+        super();\n+        this.normalMap = normalMap;\n+        this.reverseMap = reverseMap;\n+    }\n+\n+    /**\n+     * Constructs a map that decorates the specified maps,\n+     * used by the subclass <code>createBidiMap</code> implementation.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected AbstractDualBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n+        super();\n+        this.normalMap = normalMap;\n+        this.reverseMap = reverseMap;\n+        this.inverseBidiMap = inverseBidiMap;\n+    }\n+\n+    /**\n+     * Creates a new instance of the subclass.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseMap  this map, which is the inverse in the new map\n+     * @return the inverse map\n+     */\n+    protected abstract BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseMap);\n+\n+    // Map delegation\n+    //-----------------------------------------------------------------------\n+    public V get(Object key) {\n+        return normalMap.get(key);\n+    }\n+\n+    public int size() {\n+        return normalMap.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return normalMap.isEmpty();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return normalMap.containsKey(key);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return normalMap.equals(obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return normalMap.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return normalMap.toString();\n+    }\n+\n+    // BidiMap changes\n+    //-----------------------------------------------------------------------\n+    public V put(K key, V value) {\n+        if (normalMap.containsKey(key)) {\n+            reverseMap.remove(normalMap.get(key));\n+        }\n+        if (reverseMap.containsKey(value)) {\n+            normalMap.remove(reverseMap.get(value));\n+        }\n+        final V obj = normalMap.put(key, value);\n+        reverseMap.put(value, key);\n+        return obj;\n+    }\n+\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public V remove(Object key) {\n+        V value = null;\n+        if (normalMap.containsKey(key)) {\n+            value = normalMap.remove(key);\n+            reverseMap.remove(value);\n+        }\n+        return value;\n+    }\n+\n+    public void clear() {\n+        normalMap.clear();\n+        reverseMap.clear();\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return reverseMap.containsKey(value);\n+    }\n+\n+    // BidiMap\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains a <code>MapIterator</code> over the map.\n+     * The iterator implements <code>ResetableMapIterator</code>.\n+     * This implementation relies on the entrySet iterator.\n+     * <p>\n+     * The setValue() methods only allow a new value to be set.\n+     * If the value being set is already in the map, an IllegalArgumentException\n+     * is thrown (as setValue cannot change the size of the map).\n+     *\n+     * @return a map iterator\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        return new BidiMapIterator<K, V>(this);\n+    }\n+\n+    public K getKey(Object value) {\n+        return reverseMap.get(value);\n+    }\n+\n+    public K removeValue(Object value) {\n+        K key = null;\n+        if (reverseMap.containsKey(value)) {\n+            key = reverseMap.remove(value);\n+            normalMap.remove(key);\n+        }\n+        return key;\n+    }\n+\n+    public BidiMap<V, K> inverseBidiMap() {\n+        if (inverseBidiMap == null) {\n+            inverseBidiMap = createBidiMap(reverseMap, normalMap, this);\n+        }\n+        return inverseBidiMap;\n+    }\n+\n+    // Map views\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a keySet view of the map.\n+     * Changes made on the view are reflected in the map.\n+     * The set supports remove and clear but not add.\n+     *\n+     * @return the keySet view\n+     */\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet<K>(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the keySet iterator\n+     */\n+    protected Iterator<K> createKeySetIterator(Iterator<K> iterator) {\n+        return new KeySetIterator<K>(iterator, this);\n+    }\n+\n+    /**\n+     * Gets a values view of the map.\n+     * Changes made on the view are reflected in the map.\n+     * The set supports remove and clear but not add.\n+     *\n+     * @return the values view\n+     */\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new Values<V>(this);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the values iterator\n+     */\n+    protected Iterator<V> createValuesIterator(Iterator<V> iterator) {\n+        return new ValuesIterator<V>(iterator, this);\n+    }\n+\n+    /**\n+     * Gets an entrySet view of the map.\n+     * Changes made on the set are reflected in the map.\n+     * The set supports remove and clear but not add.\n+     * <p>\n+     * The Map Entry setValue() method only allow a new value to be set.\n+     * If the value being set is already in the map, an IllegalArgumentException\n+     * is thrown (as setValue cannot change the size of the map).\n+     *\n+     * @return the entrySet view\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet<K, V>(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the entrySet iterator\n+     */\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator(Iterator<Map.Entry<K, V>> iterator) {\n+        return new EntrySetIterator<K, V>(iterator, this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class View.\n+     */\n+    @SuppressWarnings(\"serial\")\n+    protected static abstract class View<K, V, E> extends AbstractCollectionDecorator<E> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param coll  the collection view being decorated\n+         * @param parent  the parent BidiMap\n+         */\n+        protected View(Collection<E> coll, AbstractDualBidiMap<K, V> parent) {\n+            super(coll);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public boolean removeAll(Collection<?> coll) {\n+            if (parent.isEmpty() || coll.isEmpty()) {\n+                return false;\n+            }\n+            boolean modified = false;\n+            Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                if (coll.contains(it.next())) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        @Override\n+        public boolean retainAll(Collection<?> coll) {\n+            if (parent.isEmpty()) {\n+                return false;\n+            }\n+            if (coll.isEmpty()) {\n+                parent.clear();\n+                return true;\n+            }\n+            boolean modified = false;\n+            Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                if (coll.contains(it.next()) == false) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class KeySet.\n+     */\n+    protected static class KeySet<K> extends View<K, Object, K> implements Set<K> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = -7107935777385040694L;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param parent  the parent BidiMap\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySet(AbstractDualBidiMap<K, ?> parent) {\n+            super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return parent.createKeySetIterator(super.iterator());\n+        }\n+\n+        @Override\n+        public boolean contains(Object key) {\n+            return parent.normalMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean remove(Object key) {\n+            if (parent.normalMap.containsKey(key)) {\n+                Object value = parent.normalMap.remove(key);\n+                parent.reverseMap.remove(value);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class KeySetIterator.\n+     */\n+    protected static class KeySetIterator<K> extends AbstractIteratorDecorator<K> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, ?> parent;\n+\n+        /** The last returned key */\n+        protected K lastKey = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent map\n+         */\n+        protected KeySetIterator(Iterator<K> iterator, AbstractDualBidiMap<K, ?> parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public K next() {\n+            lastKey = super.next();\n+            canRemove = true;\n+            return lastKey;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            Object value = parent.normalMap.get(lastKey);\n+            super.remove();\n+            parent.reverseMap.remove(value);\n+            lastKey = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class Values.\n+     */\n+    protected static class Values<V> extends View<Object, V, V> implements Set<V> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 4023777119829639864L;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param parent  the parent BidiMap\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        protected Values(AbstractDualBidiMap<?, V> parent) {\n+            super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return parent.createValuesIterator(super.iterator());\n+        }\n+\n+        @Override\n+        public boolean contains(Object value) {\n+            return parent.reverseMap.containsKey(value);\n+        }\n+\n+        @Override\n+        public boolean remove(Object value) {\n+            if (parent.reverseMap.containsKey(value)) {\n+                Object key = parent.reverseMap.remove(value);\n+                parent.normalMap.remove(key);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class ValuesIterator.\n+     */\n+    protected static class ValuesIterator<V> extends AbstractIteratorDecorator<V> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<Object, V> parent;\n+\n+        /** The last returned value */\n+        protected V lastValue = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent map\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(Iterator<V> iterator, AbstractDualBidiMap<?, V> parent) {\n+            super(iterator);\n+            this.parent = (AbstractDualBidiMap<Object, V>) parent;\n+        }\n+\n+        @Override\n+        public V next() {\n+            lastValue = super.next();\n+            canRemove = true;\n+            return lastValue;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            super.remove(); // removes from maps[0]\n+            parent.reverseMap.remove(lastValue);\n+            lastValue = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class EntrySet.\n+     */\n+    protected static class EntrySet<K, V> extends View<K, V, Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 4040410962603292348L;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param parent  the parent BidiMap\n+         */\n+        protected EntrySet(AbstractDualBidiMap<K, V> parent) {\n+            super(parent.normalMap.entrySet(), parent);\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return parent.createEntrySetIterator(super.iterator());\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object key = entry.getKey();\n+            if (parent.containsKey(key)) {\n+                V value = parent.normalMap.get(key);\n+                if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n+                    parent.normalMap.remove(key);\n+                    parent.reverseMap.remove(value);\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class EntrySetIterator.\n+     */\n+    protected static class EntrySetIterator<K, V> extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /** The last returned entry */\n+        protected Map.Entry<K, V> last = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent map\n+         */\n+        protected EntrySetIterator(Iterator<Map.Entry<K, V>> iterator, AbstractDualBidiMap<K, V> parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public Map.Entry<K, V> next() {\n+            last = new MapEntry<K, V>(super.next(), parent);\n+            canRemove = true;\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            Object value = last.getValue();\n+            super.remove();\n+            parent.reverseMap.remove(value);\n+            last = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class MapEntry.\n+     */\n+    protected static class MapEntry<K, V> extends AbstractMapEntryDecorator<K, V> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /**\n+         * Constructor.\n+         * @param entry  the entry to decorate\n+         * @param parent  the parent map\n+         */\n+        protected MapEntry(Map.Entry<K, V> entry, AbstractDualBidiMap<K, V> parent) {\n+            super(entry);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public V setValue(V value) {\n+            K key = MapEntry.this.getKey();\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != key) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            parent.put(key, value);\n+            final V oldValue = super.setValue(value);\n+            return oldValue;\n+        }\n+    }\n+\n+    /**\n+     * Inner class MapIterator.\n+     */\n+    protected static class BidiMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /** The iterator being wrapped */\n+        protected Iterator<Map.Entry<K, V>> iterator;\n+\n+        /** The last returned entry */\n+        protected Map.Entry<K, V> last = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param parent  the parent map\n+         */\n+        protected BidiMapIterator(AbstractDualBidiMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            this.iterator = parent.normalMap.entrySet().iterator();\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public K next() {\n+            last = iterator.next();\n+            canRemove = true;\n+            return last.getKey();\n+        }\n+\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            V value = last.getValue();\n+            iterator.remove();\n+            parent.reverseMap.remove(value);\n+            last = null;\n+            canRemove = false;\n+        }\n+\n+        public K getKey() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return last.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return last.getValue();\n+        }\n+\n+        public V setValue(V value) {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+            }\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != last.getKey()) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            return parent.put(last.getKey(), value);\n+        }\n+\n+        public void reset() {\n+            iterator = parent.normalMap.entrySet().iterator();\n+            last = null;\n+            canRemove = false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"MapIterator[]\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import org.apache.commons.collections.OrderedBidiMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to an OrderedBidiMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the inverse from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractOrderedBidiMapDecorator<K, V>\n+        extends AbstractBidiMapDecorator<K, V>\n+        implements OrderedBidiMap<K, V> {\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractOrderedBidiMapDecorator(OrderedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected OrderedBidiMap<K, V> decorated() {\n+        return (OrderedBidiMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    public K nextKey(K key) {\n+        return decorated().nextKey(key);\n+    }\n+\n+    public K previousKey(K key) {\n+        return decorated().previousKey(key);\n+    }\n+\n+    @Override\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n+        return decorated().inverseBidiMap();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.SortedBidiMap;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a SortedBidiMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the inverse from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractSortedBidiMapDecorator<K, V> extends\n+        AbstractOrderedBidiMapDecorator<K, V> implements SortedBidiMap<K, V> {\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractSortedBidiMapDecorator(SortedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected SortedBidiMap<K, V> decorated() {\n+        return (SortedBidiMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n+        return decorated().inverseBidiMap();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    public Comparator<? super V> valueComparator() {\n+        return decorated().valueComparator();\n+    }\n+\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return decorated().subMap(fromKey, toKey);\n+    }\n+\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return decorated().headMap(toKey);\n+    }\n+\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return decorated().tailMap(fromKey);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.BidiMap;\n+\n+/**\n+ * Implementation of <code>BidiMap</code> that uses two <code>HashMap</code> instances.\n+ * <p>\n+ * Two <code>HashMap</code> instances are used in this class.\n+ * This provides fast lookups at the expense of storing two sets of map entries.\n+ * Commons Collections would welcome the addition of a direct hash-based\n+ * implementation of the <code>BidiMap</code> interface.\n+ * <p>\n+ * NOTE: From Commons Collections 3.1, all subclasses will use <code>HashMap</code>\n+ * and the flawed <code>createMap</code> method is ignored.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Id$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class DualHashBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements Serializable {\n+\n+    /** Ensure serialization compatibility */\n+    private static final long serialVersionUID = 721969328361808L;\n+\n+    /**\n+     * Creates an empty <code>HashBidiMap</code>.\n+     */\n+    public DualHashBidiMap() {\n+        super(new HashMap<K, V>(), new HashMap<V, K>());\n+    }\n+\n+    /** \n+     * Constructs a <code>HashBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.  \n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualHashBidiMap(Map<K, V> map) {\n+        super(new HashMap<K, V>(), new HashMap<V, K>());\n+        putAll(map);\n+    }\n+    \n+    /** \n+     * Constructs a <code>HashBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected DualHashBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     * \n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    @Override\n+    protected BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseBidiMap) {\n+        return new DualHashBidiMap<V, K>(normalMap, reverseMap, inverseBidiMap);\n+    }\n+\n+    // Serialization\n+    //-----------------------------------------------------------------------\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(normalMap);\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        normalMap = new HashMap<K, V>();\n+        reverseMap = new HashMap<V, K>();\n+        @SuppressWarnings(\"unchecked\") // will fail at runtime if stream is incorrect\n+        Map<K, V> map = (Map<K, V>) in.readObject();\n+        putAll(map);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.OrderedBidiMap;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.SortedBidiMap;\n+import org.apache.commons.collections.map.AbstractSortedMapDecorator;\n+\n+/**\n+ * Implementation of <code>BidiMap</code> that uses two <code>TreeMap</code> instances.\n+ * <p>\n+ * The setValue() method on iterators will succeed only if the new value being set is\n+ * not already in the bidimap.\n+ * <p>\n+ * When considering whether to use this class, the {@link TreeBidiMap} class should\n+ * also be considered. It implements the interface using a dedicated design, and does\n+ * not store each object twice, which can save on memory use.\n+ * <p>\n+ * NOTE: From Commons Collections 3.1, all subclasses will use <code>TreeMap</code>\n+ * and the flawed <code>createMap</code> method is ignored.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Id$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class DualTreeBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements\n+        SortedBidiMap<K, V>, Serializable {\n+\n+    /** Ensure serialization compatibility */\n+    private static final long serialVersionUID = 721969328361809L;\n+\n+    /** The key comparator to use */\n+    protected final Comparator<? super K> comparator;\n+\n+    /** The value comparator to use */\n+    protected final Comparator<? super V> valueComparator;\n+    \n+    /**\n+     * Creates an empty <code>DualTreeBidiMap</code>\n+     */\n+    public DualTreeBidiMap() {\n+        super(new TreeMap<K, V>(), new TreeMap<V, K>());\n+        this.comparator = null;\n+        this.valueComparator = null;\n+    }\n+\n+    /**\n+     * Constructs a <code>DualTreeBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.\n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualTreeBidiMap(Map<K, V> map) {\n+        super(new TreeMap<K, V>(), new TreeMap<V, K>());\n+        putAll(map);\n+        this.comparator = null;\n+        this.valueComparator = null;\n+    }\n+\n+    /**\n+     * Constructs a <code>DualTreeBidiMap</code> using the specified Comparator.\n+     *\n+     * @param keyComparator  the Comparator\n+     */\n+    public DualTreeBidiMap(Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {\n+        super(new TreeMap<K, V>(keyComparator), new TreeMap<V, K>(valueComparator));\n+        this.comparator = keyComparator;\n+        this.valueComparator = valueComparator;\n+    }\n+\n+    /**\n+     * Constructs a <code>DualTreeBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected DualTreeBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+        this.comparator = ((SortedMap<K, V>) normalMap).comparator();\n+        this.valueComparator = ((SortedMap<V, K>) reverseMap).comparator();\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseMap  the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    @Override\n+    protected DualTreeBidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseMap) {\n+        return new DualTreeBidiMap<V, K>(normalMap, reverseMap, inverseMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Comparator<? super K> comparator() {\n+        return ((SortedMap<K, V>) normalMap).comparator();\n+    }\n+\n+    public Comparator<? super V> valueComparator() {\n+        return ((SortedMap<V, K>) reverseMap).comparator();\n+        \n+    }\n+\n+    public K firstKey() {\n+        return ((SortedMap<K, V>) normalMap).firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return ((SortedMap<K, V>) normalMap).lastKey();\n+    }\n+\n+    public K nextKey(K key) {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        if (normalMap instanceof OrderedMap) {\n+            return ((OrderedMap<K, ?>) normalMap).nextKey(key);\n+        }\n+        SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        Iterator<K> it = sm.tailMap(key).keySet().iterator();\n+        it.next();\n+        if (it.hasNext()) {\n+            return it.next();\n+        }\n+        return null;\n+    }\n+\n+    public K previousKey(K key) {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        if (normalMap instanceof OrderedMap) {\n+            return ((OrderedMap<K, V>) normalMap).previousKey(key);\n+        }\n+        SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        SortedMap<K, V> hm = sm.headMap(key);\n+        if (hm.isEmpty()) {\n+            return null;\n+        }\n+        return hm.lastKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an ordered map iterator.\n+     * <p>\n+     * This implementation copies the elements to an ArrayList in order to\n+     * provide the forward/backward behaviour.\n+     *\n+     * @return a new ordered map iterator\n+     */\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new BidiOrderedMapIterator<K, V>(this);\n+    }\n+\n+    public SortedBidiMap<V, K> inverseSortedBidiMap() {\n+        return inverseBidiMap();\n+    }\n+\n+    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n+        return inverseBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedMap<K, V> headMap(K toKey) {\n+        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n+        return (SortedBidiMap<V, K>) super.inverseBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal sorted map view.\n+     */\n+    protected static class ViewMap<K, V> extends AbstractSortedMapDecorator<K, V> {\n+        /** The parent bidi map. */\n+        final DualTreeBidiMap<K, V> bidi;\n+\n+        /**\n+         * Constructor.\n+         * @param bidi  the parent bidi map\n+         * @param sm  the subMap sorted map\n+         */\n+        protected ViewMap(DualTreeBidiMap<K, V> bidi, SortedMap<K, V> sm) {\n+            // the implementation is not great here...\n+            // use the normalMap as the filtered map, but reverseMap as the full map\n+            // this forces containsValue and clear to be overridden\n+            super(new DualTreeBidiMap<K, V>(sm, bidi.reverseMap, bidi.inverseBidiMap));\n+            this.bidi = decorated();\n+        }\n+\n+        @Override\n+        public boolean containsValue(Object value) {\n+            // override as default implementation uses reverseMap\n+            return decorated().normalMap.containsValue(value);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            // override as default implementation uses reverseMap\n+            for (Iterator<K> it = keySet().iterator(); it.hasNext();) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> headMap(K toKey) {\n+            return new ViewMap<K, V>(decorated(), super.headMap(toKey));\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> tailMap(K fromKey) {\n+            return new ViewMap<K, V>(decorated(), super.tailMap(fromKey));\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+            return new ViewMap<K, V>(decorated(), super.subMap(fromKey, toKey));\n+        }\n+\n+        @Override\n+        protected DualTreeBidiMap<K, V> decorated() {\n+            return (DualTreeBidiMap<K, V>) super.decorated();\n+        }\n+\n+        @Override\n+        public K previousKey(K key) {\n+            return decorated().previousKey(key);\n+        }\n+\n+        @Override\n+        public K nextKey(K key) {\n+            return decorated().nextKey(key);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class MapIterator.\n+     */\n+    protected static class BidiOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /** The iterator being decorated */\n+        protected ListIterator<Map.Entry<K, V>> iterator;\n+\n+        /** The last returned entry */\n+        private Map.Entry<K, V> last = null;\n+\n+        /**\n+         * Constructor.\n+         * @param parent  the parent map\n+         */\n+        protected BidiOrderedMapIterator(AbstractDualBidiMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public K next() {\n+            last = iterator.next();\n+            return last.getKey();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+\n+        public K previous() {\n+            last = iterator.previous();\n+            return last.getKey();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            parent.remove(last.getKey());\n+            last = null;\n+        }\n+\n+        public K getKey() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return last.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return last.getValue();\n+        }\n+\n+        public V setValue(V value) {\n+            if (last == null) {\n+                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+            }\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != last.getKey()) {\n+                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            return parent.put(last.getKey(), value);\n+        }\n+\n+        public void reset() {\n+            iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n+            last = null;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"MapIterator[]\";\n+        }\n+    }\n+\n+    // Serialization\n+    //-----------------------------------------------------------------------\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(normalMap);\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        normalMap = new TreeMap<K, V>(comparator);\n+        reverseMap = new TreeMap<V, K>(valueComparator);\n+        @SuppressWarnings(\"unchecked\") // will fail at runtime if the stream is incorrect\n+        Map<K, V> map = (Map<K, V>) in.readObject();\n+        putAll(map);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedBidiMap;\n+import org.apache.commons.collections.OrderedIterator;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n+import org.apache.commons.collections.keyvalue.UnmodifiableMapEntry;\n+import static org.apache.commons.collections.bidimap.TreeBidiMap.DataElement.*;\n+\n+/**\n+ * Red-Black tree-based implementation of BidiMap where all objects added\n+ * implement the <code>Comparable</code> interface.\n+ * <p>\n+ * This class guarantees that the map will be in both ascending key order\n+ * and ascending value order, sorted according to the natural order for\n+ * the key's and value's classes.\n+ * <p>\n+ * This Map is intended for applications that need to be able to look\n+ * up a key-value pairing by either key or value, and need to do so\n+ * with equal efficiency.\n+ * <p>\n+ * While that goal could be accomplished by taking a pair of TreeMaps\n+ * and redirecting requests to the appropriate TreeMap (e.g.,\n+ * containsKey would be directed to the TreeMap that maps values to\n+ * keys, containsValue would be directed to the TreeMap that maps keys\n+ * to values), there are problems with that implementation.\n+ * If the data contained in the TreeMaps is large, the cost of redundant\n+ * storage becomes significant. The {@link DualTreeBidiMap} and\n+ * {@link DualHashBidiMap} implementations use this approach.\n+ * <p>\n+ * This solution keeps minimizes the data storage by holding data only once.\n+ * The red-black algorithm is based on java util TreeMap, but has been modified\n+ * to simultaneously map a tree node by key and by value. This doubles the\n+ * cost of put operations (but so does using two TreeMaps), and nearly doubles\n+ * the cost of remove operations (there is a savings in that the lookup of the\n+ * node to be removed only has to be performed once). And since only one node\n+ * contains the key and value, storage is significantly less than that\n+ * required by two TreeMaps.\n+ * <p>\n+ * The Map.Entry instances returned by the appropriate methods will\n+ * not allow setValue() and will throw an\n+ * UnsupportedOperationException on attempts to call that method.\n+ *\n+ * @since Commons Collections 3.0 (previously DoubleOrderedMap v2.0)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Marc Johnson\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class TreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> implements OrderedBidiMap<K, V> {\n+\n+    static enum DataElement {\n+        KEY(\"key\"), VALUE(\"value\");\n+\n+        private final String description;\n+\n+        /**\n+         * Create a new TreeBidiMap.DataElement.\n+         */\n+        private DataElement(String description) {\n+            this.description = description;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return description;\n+        }\n+    }\n+\n+    private Node<K, V>[] rootNode;\n+    private int nodeCount = 0;\n+    private int modifications = 0;\n+    private Set<K> keySet;\n+    private Set<V> valuesSet;\n+    private Set<Map.Entry<K, V>> entrySet;\n+    private Inverse inverse = null;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty TreeBidiMap.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public TreeBidiMap() {\n+        super();\n+        rootNode = new Node[2];\n+    }\n+\n+    /**\n+     * Constructs a new TreeBidiMap by copying an existing Map.\n+     *\n+     * @param map  the map to copy\n+     * @throws ClassCastException if the keys/values in the map are\n+     *  not Comparable or are not mutually comparable\n+     * @throws NullPointerException if any key or value in the map is null\n+     */\n+    public TreeBidiMap(final Map<K, V> map) {\n+        this();\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of key-value mappings in this map.\n+     *\n+     * @return the number of key-value mappings in this map\n+     */\n+    public int size() {\n+        return nodeCount;\n+    }\n+\n+    /**\n+     * Checks whether the map is empty or not.\n+     *\n+     * @return true if the map is empty\n+     */\n+    public boolean isEmpty() {\n+        return (nodeCount == 0);\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified key.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key  key whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public boolean containsKey(final Object key) {\n+        checkKey(key);\n+        return (lookupKey(key) != null);\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified value.\n+     * <p>\n+     * The value must implement <code>Comparable</code>.\n+     *\n+     * @param value  value whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified value\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public boolean containsValue(final Object value) {\n+        checkValue(value);\n+        return (lookupValue(value) != null);\n+    }\n+\n+    /**\n+     * Gets the value to which this map maps the specified key.\n+     * Returns null if the map contains no mapping for this key.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key  key whose associated value is to be returned\n+     * @return the value to which this map maps the specified key,\n+     *  or null if the map contains no mapping for this key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public V get(final Object key) {\n+        checkKey(key);\n+        Node<K, V> node = lookupKey(key);\n+        return node == null ? null : node.getValue();\n+    }\n+\n+    /**\n+     * Puts the key-value pair into the map, replacing any previous pair.\n+     * <p>\n+     * When adding a key-value pair, the value may already exist in the map\n+     * against a different key. That mapping is removed, to ensure that the\n+     * value only occurs once in the inverse map.\n+     * <pre>\n+     *  BidiMap map1 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n+     *\n+     *  BidiMap map2 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n+     * </pre>\n+     * <p>\n+     * Both key and value must implement <code>Comparable</code>.\n+     *\n+     * @param key  key with which the specified value is to be  associated\n+     * @param value  value to be associated with the specified key\n+     * @return the previous value for the key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public V put(final K key, final V value) {\n+        V result = get(key);\n+        doPut(key, value);\n+        return result;\n+    }\n+\n+    /**\n+     * Puts all the mappings from the specified map into this map.\n+     * <p>\n+     * All keys and values must implement <code>Comparable</code>.\n+     *\n+     * @param map  the map to copy from\n+     */\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> e : map.entrySet()) {\n+            put(e.getKey(), e.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Removes the mapping for this key from this map if present.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key  key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key,\n+     *  or null if there was no mapping for key.\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public V remove(final Object key) {\n+        return doRemoveKey(key);\n+    }\n+\n+    /**\n+     * Removes all mappings from this map.\n+     */\n+    public void clear() {\n+        modify();\n+\n+        nodeCount = 0;\n+        rootNode[KEY.ordinal()] = null;\n+        rootNode[VALUE.ordinal()] = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the key to which this map maps the specified value.\n+     * Returns null if the map contains no mapping for this value.\n+     * <p>\n+     * The value must implement <code>Comparable</code>.\n+     *\n+     * @param value  value whose associated key is to be returned.\n+     * @return the key to which this map maps the specified value,\n+     *  or null if the map contains no mapping for this value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public K getKey(final Object value) {\n+        checkValue(value);\n+        Node<K, V> node = lookupValue(value);\n+        return node == null ? null : node.getKey();\n+    }\n+\n+    /**\n+     * Removes the mapping for this value from this map if present.\n+     * <p>\n+     * The value must implement <code>Comparable</code>.\n+     *\n+     * @param value  value whose mapping is to be removed from the map\n+     * @return previous key associated with specified value,\n+     *  or null if there was no mapping for value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public K removeValue(final Object value) {\n+        return doRemoveValue(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first (lowest) key currently in this map.\n+     *\n+     * @return the first (lowest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K firstKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return leastNode(rootNode[KEY.ordinal()], KEY).getKey();\n+    }\n+\n+    /**\n+     * Gets the last (highest) key currently in this map.\n+     *\n+     * @return the last (highest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K lastKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return greatestNode(rootNode[KEY.ordinal()], KEY).getKey();\n+    }\n+\n+    /**\n+     * Gets the next key after the one specified.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key the key to search for next from\n+     * @return the next key, null if no match or at end\n+     */\n+    public K nextKey(K key) {\n+        checkKey(key);\n+        Node<K, V> node = nextGreater(lookupKey(key), KEY);\n+        return node == null ? null : node.getKey();\n+    }\n+\n+    /**\n+     * Gets the previous key before the one specified.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key the key to search for previous from\n+     * @return the previous key, null if no match or at start\n+     */\n+    public K previousKey(K key) {\n+        checkKey(key);\n+        Node<K, V> node = nextSmaller(lookupKey(key), KEY);\n+        return node == null ? null : node.getKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the keys contained in this map in key order.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeyView(KEY);\n+        }\n+        return keySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the values contained in this map in key order.\n+     * The returned object can be cast to a Set.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Collection<V> values() {\n+        if (valuesSet == null) {\n+            valuesSet = new ValueView(KEY);\n+        }\n+        return valuesSet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the entries contained in this map in key order.\n+     * For simple iteration through the map, the MapIterator is quicker.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     * The returned MapEntry objects do not support setValue.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntryView();\n+        }\n+        return entrySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        if (isEmpty()) {\n+            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n+        }\n+        return new ViewMapIterator(KEY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the inverse map for comparison.\n+     *\n+     * @return the inverse map\n+     */\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n+        if (inverse == null) {\n+            inverse = new Inverse();\n+        }\n+        return inverse;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        return this.doEquals(obj, KEY);\n+    }\n+\n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @return the hash code value for this map\n+     */\n+    @Override\n+    public int hashCode() {\n+        return this.doHashCode(KEY);\n+    }\n+\n+    /**\n+     * Returns a string version of this Map in standard format.\n+     *\n+     * @return a standard format string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        return this.doToString(KEY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Put logic.\n+     *\n+     * @param key  the key, always the main map key\n+     * @param value  the value, always the main map value\n+     */\n+    private void doPut(final K key, final V value) {\n+        checkKeyAndValue(key, value);\n+\n+        // store previous and remove previous mappings\n+        doRemoveKey(key);\n+        doRemoveValue(value);\n+\n+        Node<K, V> node = rootNode[KEY.ordinal()];\n+        if (node == null) {\n+            // map is empty\n+            Node<K, V> root = new Node<K, V>(key, value);\n+            rootNode[KEY.ordinal()] = root;\n+            rootNode[VALUE.ordinal()] = root;\n+            grow();\n+\n+        } else {\n+            // add new mapping\n+            while (true) {\n+                int cmp = compare(key, node.getKey());\n+\n+                if (cmp == 0) {\n+                    // shouldn't happen\n+                    throw new IllegalArgumentException(\"Cannot store a duplicate key (\\\"\" + key + \"\\\") in this Map\");\n+                } else if (cmp < 0) {\n+                    if (node.getLeft(KEY) != null) {\n+                        node = node.getLeft(KEY);\n+                    } else {\n+                        Node<K, V> newNode = new Node<K, V>(key, value);\n+\n+                        insertValue(newNode);\n+                        node.setLeft(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+\n+                        break;\n+                    }\n+                } else { // cmp > 0\n+                    if (node.getRight(KEY) != null) {\n+                        node = node.getRight(KEY);\n+                    } else {\n+                        Node<K, V> newNode = new Node<K, V>(key, value);\n+\n+                        insertValue(newNode);\n+                        node.setRight(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private V doRemoveKey(Object key) {\n+        Node<K, V> node = lookupKey(key);\n+        if (node == null) {\n+            return null;\n+        }\n+        doRedBlackDelete(node);\n+        return node.getValue();\n+    }\n+\n+    private K doRemoveValue(Object value) {\n+        Node<K, V> node = lookupValue(value);\n+        if (node == null) {\n+            return null;\n+        }\n+        doRedBlackDelete(node);\n+        return node.getKey();\n+    }\n+\n+    /**\n+     * do the actual lookup of a piece of data\n+     *\n+     * @param data the key or value to be looked up\n+     * @param index  the KEY or VALUE int\n+     * @return the desired Node, or null if there is no mapping of the\n+     *         specified data\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private <T extends Comparable<T>> Node<K, V> lookup(final Object data, final DataElement dataElement) {\n+        Node<K, V> rval = null;\n+        Node<K, V> node = rootNode[dataElement.ordinal()];\n+\n+        while (node != null) {\n+            int cmp = compare((T) data, (T) node.getData(dataElement));\n+            if (cmp == 0) {\n+                rval = node;\n+                break;\n+            } else {\n+                node = (cmp < 0) ? node.getLeft(dataElement) : node.getRight(dataElement);\n+            }\n+        }\n+\n+        return rval;\n+    }\n+\n+    private Node<K, V> lookupKey(Object key) {\n+        return this.<K>lookup(key, KEY);\n+    }\n+\n+    private Node<K, V> lookupValue(Object value) {\n+        return this.<V>lookup(value, VALUE);\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node<K, V> nextGreater(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getRight(dataElement) != null) {\n+            // everything to the node's right is larger. The least of\n+            // the right node's descendants is the next larger node\n+            rval = leastNode(node.getRight(dataElement), dataElement);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose left child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's left\n+            // ... and that ancestor is the next greatest node\n+            Node<K, V> parent = node.getParent(dataElement);\n+            Node<K, V> child = node;\n+\n+            while ((parent != null) && (child == parent.getRight(dataElement))) {\n+                child = parent;\n+                parent = parent.getParent(dataElement);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node<K, V> nextSmaller(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getLeft(dataElement) != null) {\n+            // everything to the node's left is smaller. The greatest of\n+            // the left node's descendants is the next smaller node\n+            rval = greatestNode(node.getLeft(dataElement), dataElement);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose right child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's right\n+            // ... and that ancestor is the next greatest node\n+            Node<K, V> parent = node.getParent(dataElement);\n+            Node<K, V> child = node;\n+\n+            while ((parent != null) && (child == parent.getLeft(dataElement))) {\n+                child = parent;\n+                parent = parent.getParent(dataElement);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Compare two objects\n+     *\n+     * @param o1  the first object\n+     * @param o2  the second object\n+     *\n+     * @return negative value if o1 &lt; o2; 0 if o1 == o2; positive\n+     *         value if o1 &gt; o2\n+     */\n+    private static <T extends Comparable<T>> int compare(final T o1, final T o2) {\n+        return o1.compareTo(o2);\n+    }\n+\n+    /**\n+     * Find the least node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the smallest node, from the specified node, in the\n+     *         specified mapping\n+     */\n+    private Node<K, V> leastNode(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = node;\n+        if (rval != null) {\n+            while (rval.getLeft(dataElement) != null) {\n+                rval = rval.getLeft(dataElement);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * Find the greatest node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the greatest node, from the specified node\n+     */\n+    private Node<K, V> greatestNode(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = node;\n+        if (rval != null) {\n+            while (rval.getRight(dataElement) != null) {\n+                rval = rval.getRight(dataElement);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * copy the color from one node to another, dealing with the fact\n+     * that one or both nodes may, in fact, be null\n+     *\n+     * @param from the node whose color we're copying; may be null\n+     * @param to the node whose color we're changing; may be null\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void copyColor(final Node<K, V> from, final Node<K, V> to, final DataElement dataElement) {\n+        if (to != null) {\n+            if (from == null) {\n+                // by default, make it black\n+                to.setBlack(dataElement);\n+            } else {\n+                to.copyColor(from, dataElement);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * is the specified node red? if the node does not exist, no, it's\n+     * black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isRed(final Node<?, ?> node, final DataElement dataElement) {\n+        return node != null && node.isRed(dataElement);\n+    }\n+\n+    /**\n+     * is the specified black red? if the node does not exist, sure,\n+     * it's black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isBlack(final Node<?, ?> node, final DataElement dataElement) {\n+        return node == null || node.isBlack(dataElement);\n+    }\n+\n+    /**\n+     * force a node (if it exists) red\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeRed(final Node<?, ?> node, final DataElement dataElement) {\n+        if (node != null) {\n+            node.setRed(dataElement);\n+        }\n+    }\n+\n+    /**\n+     * force a node (if it exists) black\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeBlack(final Node<?, ?> node, final DataElement dataElement) {\n+        if (node != null) {\n+            node.setBlack(dataElement);\n+        }\n+    }\n+\n+    /**\n+     * get a node's grandparent. mind you, the node, its parent, or\n+     * its grandparent may not exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getGrandParent(final Node<K, V> node, final DataElement dataElement) {\n+        return getParent(getParent(node, dataElement), dataElement);\n+    }\n+\n+    /**\n+     * get a node's parent. mind you, the node, or its parent, may not\n+     * exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getParent(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getParent(dataElement);\n+    }\n+\n+    /**\n+     * get a node's right child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getRightChild(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getRight(dataElement);\n+    }\n+\n+    /**\n+     * get a node's left child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getLeftChild(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getLeft(dataElement);\n+    }\n+\n+    /**\n+     * do a rotate left. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateLeft(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rightChild = node.getRight(dataElement);\n+        node.setRight(rightChild.getLeft(dataElement), dataElement);\n+\n+        if (rightChild.getLeft(dataElement) != null) {\n+            rightChild.getLeft(dataElement).setParent(node, dataElement);\n+        }\n+        rightChild.setParent(node.getParent(dataElement), dataElement);\n+\n+        if (node.getParent(dataElement) == null) {\n+            // node was the root ... now its right child is the root\n+            rootNode[dataElement.ordinal()] = rightChild;\n+        } else if (node.getParent(dataElement).getLeft(dataElement) == node) {\n+            node.getParent(dataElement).setLeft(rightChild, dataElement);\n+        } else {\n+            node.getParent(dataElement).setRight(rightChild, dataElement);\n+        }\n+\n+        rightChild.setLeft(node, dataElement);\n+        node.setParent(rightChild, dataElement);\n+    }\n+\n+    /**\n+     * do a rotate right. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateRight(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> leftChild = node.getLeft(dataElement);\n+        node.setLeft(leftChild.getRight(dataElement), dataElement);\n+        if (leftChild.getRight(dataElement) != null) {\n+            leftChild.getRight(dataElement).setParent(node, dataElement);\n+        }\n+        leftChild.setParent(node.getParent(dataElement), dataElement);\n+\n+        if (node.getParent(dataElement) == null) {\n+            // node was the root ... now its left child is the root\n+            rootNode[dataElement.ordinal()] = leftChild;\n+        } else if (node.getParent(dataElement).getRight(dataElement) == node) {\n+            node.getParent(dataElement).setRight(leftChild, dataElement);\n+        } else {\n+            node.getParent(dataElement).setLeft(leftChild, dataElement);\n+        }\n+\n+        leftChild.setRight(node, dataElement);\n+        node.setParent(leftChild, dataElement);\n+    }\n+\n+    /**\n+     * complicated red-black insert stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param insertedNode the node to be inserted\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void doRedBlackInsert(final Node<K, V> insertedNode, final DataElement dataElement) {\n+        Node<K, V> currentNode = insertedNode;\n+        makeRed(currentNode, dataElement);\n+\n+        while ((currentNode != null)\n+            && (currentNode != rootNode[dataElement.ordinal()])\n+            && (isRed(currentNode.getParent(dataElement), dataElement))) {\n+            if (currentNode.isLeftChild(dataElement)) {\n+                Node<K, V> y = getRightChild(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(y, dataElement)) {\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(y, dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = getGrandParent(currentNode, dataElement);\n+                } else {\n+                    //dead code?\n+                    if (currentNode.isRightChild(dataElement)) {\n+                        currentNode = getParent(currentNode, dataElement);\n+\n+                        rotateLeft(currentNode, dataElement);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    if (getGrandParent(currentNode, dataElement) != null) {\n+                        rotateRight(getGrandParent(currentNode, dataElement), dataElement);\n+                    }\n+                }\n+            } else {\n+\n+                // just like clause above, except swap left for right\n+                Node<K, V> y = getLeftChild(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(y, dataElement)) {\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(y, dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = getGrandParent(currentNode, dataElement);\n+                } else {\n+                    //dead code?\n+                    if (currentNode.isLeftChild(dataElement)) {\n+                        currentNode = getParent(currentNode, dataElement);\n+\n+                        rotateRight(currentNode, dataElement);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    if (getGrandParent(currentNode, dataElement) != null) {\n+                        rotateLeft(getGrandParent(currentNode, dataElement), dataElement);\n+                    }\n+                }\n+            }\n+        }\n+\n+        makeBlack(rootNode[dataElement.ordinal()], dataElement);\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param deletedNode the node to be deleted\n+     */\n+    private void doRedBlackDelete(final Node<K, V> deletedNode) {\n+        for (DataElement dataElement : DataElement.values()) {\n+            // if deleted node has both left and children, swap with\n+            // the next greater node\n+            if ((deletedNode.getLeft(dataElement) != null) && (deletedNode.getRight(dataElement) != null)) {\n+                swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);\n+            }\n+\n+            Node<K, V> replacement =\n+                ((deletedNode.getLeft(dataElement) != null) ? deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement));\n+\n+            if (replacement != null) {\n+                replacement.setParent(deletedNode.getParent(dataElement), dataElement);\n+\n+                if (deletedNode.getParent(dataElement) == null) {\n+                    rootNode[dataElement.ordinal()] = replacement;\n+                } else if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n+                    deletedNode.getParent(dataElement).setLeft(replacement, dataElement);\n+                } else {\n+                    deletedNode.getParent(dataElement).setRight(replacement, dataElement);\n+                }\n+\n+                deletedNode.setLeft(null, dataElement);\n+                deletedNode.setRight(null, dataElement);\n+                deletedNode.setParent(null, dataElement);\n+\n+                if (isBlack(deletedNode, dataElement)) {\n+                    doRedBlackDeleteFixup(replacement, dataElement);\n+                }\n+            } else {\n+\n+                // replacement is null\n+                if (deletedNode.getParent(dataElement) == null) {\n+\n+                    // empty tree\n+                    rootNode[dataElement.ordinal()] = null;\n+                } else {\n+\n+                    // deleted node had no children\n+                    if (isBlack(deletedNode, dataElement)) {\n+                        doRedBlackDeleteFixup(deletedNode, dataElement);\n+                    }\n+\n+                    if (deletedNode.getParent(dataElement) != null) {\n+                        if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n+                            deletedNode.getParent(dataElement).setLeft(null, dataElement);\n+                        } else {\n+                            deletedNode.getParent(dataElement).setRight(null, dataElement);\n+                        }\n+\n+                        deletedNode.setParent(null, dataElement);\n+                    }\n+                }\n+            }\n+        }\n+        shrink();\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more. This\n+     * rebalances the tree (somewhat, as red-black trees are not\n+     * perfectly balanced -- perfect balancing takes longer)\n+     *\n+     * @param replacementNode the node being replaced\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void doRedBlackDeleteFixup(final Node<K, V> replacementNode, final DataElement dataElement) {\n+        Node<K, V> currentNode = replacementNode;\n+\n+        while ((currentNode != rootNode[dataElement.ordinal()]) && (isBlack(currentNode, dataElement))) {\n+            if (currentNode.isLeftChild(dataElement)) {\n+                Node<K, V> siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(siblingNode, dataElement)) {\n+                    makeBlack(siblingNode, dataElement);\n+                    makeRed(getParent(currentNode, dataElement), dataElement);\n+                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n+\n+                    siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n+                }\n+\n+                if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)\n+                    && isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n+                    makeRed(siblingNode, dataElement);\n+\n+                    currentNode = getParent(currentNode, dataElement);\n+                } else {\n+                    if (isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n+                        makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n+                        makeRed(siblingNode, dataElement);\n+                        rotateRight(siblingNode, dataElement);\n+\n+                        siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n+                    }\n+\n+                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n+                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = rootNode[dataElement.ordinal()];\n+                }\n+            } else {\n+                Node<K, V> siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(siblingNode, dataElement)) {\n+                    makeBlack(siblingNode, dataElement);\n+                    makeRed(getParent(currentNode, dataElement), dataElement);\n+                    rotateRight(getParent(currentNode, dataElement), dataElement);\n+\n+                    siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n+                }\n+\n+                if (isBlack(getRightChild(siblingNode, dataElement), dataElement)\n+                    && isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n+                    makeRed(siblingNode, dataElement);\n+\n+                    currentNode = getParent(currentNode, dataElement);\n+                } else {\n+                    if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n+                        makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n+                        makeRed(siblingNode, dataElement);\n+                        rotateLeft(siblingNode, dataElement);\n+\n+                        siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n+                    }\n+\n+                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n+                    rotateRight(getParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = rootNode[dataElement.ordinal()];\n+                }\n+            }\n+        }\n+\n+        makeBlack(currentNode, dataElement);\n+    }\n+\n+    /**\n+     * swap two nodes (except for their content), taking care of\n+     * special cases where one is the other's parent ... hey, it\n+     * happens.\n+     *\n+     * @param x one node\n+     * @param y another node\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement) {\n+        // Save initial values.\n+        Node<K, V> xFormerParent = x.getParent(dataElement);\n+        Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\n+        Node<K, V> xFormerRightChild = x.getRight(dataElement);\n+        Node<K, V> yFormerParent = y.getParent(dataElement);\n+        Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\n+        Node<K, V> yFormerRightChild = y.getRight(dataElement);\n+        boolean xWasLeftChild = (x.getParent(dataElement) != null) && (x == x.getParent(dataElement).getLeft(dataElement));\n+        boolean yWasLeftChild = (y.getParent(dataElement) != null) && (y == y.getParent(dataElement).getLeft(dataElement));\n+\n+        // Swap, handling special cases of one being the other's parent.\n+        if (x == yFormerParent) { // x was y's parent\n+            x.setParent(y, dataElement);\n+\n+            if (yWasLeftChild) {\n+                y.setLeft(x, dataElement);\n+                y.setRight(xFormerRightChild, dataElement);\n+            } else {\n+                y.setRight(x, dataElement);\n+                y.setLeft(xFormerLeftChild, dataElement);\n+            }\n+        } else {\n+            x.setParent(yFormerParent, dataElement);\n+\n+            if (yFormerParent != null) {\n+                if (yWasLeftChild) {\n+                    yFormerParent.setLeft(x, dataElement);\n+                } else {\n+                    yFormerParent.setRight(x, dataElement);\n+                }\n+            }\n+\n+            y.setLeft(xFormerLeftChild, dataElement);\n+            y.setRight(xFormerRightChild, dataElement);\n+        }\n+\n+        if (y == xFormerParent) { // y was x's parent\n+            y.setParent(x, dataElement);\n+\n+            if (xWasLeftChild) {\n+                x.setLeft(y, dataElement);\n+                x.setRight(yFormerRightChild, dataElement);\n+            } else {\n+                x.setRight(y, dataElement);\n+                x.setLeft(yFormerLeftChild, dataElement);\n+            }\n+        } else {\n+            y.setParent(xFormerParent, dataElement);\n+\n+            if (xFormerParent != null) {\n+                if (xWasLeftChild) {\n+                    xFormerParent.setLeft(y, dataElement);\n+                } else {\n+                    xFormerParent.setRight(y, dataElement);\n+                }\n+            }\n+\n+            x.setLeft(yFormerLeftChild, dataElement);\n+            x.setRight(yFormerRightChild, dataElement);\n+        }\n+\n+        // Fix children's parent pointers\n+        if (x.getLeft(dataElement) != null) {\n+            x.getLeft(dataElement).setParent(x, dataElement);\n+        }\n+\n+        if (x.getRight(dataElement) != null) {\n+            x.getRight(dataElement).setParent(x, dataElement);\n+        }\n+\n+        if (y.getLeft(dataElement) != null) {\n+            y.getLeft(dataElement).setParent(y, dataElement);\n+        }\n+\n+        if (y.getRight(dataElement) != null) {\n+            y.getRight(dataElement).setParent(y, dataElement);\n+        }\n+\n+        x.swapColors(y, dataElement);\n+\n+        // Check if root changed\n+        if (rootNode[dataElement.ordinal()] == x) {\n+            rootNode[dataElement.ordinal()] = y;\n+        } else if (rootNode[dataElement.ordinal()] == y) {\n+            rootNode[dataElement.ordinal()] = x;\n+        }\n+    }\n+\n+    /**\n+     * check if an object is fit to be proper input ... has to be\n+     * Comparable and non-null\n+     *\n+     * @param o the object being checked\n+     * @param index  the KEY or VALUE int (used to put the right word in the\n+     *              exception message)\n+     *\n+     * @throws NullPointerException if o is null\n+     * @throws ClassCastException if o is not Comparable\n+     */\n+    private static void checkNonNullComparable(final Object o, final DataElement dataElement) {\n+        if (o == null) {\n+            throw new NullPointerException(dataElement + \" cannot be null\");\n+        }\n+        if (!(o instanceof Comparable)) {\n+            throw new ClassCastException(dataElement + \" must be Comparable\");\n+        }\n+    }\n+\n+    /**\n+     * check a key for validity (non-null and implements Comparable)\n+     *\n+     * @param key the key to be checked\n+     *\n+     * @throws NullPointerException if key is null\n+     * @throws ClassCastException if key is not Comparable\n+     */\n+    private static void checkKey(final Object key) {\n+        checkNonNullComparable(key, KEY);\n+    }\n+\n+    /**\n+     * check a value for validity (non-null and implements Comparable)\n+     *\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if value is null\n+     * @throws ClassCastException if value is not Comparable\n+     */\n+    private static void checkValue(final Object value) {\n+        checkNonNullComparable(value, VALUE);\n+    }\n+\n+    /**\n+     * check a key and a value for validity (non-null and implements\n+     * Comparable)\n+     *\n+     * @param key the key to be checked\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if key or value is null\n+     * @throws ClassCastException if key or value is not Comparable\n+     */\n+    private static void checkKeyAndValue(final Object key, final Object value) {\n+        checkKey(key);\n+        checkValue(value);\n+    }\n+\n+    /**\n+     * increment the modification count -- used to check for\n+     * concurrent modification of the map through the map and through\n+     * an Iterator from one of its Set or Collection views\n+     */\n+    private void modify() {\n+        modifications++;\n+    }\n+\n+    /**\n+     * bump up the size and note that the map has changed\n+     */\n+    private void grow() {\n+        modify();\n+        nodeCount++;\n+    }\n+\n+    /**\n+     * decrement the size and note that the map has changed\n+     */\n+    private void shrink() {\n+        modify();\n+        nodeCount--;\n+    }\n+\n+    /**\n+     * insert a node by its value\n+     *\n+     * @param newNode the node to be inserted\n+     *\n+     * @throws IllegalArgumentException if the node already exists\n+     *                                     in the value mapping\n+     */\n+    private void insertValue(final Node<K, V> newNode) throws IllegalArgumentException {\n+        Node<K, V> node = rootNode[VALUE.ordinal()];\n+\n+        while (true) {\n+            int cmp = compare(newNode.getValue(), node.getValue());\n+\n+            if (cmp == 0) {\n+                throw new IllegalArgumentException(\n+                    \"Cannot store a duplicate value (\\\"\" + newNode.getData(VALUE) + \"\\\") in this Map\");\n+            } else if (cmp < 0) {\n+                if (node.getLeft(VALUE) != null) {\n+                    node = node.getLeft(VALUE);\n+                } else {\n+                    node.setLeft(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            } else { // cmp > 0\n+                if (node.getRight(VALUE) != null) {\n+                    node = node.getRight(VALUE);\n+                } else {\n+                    node.setRight(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @param type  the KEY or VALUE int\n+     * @return true if equal\n+     */\n+    private boolean doEquals(Object obj, DataElement dataElement) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map<?, ?> other = (Map<?, ?>) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+\n+        if (nodeCount > 0) {\n+            try {\n+                for (MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n+                    Object key = it.next();\n+                    Object value = it.getValue();\n+                    if (value.equals(other.get(key)) == false) {\n+                        return false;\n+                    }\n+                }\n+            } catch (ClassCastException ex) {\n+                return false;\n+            } catch (NullPointerException ex) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @param type  the KEY or VALUE int\n+     * @return the hash code value for this map\n+     */\n+    private int doHashCode(DataElement dataElement) {\n+        int total = 0;\n+        if (nodeCount > 0) {\n+            for (MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n+                Object key = it.next();\n+                Object value = it.getValue();\n+                total += (key.hashCode() ^ value.hashCode());\n+            }\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the string form of this map as per AbstractMap.\n+     *\n+     * @param type  the KEY or VALUE int\n+     * @return the string form of this map\n+     */\n+    private String doToString(DataElement dataElement) {\n+        if (nodeCount == 0) {\n+            return \"{}\";\n+        }\n+        StringBuilder buf = new StringBuilder(nodeCount * 32);\n+        buf.append('{');\n+        MapIterator<?, ?> it = getMapIterator(dataElement);\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            Object key = it.next();\n+            Object value = it.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key)\n+               .append('=')\n+               .append(value == this ? \"(this Map)\" : value);\n+\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+    private MapIterator<?, ?> getMapIterator(DataElement dataElement) {\n+        switch (dataElement) {\n+        case KEY:\n+            return new ViewMapIterator(KEY);\n+        case VALUE:\n+            return new InverseViewMapIterator(VALUE);\n+        default:\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A view of this map.\n+     */\n+    abstract class View<E> extends AbstractSet<E> {\n+\n+        /** Whether to return KEY or VALUE order. */\n+        protected final DataElement orderType;\n+\n+        /**\n+         * Constructor.\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param main  the main map\n+         */\n+        View(final DataElement orderType) {\n+            super();\n+            this.orderType = orderType;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return TreeBidiMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            TreeBidiMap.this.clear();\n+        }\n+    }\n+\n+    class KeyView extends View<K> {\n+\n+        /**\n+         * Create a new TreeBidiMap.KeyView.\n+         */\n+        public KeyView(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new ViewMapIterator(orderType);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            checkNonNullComparable(obj, KEY);\n+            return (lookupKey(obj) != null);\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            return doRemoveKey(o) != null;\n+        }\n+\n+    }\n+\n+    class ValueView extends View<V> {\n+\n+        /**\n+         * Create a new TreeBidiMap.ValueView.\n+         */\n+        public ValueView(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new InverseViewMapIterator(orderType);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            checkNonNullComparable(obj, VALUE);\n+            return (lookupValue(obj) != null);\n+        }\n+\n+        @Override\n+        public boolean remove(Object o) {\n+            return doRemoveValue(o) != null;\n+        }\n+\n+    }\n+\n+    /**\n+     * A view of this map.\n+     */\n+    class EntryView extends View<Map.Entry<K, V>> {\n+\n+        EntryView() {\n+            super(KEY);\n+        }\n+\n+        @Override\n+        public boolean contains(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupKey(entry.getKey());\n+            return node != null && node.getValue().equals(value);\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupKey(entry.getKey());\n+            if (node != null && node.getValue().equals(value)) {\n+                doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Iterator<java.util.Map.Entry<K, V>> iterator() {\n+            return new ViewMapEntryIterator();\n+        }\n+    }\n+\n+    /**\n+     * A view of this map.\n+     */\n+    class InverseEntryView extends View<Map.Entry<V, K>> {\n+\n+        InverseEntryView() {\n+            super(VALUE);\n+        }\n+\n+        @Override\n+        public boolean contains(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupValue(entry.getKey());\n+            return node != null && node.getKey().equals(value);\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object value = entry.getValue();\n+            Node<K, V> node = lookupValue(entry.getKey());\n+            if (node != null && node.getKey().equals(value)) {\n+                doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Iterator<java.util.Map.Entry<V, K>> iterator() {\n+            return new InverseViewMapEntryIterator();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    abstract class ViewIterator {\n+\n+        /** Whether to return KEY or VALUE order. */\n+        protected final DataElement orderType;\n+        /** The last node returned by the iterator. */\n+        protected Node<K, V> lastReturnedNode;\n+        /** The next node to be returned by the iterator. */\n+        protected Node<K, V> nextNode;\n+        /** The previous node in the sequence returned by the iterator. */\n+        protected Node<K, V> previousNode;\n+        /** The modification count. */\n+        private int expectedModifications;\n+\n+        /**\n+         * Constructor.\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param main  the main map\n+         */\n+        ViewIterator(final DataElement orderType) {\n+            super();\n+            this.orderType = orderType;\n+            expectedModifications = modifications;\n+            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);\n+            lastReturnedNode = null;\n+            previousNode = null;\n+        }\n+\n+        public final boolean hasNext() {\n+            return nextNode != null;\n+        }\n+\n+        protected Node<K, V> navigateNext() {\n+            if (nextNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            lastReturnedNode = nextNode;\n+            previousNode = nextNode;\n+            nextNode = nextGreater(nextNode, orderType);\n+            return lastReturnedNode;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return previousNode != null;\n+        }\n+\n+        protected Node<K, V> navigatePrevious() {\n+            if (previousNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            nextNode = lastReturnedNode;\n+            if (nextNode == null) {\n+                nextNode = nextGreater(previousNode, orderType);\n+            }\n+            lastReturnedNode = previousNode;\n+            previousNode = nextSmaller(previousNode, orderType);\n+            return lastReturnedNode;\n+        }\n+\n+        public final void remove() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException();\n+            }\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            doRedBlackDelete(lastReturnedNode);\n+            expectedModifications++;\n+            lastReturnedNode = null;\n+            if (nextNode == null) {\n+                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);\n+            } else {\n+                previousNode = nextSmaller(nextNode, orderType);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    class ViewMapIterator extends ViewIterator implements OrderedMapIterator<K, V> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        ViewMapIterator(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        public K getKey() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getValue();\n+        }\n+\n+        public V setValue(final V obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public K next() {\n+            return navigateNext().getKey();\n+        }\n+\n+        public K previous() {\n+            return navigatePrevious().getKey();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the map.\n+     */\n+    class InverseViewMapIterator extends ViewIterator implements OrderedMapIterator<V, K> {\n+\n+        /**\n+         * Create a new TreeBidiMap.InverseViewMapIterator.\n+         */\n+        public InverseViewMapIterator(DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        public V getKey() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getValue();\n+        }\n+\n+        public K getValue() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getKey();\n+        }\n+\n+        public K setValue(final K obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V next() {\n+            return navigateNext().getValue();\n+        }\n+\n+        public V previous() {\n+            return navigatePrevious().getValue();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the map entries.\n+     */\n+    class ViewMapEntryIterator extends ViewIterator implements OrderedIterator<Map.Entry<K, V>> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        ViewMapEntryIterator() {\n+            super(KEY);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return navigateNext();\n+        }\n+\n+        public Map.Entry<K, V> previous() {\n+            return navigatePrevious();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the inverse map entries.\n+     */\n+    class InverseViewMapEntryIterator extends ViewIterator implements OrderedIterator<Map.Entry<V, K>> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        InverseViewMapEntryIterator() {\n+            super(VALUE);\n+        }\n+\n+        public Map.Entry<V, K> next() {\n+            return createEntry(navigateNext());\n+        }\n+\n+        public Map.Entry<V, K> previous() {\n+            return createEntry(navigatePrevious());\n+        }\n+\n+        private Map.Entry<V, K> createEntry(Node<K, V> node) {\n+            return new UnmodifiableMapEntry<V, K>(node.getValue(), node.getKey());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node used to store the data.\n+     */\n+    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V>, KeyValue<K, V> {\n+\n+        private final K key;\n+        private final V value;\n+        private final Node<K, V>[] leftNode;\n+        private final Node<K, V>[] rightNode;\n+        private final Node<K, V>[] parentNode;\n+        private final boolean[] blackColor;\n+        private int hashcodeValue;\n+        private boolean calculatedHashCode;\n+\n+        /**\n+         * Make a new cell with given key and value, and with null\n+         * links, and black (true) colors.\n+         *\n+         * @param key\n+         * @param value\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        Node(final K key, final V value) {\n+            super();\n+            this.key = key;\n+            this.value = value;\n+            leftNode = new Node[2];\n+            rightNode = new Node[2];\n+            parentNode = new Node[2];\n+            blackColor = new boolean[] { true, true };\n+            calculatedHashCode = false;\n+        }\n+\n+        private Object getData(final DataElement dataElement) {\n+            switch (dataElement) {\n+            case KEY:\n+                return getKey();\n+            case VALUE:\n+                return getValue();\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\n+            leftNode[dataElement.ordinal()] = node;\n+        }\n+\n+        private Node<K, V> getLeft(final DataElement dataElement) {\n+            return leftNode[dataElement.ordinal()];\n+        }\n+\n+        private void setRight(final Node<K, V> node, final DataElement dataElement) {\n+            rightNode[dataElement.ordinal()] = node;\n+        }\n+\n+        private Node<K, V> getRight(final DataElement dataElement) {\n+            return rightNode[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Set this node's parent node.\n+         *\n+         * @param node  the new parent node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setParent(final Node<K, V> node, final DataElement dataElement) {\n+            parentNode[dataElement.ordinal()] = node;\n+        }\n+\n+        /**\n+         * Get the parent node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the parent node, may be null\n+         */\n+        private Node<K, V> getParent(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Exchange colors with another node.\n+         *\n+         * @param node  the node to swap with\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n+            // Swap colors -- old hacker's trick\n+            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n+            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\n+            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Is this node black?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if black (which is represented as a true boolean)\n+         */\n+        private boolean isBlack(final DataElement dataElement) {\n+            return blackColor[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Is this node red?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if non-black\n+         */\n+        private boolean isRed(final DataElement dataElement) {\n+            return !blackColor[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Make this node black.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setBlack(final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = true;\n+        }\n+\n+        /**\n+         * Make this node red.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setRed(final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = false;\n+        }\n+\n+        /**\n+         * Make this node the same color as another\n+         *\n+         * @param node  the node whose color we're adopting\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\n+        }\n+\n+        private boolean isLeftChild(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()] != null\n+                    && parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;\n+        }\n+\n+        private boolean isRightChild(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()] != null\n+                    && parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;\n+        }\n+\n+        //-------------------------------------------------------------------\n+        /**\n+         * Gets the key.\n+         *\n+         * @return the key corresponding to this entry.\n+         */\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        /**\n+         * Gets the value.\n+         *\n+         * @return the value corresponding to this entry.\n+         */\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Optional operation that is not permitted in this implementation\n+         *\n+         * @param ignored\n+         * @return does not return\n+         * @throws UnsupportedOperationException always\n+         */\n+        public V setValue(final V ignored) throws UnsupportedOperationException {\n+            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n+        }\n+\n+        /**\n+         * Compares the specified object with this entry for equality.\n+         * Returns true if the given object is also a map entry and\n+         * the two entries represent the same mapping.\n+         *\n+         * @param obj  the object to be compared for equality with this entry.\n+         * @return true if the specified object is equal to this entry.\n+         */\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (!(obj instanceof Map.Entry)) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n+            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n+        }\n+\n+        /**\n+         * @return the hash code value for this map entry.\n+         */\n+        @Override\n+        public int hashCode() {\n+            if (!calculatedHashCode) {\n+                hashcodeValue = getKey().hashCode() ^ getValue().hashCode();\n+                calculatedHashCode = true;\n+            }\n+            return hashcodeValue;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The inverse map implementation.\n+     */\n+    class Inverse implements OrderedBidiMap<V, K> {\n+\n+        /** Store the keySet once created. */\n+        private Set<V> inverseKeySet;\n+        /** Store the valuesSet once created. */\n+        private Set<K> inverseValuesSet;\n+        /** Store the entrySet once created. */\n+        private Set<Map.Entry<V, K>> inverseEntrySet;\n+\n+        public int size() {\n+            return TreeBidiMap.this.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return TreeBidiMap.this.isEmpty();\n+        }\n+\n+        public K get(final Object key) {\n+            return TreeBidiMap.this.getKey(key);\n+        }\n+\n+        public V getKey(final Object value) {\n+            return TreeBidiMap.this.get(value);\n+        }\n+\n+        public boolean containsKey(final Object key) {\n+            return TreeBidiMap.this.containsValue(key);\n+        }\n+\n+        public boolean containsValue(final Object value) {\n+            return TreeBidiMap.this.containsKey(value);\n+        }\n+\n+        public V firstKey() {\n+            if (TreeBidiMap.this.nodeCount == 0) {\n+                throw new NoSuchElementException(\"Map is empty\");\n+            }\n+            return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n+        }\n+\n+        public V lastKey() {\n+            if (TreeBidiMap.this.nodeCount == 0) {\n+                throw new NoSuchElementException(\"Map is empty\");\n+            }\n+            return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n+        }\n+\n+        public V nextKey(V key) {\n+            checkKey(key);\n+            Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            return node == null ? null : node.getValue();\n+        }\n+\n+        public V previousKey(V key) {\n+            checkKey(key);\n+            Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            return node == null ? null : node.getValue();\n+        }\n+\n+        public K put(final V key, final K value) {\n+            K result = get(key);\n+            TreeBidiMap.this.doPut(value, key);\n+            return result;\n+        }\n+\n+        public void putAll(Map<? extends V, ? extends K> map) {\n+            for (Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n+                put(e.getKey(), e.getValue());\n+            }\n+        }\n+\n+        public K remove(final Object key) {\n+            return TreeBidiMap.this.removeValue(key);\n+        }\n+\n+        public V removeValue(final Object value) {\n+            return TreeBidiMap.this.remove(value);\n+        }\n+\n+        public void clear() {\n+            TreeBidiMap.this.clear();\n+        }\n+\n+        public Set<V> keySet() {\n+            if (inverseKeySet == null) {\n+                inverseKeySet = new ValueView(VALUE);\n+            }\n+            return inverseKeySet;\n+        }\n+\n+        public Collection<K> values() {\n+            if (inverseValuesSet == null) {\n+                inverseValuesSet = new KeyView(VALUE);\n+            }\n+            return inverseValuesSet;\n+        }\n+\n+        public Set<Map.Entry<V, K>> entrySet() {\n+            if (inverseEntrySet == null) {\n+                inverseEntrySet = new InverseEntryView();\n+            }\n+            return inverseEntrySet;\n+        }\n+\n+        public OrderedMapIterator<V, K> mapIterator() {\n+            if (isEmpty()) {\n+                return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n+            }\n+            return new InverseViewMapIterator(VALUE);\n+        }\n+\n+        public OrderedBidiMap<K, V> inverseBidiMap() {\n+            return TreeBidiMap.this;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return TreeBidiMap.this.doHashCode(DataElement.VALUE);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return TreeBidiMap.this.doToString(DataElement.VALUE);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>BidiMap</code> to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableBidiMap<K, V>\n+        extends AbstractBidiMapDecorator<K, V> implements Unmodifiable {\n+\n+    /** The inverse unmodifiable map */\n+    private UnmodifiableBidiMap<V, K> inverse;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * <p>\n+     * If the map passed in is already unmodifiable, it is returned.\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @return an unmodifiable BidiMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> BidiMap<K, V> unmodifiableBidiMap(BidiMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableBidiMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableBidiMap(BidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K removeValue(Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        MapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+    }\n+\n+    @Override\n+    public synchronized BidiMap<V, K> inverseBidiMap() {\n+        if (inverse == null) {\n+            inverse = new UnmodifiableBidiMap<V, K>(decorated().inverseBidiMap());\n+            inverse.inverse = this;\n+        }\n+        return inverse;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.OrderedBidiMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableOrderedMapIterator;\n+import org.apache.commons.collections.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>OrderedBidiMap</code> to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableOrderedBidiMap<K, V>\n+        extends AbstractOrderedBidiMapDecorator<K, V> implements Unmodifiable {\n+\n+    /** The inverse unmodifiable map */\n+    private UnmodifiableOrderedBidiMap<V, K> inverse;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * <p>\n+     * If the map passed in is already unmodifiable, it is returned.\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @return an unmodifiable OrderedBidiMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(OrderedBidiMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableOrderedBidiMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableOrderedBidiMap(OrderedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K removeValue(Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n+        return inverseOrderedBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n+    }\n+\n+    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n+        if (inverse == null) {\n+            inverse = new UnmodifiableOrderedBidiMap<V, K>(decorated().inverseBidiMap());\n+            inverse.inverse = this;\n+        }\n+        return inverse;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.SortedBidiMap;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableOrderedMapIterator;\n+import org.apache.commons.collections.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections.map.UnmodifiableSortedMap;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>SortedBidiMap</code> to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableSortedBidiMap<K, V>\n+        extends AbstractSortedBidiMapDecorator<K, V> implements Unmodifiable {\n+\n+    /** The inverse unmodifiable map */\n+    private UnmodifiableSortedBidiMap<V, K> inverse;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * <p>\n+     * If the map passed in is already unmodifiable, it is returned.\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @return an unmodifiable SortedBidiMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(SortedBidiMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableSortedBidiMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableSortedBidiMap(SortedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K removeValue(Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n+        if (inverse == null) {\n+            inverse = new UnmodifiableSortedBidiMap<V, K>(decorated().inverseBidiMap());\n+            inverse.inverse = this;\n+        }\n+        return inverse;\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        SortedMap<K, V> sm = decorated().subMap(fromKey, toKey);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> headMap(K toKey) {\n+        SortedMap<K, V> sm = decorated().headMap(toKey);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        SortedMap<K, V> sm = decorated().tailMap(fromKey);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/AbstractBufferDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated buffer.\n+ *\n+ * @param <E> the type of the elements in the buffer\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractBufferDecorator<E> extends AbstractCollectionDecorator<E> implements\n+        Buffer<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2629815475789577029L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractBufferDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractBufferDecorator(Buffer<E> buffer) {\n+        super(buffer);\n+    }\n+\n+    /**\n+     * Gets the buffer being decorated.\n+     * \n+     * @return the decorated buffer\n+     */\n+    @Override\n+    protected Buffer<E> decorated() {\n+        return (Buffer<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E get() {\n+        return decorated().get();\n+    }\n+\n+    public E remove() {\n+        return decorated().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to make {@link #get()} and\n+ * {@link #remove()} block when the <code>Buffer</code> is empty.\n+ * <p>\n+ * If either <code>get</code> or <code>remove</code> is called on an empty\n+ * <code>Buffer</code>, the calling thread waits for notification that\n+ * an <code>add</code> or <code>addAll</code> operation has completed.\n+ * <p>\n+ * When one or more entries are added to an empty <code>Buffer</code>,\n+ * all threads blocked in <code>get</code> or <code>remove</code> are notified.\n+ * There is no guarantee that concurrent blocked <code>get</code> or\n+ * <code>remove</code> requests will be \"unblocked\" and receive data in the\n+ * order that they arrive.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * This class contains an extra field in 3.2, however the serialization\n+ * specification will handle this gracefully.\n+ *\n+ * @author Stephen Colebourne\n+ * @author Janek Bogucki\n+ * @author Phil Steitz\n+ * @author James Carman\n+ * @param <E> the type of the elements in the buffer\n+ * @version $Revision$ $Date$\n+ * @since Commons Collections 3.0\n+ */\n+public class BlockingBuffer<E> extends SynchronizedBuffer<E> {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 1719328905017860541L;\n+    /** The timeout value in milliseconds. */\n+    private final long timeout;\n+\n+    /**\n+     * Factory method to create a blocking buffer.\n+     *\n+     * @param <T> the type of the elements in the buffer\n+     * @param buffer the buffer to decorate, must not be null\n+     * @return a new blocking Buffer\n+     * @throws IllegalArgumentException if buffer is null\n+     */\n+    public static <T> Buffer<T> blockingBuffer(Buffer<T> buffer) {\n+        return new BlockingBuffer<T>(buffer);\n+    }\n+\n+    /**\n+     * Factory method to create a blocking buffer with a timeout value.\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n+     * @return a new blocking buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <T> Buffer<T> blockingBuffer(Buffer<T> buffer, long timeoutMillis) {\n+        return new BlockingBuffer<T>(buffer, timeoutMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param buffer the buffer to decorate, must not be null\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    protected BlockingBuffer(Buffer<E> buffer) {\n+        super(buffer);\n+        this.timeout = 0;\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n+     * @throws IllegalArgumentException if the buffer is null\n+     * @since Commons Collections 3.2\n+     */\n+    protected BlockingBuffer(Buffer<E> buffer, long timeoutMillis) {\n+        super(buffer);\n+        this.timeout = (timeoutMillis < 0 ? 0 : timeoutMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(E o) {\n+        synchronized (lock) {\n+            boolean result = collection.add(o);\n+            lock.notifyAll();\n+            return result;\n+        }\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> c) {\n+        synchronized (lock) {\n+            boolean result = collection.addAll(c);\n+            lock.notifyAll();\n+            return result;\n+        }\n+    }\n+\n+    /**\n+     * Gets the next value from the buffer, waiting until an object is\n+     * added if the buffer is empty. This method uses the default timeout\n+     * set in the constructor.\n+     *\n+     * @throws BufferUnderflowException if an interrupt is received\n+     */\n+    @Override\n+    public E get() {\n+        synchronized (lock) {\n+            while (collection.isEmpty()) {\n+                try {\n+                    if (timeout <= 0) {\n+                        lock.wait();\n+                    } else {\n+                        return get(timeout);\n+                    }\n+                } catch (InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            return decorated().get();\n+        }\n+    }\n+\n+    /**\n+     * Gets the next value from the buffer, waiting until an object is\n+     * added for up to the specified timeout value if the buffer is empty.\n+     *\n+     * @param timeout  the timeout value in milliseconds\n+     * @throws BufferUnderflowException if an interrupt is received\n+     * @throws BufferUnderflowException if the timeout expires\n+     * @since Commons Collections 3.2\n+     */\n+    public E get(final long timeout) {\n+        synchronized (lock) {\n+            final long expiration = System.currentTimeMillis() + timeout;\n+            long timeLeft = expiration - System.currentTimeMillis();\n+            while (timeLeft > 0 && collection.isEmpty()) {\n+                try {\n+                    lock.wait(timeLeft);\n+                    timeLeft = expiration - System.currentTimeMillis();\n+                } catch(InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            if (collection.isEmpty()) {\n+                throw new BufferUnderflowException(\"Timeout expired\");\n+            }\n+            return decorated().get();\n+        }\n+    }\n+\n+    /**\n+     * Removes the next value from the buffer, waiting until an object is\n+     * added if the buffer is empty. This method uses the default timeout\n+     * set in the constructor.\n+     *\n+     * @throws BufferUnderflowException if an interrupt is received\n+     */\n+    @Override\n+    public E remove() {\n+        synchronized (lock) {\n+            while (collection.isEmpty()) {\n+                try {\n+                    if (timeout <= 0) {\n+                        lock.wait();\n+                    } else {\n+                        return remove(timeout);\n+                    }\n+                } catch (InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            return decorated().remove();\n+        }\n+    }\n+\n+    /**\n+     * Removes the next value from the buffer, waiting until an object is\n+     * added for up to the specified timeout value if the buffer is empty.\n+     *\n+     * @param timeout  the timeout value in milliseconds\n+     * @throws BufferUnderflowException if an interrupt is received\n+     * @throws BufferUnderflowException if the timeout expires\n+     * @since Commons Collections 3.2\n+     */\n+    public E remove(final long timeout) {\n+        synchronized (lock) {\n+            final long expiration = System.currentTimeMillis() + timeout;\n+            long timeLeft = expiration - System.currentTimeMillis();\n+            while (timeLeft > 0 && collection.isEmpty()) {\n+                try {\n+                    lock.wait(timeLeft);\n+                    timeLeft = expiration - System.currentTimeMillis();\n+                } catch(InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            if (collection.isEmpty()) {\n+                throw new BufferUnderflowException(\"Timeout expired\");\n+            }\n+            return decorated().remove();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.BoundedCollection;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferOverflowException;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to ensure a fixed maximum size.\n+ * <p>\n+ * Note: This class should only be used if you need to add bounded\n+ * behaviour to another buffer. If you just want a bounded buffer then\n+ * you should use {@link BoundedFifoBuffer} or {@link CircularFifoBuffer}.\n+ * <p>\n+ * The decoration methods allow you to specify a timeout value.\n+ * This alters the behaviour of the add methods when the buffer is full.\n+ * Normally, when the buffer is full, the add method will throw an exception.\n+ * With a timeout, the add methods will wait for up to the timeout period\n+ * to try and add the elements.\n+ *\n+ * @author James Carman\n+ * @author Stephen Colebourne\n+ * @version $Revision$ $Date$\n+ * @since Commons Collections 3.2\n+ */\n+public class BoundedBuffer<E> extends SynchronizedBuffer<E> implements BoundedCollection<E> {\n+\n+    /** The serialization version. */\n+    private static final long serialVersionUID = 1536432911093974264L;\n+\n+    /** The maximum size. */\n+    private final int maximumSize;\n+    /** The timeout milliseconds. */\n+    private final long timeout;\n+\n+    /**\n+     * Factory method to create a bounded buffer.\n+     * <p>\n+     * When the buffer is full, it will immediately throw a\n+     * <code>BufferOverflowException</code> on calling <code>add()</code>.\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param maximumSize  the maximum size, must be size one or greater\n+     * @return a new bounded buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     * @throws IllegalArgumentException if the maximum size is zero or less\n+     */\n+    public static <E> BoundedBuffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize) {\n+        return new BoundedBuffer<E>(buffer, maximumSize, 0L);\n+    }\n+\n+    /**\n+     * Factory method to create a bounded buffer that blocks for a maximum\n+     * amount of time.\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param maximumSize  the maximum size, must be size one or greater\n+     * @param timeout  the maximum amount of time to wait in milliseconds\n+     * @return a new bounded buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     * @throws IllegalArgumentException if the maximum size is zero or less\n+     */\n+    public static <E> BoundedBuffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize, long timeout) {\n+        return new BoundedBuffer<E>(buffer, maximumSize, timeout);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) another buffer, making it bounded\n+     * waiting only up to a maximum amount of time.\n+     *\n+     * @param buffer  the buffer to wrap, must not be null\n+     * @param maximumSize  the maximum size, must be size one or greater\n+     * @param timeout  the maximum amount of time to wait\n+     * @throws IllegalArgumentException if the buffer is null\n+     * @throws IllegalArgumentException if the maximum size is zero or less\n+     */\n+    protected BoundedBuffer(Buffer<E> buffer, int maximumSize, long timeout) {\n+        super(buffer);\n+        if (maximumSize < 1) {\n+            throw new IllegalArgumentException();\n+        }\n+        this.maximumSize = maximumSize;\n+        this.timeout = timeout;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public E remove() {\n+        synchronized (lock) {\n+            E returnValue = decorated().remove();\n+            lock.notifyAll();\n+            return returnValue;\n+        }\n+    }\n+\n+    @Override\n+    public boolean add(E o) {\n+        synchronized (lock) {\n+            timeoutWait(1);\n+            return decorated().add(o);\n+        }\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> c) {\n+        synchronized (lock) {\n+            timeoutWait(c.size());\n+            return decorated().addAll(c);\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new NotifyingIterator(collection.iterator());\n+    }\n+\n+    private void timeoutWait(final int nAdditions) {\n+        // method synchronized by callers\n+        if (nAdditions > maximumSize) {\n+            throw new BufferOverflowException(\n+                    \"Buffer size cannot exceed \" + maximumSize);\n+        }\n+        if (timeout <= 0) {\n+            // no wait period (immediate timeout)\n+            if (decorated().size() + nAdditions > maximumSize) {\n+                throw new BufferOverflowException(\n+                        \"Buffer size cannot exceed \" + maximumSize);\n+            }\n+            return;\n+        }\n+        final long expiration = System.currentTimeMillis() + timeout;\n+        long timeLeft = expiration - System.currentTimeMillis();\n+        while (timeLeft > 0 && decorated().size() + nAdditions > maximumSize) {\n+            try {\n+                lock.wait(timeLeft);\n+                timeLeft = expiration - System.currentTimeMillis();\n+            } catch (InterruptedException ex) {\n+                PrintWriter out = new PrintWriter(new StringWriter());\n+                ex.printStackTrace(out);\n+                throw new BufferUnderflowException(\n+                    \"Caused by InterruptedException: \" + out.toString());\n+            }\n+        }\n+        if (decorated().size() + nAdditions > maximumSize) {\n+            throw new BufferOverflowException(\"Timeout expired\");\n+        }\n+    }\n+\n+    public boolean isFull() {\n+        // size() is synchronized\n+        return (size() == maxSize());\n+    }\n+\n+    public int maxSize() {\n+        return maximumSize;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * BoundedBuffer iterator.\n+     */\n+    private class NotifyingIterator extends AbstractIteratorDecorator<E> {\n+\n+        public NotifyingIterator(Iterator<E> it) {\n+            super(it);\n+        }\n+\n+        @Override\n+        public void remove() {\n+            synchronized (lock) {\n+                iterator.remove();\n+                lock.notifyAll();\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.BoundedCollection;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferOverflowException;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+/**\n+ * The BoundedFifoBuffer is a very efficient implementation of\n+ * <code>Buffer</code> that is of a fixed size.\n+ * <p>\n+ * The removal order of a <code>BoundedFifoBuffer</code> is based on the\n+ * insertion order; elements are removed in the same order in which they\n+ * were added.  The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #add(Object)}, {@link #remove()} and {@link #get()} operations\n+ * all perform in constant time.  All other operations perform in linear\n+ * time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <code>BoundedFifoBuffer</code>:\n+ * <pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new BoundedFifoBuffer());\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v2.1)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Avalon\n+ * @author Berin Loritsch\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Herve Quiroz\n+ */\n+public class BoundedFifoBuffer<E> extends AbstractCollection<E>\n+        implements Buffer<E>, BoundedCollection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5603722811189451017L;\n+\n+    /** Underlying storage array */\n+    private transient E[] elements;\n+\n+    /** Array index of first (oldest) buffer element */\n+    private transient int start = 0;\n+\n+    /**\n+     * Index mod maxElements of the array position following the last buffer\n+     * element.  Buffer elements start at elements[start] and \"wrap around\"\n+     * elements[maxElements-1], ending at elements[decrement(end)].\n+     * For example, elements = {c,a,b}, start=1, end=1 corresponds to\n+     * the buffer [a,b,c].\n+     */\n+    private transient int end = 0;\n+\n+    /** Flag to indicate if the buffer is currently full. */\n+    private transient boolean full = false;\n+\n+    /** Capacity of the buffer */\n+    private final int maxElements;\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold\n+     * 32 elements.\n+     */\n+    public BoundedFifoBuffer() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold\n+     * the specified number of elements.\n+     *\n+     * @param size  the maximum number of elements for this fifo\n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public BoundedFifoBuffer(int size) {\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        elements = (E[]) new Object[size];\n+        maxElements = elements.length;\n+    }\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold all\n+     * of the elements in the specified collection. That collection's\n+     * elements will also be added to the buffer.\n+     *\n+     * @param coll  the collection whose elements to add, may not be null\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public BoundedFifoBuffer(Collection<? extends E> coll) {\n+        this(coll.size());\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the buffer out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(size());\n+        for (Iterator<E> it = iterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+        }\n+    }\n+\n+    /**\n+     * Read the buffer in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        elements = (E[]) new Object[maxElements];\n+        int size = in.readInt();\n+        for (int i = 0; i < size; i++) {\n+            elements[i] = (E) in.readObject();\n+        }\n+        start = 0;\n+        full = (size == maxElements);\n+        if (full) {\n+            end = 0;\n+        } else {\n+            end = size;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements stored in the buffer.\n+     *\n+     * @return this buffer's size\n+     */\n+    @Override\n+    public int size() {\n+        int size = 0;\n+\n+        if (end < start) {\n+            size = maxElements - start + end;\n+        } else if (end == start) {\n+            size = (full ? maxElements : 0);\n+        } else {\n+            size = end - start;\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if this buffer is empty; false otherwise.\n+     *\n+     * @return true if this buffer is empty\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Returns true if this collection is full and no new elements can be added.\n+     *\n+     * @return <code>true</code> if the collection is full\n+     */\n+    public boolean isFull() {\n+        return size() == maxElements;\n+    }\n+\n+    /**\n+     * Gets the maximum size of the collection (the bound).\n+     *\n+     * @return the maximum number of elements the collection can hold\n+     */\n+    public int maxSize() {\n+        return maxElements;\n+    }\n+\n+    /**\n+     * Clears this buffer.\n+     */\n+    @Override\n+    public void clear() {\n+        full = false;\n+        start = 0;\n+        end = 0;\n+        Arrays.fill(elements, null);\n+    }\n+\n+    /**\n+     * Adds the given element to this buffer.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     * @throws BufferOverflowException  if this buffer is full\n+     */\n+    @Override\n+    public boolean add(E element) {\n+        if (null == element) {\n+            throw new NullPointerException(\"Attempted to add null object to buffer\");\n+        }\n+\n+        if (full) {\n+            throw new BufferOverflowException(\"The buffer cannot hold more than \" + maxElements + \" objects.\");\n+        }\n+\n+        elements[end++] = element;\n+\n+        if (end >= maxElements) {\n+            end = 0;\n+        }\n+\n+        if (end == start) {\n+            full = true;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the least recently inserted element in this buffer.\n+     *\n+     * @return the least recently inserted element\n+     * @throws BufferUnderflowException  if the buffer is empty\n+     */\n+    public E get() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+        return elements[start];\n+    }\n+\n+    /**\n+     * Removes the least recently inserted element from this buffer.\n+     *\n+     * @return the least recently inserted element\n+     * @throws BufferUnderflowException  if the buffer is empty\n+     */\n+    public E remove() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        E element = elements[start];\n+\n+        if (null != element) {\n+            elements[start++] = null;\n+\n+            if (start >= maxElements) {\n+                start = 0;\n+            }\n+            full = false;\n+        }\n+        return element;\n+    }\n+\n+    /**\n+     * Increments the internal index.\n+     *\n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n+    private int increment(int index) {\n+        index++;\n+        if (index >= maxElements) {\n+            index = 0;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Decrements the internal index.\n+     *\n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) {\n+            index = maxElements - 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Returns an iterator over this buffer's elements.\n+     *\n+     * @return an iterator over this buffer's elements\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n+\n+            private int index = start;\n+            private int lastReturnedIndex = -1;\n+            private boolean isFirst = full;\n+\n+            public boolean hasNext() {\n+                return isFirst || (index != end);\n+            }\n+\n+            public E next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n+                isFirst = false;\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == start) {\n+                    BoundedFifoBuffer.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                int pos = lastReturnedIndex + 1;\n+                if (start < lastReturnedIndex && pos < end) {\n+                    // shift in one part\n+                    System.arraycopy(elements, pos, elements,\n+                            lastReturnedIndex, end - pos);\n+                } else {\n+                    // Other elements require us to shift the subsequent elements\n+                    while (pos != end) {\n+                        if (pos >= maxElements) {\n+                            elements[pos - 1] = elements[0];\n+                            pos = 0;\n+                        } else {\n+                            elements[decrement(pos)] = elements[pos];\n+                            pos = increment(pos);\n+                        }\n+                    }\n+                }\n+\n+                lastReturnedIndex = -1;\n+                end = decrement(end);\n+                elements[end] = null;\n+                full = false;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/CircularFifoBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Collection;\n+\n+/**\n+ * CircularFifoBuffer is a first in first out buffer with a fixed size that\n+ * replaces its oldest element if full.\n+ * <p>\n+ * The removal order of a <code>CircularFifoBuffer</code> is based on the\n+ * insertion order; elements are removed in the same order in which they\n+ * were added.  The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #add(Object)}, {@link #remove()} and {@link #get()} operations\n+ * all perform in constant time.  All other operations perform in linear\n+ * time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <code>CircularFifoBuffer</code>:\n+ * <pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new CircularFifoBuffer());\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stefano Fornari\n+ * @author Stephen Colebourne\n+ */\n+public class CircularFifoBuffer<E> extends BoundedFifoBuffer<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8423413834657610406L;\n+\n+    /**\n+     * Constructor that creates a buffer with the default size of 32.\n+     */\n+    public CircularFifoBuffer() {\n+        super(32);\n+    }\n+\n+    /**\n+     * Constructor that creates a buffer with the specified size.\n+     *\n+     * @param size  the size of the buffer (cannot be changed)\n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    public CircularFifoBuffer(int size) {\n+        super(size);\n+    }\n+\n+    /**\n+     * Constructor that creates a buffer from the specified collection.\n+     * The collection size also sets the buffer size\n+     *\n+     * @param coll  the collection to copy into the buffer, may not be null\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public CircularFifoBuffer(Collection<E> coll) {\n+        super(coll);\n+    }\n+\n+    /**\n+     * If the buffer is full, the least recently added element is discarded so\n+     * that a new element can be inserted.\n+     *\n+     * @param element the element to add\n+     * @return true, always\n+     */\n+    @Override\n+    public boolean add(E element) {\n+        if (isFull()) {\n+            remove();\n+        }\n+        return super.add(element);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/PredicatedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This buffer exists to provide validation for the decorated buffer.\n+ * It is normally created to decorate an empty buffer.\n+ * If an object cannot be added to the buffer, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the buffer.\n+ * <pre>Buffer buffer = PredicatedBuffer.decorate(new UnboundedFifoBuffer(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedBuffer<E> extends PredicatedCollection<E> implements Buffer<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2307609000539943581L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) buffer.\n+     * <p>\n+     * If there are any elements already in the buffer being decorated, they\n+     * are validated.\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated Buffer\n+     * @throws IllegalArgumentException if buffer or predicate is null\n+     * @throws IllegalArgumentException if the buffer contains invalid elements\n+     */\n+    public static <T> Buffer<T> predicatedBuffer(Buffer<T> buffer, Predicate<? super T> predicate) {\n+        return new PredicatedBuffer<T>(buffer, predicate);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are validated.\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if buffer or predicate is null\n+     * @throws IllegalArgumentException if the buffer contains invalid elements\n+     */\n+    protected PredicatedBuffer(Buffer<E> buffer, Predicate<? super E> predicate) {\n+        super(buffer, predicate);\n+    }\n+\n+    /**\n+     * Gets the buffer being decorated.\n+     * \n+     * @return the decorated buffer\n+     */\n+    @Override\n+    protected Buffer<E> decorated() {\n+        return (Buffer<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E get() {\n+        return decorated().get();\n+    }\n+\n+    public E remove() {\n+        return decorated().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+\n+/**\n+ * Binary heap implementation of <code>Buffer</code> that provides for\n+ * removal based on <code>Comparator</code> ordering.\n+ * <p>\n+ * The removal order of a binary heap is based on either the natural sort\n+ * order of its elements or a specified {@link Comparator}.  The \n+ * {@link #remove()} method always returns the first element as determined\n+ * by the sort order.  (The <code>ascendingOrder</code> flag in the constructors\n+ * can be used to reverse the sort order, in which case {@link #remove()}\n+ * will always remove the last element.)  The removal order is \n+ * <i>not</i> the same as the order of iteration; elements are\n+ * returned by the iterator in no particular order.\n+ * <p>\n+ * The {@link #add(Object)} and {@link #remove()} operations perform\n+ * in logarithmic time.  The {@link #get()} operation performs in constant\n+ * time.  All other operations perform in linear time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  Use \n+ * {@link org.apache.commons.collections.BufferUtils#synchronizedBuffer(Buffer)} or\n+ * {@link org.apache.commons.collections.buffer.SynchronizedBuffer#synchronizedBuffer(Buffer)}\n+ * to provide synchronized access to a <code>PriorityBuffer</code>:\n+ * <pre>\n+ * Buffer heap = SynchronizedBuffer.decorate(new PriorityBuffer());\n+ * </pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.2.\n+ *\n+ * @since Commons Collections 3.0 (previously BinaryHeap v1.0)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Peter Donald\n+ * @author Ram Chidambaram\n+ * @author Michael A. Smith\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Steve Phelps\n+ */\n+public class PriorityBuffer<E> extends AbstractCollection<E> implements Buffer<E>, Serializable {\n+\n+    /** Serialization lock. */\n+    private static final long serialVersionUID = 6891186490470027896L;\n+\n+    /**\n+     * The default capacity for the buffer.\n+     */\n+    private static final int DEFAULT_CAPACITY = 13;\n+    \n+    /**\n+     * The elements in this buffer.\n+     */\n+    protected E[] elements;\n+\n+    /**\n+     * The number of elements currently in this buffer.\n+     */\n+    protected int size;\n+\n+    /**\n+     * If true, the first element as determined by the sort order will \n+     * be returned.  If false, the last element as determined by the\n+     * sort order will be returned.\n+     */\n+    protected boolean ascendingOrder;\n+\n+    /**\n+     * The comparator used to order the elements\n+     */\n+    protected Comparator<? super E> comparator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order by the\n+     * natural order of the objects added.\n+     */\n+    public PriorityBuffer() {\n+        this(DEFAULT_CAPACITY, true, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order using the\n+     * specified comparator.\n+     * \n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     */\n+    public PriorityBuffer(Comparator<? super E> comparator) {\n+        this(DEFAULT_CAPACITY, true, comparator);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer specifying the sort order and using the\n+     * natural order of the objects added.\n+     *\n+     * @param ascendingOrder  if <code>true</code> the heap is created as a \n+     * minimum heap; otherwise, the heap is created as a maximum heap\n+     */\n+    public PriorityBuffer(boolean ascendingOrder) {\n+        this(DEFAULT_CAPACITY, ascendingOrder, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer specifying the sort order and comparator.\n+     *\n+     * @param ascendingOrder  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     */\n+    public PriorityBuffer(boolean ascendingOrder, Comparator<? super E> comparator) {\n+        this(DEFAULT_CAPACITY, ascendingOrder, comparator);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order by the\n+     * natural order of the objects added, specifying an initial capacity.\n+     *  \n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @throws IllegalArgumentException if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public PriorityBuffer(int capacity) {\n+        this(capacity, true, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order using the\n+     * specified comparator and initial capacity.\n+     *\n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     * @throws IllegalArgumentException if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public PriorityBuffer(int capacity, Comparator<? super E> comparator) {\n+        this(capacity, true, comparator);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that specifying initial capacity and\n+     * sort order, using the natural order of the objects added.\n+     *\n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @param ascendingOrder if <code>true</code> the heap is created as a \n+     *  minimum heap; otherwise, the heap is created as a maximum heap.\n+     * @throws IllegalArgumentException if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    public PriorityBuffer(int capacity, boolean ascendingOrder) {\n+        this(capacity, ascendingOrder, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that specifying initial capacity,\n+     * sort order and comparator.\n+     *\n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @param ascendingOrder  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     * @throws IllegalArgumentException if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public PriorityBuffer(int capacity, boolean ascendingOrder, Comparator<? super E> comparator) {\n+        super();\n+        if (capacity <= 0) {\n+            throw new IllegalArgumentException(\"invalid capacity\");\n+        }\n+        this.ascendingOrder = ascendingOrder;\n+\n+        //+1 as 0 is noop\n+        this.elements = (E[]) new Object[capacity + 1];\n+        this.comparator = (Comparator<? super E>) (comparator == null ? ComparableComparator.INSTANCE : comparator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the heap is ascending or descending order.\n+     * \n+     * @return true if ascending order (a min heap)\n+     */\n+    public boolean isAscendingOrder() {\n+        return ascendingOrder;\n+    }\n+    \n+    /**\n+     * Gets the comparator being used for this buffer, null is natural order.\n+     * \n+     * @return the comparator in use, null is natural order\n+     */\n+    public Comparator<? super E> comparator() {\n+        return comparator;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements in this buffer.\n+     *\n+     * @return the number of elements in this buffer\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Clears all elements from the buffer.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void clear() {\n+        elements = (E[]) new Object[elements.length]; // for gc\n+        size = 0;\n+    }\n+\n+    /**\n+     * Adds an element to the buffer.\n+     * <p>\n+     * The element added will be sorted according to the comparator in use.\n+     *\n+     * @param element  the element to be added\n+     * @return true always\n+     */\n+    @Override\n+    public boolean add(E element) {\n+        if (isAtCapacity()) {\n+            grow();\n+        }\n+        // percolate element to its place in tree\n+        if (ascendingOrder) {\n+            percolateUpMinHeap(element);\n+        } else {\n+            percolateUpMaxHeap(element);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the next element to be removed without actually removing it (peek).\n+     *\n+     * @return the next element\n+     * @throws BufferUnderflowException if the buffer is empty\n+     */\n+    public E get() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException();\n+        }\n+        return elements[1];\n+    }\n+\n+    /**\n+     * Gets and removes the next element (pop).\n+     *\n+     * @return the next element\n+     * @throws BufferUnderflowException if the buffer is empty\n+     */\n+    public E remove() {\n+        final E result = get();\n+        elements[1] = elements[size--];\n+\n+        // set the unused element to 'null' so that the garbage collector\n+        // can free the object if not used anywhere else.(remove reference)\n+        elements[size + 1] = null;\n+\n+        if (size != 0) {\n+            // percolate top element to it's place in tree\n+            if (ascendingOrder) {\n+                percolateDownMinHeap(1);\n+            } else {\n+                percolateDownMaxHeap(1);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests if the buffer is at capacity.\n+     *\n+     * @return <code>true</code> if buffer is full; <code>false</code> otherwise.\n+     */\n+    protected boolean isAtCapacity() {\n+        //+1 as element 0 is noop\n+        return elements.length == size + 1;\n+    }\n+\n+    \n+    /**\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param index the index for the element\n+     */\n+    protected void percolateDownMinHeap(final int index) {\n+        final E element = elements[index];\n+        int hole = index;\n+\n+        while ((hole * 2) <= size) {\n+            int child = hole * 2;\n+\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != size && compare(elements[child + 1], elements[child]) < 0) {\n+                child++;\n+            }\n+\n+            // if we found resting place of bubble then terminate search\n+            if (compare(elements[child], element) >= 0) {\n+                break;\n+            }\n+\n+            elements[hole] = elements[child];\n+            hole = child;\n+        }\n+\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a maximum heap.\n+     *\n+     * @param index the index of the element\n+     */\n+    protected void percolateDownMaxHeap(final int index) {\n+        final E element = elements[index];\n+        int hole = index;\n+\n+        while ((hole * 2) <= size) {\n+            int child = hole * 2;\n+\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != size && compare(elements[child + 1], elements[child]) > 0) {\n+                child++;\n+            }\n+\n+            // if we found resting place of bubble then terminate search\n+            if (compare(elements[child], element) <= 0) {\n+                break;\n+            }\n+\n+            elements[hole] = elements[child];\n+            hole = child;\n+        }\n+\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element up heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param index the index of the element to be percolated up\n+     */\n+    protected void percolateUpMinHeap(final int index) {\n+        int hole = index;\n+        E element = elements[hole];\n+        while (hole > 1 && compare(element, elements[hole / 2]) < 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            elements[hole] = elements[next];\n+            hole = next;\n+        }\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMinHeap(final E element) {\n+        elements[++size] = element;\n+        percolateUpMinHeap(size);\n+    }\n+\n+    /**\n+     * Percolates element up heap from from the position given by the index.\n+     * <p>\n+     * Assume it is a maximum heap.\n+     *\n+     * @param index the index of the element to be percolated up\n+     */\n+    protected void percolateUpMaxHeap(final int index) {\n+        int hole = index;\n+        E element = elements[hole];\n+\n+        while (hole > 1 && compare(element, elements[hole / 2]) > 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            elements[hole] = elements[next];\n+            hole = next;\n+        }\n+\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMaxHeap(final E element) {\n+        elements[++size] = element;\n+        percolateUpMaxHeap(size);\n+    }\n+\n+    /**\n+     * Compares two objects using the comparator if specified, or the\n+     * natural order otherwise.\n+     * \n+     * @param a  the first object\n+     * @param b  the second object\n+     * @return -ve if a less than b, 0 if they are equal, +ve if a greater than b\n+     */\n+    protected int compare(E a, E b) {\n+        return comparator.compare(a, b);\n+    }\n+\n+    /**\n+     * Increases the size of the heap to support additional elements\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void grow() {\n+        final E[] array = (E[]) new Object[elements.length * 2];\n+        System.arraycopy(elements, 0, array, 0, elements.length);\n+        elements = array;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an iterator over this heap's elements.\n+     *\n+     * @return an iterator over this heap's elements\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n+\n+            private int index = 1;\n+            private int lastReturnedIndex = -1;\n+\n+            public boolean hasNext() {\n+                return index <= size;\n+            }\n+\n+            public E next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n+                lastReturnedIndex = index;\n+                index++;\n+                return elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n+                elements[ lastReturnedIndex ] = elements[ size ];\n+                elements[ size ] = null;\n+                size--;  \n+                if( size != 0 && lastReturnedIndex <= size) {\n+                    int compareToParent = 0;\n+                    if (lastReturnedIndex > 1) {\n+                        compareToParent = compare(elements[lastReturnedIndex], \n+                            elements[lastReturnedIndex / 2]);  \n+                    }\n+                    if (ascendingOrder) {\n+                        if (lastReturnedIndex > 1 && compareToParent < 0) {\n+                            percolateUpMinHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMinHeap(lastReturnedIndex);\n+                        }\n+                    } else {  // max heap\n+                        if (lastReturnedIndex > 1 && compareToParent > 0) {\n+                            percolateUpMaxHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMaxHeap(lastReturnedIndex);\n+                        }\n+                    }          \n+                }\n+                index--;\n+                lastReturnedIndex = -1; \n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Returns a string representation of this heap.  The returned string\n+     * is similar to those produced by standard JDK collections.\n+     *\n+     * @return a string representation of this heap\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+\n+        sb.append(\"[ \");\n+\n+        for (int i = 1; i < size + 1; i++) {\n+            if (i != 1) {\n+                sb.append(\", \");\n+            }\n+            sb.append(elements[i]);\n+        }\n+\n+        sb.append(\" ]\");\n+\n+        return sb.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/SynchronizedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated buffer.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @param <E> the type of the elements in the buffer\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedBuffer<E>\n+        extends SynchronizedCollection<E>\n+        implements Buffer<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -6859936183953626253L;\n+\n+    /**\n+     * Factory method to create a synchronized buffer.\n+     * \n+     * @param <T> the type of the elements in the buffer\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @return a new synchronized Buffer\n+     * @throws IllegalArgumentException if buffer is null\n+     */\n+    public static <T> Buffer<T> synchronizedBuffer(Buffer<T> buffer) {\n+        return new SynchronizedBuffer<T>(buffer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    protected SynchronizedBuffer(Buffer<E> buffer) {\n+        super(buffer);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param lock  the lock object to use, must not be null\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    protected SynchronizedBuffer(Buffer<E> buffer, Object lock) {\n+        super(buffer, lock);\n+    }\n+\n+    /**\n+     * Gets the buffer being decorated.\n+     * \n+     * @return the decorated buffer\n+     */\n+    @Override\n+    protected Buffer<E> decorated() {\n+        return (Buffer<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E get() {\n+        synchronized (lock) {\n+            return decorated().get();\n+        }\n+    }\n+\n+    public E remove() {\n+        synchronized (lock) {\n+            return decorated().remove();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/TransformedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedBuffer<E> extends TransformedCollection<E> implements Buffer<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -7901091318986132033L;\n+\n+    /**\n+     * Factory method to create a transforming buffer.\n+     * <p>\n+     * If there are any elements already in the buffer being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedBuffer(Buffer, Transformer)}.\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Buffer\n+     * @throws IllegalArgumentException if buffer or transformer is null\n+     */\n+    public static <E> Buffer<E> transformingBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedBuffer<E>(buffer, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming buffer that will transform\n+     * existing contents of the specified buffer.\n+     * <p>\n+     * If there are any elements already in the buffer being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingBuffer(Buffer, Transformer)}.\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Buffer\n+     * @throws IllegalArgumentException if buffer or transformer is null\n+     * @since Commons Collections 3.3\n+     */\n+    public static <E> Buffer<E> transformedBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+        TransformedBuffer<E> decorated = new TransformedBuffer<E>(buffer, transformer); // throws IAE if buffer or transformer is null\n+        if (buffer.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // buffer is type <E>\n+            E[] values = (E[]) buffer.toArray();\n+            buffer.clear();\n+            for(int i=0; i<values.length; i++) {\n+                decorated.decorated().add(transformer.transform(values[i]));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the buffer being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if buffer or transformer is null\n+     */\n+    protected TransformedBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+        super(buffer, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated buffer.\n+     * \n+     * @return the decorated buffer\n+     */\n+    protected Buffer<E> getBuffer() {\n+        return (Buffer<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E get() {\n+        return getBuffer().get();\n+    }\n+\n+    public E remove() {\n+        return getBuffer().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+/**\n+ * UnboundedFifoBuffer is a very efficient implementation of\n+ * <code>Buffer</code> that can grow to any size.\n+ * According to performance testing, it exhibits a constant access time, but it\n+ * also outperforms ArrayList when used for the same purpose.\n+ * <p>\n+ * The removal order of an <code>UnboundedFifoBuffer</code> is based on the insertion\n+ * order; elements are removed in the same order in which they were added.\n+ * The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #remove()} and {@link #get()} operations perform in constant time.\n+ * The {@link #add(Object)} operation performs in amortized constant time.  All\n+ * other operations perform in linear time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <code>UnboundedFifoBuffer</code>:\n+ * <pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new UnboundedFifoBuffer());\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v2.1)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Avalon\n+ * @author Federico Barbieri\n+ * @author Berin Loritsch\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Andreas Schlosser\n+ * @author Thomas Knych\n+ * @author Jordan Krey\n+ */\n+public class UnboundedFifoBuffer<E> extends AbstractCollection<E> implements Buffer<E>, Serializable {\n+    // invariant: buffer.length > size()\n+    //   ie.buffer always has at least one empty entry\n+\n+    /** Serialization vesrion */\n+    private static final long serialVersionUID = -3482960336579541419L;\n+\n+    /** The array of objects in the buffer. */\n+    protected transient E[] buffer;\n+\n+    /** The current head index. */\n+    protected transient int head;\n+\n+    /** The current tail index. */\n+    protected transient int tail;\n+\n+    /**\n+     * Constructs an UnboundedFifoBuffer with the default number of elements.\n+     * It is exactly the same as performing the following:\n+     *\n+     * <pre>\n+     *   new UnboundedFifoBuffer(32);\n+     * </pre>\n+     */\n+    public UnboundedFifoBuffer() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructs an UnboundedFifoBuffer with the specified number of elements.\n+     * The integer must be a positive integer.\n+     *\n+     * @param initialSize  the initial size of the buffer\n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public UnboundedFifoBuffer(int initialSize) {\n+        if (initialSize <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        buffer = (E[]) new Object[initialSize + 1];\n+        head = 0;\n+        tail = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the buffer out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(size());\n+        out.writeInt(buffer.length);\n+        for (Iterator<E> it = iterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+        }\n+    }\n+\n+    /**\n+     * Read the buffer in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        int size = in.readInt();\n+        int length = in.readInt();\n+        buffer = (E[]) new Object[length];\n+        for (int i = 0; i < size; i++) {\n+            buffer[i] = (E) in.readObject();\n+        }\n+        head = 0;\n+        tail = size;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements stored in the buffer.\n+     *\n+     * @return this buffer's size\n+     */\n+    @Override\n+    public int size() {\n+        int size = 0;\n+\n+        if (tail < head) {\n+            size = buffer.length - head + tail;\n+        } else {\n+            size = tail - head;\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if this buffer is empty; false otherwise.\n+     *\n+     * @return true if this buffer is empty\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    /**\n+     * Adds the given element to this buffer.\n+     *\n+     * @param obj  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean add(final E obj) {\n+        if (obj == null) {\n+            throw new NullPointerException(\"Attempted to add null object to buffer\");\n+        }\n+\n+        if (size() + 1 >= buffer.length) {\n+            // copy contents to a new buffer array\n+            E[] tmp = (E[]) new Object[((buffer.length - 1) * 2) + 1];\n+            int j = 0;\n+            // move head to element zero in the new array\n+            for (int i = head; i != tail;) {\n+                tmp[j] = buffer[i];\n+                buffer[i] = null;\n+\n+                j++;\n+                i = increment(i);\n+            }\n+            buffer = tmp;\n+            head = 0;\n+            tail = j;\n+        }\n+\n+        buffer[tail] = obj;\n+        tail = increment(tail);\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the next object in the buffer.\n+     *\n+     * @return the next object in the buffer\n+     * @throws BufferUnderflowException  if this buffer is empty\n+     */\n+    public E get() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        return buffer[head];\n+    }\n+\n+    /**\n+     * Removes the next object from the buffer\n+     *\n+     * @return the removed object\n+     * @throws BufferUnderflowException  if this buffer is empty\n+     */\n+    public E remove() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        E element = buffer[head];\n+        if (element != null) {\n+            buffer[head] = null;\n+            head = increment(head);\n+        }\n+        return element;\n+    }\n+\n+    /**\n+     * Increments the internal index.\n+     *\n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n+    private int increment(int index) {\n+        index++;\n+        if (index >= buffer.length) {\n+            index = 0;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Decrements the internal index.\n+     *\n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) {\n+            index = buffer.length - 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Returns an iterator over this buffer's elements.\n+     *\n+     * @return an iterator over this buffer's elements\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n+\n+            private int index = head;\n+            private int lastReturnedIndex = -1;\n+\n+            public boolean hasNext() {\n+                return index != tail;\n+\n+            }\n+\n+            public E next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return buffer[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == head) {\n+                    UnboundedFifoBuffer.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                // Other elements require us to shift the subsequent elements\n+                int i = increment(lastReturnedIndex);\n+                while (i != tail) {\n+                    buffer[decrement(i)] = buffer[i];\n+                    i = increment(i);\n+                }\n+\n+                lastReturnedIndex = -1;\n+                tail = decrement(tail);\n+                buffer[tail] = null;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/buffer/UnmodifiableBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableBuffer<E>\n+        extends AbstractBufferDecorator<E>\n+        implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1832948656215393357L;\n+\n+    /**\n+     * Factory method to create an unmodifiable buffer.\n+     * <p>\n+     * If the buffer passed in is already unmodifiable, it is returned.\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @return an unmodifiable Buffer\n+     * @throws IllegalArgumentException if buffer is null\n+     */\n+    public static <E> Buffer<E> unmodifiableBuffer(Buffer<E> buffer) {\n+        if (buffer instanceof Unmodifiable) {\n+            return buffer;\n+        }\n+        return new UnmodifiableBuffer<E>(buffer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param buffer  the buffer to decorate, must not be null\n+     * @throws IllegalArgumentException if buffer is null\n+     */\n+    private UnmodifiableBuffer(Buffer<E> buffer) {\n+        super(buffer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public E remove() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/AbstractCollectionDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Decorates another <code>Collection</code> to provide additional behaviour.\n+ * <p>\n+ * Each method call made on this <code>Collection</code> is forwarded to the\n+ * decorated <code>Collection</code>. This class is used as a framework on which\n+ * to build to extensions such as synchronized and unmodifiable behaviour. The\n+ * main advantage of decoration is that one decorator can wrap any implementation\n+ * of <code>Collection</code>, whereas sub-classing requires a new class to be\n+ * written for each implementation.\n+ * <p>\n+ * This implementation does not perform any special processing with\n+ * {@link #iterator()}. Instead it simply returns the value from the \n+ * wrapped collection. This may be undesirable, for example if you are trying\n+ * to write an unmodifiable implementation it might provide a loophole.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public abstract class AbstractCollectionDecorator<E>\n+        implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6249888059822088500L;\n+\n+    /** The collection being decorated */\n+    protected Collection<E> collection;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractCollectionDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractCollectionDecorator(Collection<E> coll) {\n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.collection = coll;\n+    }\n+\n+    /**\n+     * Gets the collection being decorated.\n+     * All access to the decorated collection goes via this method.\n+     * \n+     * @return the decorated collection\n+     */\n+    protected Collection<E> decorated() {\n+        return collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean add(E object) {\n+        return decorated().add(object);\n+    }\n+\n+    public boolean addAll(Collection<? extends E> coll) {\n+        return decorated().addAll(coll);\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public boolean contains(Object object) {\n+        return decorated().contains(object);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return decorated().iterator();\n+    }\n+\n+    public boolean remove(Object object) {\n+        return decorated().remove(object);\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Object[] toArray() {\n+        return decorated().toArray();\n+    }\n+\n+    public <T> T[] toArray(T[] object) {\n+        return decorated().toArray(object);\n+    }\n+\n+    public boolean containsAll(Collection<?> coll) {\n+        return decorated().containsAll(coll);\n+    }\n+\n+    public boolean removeAll(Collection<?> coll) {\n+        return decorated().removeAll(coll);\n+    }\n+\n+    public boolean retainAll(Collection<?> coll) {\n+        return decorated().retainAll(coll);\n+    }\n+\n+    @Override\n+    public boolean equals(Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/AbstractUntypedCollectionDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+/**\n+ * Decorates another <code>Collection</code> to provide additional behaviour\n+ * without guaranteeing that the provided <code>Collection</code> type is the\n+ * same as that of the decorated <code>Collection</code>.\n+ * <p>\n+ * Each untyped method call made on this <code>Collection</code> is forwarded to the\n+ * decorated <code>Collection</code>. This class is used as a framework on which\n+ * to build to extensions such as synchronized and unmodifiable behaviour. The\n+ * main advantage of decoration is that one decorator can wrap any\n+ * implementation of <code>Collection</code>, whereas sub-classing requires a\n+ * new class to be written for each implementation.\n+ * <p>\n+ * This implementation does not perform any special processing with\n+ * {@link #iterator()}. Instead it simply returns the value from the wrapped\n+ * collection. This may be undesirable, for example if you are trying to write\n+ * an unmodifiable implementation it might provide a loophole.\n+ *\n+ * @param <D> the type of the elements in the decorated collection\n+ * @param <E> the element type of the Collection implementation\n+ * @since Commons Collections 5\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ * @author Matt Benson\n+ */\n+public abstract class AbstractUntypedCollectionDecorator<E, D> implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8016691444524268856L;\n+\n+    /** The collection being decorated */\n+    protected Collection<D> collection;\n+\n+    /**\n+     * Create a new AbstractUntypedCollectionDecorator.\n+     */\n+    public AbstractUntypedCollectionDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets the collection being decorated. All access to the decorated\n+     * collection goes via this method.\n+     * \n+     * @return the decorated collection\n+     */\n+    protected Collection<D> decorated() {\n+        return collection;\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public boolean contains(Object object) {\n+        return decorated().contains(object);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public boolean remove(Object object) {\n+        return decorated().remove(object);\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Object[] toArray() {\n+        return decorated().toArray();\n+    }\n+\n+    public <T> T[] toArray(T[] object) {\n+        return decorated().toArray(object);\n+    }\n+\n+    public boolean containsAll(Collection<?> coll) {\n+        return decorated().containsAll(coll);\n+    }\n+\n+    public boolean removeAll(Collection<?> coll) {\n+        return decorated().removeAll(coll);\n+    }\n+\n+    public boolean retainAll(Collection<?> coll) {\n+        return decorated().retainAll(coll);\n+    }\n+\n+    @Override\n+    public boolean equals(Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/CompositeCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+import org.apache.commons.collections.list.UnmodifiableList;\n+\n+/**\n+ * Decorates a collection of other collections to provide a single unified view.\n+ * <p>\n+ * Changes made to this collection will actually be made on the decorated collection.\n+ * Add and remove operations require the use of a pluggable strategy. If no\n+ * strategy is provided then add and remove are unsupported.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Brian McCallister\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ */\n+public class CompositeCollection<E> implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8417515734108306801L;\n+\n+    /** CollectionMutator to handle changes to the collection */\n+    protected CollectionMutator<E> mutator;\n+\n+    /** Collections in the composite */\n+    protected List<Collection<E>> all = new ArrayList<Collection<E>>();\n+\n+    /**\n+     * Create an empty CompositeCollection.\n+     */\n+    public CompositeCollection() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a Composite Collection with one collection.\n+     *\n+     * @param compositeCollection  the Collection to be appended to the composite\n+     */\n+    public CompositeCollection(Collection<E> compositeCollection) {\n+        super();\n+        addComposited(compositeCollection);\n+    }\n+\n+    /**\n+     * Create a Composite Collection with two collections.\n+     *\n+     * @param compositeCollection1  the Collection to be appended to the composite\n+     * @param compositeCollection2  the Collection to be appended to the composite\n+     */\n+    public CompositeCollection(Collection<E> compositeCollection1, Collection<E> compositeCollection2) {\n+        super();\n+        addComposited(compositeCollection1, compositeCollection2);\n+    }\n+\n+    /**\n+     * Create a Composite Collection with an array of collections.\n+     *\n+     * @param compositeCollections  the collections to composite\n+     */\n+    public CompositeCollection(Collection<E>[] compositeCollections) {\n+        super();\n+        addComposited(compositeCollections);\n+    }\n+\n+//    /**\n+//     * Create a Composite Collection extracting the collections from an iterable.\n+//     *\n+//     * @param compositeCollections  the collections to composite\n+//     */\n+//    public CompositeCollection(Iterable<Collection<E>> compositeCollections) {\n+//        super();\n+//        addComposited(compositeCollections);\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of this composite collection.\n+     * <p>\n+     * This implementation calls <code>size()</code> on each collection.\n+     *\n+     * @return total number of elements in all contained containers\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (Collection<E> item : all) {\n+            size += item.size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether this composite collection is empty.\n+     * <p>\n+     * This implementation calls <code>isEmpty()</code> on each collection.\n+     *\n+     * @return true if all of the contained collections are empty\n+     */\n+    public boolean isEmpty() {\n+        for (Collection<? extends E> item : all) {\n+            if (item.isEmpty() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this composite collection contains the object.\n+     * <p>\n+     * This implementation calls <code>contains()</code> on each collection.\n+     *\n+     * @param obj  the object to search for\n+     * @return true if obj is contained in any of the contained collections\n+     */\n+    public boolean contains(Object obj) {\n+        for (Collection<? extends E> item : all) {\n+            if (item.contains(obj)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets an iterator over all the collections in this composite.\n+     * <p>\n+     * This implementation uses an <code>IteratorChain</code>.\n+     *\n+     * @return an <code>IteratorChain</code> instance which supports\n+     *  <code>remove()</code>. Iteration occurs over contained collections in\n+     *  the order they were added, but this behavior should not be relied upon.\n+     * @see IteratorChain\n+     */\n+    public Iterator<E> iterator() {\n+        if (all.isEmpty()) {\n+            return EmptyIterator.<E>emptyIterator();\n+        }\n+        IteratorChain<E> chain = new IteratorChain<E>();\n+        for (Collection<? extends E> item : all) {\n+            chain.addIterator(item.iterator());\n+        }\n+        return chain;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this composite.\n+     *\n+     * @return an object array of all the elements in the collection\n+     */\n+    public Object[] toArray() {\n+        final Object[] result = new Object[size()];\n+        int i = 0;\n+        for (Iterator<E> it = iterator(); it.hasNext(); i++) {\n+            result[i] = it.next();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an object array, populating the supplied array if possible.\n+     * See <code>Collection</code> interface for full details.\n+     *\n+     * @param array  the array to use, populating if possible\n+     * @return an array of all the elements in the collection\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n+        int size = size();\n+        Object[] result = null;\n+        if (array.length >= size) {\n+            result = array;\n+        } else {\n+            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n+        }\n+\n+        int offset = 0;\n+        for (Collection<? extends E> item : all) {\n+            for (E e : item) {\n+                result[offset++] = e;\n+            }\n+        }\n+        if (result.length > size) {\n+            result[size] = null;\n+        }\n+        return (T[]) result;\n+    }\n+\n+    /**\n+     * Adds an object to the collection, throwing UnsupportedOperationException\n+     * unless a CollectionMutator strategy is specified.\n+     *\n+     * @param obj  the object to add\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n+     * @throws UnsupportedOperationException if add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean add(E obj) {\n+        if (mutator == null) {\n+           throw new UnsupportedOperationException(\n+               \"add() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.add(this, all, obj);\n+    }\n+\n+    /**\n+     * Removes an object from the collection, throwing UnsupportedOperationException\n+     * unless a CollectionMutator strategy is specified.\n+     *\n+     * @param obj  the object being removed\n+     * @return true if the collection is changed\n+     * @throws UnsupportedOperationException if removed is unsupported\n+     * @throws ClassCastException if the object cannot be removed due to its type\n+     * @throws NullPointerException if the object cannot be removed because its null\n+     * @throws IllegalArgumentException if the object cannot be removed\n+     */\n+    public boolean remove(Object obj) {\n+        if (mutator == null) {\n+            throw new UnsupportedOperationException(\n+                \"remove() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.remove(this, all, obj);\n+    }\n+\n+    /**\n+     * Checks whether this composite contains all the elements in the specified collection.\n+     * <p>\n+     * This implementation calls <code>contains()</code> for each element in the\n+     * specified collection.\n+     *\n+     * @param coll  the collection to check for\n+     * @return true if all elements contained\n+     */\n+    public boolean containsAll(Collection<?> coll) {\n+        for (Object item : coll) {\n+            if (contains(item) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Adds a collection of elements to this collection, throwing\n+     * UnsupportedOperationException unless a CollectionMutator strategy is specified.\n+     *\n+     * @param coll  the collection to add\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n+     * @throws UnsupportedOperationException if add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean addAll(Collection<? extends E> coll) {\n+        if (mutator == null) {\n+            throw new UnsupportedOperationException(\n+                \"addAll() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.addAll(this, all, coll);\n+    }\n+\n+    /**\n+     * Removes the elements in the specified collection from this composite collection.\n+     * <p>\n+     * This implementation calls <code>removeAll</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if removeAll is unsupported\n+     */\n+    public boolean removeAll(Collection<?> coll) {\n+        if (coll.size() == 0) {\n+            return false;\n+        }\n+        boolean changed = false;\n+        for (Collection<? extends E> item : all) {\n+            changed |= item.removeAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Retains all the elements in the specified collection in this composite collection,\n+     * removing all others.\n+     * <p>\n+     * This implementation calls <code>retainAll()</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if retainAll is unsupported\n+     */\n+    public boolean retainAll(final Collection<?> coll) {\n+        boolean changed = false;\n+        for (Collection<? extends E> item : all) {\n+            changed |= item.retainAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Removes all of the elements from this collection .\n+     * <p>\n+     * This implementation calls <code>clear()</code> on each collection.\n+     *\n+     * @throws UnsupportedOperationException if clear is unsupported\n+     */\n+    public void clear() {\n+        for (Collection<? extends E> coll : all) {\n+            coll.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify a CollectionMutator strategy instance to handle changes.\n+     *\n+     * @param mutator  the mutator to use\n+     */\n+    public void setMutator(CollectionMutator<E> mutator) {\n+        this.mutator = mutator;\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollection  the Collection to be appended to the composite\n+     */\n+    public void addComposited(Collection<E> compositeCollection) {\n+        all.add(compositeCollection);\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollection1  the Collection to be appended to the composite\n+     * @param compositeCollection2  the Collection to be appended to the composite\n+     */\n+    public void addComposited(Collection<E> compositeCollection1, Collection<E> compositeCollection2) {\n+        all.add(compositeCollection1);\n+        all.add(compositeCollection2);\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollections  the Collections to be appended to the composite\n+     */\n+    public void addComposited(Collection<E>[] compositeCollections) {\n+        all.addAll(Arrays.asList(compositeCollections));\n+    }\n+\n+//    /**\n+//     * Add these Collections to the list of collections in this composite\n+//     *\n+//     * @param compositeCollections  the Collections to be appended to the composite\n+//     */\n+//    public void addComposited(Iterable<Collection<E>> compositeCollections) {\n+//        for (Collection<E> item : compositeCollections) {\n+//            all.add(item);\n+//        }\n+//    }\n+\n+    /**\n+     * Removes a collection from the those being decorated in this composite.\n+     *\n+     * @param coll  collection to be removed\n+     */\n+    public void removeComposited(Collection<E> coll) {\n+        all.remove(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new collection containing all of the elements\n+     *\n+     * @return A new ArrayList containing all of the elements in this composite.\n+     *         The new collection is <i>not</i> backed by this composite.\n+     */\n+    public Collection<E> toCollection() {\n+        return new ArrayList<E>(this);\n+    }\n+\n+    /**\n+     * Gets the collections being decorated.\n+     *\n+     * @return Unmodifiable list of all collections in this composite.\n+     */\n+    public List<? extends Collection<E>> getCollections() {\n+        return UnmodifiableList.unmodifiableList(all);\n+    }\n+\n+    /**\n+     * Get the collection mutator to be used for this CompositeCollection.\n+     * @return CollectionMutator<E>\n+     */\n+    protected CollectionMutator<E> getMutator() {\n+        return mutator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Pluggable strategy to handle changes to the composite.\n+     *\n+     * @param <E> the element being held in the collection\n+     */\n+    public interface CollectionMutator<E> extends Serializable {\n+\n+        /**\n+         * Called when an object is to be added to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param obj  the object being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean add(CompositeCollection<E> composite, List<Collection<E>> collections, E obj);\n+\n+        /**\n+         * Called when a collection is to be added to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param coll  the collection being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean addAll(CompositeCollection<E> composite, List<Collection<E>> collections, Collection<? extends E> coll);\n+\n+        /**\n+         * Called when an object is to be removed to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param obj  the object being removed\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if removed is unsupported\n+         * @throws ClassCastException if the object cannot be removed due to its type\n+         * @throws NullPointerException if the object cannot be removed because its null\n+         * @throws IllegalArgumentException if the object cannot be removed\n+         */\n+        public boolean remove(CompositeCollection<E> composite, List<Collection<E>> collections, Object obj);\n+\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/PredicatedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Decorates another <code>Collection</code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This collection exists to provide validation for the decorated collection.\n+ * It is normally created to decorate an empty collection.\n+ * If an object cannot be added to the collection, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the collection.\n+ * <pre>Collection coll = PredicatedCollection.decorate(new ArrayList(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5259182142076705162L;\n+\n+    /** The predicate to use */\n+    protected final Predicate<? super E> predicate;\n+\n+    /**\n+     * Factory method to create a predicated (validating) collection.\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are validated.\n+     * \n+     * @param <T> the type of the elements in the collection\n+     * @param coll  the collection to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated collection\n+     * @throws IllegalArgumentException if collection or predicate is null\n+     * @throws IllegalArgumentException if the collection contains invalid elements\n+     */\n+    public static <T> Collection<T> predicatedCollection(Collection<T> coll, Predicate<? super T> predicate) {\n+        return new PredicatedCollection<T>(coll, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are validated.\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if collection or predicate is null\n+     * @throws IllegalArgumentException if the collection contains invalid elements\n+     */\n+    protected PredicatedCollection(Collection<E> coll, Predicate<? super E> predicate) {\n+        super(coll);\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        this.predicate = predicate;\n+        for (E item : coll) {\n+            validate(item);\n+        }\n+    }\n+\n+    /**\n+     * Validates the object being added to ensure it matches the predicate.\n+     * <p>\n+     * The predicate itself should not throw an exception, but return false to\n+     * indicate that the object cannot be added.\n+     * \n+     * @param object  the object being added\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    protected void validate(E object) {\n+        if (predicate.evaluate(object) == false) {\n+            throw new IllegalArgumentException(\"Cannot add Object '\" + object + \"' - Predicate '\" + predicate + \"' rejected it\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to validate the object being added to ensure it matches\n+     * the predicate.\n+     * \n+     * @param object  the object being added\n+     * @return the result of adding to the underlying collection\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    @Override\n+    public boolean add(E object) {\n+        validate(object);\n+        return decorated().add(object);\n+    }\n+\n+    /**\n+     * Override to validate the objects being added to ensure they match\n+     * the predicate. If any one fails, no update is made to the underlying\n+     * collection.\n+     * \n+     * @param coll  the collection being added\n+     * @return the result of adding to the underlying collection\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        for (E item : coll) {\n+            validate(item);\n+        }\n+        return decorated().addAll(coll);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/SynchronizedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Decorates another <code>Collection</code> to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Iterators must be manually synchronized:\n+ * <pre>\n+ * synchronized (coll) {\n+ *   Iterator it = coll.iterator();\n+ *   // do stuff with iterator\n+ * }\n+ * </pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedCollection<E> implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2412805092710877986L;\n+\n+    /** The collection to decorate */\n+    protected final Collection<E> collection;\n+    /** The object to lock on, needed for List/SortedSet views */\n+    protected final Object lock;\n+\n+    /**\n+     * Factory method to create a synchronized collection.\n+     * \n+     * @param <T> the type of the elements in the collection\n+     * @param coll  the collection to decorate, must not be null\n+     * @return a new synchronized collection\n+     * @throws IllegalArgumentException if collection is null\n+     */\n+    public static <T> Collection<T> synchronizedCollection(Collection<T> coll) {\n+        return new SynchronizedCollection<T>(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param collection  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected SynchronizedCollection(Collection<E> collection) {\n+        if (collection == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.collection = collection;\n+        this.lock = this;\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param collection  the collection to decorate, must not be null\n+     * @param lock  the lock object to use, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected SynchronizedCollection(Collection<E> collection, Object lock) {\n+        if (collection == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.collection = collection;\n+        this.lock = lock;\n+    }\n+\n+    /**\n+     * Gets the collection being decorated.\n+     * \n+     * @return the decorated collection\n+     */\n+    protected Collection<E> decorated() {\n+        return collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean add(E object) {\n+        synchronized (lock) {\n+            return decorated().add(object);\n+        }\n+    }\n+\n+    public boolean addAll(Collection<? extends E> coll) {\n+        synchronized (lock) {\n+            return decorated().addAll(coll);\n+        }\n+    }\n+\n+    public void clear() {\n+        synchronized (lock) {\n+            decorated().clear();\n+        }\n+    }\n+\n+    public boolean contains(Object object) {\n+        synchronized (lock) {\n+            return decorated().contains(object);\n+        }\n+    }\n+\n+    public boolean containsAll(Collection<?> coll) {\n+        synchronized (lock) {\n+            return decorated().containsAll(coll);\n+        }\n+    }\n+\n+    public boolean isEmpty() {\n+        synchronized (lock) {\n+            return decorated().isEmpty();\n+        }\n+    }\n+\n+    /**\n+     * Iterators must be manually synchronized.\n+     * <pre>\n+     * synchronized (coll) {\n+     *   Iterator it = coll.iterator();\n+     *   // do stuff with iterator\n+     * }\n+     * \n+     * @return an iterator that must be manually synchronized on the collection\n+     */\n+    public Iterator<E> iterator() {\n+        return decorated().iterator();\n+    }\n+\n+    public Object[] toArray() {\n+        synchronized (lock) {\n+            return decorated().toArray();\n+        }\n+    }\n+\n+    public <T> T[] toArray(T[] object) {\n+        synchronized (lock) {\n+            return decorated().toArray(object);\n+        }\n+    }\n+\n+    public boolean remove(Object object) {\n+        synchronized (lock) {\n+            return decorated().remove(object);\n+        }\n+    }\n+\n+    public boolean removeAll(Collection<?> coll) {\n+        synchronized (lock) {\n+            return decorated().removeAll(coll);\n+        }\n+    }\n+\n+    public boolean retainAll(Collection<?> coll) {\n+        synchronized (lock) {\n+            return decorated().retainAll(coll);\n+        }\n+    }\n+\n+    public int size() {\n+        synchronized (lock) {\n+            return decorated().size();\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object object) {\n+        synchronized (lock) {\n+            if (object == this) {\n+                return true;\n+            }\n+            return decorated().equals(object);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        synchronized (lock) {\n+            return decorated().hashCode();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        synchronized (lock) {\n+            return decorated().toString();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/TransformedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Decorates another <code>Collection</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedCollection<E> extends AbstractCollectionDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8692300188161871514L;\n+\n+    /** The transformer to use */\n+    protected final Transformer<? super E, ? extends E> transformer;\n+\n+    /**\n+     * Factory method to create a transforming collection.\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed collection\n+     * @throws IllegalArgumentException if collection or transformer is null\n+     */\n+    public static <E> Collection<E> transformingCollection(Collection<E> coll, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedCollection<E>(coll, transformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming collection that will transform\n+     * existing contents of the specified collection.\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n+     * \n+     * @param collection  the collection to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Collection\n+     * @throws IllegalArgumentException if collection or transformer is null\n+     * @since Commons Collections 3.3\n+     */\n+    public static <E> Collection<E> transformedCollection(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n+        TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n+        // null collection & transformer are disallowed by the constructor call above \n+        if (collection.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // collection is of type E\n+            E[] values = (E[]) collection.toArray();\n+            collection.clear();\n+            for(int i=0; i<values.length; i++) {\n+                decorated.decorated().add(transformer.transform(values[i]));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if collection or transformer is null\n+     */\n+    protected TransformedCollection(Collection<E> coll, Transformer<? super E, ? extends E> transformer) {\n+        super(coll);\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"Transformer must not be null\");\n+        }\n+        this.transformer = transformer;\n+    }\n+\n+    /**\n+     * Transforms an object.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     * \n+     * @param object  the object to transform\n+     * @return a transformed object\n+     */\n+    protected E transform(E object) {\n+        return transformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a collection.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     * \n+     * @param coll  the collection to transform\n+     * @return a transformed object\n+     */\n+    protected Collection<E> transform(Collection<? extends E> coll) {\n+        List<E> list = new ArrayList<E>(coll.size());\n+        for (E item : coll) {\n+            list.add(transform(item));\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(E object) {\n+        return decorated().add(transform(object));\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        return decorated().addAll(transform(coll));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.BoundedCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+\n+/**\n+ * <code>UnmodifiableBoundedCollection</code> decorates another\n+ * <code>BoundedCollection</code> to ensure it can't be altered.\n+ * <p>\n+ * If a BoundedCollection is first wrapped in some other collection decorator,\n+ * such as synchronized or predicated, the BoundedCollection methods are no\n+ * longer accessible.\n+ * The factory on this class will attempt to retrieve the bounded nature by\n+ * examining the package scope variables.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E>\n+        implements BoundedCollection<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -7112672385450340330L;\n+\n+    /**\n+     * Factory method to create an unmodifiable bounded collection.\n+     *\n+     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n+     * @return a new unmodifiable bounded collection\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(BoundedCollection<E> coll) {\n+        return unmodifiableBoundedCollection(coll);\n+    }\n+\n+    /**\n+     * Factory method to create an unmodifiable bounded collection.\n+     * <p>\n+     * This method is capable of drilling down through up to 1000 other decorators\n+     * to find a suitable BoundedCollection.\n+     *\n+     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n+     * @return a new unmodifiable bounded collection\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"The collection must not be null\");\n+        }\n+\n+        // handle decorators\n+        for (int i = 0; i < 1000; i++) {  // counter to prevent infinite looping\n+            if (coll instanceof BoundedCollection) {\n+                break;  // normal loop exit\n+            }\n+            if (coll instanceof AbstractCollectionDecorator) {\n+                coll = ((AbstractCollectionDecorator<E>) coll).collection;\n+            } else if (coll instanceof SynchronizedCollection) {\n+                coll = ((SynchronizedCollection<E>) coll).collection;\n+            }\n+        }\n+\n+        if (coll instanceof BoundedCollection == false) {\n+            throw new IllegalArgumentException(\"The collection is not a bounded collection\");\n+        }\n+        return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if coll is null\n+     */\n+    private UnmodifiableBoundedCollection(BoundedCollection<E> coll) {\n+        super(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean isFull() {\n+        return decorated().isFull();\n+    }\n+\n+    public int maxSize() {\n+        return decorated().maxSize();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected BoundedCollection<E> decorated() {\n+        return (BoundedCollection<E>) super.decorated();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/UnmodifiableCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>Collection</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableCollection<E>\n+        extends AbstractCollectionDecorator<E>\n+        implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -239892006883819945L;\n+\n+    /**\n+     * Factory method to create an unmodifiable collection.\n+     * <p>\n+     * If the collection passed in is already unmodifiable, it is returned.\n+     * \n+     * @param <T> the type of the elements in the collection\n+     * @param coll  the collection to decorate, must not be null\n+     * @return an unmodifiable collection\n+     * @throws IllegalArgumentException if collection is null\n+     */\n+    public static <T> Collection<T> unmodifiableCollection(Collection<T> coll) {\n+        if (coll instanceof Unmodifiable) {\n+            return coll;\n+        }\n+        return new UnmodifiableCollection<T>(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if collection is null\n+     */\n+    private UnmodifiableCollection(Collection<E> coll) {\n+        super(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/BooleanComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/**\n+ * A {@link Comparator} for {@link Boolean} objects that can sort either\n+ * true or false first.\n+ * <p>\n+ * @see #getTrueFirstComparator()\n+ * @see #getFalseFirstComparator()\n+ * @see #booleanComparator(boolean)\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ */\n+public final class BooleanComparator implements Comparator<Boolean>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 1830042991606340609L;\n+\n+    /** Constant \"true first\" reference. */\n+    private static final BooleanComparator TRUE_FIRST = new BooleanComparator(true);\n+\n+    /** Constant \"false first\" reference. */\n+    private static final BooleanComparator FALSE_FIRST = new BooleanComparator(false);\n+\n+    /** <code>true</code> iff <code>true</code> values sort before <code>false</code> values. */\n+    private boolean trueFirst = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a BooleanComparator instance that sorts \n+     * <code>true</code> values before <code>false</code> values.\n+     * <p />\n+     * Clients are encouraged to use the value returned from \n+     * this method instead of constructing a new instance \n+     * to reduce allocation and garbage collection overhead when\n+     * multiple BooleanComparators may be used in the same \n+     * virtual machine.\n+     * \n+     * @return the true first singleton BooleanComparator\n+     */\n+    public static BooleanComparator getTrueFirstComparator() {\n+        return TRUE_FIRST;\n+    }\n+    \n+    /**\n+     * Returns a BooleanComparator instance that sorts \n+     * <code>false</code> values before <code>true</code> values.\n+     * <p />\n+     * Clients are encouraged to use the value returned from \n+     * this method instead of constructing a new instance \n+     * to reduce allocation and garbage collection overhead when\n+     * multiple BooleanComparators may be used in the same \n+     * virtual machine.\n+     * \n+     * @return the false first singleton BooleanComparator\n+     */\n+    public static BooleanComparator getFalseFirstComparator() {\n+        return FALSE_FIRST;\n+    }\n+        \n+    /**\n+     * Returns a BooleanComparator instance that sorts \n+     * <code><i>trueFirst</i></code> values before \n+     * <code>&#x21;<i>trueFirst</i></code> values.\n+     * <p />\n+     * Clients are encouraged to use the value returned from \n+     * this method instead of constructing a new instance \n+     * to reduce allocation and garbage collection overhead when\n+     * multiple BooleanComparators may be used in the same \n+     * virtual machine.\n+     * \n+     * @param trueFirst when <code>true</code>, sort \n+     * <code>true</code> <code>Boolean</code>s before <code>false</code>\n+     * @return a singleton BooleanComparator instance\n+     */\n+    public static BooleanComparator booleanComparator(boolean trueFirst) {\n+        return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>BooleanComparator</code> that sorts\n+     * <code>false</code> values before <code>true</code> values.\n+     * <p>\n+     * Equivalent to {@link #BooleanComparator(boolean) BooleanComparator(false)}.\n+     * <p>\n+     * Please use the static factory instead whenever possible.\n+     */\n+    public BooleanComparator() {\n+        this(false);\n+    }\n+\n+    /**\n+     * Creates a <code>BooleanComparator</code> that sorts\n+     * <code><i>trueFirst</i></code> values before \n+     * <code>&#x21;<i>trueFirst</i></code> values.\n+     * <p>\n+     * Please use the static factories instead whenever possible.\n+     * \n+     * @param trueFirst when <code>true</code>, sort \n+     *  <code>true</code> boolean values before <code>false</code>\n+     */\n+    public BooleanComparator(boolean trueFirst) {\n+        this.trueFirst = trueFirst;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two non-<code>null</code> <code>Boolean</code> objects\n+     * according to the value of {@link #sortsTrueFirst()}.\n+     * \n+     * @param b1  the first boolean to compare\n+     * @param b2  the second boolean to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     * @throws NullPointerException when either argument <code>null</code>\n+     */\n+    public int compare(Boolean b1, Boolean b2) {\n+        boolean v1 = b1.booleanValue();\n+        boolean v2 = b2.booleanValue();\n+\n+        return (v1 ^ v2) ? ( (v1 ^ trueFirst) ? 1 : -1 ) : 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     */\n+    @Override\n+    public int hashCode() {\n+        int hash = \"BooleanComparator\".hashCode();\n+        return trueFirst ? -1 * hash : hash;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>that</i></code> is a {@link BooleanComparator} \n+     * whose value of {@link #sortsTrueFirst()} is equal to mine.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        return (this == object) || \n+               ((object instanceof BooleanComparator) && \n+                (this.trueFirst == ((BooleanComparator)object).trueFirst));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns <code>true</code> iff\n+     * I sort <code>true</code> values before \n+     * <code>false</code> values.  In other words,\n+     * returns <code>true</code> iff\n+     * {@link #compare(Boolean,Boolean) compare(Boolean.FALSE,Boolean.TRUE)}\n+     * returns a positive value.\n+     * \n+     * @return the trueFirst flag\n+     */\n+    public boolean sortsTrueFirst() {\n+        return trueFirst;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/ComparableComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/**\n+ * A {@link Comparator Comparator} that compares \n+ * {@link Comparable Comparable} objects.\n+ * <p />\n+ * This Comparator is useful, for example,\n+ * for enforcing the natural order in custom implementations\n+ * of SortedSet and SortedMap.\n+ * <p />\n+ * Note: In the 2.0 and 2.1 releases of Commons Collections, \n+ * this class would throw a {@link ClassCastException} if\n+ * either of the arguments to {@link #compare(Object, Object) compare}\n+ * were <code>null</code>, not {@link Comparable Comparable},\n+ * or for which {@link Comparable#compareTo(Object) compareTo} gave\n+ * inconsistent results.  This is no longer the case.  See\n+ * {@link #compare(Object, Object) compare} for details.\n+ *\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @see java.util.Collections#reverseOrder()\n+ */\n+public class ComparableComparator<E extends Comparable<? super E>> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID=-291439688585137865L;\n+\n+    /** The singleton instance. */\n+    @SuppressWarnings(\"rawtypes\")\n+    public static final ComparableComparator<?> INSTANCE = new ComparableComparator();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the singleton instance of a ComparableComparator.\n+     * <p>\n+     * Developers are encouraged to use the comparator returned from this method\n+     * instead of constructing a new instance to reduce allocation and GC overhead\n+     * when multiple comparable comparators may be used in the same VM.\n+     * \n+     * @return the singleton ComparableComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n+        return (ComparableComparator<E>) INSTANCE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor whose use should be avoided.\n+     * <p>\n+     * Please use the {@link #comparableComparator()} method whenever possible.\n+     */\n+    public ComparableComparator() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare the two {@link Comparable Comparable} arguments.\n+     * This method is equivalent to:\n+     * <pre>((Comparable)obj1).compareTo(obj2)</pre>\n+     * \n+     * @param obj1  the first object to compare\n+     * @param obj2  the second object to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     * @throws NullPointerException when <i>obj1</i> is <code>null</code>, \n+     *         or when <code>((Comparable)obj1).compareTo(obj2)</code> does\n+     * @throws ClassCastException when <i>obj1</i> is not a <code>Comparable</code>,\n+     *         or when <code>((Comparable)obj1).compareTo(obj2)</code> does\n+     */\n+    public int compare(E obj1, E obj2) {\n+        return obj1.compareTo(obj2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        return \"ComparableComparator\".hashCode();\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator Comparator} whose ordering is \n+     * known to be equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>object</i>.{@link Object#getClass() getClass()}</code>\n+     * equals <code>this.getClass()</code>.\n+     * Subclasses may want to override this behavior to remain consistent\n+     * with the {@link Comparator#equals(Object)} contract.\n+     * \n+     * @param object  the object to compare with\n+     * @return true if equal\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        return (this == object) || \n+               ((null != object) && (object.getClass().equals(this.getClass())));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/ComparatorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * <p>A ComparatorChain is a Comparator that wraps one or\n+ * more Comparators in sequence.  The ComparatorChain\n+ * calls each Comparator in sequence until either 1)\n+ * any single Comparator returns a non-zero result\n+ * (and that result is then returned),\n+ * or 2) the ComparatorChain is exhausted (and zero is\n+ * returned).  This type of sorting is very similar\n+ * to multi-column sorting in SQL, and this class\n+ * allows Java classes to emulate that kind of behaviour\n+ * when sorting a List.</p>\n+ *\n+ * <p>To further facilitate SQL-like sorting, the order of\n+ * any single Comparator in the list can be reversed.</p>\n+ *\n+ * <p>Calling a method that adds new Comparators or\n+ * changes the ascend/descend sort <i>after compare(Object,\n+ * Object) has been called</i> will result in an\n+ * UnsupportedOperationException.  However, <i>take care</i>\n+ * to not alter the underlying List of Comparators\n+ * or the BitSet that defines the sort order.</p>\n+ *\n+ * <p>Instances of ComparatorChain are not synchronized.\n+ * The class is not thread-safe at construction time, but\n+ * it <i>is</i> thread-safe to perform multiple comparisons\n+ * after all the setup operations are complete.</p>\n+ *\n+ * @since Commons Collections 2.0\n+ * @author Morgan Delagrange\n+ * @version $Revision$ $Date$\n+ */\n+public class ComparatorChain<E> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version from Collections 2.0. */\n+    private static final long serialVersionUID = -721644942746081630L;\n+\n+    /** The list of comparators in the chain. */\n+    protected List<Comparator<E>> comparatorChain = null;\n+    /** Order - false (clear) = ascend; true (set) = descend. */\n+    protected BitSet orderingBits = null;\n+   /** Whether the chain has been \"locked\". */\n+    protected boolean isLocked = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Construct a ComparatorChain with no Comparators.\n+     * You must add at least one Comparator before calling\n+     * the compare(Object,Object) method, or an\n+     * UnsupportedOperationException is thrown\n+     */\n+    public ComparatorChain() {\n+        this(new ArrayList<Comparator<E>>(), new BitSet());\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain with a single Comparator,\n+     * sorting in the forward order\n+     *\n+     * @param comparator First comparator in the Comparator chain\n+     */\n+    public ComparatorChain(Comparator<E> comparator) {\n+        this(comparator, false);\n+    }\n+\n+    /**\n+     * Construct a Comparator chain with a single Comparator,\n+     * sorting in the given order\n+     *\n+     * @param comparator First Comparator in the ComparatorChain\n+     * @param reverse    false = forward sort; true = reverse sort\n+     */\n+    public ComparatorChain(Comparator<E> comparator, boolean reverse) {\n+        comparatorChain = new ArrayList<Comparator<E>>(1);\n+        comparatorChain.add(comparator);\n+        orderingBits = new BitSet(1);\n+        if (reverse == true) {\n+            orderingBits.set(0);\n+        }\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain from the Comparators in the\n+     * List.  All Comparators will default to the forward\n+     * sort order.\n+     *\n+     * @param list   List of Comparators\n+     * @see #ComparatorChain(List,BitSet)\n+     */\n+    public ComparatorChain(List<Comparator<E>> list) {\n+        this(list, new BitSet(list.size()));\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain from the Comparators in the\n+     * given List.  The sort order of each column will be\n+     * drawn from the given BitSet.  When determining the sort\n+     * order for Comparator at index <i>i</i> in the List,\n+     * the ComparatorChain will call BitSet.get(<i>i</i>).\n+     * If that method returns <i>false</i>, the forward\n+     * sort order is used; a return value of <i>true</i>\n+     * indicates reverse sort order.\n+     *\n+     * @param list   List of Comparators.  NOTE: This constructor does not perform a\n+     *               defensive copy of the list\n+     * @param bits   Sort order for each Comparator.  Extra bits are ignored,\n+     *               unless extra Comparators are added by another method.\n+     */\n+    public ComparatorChain(List<Comparator<E>> list, BitSet bits) {\n+        comparatorChain = list;\n+        orderingBits = bits;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * forward sort order\n+     *\n+     * @param comparator Comparator with the forward sort order\n+     */\n+    public void addComparator(Comparator<E> comparator) {\n+        addComparator(comparator, false);\n+    }\n+\n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * given sort order\n+     *\n+     * @param comparator Comparator to add to the end of the chain\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n+    public void addComparator(Comparator<E> comparator, boolean reverse) {\n+        checkLocked();\n+\n+        comparatorChain.add(comparator);\n+        if (reverse == true) {\n+            orderingBits.set(comparatorChain.size() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Replace the Comparator at the given index, maintaining\n+     * the existing sort order.\n+     *\n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to place at the given index\n+     * @exception IndexOutOfBoundsException\n+     *                   if index &lt; 0 or index &gt;= size()\n+     */\n+    public void setComparator(int index, Comparator<E> comparator) throws IndexOutOfBoundsException {\n+        setComparator(index, comparator, false);\n+    }\n+\n+    /**\n+     * Replace the Comparator at the given index in the\n+     * ComparatorChain, using the given sort order\n+     *\n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to set\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n+    public void setComparator(int index, Comparator<E> comparator, boolean reverse) {\n+        checkLocked();\n+\n+        comparatorChain.set(index,comparator);\n+        if (reverse == true) {\n+            orderingBits.set(index);\n+        } else {\n+            orderingBits.clear(index);\n+        }\n+    }\n+\n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a forward sort.\n+     *\n+     * @param index  Index of the ComparatorChain\n+     */\n+    public void setForwardSort(int index) {\n+        checkLocked();\n+        orderingBits.clear(index);\n+    }\n+\n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a reverse sort.\n+     *\n+     * @param index  Index of the ComparatorChain\n+     */\n+    public void setReverseSort(int index) {\n+        checkLocked();\n+        orderingBits.set(index);\n+    }\n+\n+    /**\n+     * Number of Comparators in the current ComparatorChain.\n+     *\n+     * @return Comparator count\n+     */\n+    public int size() {\n+        return comparatorChain.size();\n+    }\n+\n+    /**\n+     * Determine if modifications can still be made to the\n+     * ComparatorChain.  ComparatorChains cannot be modified\n+     * once they have performed a comparison.\n+     *\n+     * @return true = ComparatorChain cannot be modified; false =\n+     *         ComparatorChain can still be modified.\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    // throw an exception if the ComparatorChain is locked\n+    private void checkLocked() {\n+        if (isLocked == true) {\n+            throw new UnsupportedOperationException(\"Comparator ordering cannot be changed after the first comparison is performed\");\n+        }\n+    }\n+\n+    private void checkChainIntegrity() {\n+        if (comparatorChain.size() == 0) {\n+            throw new UnsupportedOperationException(\"ComparatorChains must contain at least one Comparator\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Perform comparisons on the Objects as per\n+     * Comparator.compare(o1,o2).\n+     *\n+     * @param o1  the first object to compare\n+     * @param o2  the second object to compare\n+     * @return -1, 0, or 1\n+     * @exception UnsupportedOperationException\n+     *                   if the ComparatorChain does not contain at least one\n+     *                   Comparator\n+     */\n+    public int compare(E o1, E o2) throws UnsupportedOperationException {\n+        if (isLocked == false) {\n+            checkChainIntegrity();\n+            isLocked = true;\n+        }\n+\n+        // iterate over all comparators in the chain\n+        Iterator<Comparator<E>> comparators = comparatorChain.iterator();\n+        for (int comparatorIndex = 0; comparators.hasNext(); ++comparatorIndex) {\n+\n+            Comparator<E> comparator = comparators.next();\n+            int retval = comparator.compare(o1,o2);\n+            if (retval != 0) {\n+                // invert the order if it is a reverse sort\n+                if (orderingBits.get(comparatorIndex) == true) {\n+                    if(Integer.MIN_VALUE == retval) {\n+                        retval = Integer.MAX_VALUE;\n+                    } else {\n+                        retval *= -1;\n+                    }\n+                }\n+                return retval;\n+            }\n+        }\n+\n+        // if comparators are exhausted, return 0\n+        return 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a suitable hash code\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        if (null != comparatorChain) {\n+            hash ^= comparatorChain.hashCode();\n+        }\n+        if (null != orderingBits) {\n+            hash ^= orderingBits.hashCode();\n+        }\n+        return hash;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is\n+     * is a {@link Comparator} whose ordering is known to be\n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>object</i>.{@link Object#getClass() getClass()}</code>\n+     * equals <code>this.getClass()</code>, and the underlying\n+     * comparators and order bits are equal.\n+     * Subclasses may want to override this behavior to remain consistent\n+     * with the {@link Comparator#equals(Object)} contract.\n+     *\n+     * @param object  the object to compare with\n+     * @return true if equal\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            ComparatorChain<?> chain = (ComparatorChain<?>) object;\n+            return ((null == orderingBits ? null == chain.orderingBits : orderingBits\n+                    .equals(chain.orderingBits)) && (null == comparatorChain ? null == chain.comparatorChain\n+                    : comparatorChain.equals(chain.comparatorChain)));\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A Comparator which imposes a specific order on a specific set of Objects.\n+ * Objects are presented to the FixedOrderComparator in a specified order and\n+ * subsequent calls to {@link #compare(Object, Object) compare} yield that order.\n+ * For example:\n+ * <pre>\n+ * String[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"};\n+ * FixedOrderComparator distanceFromSun = new FixedOrderComparator(planets);\n+ * Arrays.sort(planets);                     // Sort to alphabetical order\n+ * Arrays.sort(planets, distanceFromSun);    // Back to original order\n+ * </pre>\n+ * <p>\n+ * Once <code>compare</code> has been called, the FixedOrderComparator is locked\n+ * and attempts to modify it yield an UnsupportedOperationException.\n+ * <p>\n+ * Instances of FixedOrderComparator are not synchronized.  The class is not\n+ * thread-safe at construction time, but it is thread-safe to perform\n+ * multiple comparisons  after all the setup operations are complete.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author David Leppik\n+ * @author Stephen Colebourne\n+ * @author Janek Bogucki\n+ */\n+public class FixedOrderComparator<T> implements Comparator<T> {\n+\n+    /**\n+     * Unknown object behavior enum.\n+     * @since Commons Collections 5\n+     */\n+    public static enum UnknownObjectBehavior {\n+        BEFORE, AFTER, EXCEPTION;\n+    }\n+\n+    /** Internal map of object to position */\n+    private final Map<T, Integer> map = new HashMap<T, Integer>();\n+\n+    /** Counter used in determining the position in the map */\n+    private int counter = 0;\n+\n+    /** Is the comparator locked against further change */\n+    private boolean isLocked = false;\n+\n+    /** The behaviour in the case of an unknown object */\n+    private UnknownObjectBehavior unknownObjectBehavior = UnknownObjectBehavior.EXCEPTION;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an empty FixedOrderComparator.\n+     */\n+    public FixedOrderComparator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a FixedOrderComparator which uses the order of the given array\n+     * to compare the objects.\n+     * <p>\n+     * The array is copied, so later changes will not affect the comparator.\n+     *\n+     * @param items  the items that the comparator can compare in order\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public FixedOrderComparator(T[] items) {\n+        super();\n+        if (items == null) {\n+            throw new IllegalArgumentException(\"The list of items must not be null\");\n+        }\n+        for (int i = 0; i < items.length; i++) {\n+            add(items[i]);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a FixedOrderComparator which uses the order of the given list\n+     * to compare the objects.\n+     * <p>\n+     * The list is copied, so later changes will not affect the comparator.\n+     *\n+     * @param items  the items that the comparator can compare in order\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    public FixedOrderComparator(List<T> items) {\n+        super();\n+        if (items == null) {\n+            throw new IllegalArgumentException(\"The list of items must not be null\");\n+        }\n+        for (T t : items) {\n+            add(t);\n+        }\n+    }\n+\n+    // Bean methods / state querying methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if modifications cannot be made to the FixedOrderComparator.\n+     * FixedOrderComparators cannot be modified once they have performed a comparison.\n+     *\n+     * @return true if attempts to change the FixedOrderComparator yield an\n+     *  UnsupportedOperationException, false if it can be changed.\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    /**\n+     * Checks to see whether the comparator is now locked against further changes.\n+     *\n+     * @throws UnsupportedOperationException if the comparator is locked\n+     */\n+    protected void checkLocked() {\n+        if (isLocked()) {\n+            throw new UnsupportedOperationException(\"Cannot modify a FixedOrderComparator after a comparison\");\n+        }\n+    }\n+\n+    /**\n+     * Gets the behavior for comparing unknown objects.\n+     *\n+     * @return {@link UnknownObjectBehavior}\n+     */\n+    public UnknownObjectBehavior getUnknownObjectBehavior() {\n+        return unknownObjectBehavior;\n+    }\n+\n+    /**\n+     * Sets the behavior for comparing unknown objects.\n+     *\n+     * @param unknownObjectBehavior  the flag for unknown behaviour -\n+     * UNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION\n+     * @throws UnsupportedOperationException if a comparison has been performed\n+     * @throws IllegalArgumentException if the unknown flag is not valid\n+     */\n+    public void setUnknownObjectBehavior(UnknownObjectBehavior unknownObjectBehavior) {\n+        checkLocked();\n+        if (unknownObjectBehavior == null) {\n+            throw new IllegalArgumentException(\"Unknown object behavior must not be null\");\n+        }\n+        this.unknownObjectBehavior = unknownObjectBehavior;\n+    }\n+\n+    // Methods for adding items\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds an item, which compares as after all items known to the Comparator.\n+     * If the item is already known to the Comparator, its old position is\n+     * replaced with the new position.\n+     *\n+     * @param obj  the item to be added to the Comparator.\n+     * @return true if obj has been added for the first time, false if\n+     *  it was already known to the Comparator.\n+     * @throws UnsupportedOperationException if a comparison has already been made\n+     */\n+    public boolean add(T obj) {\n+        checkLocked();\n+        Integer position = map.put(obj, new Integer(counter++));\n+        return (position == null);\n+    }\n+\n+    /**\n+     * Adds a new item, which compares as equal to the given existing item.\n+     *\n+     * @param existingObj  an item already in the Comparator's set of\n+     *  known objects\n+     * @param newObj  an item to be added to the Comparator's set of\n+     *  known objects\n+     * @return true if newObj has been added for the first time, false if\n+     *  it was already known to the Comparator.\n+     * @throws IllegalArgumentException if existingObject is not in the\n+     *  Comparator's set of known objects.\n+     * @throws UnsupportedOperationException if a comparison has already been made\n+     */\n+    public boolean addAsEqual(T existingObj, T newObj) {\n+        checkLocked();\n+        Integer position = map.get(existingObj);\n+        if (position == null) {\n+            throw new IllegalArgumentException(existingObj + \" not known to \" + this);\n+        }\n+        Integer result = map.put(newObj, position);\n+        return (result == null);\n+    }\n+\n+    // Comparator methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two objects according to the order of this Comparator.\n+     * <p>\n+     * It is important to note that this class will throw an IllegalArgumentException\n+     * in the case of an unrecognised object. This is not specified in the\n+     * Comparator interface, but is the most appropriate exception.\n+     *\n+     * @param obj1  the first object to compare\n+     * @param obj2  the second object to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     * @throws IllegalArgumentException if obj1 or obj2 are not known\n+     *  to this Comparator and an alternative behavior has not been set\n+     *  via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}.\n+     */\n+    public int compare(T obj1, T obj2) {\n+        isLocked = true;\n+        Integer position1 = map.get(obj1);\n+        Integer position2 = map.get(obj2);\n+        if (position1 == null || position2 == null) {\n+            switch (unknownObjectBehavior) {\n+            case BEFORE:\n+                return position1 == null ? position2 == null ? 0 : -1 : 1;\n+            case AFTER:\n+                return position1 == null ? position2 == null ? 0 : 1 : -1;\n+            case EXCEPTION:\n+                Object unknownObj = (position1 == null) ? obj1 : obj2;\n+                throw new IllegalArgumentException(\"Attempting to compare unknown object \"\n+                        + unknownObj);\n+            default: //could be null\n+                throw new UnsupportedOperationException(\"Unknown unknownObjectBehavior: \"\n+                        + unknownObjectBehavior);\n+            }\n+        }\n+        return position1.compareTo(position2);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/NullComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.ComparatorUtils;\n+\n+/**\n+ * A Comparator that will compare nulls to be either lower or higher than\n+ * other objects.\n+ *\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$ \n+ *\n+ * @author Michael A. Smith\n+ */\n+public class NullComparator<E> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -5820772575483504339L;\n+\n+    /**\n+     *  The comparator to use when comparing two non-<code>null</code> objects.\n+     **/\n+    private final Comparator<E> nonNullComparator;\n+\n+    /**\n+     *  Specifies whether a <code>null</code> are compared as higher than\n+     *  non-<code>null</code> objects.\n+     **/\n+    private final boolean nullsAreHigh;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher than any\n+     *  non-<code>null</code> object it is compared with. When comparing two\n+     *  non-<code>null</code> objects, the {@link ComparableComparator} is\n+     *  used.\n+     **/\n+    @SuppressWarnings(\"unchecked\")\n+    public NullComparator() {\n+        this(ComparatorUtils.NATURAL_COMPARATOR, true);\n+    }\n+\n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher than any\n+     *  non-<code>null</code> object it is compared with.  When comparing two\n+     *  non-<code>null</code> objects, the specified {@link Comparator} is\n+     *  used.\n+     *\n+     *  @param nonNullComparator the comparator to use when comparing two\n+     *  non-<code>null</code> objects.  This argument cannot be\n+     *  <code>null</code>\n+     *\n+     *  @exception NullPointerException if <code>nonNullComparator</code> is\n+     *  <code>null</code>\n+     **/\n+    public NullComparator(Comparator<E> nonNullComparator) {\n+        this(nonNullComparator, true);\n+    }\n+\n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher or lower than\n+     *  any non-<code>null</code> object it is compared with.  When comparing\n+     *  two non-<code>null</code> objects, the {@link ComparableComparator} is\n+     *  used.\n+     *\n+     *  @param nullsAreHigh a <code>true</code> value indicates that\n+     *  <code>null</code> should be compared as higher than a\n+     *  non-<code>null</code> object.  A <code>false</code> value indicates\n+     *  that <code>null</code> should be compared as lower than a\n+     *  non-<code>null</code> object.\n+     **/\n+    @SuppressWarnings(\"unchecked\")\n+    public NullComparator(boolean nullsAreHigh) {\n+        this(ComparatorUtils.NATURAL_COMPARATOR, nullsAreHigh);\n+    }\n+    \n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher or lower than\n+     *  any non-<code>null</code> object it is compared with.  When comparing\n+     *  two non-<code>null</code> objects, the specified {@link Comparator} is\n+     *  used.\n+     *\n+     *  @param nonNullComparator the comparator to use when comparing two\n+     *  non-<code>null</code> objects. This argument cannot be\n+     *  <code>null</code>\n+     *\n+     *  @param nullsAreHigh a <code>true</code> value indicates that\n+     *  <code>null</code> should be compared as higher than a\n+     *  non-<code>null</code> object.  A <code>false</code> value indicates\n+     *  that <code>null</code> should be compared as lower than a\n+     *  non-<code>null</code> object.\n+     *\n+     *  @exception NullPointerException if <code>nonNullComparator</code> is\n+     *  <code>null</code>\n+     **/\n+    public NullComparator(Comparator<E> nonNullComparator, boolean nullsAreHigh) {\n+        this.nonNullComparator = nonNullComparator;\n+        this.nullsAreHigh = nullsAreHigh;\n+        \n+        if (nonNullComparator == null) {\n+            throw new NullPointerException(\"null nonNullComparator\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Perform a comparison between two objects.  If both objects are\n+     *  <code>null</code>, a <code>0</code> value is returned.  If one object\n+     *  is <code>null</code> and the other is not, the result is determined on\n+     *  whether the Comparator was constructed to have nulls as higher or lower\n+     *  than other objects.  If neither object is <code>null</code>, an\n+     *  underlying comparator specified in the constructor (or the default) is\n+     *  used to compare the non-<code>null</code> objects.\n+     *\n+     *  @param o1  the first object to compare\n+     *  @param o2  the object to compare it to.\n+     *  @return <code>-1</code> if <code>o1</code> is \"lower\" than (less than,\n+     *  before, etc.) <code>o2</code>; <code>1</code> if <code>o1</code> is\n+     *  \"higher\" than (greater than, after, etc.) <code>o2</code>; or\n+     *  <code>0</code> if <code>o1</code> and <code>o2</code> are equal.\n+     **/\n+    public int compare(E o1, E o2) {\n+        if(o1 == o2) { return 0; }\n+        if(o1 == null) { return (this.nullsAreHigh ? 1 : -1); }\n+        if(o2 == null) { return (this.nullsAreHigh ? -1 : 1); }\n+        return this.nonNullComparator.compare(o1, o2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Implement a hash code for this comparator that is consistent with\n+     *  {@link #equals(Object)}.\n+     *\n+     *  @return a hash code for this comparator.\n+     **/\n+    @Override\n+    public int hashCode() {\n+        return (nullsAreHigh ? -1 : 1) * nonNullComparator.hashCode();\n+    }\n+\n+    /**\n+     *  Determines whether the specified object represents a comparator that is\n+     *  equal to this comparator.\n+     *\n+     *  @param obj  the object to compare this comparator with.\n+     *\n+     *  @return <code>true</code> if the specified object is a NullComparator\n+     *  with equivalent <code>null</code> comparison behavior\n+     *  (i.e. <code>null</code> high or low) and with equivalent underlying\n+     *  non-<code>null</code> object comparators.\n+     **/\n+    @Override\n+    public boolean equals(Object obj) {\n+        if(obj == null) { return false; }\n+        if(obj == this) { return true; }\n+        if(!obj.getClass().equals(this.getClass())) { return false; }\n+\n+        NullComparator<?> other = (NullComparator<?>) obj;\n+\n+        return ((this.nullsAreHigh == other.nullsAreHigh) &&\n+                (this.nonNullComparator.equals(other.nonNullComparator)));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/ReverseComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.ComparatorUtils;\n+\n+/**\n+ * Reverses the order of another comparator by reversing the arguments\n+ * to its {@link #compare(Object, Object) compare} method.\n+ *\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Michael A. Smith\n+ *\n+ * @see java.util.Collections#reverseOrder()\n+ */\n+public class ReverseComparator<E> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version from Collections 2.0. */\n+    private static final long serialVersionUID = 2858887242028539265L;\n+\n+    /** The comparator being decorated. */\n+    private final Comparator<E> comparator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a comparator that compares objects based on the inverse of their\n+     * natural ordering.  Using this Constructor will create a ReverseComparator\n+     * that is functionally identical to the Comparator returned by\n+     * java.util.Collections.<b>reverseOrder()</b>.\n+     * \n+     * @see java.util.Collections#reverseOrder()\n+     */\n+    public ReverseComparator() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Creates a comparator that inverts the comparison\n+     * of the given comparator.  If you pass in <code>null</code>,\n+     * the ReverseComparator defaults to reversing the\n+     * natural order, as per \n+     * {@link java.util.Collections#reverseOrder()}</b>.\n+     * \n+     * @param comparator Comparator to reverse\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ReverseComparator(Comparator<E> comparator) {\n+        this.comparator = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two objects in reverse order.\n+     * \n+     * @param obj1  the first object to compare\n+     * @param obj2  the second object to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     */\n+    public int compare(E obj1, E obj2) {\n+        return comparator.compare(obj2, obj1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     * \n+     * @return a suitable hash code\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        return \"ReverseComparator\".hashCode() ^ comparator.hashCode();\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>object</i>.{@link Object#getClass() getClass()}</code>\n+     * equals <code>this.getClass()</code>, and the underlying \n+     * comparators are equal.\n+     * Subclasses may want to override this behavior to remain consistent\n+     * with the {@link Comparator#equals(Object) equals} contract.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     * @since Commons Collections 3.0\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            ReverseComparator<?> thatrc = (ReverseComparator<?>) object;\n+            return comparator.equals(thatrc.comparator);\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/comparators/TransformingComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.ComparatorUtils;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Decorates another Comparator with transformation behavior. That is, the\n+ * return value from the transform operation will be passed to the decorated\n+ * {@link Comparator#compare(Object,Object) compare} method.\n+ *\n+ * @since Commons Collections 2.0 (?)\n+ * @version $Revision$ $Date$\n+ *\n+ * @see org.apache.commons.collections.Transformer\n+ * @see org.apache.commons.collections.comparators.ComparableComparator\n+ */\n+public class TransformingComparator<E> implements Comparator<E> {\n+    \n+    /** The decorated comparator. */\n+    protected Comparator<E> decorated;\n+    /** The transformer being used. */    \n+    protected Transformer<? super E, ? extends E> transformer;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance with the given Transformer and a \n+     * {@link ComparableComparator ComparableComparator}.\n+     * \n+     * @param transformer what will transform the arguments to <code>compare</code>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public TransformingComparator(Transformer<? super E, ? extends E> transformer) {\n+        this(transformer, ComparatorUtils.NATURAL_COMPARATOR);\n+    }\n+\n+    /**\n+     * Constructs an instance with the given Transformer and Comparator.\n+     * \n+     * @param transformer  what will transform the arguments to <code>compare</code>\n+     * @param decorated  the decorated Comparator\n+     */\n+    public TransformingComparator(Transformer<? super E, ? extends E> transformer, Comparator<E> decorated) {\n+        this.decorated = decorated;\n+        this.transformer = transformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the result of comparing the values from the transform operation.\n+     * \n+     * @param obj1  the first object to transform then compare\n+     * @param obj2  the second object to transform then compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     */\n+    public int compare(E obj1, E obj2) {\n+        E value1 = this.transformer.transform(obj1);\n+        E value2 = this.transformer.transform(obj2);\n+        return this.decorated.compare(value1, value2);\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/AllPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import static org.apache.commons.collections.functors.FunctorUtils.coerce;\n+import static org.apache.commons.collections.functors.FunctorUtils.validate;\n+import static org.apache.commons.collections.functors.TruePredicate.truePredicate;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if all the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns true.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ * @author Stephen Kestle\n+ */\n+public final class AllPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3094696765038308799L;\n+    \n+    /** The array of predicates to call */\n+    private final Predicate<? super T>[] iPredicates;\n+    \n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns true.\n+     * If the array is size one, then that predicate is returned.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> allPredicate(Predicate<? super T> ... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return truePredicate();\n+        }\n+        if (predicates.length == 1) {\n+            return coerce(predicates[0]);\n+        }\n+\n+        return new AllPredicate<T>(FunctorUtils.copy(predicates));\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the collection is size zero, the predicate always returns true.\n+     * If the collection is size one, then that predicate is returned.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> allPredicate(Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<T>[] preds = validate(predicates);\n+        if (preds.length == 0) {\n+            return truePredicate();\n+        }\n+        if (preds.length == 1) {\n+            return preds[0];\n+        }\n+        return new AllPredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public AllPredicate(Predicate<? super T> ... predicates) {\n+        super();\n+        iPredicates = predicates;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if all predicates return true.\n+     * \n+     * @param object  the input object\n+     * @return true if all decorated predicates return true\n+     */\n+    public boolean evaluate(T object) {\n+        for (Predicate<? super T> iPredicate : iPredicates) {\n+            if (!iPredicate.evaluate(object)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the predicates, do not modify the array.\n+     * \n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super T>[] getPredicates() {\n+        return iPredicates;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/AndPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if both the predicates return true.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class AndPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 4189014213763186912L;\n+\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate1;\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate2;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     * @return the <code>and</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static <T> Predicate<T> andPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        if (predicate1 == null || predicate2 == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new AndPredicate<T>(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     */\n+    public AndPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        super();\n+        iPredicate1 = predicate1;\n+        iPredicate2 = predicate2;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if both predicates return true.\n+     *\n+     * @param object  the input object\n+     * @return true if both decorated predicates return true\n+     */\n+    public boolean evaluate(T object) {\n+       return (iPredicate1.evaluate(object) && iPredicate2.evaluate(object));\n+    }\n+\n+    /**\n+     * Gets the two predicates being decorated as an array.\n+     *\n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate1, iPredicate2};\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/AnyPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if any of the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns false.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public final class AnyPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7429999530934647542L;\n+\n+    /** The array of predicates to call */\n+    private final Predicate<? super T>[] iPredicates;\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns false.\n+     * If the array is size one, then that predicate is returned.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> anyPredicate(Predicate<? super T>... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return FalsePredicate.<T>falsePredicate();\n+        }\n+        if (predicates.length == 1) {\n+            return (Predicate<T>) predicates[0];\n+        }\n+        return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the collection is size zero, the predicate always returns false.\n+     * If the collection is size one, then that predicate is returned.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> anyPredicate(Collection<? extends Predicate<T>> predicates) {\n+        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+        if (preds.length == 0) {\n+            return FalsePredicate.<T>falsePredicate();\n+        }\n+        if (preds.length == 1) {\n+            return (Predicate<T>) preds[0];\n+        }\n+        return new AnyPredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public AnyPredicate(Predicate<? super T>[] predicates) {\n+        super();\n+        iPredicates = predicates;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if any predicate returns true.\n+     *\n+     * @param object  the input object\n+     * @return true if any decorated predicate return true\n+     */\n+    public boolean evaluate(T object) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(object)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the predicates, do not modify the array.\n+     *\n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super T>[] getPredicates() {\n+        return iPredicates;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/CatchAndRethrowClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.FunctorException;\n+\n+/**\n+ * {@link Closure} that catches any checked exception and re-throws it as a\n+ * {@link FunctorException} runtime exception. Example usage:\n+ * \n+ * <pre>\n+ * // Create a catch and re-throw closure via anonymous subclass\n+ * CatchAndRethrowClosure&lt;String&gt; writer = new ThrowingClosure() {\n+ *     private java.io.Writer out = // some writer\n+ *     \n+ *     protected void executeAndThrow(String input) throws IOException {\n+ *         out.write(input); // throwing of IOException allowed\n+ *     }\n+ * };\n+ * \n+ * // use catch and re-throw closure\n+ * java.util.List<String> strList = // some list\n+ * try {\n+ *     CollctionUtils.forAllDo(strList, writer);\n+ * } catch (FunctorException ex) {\n+ *     Throwable originalError = ex.getCause();\n+ *     // handle error\n+ * }\n+ * </pre>\n+ * \n+ * @since Commons Collections 4.0\n+ * @version $Revision: $ $Date: $\n+ */\n+public abstract class CatchAndRethrowClosure<E> implements Closure<E> {\n+\n+    /**\n+     * Execute this closure on the specified input object.\n+     * \n+     * @param input the input to execute on\n+     * @throws ClosureException (runtime) if the closure execution resulted in a\n+     *             checked exception.\n+     */\n+    public void execute(E input) {\n+        try {\n+            executeAndThrow(input);\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (Throwable t) {\n+            throw new FunctorException(t);\n+        }\n+    }\n+\n+    /**\n+     * Execute this closure on the specified input object.\n+     * \n+     * @param input the input to execute on\n+     * @throws Throwable if the closure execution resulted in a checked\n+     *             exception.\n+     */\n+    protected abstract void executeAndThrow(E input) throws Throwable;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ChainedClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Closure;\n+\n+/**\n+ * Closure implementation that chains the specified closures together.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ChainedClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3520677225766901240L;\n+\n+    /** The closures to call in turn */\n+    private final Closure<? super E>[] iClosures;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter array.\n+     * \n+     * @param closures  the closures to chain, copied, no nulls\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures array is null\n+     * @throws IllegalArgumentException if any closure in the array is null\n+     */\n+    public static <E> Closure<E> chainedClosure(Closure<? super E>... closures) {\n+        FunctorUtils.validate(closures);\n+        if (closures.length == 0) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        closures = FunctorUtils.copy(closures);\n+        return new ChainedClosure<E>(closures);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param closures  a collection of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures collection is null\n+     * @throws IllegalArgumentException if any closure in the collection is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> chainedClosure(Collection<Closure<E>> closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"Closure collection must not be null\");\n+        }\n+        if (closures.size() == 0) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure<? super E>[] cmds = new Closure[closures.size()];\n+        int i = 0;\n+        for (Closure<? super E> closure : closures) {\n+            cmds[i++] = closure;\n+        }\n+        FunctorUtils.validate(cmds);\n+        return new ChainedClosure<E>(cmds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param closures  the closures to chain, not copied, no nulls\n+     */\n+    public ChainedClosure(Closure<? super E>[] closures) {\n+        super();\n+        iClosures = closures;\n+    }\n+\n+    /**\n+     * Execute a list of closures.\n+     * \n+     * @param input  the input object passed to each closure\n+     */\n+    public void execute(E input) {\n+        for (int i = 0; i < iClosures.length; i++) {\n+            iClosures[i].execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the closures, do not modify the array.\n+     * @return the closures\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super E>[] getClosures() {\n+        return iClosures;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ChainedTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that chains the specified transformers together.\n+ * <p>\n+ * The input object is passed to the first transformer. The transformed result\n+ * is passed to the second transformer and so on.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ChainedTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3514945074733160196L;\n+\n+    /** The transformers to call in turn */\n+    private final Transformer<? super T, ? extends T>[] iTransformers;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter array.\n+     * \n+     * @param transformers  the transformers to chain, copied, no nulls\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if the transformers array is null\n+     * @throws IllegalArgumentException if any transformer in the array is null\n+     */\n+    public static <T> Transformer<T, T> chainedTransformer(Transformer<? super T, ? extends T>... transformers) {\n+        FunctorUtils.validate(transformers);\n+        if (transformers.length == 0) {\n+            return NOPTransformer.<T>nopTransformer();\n+        }\n+        transformers = FunctorUtils.copy(transformers);\n+        return new ChainedTransformer<T>(transformers);\n+    }\n+    \n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param transformers  a collection of transformers to chain\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if the transformers collection is null\n+     * @throws IllegalArgumentException if any transformer in the collection is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> chainedTransformer(Collection<? extends Transformer<T, T>> transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"Transformer collection must not be null\");\n+        }\n+        if (transformers.size() == 0) {\n+            return NOPTransformer.<T>nopTransformer();\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n+        FunctorUtils.validate(cmds);\n+        return new ChainedTransformer<T>(cmds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param transformers  the transformers to chain, not copied, no nulls\n+     */\n+    public ChainedTransformer(Transformer<? super T, ? extends T>[] transformers) {\n+        super();\n+        iTransformers = transformers;\n+    }\n+\n+    /**\n+     * Transforms the input to result via each decorated transformer\n+     * \n+     * @param object  the input object passed to the first transformer\n+     * @return the transformed result\n+     */\n+    public T transform(T object) {\n+        for (int i = 0; i < iTransformers.length; i++) {\n+            object = iTransformers[i].transform(object);\n+        }\n+        return object;\n+    }\n+\n+    /**\n+     * Gets the transformers, do not modify the array.\n+     * @return the transformers\n+     * @since Commons Collections 3.1\n+     */\n+    public Transformer<? super T, ? extends T>[] getTransformers() {\n+        return iTransformers;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/CloneTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that returns a clone of the input object.\n+ * <p>\n+ * Clone is performed using <code>PrototypeFactory.getInstance(input).create()</code>.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class CloneTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -8188742709499652567L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, Object> INSTANCE = new CloneTransformer<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     * \n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> cloneTransformer() {\n+        return (Transformer<T, T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    private CloneTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by cloning it.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public T transform(T input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        return PrototypeFactory.prototypeFactory(input).create();\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ClosureTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Closure using the input object\n+ * and then returns the input.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ClosureTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 478466901448617286L;\n+\n+    /** The closure to wrap */\n+    private final Closure<? super T> iClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param closure  the closure to call, not null\n+     * @return the <code>closure</code> transformer\n+     * @throws IllegalArgumentException if the closure is null\n+     */\n+    public static <T> Transformer<T, T> closureTransformer(Closure<? super T> closure) {\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"Closure must not be null\");\n+        }\n+        return new ClosureTransformer<T>(closure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param closure  the closure to call, not null\n+     */\n+    public ClosureTransformer(Closure<? super T> closure) {\n+        super();\n+        iClosure = closure;\n+    }\n+\n+    /**\n+     * Transforms the input to result by executing a closure.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public T transform(T input) {\n+        iClosure.execute(input);\n+        return input;\n+    }\n+\n+    /**\n+     * Gets the closure.\n+     * \n+     * @return the closure\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super T> getClosure() {\n+        return iClosure;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate that compares the input object with the one stored in the predicate using a comparator.\n+ * In addition, the comparator result can be evaluated in accordance to a supplied criterion value.\n+ *\n+ * In order to demonstrate the use of the predicate, the following variables are declared:\n+ *\n+ * <pre>\n+ * Integer ONE = new Integer(1);\n+ * Integer TWO = new Integer(2);\n+ *\n+ * Comparator comparator = new Comparator() {\n+ *\n+ *     public int compare(Object first, Object second) {\n+ *         return ((Integer) second) - ((Integer) first);\n+ *     }\n+ *\n+ * };\n+ * </pre>\n+ *\n+ * Using the declared variables, the <code>ComparatorPredicate</code> can be used used in the\n+ * following way:\n+ *\n+ * <pre>\n+ * ComparatorPredicate.getInstance(ONE, comparator).evaluate(TWO);\n+ * </pre>\n+ *\n+ * The input variable <code>TWO</code> in compared to the stored variable <code>ONE</code> using\n+ * the supplied <code>comparator</code>. This is the default usage of the predicate and will return\n+ * <code>true</code> if the underlying comparator returns <code>0</code>. In addition to the default\n+ * usage of the predicate, it is possible to evaluate the comparator's result in several ways. The\n+ * following {@link Criterion} enumeration values are provided by the predicate:\n+ * </p>\n+ *\n+ * <ul>\n+ *     <li>EQUAL</li>\n+ *     <li>GREATER</li>\n+ *     <li>GREATER_OR_EQUAL</li>\n+ *     <li>LESS</li>\n+ *     <li>LESS_OR_EQUAL</li>\n+ * </ul>\n+ *\n+ * The following examples demonstrates how these constants can be used in order to manipulate the\n+ * evaluation of a comparator result.\n+ *\n+ * <pre>\n+ * ComparatorPredicate.getInstance(ONE, comparator, <b>ComparatorPredicate.Criterion.GREATER</b>).evaluate(TWO);\n+ * </pre>\n+ *\n+ * The input variable TWO is compared to the stored variable ONE using the supplied <code>comparator</code>\n+ * using the <code>GREATER</code> evaluation criterion constant. This instructs the predicate to\n+ * return <code>true</code> if the comparator returns a value greater than <code>0</code>.\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Revision: $ $Date: $\n+ *\n+ * @author Rune Peter Bjrnstad.\n+ */\n+public class ComparatorPredicate<T> implements Predicate<T>, Serializable {\n+\n+    private static final long serialVersionUID = -1863209236504077399L;\n+\n+    public enum Criterion {\n+        EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL,\n+    }\n+\n+    // Instance variables:\n+\n+    /** The internal object to compare with */\n+    private final T object;\n+\n+    /** The comparator to use for comparison */\n+    private final Comparator<T> comparator;\n+\n+    /** The comparison evaluation criterion to use */\n+    private final Criterion criterion;\n+\n+    /**\n+     * Factory to create the comparator predicate\n+     *\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @return the predicate\n+     * @throws IllegalArgumentException if comparator is null\n+     */\n+    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator) {\n+        return comparatorPredicate(object, comparator, Criterion.EQUAL);\n+    }\n+\n+    /**\n+     * Factory to create the comparator predicate\n+     *\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @param criterion  the criterion to use to evaluate comparison\n+     * @return the predicate\n+     * @throws IllegalArgumentException if comparator is null of criterion is invalid\n+     */\n+    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n+        if (comparator == null) {\n+            throw new IllegalArgumentException(\"Comparator must not be null.\");\n+        }\n+        if (criterion == null) {\n+            throw new IllegalArgumentException(\"Criterion must not be null.\");\n+        }\n+        return new ComparatorPredicate<T>(object, comparator, criterion);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want.\n+     *\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @param criterion  the criterion to use to evaluate comparison\n+     */\n+    public ComparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n+        super();\n+        this.object = object;\n+        this.comparator = comparator;\n+        this.criterion = criterion;\n+    }\n+\n+    /**\n+     * Evaluates the predicate. The predicate evaluates to <code>true</code> in the following cases:\n+     *\n+     * <ul>\n+     *     <li><code>comparator.compare(object, input) == 0 && criterion == EQUAL</code></li>\n+     *     <li><code>comparator.compare(object, input) < 0 && criterion == LESS</code></li>\n+     *     <li><code>comparator.compare(object, input) > 0 && criterion == GREATER</code></li>\n+     *     <li><code>comparator.compare(object, input) >= 0 && criterion == GREATER_OR_EQUAL</code></li>\n+     *     <li><code>comparator.compare(object, input) <= 0 && criterion == LESS_OR_EQUAL</code></li>\n+     * </ul>\n+     *\n+     * @see org.apache.commons.collections.Predicate#evaluate(java.lang.Object)\n+     * @see java.util.Comparator#compare(java.lang.Object first, java.lang.Object second)\n+     *\n+     * @throws IllegalStateException if the criterion is invalid (really not possible)\n+     */\n+    public boolean evaluate(T target) {\n+\n+        boolean result = false;\n+        int comparison = comparator.compare(object, target);\n+        switch (criterion) {\n+        case EQUAL:\n+            result = (comparison == 0);\n+            break;\n+        case GREATER:\n+            result = (comparison > 0);\n+            break;\n+        case LESS:\n+            result = (comparison < 0);\n+            break;\n+        case GREATER_OR_EQUAL:\n+            result = (comparison >= 0);\n+            break;\n+        case LESS_OR_EQUAL:\n+            result = (comparison <= 0);\n+            break;\n+        default:\n+            throw new IllegalStateException(\"The current criterion '\" + criterion + \"' is invalid.\");\n+        }\n+\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ConstantFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Factory;\n+\n+/**\n+ * Factory implementation that returns the same constant each time.\n+ * <p>\n+ * No check is made that the object is immutable. In general, only immutable\n+ * objects should use the constant factory. Mutable objects should\n+ * use the prototype factory.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ConstantFactory<T> implements Factory<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3520677225766901240L;\n+    \n+    /** Returns null each time */\n+    public static final Factory<Object> NULL_INSTANCE = new ConstantFactory<Object>(null);\n+\n+    /** The closures to call in turn */\n+    private final T iConstant;\n+\n+    /**\n+     * Factory method that performs validation.\n+     *\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> constantFactory(T constantToReturn) {\n+        if (constantToReturn == null) {\n+            return (Factory<T>) NULL_INSTANCE;\n+        }\n+        return new ConstantFactory<T>(constantToReturn);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param constantToReturn  the constant to return each time\n+     */\n+    public ConstantFactory(T constantToReturn) {\n+        super();\n+        iConstant = constantToReturn;\n+    }\n+\n+    /**\n+     * Always return constant.\n+     * \n+     * @return the stored constant value\n+     */\n+    public T create() {\n+        return iConstant;\n+    }\n+\n+    /**\n+     * Gets the constant.\n+     * \n+     * @return the constant\n+     * @since Commons Collections 3.1\n+     */\n+    public T getConstant() {\n+        return iConstant;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ConstantTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the same constant each time.\n+ * <p>\n+ * No check is made that the object is immutable. In general, only immutable\n+ * objects should use the constant factory. Mutable objects should\n+ * use the prototype factory.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ConstantTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 6374440726369055124L;\n+    \n+    /** Returns null each time */\n+    public static final Transformer<Object, Object> NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);\n+\n+    /** The closures to call in turn */\n+    private final O iConstant;\n+\n+    /**\n+     * Get a typed null instance.\n+     * @param <I>\n+     * @param <O>\n+     * @return Transformer<I, O> that always returns null.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> nullTransformer() {\n+        return (Transformer<I, O>) NULL_INSTANCE;\n+    }\n+\n+    /**\n+     * Transformer method that performs validation.\n+     *\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    public static <I, O> Transformer<I, O> constantTransformer(O constantToReturn) {\n+        if (constantToReturn == null) {\n+            return nullTransformer();\n+        }\n+        return new ConstantTransformer<I, O>(constantToReturn);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param constantToReturn  the constant to return each time\n+     */\n+    public ConstantTransformer(O constantToReturn) {\n+        super();\n+        iConstant = constantToReturn;\n+    }\n+\n+    /**\n+     * Transforms the input by ignoring it and returning the stored constant instead.\n+     * \n+     * @param input  the input object which is ignored\n+     * @return the stored constant\n+     */\n+    public O transform(I input) {\n+        return iConstant;\n+    }\n+\n+    /**\n+     * Gets the constant.\n+     * \n+     * @return the constant\n+     * @since Commons Collections 3.1\n+     */\n+    public O getConstant() {\n+        return iConstant;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof ConstantTransformer == false) {\n+            return false;\n+        }\n+        Object otherConstant = ((ConstantTransformer<?, ?>) obj).getConstant();\n+        return otherConstant == getConstant() || otherConstant != null && otherConstant.equals(getConstant());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = \"ConstantTransformer\".hashCode() << 2;\n+        if (getConstant() != null) {\n+            result |= getConstant().hashCode();\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/DefaultEquator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+/**\n+ * Default {@link Equator} implementation.\n+ * \n+ * @param <T>\n+ * @since Commons Collections 4.0\n+ * @version $Revision$ $Date$\n+ */\n+public class DefaultEquator<T> implements Equator<T> {\n+\t/** Static instance */\n+\tpublic static final DefaultEquator<Object> INSTANCE = new DefaultEquator<Object>();\n+\n+\t/**\n+\t * Hashcode used for <code>null</code> objects.\n+\t */\n+\tpublic static final int HASHCODE_NULL = -1;\n+\n+\t/**\n+\t * {@inheritDoc} Delegates to {@link Object#equals(Object)}.\n+\t */\n+\tpublic boolean equate(T o1, T o2) {\n+\t\treturn o1 == o2 || o1 != null && o1.equals(o2);\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t * \n+\t * @return <code>o.hashCode()</code> if <code>o</code> is non-\n+\t *         <code>null</code>, else {@link #HASHCODE_NULL}.\n+\t */\n+\tpublic int hash(T o) {\n+\t\treturn o == null ? HASHCODE_NULL : o.hashCode();\n+\t}\n+\n+\tprivate Object readResolve() {\n+\t\treturn INSTANCE;\n+\t}\n+\n+\t/**\n+\t * Get a typed {@link DefaultEquator} instance.\n+\t * \n+\t * @param <T>\n+\t * @return {@link DefaultEquator#INSTANCE}\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static <T> DefaultEquator<T> defaultEquator() {\n+\t\treturn (DefaultEquator<T>) DefaultEquator.INSTANCE;\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import static org.apache.commons.collections.functors.NullPredicate.nullPredicate;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is the same object\n+ * as the one stored in this predicate by equals.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class EqualPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 5633766978029907089L;\n+\n+    /** The value to compare to */\n+    private final Object iValue;\n+\n+    /**\n+     * Factory to create the identity predicate.\n+     * \n+     * @param object  the object to compare to\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> equalPredicate(T object) {\n+        if (object == null) {\n+            return nullPredicate();\n+        }\n+        return new EqualPredicate<T>(object);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param object  the object to compare to\n+     */\n+    public EqualPredicate(Object object) {\n+        super();\n+        iValue = object;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input equals the stored value.\n+     * \n+     * @param object  the input object\n+     * @return true if input object equals stored value\n+     */\n+    public boolean evaluate(Object object) {\n+        return (iValue.equals(object));\n+    }\n+\n+    /**\n+     * Gets the value.\n+     * \n+     * @return the value\n+     * @since Commons Collections 3.1\n+     */\n+    public Object getValue() {\n+        return iValue;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/Equator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable\n+ * law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\"\n+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.map.HashedMap;\n+\n+/**\n+ * <p>\n+ * An equation function, which determines equality between objects of type T.\n+ * </p>\n+ * <p>\n+ * It is the functional sibling of {@link java.util.Comparator}; {@link Equator} is to\n+ * {@link Object} as {@link java.util.Comparator} is to {@link java.lang.Comparable}.\n+ * </p>\n+ * \n+ * @param <T> the types of object this {@link Equator} can evaluate.\n+ * @author Stephen Kestle\n+ * @since Commons Collections 4.0\n+ * @version $Revision$ $Date$\n+ */\n+public interface Equator<T> {\n+    /**\n+     * Evaluates the two arguments for their equality.\n+     * \n+     * @param o1 the first object to be equated.\n+     * @param o2 the second object to be equated.\n+     * @return whether the two objects are equal.\n+     */\n+    boolean equate(T o1, T o2);\n+\n+    /**\n+     * Calculates the hash for the object, based on the method of equality used in the equate\n+     * method. This is used for classes that delegate their {@link #equals(Object)} method to an\n+     * Equator (and so must also delegate their {@link #hashCode()} method), or for implementations\n+     * of {@link HashedMap} that use an Equator for the key objects.\n+     * \n+     * @param o the object to calculate the hash for.\n+     * @return the hash of the object.\n+     */\n+    int hash(T o);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.FunctorException;\n+\n+/**\n+ * Closure implementation that always throws an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Closure<Object> INSTANCE = new ExceptionClosure<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     * \n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> exceptionClosure() {\n+        return (Closure<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionClosure() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throw an exception.\n+     * \n+     * @param input  the input object\n+     * @throws FunctorException always\n+     */\n+    public void execute(E input) {\n+        throw new FunctorException(\"ExceptionClosure invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FunctorException;\n+\n+/**\n+ * Factory implementation that always throws an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionFactory<T> implements Factory<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Factory<Object> INSTANCE = new ExceptionFactory<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     * \n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> exceptionFactory() {\n+        return (Factory<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionFactory() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throws an exception.\n+     * \n+     * @return never\n+     * @throws FunctorException always\n+     */\n+    public T create() {\n+        throw new FunctorException(\"ExceptionFactory invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.FunctorException;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that always throws an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<Object> INSTANCE = new ExceptionPredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> exceptionPredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionPredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate always throwing an exception.\n+     *\n+     * @param object  the input object\n+     * @return never\n+     * @throws FunctorException always\n+     */\n+    public boolean evaluate(T object) {\n+        throw new FunctorException(\"ExceptionPredicate invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.FunctorException;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that always throws an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class ExceptionTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, Object> INSTANCE = new ExceptionTransformer<Object, Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> exceptionTransformer() {\n+        return (Transformer<I, O>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by cloning it.\n+     *\n+     * @param input  the input object to transform\n+     * @return never\n+     * @throws FunctorException always\n+     */\n+    public O transform(I input) {\n+        throw new FunctorException(\"ExceptionTransformer invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/FactoryTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Factory and returns the result.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FactoryTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -6817674502475353160L;\n+\n+    /** The factory to wrap */\n+    private final Factory<? extends O> iFactory;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param factory  the factory to call, not null\n+     * @return the <code>factory</code> transformer\n+     * @throws IllegalArgumentException if the factory is null\n+     */\n+    public static <I, O> Transformer<I, O> factoryTransformer(Factory<? extends O> factory) {\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        return new FactoryTransformer<I, O>(factory);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param factory  the factory to call, not null\n+     */\n+    public FactoryTransformer(Factory<? extends O> factory) {\n+        super();\n+        iFactory = factory;\n+    }\n+\n+    /**\n+     * Transforms the input by ignoring the input and returning the result of\n+     * calling the decorated factory.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public O transform(I input) {\n+        return iFactory.create();\n+    }\n+\n+    /**\n+     * Gets the factory.\n+     * \n+     * @return the factory\n+     * @since Commons Collections 3.1\n+     */\n+    public Factory<? extends O> getFactory() {\n+        return iFactory;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/FalsePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that always returns false.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class FalsePredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7533784454832764388L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<Object> INSTANCE = new FalsePredicate<Object>();\n+\n+    /**\n+     * Get a typed instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 4.0\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> falsePredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FalsePredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning false always.\n+     *\n+     * @param object  the input object\n+     * @return false always\n+     */\n+    public boolean evaluate(T object) {\n+        return false;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/ForClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+\n+/**\n+ * Closure implementation that calls another closure n times, like a for loop.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ForClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -1190120533393621674L;\n+\n+    /** The number of times to loop */\n+    private final int iCount;\n+    /** The closure to call */\n+    private final Closure<? super E> iClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * A null closure or zero count returns the <code>NOPClosure</code>.\n+     * A count of one returns the specified closure.\n+     * \n+     * @param count  the number of times to execute the closure\n+     * @param closure  the closure to execute, not null\n+     * @return the <code>for</code> closure\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> forClosure(int count, Closure<? super E> closure) {\n+        if (count <= 0 || closure == null) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        if (count == 1) {\n+            return (Closure<E>) closure;\n+        }\n+        return new ForClosure<E>(count, closure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param count  the number of times to execute the closure\n+     * @param closure  the closure to execute, not null\n+     */\n+    public ForClosure(int count, Closure<? super E> closure) {\n+        super();\n+        iCount = count;\n+        iClosure = closure;\n+    }\n+\n+    /**\n+     * Executes the closure <code>count</code> times.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(E input) {\n+        for (int i = 0; i < iCount; i++) {\n+            iClosure.execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the closure.\n+     * \n+     * @return the closure\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super E> getClosure() {\n+        return iClosure;\n+    }\n+\n+    /**\n+     * Gets the count.\n+     * \n+     * @return the count\n+     * @since Commons Collections 3.1\n+     */\n+    public int getCount() {\n+        return iCount;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/FunctorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Internal utilities for functors.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+class FunctorUtils {\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FunctorUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Clone the predicates to ensure that the internal reference can't be messed with.\n+     * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n+     * able to be coerced to Predicate<T> without casting issues.\n+     *\n+     * @param predicates  the predicates to copy\n+     * @return the cloned predicates\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T>[] copy(Predicate<? super T>[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate<T>[]) predicates.clone();\n+    }\n+\n+    /**\n+     * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n+     * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n+     * able to be coerced to Predicate<T> without casting issues.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned predicate should \"accept\"\n+     * @param predicate the predicate to coerce.\n+     * @return the coerced predicate.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T> coerce(Predicate<? super T> predicate){\n+        return (Predicate<T>) predicate;\n+    }\n+\n+    /**\n+     * Validate the predicates to ensure that all is well.\n+     *\n+     * @param predicates  the predicates to validate\n+     */\n+    static void validate(Predicate<?>[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate the predicates to ensure that all is well.\n+     *\n+     * @param predicates  the predicates to validate\n+     * @return predicate array\n+     */\n+    static <T> Predicate<T>[] validate(Collection<? extends Predicate<T>> predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate collection must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        @SuppressWarnings(\"unchecked\") // OK\n+        Predicate<T>[] preds = new Predicate[predicates.size()];\n+        int i = 0;\n+        for (Predicate<T> predicate : predicates) {\n+            preds[i] = predicate;\n+            if (preds[i] == null) {\n+                throw new IllegalArgumentException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+            i++;\n+        }\n+        return preds;\n+    }\n+\n+    /**\n+     * Clone the closures to ensure that the internal reference can't be messed with.\n+     *\n+     * @param closures  the closures to copy\n+     * @return the cloned closures\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> Closure<E>[] copy(Closure<? super E>[] closures) {\n+        if (closures == null) {\n+            return null;\n+        }\n+        return (Closure<E>[]) closures.clone();\n+    }\n+\n+    /**\n+     * Validate the closures to ensure that all is well.\n+     *\n+     * @param closures  the closures to validate\n+     */\n+    static void validate(Closure<?>[] closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"The closure array must not be null\");\n+        }\n+        for (int i = 0; i < closures.length; i++) {\n+            if (closures[i] == null) {\n+                throw new IllegalArgumentException(\"The closure array must not contain a null closure, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A very simple method that coerces Closure<? super T> to Closure<T>.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned closure should \"accept\"\n+     * @param closure the closure to coerce.\n+     * @return the coerced closure.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Closure<T> coerce(Closure<? super T> closure){\n+        return (Closure<T>) closure;\n+    }\n+\n+    /**\n+     * Copy method\n+     *\n+     * @param transformers  the transformers to copy\n+     * @return a clone of the transformers\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <I, O> Transformer<I, O>[] copy(Transformer<? super I, ? extends O>[] transformers) {\n+        if (transformers == null) {\n+            return null;\n+        }\n+        return (Transformer<I, O>[]) transformers.clone();\n+    }\n+\n+    /**\n+     * Validate method\n+     *\n+     * @param transformers  the transformers to validate\n+     */\n+    static void validate(Transformer<?, ?>[] transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"The transformer array must not be null\");\n+        }\n+        for (int i = 0; i < transformers.length; i++) {\n+            if (transformers[i] == null) {\n+                throw new IllegalArgumentException(\n+                    \"The transformer array must not contain a null transformer, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned transformer should \"accept\"\n+     * @param transformer the transformer to coerce.\n+     * @return the coerced transformer.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <I, O> Transformer<I, O> coerce(Transformer<? super I, ? extends O> transformer) {\n+        return (Transformer<I, O>) transformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/IdentityPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is the same object\n+ * as the one stored in this predicate.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class IdentityPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -89901658494523293L;\n+\n+    /** The value to compare to */\n+    private final T iValue;\n+\n+    /**\n+     * Factory to create the identity predicate.\n+     *\n+     * @param object  the object to compare to\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> identityPredicate(T object) {\n+        if (object == null) {\n+            return NullPredicate.<T>nullPredicate();\n+        }\n+        return new IdentityPredicate<T>(object);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param object  the object to compare to\n+     */\n+    public IdentityPredicate(T object) {\n+        super();\n+        iValue = object;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input object is identical to\n+     * the stored object.\n+     *\n+     * @param object  the input object\n+     * @return true if input is the same object as the stored value\n+     */\n+    public boolean evaluate(T object) {\n+        return (iValue == object);\n+    }\n+\n+    /**\n+     * Gets the value.\n+     *\n+     * @return the value\n+     * @since Commons Collections 3.1\n+     */\n+    public T getValue() {\n+        return iValue;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/IfClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Closure implementation acts as an if statement calling one or other closure\n+ * based on a predicate.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class IfClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** The test */\n+    private final Predicate<? super E> iPredicate;\n+    /** The closure to use if true */\n+    private final Closure<? super E> iTrueClosure;\n+    /** The closure to use if false */\n+    private final Closure<? super E> iFalseClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * This factory creates a closure that performs no action when\n+     * the predicate is false.\n+     * \n+     * @param predicate  predicate to switch on\n+     * @param trueClosure  closure used if true\n+     * @return the <code>if</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+        return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n+    }\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param predicate  predicate to switch on\n+     * @param trueClosure  closure used if true\n+     * @param falseClosure  closure used if false\n+     * @return the <code>if</code> closure\n+     * @throws IllegalArgumentException if any argument is null\n+     */\n+    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        if (trueClosure == null || falseClosure == null) {\n+            throw new IllegalArgumentException(\"Closures must not be null\");\n+        }\n+        return new IfClosure<E>(predicate, trueClosure, falseClosure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * <p>\n+     * This constructor creates a closure that performs no action when\n+     * the predicate is false.\n+     * \n+     * @param predicate  predicate to switch on, not null\n+     * @param trueClosure  closure used if true, not null\n+     * @since Commons Collections 3.2\n+     */\n+    public IfClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+        this(predicate, trueClosure, NOPClosure.INSTANCE);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  predicate to switch on, not null\n+     * @param trueClosure  closure used if true, not null\n+     * @param falseClosure  closure used if false, not null\n+     */\n+    public IfClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n+        super();\n+        iPredicate = predicate;\n+        iTrueClosure = trueClosure;\n+        iFalseClosure = falseClosure;\n+    }\n+\n+    /**\n+     * Executes the true or false closure accoring to the result of the predicate.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(E input) {\n+        if (iPredicate.evaluate(input)) {\n+            iTrueClosure.execute(input);\n+        } else {\n+            iFalseClosure.execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the predicate.\n+     * \n+     * @return the predicate\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return iPredicate;\n+    }\n+\n+    /**\n+     * Gets the closure called when true.\n+     * \n+     * @return the closure\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super E> getTrueClosure() {\n+        return iTrueClosure;\n+    }\n+\n+    /**\n+     * Gets the closure called when false.\n+     * \n+     * @return the closure\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super E> getFalseClosure() {\n+        return iFalseClosure;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/InstanceofPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is an instanceof\n+ * the type stored in this predicate.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class InstanceofPredicate implements Predicate<Object>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -6682656911025165584L;\n+\n+    /** The type to compare to */\n+    private final Class<?> iType;\n+\n+    /**\n+     * Factory to create the identity predicate.\n+     *\n+     * @param type  the type to check for, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Predicate<Object> instanceOfPredicate(Class<?> type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n+        }\n+        return new InstanceofPredicate(type);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param type  the type to check for\n+     */\n+    public InstanceofPredicate(Class<?> type) {\n+        super();\n+        iType = type;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input object is of the correct type.\n+     *\n+     * @param object  the input object\n+     * @return true if input is of stored type\n+     */\n+    public boolean evaluate(Object object) {\n+        return (iType.isInstance(object));\n+    }\n+\n+    /**\n+     * Gets the type to compare to.\n+     *\n+     * @return the type\n+     * @since Commons Collections 3.1\n+     */\n+    public Class<?> getType() {\n+        return iType;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/InstantiateFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FunctorException;\n+\n+/**\n+ * Factory implementation that creates a new object instance by reflection.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class InstantiateFactory<T> implements Factory<T>, Serializable {\n+\n+    /** The serial version */\n+    private static final long serialVersionUID = -7732226881069447957L;\n+\n+    /** The class to create */\n+    private final Class<T> iClassToInstantiate;\n+    /** The constructor parameter types */\n+    private final Class<?>[] iParamTypes;\n+    /** The constructor arguments */\n+    private final Object[] iArgs;\n+    /** The constructor */\n+    private transient Constructor<T> iConstructor = null;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param classToInstantiate  the class to instantiate, not null\n+     * @param paramTypes  the constructor parameter types\n+     * @param args  the constructor arguments\n+     * @return a new instantiate factory\n+     */\n+    public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+        if (classToInstantiate == null) {\n+            throw new IllegalArgumentException(\"Class to instantiate must not be null\");\n+        }\n+        if (((paramTypes == null) && (args != null))\n+            || ((paramTypes != null) && (args == null))\n+            || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+            throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n+        }\n+\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            return new InstantiateFactory<T>(classToInstantiate);\n+        }\n+        paramTypes = paramTypes.clone();\n+        args = args.clone();\n+        return new InstantiateFactory<T>(classToInstantiate, paramTypes, args);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param classToInstantiate  the class to instantiate\n+     */\n+    public InstantiateFactory(Class<T> classToInstantiate) {\n+        super();\n+        iClassToInstantiate = classToInstantiate;\n+        iParamTypes = null;\n+        iArgs = null;\n+        findConstructor();\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param classToInstantiate  the class to instantiate\n+     * @param paramTypes  the constructor parameter types, not cloned\n+     * @param args  the constructor arguments, not cloned\n+     */\n+    public InstantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+        super();\n+        iClassToInstantiate = classToInstantiate;\n+        iParamTypes = paramTypes;\n+        iArgs = args;\n+        findConstructor();\n+    }\n+\n+    /**\n+     * Find the Constructor for the class specified.\n+     */\n+    private void findConstructor() {\n+        try {\n+            iConstructor = iClassToInstantiate.getConstructor(iParamTypes);\n+\n+        } catch (NoSuchMethodException ex) {\n+            throw new IllegalArgumentException(\"InstantiateFactory: The constructor must exist and be public \");\n+        }\n+    }\n+\n+    /**\n+     * Creates an object using the stored constructor.\n+     * \n+     * @return the new object\n+     */\n+    public T create() {\n+        // needed for post-serialization\n+        if (iConstructor == null) {\n+            findConstructor();\n+        }\n+\n+        try {\n+            return iConstructor.newInstance(iArgs);\n+        } catch (InstantiationException ex) {\n+            throw new FunctorException(\"InstantiateFactory: InstantiationException\", ex);\n+        } catch (IllegalAccessException ex) {\n+            throw new FunctorException(\"InstantiateFactory: Constructor must be public\", ex);\n+        } catch (InvocationTargetException ex) {\n+            throw new FunctorException(\"InstantiateFactory: Constructor threw an exception\", ex);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.apache.commons.collections.FunctorException;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that creates a new object instance by reflection.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class InstantiateTransformer<T> implements Transformer<Class<? extends T>, T>, Serializable {\n+\n+    /** The serial version */\n+    private static final long serialVersionUID = 3786388740793356347L;\n+\n+    /** Singleton instance that uses the no arg constructor */\n+    public static final Transformer<Class<?>, ?> NO_ARG_INSTANCE = new InstantiateTransformer<Object>();\n+\n+    /** The constructor parameter types */\n+    private final Class<?>[] iParamTypes;\n+    /** The constructor arguments */\n+    private final Object[] iArgs;\n+\n+    /**\n+     * Get a typed no-arg instance.\n+     * @param <T>\n+     * @return Transformer<Class<? extends T>, T>\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n+        return new InstantiateTransformer<T>();\n+    }\n+\n+    /**\n+     * Transformer method that performs validation.\n+     *\n+     * @param paramTypes  the constructor parameter types\n+     * @param args  the constructor arguments\n+     * @return an instantiate transformer\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(Class<?>[] paramTypes, Object[] args) {\n+        if (((paramTypes == null) && (args != null))\n+            || ((paramTypes != null) && (args == null))\n+            || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+            throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n+        }\n+\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            return new InstantiateTransformer<T>();\n+        }\n+        paramTypes = paramTypes.clone();\n+        args = args.clone();\n+        return new InstantiateTransformer<T>(paramTypes, args);\n+    }\n+\n+    /**\n+     * Constructor for no arg instance.\n+     */\n+    private InstantiateTransformer() {\n+        super();\n+        iParamTypes = null;\n+        iArgs = null;\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param paramTypes  the constructor parameter types, not cloned\n+     * @param args  the constructor arguments, not cloned\n+     */\n+    public InstantiateTransformer(Class<?>[] paramTypes, Object[] args) {\n+        super();\n+        iParamTypes = paramTypes;\n+        iArgs = args;\n+    }\n+\n+    /**\n+     * Transforms the input Class object to a result by instantiation.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public T transform(Class<? extends T> input) {\n+        try {\n+            if (input == null) {\n+                throw new FunctorException(\n+                    \"InstantiateTransformer: Input object was not an instanceof Class, it was a null object\");\n+            }\n+            Constructor<? extends T> con = input.getConstructor(iParamTypes);\n+            return con.newInstance(iArgs);\n+        } catch (NoSuchMethodException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: The constructor must exist and be public \");\n+        } catch (InstantiationException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: InstantiationException\", ex);\n+        } catch (IllegalAccessException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: Constructor must be public\", ex);\n+        } catch (InvocationTargetException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: Constructor threw an exception\", ex);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/InvokerTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.apache.commons.collections.FunctorException;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that creates a new object instance by reflection.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class InvokerTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** The serial version */\n+    private static final long serialVersionUID = -8653385846894047688L;\n+    \n+    /** The method name to call */\n+    private final String iMethodName;\n+    /** The array of reflection parameter types */\n+    private final Class<?>[] iParamTypes;\n+    /** The array of reflection arguments */\n+    private final Object[] iArgs;\n+\n+    /**\n+     * Gets an instance of this transformer calling a specific method with no arguments.\n+     * \n+     * @param methodName  the method name to call\n+     * @return an invoker transformer\n+     * @since Commons Collections 3.1\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(String methodName) {\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method to invoke must not be null\");\n+        }\n+        return new InvokerTransformer<I, O>(methodName);\n+    }\n+\n+    /**\n+     * Gets an instance of this transformer calling a specific method with specific values.\n+     * \n+     * @param methodName  the method name to call\n+     * @param paramTypes  the parameter types of the method\n+     * @param args  the arguments to pass to the method\n+     * @return an invoker transformer\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args) {\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method to invoke must not be null\");\n+        }\n+        if (((paramTypes == null) && (args != null))\n+            || ((paramTypes != null) && (args == null))\n+            || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+            throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n+        }\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            return new InvokerTransformer<I, O>(methodName);\n+        } else {\n+            paramTypes = paramTypes.clone();\n+            args = args.clone();\n+            return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n+        }\n+    }\n+\n+    /**\n+     * Constructor for no arg instance.\n+     * \n+     * @param methodName  the method to call\n+     */\n+    private InvokerTransformer(String methodName) {\n+        super();\n+        iMethodName = methodName;\n+        iParamTypes = null;\n+        iArgs = null;\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param methodName  the method to call\n+     * @param paramTypes  the constructor parameter types, not cloned\n+     * @param args  the constructor arguments, not cloned\n+     */\n+    public InvokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args) {\n+        super();\n+        iMethodName = methodName;\n+        iParamTypes = paramTypes;\n+        iArgs = args;\n+    }\n+\n+    /**\n+     * Transforms the input to result by invoking a method on the input.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result, null if null input\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public O transform(Object input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        try {\n+            Class<?> cls = input.getClass();\n+            Method method = cls.getMethod(iMethodName, iParamTypes);\n+            return (O) method.invoke(input, iArgs);\n+        } catch (NoSuchMethodException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n+        } catch (IllegalAccessException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n+        } catch (InvocationTargetException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/MapTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the value held in a specified map\n+ * using the input parameter as a key.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class MapTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 862391807045468939L;\n+\n+    /** The map of data to lookup in */\n+    private final Map<? super I, ? extends O> iMap;\n+\n+    /**\n+     * Factory to create the transformer.\n+     * <p>\n+     * If the map is null, a transformer that always returns null is returned.\n+     *\n+     * @param map the map, not cloned\n+     * @return the transformer\n+     */\n+    public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {\n+        if (map == null) {\n+            return ConstantTransformer.<I, O>nullTransformer();\n+        }\n+        return new MapTransformer<I, O>(map);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param map  the map to use for lookup, not cloned\n+     */\n+    private MapTransformer(Map<? super I, ? extends O> map) {\n+        super();\n+        iMap = map;\n+    }\n+\n+    /**\n+     * Transforms the input to result by looking it up in a <code>Map</code>.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public O transform(I input) {\n+        return iMap.get(input);\n+    }\n+\n+    /**\n+     * Gets the map to lookup in.\n+     *\n+     * @return the map\n+     * @since Commons Collections 3.1\n+     */\n+    public Map<? super I, ? extends O> getMap() {\n+        return iMap;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NOPClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+\n+/**\n+ * Closure implementation that does nothing.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class NOPClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** Singleton predicate instance */\n+    public static final Closure<Object> INSTANCE = new NOPClosure<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> nopClosure() {\n+        return (Closure<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    private NOPClosure() {\n+        super();\n+    }\n+\n+    /**\n+     * Do nothing.\n+     *\n+     * @param input  the input object\n+     */\n+    public void execute(E input) {\n+        // do nothing\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NOPTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that does nothing.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class NOPTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 2133891748318574490L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, Object> INSTANCE = new NOPTransformer<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> nopTransformer() {\n+        return (Transformer<T, T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    private NOPTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by doing nothing.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result which is the input\n+     */\n+    public T transform(T input) {\n+        return input;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NonePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if none of the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns true.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public final class NonePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 2007613066565892961L;\n+\n+    /** The array of predicates to call */\n+    private final Predicate<? super T>[] iPredicates;\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns true.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> nonePredicate(Predicate<? super T>... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return TruePredicate.<T>truePredicate();\n+        }\n+        predicates = FunctorUtils.copy(predicates);\n+        return new NonePredicate<T>(predicates);\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the collection is size zero, the predicate always returns true.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> nonePredicate(Collection<? extends Predicate<T>> predicates) {\n+        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+        if (preds.length == 0) {\n+            return TruePredicate.<T>truePredicate();\n+        }\n+        return new NonePredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public NonePredicate(Predicate<? super T>[] predicates) {\n+        super();\n+        iPredicates = predicates;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning false if any stored predicate returns false.\n+     *\n+     * @param object  the input object\n+     * @return true if none of decorated predicates return true\n+     */\n+    public boolean evaluate(T object) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(object)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the predicates, do not modify the array.\n+     *\n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super T>[] getPredicates() {\n+        return iPredicates;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NotNullPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is not null.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class NotNullPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7533784454832764388L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<Object> INSTANCE = new NotNullPredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> notNullPredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private NotNullPredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the object does not equal null.\n+     *\n+     * @param object  the object to evaluate\n+     * @return true if not null\n+     */\n+    public boolean evaluate(T object) {\n+        return (object != null);\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NotPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns the opposite of the decorated predicate.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class NotPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -2654603322338049674L;\n+    \n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+    \n+    /**\n+     * Factory to create the not predicate.\n+     * \n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> notPredicate(Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NotPredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NotPredicate(Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the opposite to the stored predicate.\n+     * \n+     * @param object  the input object\n+     * @return true if predicate returns false\n+     */\n+    public boolean evaluate(T object) {\n+        return !(iPredicate.evaluate(object));\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     * \n+     * @return the predicate as the only element in an array\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate};\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NullIsExceptionPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.FunctorException;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that throws an exception if the input is null.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class NullIsExceptionPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3243449850504576071L;\n+    \n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+    \n+    /**\n+     * Factory to create the null exception predicate.\n+     * \n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> nullIsExceptionPredicate(Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NullIsExceptionPredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NullIsExceptionPredicate(Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once a null check is performed.\n+     * \n+     * @param object  the input object\n+     * @return true if decorated predicate returns true\n+     * @throws FunctorException if input is null\n+     */\n+    public boolean evaluate(T object) {\n+        if (object == null) {\n+            throw new FunctorException(\"Input Object must not be null\");\n+        }\n+        return iPredicate.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     * \n+     * @return the predicate as the only element in an array\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NullIsFalsePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns false if the input is null.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class NullIsFalsePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -2997501534564735525L;\n+\n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+\n+    /**\n+     * Factory to create the null false predicate.\n+     *\n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> nullIsFalsePredicate(Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NullIsFalsePredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NullIsFalsePredicate(Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once a null check is performed.\n+     *\n+     * @param object  the input object\n+     * @return true if decorated predicate returns true, false if input is null\n+     */\n+    public boolean evaluate(T object) {\n+        if (object == null) {\n+            return false;\n+        }\n+        return iPredicate.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     *\n+     * @return the predicate as the only element in an array\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NullIsTruePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is null.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class NullIsTruePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -7625133768987126273L;\n+    \n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+    \n+    /**\n+     * Factory to create the null true predicate.\n+     * \n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> nullIsTruePredicate(Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NullIsTruePredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NullIsTruePredicate(Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once a null check is performed.\n+     * \n+     * @param object  the input object\n+     * @return true if decorated predicate returns true or input is null\n+     */\n+    public boolean evaluate(T object) {\n+        if (object == null) {\n+            return true;\n+        }\n+        return iPredicate.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     * \n+     * @return the predicate as the only element in an array\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/NullPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is null.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class NullPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7533784454832764388L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<?> INSTANCE = new NullPredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> nullPredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private NullPredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input is null.\n+     *\n+     * @param object  the input object\n+     * @return true if input is null\n+     */\n+    public boolean evaluate(Object object) {\n+        return (object == null);\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/OnePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if only one of the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns false.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public final class OnePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -8125389089924745785L;\n+    \n+    /** The array of predicates to call */\n+    private final Predicate<? super T>[] iPredicates;\n+    \n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns false.\n+     * If the array is size one, then that predicate is returned.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> onePredicate(Predicate<? super T>... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return FalsePredicate.<T>falsePredicate();\n+        }\n+        if (predicates.length == 1) {\n+            return (Predicate<T>) predicates[0];\n+        }\n+        predicates = FunctorUtils.copy(predicates);\n+        return new OnePredicate<T>(predicates);\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> onePredicate(Collection<? extends Predicate<T>> predicates) {\n+        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+        return new OnePredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public OnePredicate(Predicate<? super T>[] predicates) {\n+        super();\n+        iPredicates = predicates;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if only one decorated predicate\n+     * returns true.\n+     * \n+     * @param object  the input object\n+     * @return true if only one decorated predicate returns true\n+     */\n+    public boolean evaluate(T object) {\n+        boolean match = false;\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(object)) {\n+                if (match) {\n+                    return false;\n+                }\n+                match = true;\n+            }\n+        }\n+        return match;\n+    }\n+\n+    /**\n+     * Gets the predicates, do not modify the array.\n+     * \n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super T>[] getPredicates() {\n+        return iPredicates;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/OrPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if either of the predicates return true.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class OrPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -8791518325735182855L;\n+\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate1;\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate2;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     * @return the <code>and</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static <T> Predicate<T> orPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        if (predicate1 == null || predicate2 == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new OrPredicate<T>(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     */\n+    public OrPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+        super();\n+        iPredicate1 = predicate1;\n+        iPredicate2 = predicate2;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if either predicate returns true.\n+     *\n+     * @param object  the input object\n+     * @return true if either decorated predicate returns true\n+     */\n+    public boolean evaluate(T object) {\n+       return (iPredicate1.evaluate(object) || iPredicate2.evaluate(object));\n+    }\n+\n+    /**\n+     * Gets the two predicates being decorated as an array.\n+     *\n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate1, iPredicate2};\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/PredicateDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Defines a predicate that decorates one or more other predicates.\n+ * <p>\n+ * This interface enables tools to access the decorated predicates.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Stephen Kestle\n+ */\n+public interface PredicateDecorator<T> extends Predicate<T> {\n+\n+    /**\n+     * Gets the predicates being decorated as an array.\n+     * <p>\n+     * The array may be the internal data structure of the predicate and thus\n+     * should not be altered.\n+     * \n+     * @return the predicates being decorated\n+     */\n+    Predicate<? super T>[] getPredicates();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/PredicateTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Predicate using the input object\n+ * and then returns the result.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class PredicateTransformer<T> implements Transformer<T, Boolean>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 5278818408044349346L;\n+\n+    /** The closure to wrap */\n+    private final Predicate<? super T> iPredicate;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param predicate  the predicate to call, not null\n+     * @return the <code>predicate</code> transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Transformer<T, Boolean> predicateTransformer(Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new PredicateTransformer<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call, not null\n+     */\n+    public PredicateTransformer(Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Transforms the input to result by calling a predicate.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public Boolean transform(T input) {\n+        return Boolean.valueOf(iPredicate.evaluate(input));\n+    }\n+\n+    /**\n+     * Gets the predicate.\n+     * \n+     * @return the predicate\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super T> getPredicate() {\n+        return iPredicate;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/PrototypeFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FunctorException;\n+\n+/**\n+ * Factory implementation that creates a new instance each time based on a prototype.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class PrototypeFactory {\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * Creates a Factory that will return a clone of the same prototype object\n+     * each time the factory is used. The prototype will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     *\n+     * @param prototype  the object to clone each time in the factory\n+     * @return the <code>prototype</code> factory\n+     * @throws IllegalArgumentException if the prototype is null\n+     * @throws IllegalArgumentException if the prototype cannot be cloned\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> prototypeFactory(T prototype) {\n+        if (prototype == null) {\n+            return ConstantFactory.<T>constantFactory(null);\n+        }\n+        try {\n+            Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n+            return new PrototypeCloneFactory<T>(prototype, method);\n+\n+        } catch (NoSuchMethodException ex) {\n+            try {\n+                prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n+                return new InstantiateFactory<T>(\n+                    (Class<T>) prototype.getClass(),\n+                    new Class<?>[] { prototype.getClass() },\n+                    new Object[] { prototype });\n+            } catch (NoSuchMethodException ex2) {\n+                if (prototype instanceof Serializable) {\n+                    return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     */\n+    private PrototypeFactory() {\n+        super();\n+    }\n+\n+    // PrototypeCloneFactory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n+     */\n+    static class PrototypeCloneFactory<T> implements Factory<T>, Serializable {\n+        \n+        /** The serial version */\n+        private static final long serialVersionUID = 5604271422565175555L;\n+        \n+        /** The object to clone each time */\n+        private final T iPrototype;\n+        /** The method used to clone */\n+        private transient Method iCloneMethod;\n+\n+        /**\n+         * Constructor to store prototype.\n+         */\n+        private PrototypeCloneFactory(T prototype, Method method) {\n+            super();\n+            iPrototype = prototype;\n+            iCloneMethod = method;\n+        }\n+\n+        /**\n+         * Find the Clone method for the class specified.\n+         */\n+        private void findCloneMethod() {\n+            try {\n+                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n+            } catch (NoSuchMethodException ex) {\n+                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n+            }\n+        }\n+\n+        /**\n+         * Creates an object by calling the clone method.\n+         * \n+         * @return the new object\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        public T create() {\n+            // needed for post-serialization\n+            if (iCloneMethod == null) {\n+                findCloneMethod();\n+            }\n+\n+            try {\n+                return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n+            } catch (IllegalAccessException ex) {\n+                throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n+            } catch (InvocationTargetException ex) {\n+                throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+    // PrototypeSerializationFactory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n+     */\n+    static class PrototypeSerializationFactory<T extends Serializable> implements Factory<T>, Serializable {\n+        \n+        /** The serial version */\n+        private static final long serialVersionUID = -8704966966139178833L;\n+        \n+        /** The object to clone via serialization each time */\n+        private final T iPrototype;\n+\n+        /**\n+         * Constructor to store prototype\n+         */\n+        private PrototypeSerializationFactory(T prototype) {\n+            super();\n+            iPrototype = prototype;\n+        }\n+\n+        /**\n+         * Creates an object using serialization.\n+         * \n+         * @return the new object\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        public T create() {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+            ByteArrayInputStream bais = null;\n+            try {\n+                ObjectOutputStream out = new ObjectOutputStream(baos);\n+                out.writeObject(iPrototype);\n+\n+                bais = new ByteArrayInputStream(baos.toByteArray());\n+                ObjectInputStream in = new ObjectInputStream(bais);\n+                return (T) in.readObject();\n+\n+            } catch (ClassNotFoundException ex) {\n+                throw new FunctorException(ex);\n+            } catch (IOException ex) {\n+                throw new FunctorException(ex);\n+            } finally {\n+                try {\n+                    if (bais != null) {\n+                        bais.close();\n+                    }\n+                } catch (IOException ex) {\n+                    // ignore\n+                }\n+                try {\n+                    baos.close();\n+                } catch (IOException ex) {\n+                    // ignore\n+                }\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/StringValueTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the result of calling\n+ * <code>String.valueOf</code> on the input object.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class StringValueTransformer<T> implements Transformer<T, String>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7511110693171758606L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, String> INSTANCE = new StringValueTransformer<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, String> stringValueTransformer() {\n+        return (Transformer<T, String>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private StringValueTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by calling <code>String.valueOf</code>.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public String transform(T input) {\n+        return String.valueOf(input);\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/SwitchClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Closure implementation calls the closure whose predicate returns true,\n+ * like a switch statement.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SwitchClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** The tests to consider */\n+    private final Predicate<? super E>[] iPredicates;\n+    /** The matching closures to call */\n+    private final Closure<? super E>[] iClosures;\n+    /** The default closure to call if no tests match */\n+    private final Closure<? super E> iDefault;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter arrays.\n+     *\n+     * @param predicates  array of predicates, cloned, no nulls\n+     * @param closures  matching array of closures, cloned, no nulls\n+     * @param defaultClosure  the closure to use if no match, null means nop\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if array is null\n+     * @throws IllegalArgumentException if any element in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n+        FunctorUtils.validate(predicates);\n+        FunctorUtils.validate(closures);\n+        if (predicates.length != closures.length) {\n+            throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n+        }\n+        if (predicates.length == 0) {\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure(): defaultClosure);\n+        }\n+        predicates = FunctorUtils.copy(predicates);\n+        closures = FunctorUtils.copy(closures);\n+        return new SwitchClosure<E>(predicates, closures, defaultClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending\n+     * on the predicates.\n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A closure\n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called. The default closure is set in the map with a\n+     * null key. The ordering is that of the iterator() method on the entryset\n+     * collection of the map.\n+     *\n+     * @param predicatesAndClosures  a map of predicates to closures\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> switchClosure(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n+        if (predicatesAndClosures == null) {\n+            throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n+        int size = predicatesAndClosures.size();\n+        if (size == 0) {\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n+        }\n+        Closure<E>[] closures = new Closure[size];\n+        Predicate<E>[] preds = new Predicate[size];\n+        int i = 0;\n+        for (Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n+            preds[i] = entry.getKey();\n+            closures[i] = entry.getValue();\n+            i++;\n+        }\n+        return new SwitchClosure<E>(preds, closures, defaultClosure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  array of predicates, not cloned, no nulls\n+     * @param closures  matching array of closures, not cloned, no nulls\n+     * @param defaultClosure  the closure to use if no match, null means nop\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public SwitchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures, Closure<? super E> defaultClosure) {\n+        super();\n+        iPredicates = predicates;\n+        iClosures = closures;\n+        iDefault = (Closure<? super E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n+    }\n+\n+    /**\n+     * Executes the closure whose matching predicate returns true\n+     *\n+     * @param input  the input object\n+     */\n+    public void execute(E input) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(input) == true) {\n+                iClosures[i].execute(input);\n+                return;\n+            }\n+        }\n+        iDefault.execute(input);\n+    }\n+\n+    /**\n+     * Gets the predicates, do not modify the array.\n+     *\n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super E>[] getPredicates() {\n+        return iPredicates;\n+    }\n+\n+    /**\n+     * Gets the closures, do not modify the array.\n+     *\n+     * @return the closures\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super E>[] getClosures() {\n+        return iClosures;\n+    }\n+\n+    /**\n+     * Gets the default closure.\n+     *\n+     * @return the default closure\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super E> getDefaultClosure() {\n+        return iDefault;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/SwitchTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Transformer implementation calls the transformer whose predicate returns true,\n+ * like a switch statement.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SwitchTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -6404460890903469332L;\n+\n+    /** The tests to consider */\n+    private final Predicate<? super I>[] iPredicates;\n+    /** The matching transformers to call */\n+    private final Transformer<? super I, ? extends O>[] iTransformers;\n+    /** The default transformer to call if no tests match */\n+    private final Transformer<? super I, ? extends O> iDefault;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter arrays.\n+     * \n+     * @param predicates  array of predicates, cloned, no nulls\n+     * @param transformers  matching array of transformers, cloned, no nulls\n+     * @param defaultTransformer  the transformer to use if no match, null means return null\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if array is null\n+     * @throws IllegalArgumentException if any element in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n+            Transformer<? super I, ? extends O>[] transformers,\n+            Transformer<? super I, ? extends O> defaultTransformer) {\n+        FunctorUtils.validate(predicates);\n+        FunctorUtils.validate(transformers);\n+        if (predicates.length != transformers.length) {\n+            throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n+        }\n+        if (predicates.length == 0) {\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n+        }\n+        predicates = FunctorUtils.copy(predicates);\n+        transformers = FunctorUtils.copy(transformers);\n+        return new SwitchTransformer<I, O>(predicates, transformers, defaultTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. The default transformer is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @param predicatesAndTransformers  a map of predicates to transformers\n+     * @return the <code>switch</code> transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchTransformer(\n+            Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> predicatesAndTransformers) {\n+        if (predicatesAndTransformers == null) {\n+            throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n+        }\n+        if (predicatesAndTransformers.size() == 0) {\n+            return ConstantTransformer.<I, O>nullTransformer();\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Transformer<? super I, ? extends O> defaultTransformer = predicatesAndTransformers.remove(null);\n+        int size = predicatesAndTransformers.size();\n+        if (size == 0) {\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n+        }\n+        Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n+        Predicate<? super I>[] preds = new Predicate[size];\n+        int i = 0;\n+        for (Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : predicatesAndTransformers.entrySet()) {\n+            preds[i] = entry.getKey();\n+            transformers[i] = entry.getValue();\n+            i++;\n+        }\n+        return new SwitchTransformer<I, O>(preds, transformers, defaultTransformer);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicates  array of predicates, not cloned, no nulls\n+     * @param transformers  matching array of transformers, not cloned, no nulls\n+     * @param defaultTransformer  the transformer to use if no match, null means return null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public SwitchTransformer(Predicate<? super I>[] predicates,\n+            Transformer<? super I, ? extends O>[] transformers,\n+            Transformer<? super I, ? extends O> defaultTransformer) {\n+        super();\n+        iPredicates = predicates;\n+        iTransformers = transformers;\n+        iDefault = (Transformer<? super I, ? extends O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n+    }\n+\n+    /**\n+     * Transforms the input to result by calling the transformer whose matching\n+     * predicate returns true.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public O transform(I input) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(input) == true) {\n+                return iTransformers[i].transform(input);\n+            }\n+        }\n+        return iDefault.transform(input);\n+    }\n+\n+    /**\n+     * Gets the predicates, do not modify the array.\n+     * \n+     * @return the predicates\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super I>[] getPredicates() {\n+        return iPredicates;\n+    }\n+\n+    /**\n+     * Gets the transformers, do not modify the array.\n+     * \n+     * @return the transformers\n+     * @since Commons Collections 3.1\n+     */\n+    public Transformer<? super I, ? extends O>[] getTransformers() {\n+        return iTransformers;\n+    }\n+\n+    /**\n+     * Gets the default transformer.\n+     * \n+     * @return the default transformer\n+     * @since Commons Collections 3.1\n+     */\n+    public Transformer<? super I, ? extends O> getDefaultTransformer() {\n+        return iDefault;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/TransformedPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Predicate implementation that transforms the given object before invoking\n+ * another <code>Predicate</code>.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ * @author Alban Peignier\n+ * @author Stephen Colebourne\n+ */\n+public final class TransformedPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -5596090919668315834L;\n+\n+    /** The transformer to call */\n+    private final Transformer<? super T, ? extends T> iTransformer;\n+\n+    /** The predicate to call */\n+    private final Predicate<? super T> iPredicate;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param transformer  the transformer to call\n+     * @param predicate  the predicate to call with the result of the transform\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the transformer or the predicate is null\n+     */\n+    public static <T> Predicate<T> transformedPredicate(Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate to call must not be null\");\n+        }\n+        return new TransformedPredicate<T>(transformer, predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param transformer  the transformer to use\n+     * @param predicate  the predicate to decorate\n+     */\n+    public TransformedPredicate(Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n+        iTransformer = transformer;\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once the input has been transformed\n+     *\n+     * @param object  the input object which will be transformed\n+     * @return true if decorated predicate returns true\n+     */\n+    public boolean evaluate(T object) {\n+        T result = iTransformer.transform(object);\n+        return iPredicate.evaluate(result);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     *\n+     * @return the predicate as the only element in an array\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate};\n+    }\n+\n+    /**\n+     * Gets the transformer in use.\n+     *\n+     * @return the transformer\n+     */\n+    public Transformer<? super T, ? extends T> getTransformer() {\n+        return iTransformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/TransformerClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Closure implementation that calls a Transformer using the input object\n+ * and ignore the result.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformerClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -5194992589193388969L;\n+\n+    /** The transformer to wrap */\n+    private final Transformer<? super E, ?> iTransformer;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * A null transformer will return the <code>NOPClosure</code>.\n+     * \n+     * @param transformer  the transformer to call, null means nop\n+     * @return the <code>transformer</code> closure\n+     */\n+    public static <E> Closure<E> transformerClosure(Transformer<? super E, ?> transformer) {\n+        if (transformer == null) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        return new TransformerClosure<E>(transformer);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param transformer  the transformer to call, not null\n+     */\n+    public TransformerClosure(Transformer<? super E, ?> transformer) {\n+        super();\n+        iTransformer = transformer;\n+    }\n+\n+    /**\n+     * Executes the closure by calling the decorated transformer.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(E input) {\n+        iTransformer.transform(input);\n+    }\n+\n+    /**\n+     * Gets the transformer.\n+     * \n+     * @return the transformer\n+     * @since Commons Collections 3.1\n+     */\n+    public Transformer<? super E, ?> getTransformer() {\n+        return iTransformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/TransformerPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.FunctorException;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Predicate implementation that returns the result of a transformer.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class TransformerPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -2407966402920578741L;\n+\n+    /** The transformer to call */\n+    private final Transformer<? super T, Boolean> iTransformer;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param transformer  the transformer to decorate\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the transformer is null\n+     */\n+    public static <T> Predicate<T> transformerPredicate(Transformer<? super T, Boolean> transformer) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n+        }\n+        return new TransformerPredicate<T>(transformer);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param transformer  the transformer to decorate\n+     */\n+    public TransformerPredicate(Transformer<? super T, Boolean> transformer) {\n+        super();\n+        iTransformer = transformer;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated transformer.\n+     *\n+     * @param object  the input object\n+     * @return true if decorated transformer returns Boolean.TRUE\n+     * @throws FunctorException if the transformer returns an invalid type\n+     */\n+    public boolean evaluate(T object) {\n+        Boolean result = iTransformer.transform(object);\n+        if (result == null) {\n+            throw new FunctorException(\n+                    \"Transformer must return an instanceof Boolean, it was a null object\");\n+        }\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * Gets the transformer.\n+     *\n+     * @return the transformer\n+     * @since Commons Collections 3.1\n+     */\n+    public Transformer<? super T, Boolean> getTransformer() {\n+        return iTransformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/TruePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that always returns true.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Stephen Kestle\n+ */\n+public final class TruePredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3374767158756189740L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<?> INSTANCE = new TruePredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @return the singleton instance\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> truePredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private TruePredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true always.\n+     *\n+     * @param object  the input object\n+     * @return true always\n+     */\n+    public boolean evaluate(T object) {\n+        return true;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/UniquePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true the first time an object is\n+ * passed into the predicate.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UniquePredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3319417438027438040L;\n+\n+    /** The set of previously seen objects */\n+    private final Set<T> iSet = new HashSet<T>();\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <E> Predicate<E> uniquePredicate() {\n+        return new UniquePredicate<E>();\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     */\n+    public UniquePredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input object hasn't been\n+     * received yet.\n+     *\n+     * @param object  the input object\n+     * @return true if this is the first time the object is seen\n+     */\n+    public boolean evaluate(T object) {\n+        return iSet.add(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/functors/WhileClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Closure implementation that executes a closure repeatedly until a condition is met,\n+ * like a do-while or while loop.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class WhileClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3110538116913760108L;\n+\n+    /** The test condition */\n+    private final Predicate<? super E> iPredicate;\n+    /** The closure to call */\n+    private final Closure<? super E> iClosure;\n+    /** The flag, true is a do loop, false is a while */\n+    private final boolean iDoLoop;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n+     * @param closure  the closure the execute, not null\n+     * @param doLoop  true to act as a do-while loop, always executing the closure once\n+     * @return the <code>while</code> closure\n+     * @throws IllegalArgumentException if the predicate or closure is null\n+     */\n+    public static <E> Closure<E> whileClosure(Predicate<? super E> predicate, Closure<? super E> closure, boolean doLoop) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"Closure must not be null\");\n+        }\n+        return new WhileClosure<E>(predicate, closure, doLoop);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n+     * @param closure  the closure the execute, not null\n+     * @param doLoop  true to act as a do-while loop, always executing the closure once\n+     */\n+    public WhileClosure(Predicate<? super E> predicate, Closure<? super E> closure, boolean doLoop) {\n+        super();\n+        iPredicate = predicate;\n+        iClosure = closure;\n+        iDoLoop = doLoop;\n+    }\n+\n+    /**\n+     * Executes the closure until the predicate is false.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(E input) {\n+        if (iDoLoop) {\n+            iClosure.execute(input);\n+        }\n+        while (iPredicate.evaluate(input)) {\n+            iClosure.execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the predicate in use.\n+     * \n+     * @return the predicate\n+     * @since Commons Collections 3.1\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return iPredicate;\n+    }\n+\n+    /**\n+     * Gets the closure.\n+     * \n+     * @return the closure\n+     * @since Commons Collections 3.1\n+     */\n+    public Closure<? super E> getClosure() {\n+        return iClosure;\n+    }\n+\n+    /**\n+     * Is the loop a do-while loop.\n+     * \n+     * @return true is do-while, false if while\n+     * @since Commons Collections 3.1\n+     */\n+    public boolean isDoLoop() {\n+        return iDoLoop;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractEmptyIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.NoSuchElementException;\n+\n+/** \n+ * Provides an implementation of an empty iterator.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+abstract class AbstractEmptyIterator<E> {\n+ \n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractEmptyIterator() {\n+        super();\n+    }\n+\n+    public boolean hasNext() {\n+        return false;\n+    }\n+\n+    public E next() {\n+        throw new NoSuchElementException(\"Iterator contains no elements\");\n+    }\n+\n+    public boolean hasPrevious() {\n+        return false;\n+    }\n+\n+    public E previous() {\n+        throw new NoSuchElementException(\"Iterator contains no elements\");\n+    }\n+\n+    public int nextIndex() {\n+        return 0;\n+    }\n+\n+    public int previousIndex() {\n+        return -1;\n+    }\n+\n+    public void add(E obj) {\n+        throw new UnsupportedOperationException(\"add() not supported for empty Iterator\");\n+    }\n+\n+    public void set(E obj) {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public void remove() {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public void reset() {\n+        // do nothing\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractEmptyMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+/** \n+ * Provides an implementation of an empty map iterator.\n+ *\n+ * @since Commons Collections 5\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public abstract class AbstractEmptyMapIterator<K, V> extends AbstractEmptyIterator<K> {\n+\n+    /**\n+     * Create a new AbstractEmptyMapIterator.\n+     */\n+    public AbstractEmptyMapIterator() {\n+        super();\n+    }\n+\n+    public K getKey() {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public V getValue() {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public V setValue(V value) {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Provides basic behaviour for decorating an iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated iterator.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractIteratorDecorator<E> extends AbstractUntypedIteratorDecorator<E, E> {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractIteratorDecorator(Iterator<E> iterator) {\n+        super(iterator);\n+    }\n+\n+    public E next() {\n+        return getIterator().next();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractListIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ListIterator;\n+\n+/**\n+ * Provides basic behaviour for decorating a list iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated list iterator.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Stephen Colebourne\n+ */\n+public class AbstractListIteratorDecorator<E> implements ListIterator<E> {\n+\n+    /** The iterator being decorated */\n+    protected final ListIterator<E> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractListIteratorDecorator(ListIterator<E> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"ListIterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected ListIterator<E> getListIterator() {\n+        return iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public E next() {\n+        return iterator.next();\n+    }\n+\n+    public int nextIndex() {\n+        return iterator.nextIndex();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    public E previous() {\n+        return iterator.previous();\n+    }\n+\n+    public int previousIndex() {\n+        return iterator.previousIndex();\n+    }\n+\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    public void set(E obj) {\n+        iterator.set(obj);\n+    }\n+\n+    public void add(E obj) {\n+        iterator.add(obj);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractMapIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import org.apache.commons.collections.MapIterator;\n+\n+/**\n+ * Provides basic behaviour for decorating a map iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated map iterator.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class AbstractMapIteratorDecorator<K, V> implements MapIterator<K, V> {\n+\n+    /** The iterator being decorated */\n+    protected final MapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractMapIteratorDecorator(MapIterator<K, V> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"MapIterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected MapIterator<K, V> getMapIterator() {\n+        return iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    public void remove() {\n+        iterator.remove();\n+    }\n+    \n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    public V setValue(V obj) {\n+        return iterator.setValue(obj);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractOrderedMapIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import org.apache.commons.collections.OrderedMapIterator;\n+\n+/**\n+ * Provides basic behaviour for decorating an ordered map iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated map iterator.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class AbstractOrderedMapIteratorDecorator<K, V> implements OrderedMapIterator<K, V> {\n+\n+    /** The iterator being decorated */\n+    protected final OrderedMapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractOrderedMapIteratorDecorator(OrderedMapIterator<K, V> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected OrderedMapIterator<K, V> getOrderedMapIterator() {\n+        return iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    public K previous() {\n+        return iterator.previous();\n+    }\n+\n+    public void remove() {\n+        iterator.remove();\n+    }\n+    \n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    public V setValue(V obj) {\n+        return iterator.setValue(obj);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractUntypedIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Provides basic behaviour for decorating an iterator with extra functionality\n+ * without committing the generic type of the Iterator implementation.\n+ * <p>\n+ * All methods are forwarded to the decorated iterator.\n+ *\n+ * @since Commons Collections 5\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public abstract class AbstractUntypedIteratorDecorator<I, O> implements Iterator<O> {\n+\n+    /** The iterator being decorated */\n+    protected final Iterator<I> iterator;\n+\n+    /**\n+     * Create a new AbstractUntypedIteratorDecorator.\n+     */\n+    protected AbstractUntypedIteratorDecorator(Iterator<I> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"Iterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected Iterator<I> getIterator() {\n+        return iterator;\n+    }\n+\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/ArrayIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.lang.reflect.Array;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/** \n+ * Implements an {@link java.util.Iterator Iterator} over any array.\n+ * <p>\n+ * The array can be either an array of object or of primitives. If you know \n+ * that you have an object array, the \n+ * {@link org.apache.commons.collections.iterators.ObjectArrayIterator ObjectArrayIterator}\n+ * class is a better choice, as it will perform better.\n+ * <p>\n+ * The iterator implements a {@link #reset} method, allowing the reset of \n+ * the iterator back to the start if required.\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Mauricio S. Moura\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ */\n+public class ArrayIterator<E> implements ResettableIterator<E> {\n+\n+    /** The array to iterate over */    \n+    protected Object array;\n+    /** The start index to loop from */\n+    protected int startIndex = 0;\n+    /** The end index to loop to */\n+    protected int endIndex = 0;\n+    /** The current iterator index */\n+    protected int index = 0;\n+    \n+    // Constructors\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray(Object)} is  called to establish the array to iterate over.\n+     */\n+    public ArrayIterator() {\n+        super();\n+    }\n+   \n+    /**\n+     * Constructs an ArrayIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ArrayIterator(final Object array) {\n+        super();\n+        setArray(array);\n+    }\n+\n+    /**\n+     * Constructs an ArrayIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over.\n+     * @param startIndex  the index to start iterating at.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public ArrayIterator(final Object array, final int startIndex) {\n+        super();\n+        setArray(array);\n+        checkBound(startIndex, \"start\");\n+        this.startIndex = startIndex;\n+        this.index = startIndex;\n+    }\n+\n+    /**\n+     * Construct an ArrayIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over.\n+     * @param startIndex  the index to start iterating at.\n+     * @param endIndex  the index to finish iterating at.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if either index is invalid\n+     */\n+    public ArrayIterator(final Object array, final int startIndex, final int endIndex) {\n+        super();\n+        setArray(array);\n+        checkBound(startIndex, \"start\");\n+        checkBound(endIndex, \"end\");\n+        if (endIndex < startIndex) {\n+            throw new IllegalArgumentException(\"End index must not be less than start index.\");\n+        }\n+        this.startIndex = startIndex;\n+        this.endIndex = endIndex;\n+        this.index = startIndex;\n+    }\n+\n+    /**\n+     * Checks whether the index is valid or not.\n+     * \n+     * @param bound  the index to check\n+     * @param type  the index type (for error messages)\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void checkBound(final int bound, final String type ) {\n+        if (bound > this.endIndex) {\n+            throw new ArrayIndexOutOfBoundsException(\n+              \"Attempt to make an ArrayIterator that \" + type +\n+              \"s beyond the end of the array. \"\n+            );\n+        }\n+        if (bound < 0) {\n+            throw new ArrayIndexOutOfBoundsException(\n+              \"Attempt to make an ArrayIterator that \" + type +\n+              \"s before the start of the array. \"\n+            );\n+        }\n+    }\n+\n+    // Iterator interface\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if there are more elements to return from the array.\n+     *\n+     * @return true if there is a next element to return\n+     */\n+    public boolean hasNext() {\n+        return (index < endIndex);\n+    }\n+\n+    /**\n+     * Returns the next element in the array.\n+     *\n+     * @return the next element in the array\n+     * @throws NoSuchElementException if all the elements in the array\n+     *  have already been returned\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        return (E) Array.get(array, index++);\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() method is not supported\");\n+    }\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the array that this iterator is iterating over. \n+     *\n+     * @return the array this iterator iterates over, or <code>null</code> if\n+     *  the no-arg constructor was used and {@link #setArray(Object)} has never\n+     *  been called with a valid array.\n+     */\n+    public Object getArray() {\n+        return array;\n+    }\n+    \n+    /**\n+     * Sets the array that the ArrayIterator should iterate over.\n+     * <p>\n+     * If an array has previously been set (using the single-arg constructor\n+     * or this method) then that array is discarded in favour of this one.\n+     * Iteration is restarted at the start of the new array.\n+     * Although this can be used to reset iteration, the {@link #reset()} method\n+     * is a more effective choice.\n+     *\n+     * @param array the array that the iterator should iterate over.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public void setArray(final Object array) {\n+        // Array.getLength throws IllegalArgumentException if the object is not\n+        // an array or NullPointerException if the object is null.  This call\n+        // is made before saving the array and resetting the index so that the\n+        // array iterator remains in a consistent state if the argument is not\n+        // an array or is null.\n+        this.endIndex = Array.getLength(array);\n+        this.startIndex = 0;\n+        this.array = array;\n+        this.index = 0;\n+    }\n+    \n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    public void reset() {\n+        this.index = this.startIndex;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/ArrayListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.lang.reflect.Array;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Implements a {@link ListIterator} over an array. \n+ * <p>\n+ * The array can be either an array of object or of primitives. If you know \n+ * that you have an object array, the {@link ObjectArrayListIterator}\n+ * class is a better choice, as it will perform better.\n+ *\n+ * <p>\n+ * This iterator does not support {@link #add(Object)} or {@link #remove()}, as the array \n+ * cannot be changed in size. The {@link #set(Object)} method is supported however.\n+ *\n+ * @see org.apache.commons.collections.iterators.ArrayIterator\n+ * @see java.util.Iterator\n+ * @see java.util.ListIterator\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ */\n+public class ArrayListIterator<E> extends ArrayIterator<E>\n+        implements ListIterator<E>, ResettableListIterator<E> {\n+\n+    /**\n+     * Holds the index of the last item returned by a call to <code>next()</code>\n+     * or <code>previous()</code>. This is set to <code>-1</code> if neither method\n+     * has yet been invoked. <code>lastItemIndex</code> is used to to implement \n+     * the {@link #set} method.\n+     *\n+     */\n+    protected int lastItemIndex = -1;\n+\n+    // Constructors\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray(Object)} is  called to establish the array to iterate over.\n+     */\n+    public ArrayListIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an ArrayListIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ArrayListIterator(Object array) {\n+        super(array);\n+    }\n+\n+    /**\n+     * Constructs an ArrayListIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over\n+     * @param startIndex  the index to start iterating at\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the start index is out of bounds\n+     */\n+    public ArrayListIterator(Object array, int startIndex) {\n+        super(array, startIndex);\n+        this.startIndex = startIndex;\n+    }\n+\n+    /**\n+     * Construct an ArrayListIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over\n+     * @param startIndex  the index to start iterating at\n+     * @param endIndex  the index (exclusive) to finish iterating at\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n+     * @throws IllegalArgumentException if end index is before the start\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ArrayListIterator(Object array, int startIndex, int endIndex) {\n+        super(array, startIndex, endIndex);\n+        this.startIndex = startIndex;\n+    }\n+\n+    // ListIterator interface\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if there are previous elements to return from the array.\n+     *\n+     * @return true if there is a previous element to return\n+     */\n+    public boolean hasPrevious() {\n+        return (this.index > this.startIndex);\n+    }\n+\n+    /**\n+     * Gets the previous element from the array.\n+     * \n+     * @return the previous element\n+     * @throws NoSuchElementException if there is no previous element\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E previous() {\n+        if (hasPrevious() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = --this.index;\n+        return (E) Array.get(this.array, this.index);\n+    }\n+\n+    /**\n+     * Gets the next element from the array.\n+     * \n+     * @return the next element\n+     * @throws NoSuchElementException if there is no next element\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = this.index;\n+        return (E) Array.get(this.array, this.index++);\n+    }\n+\n+    /**\n+     * Gets the next index to be retrieved.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int nextIndex() {\n+        return this.index - this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the index of the item to be retrieved if {@link #previous()} is called.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int previousIndex() {\n+        return this.index - this.startIndex - 1;\n+    }\n+\n+    /**\n+     * This iterator does not support modification of its backing collection, and so will\n+     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n+     *\n+     * @throws UnsupportedOperationException always thrown.\n+     * @see java.util.ListIterator#set\n+     */\n+    public void add(Object o) {\n+        throw new UnsupportedOperationException(\"add() method is not supported\");\n+    }\n+\n+    /**\n+     * Sets the element under the cursor.\n+     * <p>\n+     * This method sets the element that was returned by the last call \n+     * to {@link #next()} of {@link #previous()}. \n+     * <p>\n+     * <b>Note:</b> {@link ListIterator} implementations that support\n+     * <code>add()</code> and <code>remove()</code> only allow <code>set()</code> to be called\n+     * once per call to <code>next()</code> or <code>previous</code> (see the {@link ListIterator}\n+     * javadoc for more details). Since this implementation does\n+     * not support <code>add()</code> or <code>remove()</code>, <code>set()</code> may be\n+     * called as often as desired.\n+     *\n+     * @see java.util.ListIterator#set\n+     */\n+    public void set(Object o) {\n+        if (this.lastItemIndex == -1) {\n+            throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n+        }\n+\n+        Array.set(this.array, this.lastItemIndex, o);\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    @Override\n+    public void reset() {\n+        super.reset();\n+        this.lastItemIndex = -1;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/CollatingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.list.UnmodifiableList;\n+\n+\n+/**\n+ * Provides an ordered iteration over the elements contained in a collection of\n+ * ordered Iterators.\n+ * <p>\n+ * Given two ordered {@link Iterator} instances <code>A</code> and\n+ * <code>B</code>, the {@link #next} method on this iterator will return the\n+ * lesser of <code>A.next()</code> and <code>B.next()</code>.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Stephen Colebourne\n+ */\n+public class CollatingIterator<E> implements Iterator<E> {\n+\n+    /** The {@link Comparator} used to evaluate order. */\n+    private Comparator<? super E> comparator = null;\n+\n+    /** The list of {@link Iterator}s to evaluate. */\n+    private ArrayList<Iterator<? extends E>> iterators = null;\n+\n+    /** {@link Iterator#next Next} objects peeked from each iterator. */\n+    private ArrayList<E> values = null;\n+\n+    /** Whether or not each {@link #values} element has been set. */\n+    private BitSet valueSet = null;\n+\n+    /**\n+     * Index of the {@link #iterators iterator} from whom the last returned\n+     * value was obtained.\n+     */\n+    private int lastReturned = -1;\n+\n+    // Constructors\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>CollatingIterator</code>. A comparator must be\n+     * set by calling {@link #setComparator(Comparator)} before invoking\n+     * {@link #hasNext()}, or {@link #next()} for the first time. Child\n+     * iterators will have to be manually added using the\n+     * {@link #addIterator(Iterator)} method.\n+     */\n+    public CollatingIterator() {\n+        this(null, 2);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will used the\n+     * specified comparator for ordering. Child iterators will have to be\n+     * manually added using the {@link #addIterator(Iterator)} method.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp) {\n+        this(comp, 2);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will used the\n+     * specified comparator for ordering and have the specified initial\n+     * capacity. Child iterators will have to be manually added using the\n+     * {@link #addIterator(Iterator)} method.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param initIterCapacity the initial capacity for the internal list of\n+     * child iterators\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final int initIterCapacity) {\n+        iterators = new ArrayList<Iterator<? extends E>>(initIterCapacity);\n+        setComparator(comp);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will use the\n+     * specified comparator to provide ordered iteration over the two given\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param a the first child ordered iterator\n+     * @param b the second child ordered iterator\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E> a, final Iterator<? extends E> b) {\n+        this(comp, 2);\n+        addIterator(a);\n+        addIterator(b);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will use the\n+     * specified comparator to provide ordered iteration over the array of\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param iterators the array of iterators\n+     * @throws NullPointerException if iterators array is or contains null\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E>[] iterators) {\n+        this(comp, iterators.length);\n+        for (int i = 0; i < iterators.length; i++) {\n+            addIterator(iterators[i]);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will use the\n+     * specified comparator to provide ordered iteration over the collection of\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param iterators the collection of iterators\n+     * @throws NullPointerException if the iterators collection is or contains\n+     * null\n+     * @throws ClassCastException if the iterators collection contains an\n+     * element that's not an {@link Iterator}\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final Collection<Iterator<? extends E>> iterators) {\n+        this(comp, iterators.size());\n+        for (Iterator<? extends E> iterator : iterators) {\n+            addIterator(iterator);\n+        }\n+    }\n+\n+    // Public Methods\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Adds the given {@link Iterator} to the iterators being collated.\n+     * \n+     * @param iterator the iterator to add to the collation, must not be null\n+     * @throws IllegalStateException if iteration has started\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void addIterator(final Iterator<? extends E> iterator) {\n+        checkNotStarted();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iterators.add(iterator);\n+    }\n+\n+    /**\n+     * Sets the iterator at the given index.\n+     * \n+     * @param index index of the Iterator to replace\n+     * @param iterator Iterator to place at the given index\n+     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n+     * @throws IllegalStateException if iteration has started\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void setIterator(final int index, final Iterator<? extends E> iterator) {\n+        checkNotStarted();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iterators.set(index, iterator);\n+    }\n+\n+    /**\n+     * Gets the list of Iterators (unmodifiable).\n+     * \n+     * @return the unmodifiable list of iterators added\n+     */\n+    public List<Iterator<? extends E>> getIterators() {\n+        return UnmodifiableList.unmodifiableList(iterators);\n+    }\n+\n+    /**\n+     * Gets the {@link Comparator} by which collatation occurs.\n+     */\n+    public Comparator<? super E> getComparator() {\n+        return comparator;\n+    }\n+\n+    /**\n+     * Sets the {@link Comparator} by which collation occurs. If you\n+     * would like to use the natural sort order (or, in other words,\n+     * if the elements in the iterators are implementing the\n+     * {@link java.lang.Comparable} interface), then use the\n+     * {@link org.apache.commons.collections.comparators.ComparableComparator}.\n+     * \n+     * @throws IllegalStateException if iteration has started\n+     */\n+    public void setComparator(final Comparator<? super E> comp) {\n+        checkNotStarted();\n+        comparator = comp;\n+    }\n+\n+    // Iterator Methods\n+    // -------------------------------------------------------------------\n+    /**\n+     * Returns <code>true</code> if any child iterator has remaining elements.\n+     * \n+     * @return true if this iterator has remaining elements\n+     */\n+    public boolean hasNext() {\n+        start();\n+        return anyValueSet(valueSet) || anyHasNext(iterators);\n+    }\n+\n+    /**\n+     * Returns the next ordered element from a child iterator.\n+     * \n+     * @return the next ordered element\n+     * @throws NoSuchElementException if no child iterator has any more elements\n+     */\n+    public E next() throws NoSuchElementException {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        int leastIndex = least();\n+        if (leastIndex == -1) {\n+            throw new NoSuchElementException();\n+        }\n+        E val = values.get(leastIndex);\n+        clear(leastIndex);\n+        lastReturned = leastIndex;\n+        return val;\n+    }\n+\n+    /**\n+     * Removes the last returned element from the child iterator that produced\n+     * it.\n+     * \n+     * @throws IllegalStateException if there is no last returned element, or if\n+     * the last returned element has already been removed\n+     */\n+    public void remove() {\n+        if (lastReturned == -1) {\n+            throw new IllegalStateException(\"No value can be removed at present\");\n+        }\n+        iterators.get(lastReturned).remove();\n+    }\n+\n+    /**\n+     * Returns the index of the iterator that returned the last element.\n+     * \n+     * @return the index of the iterator that returned the last element\n+     * @throws IllegalStateException if there is no last returned element\n+     */\n+    public int getIteratorIndex() {\n+        if (lastReturned == -1) {\n+            throw new IllegalStateException(\"No value has been returned yet\");\n+        }\n+        \n+        return lastReturned;\n+    }\n+    \n+    // Private Methods\n+    // -------------------------------------------------------------------\n+    /**\n+     * Initializes the collating state if it hasn't been already.\n+     */\n+    private void start() {\n+        if (values == null) {\n+            values = new ArrayList<E>(iterators.size());\n+            valueSet = new BitSet(iterators.size());\n+            for (int i = 0; i < iterators.size(); i++) {\n+                values.add(null);\n+                valueSet.clear(i);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets the {@link #values} and {@link #valueSet} attributes at position\n+     * <i>i</i> to the next value of the {@link #iterators iterator} at position\n+     * <i>i</i>, or clear them if the <i>i</i><sup>th</sup> iterator has no next\n+     * value.\n+     * \n+     * @return <tt>false</tt> iff there was no value to set\n+     */\n+    private boolean set(int i) {\n+        Iterator<? extends E> it = iterators.get(i);\n+        if (it.hasNext()) {\n+            values.set(i, it.next());\n+            valueSet.set(i);\n+            return true;\n+        }\n+        values.set(i, null);\n+        valueSet.clear(i);\n+        return false;\n+    }\n+\n+    /**\n+     * Clears the {@link #values} and {@link #valueSet} attributes at position\n+     * <i>i</i>.\n+     */\n+    private void clear(int i) {\n+        values.set(i, null);\n+        valueSet.clear(i);\n+    }\n+\n+    /**\n+     * Throws {@link IllegalStateException} if iteration has started via\n+     * {@link #start}.\n+     * \n+     * @throws IllegalStateException if iteration started\n+     */\n+    private void checkNotStarted() throws IllegalStateException {\n+        if (values != null) {\n+            throw new IllegalStateException(\"Can't do that after next or hasNext has been called.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the index of the least element in {@link #values},\n+     * {@link #set(int) setting} any uninitialized values.\n+     * \n+     * @throws IllegalStateException\n+     */\n+    private int least() {\n+        int leastIndex = -1;\n+        E leastObject = null;\n+        for (int i = 0; i < values.size(); i++) {\n+            if (valueSet.get(i) == false) {\n+                set(i);\n+            }\n+            if (valueSet.get(i)) {\n+                if (leastIndex == -1) {\n+                    leastIndex = i;\n+                    leastObject = values.get(i);\n+                } else {\n+                    E curObject = values.get(i);\n+                    if (comparator == null) {\n+                        throw new NullPointerException(\"You must invoke setComparator() to set a compator first.\");\n+                    }\n+                    if (comparator.compare(curObject, leastObject) < 0) {\n+                        leastObject = curObject;\n+                        leastIndex = i;\n+                    }\n+                }\n+            }\n+        }\n+        return leastIndex;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff any bit in the given set is\n+     * <code>true</code>.\n+     */\n+    private boolean anyValueSet(BitSet set) {\n+        for (int i = 0; i < set.size(); i++) {\n+            if (set.get(i)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff any {@link Iterator} in the given list has\n+     * a next value.\n+     */\n+    private boolean anyHasNext(ArrayList<Iterator<? extends E>> iters) {\n+        for (Iterator<? extends E> iterator : iters) {\n+            if (iterator.hasNext()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/EmptyIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty iterator.\n+ * <p>\n+ * This class provides an implementation of an empty iterator.\n+ * This class provides for binary compatability between Commons Collections\n+ * 2.1.1 and 3.1 due to issues with <code>IteratorUtils</code>.\n+ *\n+ * @since Commons Collections 2.1.1 and 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class EmptyIterator<E> extends AbstractEmptyIterator<E> implements ResettableIterator<E> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since Commons Collections 3.1\n+     */\n+    public static final ResettableIterator<Object> RESETTABLE_INSTANCE = new EmptyIterator<Object>();\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since Commons Collections 2.1.1 and 3.1\n+     */\n+    public static final Iterator<Object> INSTANCE = RESETTABLE_INSTANCE;\n+\n+    /**\n+     * Get a typed resettable empty iterator instance.\n+     * @param <E>\n+     * @return ResettableIterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ResettableIterator<E> resettableEmptyIterator() {\n+        return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n+    }\n+\n+    /**\n+     * Get a typed empty iterator instance.\n+     * @param <E>\n+     * @return Iterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Iterator<E> emptyIterator() {\n+        return (Iterator<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/EmptyListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Provides an implementation of an empty list iterator.\n+ * <p>\n+ * This class provides an implementation of an empty list iterator. This class\n+ * provides for binary compatability between Commons Collections 2.1.1 and 3.1\n+ * due to issues with <code>IteratorUtils</code>.\n+ *\n+ * @since Commons Collections 2.1.1 and 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class EmptyListIterator<E> extends AbstractEmptyIterator<E> implements\n+        ResettableListIterator<E> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since Commons Collections 3.1\n+     */\n+    public static final ResettableListIterator<Object> RESETTABLE_INSTANCE = new EmptyListIterator<Object>();\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since Commons Collections 2.1.1 and 3.1\n+     */\n+    public static final ListIterator<Object> INSTANCE = RESETTABLE_INSTANCE;\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <E>\n+     * @return {@link ResettableListIterator}<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n+        return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n+    }\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <E>\n+     * @return {@link ListIterator}<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ListIterator<E> emptyListIterator() {\n+        return (ListIterator<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyListIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/EmptyMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty map iterator.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class EmptyMapIterator<K, V> extends AbstractEmptyMapIterator<K, V> implements\n+        MapIterator<K, V>, ResettableIterator<K> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since Commons Collections 3.1\n+     */\n+    public static final MapIterator<Object, Object> INSTANCE = new EmptyMapIterator<Object, Object>();\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <K>\n+     * @param <V>\n+     * @return {@link MapIterator}<K, V>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n+        return (MapIterator<K, V>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyMapIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/EmptyOrderedIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import org.apache.commons.collections.OrderedIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty ordered iterator.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class EmptyOrderedIterator<E> extends AbstractEmptyIterator<E> implements OrderedIterator<E>, ResettableIterator<E> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since Commons Collections 3.1\n+     */\n+    public static final OrderedIterator<Object> INSTANCE = new EmptyOrderedIterator<Object>();\n+\n+    /**\n+     * Typed instance of the iterator.\n+     * @param <E>\n+     * @return OrderedIterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n+        return (OrderedIterator<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyOrderedIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/EmptyOrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty ordered map iterator.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class EmptyOrderedMapIterator<K, V> extends AbstractEmptyMapIterator<K, V> implements\n+        OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since Commons Collections 3.1\n+     */\n+    public static final OrderedMapIterator<Object, Object> INSTANCE = new EmptyOrderedMapIterator<Object, Object>();\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <K>\n+     * @param <V>\n+     * @return {@link OrderedMapIterator}<K, V>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n+        return (OrderedMapIterator<K, V>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyOrderedMapIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/EntrySetMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * Implements a <code>MapIterator</code> using a Map entrySet.\n+ * Reverse iteration is not supported.\n+ * <pre>\n+ * MapIterator it = map.mapIterator();\n+ * while (it.hasNext()) {\n+ *   Object key = it.next();\n+ *   Object value = it.getValue();\n+ *   it.setValue(newValue);\n+ * }\n+ * </pre>\n+ *  \n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class EntrySetMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+    \n+    private final Map<K, V> map;\n+    private Iterator<Map.Entry<K, V>> iterator;\n+    private Map.Entry<K, V> last;\n+    private boolean canRemove = false;\n+    \n+    /**\n+     * Constructor.\n+     * \n+     * @param map  the map to iterate over\n+     */\n+    public EntrySetMapIterator(Map<K, V> map) {\n+        super();\n+        this.map = map;\n+        this.iterator = map.entrySet().iterator();\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Checks to see if there are more entries still to be iterated.\n+     *\n+     * @return <code>true</code> if the iterator has more elements\n+     */\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Gets the next <em>key</em> from the <code>Map</code>.\n+     *\n+     * @return the next key in the iteration\n+     * @throws java.util.NoSuchElementException if the iteration is finished\n+     */\n+    public K next() {\n+        last = iterator.next();\n+        canRemove = true;\n+        return last.getKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes the last returned key from the underlying <code>Map</code>.\n+     * <p>\n+     * This method can be called once per call to <code>next()</code>.\n+     *\n+     * @throws UnsupportedOperationException if remove is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has already been called\n+     *  since the last call to <code>next()</code>\n+     */\n+    public void remove() {\n+        if (canRemove == false) {\n+            throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+        }\n+        iterator.remove();\n+        last = null;\n+        canRemove = false;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current key, which is the key returned by the last call\n+     * to <code>next()</code>.\n+     *\n+     * @return the current key\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    public K getKey() {\n+        if (last == null) {\n+            throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+        }\n+        return last.getKey();\n+    }\n+\n+    /**\n+     * Gets the current value, which is the value associated with the last key\n+     * returned by <code>next()</code>.\n+     *\n+     * @return the current value\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    public V getValue() {\n+        if (last == null) {\n+            throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+        }\n+        return last.getValue();\n+    }\n+\n+    /**\n+     * Sets the value associated with the current key.\n+     *\n+     * @param value  the new value\n+     * @return the previous value\n+     * @throws UnsupportedOperationException if setValue is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has been called since the\n+     *  last call to <code>next()</code>\n+     */\n+    public V setValue(V value) {\n+        if (last == null) {\n+            throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+        }\n+        return last.setValue(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Resets the state of the iterator.\n+     */\n+    public void reset() {\n+        iterator = map.entrySet().iterator();\n+        last = null;\n+        canRemove = false;\n+    }\n+    \n+    /**\n+     * Gets the iterator as a String.\n+     * \n+     * @return a string version of the iterator\n+     */    \n+    @Override\n+    public String toString() {\n+        if (last != null) {\n+            return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+        }\n+        return \"MapIterator[]\";\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/EnumerationIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/** \n+ * Adapter to make {@link Enumeration Enumeration} instances appear\n+ * to be {@link Iterator Iterator} instances.\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author <a href=\"mailto:dlr@finemaltcoding.com\">Daniel Rall</a>\n+ */\n+public class EnumerationIterator<E> implements Iterator<E> {\n+    \n+    /** The collection to remove elements from */\n+    private final Collection<? super E> collection;\n+    /** The enumeration being converted */\n+    private Enumeration<? extends E> enumeration;\n+    /** The last object retrieved */\n+    private E last;\n+    \n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>EnumerationIterator</code> that will not\n+     * function until {@link #setEnumeration(Enumeration)} is called.\n+     */\n+    public EnumerationIterator() {\n+        this(null, null);\n+    }\n+\n+    /**\n+     * Constructs a new <code>EnumerationIterator</code> that provides\n+     * an iterator view of the given enumeration.\n+     *\n+     * @param enumeration  the enumeration to use\n+     */\n+    public EnumerationIterator(final Enumeration<? extends E> enumeration) {\n+        this(enumeration, null);\n+    }\n+\n+    /**\n+     * Constructs a new <code>EnumerationIterator</code> that will remove\n+     * elements from the specified collection.\n+     *\n+     * @param enumeration  the enumeration to use\n+     * @param collection  the collection to remove elements from\n+     */\n+    public EnumerationIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> collection) {\n+        super();\n+        this.enumeration = enumeration;\n+        this.collection = collection;\n+        this.last = null;\n+    }\n+\n+    // Iterator interface\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if the underlying enumeration has more elements.\n+     *\n+     * @return true if the underlying enumeration has more elements\n+     * @throws NullPointerException  if the underlying enumeration is null\n+     */\n+    public boolean hasNext() {\n+        return enumeration.hasMoreElements();\n+    }\n+\n+    /**\n+     * Returns the next object from the enumeration.\n+     *\n+     * @return the next object from the enumeration\n+     * @throws NullPointerException if the enumeration is null\n+     */\n+    public E next() {\n+        last = enumeration.nextElement();\n+        return last;\n+    }\n+\n+    /**\n+     * Removes the last retrieved element if a collection is attached.\n+     * <p>\n+     * Functions if an associated <code>Collection</code> is known.\n+     * If so, the first occurrence of the last returned object from this\n+     * iterator will be removed from the collection.\n+     *\n+     * @exception IllegalStateException <code>next()</code> not called.\n+     * @exception UnsupportedOperationException if no associated collection\n+     */\n+    public void remove() {\n+        if (collection != null) {\n+            if (last != null) {\n+                collection.remove(last);\n+            } else {\n+                throw new IllegalStateException(\"next() must have been called for remove() to function\");\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"No Collection associated with this Iterator\");\n+        }\n+    }\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the underlying enumeration.\n+     *\n+     * @return the underlying enumeration\n+     */\n+    public Enumeration<? extends E> getEnumeration() {\n+        return enumeration;\n+    }\n+\n+    /**\n+     * Sets the underlying enumeration.\n+     *\n+     * @param enumeration  the new underlying enumeration\n+     */\n+    public void setEnumeration(final Enumeration<? extends E> enumeration) {\n+        this.enumeration = enumeration;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/FilterIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/** \n+ * Decorates another {@link Iterator} using a predicate to filter elements.\n+ * <p>\n+ * This iterator decorates the underlying iterator, only allowing through\n+ * those elements that match the specified {@link Predicate Predicate}.\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Jan Sorensen\n+ * @author Ralph Wagner\n+ * @author Stephen Colebourne\n+ */\n+public class FilterIterator<E> implements Iterator<E> {\n+\n+    /** The iterator being used */\n+    private Iterator<? extends E> iterator;\n+    /** The predicate being used */\n+    private Predicate<? super E> predicate;\n+    /** The next object in the iteration */\n+    private E nextObject;\n+    /** Whether the next object has been calculated yet */\n+    private boolean nextObjectSet = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>FilterIterator</code> that will not function\n+     * until {@link #setIterator(Iterator) setIterator} is invoked.\n+     */\n+    public FilterIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterIterator</code> that will not function\n+     * until {@link #setPredicate(Predicate) setPredicate} is invoked.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public FilterIterator(Iterator<? extends E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterIterator</code> that will use the\n+     * given iterator and predicate.\n+     *\n+     * @param iterator  the iterator to use\n+     * @param predicate  the predicate to use\n+     */\n+    public FilterIterator(Iterator<? extends E> iterator, Predicate<? super E> predicate) {\n+        super();\n+        this.iterator = iterator;\n+        this.predicate = predicate;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Returns true if the underlying iterator contains an object that \n+     * matches the predicate.\n+     *\n+     * @return true if there is another object that matches the predicate\n+     * @throws NullPointerException if either the iterator or predicate are null\n+     */\n+    public boolean hasNext() {\n+        return nextObjectSet || setNextObject();\n+    }\n+\n+    /** \n+     * Returns the next object that matches the predicate.\n+     *\n+     * @return the next object which matches the given predicate\n+     * @throws NullPointerException if either the iterator or predicate are null\n+     * @throws NoSuchElementException if there are no more elements that\n+     *  match the predicate \n+     */\n+    public E next() {\n+        if (!nextObjectSet) {\n+            if (!setNextObject()) {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+        nextObjectSet = false;\n+        return nextObject;\n+    }\n+\n+    /**\n+     * Removes from the underlying collection of the base iterator the last\n+     * element returned by this iterator.\n+     * This method can only be called\n+     * if <code>next()</code> was called, but not after\n+     * <code>hasNext()</code>, because the <code>hasNext()</code> call\n+     * changes the base iterator.\n+     *\n+     * @throws IllegalStateException if <code>hasNext()</code> has already\n+     *  been called.\n+     */\n+    public void remove() {\n+        if (nextObjectSet) {\n+            throw new IllegalStateException(\"remove() cannot be called\");\n+        }\n+        iterator.remove();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the iterator this iterator is using.\n+     *\n+     * @return the iterator\n+     */\n+    public Iterator<? extends E> getIterator() {\n+        return iterator;\n+    }\n+\n+    /** \n+     * Sets the iterator for this iterator to use.\n+     * If iteration has started, this effectively resets the iterator.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public void setIterator(Iterator<? extends E> iterator) {\n+        this.iterator = iterator;\n+        nextObject = null;\n+        nextObjectSet = false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the predicate this iterator is using.\n+     *\n+     * @return the predicate\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return predicate;\n+    }\n+\n+    /** \n+     * Sets the predicate this the iterator to use.\n+     *\n+     * @param predicate  the predicate to use\n+     */\n+    public void setPredicate(Predicate<? super E> predicate) {\n+        this.predicate = predicate;\n+        nextObject = null;\n+        nextObjectSet = false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set nextObject to the next object. If there are no more \n+     * objects then return false. Otherwise, return true.\n+     */\n+    private boolean setNextObject() {\n+        while (iterator.hasNext()) {\n+            E object = iterator.next();\n+            if (predicate.evaluate(object)) {\n+                nextObject = object;\n+                nextObjectSet = true;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/FilterListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/** \n+ * Decorates another {@link ListIterator} using a predicate to filter elements.\n+ * <p>\n+ * This iterator decorates the underlying iterator, only allowing through\n+ * those elements that match the specified {@link Predicate Predicate}.\n+ *\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ */\n+public class FilterListIterator<E> implements ListIterator<E> {\n+\n+    /** The iterator being used */\n+    private ListIterator<? extends E> iterator;\n+    \n+    /** The predicate being used */\n+    private Predicate<? super E> predicate;\n+\n+    /** \n+     * The value of the next (matching) object, when \n+     * {@link #nextObjectSet} is true. \n+     */\n+    private E nextObject;\n+\n+    /** \n+     * Whether or not the {@link #nextObject} has been set\n+     * (possibly to <code>null</code>). \n+     */\n+    private boolean nextObjectSet = false;   \n+\n+    /** \n+     * The value of the previous (matching) object, when \n+     * {@link #previousObjectSet} is true. \n+     */\n+    private E previousObject;\n+\n+    /** \n+     * Whether or not the {@link #previousObject} has been set\n+     * (possibly to <code>null</code>). \n+     */\n+    private boolean previousObjectSet = false;   \n+\n+    /** \n+     * The index of the element that would be returned by {@link #next}.\n+     */\n+    private int nextIndex = 0;\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>FilterListIterator</code> that will not function\n+     * until {@link #setListIterator(ListIterator) setListIterator}\n+     * and {@link #setPredicate(Predicate) setPredicate} are invoked.\n+     */\n+    public FilterListIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterListIterator</code> that will not \n+     * function until {@link #setPredicate(Predicate) setPredicate} is invoked.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public FilterListIterator(ListIterator<? extends E> iterator ) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterListIterator</code>.\n+     *\n+     * @param iterator  the iterator to use\n+     * @param predicate  the predicate to use\n+     */\n+    public FilterListIterator(ListIterator<? extends E> iterator, Predicate<? super E> predicate) {\n+        super();\n+        this.iterator = iterator;\n+        this.predicate = predicate;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterListIterator</code> that will not function\n+     * until {@link #setListIterator(ListIterator) setListIterator} is invoked.\n+     *\n+     * @param predicate  the predicate to use.\n+     */\n+    public FilterListIterator(Predicate<? super E> predicate) {\n+        super();\n+        this.predicate = predicate;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** Not supported. */\n+    public void add(E o) {\n+        throw new UnsupportedOperationException(\"FilterListIterator.add(Object) is not supported.\");\n+    }\n+\n+    public boolean hasNext() {\n+        return nextObjectSet || setNextObject();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return previousObjectSet || setPreviousObject();\n+    }\n+\n+    public E next() {\n+        if (!nextObjectSet) {\n+            if (!setNextObject()) {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+        nextIndex++;\n+        E temp = nextObject;\n+        clearNextObject();\n+        return temp;\n+    }\n+\n+    public int nextIndex() {\n+        return nextIndex;\n+    }\n+\n+    public E previous() {\n+        if (!previousObjectSet) {\n+            if (!setPreviousObject()) {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+        nextIndex--;\n+        E temp = previousObject;\n+        clearPreviousObject();\n+        return temp;\n+    }\n+\n+    public int previousIndex() {\n+        return (nextIndex-1);\n+    }\n+\n+    /** Not supported. */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"FilterListIterator.remove() is not supported.\");\n+    }\n+\n+    /** Not supported. */\n+    public void set(E o) {\n+        throw new UnsupportedOperationException(\"FilterListIterator.set(Object) is not supported.\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the iterator this iterator is using.\n+     * \n+     * @return the iterator.\n+     */\n+    public ListIterator<? extends E> getListIterator() {\n+        return iterator;\n+    }\n+\n+    /** \n+     * Sets the iterator for this iterator to use.\n+     * If iteration has started, this effectively resets the iterator.\n+     * \n+     * @param iterator  the iterator to use\n+     */\n+    public void setListIterator(ListIterator<? extends E> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the predicate this iterator is using.\n+     * \n+     * @return the predicate.\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return predicate;\n+    }\n+\n+    /** \n+     * Sets the predicate this the iterator to use.\n+     * \n+     * @param predicate  the transformer to use\n+     */\n+    public void setPredicate(Predicate<? super E> predicate) {\n+        this.predicate = predicate;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void clearNextObject() {\n+        nextObject = null;\n+        nextObjectSet = false;\n+    }\n+\n+    private boolean setNextObject() {\n+        // if previousObjectSet,\n+        // then we've walked back one step in the \n+        // underlying list (due to a hasPrevious() call)\n+        // so skip ahead one matching object\n+        if (previousObjectSet) {\n+            clearPreviousObject();\n+            if (!setNextObject()) {\n+                return false;\n+            }\n+            clearNextObject();\n+        }\n+\n+        if (iterator == null) {\n+            return false;\n+        }\n+        while (iterator.hasNext()) {\n+            E object = iterator.next();\n+            if (predicate.evaluate(object)) {\n+                nextObject = object;\n+                nextObjectSet = true;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void clearPreviousObject() {\n+        previousObject = null;\n+        previousObjectSet = false;\n+    }\n+\n+    private boolean setPreviousObject() {\n+        // if nextObjectSet,\n+        // then we've walked back one step in the \n+        // underlying list (due to a hasNext() call)\n+        // so skip ahead one matching object\n+        if (nextObjectSet) {\n+            clearNextObject();\n+            if (!setPreviousObject()) {\n+                return false;\n+            }\n+            clearPreviousObject();\n+        }\n+\n+        if (iterator == null) {\n+            return false;\n+        }\n+        while (iterator.hasPrevious()) {\n+            E object = iterator.previous();\n+            if (predicate.evaluate(object)) {\n+                previousObject = object;\n+                previousObjectSet = true;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/IteratorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.list.UnmodifiableList;\n+\n+/**\n+ * An IteratorChain is an Iterator that wraps a number of Iterators.\n+ * <p>\n+ * This class makes multiple iterators look like one to the caller When any\n+ * method from the Iterator interface is called, the IteratorChain will delegate\n+ * to a single underlying Iterator. The IteratorChain will invoke the Iterators\n+ * in sequence until all Iterators are exhausted.\n+ * <p>\n+ * Under many circumstances, linking Iterators together in this manner is more\n+ * efficient (and convenient) than reading out the contents of each Iterator\n+ * into a List and creating a new Iterator.\n+ * <p>\n+ * Calling a method that adds new Iterator<i>after a method in the Iterator\n+ * interface has been called</i> will result in an\n+ * UnsupportedOperationException. Subclasses should <i>take care</i> to not\n+ * alter the underlying List of Iterators.\n+ * <p>\n+ * NOTE: As from version 3.0, the IteratorChain may contain no iterators. In\n+ * this case the class will function as an empty iterator.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date: 2006-10-27 19:52:37 -0500 (Fri, 27 Oct\n+ * 2006) $\n+ *\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ */\n+public class IteratorChain<E> implements Iterator<E> {\n+\n+    /** The chain of iterators */\n+    protected final List<Iterator<? extends E>> iteratorChain = new ArrayList<Iterator<? extends E>>();\n+\n+    /** The index of the current iterator */\n+    protected int currentIteratorIndex = 0;\n+\n+    /** The current iterator */\n+    protected Iterator<? extends E> currentIterator = null;\n+\n+    /**\n+     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n+     * was most recently called used for the remove() operation only\n+     */\n+    protected Iterator<? extends E> lastUsedIterator = null;\n+\n+    /**\n+     * ComparatorChain is \"locked\" after the first time compare(Object,Object)\n+     * is called\n+     */\n+    protected boolean isLocked = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Construct an IteratorChain with no Iterators.\n+     * <p>\n+     * You will normally use {@link #addIterator(Iterator)} to add some\n+     * iterators after using this constructor.\n+     */\n+    public IteratorChain() {\n+        super();\n+    }\n+\n+    /**\n+     * Construct an IteratorChain with a single Iterator.\n+     * <p>\n+     * This method takes one iterator. The newly constructed iterator will\n+     * iterate through that iterator. Thus calling this constructor on its own\n+     * will have no effect other than decorating the input iterator.\n+     * <p>\n+     * You will normally use {@link #addIterator(Iterator)} to add some more\n+     * iterators after using this constructor.\n+     * \n+     * @param iterator the first child iterator in the IteratorChain, not null\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public IteratorChain(Iterator<? extends E> iterator) {\n+        super();\n+        addIterator(iterator);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorChain</code> over the two given iterators.\n+     * <p>\n+     * This method takes two iterators. The newly constructed iterator will\n+     * iterate through each one of the input iterators in turn.\n+     * \n+     * @param first the first child iterator in the IteratorChain, not null\n+     * @param second the second child iterator in the IteratorChain, not null\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public IteratorChain(Iterator<? extends E> first, Iterator<? extends E> second) {\n+        super();\n+        addIterator(first);\n+        addIterator(second);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorChain</code> over the array of iterators.\n+     * <p>\n+     * This method takes an array of iterators. The newly constructed iterator\n+     * will iterate through each one of the input iterators in turn.\n+     * \n+     * @param iteratorChain the array of iterators, not null\n+     * @throws NullPointerException if iterators array is or contains null\n+     */\n+    public IteratorChain(Iterator<? extends E>... iteratorChain) {\n+        super();\n+        for (int i = 0; i < iteratorChain.length; i++) {\n+            addIterator(iteratorChain[i]);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorChain</code> over the collection of\n+     * iterators.\n+     * <p>\n+     * This method takes a collection of iterators. The newly constructed\n+     * iterator will iterate through each one of the input iterators in turn.\n+     * \n+     * @param iteratorChain the collection of iterators, not null\n+     * @throws NullPointerException if iterators collection is or contains null\n+     * @throws ClassCastException if iterators collection doesn't contain an\n+     * iterator\n+     */\n+    public IteratorChain(Collection<Iterator<? extends E>> iteratorChain) {\n+        super();\n+        for (Iterator<? extends E> iterator : iteratorChain) {\n+            addIterator(iterator);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add an Iterator to the end of the chain\n+     * \n+     * @param iterator Iterator to add\n+     * @throws IllegalStateException if I've already started iterating\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void addIterator(Iterator<? extends E> iterator) {\n+        checkLocked();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iteratorChain.add(iterator);\n+    }\n+\n+    /**\n+     * Set the Iterator at the given index\n+     * \n+     * @param index index of the Iterator to replace\n+     * @param iterator Iterator to place at the given index\n+     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n+     * @throws IllegalStateException if I've already started iterating\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void setIterator(int index, Iterator<? extends E> iterator)\n+            throws IndexOutOfBoundsException {\n+        checkLocked();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iteratorChain.set(index, iterator);\n+    }\n+\n+    /**\n+     * Get the list of Iterators (unmodifiable)\n+     * \n+     * @return the unmodifiable list of iterators added\n+     */\n+    public List<Iterator<? extends E>> getIterators() {\n+        return UnmodifiableList.unmodifiableList(iteratorChain);\n+    }\n+\n+    /**\n+     * Number of Iterators in the current IteratorChain.\n+     * \n+     * @return Iterator count\n+     */\n+    public int size() {\n+        return iteratorChain.size();\n+    }\n+\n+    /**\n+     * Determine if modifications can still be made to the IteratorChain.\n+     * IteratorChains cannot be modified once they have executed a method from\n+     * the Iterator interface.\n+     * \n+     * @return true if IteratorChain cannot be modified, false if it can\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    /**\n+     * Checks whether the iterator chain is now locked and in use.\n+     */\n+    private void checkLocked() {\n+        if (isLocked == true) {\n+            throw new UnsupportedOperationException(\n+                    \"IteratorChain cannot be changed after the first use of a method from the Iterator interface\");\n+        }\n+    }\n+\n+    /**\n+     * Lock the chain so no more iterators can be added. This must be called\n+     * from all Iterator interface methods.\n+     */\n+    private void lockChain() {\n+        if (isLocked == false) {\n+            isLocked = true;\n+        }\n+    }\n+\n+    /**\n+     * Updates the current iterator field to ensure that the current Iterator is\n+     * not exhausted\n+     */\n+    protected void updateCurrentIterator() {\n+        if (currentIterator == null) {\n+            if (iteratorChain.isEmpty()) {\n+                currentIterator = EmptyIterator.<E> emptyIterator();\n+            } else {\n+                currentIterator = iteratorChain.get(0);\n+            }\n+            // set last used iterator here, in case the user calls remove\n+            // before calling hasNext() or next() (although they shouldn't)\n+            lastUsedIterator = currentIterator;\n+        }\n+\n+        while (currentIterator.hasNext() == false\n+                && currentIteratorIndex < iteratorChain.size() - 1) {\n+            currentIteratorIndex++;\n+            currentIterator = iteratorChain.get(currentIteratorIndex);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return true if any Iterator in the IteratorChain has a remaining element.\n+     * \n+     * @return true if elements remain\n+     */\n+    public boolean hasNext() {\n+        lockChain();\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+\n+        return currentIterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next Object of the current Iterator\n+     * \n+     * @return Object from the current Iterator\n+     * @throws java.util.NoSuchElementException if all the Iterators are\n+     * exhausted\n+     */\n+    public E next() {\n+        lockChain();\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+\n+        return currentIterator.next();\n+    }\n+\n+    /**\n+     * Removes from the underlying collection the last element returned by the\n+     * Iterator. As with next() and hasNext(), this method calls remove() on the\n+     * underlying Iterator. Therefore, this method may throw an\n+     * UnsupportedOperationException if the underlying Iterator does not support\n+     * this method.\n+     * \n+     * @throws UnsupportedOperationException if the remove operator is not\n+     * supported by the underlying Iterator\n+     * @throws IllegalStateException if the next method has not yet been called,\n+     * or the remove method has already been called after the last call to the\n+     * next method.\n+     */\n+    public void remove() {\n+        lockChain();\n+        if (currentIterator == null) {\n+            updateCurrentIterator();\n+        }\n+        lastUsedIterator.remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/IteratorEnumeration.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/**\n+ * Adapter to make an {@link Iterator Iterator} instance appear to be an\n+ * {@link Enumeration Enumeration} instance.\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ */\n+public class IteratorEnumeration<E> implements Enumeration<E> {\n+\n+    /** The iterator being decorated. */\n+    private Iterator<? extends E> iterator;\n+\n+    /**\n+     * Constructs a new <code>IteratorEnumeration</code> that will not function\n+     * until {@link #setIterator(Iterator) setIterator} is invoked.\n+     */\n+    public IteratorEnumeration() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorEnumeration</code> that will use the given\n+     * iterator.\n+     * \n+     * @param iterator the iterator to use\n+     */\n+    public IteratorEnumeration(Iterator<? extends E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns true if the underlying iterator has more elements.\n+     * \n+     * @return true if the underlying iterator has more elements\n+     */\n+    public boolean hasMoreElements() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next element from the underlying iterator.\n+     * \n+     * @return the next element from the underlying iterator.\n+     * @throws java.util.NoSuchElementException if the underlying iterator has\n+     * no more elements\n+     */\n+    public E nextElement() {\n+        return iterator.next();\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the underlying iterator.\n+     * \n+     * @return the underlying iterator\n+     */\n+    public Iterator<? extends E> getIterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Sets the underlying iterator.\n+     * \n+     * @param iterator the new underlying iterator\n+     */\n+    public void setIterator(Iterator<? extends E> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/IteratorIterable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * Adapter to make an {@link Iterator Iterator} instance appear to be an\n+ * {@link Iterable Iterable} instance.  The iterable can be constructed in one\n+ * of two variants:  single use, multiple use.\n+ * \n+ * <p>\n+ * In the single use iterable case, the iterable is only usable for one\n+ * iterative operation over the source iterator.  Subsequent iterative\n+ * operations use the same, exhausted source iterator.  To create a single use\n+ * iterable, construct a new {@link IteratorIterable} using a {@link Iterator}\n+ * that is NOT a {@link ResettableIterator} iterator:\n+ * <pre>\n+ *   Iterator<Integer> iterator = // some non-resettable iterator\n+ *   Iterable<Integer> iterable = new IteratorIterable<Integer>(iterator);\n+ * </pre>\n+ * </p>\n+ * \n+ * <p>\n+ * In the multiple use iterable case, the iterable is usable for any number of\n+ * iterative operations over the source iterator.  Of special note, even though\n+ * the iterable supports multiple iterations, it does not support concurrent\n+ * iterations. To implicitly create a multiple use iterable, construct a new\n+ * {@link IteratorIterable} using a {@link ResettableIterator} iterator:\n+ * <pre>\n+ *   Integer[] array = {Integer.valueOf(1),Integer.valueOf(2),Integer.valueOf(3)};\n+ *   Iterator<Integer> iterator = IteratorUtils.arrayIterator(array); // a resettable iterator\n+ *   Iterable<Integer> iterable = new IteratorIterable<Integer>(iterator);\n+ * </pre>\n+ * </p>\n+ * \n+ * <p>\n+ * A multiple use iterable can also be explicitly constructed using any\n+ * {@link Iterator} and specifying <code>true</code> for the\n+ * <code>multipleUse</code> flag:\n+ * <pre>\n+ *   Iterator<Integer> iterator = // some non-resettable iterator\n+ *   Iterable<Integer> iterable = new IteratorIterable<Integer>(iterator, true);\n+ * </pre>\n+ * </p>\n+ * \n+ * @since Commons Collections 4.0\n+ * @version $Revision: $ $Date: $\n+ */\n+public class IteratorIterable<E> implements Iterable<E> {\n+\n+    /**\n+     * Factory method to create an {@link Iterator Iterator} from another\n+     * iterator over objects of a different subtype.\n+     */\n+    private static <E> Iterator<E> createTypesafeIterator(\n+            final Iterator<? extends E> iterator) {\n+        return new Iterator<E>() {\n+            public boolean hasNext() {\n+                return iterator.hasNext();\n+            }\n+\n+            public E next() {\n+                return iterator.next();\n+            }\n+\n+            public void remove() {\n+                iterator.remove();\n+            }\n+        };\n+    }\n+\n+    /** the iterator being adapted into an iterable. */\n+    private final Iterator<? extends E> iterator;\n+    \n+    /** the iterator parameterized as the {@link #iterator()} return type. */ \n+    private final Iterator<E> typeSafeIterator;\n+    \n+    /**\n+     * Constructs a new <code>IteratorIterable</code> that will use the given\n+     * iterator.\n+     * \n+     * @param iterator the iterator to use.\n+     */\n+    public IteratorIterable(Iterator<? extends E> iterator) {\n+        this(iterator, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorIterable</code> that will use the given\n+     * iterator.\n+     * \n+     * @param iterator the iterator to use.\n+     * @param multipleUse <code>true</code> if the new iterable can be used in multiple iterations\n+     */\n+    public IteratorIterable(Iterator<? extends E> iterator, boolean multipleUse) {\n+        super();\n+        if (multipleUse && !(iterator instanceof ResettableIterator)) {\n+            this.iterator = new ListIteratorWrapper<E>(iterator); \n+        } else {\n+            this.iterator = iterator;\n+        }\n+        this.typeSafeIterator = createTypesafeIterator(this.iterator);\n+    }\n+\n+    /**\n+     * Gets the iterator wrapped by this iterable.\n+     * \n+     * @return the iterator\n+     */\n+    public Iterator<E> iterator() {\n+        if (iterator instanceof ResettableIterator) {\n+            ((ResettableIterator<? extends E>)iterator).reset();\n+        }\n+        return typeSafeIterator;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/ListIteratorWrapper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Converts an {@link Iterator} into a {@link ResettableListIterator}.\n+ * For plain <code>Iterator</code>s this is accomplished by caching the returned\n+ * elements.  This class can also be used to simply add {@link ResettableIterator}\n+ * functionality to a given {@link ListIterator}.\n+ * <p>\n+ * The <code>ListIterator</code> interface has additional useful methods\n+ * for navigation - <code>previous()</code> and the index methods.\n+ * This class allows a regular <code>Iterator</code> to behave as a\n+ * <code>ListIterator</code>. It achieves this by building a list internally\n+ * of as the underlying iterator is traversed.\n+ * <p>\n+ * The optional operations of <code>ListIterator</code> are not supported for plain <code>Iterator</code>s.\n+ * <p>\n+ * This class implements ResettableListIterator from Commons Collections 3.2.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class ListIteratorWrapper<E> implements ResettableListIterator<E> {\n+\n+    /** Message used when set or add are called. */\n+    private static final String UNSUPPORTED_OPERATION_MESSAGE =\n+        \"ListIteratorWrapper does not support optional operations of ListIterator.\";\n+\n+    /** Message used when set or add are called. */\n+    private static final String CANNOT_REMOVE_MESSAGE = \"Cannot remove element at index {0}.\";\n+\n+    /** The underlying iterator being decorated. */\n+    private final Iterator<? extends E> iterator;\n+    /** The list being used to cache the iterator. */\n+    private final List<E> list = new ArrayList<E>();\n+\n+    /** The current index of this iterator. */\n+    private int currentIndex = 0;\n+    /** The current index of the wrapped iterator. */\n+    private int wrappedIteratorIndex = 0;\n+    /** recall whether the wrapped iterator's \"cursor\" is in such a state as to allow remove() to be called */\n+    private boolean removeState;\n+\n+    // Constructor\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>ListIteratorWrapper</code> that will wrap\n+     * the given iterator.\n+     *\n+     * @param iterator  the iterator to wrap\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public ListIteratorWrapper(Iterator<? extends E> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    // ListIterator interface\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Throws {@link UnsupportedOperationException}\n+     * unless the underlying <code>Iterator</code> is a <code>ListIterator</code>.\n+     *\n+     * @param obj  the object to add\n+     * @throws UnsupportedOperationException\n+     */\n+    public void add(E obj) throws UnsupportedOperationException {\n+        if (iterator instanceof ListIterator) {\n+            @SuppressWarnings(\"unchecked\")\n+            ListIterator<E> li = (ListIterator<E>) iterator;\n+            li.add(obj);\n+            return;\n+        }\n+        throw new UnsupportedOperationException(UNSUPPORTED_OPERATION_MESSAGE);\n+    }\n+\n+    /**\n+     * Returns true if there are more elements in the iterator.\n+     *\n+     * @return true if there are more elements\n+     */\n+    public boolean hasNext() {\n+        if (currentIndex == wrappedIteratorIndex || iterator instanceof ListIterator) {\n+            return iterator.hasNext();\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if there are previous elements in the iterator.\n+     *\n+     * @return true if there are previous elements\n+     */\n+    public boolean hasPrevious() {\n+        if (iterator instanceof ListIterator) {\n+            ListIterator<?> li = (ListIterator<?>) iterator;\n+            return li.hasPrevious();\n+        }\n+        return currentIndex > 0;\n+    }\n+\n+    /**\n+     * Returns the next element from the iterator.\n+     *\n+     * @return the next element from the iterator\n+     * @throws NoSuchElementException if there are no more elements\n+     */\n+    public E next() throws NoSuchElementException {\n+        if (iterator instanceof ListIterator) {\n+            return iterator.next();\n+        }\n+\n+        if (currentIndex < wrappedIteratorIndex) {\n+            ++currentIndex;\n+            return list.get(currentIndex - 1);\n+        }\n+\n+        E retval = iterator.next();\n+        list.add(retval);\n+        ++currentIndex;\n+        ++wrappedIteratorIndex;\n+        removeState = true;\n+        return retval;\n+    }\n+\n+    /**\n+     * Returns the index of the next element.\n+     *\n+     * @return the index of the next element\n+     */\n+    public int nextIndex() {\n+        if (iterator instanceof ListIterator) {\n+            ListIterator<?> li = (ListIterator<?>) iterator;\n+            return li.nextIndex();\n+        }\n+        return currentIndex;\n+    }\n+\n+    /**\n+     * Returns the the previous element.\n+     *\n+     * @return the previous element\n+     * @throws NoSuchElementException  if there are no previous elements\n+     */\n+    public E previous() throws NoSuchElementException {\n+        if (iterator instanceof ListIterator) {\n+            @SuppressWarnings(\"unchecked\")\n+            ListIterator<E> li = (ListIterator<E>) iterator;\n+            return li.previous();\n+        }\n+\n+        if (currentIndex == 0) {\n+            throw new NoSuchElementException();\n+        }\n+        removeState = wrappedIteratorIndex == currentIndex;\n+        return list.get(--currentIndex);\n+    }\n+\n+    /**\n+     * Returns the index of the previous element.\n+     *\n+     * @return  the index of the previous element\n+     */\n+    public int previousIndex() {\n+        if (iterator instanceof ListIterator) {\n+            ListIterator<?> li = (ListIterator<?>) iterator;\n+            return li.previousIndex();\n+        }\n+        return currentIndex - 1;\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException} if {@link #previous()} has ever been called.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() throws UnsupportedOperationException {\n+        if (iterator instanceof ListIterator) {\n+            iterator.remove();\n+            return;\n+        }\n+        int removeIndex = currentIndex;\n+        if (currentIndex == wrappedIteratorIndex) {\n+            --removeIndex;\n+        }\n+        if (!removeState || wrappedIteratorIndex - currentIndex > 1) {\n+            throw new IllegalStateException(MessageFormat.format(CANNOT_REMOVE_MESSAGE, removeIndex));\n+        }\n+        iterator.remove();\n+        list.remove(removeIndex);\n+        currentIndex = removeIndex;\n+        wrappedIteratorIndex--;\n+        removeState = false;\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}\n+     * unless the underlying <code>Iterator</code> is a <code>ListIterator</code>.\n+     *\n+     * @param obj  the object to set\n+     * @throws UnsupportedOperationException\n+     */\n+    public void set(E obj) throws UnsupportedOperationException {\n+        if (iterator instanceof ListIterator) {\n+            @SuppressWarnings(\"unchecked\")\n+            ListIterator<E> li = (ListIterator<E>) iterator;\n+            li.set(obj);\n+            return;\n+        }\n+        throw new UnsupportedOperationException(UNSUPPORTED_OPERATION_MESSAGE);\n+    }\n+\n+    // ResettableIterator interface\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Resets this iterator back to the position at which the iterator\n+     * was created.\n+     *\n+     * @since Commons Collections 3.2\n+     */\n+    public void reset()  {\n+        if (iterator instanceof ListIterator) {\n+            ListIterator<?> li = (ListIterator<?>) iterator;\n+            while (li.previousIndex() >= 0) {\n+                li.previous();\n+            }\n+            return;\n+        }\n+        currentIndex = 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/LoopingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * An Iterator that restarts when it reaches the end.\n+ * <p>\n+ * The iterator will loop continuously around the provided elements, unless \n+ * there are no elements in the collection to begin with, or all the elements\n+ * have been {@link #remove removed}.\n+ * <p>\n+ * Concurrent modifications are not directly supported, and for most collection\n+ * implementations will throw a ConcurrentModificationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author <a href=\"mailto:joncrlsn@users.sf.net\">Jonathan Carlson</a>\n+ * @author Stephen Colebourne\n+ */\n+public class LoopingIterator<E> implements ResettableIterator<E> {\n+    \n+    /** The collection to base the iterator on */\n+    private Collection<? extends E> collection;\n+    /** The current iterator */\n+    private Iterator<? extends E> iterator;\n+\n+    /**\n+     * Constructor that wraps a collection.\n+     * <p>\n+     * There is no way to reset an Iterator instance without recreating it from\n+     * the original source, so the Collection must be passed in.\n+     * \n+     * @param coll  the collection to wrap\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public LoopingIterator(Collection<? extends E> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+        collection = coll;\n+        reset();\n+    }\n+\n+    /** \n+     * Has the iterator any more elements.\n+     * <p>\n+     * Returns false only if the collection originally had zero elements, or\n+     * all the elements have been {@link #remove removed}.\n+     * \n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasNext() {\n+        return (collection.size() > 0);\n+    }\n+\n+    /**\n+     * Returns the next object in the collection.\n+     * <p>\n+     * If at the end of the collection, return the first element.\n+     * \n+     * @throws NoSuchElementException if there are no elements\n+     *         at all.  Use {@link #hasNext} to avoid this error.\n+     */\n+    public E next() {\n+        if (collection.size() == 0) {\n+            throw new NoSuchElementException(\"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            reset();\n+        }\n+        return iterator.next();\n+    }\n+\n+    /**\n+     * Removes the previously retrieved item from the underlying collection.\n+     * <p>\n+     * This feature is only supported if the underlying collection's \n+     * {@link Collection#iterator iterator} method returns an implementation \n+     * that supports it.\n+     * <p>\n+     * This method can only be called after at least one {@link #next} method call.\n+     * After a removal, the remove method may not be called again until another\n+     * next has been performed. If the {@link #reset} is called, then remove may\n+     * not be called until {@link #next} is called again.\n+     */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start of the collection.\n+     */\n+    public void reset() {\n+        iterator = collection.iterator();\n+    }\n+\n+    /**\n+     * Gets the size of the collection underlying the iterator.\n+     * \n+     * @return the current collection size\n+     */\n+    public int size() {\n+        return collection.size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/LoopingListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * A ListIterator that restarts when it reaches the end or when it\n+ * reaches the beginning.\n+ * <p>\n+ * The iterator will loop continuously around the provided list,\n+ * unless there are no elements in the collection to begin with, or\n+ * all of the elements have been {@link #remove removed}.\n+ * <p>\n+ * Concurrent modifications are not directly supported, and for most\n+ * collection implementations will throw a\n+ * ConcurrentModificationException.\n+ *\n+ * @since Commons Collections 3.2\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Eric Crampton <ccesc@eonomine.com>\n+ */\n+public class LoopingListIterator<E> implements ResettableListIterator<E> {\n+\n+    /** The list to base the iterator on */\n+    private List<E> list;\n+    /** The current list iterator */\n+    private ListIterator<E> iterator;\n+\n+    /**\n+     * Constructor that wraps a list.\n+     * <p>\n+     * There is no way to reset a ListIterator instance without\n+     * recreating it from the original source, so the List must be\n+     * passed in and a reference to it held.\n+     *\n+     * @param list the list to wrap\n+     * @throws NullPointerException if the list it null\n+     */\n+    public LoopingListIterator(List<E> list) {\n+        if (list == null) {\n+            throw new NullPointerException(\"The list must not be null\");\n+        }\n+        this.list = list;\n+        reset();\n+    }\n+\n+    /**\n+     * Returns whether this iterator has any more elements.\n+     * <p>\n+     * Returns false only if the list originally had zero elements, or\n+     * all elements have been {@link #remove removed}.\n+     *\n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasNext() {\n+        return !list.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the next object in the list.\n+     * <p>\n+     * If at the end of the list, returns the first element.\n+     *\n+     * @return the object after the last element returned\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public E next() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            reset();\n+        }\n+        return iterator.next();\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a\n+     * subsequent call to {@link #next}.\n+     * <p>\n+     * As would be expected, if the iterator is at the physical end of\n+     * the underlying list, 0 is returned, signifying the beginning of\n+     * the list.\n+     *\n+     * @return the index of the element that would be returned if next() were called\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public int nextIndex() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            return 0;\n+        }\n+        return iterator.nextIndex();\n+    }\n+\n+    /**\n+     * Returns whether this iterator has any more previous elements.\n+     * <p>\n+     * Returns false only if the list originally had zero elements, or\n+     * all elements have been {@link #remove removed}.\n+     *\n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasPrevious() {\n+        return !list.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the previous object in the list.\n+     * <p>\n+     * If at the beginning of the list, return the last element. Note\n+     * that in this case, traversal to find that element takes linear time.\n+     *\n+     * @return the object before the last element returned\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public E previous() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasPrevious() == false) {\n+            E result = null;\n+            while (iterator.hasNext()) {\n+                result = iterator.next();\n+            }\n+            iterator.previous();\n+            return result;\n+        }\n+        return iterator.previous();\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a\n+     * subsequent call to {@link #previous}.\n+     * <p>\n+     * As would be expected, if at the iterator is at the physical\n+     * beginning of the underlying list, the list's size minus one is\n+     * returned, signifying the end of the list.\n+     *\n+     * @return the index of the element that would be returned if previous() were called\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public int previousIndex() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasPrevious() == false) {\n+            return list.size() - 1;\n+        }\n+        return iterator.previousIndex();\n+    }\n+\n+    /**\n+     * Removes the previously retrieved item from the underlying list.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#iterator iterator} method returns an implementation\n+     * that supports it.\n+     * <p>\n+     * This method can only be called after at least one {@link #next}\n+     * or {@link #previous} method call. After a removal, the remove\n+     * method may not be called again until another {@link #next} or\n+     * {@link #previous} has been performed. If the {@link #reset} is\n+     * called, then remove may not be called until {@link #next} or\n+     * {@link #previous} is called again.\n+     *\n+     * @throws UnsupportedOperationException if the remove method is\n+     * not supported by the iterator implementation of the underlying\n+     * list\n+     */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    /**\n+     * Inserts the specified element into the underlying list.\n+     * <p>\n+     * The element is inserted before the next element that would be\n+     * returned by {@link #next}, if any, and after the next element\n+     * that would be returned by {@link #previous}, if any.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#listIterator} method returns an implementation\n+     * that supports it.\n+     *\n+     * @param obj  the element to insert\n+     * @throws UnsupportedOperationException if the add method is not\n+     *  supported by the iterator implementation of the underlying list\n+     */\n+    public void add(E obj) {\n+        iterator.add(obj);\n+    }\n+\n+    /**\n+     * Replaces the last element that was returned by {@link #next} or\n+     * {@link #previous}.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#listIterator} method returns an implementation\n+     * that supports it.\n+     *\n+     * @param obj  the element with which to replace the last element returned\n+     * @throws UnsupportedOperationException if the set method is not\n+     *  supported by the iterator implementation of the underlying list\n+     */\n+    public void set(E obj) {\n+        iterator.set(obj);\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start of the list.\n+     */\n+    public void reset() {\n+        iterator = list.listIterator();\n+    }\n+\n+    /**\n+     * Gets the size of the list underlying the iterator.\n+     *\n+     * @return the current list size\n+     */\n+    public int size() {\n+        return list.size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/ObjectArrayIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/** \n+ * An {@link Iterator} over an array of objects.\n+ * <p>\n+ * This iterator does not support {@link #remove}, as the object array cannot be\n+ * structurally modified.\n+ * <p>\n+ * The iterator implements a {@link #reset} method, allowing the reset of the iterator\n+ * back to the start if required.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Mauricio S. Moura\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ */\n+public class ObjectArrayIterator<E>\n+        implements Iterator<E>, ResettableIterator<E> {\n+\n+    /** The array */\n+    protected E[] array = null;\n+    /** The start index to loop from */\n+    protected int startIndex = 0;\n+    /** The end index to loop to */\n+    protected int endIndex = 0;\n+    /** The current iterator index */\n+    protected int index = 0;\n+\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray} is  called to establish the array to iterate over.\n+     */\n+    public ObjectArrayIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayIterator(E... array) {\n+        this(array, 0, array.length);\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the start index is out of bounds\n+     */\n+    public ObjectArrayIterator(E array[], int start) {\n+        this(array, start, array.length);\n+    }\n+\n+    /**\n+     * Construct an ObjectArrayIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @param end  the index (exclusive) to finish iterating at\n+     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n+     * @throws IllegalArgumentException if end index is before the start\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayIterator(E array[], int start, int end) {\n+        super();\n+        if (start < 0) {\n+            throw new ArrayIndexOutOfBoundsException(\"Start index must not be less than zero\");\n+        }\n+        if (end > array.length) {\n+            throw new ArrayIndexOutOfBoundsException(\"End index must not be greater than the array length\");\n+        }\n+        if (start > array.length) {\n+            throw new ArrayIndexOutOfBoundsException(\"Start index must not be greater than the array length\");\n+        }\n+        if (end < start) {\n+            throw new IllegalArgumentException(\"End index must not be less than start index\");\n+        }\n+        this.array = array;\n+        this.startIndex = start;\n+        this.endIndex = end;\n+        this.index = start;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns true if there are more elements to return from the array.\n+     *\n+     * @return true if there is a next element to return\n+     */\n+    public boolean hasNext() {\n+        return (this.index < this.endIndex);\n+    }\n+\n+    /**\n+     * Returns the next element in the array.\n+     *\n+     * @return the next element in the array\n+     * @throws NoSuchElementException if all the elements in the array\n+     *    have already been returned\n+     */\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        return this.array[this.index++];\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() method is not supported for an ObjectArrayIterator\");\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the array that this iterator is iterating over. \n+     *\n+     * @return the array this iterator iterates over, or <code>null</code> if\n+     * the no-arg constructor was used and {@link #setArray} has never\n+     * been called with a valid array.\n+     */\n+    public E[] getArray() {\n+        return this.array;\n+    }\n+\n+    /**\n+     * Sets the array that the ArrayIterator should iterate over.\n+     * <p>\n+     * This method may only be called once, otherwise an IllegalStateException\n+     * will occur.\n+     * <p>\n+     * The {@link #reset} method can be used to reset the iterator if required.\n+     *\n+     * @param array  the array that the iterator should iterate over\n+     * @throws IllegalStateException if the <code>array</code> was set in the constructor\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public void setArray(E[] array) {\n+        if (this.array != null) {\n+            throw new IllegalStateException(\"The array to iterate over has already been set\");\n+        }\n+        this.array = array;\n+        this.startIndex = 0;\n+        this.endIndex = array.length;\n+        this.index = 0;\n+    }\n+\n+    /**\n+     * Gets the start index to loop from.\n+     * \n+     * @return the start index\n+     */\n+    public int getStartIndex() {\n+        return this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the end index to loop to.\n+     * \n+     * @return the end index\n+     */\n+    public int getEndIndex() {\n+        return this.endIndex;\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    public void reset() {\n+        this.index = this.startIndex;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/ObjectArrayListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Implements a {@link ListIterator} over an array of objects.\n+ * <p>\n+ * This iterator does not support {@link #add} or {@link #remove}, as the object array \n+ * cannot be structurally modified. The {@link #set} method is supported however.\n+ * <p>\n+ * The iterator implements a {@link #reset} method, allowing the reset of the iterator\n+ * back to the start if required.\n+ *\n+ * @see org.apache.commons.collections.iterators.ObjectArrayIterator\n+ * @see java.util.Iterator\n+ * @see java.util.ListIterator\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ */\n+public class ObjectArrayListIterator<E> extends ObjectArrayIterator<E>\n+        implements ListIterator<E>, ResettableListIterator<E> {\n+\n+    /**\n+     * Holds the index of the last item returned by a call to <code>next()</code> \n+     * or <code>previous()</code>. This is set to <code>-1</code> if neither method\n+     * has yet been invoked. <code>lastItemIndex</code> is used to to implement the\n+     * {@link #set} method.\n+     */\n+    protected int lastItemIndex = -1;\n+\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray} is  called to establish the array to iterate over.\n+     */\n+    public ObjectArrayListIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayListIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayListIterator(E... array) {\n+        super(array);\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayListIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the start index is out of bounds\n+     */\n+    public ObjectArrayListIterator(E[] array, int start) {\n+        super(array, start);\n+    }\n+    \n+    /**\n+     * Construct an ObjectArrayListIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @param end  the index (exclusive) to finish iterating at\n+     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n+     * @throws IllegalArgumentException if end index is before the start\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayListIterator(E[] array, int start, int end) {\n+        super(array, start, end);\n+    }\n+\n+    // ListIterator interface\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns true if there are previous elements to return from the array.\n+     *\n+     * @return true if there is a previous element to return\n+     */\n+    public boolean hasPrevious() {\n+        return (this.index > this.startIndex);\n+    }\n+\n+    /**\n+     * Gets the previous element from the array.\n+     * \n+     * @return the previous element\n+     * @throws NoSuchElementException if there is no previous element\n+     */\n+    public E previous() {\n+        if (hasPrevious() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = --this.index;\n+        return this.array[this.index];\n+    }\n+\n+    /**\n+     * Gets the next element from the array.\n+     * \n+     * @return the next element\n+     * @throws NoSuchElementException if there is no next element\n+     */\n+    @Override\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = this.index;\n+        return this.array[this.index++];\n+    }\n+\n+    /**\n+     * Gets the next index to be retrieved.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int nextIndex() {\n+        return this.index - this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the index of the item to be retrieved if {@link #previous()} is called.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int previousIndex() {\n+        return this.index - this.startIndex - 1;\n+    }\n+\n+    /**\n+     * This iterator does not support modification of its backing array's size, and so will\n+     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n+     *\n+     * @param obj  the object to add\n+     * @throws UnsupportedOperationException always thrown.\n+     */\n+    public void add(E obj) {\n+        throw new UnsupportedOperationException(\"add() method is not supported\");\n+    }\n+\n+    /**\n+     * Sets the element under the cursor.\n+     * <p>\n+     * This method sets the element that was returned by the last call \n+     * to {@link #next()} of {@link #previous()}. \n+     * \n+     * <b>Note:</b> {@link ListIterator} implementations that support <code>add()</code>\n+     * and <code>remove()</code> only allow <code>set()</code> to be called once per call \n+     * to <code>next()</code> or <code>previous</code> (see the {@link ListIterator}\n+     * javadoc for more details). Since this implementation does not support \n+     * <code>add()</code> or <code>remove()</code>, <code>set()</code> may be\n+     * called as often as desired.\n+     * \n+     * @param obj  the object to set into the array\n+     * @throws IllegalStateException if next() has not yet been called.\n+     * @throws ClassCastException if the object type is unsuitable for the array\n+     */\n+    public void set(E obj) {\n+        if (this.lastItemIndex == -1) {\n+            throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n+        }\n+\n+        this.array[this.lastItemIndex] = obj;\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    @Override\n+    public void reset() {\n+        super.reset();\n+        this.lastItemIndex = -1;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/ObjectGraphIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * An Iterator that can traverse multiple iterators down an object graph.\n+ * <p>\n+ * This iterator can extract multiple objects from a complex tree-like object graph.\n+ * The iteration starts from a single root object.\n+ * It uses a <code>Transformer</code> to extract the iterators and elements.\n+ * Its main benefit is that no intermediate <code>List</code> is created.\n+ * <p>\n+ * For example, consider an object graph:\n+ * <pre>\n+ *                 |- Branch -- Leaf\n+ *                 |         \\- Leaf\n+ *         |- Tree |         /- Leaf\n+ *         |       |- Branch -- Leaf\n+ *  Forest |                 \\- Leaf\n+ *         |       |- Branch -- Leaf\n+ *         |       |         \\- Leaf\n+ *         |- Tree |         /- Leaf\n+ *                 |- Branch -- Leaf\n+ *                 |- Branch -- Leaf</pre>\n+ * The following <code>Transformer</code>, used in this class, will extract all\n+ * the Leaf objects without creating a combined intermediate list:\n+ * <pre>\n+ * public Object transform(Object input) {\n+ *   if (input instanceof Forest) {\n+ *     return ((Forest) input).treeIterator();\n+ *   }\n+ *   if (input instanceof Tree) {\n+ *     return ((Tree) input).branchIterator();\n+ *   }\n+ *   if (input instanceof Branch) {\n+ *     return ((Branch) input).leafIterator();\n+ *   }\n+ *   if (input instanceof Leaf) {\n+ *     return input;\n+ *   }\n+ *   throw new ClassCastException();\n+ * }</pre>\n+ * <p>\n+ * Internally, iteration starts from the root object. When next is called,\n+ * the transformer is called to examine the object. The transformer will return\n+ * either an iterator or an object. If the object is an Iterator, the next element\n+ * from that iterator is obtained and the process repeats. If the element is an object\n+ * it is returned.\n+ * <p>\n+ * Under many circumstances, linking Iterators together in this manner is\n+ * more efficient (and convenient) than using nested for loops to extract a list.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ObjectGraphIterator<E> implements Iterator<E> {\n+\n+    /** The stack of iterators */\n+    protected final ArrayStack<Iterator<? extends E>> stack = new ArrayStack<Iterator<? extends E>>(8);\n+    /** The root object in the tree */\n+    protected E root;\n+    /** The transformer to use */\n+    protected final Transformer<? super E, ? extends E> transformer;\n+\n+    /** Whether there is another element in the iteration */\n+    protected boolean hasNext = false;\n+    /** The current iterator */\n+    protected Iterator<? extends E> currentIterator;\n+    /** The current value */\n+    protected E currentValue;\n+    /** The last used iterator, needed for remove() */\n+    protected Iterator<? extends E> lastUsedIterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an ObjectGraphIterator using a root object and transformer.\n+     * <p>\n+     * The root object can be an iterator, in which case it will be immediately\n+     * looped around.\n+     * \n+     * @param root  the root object, null will result in an empty iterator\n+     * @param transformer  the transformer to use, null will use a no effect transformer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectGraphIterator(E root, Transformer<? super E, ? extends E> transformer) {\n+        super();\n+        if (root instanceof Iterator) {\n+            this.currentIterator = (Iterator<? extends E>) root;\n+        } else {\n+            this.root = root;\n+        }\n+        this.transformer = transformer;\n+    }\n+\n+    /**\n+     * Constructs a ObjectGraphIterator that will handle an iterator of iterators.\n+     * <p>\n+     * This constructor exists for convenience to emphasise that this class can\n+     * be used to iterate over nested iterators. That is to say that the iterator\n+     * passed in here contains other iterators, which may in turn contain further\n+     * iterators.\n+     * \n+     * @param rootIterator  the root iterator, null will result in an empty iterator\n+     */\n+    public ObjectGraphIterator(Iterator<? extends E> rootIterator) {\n+        super();\n+        this.currentIterator = rootIterator;\n+        this.transformer = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Loops around the iterators to find the next value to return.\n+     */\n+    protected void updateCurrentIterator() {\n+        if (hasNext) {\n+            return;\n+        }\n+        if (currentIterator == null) {\n+            if (root == null) {\n+                // do nothing, hasNext will be false\n+            } else {\n+                if (transformer == null) {\n+                    findNext(root);\n+                } else {\n+                    findNext(transformer.transform(root));\n+                }\n+                root = null;\n+            }\n+        } else {\n+            findNextByIterator(currentIterator);\n+        }\n+    }\n+\n+    /**\n+     * Finds the next object in the iteration given any start object.\n+     * \n+     * @param value  the value to start from\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void findNext(E value) {\n+        if (value instanceof Iterator) {\n+            // need to examine this iterator\n+            findNextByIterator((Iterator<? extends E>) value);\n+        } else {\n+            // next value found\n+            currentValue = value;\n+            hasNext = true;\n+        }\n+    }\n+    \n+    /**\n+     * Finds the next object in the iteration given an iterator.\n+     * \n+     * @param iterator  the iterator to start from\n+     */\n+    protected void findNextByIterator(Iterator<? extends E> iterator) {\n+        if (iterator != currentIterator) {\n+            // recurse a level\n+            if (currentIterator != null) {\n+                stack.push(currentIterator);\n+            }\n+            currentIterator = iterator;\n+        }\n+        \n+        while (currentIterator.hasNext() && hasNext == false) {\n+            E next = currentIterator.next();\n+            if (transformer != null) {\n+                next = transformer.transform(next);\n+            }\n+            findNext(next);\n+        }\n+        if (hasNext) {\n+            // next value found\n+        } else if (stack.isEmpty()) {\n+            // all iterators exhausted\n+        } else {\n+            // current iterator exhausted, go up a level\n+            currentIterator = stack.pop();\n+            findNextByIterator(currentIterator);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more elements in the iteration to obtain.\n+     * \n+     * @return true if elements remain in the iteration\n+     */\n+    public boolean hasNext() {\n+        updateCurrentIterator();\n+        return hasNext;\n+    }\n+\n+    /**\n+     * Gets the next element of the iteration.\n+     * \n+     * @return the next element from the iteration\n+     * @throws NoSuchElementException if all the Iterators are exhausted\n+     */\n+    public E next() {\n+        updateCurrentIterator();\n+        if (hasNext == false) {\n+            throw new NoSuchElementException(\"No more elements in the iteration\");\n+        }\n+        lastUsedIterator = currentIterator;\n+        E result = currentValue;\n+        currentValue = null;\n+        hasNext = false;\n+        return result;\n+    }\n+\n+    /**\n+     * Removes from the underlying collection the last element returned.\n+     * <p>\n+     * This method calls remove() on the underlying Iterator and it may\n+     * throw an UnsupportedOperationException if the underlying Iterator\n+     * does not support this method. \n+     * \n+     * @throws UnsupportedOperationException\n+     *   if the remove operator is not supported by the underlying Iterator\n+     * @throws IllegalStateException\n+     *   if the next method has not yet been called, or the remove method has\n+     *   already been called after the last call to the next method.\n+     */\n+    public void remove() {\n+        if (lastUsedIterator == null) {\n+            throw new IllegalStateException(\"Iterator remove() cannot be called at this time\");\n+        }\n+        lastUsedIterator.remove();\n+        lastUsedIterator = null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/ReverseListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Iterates backwards through a List, starting with the last element\n+ * and continuing to the first. This is useful for looping around\n+ * a list in reverse order without needing to actually reverse the list.\n+ * <p>\n+ * The first call to <code>next()</code> will return the last element\n+ * from the list, and so on. The <code>hasNext()</code> method works\n+ * in concert with the <code>next()</code> method as expected.\n+ * However, the <code>nextIndex()</code> method returns the correct\n+ * index in the list, thus it starts high and reduces as the iteration\n+ * continues. The previous methods work similarly.\n+ *\n+ * @author Serge Knystautas\n+ * @author Stephen Colebourne\n+ * @since Commons Collections 3.2\n+ * @version $Revision: $ $Date$\n+ */\n+public class ReverseListIterator<E> implements ResettableListIterator<E> {\n+\n+    /** The list being wrapped. */\n+    private final List<E> list;\n+    /** The list iterator being wrapped. */\n+    private ListIterator<E> iterator;\n+    /** Flag to indicate if updating is possible at the moment. */\n+    private boolean validForUpdate = true;\n+\n+    /**\n+     * Constructor that wraps a list.\n+     *\n+     * @param list  the list to create a reversed iterator for\n+     * @throws NullPointerException if the list is null\n+     */\n+    public ReverseListIterator(List<E> list) {\n+        super();\n+        this.list = list;\n+        iterator = list.listIterator(list.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there is another element.\n+     *\n+     * @return true if there is another element\n+     */\n+    public boolean hasNext() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    /**\n+     * Gets the next element.\n+     * The next element is the previous in the list.\n+     *\n+     * @return the next element in the iterator\n+     */\n+    public E next() {\n+        E obj = iterator.previous();\n+        validForUpdate = true;\n+        return obj;\n+    }\n+\n+    /**\n+     * Gets the index of the next element.\n+     *\n+     * @return the index of the next element in the iterator\n+     */\n+    public int nextIndex() {\n+        return iterator.previousIndex();\n+    }\n+\n+    /**\n+     * Checks whether there is a previous element.\n+     *\n+     * @return true if there is a previous element\n+     */\n+    public boolean hasPrevious() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Gets the previous element.\n+     * The next element is the previous in the list.\n+     *\n+     * @return the previous element in the iterator\n+     */\n+    public E previous() {\n+        E obj = iterator.next();\n+        validForUpdate = true;\n+        return obj;\n+    }\n+\n+    /**\n+     * Gets the index of the previous element.\n+     *\n+     * @return the index of the previous element in the iterator\n+     */\n+    public int previousIndex() {\n+        return iterator.nextIndex();\n+    }\n+\n+    /**\n+     * Removes the last returned element.\n+     *\n+     * @throws UnsupportedOperationException if the list is unmodifiable\n+     * @throws IllegalStateException if there is no element to remove\n+     */\n+    public void remove() {\n+        if (validForUpdate == false) {\n+            throw new IllegalStateException(\"Cannot remove from list until next() or previous() called\");\n+        }\n+        iterator.remove();\n+    }\n+\n+    /**\n+     * Replaces the last returned element.\n+     *\n+     * @param obj  the object to set\n+     * @throws UnsupportedOperationException if the list is unmodifiable\n+     * @throws IllegalStateException if the iterator is not in a valid state for set\n+     */\n+    public void set(E obj) {\n+        if (validForUpdate == false) {\n+            throw new IllegalStateException(\"Cannot set to list until next() or previous() called\");\n+        }\n+        iterator.set(obj);\n+    }\n+\n+    /**\n+     * Adds a new element to the list between the next and previous elements.\n+     *\n+     * @param obj  the object to add\n+     * @throws UnsupportedOperationException if the list is unmodifiable\n+     * @throws IllegalStateException if the iterator is not in a valid state for set\n+     */\n+    public void add(E obj) {\n+        // the validForUpdate flag is needed as the necessary previous()\n+        // method call re-enables remove and add\n+        if (validForUpdate == false) {\n+            throw new IllegalStateException(\"Cannot add to list until next() or previous() called\");\n+        }\n+        validForUpdate = false;\n+        iterator.add(obj);\n+        iterator.previous();\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start (which is the\n+     * end of the list as this is a reversed iterator)\n+     */\n+    public void reset() {\n+        iterator = list.listIterator(list.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/SingletonIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/** \n+ * <code>SingletonIterator</code> is an {@link Iterator} over a single \n+ * object instance.\n+ *\n+ * @since Commons Collections 2.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ * @author Rodney Waldhoff\n+ */\n+public class SingletonIterator<E>\n+        implements Iterator<E>, ResettableIterator<E> {\n+\n+    /** Whether remove is allowed */\n+    private final boolean removeAllowed;\n+    /** Is the cursor before the first element */\n+    private boolean beforeFirst = true;\n+    /** Has the element been removed */\n+    private boolean removed = false;\n+    /** The object */\n+    private E object;\n+\n+    /**\n+     * Constructs a new <code>SingletonIterator</code> where <code>remove</code>\n+     * is a permitted operation.\n+     *\n+     * @param object  the single object to return from the iterator\n+     */\n+    public SingletonIterator(E object) {\n+        this(object, true);\n+    }\n+\n+    /**\n+     * Constructs a new <code>SingletonIterator</code> optionally choosing if\n+     * <code>remove</code> is a permitted operation.\n+     *\n+     * @param object  the single object to return from the iterator\n+     * @param removeAllowed  true if remove is allowed\n+     * @since Commons Collections 3.1\n+     */\n+    public SingletonIterator(E object, boolean removeAllowed) {\n+        super();\n+        this.object = object;\n+        this.removeAllowed = removeAllowed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is another object available from the iterator?\n+     * <p>\n+     * This returns true if the single object hasn't been returned yet.\n+     * \n+     * @return true if the single object hasn't been returned yet\n+     */\n+    public boolean hasNext() {\n+        return (beforeFirst && !removed);\n+    }\n+\n+    /**\n+     * Get the next object from the iterator.\n+     * <p>\n+     * This returns the single object if it hasn't been returned yet.\n+     *\n+     * @return the single object\n+     * @throws NoSuchElementException if the single object has already \n+     *    been returned\n+     */\n+    public E next() {\n+        if (!beforeFirst || removed) {\n+            throw new NoSuchElementException();\n+        }\n+        beforeFirst = false;\n+        return object;\n+    }\n+\n+    /**\n+     * Remove the object from this iterator.\n+     * \n+     * @throws IllegalStateException if the <tt>next</tt> method has not\n+     *        yet been called, or the <tt>remove</tt> method has already\n+     *        been called after the last call to the <tt>next</tt>\n+     *        method.\n+     * @throws UnsupportedOperationException if remove is not supported\n+     */\n+    public void remove() {\n+        if (removeAllowed) {\n+            if (removed || beforeFirst) {\n+                throw new IllegalStateException();\n+            } else {\n+                object = null;\n+                removed = true;\n+            }\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    \n+    /**\n+     * Reset the iterator to the start.\n+     */\n+    public void reset() {\n+        beforeFirst = true;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/SingletonListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * <code>SingletonIterator</code> is an {@link ListIterator} over a single \n+ * object instance.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Rodney Waldhoff\n+ */\n+public class SingletonListIterator<E> implements ListIterator<E>, ResettableListIterator<E> {\n+\n+    private boolean beforeFirst = true;\n+    private boolean nextCalled = false;\n+    private boolean removed = false;\n+    private E object;\n+\n+    /**\n+     * Constructs a new <code>SingletonListIterator</code>.\n+     *\n+     * @param object  the single object to return from the iterator\n+     */\n+    public SingletonListIterator(E object) {\n+        super();\n+        this.object = object;\n+    }\n+\n+    /**\n+     * Is another object available from the iterator?\n+     * <p>\n+     * This returns true if the single object hasn't been returned yet.\n+     * \n+     * @return true if the single object hasn't been returned yet\n+     */\n+    public boolean hasNext() {\n+        return beforeFirst && !removed;\n+    }\n+\n+    /**\n+     * Is a previous object available from the iterator?\n+     * <p>\n+     * This returns true if the single object has been returned.\n+     * \n+     * @return true if the single object has been returned\n+     */\n+    public boolean hasPrevious() {\n+        return !beforeFirst && !removed;\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a subsequent\n+     * call to <tt>next</tt>.\n+     *\n+     * @return 0 or 1 depending on current state. \n+     */\n+    public int nextIndex() {\n+        return (beforeFirst ? 0 : 1);\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a subsequent\n+     * call to <tt>previous</tt>. A return value of -1 indicates that the iterator is currently at\n+     * the start.\n+     *\n+     * @return 0 or -1 depending on current state. \n+     */\n+    public int previousIndex() {\n+        return (beforeFirst ? -1 : 0);\n+    }\n+\n+    /**\n+     * Get the next object from the iterator.\n+     * <p>\n+     * This returns the single object if it hasn't been returned yet.\n+     *\n+     * @return the single object\n+     * @throws NoSuchElementException if the single object has already \n+     *    been returned\n+     */\n+    public E next() {\n+        if (!beforeFirst || removed) {\n+            throw new NoSuchElementException();\n+        }\n+        beforeFirst = false;\n+        nextCalled = true;\n+        return object;\n+    }\n+\n+    /**\n+     * Get the previous object from the iterator.\n+     * <p>\n+     * This returns the single object if it has been returned.\n+     *\n+     * @return the single object\n+     * @throws NoSuchElementException if the single object has not already \n+     *    been returned\n+     */\n+    public E previous() {\n+        if (beforeFirst || removed) {\n+            throw new NoSuchElementException();\n+        }\n+        beforeFirst = true;\n+        return object;\n+    }\n+\n+    /**\n+     * Remove the object from this iterator.\n+     * @throws IllegalStateException if the <tt>next</tt> or <tt>previous</tt> \n+     *        method has not yet been called, or the <tt>remove</tt> method \n+     *        has already been called after the last call to <tt>next</tt>\n+     *        or <tt>previous</tt>.\n+     */\n+    public void remove() {\n+        if(!nextCalled || removed) {\n+            throw new IllegalStateException();\n+        } else {\n+            object = null;\n+            removed = true;\n+        }\n+    }\n+    \n+    /**\n+     * Add always throws {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void add(E obj) {\n+        throw new UnsupportedOperationException(\"add() is not supported by this iterator\");\n+    }\n+    \n+    /**\n+     * Set sets the value of the singleton.\n+     *\n+     * @param obj  the object to set\n+     * @throws IllegalStateException if <tt>next</tt> has not been called \n+     *          or the object has been removed\n+     */\n+    public void set(E obj) {\n+        if (!nextCalled || removed) {\n+            throw new IllegalStateException();\n+        }\n+        this.object = obj;\n+    }\n+    \n+    /**\n+     * Reset the iterator back to the start.\n+     */\n+    public void reset() {\n+        beforeFirst = true;\n+        nextCalled = false;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/TransformIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/** \n+ * Decorates an iterator such that each element returned is transformed.\n+ *\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ */\n+public class TransformIterator<I, O> implements Iterator<O> {\n+\n+    /** The iterator being used */\n+    private Iterator<? extends I> iterator;\n+    /** The transformer being used */\n+    private Transformer<? super I, ? extends O> transformer;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>TransformIterator</code> that will not function\n+     * until the {@link #setIterator(Iterator) setIterator} and \n+     * {@link #setTransformer(Transformer)} methods are invoked.\n+     */\n+    public TransformIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>TransformIterator</code> that won't transform\n+     * elements from the given iterator.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public TransformIterator(Iterator<? extends I> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Constructs a new <code>TransformIterator</code> that will use the\n+     * given iterator and transformer.  If the given transformer is null,\n+     * then objects will not be transformed.\n+     *\n+     * @param iterator  the iterator to use\n+     * @param transformer  the transformer to use\n+     */\n+    public TransformIterator(Iterator<? extends I> iterator, Transformer<? super I, ? extends O> transformer) {\n+        super();\n+        this.iterator = iterator;\n+        this.transformer = transformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Gets the next object from the iteration, transforming it using the\n+     * current transformer. If the transformer is null, no transformation\n+     * occurs and the object from the iterator is returned directly.\n+     * \n+     * @return the next object\n+     * @throws java.util.NoSuchElementException if there are no more elements\n+     */\n+    public O next() {\n+        return transform(iterator.next());\n+    }\n+\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the iterator this iterator is using.\n+     * \n+     * @return the iterator.\n+     */\n+    public Iterator<? extends I> getIterator() {\n+        return iterator;\n+    }\n+\n+    /** \n+     * Sets the iterator for this iterator to use.\n+     * If iteration has started, this effectively resets the iterator.\n+     * \n+     * @param iterator  the iterator to use\n+     */\n+    public void setIterator(Iterator<? extends I> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the transformer this iterator is using.\n+     * \n+     * @return the transformer.\n+     */\n+    public Transformer<? super I, ? extends O> getTransformer() {\n+        return transformer;\n+    }\n+\n+    /** \n+     * Sets the transformer this the iterator to use.\n+     * A null transformer is a no-op transformer.\n+     * \n+     * @param transformer  the transformer to use\n+     */\n+    public void setTransformer(Transformer<? super I, ? extends O> transformer) {\n+        this.transformer = transformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms the given object using the transformer.\n+     * If the transformer is null, the original object is returned as-is.\n+     *\n+     * @param source  the object to transform\n+     * @return the transformed object\n+     */\n+    protected O transform(I source) {\n+        return transformer.transform(source);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/UniqueFilterIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.functors.UniquePredicate;\n+\n+/**\n+ * A FilterIterator which only returns \"unique\" Objects.  Internally,\n+ * the Iterator maintains a Set of objects it has already encountered,\n+ * and duplicate Objects are skipped.\n+ *\n+ * @since Commons Collections 2.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Morgan Delagrange\n+ */\n+public class UniqueFilterIterator<E> extends FilterIterator<E> {\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     *  Constructs a new <code>UniqueFilterIterator</code>.\n+     *\n+     *  @param iterator  the iterator to use\n+     */\n+    public UniqueFilterIterator(Iterator<E> iterator) {\n+        super(iterator, UniquePredicate.uniquePredicate());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/** \n+ * Decorates an iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableIterator<E> implements Iterator<E>, Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private final Iterator<E> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     * <p>\n+     * If the iterator is already unmodifiable it is returned directly.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <E> Iterator<E> unmodifiableIterator(Iterator<E> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"Iterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableIterator<E>(iterator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableIterator(Iterator<E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public E next() {\n+        return iterator.next();\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/** \n+ * Decorates a list iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableListIterator<E> implements ListIterator<E>, Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private ListIterator<E> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <E> ListIterator<E> umodifiableListIterator(ListIterator<E> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"ListIterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableListIterator<E>(iterator);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableListIterator(ListIterator<E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public E next() {\n+        return iterator.next();\n+    }\n+\n+    public int nextIndex() {\n+        return iterator.nextIndex();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    public E previous() {\n+        return iterator.previous();\n+    }\n+\n+    public int previousIndex() {\n+        return iterator.previousIndex();\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+    public void set(E obj) {\n+        throw new UnsupportedOperationException(\"set() is not supported\");\n+    }\n+\n+    public void add(E obj) {\n+        throw new UnsupportedOperationException(\"add() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/** \n+ * Decorates a map iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableMapIterator<K, V> implements MapIterator<K, V>, Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private final MapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(MapIterator<K, V> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"MapIterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableMapIterator<K, V>(iterator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableMapIterator(MapIterator<K, V> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    public V setValue(V value) {\n+        throw new UnsupportedOperationException(\"setValue() is not supported\");\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Decorates an ordered map iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>,\n+        Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private OrderedMapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(OrderedMapIterator<K, V> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableOrderedMapIterator(OrderedMapIterator<K, V> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    public K previous() {\n+        return iterator.previous();\n+    }\n+\n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    public V setValue(V value) {\n+        throw new UnsupportedOperationException(\"setValue() is not supported\");\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/AbstractKeyValue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * Abstract pair class to assist with creating <code>KeyValue</code>\n+ * and {@link java.util.Map.Entry Map.Entry} implementations.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractKeyValue<K, V> implements KeyValue<K, V> {\n+\n+    /** The key */\n+    protected K key;\n+    /** The value */\n+    protected V value;\n+\n+    /**\n+     * Constructs a new pair with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    protected AbstractKeyValue(K key, V value) {\n+        super();\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Gets the key from the pair.\n+     *\n+     * @return the key \n+     */\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Gets the value from the pair.\n+     *\n+     * @return the value\n+     */\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Gets a debugging String view of the pair.\n+     * \n+     * @return a String view of the entry\n+     */\n+    @Override\n+    public String toString() {\n+        return new StringBuilder()\n+            .append(getKey())\n+            .append('=')\n+            .append(getValue())\n+            .toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/AbstractMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+/**\n+ * Abstract Pair class to assist with creating correct\n+ * {@link java.util.Map.Entry Map.Entry} implementations.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractMapEntry<K, V> extends AbstractKeyValue<K, V> implements Map.Entry<K, V> {\n+\n+    /**\n+     * Constructs a new entry with the given key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    protected AbstractMapEntry(K key, V value) {\n+        super(key, value);\n+    }\n+\n+    // Map.Entry interface\n+    //-------------------------------------------------------------------------\n+    /** \n+     * Sets the value stored in this <code>Map.Entry</code>.\n+     * <p>\n+     * This <code>Map.Entry</code> is not connected to a Map, so only the\n+     * local data is changed.\n+     *\n+     * @param value  the new value\n+     * @return the previous value\n+     */\n+    public V setValue(V value) {\n+        V answer = this.value;\n+        this.value = value;\n+        return answer;\n+    }\n+\n+    /**\n+     * Compares this <code>Map.Entry</code> with another <code>Map.Entry</code>.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal key and value\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map.Entry == false) {\n+            return false;\n+        }\n+        Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+        return\n+            (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n+            (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n+    }\n+\n+    /**\n+     * Gets a hashCode compatible with the equals method.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (getValue() == null ? 0 : getValue().hashCode()); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/AbstractMapEntryDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * Provides a base decorator that allows additional functionality to be\n+ * added to a {@link java.util.Map.Entry Map.Entry}.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractMapEntryDecorator<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n+    \n+    /** The <code>Map.Entry</code> to decorate */\n+    protected final Map.Entry<K, V> entry;\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param entry  the <code>Map.Entry</code> to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractMapEntryDecorator(Map.Entry<K, V> entry) {\n+        if (entry == null) {\n+            throw new IllegalArgumentException(\"Map Entry must not be null\");\n+        }\n+        this.entry = entry;\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected Map.Entry<K, V> getMapEntry() {\n+        return entry;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K getKey() {\n+        return entry.getKey();\n+    }\n+\n+    public V getValue() {\n+        return entry.getValue();\n+    }\n+\n+    public V setValue(V object) {\n+        return entry.setValue(object);\n+    }\n+   \n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return entry.equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return entry.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return entry.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/DefaultKeyValue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * A mutable <code>KeyValue</code> pair that does not implement\n+ * {@link java.util.Map.Entry Map.Entry}.\n+ * <p>\n+ * Note that a <code>DefaultKeyValue</code> instance may not contain\n+ * itself as a key or value.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ */\n+public class DefaultKeyValue<K, V> extends AbstractKeyValue<K, V> {\n+\n+    /**\n+     * Constructs a new pair with a null key and null value.\n+     */\n+    public DefaultKeyValue() {\n+        super(null, null);\n+    }\n+\n+    /**\n+     * Constructs a new pair with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    public DefaultKeyValue(final K key, final V value) {\n+        super(key, value);\n+    }\n+\n+    /**\n+     * Constructs a new pair from the specified <code>KeyValue</code>.\n+     *\n+     * @param pair  the pair to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultKeyValue(final KeyValue<K, V> pair) {\n+        super(pair.getKey(), pair.getValue());\n+    }\n+\n+    /**\n+     * Constructs a new pair from the specified <code>Map.Entry</code>.\n+     *\n+     * @param entry  the entry to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultKeyValue(final Map.Entry<K, V> entry) {\n+        super(entry.getKey(), entry.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the key.\n+     *\n+     * @param key  the new key\n+     * @return the old key\n+     * @throws IllegalArgumentException if key is this object\n+     */\n+    public K setKey(final K key) {\n+        if (key == this) {\n+            throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a key.\");\n+        }\n+\n+        final K old = this.key;\n+        this.key = key;\n+        return old;\n+    }\n+\n+    /** \n+     * Sets the value.\n+     *\n+     * @return the old value of the value\n+     * @param value the new value\n+     * @throws IllegalArgumentException if value is this object\n+     */\n+    public V setValue(final V value) {\n+        if (value == this) {\n+            throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a value.\");\n+        }\n+\n+        final V old = this.value;\n+        this.value = value;\n+        return old;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new <code>Map.Entry</code> object with key and value from this pair.\n+     * \n+     * @return a MapEntry instance\n+     */\n+    public Map.Entry<K, V> toMapEntry() {\n+        return new DefaultMapEntry<K, V>(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this <code>Map.Entry</code> with another <code>Map.Entry</code>.\n+     * <p>\n+     * Returns true if the compared object is also a <code>DefaultKeyValue</code>,\n+     * and its key and value are equal to this object's key and value.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal key and value\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof DefaultKeyValue == false) {\n+            return false;\n+        }\n+\n+        DefaultKeyValue<?, ?> other = (DefaultKeyValue<?, ?>) obj;\n+        return \n+            (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n+            (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n+    }\n+\n+    /**\n+     * Gets a hashCode compatible with the equals method.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()},\n+     * however subclasses may override this.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (getValue() == null ? 0 : getValue().hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/DefaultMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * A restricted implementation of {@link java.util.Map.Entry} that prevents\n+ * the <code>Map.Entry</code> contract from being broken.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ */\n+public final class DefaultMapEntry<K, V> extends AbstractMapEntry<K, V> {\n+\n+    /**\n+     * Constructs a new entry with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    public DefaultMapEntry(final K key, final V value) {\n+        super(key, value);\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>KeyValue</code>.\n+     *\n+     * @param pair  the pair to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultMapEntry(final KeyValue<K, V> pair) {\n+        super(pair.getKey(), pair.getValue());\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>Map.Entry</code>.\n+     *\n+     * @param entry  the entry to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultMapEntry(final Map.Entry<K, V> entry) {\n+        super(entry.getKey(), entry.getValue());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/MultiKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/** \n+ * A <code>MultiKey</code> allows multiple map keys to be merged together.\n+ * <p>\n+ * The purpose of this class is to avoid the need to write code to handle\n+ * maps of maps. An example might be the need to look up a file name by \n+ * key and locale. The typical solution might be nested maps. This class\n+ * can be used instead by creating an instance passing in the key and locale.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * // populate map with data mapping key+locale to localizedText\n+ * Map map = new HashMap();\n+ * MultiKey multiKey = new MultiKey(key, locale);\n+ * map.put(multiKey, localizedText);\n+ *\n+ * // later retrieve the localized text\n+ * MultiKey multiKey = new MultiKey(key, locale);\n+ * String localizedText = (String) map.get(multiKey);\n+ * </pre>\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Howard Lewis Ship\n+ * @author Stephen Colebourne\n+ */\n+public class MultiKey<K> implements Serializable {\n+    // This class could implement List, but that would confuse it's purpose\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = 4465448607415788805L;\n+\n+    /** The individual keys */\n+    private final K[] keys;\n+    /** The cached hashCode */\n+    private transient int hashCode;\n+\n+    /**\n+     * Constructor taking two keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2) {\n+        this((K[]) new Object[] { key1, key2 }, false);\n+    }\n+\n+    /**\n+     * Constructor taking three keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2, K key3) {\n+        this((K[]) new Object[] {key1, key2, key3}, false);\n+    }\n+\n+    /**\n+     * Constructor taking four keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2, K key3, K key4) {\n+        this((K[]) new Object[] {key1, key2, key3, key4}, false);\n+    }\n+\n+    /**\n+     * Constructor taking five keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(K key1, K key2, K key3, K key4, K key5) {\n+        this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);\n+    }\n+\n+    /**\n+     * Constructor taking an array of keys which is cloned.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * <p>\n+     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n+     *\n+     * @param keys  the array of keys, not null\n+     * @throws IllegalArgumentException if the key array is null\n+     */\n+    public MultiKey(K[] keys) {\n+        this(keys, true);\n+    }\n+\n+    /**\n+     * Constructor taking an array of keys, optionally choosing whether to clone.\n+     * <p>\n+     * <b>If the array is not cloned, then it must not be modified.</b>\n+     * <p>\n+     * This method is public for performance reasons only, to avoid a clone.\n+     * The hashcode is calculated once here in this method.\n+     * Therefore, changing the array passed in would not change the hashcode but\n+     * would change the equals method, which is a bug.\n+     * <p>\n+     * This is the only fully safe usage of this constructor, as the object array\n+     * is never made available in a variable:\n+     * <pre>\n+     * new MultiKey(new Object[] {...}, false);\n+     * </pre>\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     *\n+     * @param keys  the array of keys, not null\n+     * @param makeClone  true to clone the array, false to assign it\n+     * @throws IllegalArgumentException if the key array is null\n+     * @since Commons Collections 3.1\n+     */\n+    public MultiKey(K[] keys, boolean makeClone) {\n+        super();\n+        if (keys == null) {\n+            throw new IllegalArgumentException(\"The array of keys must not be null\");\n+        }\n+        if (makeClone) {\n+            this.keys = keys.clone();\n+        } else {\n+            this.keys = keys;\n+        }\n+\n+        calculateHashCode(keys);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a clone of the array of keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed.\n+     * \n+     * @return the individual keys\n+     */\n+    public K[] getKeys() {\n+        return keys.clone();\n+    }\n+\n+    /**\n+     * Gets the key at the specified index.\n+     * <p>\n+     * The key should be immutable.\n+     * If it is not then it must not be changed.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @since Commons Collections 3.1\n+     */\n+    public K getKey(int index) {\n+        return keys[index];\n+    }\n+\n+    /**\n+     * Gets the size of the list of keys.\n+     * \n+     * @return the size of the list of keys\n+     * @since Commons Collections 3.1\n+     */\n+    public int size() {\n+        return keys.length;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to another.\n+     * <p>\n+     * To be equal, the other object must be a <code>MultiKey</code> with the\n+     * same number of keys which are also equal.\n+     * \n+     * @param other  the other object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        if (other == this) {\n+            return true;\n+        }\n+        if (other instanceof MultiKey) {\n+            MultiKey<?> otherMulti = (MultiKey<?>) other;\n+            return Arrays.equals(keys, otherMulti.keys);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the combined hash code that is computed from all the keys.\n+     * <p>\n+     * This value is computed once and then cached, so elements should not\n+     * change their hash codes once created (note that this is the same \n+     * constraint that would be used if the individual keys elements were\n+     * themselves {@link java.util.Map Map} keys.\n+     * \n+     * @return the hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+\n+    /**\n+     * Gets a debugging string version of the key.\n+     * \n+     * @return a debugging string\n+     */\n+    @Override\n+    public String toString() {\n+        return \"MultiKey\" + Arrays.asList(keys).toString();\n+    }\n+\n+    /**\n+     * Calculate the hash code of the instance using the provided keys.\n+     * @param keys\n+     */\n+    private void calculateHashCode(Object[] keys)\n+    {\n+        int total = 0;\n+        for (int i = 0; i < keys.length; i++) {\n+            if (keys[i] != null) {\n+                total ^= keys[i].hashCode();\n+            }\n+        }\n+        hashCode = total;\n+    }\n+    \n+    /**\n+     * Recalculate the hash code after deserialization. The hash code of some\n+     * keys might have change (hash codes based on the system hash code are\n+     * only stable for the same process). \n+     * @return the instance with recalculated hash code\n+     */\n+    private Object readResolve() {\n+        calculateHashCode(keys);\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/TiedMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * A {@link java.util.Map.Entry Map.Entry} tied to a map underneath.\n+ * <p>\n+ * This can be used to enable a map entry to make changes on the underlying\n+ * map, however this will probably mess up any iterators.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TiedMapEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V>, Serializable {\n+\n+    /** Serialization version */    \n+    private static final long serialVersionUID = -8453869361373831205L;\n+\n+    /** The map underlying the entry/iterator */    \n+    private final Map<K, V> map;\n+\n+    /** The key */\n+    private final K key;\n+\n+    /**\n+     * Constructs a new entry with the given Map and key.\n+     *\n+     * @param map  the map\n+     * @param key  the key\n+     */\n+    public TiedMapEntry(Map<K, V> map, K key) {\n+        super();\n+        this.map = map;\n+        this.key = key;\n+    }\n+\n+    // Map.Entry interface\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets the key of this entry\n+     * \n+     * @return the key\n+     */\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Gets the value of this entry direct from the map.\n+     * \n+     * @return the value\n+     */\n+    public V getValue() {\n+        return map.get(key);\n+    }\n+\n+    /**\n+     * Sets the value associated with the key direct onto the map.\n+     * \n+     * @param value  the new value\n+     * @return the old value\n+     * @throws IllegalArgumentException if the value is set to this map entry\n+     */\n+    public V setValue(V value) {\n+        if (value == this) {\n+            throw new IllegalArgumentException(\"Cannot set value to this map entry\");\n+        }\n+        return map.put(key, value);\n+    }\n+\n+    /**\n+     * Compares this <code>Map.Entry</code> with another <code>Map.Entry</code>.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal key and value\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map.Entry == false) {\n+            return false;\n+        }\n+        Map.Entry<?,?> other = (Map.Entry<?,?>) obj;\n+        Object value = getValue();\n+        return\n+            (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n+            (value == null ? other.getValue() == null : value.equals(other.getValue()));\n+    }\n+\n+    /**\n+     * Gets a hashCode compatible with the equals method.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        Object value = getValue();\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (value == null ? 0 : value.hashCode()); \n+    }\n+\n+    /**\n+     * Gets a string version of the entry.\n+     * \n+     * @return entry as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return getKey() + \"=\" + getValue();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * A {@link java.util.Map.Entry Map.Entry} that throws\n+ * UnsupportedOperationException when <code>setValue</code> is called.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableMapEntry<K, V> extends AbstractMapEntry<K, V> implements Unmodifiable {\n+\n+    /**\n+     * Constructs a new entry with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    public UnmodifiableMapEntry(final K key, final V value) {\n+        super(key, value);\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>KeyValue</code>.\n+     *\n+     * @param pair  the pair to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public UnmodifiableMapEntry(final KeyValue<K, V> pair) {\n+        super(pair.getKey(), pair.getValue());\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>Map.Entry</code>.\n+     *\n+     * @param entry  the entry to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public UnmodifiableMapEntry(final Map.Entry<K, V> entry) {\n+        super(entry.getKey(), entry.getValue());\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     * \n+     * @param value  the new value\n+     * @return the previous value\n+     * @throws UnsupportedOperationException always\n+     */\n+    @Override\n+    public V setValue(V value) {\n+        throw new UnsupportedOperationException(\"setValue() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/AbstractLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.OrderedIterator;\n+\n+/**\n+ * An abstract implementation of a linked list which provides numerous points for\n+ * subclasses to override.\n+ * <p>\n+ * Overridable methods are provided to change the storage node and to change how\n+ * nodes are added to and removed. Hopefully, all you need for unusual subclasses\n+ * is here.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rich Dougherty\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractLinkedList<E> implements List<E> {\n+\n+    /*\n+     * Implementation notes:\n+     * - a standard circular doubly-linked list\n+     * - a marker node is stored to mark the start and the end of the list\n+     * - node creation and removal always occurs through createNode() and\n+     *   removeNode().\n+     * - a modification count is kept, with the same semantics as\n+     * {@link java.util.LinkedList}.\n+     * - respects {@link AbstractList#modCount}\n+     */\n+\n+    /**\n+     * A {@link Node} which indicates the start and end of the list and does not\n+     * hold a value. The value of <code>next</code> is the first item in the\n+     * list. The value of of <code>previous</code> is the last item in the list.\n+     */\n+    protected transient Node<E> header;\n+\n+    /** The size of the list */\n+    protected transient int size;\n+\n+    /** Modification count for iterators */\n+    protected transient int modCount;\n+\n+    /**\n+     * Constructor that does nothing intended for deserialization.\n+     * <p>\n+     * If this constructor is used by a serializable subclass then the init()\n+     * method must be called.\n+     */\n+    protected AbstractLinkedList() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a list copying data from the specified collection.\n+     *\n+     * @param coll  the collection to copy\n+     */\n+    protected AbstractLinkedList(Collection<? extends E> coll) {\n+        super();\n+        init();\n+        addAll(coll);\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor, broken out so it can be called\n+     * by any constructor and by <code>readObject</code>.\n+     * Subclasses which override this method should make sure they call super,\n+     * so the list is initialised properly.\n+     */\n+    protected void init() {\n+        header = createHeaderNode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int size() {\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    public E get(int index) {\n+        Node<E> node = getNode(index, false);\n+        return node.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Iterator<E> iterator() {\n+        return listIterator();\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return new LinkedListIterator<E>(this, 0);\n+    }\n+\n+    public ListIterator<E> listIterator(int fromIndex) {\n+        return new LinkedListIterator<E>(this, fromIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int indexOf(Object value) {\n+        int i = 0;\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                return i;\n+            }\n+            i++;\n+        }\n+        return -1;\n+    }\n+\n+    public int lastIndexOf(Object value) {\n+        int i = size - 1;\n+        for (Node<E> node = header.previous; node != header; node = node.previous) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                return i;\n+            }\n+            i--;\n+        }\n+        return -1;\n+    }\n+\n+    public boolean contains(Object value) {\n+        return indexOf(value) != -1;\n+    }\n+\n+    public boolean containsAll(Collection<?> coll) {\n+        for (Object o : coll) {\n+            if (!contains(o)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Object[] toArray() {\n+        return toArray(new Object[size]);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n+        // Extend the array if needed\n+        if (array.length < size) {\n+            Class<?> componentType = array.getClass().getComponentType();\n+            array = (T[]) Array.newInstance(componentType, size);\n+        }\n+        // Copy the values into the array\n+        int i = 0;\n+        for (Node<E> node = header.next; node != header; node = node.next, i++) {\n+            array[i] = (T) node.getValue();\n+        }\n+        // Set the value after the last value to null\n+        if (array.length > size) {\n+            array[size] = null;\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Gets a sublist of the main list.\n+     *\n+     * @param fromIndexInclusive  the index to start from\n+     * @param toIndexExclusive  the index to end at\n+     * @return the new sublist\n+     */\n+    public List<E> subList(int fromIndexInclusive, int toIndexExclusive) {\n+        return new LinkedSubList<E>(this, fromIndexInclusive, toIndexExclusive);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean add(E value) {\n+        addLast(value);\n+        return true;\n+    }\n+\n+    public void add(int index, E value) {\n+        Node<E> node = getNode(index, true);\n+        addNodeBefore(node, value);\n+    }\n+\n+    public boolean addAll(Collection<? extends E> coll) {\n+        return addAll(size, coll);\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        Node<E> node = getNode(index, true);\n+        for (E e : coll) {\n+            addNodeBefore(node, e);\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E remove(int index) {\n+        Node<E> node = getNode(index, false);\n+        E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    public boolean remove(Object value) {\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                removeNode(node);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean removeAll(Collection<?> coll) {\n+        boolean modified = false;\n+        Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (coll.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean retainAll(Collection<?> coll) {\n+        boolean modified = false;\n+        Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (coll.contains(it.next()) == false) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    public E set(int index, E value) {\n+        Node<E> node = getNode(index, false);\n+        E oldValue = node.getValue();\n+        updateNode(node, value);\n+        return oldValue;\n+    }\n+\n+    public void clear() {\n+        removeAllNodes();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E getFirst() {\n+        Node<E> node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.getValue();\n+    }\n+\n+    public E getLast() {\n+        Node<E> node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.getValue();\n+    }\n+\n+    public boolean addFirst(E o) {\n+        addNodeAfter(header, o);\n+        return true;\n+    }\n+\n+    public boolean addLast(E o) {\n+        addNodeBefore(header, o);\n+        return true;\n+    }\n+\n+    public E removeFirst() {\n+        Node<E> node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    public E removeLast() {\n+        Node<E> node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof List == false) {\n+            return false;\n+        }\n+        List<?> other = (List<?>) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        ListIterator<?> it1 = listIterator();\n+        ListIterator<?> it2 = other.listIterator();\n+        while (it1.hasNext() && it2.hasNext()) {\n+            Object o1 = it1.next();\n+            Object o2 = it2.next();\n+            if (!(o1 == null ? o2 == null : o1.equals(o2)))\n+                return false;\n+        }\n+        return !(it1.hasNext() || it2.hasNext());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 1;\n+        for (E e : this) {\n+            hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n+        }\n+        return hashCode;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"[]\";\n+        }\n+        StringBuilder buf = new StringBuilder(16 * size());\n+        buf.append(\"[\");\n+\n+        Iterator<E> it = iterator();\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            Object value = it.next();\n+            buf.append(value == this ? \"(this Collection)\" : value);\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+        buf.append(\"]\");\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses the equals method.\n+     * Subclasses can override this to match differently.\n+     *\n+     * @param value1  the first value to compare, may be null\n+     * @param value2  the second value to compare, may be null\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(Object value1, Object value2) {\n+        return (value1 == value2 || (value1 == null ? false : value1.equals(value2)));\n+    }\n+\n+    /**\n+     * Updates the node with a new value.\n+     * This implementation sets the value on the node.\n+     * Subclasses can override this to record the change.\n+     *\n+     * @param node  node to update\n+     * @param value  new value of the node\n+     */\n+    protected void updateNode(Node<E> node, E value) {\n+        node.setValue(value);\n+    }\n+\n+    /**\n+     * Creates a new node with previous, next and element all set to null.\n+     * This implementation creates a new empty Node.\n+     * Subclasses can override this to create a different class.\n+     *\n+     * @return  newly created node\n+     */\n+    protected Node<E> createHeaderNode() {\n+        return new Node<E>();\n+    }\n+\n+    /**\n+     * Creates a new node with the specified properties.\n+     * This implementation creates a new Node with data.\n+     * Subclasses can override this to create a different class.\n+     *\n+     * @param value  value of the new node\n+     */\n+    protected Node<E> createNode(E value) {\n+        return new Node<E>(value);\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its\n+     * <code>value</code> and inserts it before <code>node</code>.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and\n+     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n+     *\n+     * @param node  node to insert before\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void addNodeBefore(Node<E> node, E value) {\n+        Node<E> newNode = createNode(value);\n+        addNode(newNode, node);\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its\n+     * <code>value</code> and inserts it after <code>node</code>.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and\n+     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n+     *\n+     * @param node  node to insert after\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void addNodeAfter(Node<E> node, E value) {\n+        Node<E> newNode = createNode(value);\n+        addNode(newNode, node.next);\n+    }\n+\n+    /**\n+     * Inserts a new node into the list.\n+     *\n+     * @param nodeToInsert  new node to insert\n+     * @param insertBeforeNode  node to insert before\n+     * @throws NullPointerException if either node is null\n+     */\n+    protected void addNode(Node<E> nodeToInsert, Node<E> insertBeforeNode) {\n+        nodeToInsert.next = insertBeforeNode;\n+        nodeToInsert.previous = insertBeforeNode.previous;\n+        insertBeforeNode.previous.next = nodeToInsert;\n+        insertBeforeNode.previous = nodeToInsert;\n+        size++;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Removes the specified node from the list.\n+     *\n+     * @param node  the node to remove\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void removeNode(Node<E> node) {\n+        node.previous.next = node.next;\n+        node.next.previous = node.previous;\n+        size--;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Removes all nodes by resetting the circular list marker.\n+     */\n+    protected void removeAllNodes() {\n+        header.next = header;\n+        header.previous = header;\n+        size = 0;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Gets the node at a particular index.\n+     *\n+     * @param index  the index, starting from 0\n+     * @param endMarkerAllowed  whether or not the end marker can be returned if\n+     * startIndex is set to the list's size\n+     * @throws IndexOutOfBoundsException if the index is less than 0; equal to\n+     * the size of the list and endMakerAllowed is false; or greater than the\n+     * size of the list\n+     */\n+    protected Node<E> getNode(int index, boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n+        // Check the index is within the bounds\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") less than zero.\");\n+        }\n+        if (!endMarkerAllowed && index == size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") is the size of the list.\");\n+        }\n+        if (index > size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") greater than the size of the \" +\n+                    \"list (\" + size + \").\");\n+        }\n+        // Search the list and get the node\n+        Node<E> node;\n+        if (index < (size / 2)) {\n+            // Search forwards\n+            node = header.next;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                node = node.next;\n+            }\n+        } else {\n+            // Search backwards\n+            node = header;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                node = node.previous;\n+            }\n+        }\n+        return node;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates an iterator for the sublist.\n+     *\n+     * @param subList  the sublist to get an iterator for\n+     */\n+    protected Iterator<E> createSubListIterator(LinkedSubList<E> subList) {\n+        return createSubListListIterator(subList, 0);\n+    }\n+\n+    /**\n+     * Creates a list iterator for the sublist.\n+     *\n+     * @param subList  the sublist to get an iterator for\n+     * @param fromIndex  the index to start from, relative to the sublist\n+     */\n+    protected ListIterator<E> createSubListListIterator(LinkedSubList<E> subList, int fromIndex) {\n+        return new LinkedSubListIterator<E>(subList, fromIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * <code>writeObject</code>.\n+     */\n+    protected void doWriteObject(ObjectOutputStream outputStream) throws IOException {\n+        // Write the size so we know how many nodes to read back\n+        outputStream.writeInt(size());\n+        for (Iterator<E> itr = iterator(); itr.hasNext();) {\n+            outputStream.writeObject(itr.next());\n+        }\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * <code>readObject</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n+        init();\n+        int size = inputStream.readInt();\n+        for (int i = 0; i < size; i++) {\n+            add((E) inputStream.readObject());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node within the linked list.\n+     * <p>\n+     * From Commons Collections 3.1, all access to the <code>value</code> property\n+     * is via the methods on this class.\n+     */\n+    protected static class Node<E> {\n+\n+        /** A pointer to the node before this node */\n+        protected Node<E> previous;\n+        /** A pointer to the node after this node */\n+        protected Node<E> next;\n+        /** The object contained within this node */\n+        protected E value;\n+\n+        /**\n+         * Constructs a new header node.\n+         */\n+        protected Node() {\n+            super();\n+            previous = this;\n+            next = this;\n+        }\n+\n+        /**\n+         * Constructs a new node.\n+         *\n+         * @param value  the value to store\n+         */\n+        protected Node(E value) {\n+            super();\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Constructs a new node.\n+         *\n+         * @param previous  the previous node in the list\n+         * @param next  the next node in the list\n+         * @param value  the value to store\n+         */\n+        protected Node(Node<E> previous, Node<E> next, E value) {\n+            super();\n+            this.previous = previous;\n+            this.next = next;\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Gets the value of the node.\n+         *\n+         * @return the value\n+         * @since Commons Collections 3.1\n+         */\n+        protected E getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the value of the node.\n+         *\n+         * @param value  the value\n+         * @since Commons Collections 3.1\n+         */\n+        protected void setValue(E value) {\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Gets the previous node.\n+         *\n+         * @return the previous node\n+         * @since Commons Collections 3.1\n+         */\n+        protected Node<E> getPreviousNode() {\n+            return previous;\n+        }\n+\n+        /**\n+         * Sets the previous node.\n+         *\n+         * @param previous  the previous node\n+         * @since Commons Collections 3.1\n+         */\n+        protected void setPreviousNode(Node<E> previous) {\n+            this.previous = previous;\n+        }\n+\n+        /**\n+         * Gets the next node.\n+         *\n+         * @return the next node\n+         * @since Commons Collections 3.1\n+         */\n+        protected Node<E> getNextNode() {\n+            return next;\n+        }\n+\n+        /**\n+         * Sets the next node.\n+         *\n+         * @param next  the next node\n+         * @since Commons Collections 3.1\n+         */\n+        protected void setNextNode(Node<E> next) {\n+            this.next = next;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A list iterator over the linked list.\n+     */\n+    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n+\n+        /** The parent list */\n+        protected final AbstractLinkedList<E> parent;\n+\n+        /**\n+         * The node that will be returned by {@link #next()}. If this is equal\n+         * to {@link AbstractLinkedList#header} then there are no more values to return.\n+         */\n+        protected Node<E> next;\n+\n+        /**\n+         * The index of {@link #next}.\n+         */\n+        protected int nextIndex;\n+\n+        /**\n+         * The last node that was returned by {@link #next()} or {@link\n+         * #previous()}. Set to <code>null</code> if {@link #next()} or {@link\n+         * #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n+         * this behaviour.\n+         */\n+        protected Node<E> current;\n+\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         *\n+         * @param parent  the parent list\n+         * @param fromIndex  the index to start at\n+         */\n+        protected LinkedListIterator(AbstractLinkedList<E> parent, int fromIndex) throws IndexOutOfBoundsException {\n+            super();\n+            this.parent = parent;\n+            this.expectedModCount = parent.modCount;\n+            this.next = parent.getNode(fromIndex, true);\n+            this.nextIndex = fromIndex;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         *\n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        /**\n+         * Gets the last node returned.\n+         *\n+         * @throws IllegalStateException If {@link #next()} or\n+         * {@link #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         */\n+        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current;\n+        }\n+\n+        public boolean hasNext() {\n+            return next != parent.header;\n+        }\n+\n+        public E next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n+            }\n+            E value = next.getValue();\n+            current = next;\n+            next = next.next;\n+            nextIndex++;\n+            return value;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return next.previous != parent.header;\n+        }\n+\n+        public E previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            next = next.previous;\n+            E value = next.getValue();\n+            current = next;\n+            nextIndex--;\n+            return value;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            // not normally overridden, as relative to nextIndex()\n+            return nextIndex() - 1;\n+        }\n+\n+        public void remove() {\n+            checkModCount();\n+            if (current == next) {\n+                // remove() following previous()\n+                next = next.next;\n+                parent.removeNode(getLastNodeReturned());\n+            } else {\n+                // remove() following next()\n+                parent.removeNode(getLastNodeReturned());\n+                nextIndex--;\n+            }\n+            current = null;\n+            expectedModCount++;\n+        }\n+\n+        public void set(E obj) {\n+            checkModCount();\n+            getLastNodeReturned().setValue(obj);\n+        }\n+\n+        public void add(E obj) {\n+            checkModCount();\n+            parent.addNodeBefore(next, obj);\n+            current = null;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A list iterator over the linked sub list.\n+     */\n+    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n+\n+        /** The parent list */\n+        protected final LinkedSubList<E> sub;\n+\n+        protected LinkedSubListIterator(LinkedSubList<E> sub, int startIndex) {\n+            super(sub.parent, startIndex + sub.offset);\n+            this.sub = sub;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return (nextIndex() < sub.size);\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+            return (previousIndex() >= 0);\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+            return (super.nextIndex() - sub.offset);\n+        }\n+\n+        @Override\n+        public void add(E obj) {\n+            super.add(obj);\n+            sub.expectedModCount = parent.modCount;\n+            sub.size++;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            sub.expectedModCount = parent.modCount;\n+            sub.size--;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The sublist implementation for AbstractLinkedList.\n+     */\n+    protected static class LinkedSubList<E> extends AbstractList<E> {\n+        /** The main list */\n+        AbstractLinkedList<E> parent;\n+        /** Offset from the main list */\n+        int offset;\n+        /** Sublist size */\n+        int size;\n+        /** Sublist modCount */\n+        int expectedModCount;\n+\n+        protected LinkedSubList(AbstractLinkedList<E> parent, int fromIndex, int toIndex) {\n+            if (fromIndex < 0) {\n+                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n+            }\n+            if (toIndex > parent.size()) {\n+                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n+            }\n+            if (fromIndex > toIndex) {\n+                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n+            }\n+            this.parent = parent;\n+            this.offset = fromIndex;\n+            this.size = toIndex - fromIndex;\n+            this.expectedModCount = parent.modCount;\n+        }\n+\n+        @Override\n+        public int size() {\n+            checkModCount();\n+            return size;\n+        }\n+\n+        @Override\n+        public E get(int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return parent.get(index + offset);\n+        }\n+\n+        @Override\n+        public void add(int index, E obj) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            parent.add(index + offset, obj);\n+            expectedModCount = parent.modCount;\n+            size++;\n+            LinkedSubList.this.modCount++;\n+        }\n+\n+        @Override\n+        public E remove(int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            E result = parent.remove(index + offset);\n+            expectedModCount = parent.modCount;\n+            size--;\n+            LinkedSubList.this.modCount++;\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends E> coll) {\n+            return addAll(size, coll);\n+        }\n+\n+        @Override\n+        public boolean addAll(int index, Collection<? extends E> coll) {\n+            rangeCheck(index, size + 1);\n+            int cSize = coll.size();\n+            if (cSize == 0) {\n+                return false;\n+            }\n+\n+            checkModCount();\n+            parent.addAll(offset + index, coll);\n+            expectedModCount = parent.modCount;\n+            size += cSize;\n+            LinkedSubList.this.modCount++;\n+            return true;\n+        }\n+\n+        @Override\n+        public E set(int index, E obj) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return parent.set(index + offset, obj);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            checkModCount();\n+            Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            checkModCount();\n+            return parent.createSubListIterator(this);\n+        }\n+\n+        @Override\n+        public ListIterator<E> listIterator(final int index) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            return parent.createSubListListIterator(this, index);\n+        }\n+\n+        @Override\n+        public List<E> subList(int fromIndexInclusive, int toIndexExclusive) {\n+            return new LinkedSubList<E>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n+        }\n+\n+        protected void rangeCheck(int index, int beyond) {\n+            if (index < 0 || index >= beyond) {\n+                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n+            }\n+        }\n+\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/AbstractListDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another <code>List</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated list.\n+ *\n+ * @param <E> the type of the elements in the list\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractListDecorator<E> extends AbstractCollectionDecorator<E> implements\n+        List<E> {\n+\n+    /** Serialization version--necessary in an abstract class? */\n+    private static final long serialVersionUID = 4500739654952315623L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractListDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractListDecorator(List<E> list) {\n+        super(list);\n+    }\n+\n+    /**\n+     * Gets the list being decorated.\n+     * \n+     * @return the decorated list\n+     */\n+    @Override\n+    protected List<E> decorated() {\n+        return (List<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void add(int index, E object) {\n+        decorated().add(index, object);\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        return decorated().addAll(index, coll);\n+    }\n+\n+    public E get(int index) {\n+        return decorated().get(index);\n+    }\n+\n+    public int indexOf(Object object) {\n+        return decorated().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(Object object) {\n+        return decorated().lastIndexOf(object);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return decorated().listIterator();\n+    }\n+\n+    public ListIterator<E> listIterator(int index) {\n+        return decorated().listIterator(index);\n+    }\n+\n+    public E remove(int index) {\n+        return decorated().remove(index);\n+    }\n+\n+    public E set(int index, E object) {\n+        return decorated().set(index, object);\n+    }\n+\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        return decorated().subList(fromIndex, toIndex);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/AbstractSerializableListDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Serializable subclass of AbstractListDecorator.\n+ *\n+ * @author Stephen Colebourne\n+ * @since Commons Collections 3.1\n+ */\n+public abstract class AbstractSerializableListDecorator<E>\n+        extends AbstractListDecorator<E>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2684959196747496299L;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractSerializableListDecorator(List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the list out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the list in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * A <code>List</code> implementation with a <code>ListIterator</code> that\n+ * allows concurrent modifications to the underlying list.\n+ * <p>\n+ * This implementation supports all of the optional {@link List} operations.\n+ * It extends <code>AbstractLinkedList</code> and thus provides the\n+ * stack/queue/dequeue operations available in {@link java.util.LinkedList}.\n+ * <p>\n+ * The main feature of this class is the ability to modify the list and the\n+ * iterator at the same time. Both the {@link #listIterator()} and {@link #cursor()}\n+ * methods provides access to a <code>Cursor</code> instance which extends\n+ * <code>ListIterator</code>. The cursor allows changes to the list concurrent\n+ * with changes to the iterator. Note that the {@link #iterator()} method and\n+ * sublists do <b>not</b> provide this cursor behaviour.\n+ * <p>\n+ * The <code>Cursor</code> class is provided partly for backwards compatibility\n+ * and partly because it allows the cursor to be directly closed. Closing the\n+ * cursor is optional because references are held via a <code>WeakReference</code>.\n+ * For most purposes, simply modify the iterator and list at will, and then let\n+ * the garbage collector to the rest.\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b>\n+ *\n+ * @see java.util.LinkedList\n+ * @since Commons Collections 1.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Janek Bogucki\n+ * @author Simon Kitching\n+ * @author Stephen Colebourne\n+ */\n+public class CursorableLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n+\n+    /** Ensure serialization compatibility */\n+    private static final long serialVersionUID = 8836393098519411393L;\n+\n+    /** A list of the cursor currently open on this list */\n+    protected transient List<WeakReference<Cursor<E>>> cursors;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates.\n+     */\n+    public CursorableLinkedList() {\n+        super();\n+        init(); // must call init() as use super();\n+    }\n+\n+    /**\n+     * Constructor that copies the specified collection\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    public CursorableLinkedList(Collection<E> coll) {\n+        super(coll);\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor called\n+     * by any constructor and by <code>readObject</code>.\n+     */\n+    @Override\n+    protected void init() {\n+        super.init();\n+        cursors = new ArrayList<WeakReference<Cursor<E>>>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an iterator that does <b>not</b> support concurrent modification.\n+     * <p>\n+     * If the underlying list is modified while iterating using this iterator\n+     * a ConcurrentModificationException will occur.\n+     * The cursor behaviour is available via {@link #listIterator()}.\n+     * \n+     * @return a new iterator that does <b>not</b> support concurrent modification\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return super.listIterator(0);\n+    }\n+\n+    /**\n+     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * \n+     * @return a new cursor iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return cursor(0);\n+    }\n+\n+    /**\n+     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * \n+     * @param fromIndex  the index to start from\n+     * @return a new cursor iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator(int fromIndex) {\n+        return cursor(fromIndex);\n+    }\n+\n+    /**\n+     * Returns a {@link Cursor} for iterating through the elements of this list.\n+     * <p>\n+     * A <code>Cursor</code> is a <code>ListIterator</code> with an additional\n+     * <code>close()</code> method. Calling this method immediately discards the\n+     * references to the cursor. If it is not called, then the garbage collector\n+     * will still remove the reference as it is held via a <code>WeakReference</code>.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * <p>\n+     * The {@link #listIterator()} method returns the same as this method, and can\n+     * be cast to a <code>Cursor</code> if the <code>close</code> method is required.\n+     *\n+     * @return a new cursor iterator\n+     */\n+    public CursorableLinkedList.Cursor<E> cursor() {\n+        return cursor(0);\n+    }\n+\n+    /**\n+     * Returns a {@link Cursor} for iterating through the elements of this list\n+     * starting from a specified index.\n+     * <p>\n+     * A <code>Cursor</code> is a <code>ListIterator</code> with an additional\n+     * <code>close()</code> method. Calling this method immediately discards the\n+     * references to the cursor. If it is not called, then the garbage collector\n+     * will still remove the reference as it is held via a <code>WeakReference</code>.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * <p>\n+     * The {@link #listIterator(int)} method returns the same as this method, and can\n+     * be cast to a <code>Cursor</code> if the <code>close</code> method is required.\n+     *\n+     * @param fromIndex  the index to start from\n+     * @return a new cursor iterator\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     *      (index &lt; 0 || index &gt; size()).\n+     */\n+    public CursorableLinkedList.Cursor<E> cursor(int fromIndex) {\n+        Cursor<E> cursor = new Cursor<E>(this, fromIndex);\n+        registerCursor(cursor);\n+        return cursor;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates the node with a new value.\n+     * This implementation sets the value on the node.\n+     * Subclasses can override this to record the change.\n+     * \n+     * @param node  node to update\n+     * @param value  new value of the node\n+     */\n+    @Override\n+    protected void updateNode(Node<E> node, E value) {\n+        super.updateNode(node, value);\n+        broadcastNodeChanged(node);\n+    }\n+\n+    /**\n+     * Inserts a new node into the list.\n+     *\n+     * @param nodeToInsert  new node to insert\n+     * @param insertBeforeNode  node to insert before\n+     * @throws NullPointerException if either node is null\n+     */\n+    @Override\n+    protected void addNode(Node<E> nodeToInsert, Node<E> insertBeforeNode) {\n+        super.addNode(nodeToInsert, insertBeforeNode);\n+        broadcastNodeInserted(nodeToInsert);\n+    }\n+    \n+    /**\n+     * Removes the specified node from the list.\n+     *\n+     * @param node  the node to remove\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    @Override\n+    protected void removeNode(Node<E> node) {\n+        super.removeNode(node);\n+        broadcastNodeRemoved(node);\n+    }\n+\n+    /**\n+     * Removes all nodes by iteration.\n+     */\n+    @Override\n+    protected void removeAllNodes() {\n+        if (size() > 0) {\n+            // superclass implementation would break all the iterators\n+            Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Registers a cursor to be notified of changes to this list.\n+     * \n+     * @param cursor  the cursor to register\n+     */\n+    protected void registerCursor(Cursor<E> cursor) {\n+        // We take this opportunity to clean the cursors list\n+        // of WeakReference objects to garbage-collected cursors.\n+        for (Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            WeakReference<Cursor<E>> ref = it.next();\n+            if (ref.get() == null) {\n+                it.remove();\n+            }\n+        }\n+        cursors.add(new WeakReference<Cursor<E>>(cursor));\n+    }\n+\n+    /**\n+     * Deregisters a cursor from the list to be notified of changes.\n+     * \n+     * @param cursor  the cursor to deregister\n+     */\n+    protected void unregisterCursor(Cursor<E> cursor) {\n+        for (Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cur = ref.get();\n+            if (cur == null) {\n+                // some other unrelated cursor object has been \n+                // garbage-collected; let's take the opportunity to\n+                // clean up the cursors list anyway..\n+                it.remove();\n+            } else if (cur == cursor) {\n+                ref.clear();\n+                it.remove();\n+                break;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was changed.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeChanged(Node<E> node) {\n+        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+        while (it.hasNext()) {\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cursor = ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeChanged(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was just removed from my list.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeRemoved(Node<E> node) {\n+        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+        while (it.hasNext()) {\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cursor = ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeRemoved(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was just added to my list.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeInserted(Node<E> node) {\n+        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+        while (it.hasNext()) {\n+            WeakReference<Cursor<E>> ref = it.next();\n+            Cursor<E> cursor = ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeInserted(node);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a list iterator for the sublist.\n+     * \n+     * @param subList  the sublist to get an iterator for\n+     * @param fromIndex  the index to start from, relative to the sublist\n+     */\n+    @Override\n+    protected ListIterator<E> createSubListListIterator(LinkedSubList<E> subList, int fromIndex) {\n+        SubCursor<E> cursor = new SubCursor<E>(subList, fromIndex);\n+        registerCursor(cursor);\n+        return cursor;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An extended <code>ListIterator</code> that allows concurrent changes to\n+     * the underlying list.\n+     */\n+    public static class Cursor<E> extends AbstractLinkedList.LinkedListIterator<E> {\n+        /** Is the cursor valid (not closed) */\n+        boolean valid = true;\n+        /** Is the next index valid */\n+        boolean nextIndexValid = true;\n+        /** Flag to indicate if the current element was removed by another object. */\n+        boolean currentRemovedByAnother = false;\n+        \n+        /**\n+         * Constructs a new cursor.\n+         * \n+         * @param index  the index to start from\n+         */\n+        protected Cursor(CursorableLinkedList<E> parent, int index) {\n+            super(parent, index);\n+            valid = true;\n+        }\n+\n+        /**\n+         * Removes the item last returned by this iterator.\n+         * <p>\n+         * There may have been subsequent alterations to the list\n+         * since you obtained this item, however you can still remove it.\n+         * You can even remove it if the item is no longer in the main list.\n+         * However, you can't call this method on the same iterator more\n+         * than once without calling next() or previous().\n+         *\n+         * @throws IllegalStateException if there is no item to remove\n+         */\n+        @Override\n+        public void remove() {\n+            // overridden, as the nodeRemoved() method updates the iterator\n+            // state in the parent.removeNode() call below\n+            if (current == null && currentRemovedByAnother) {\n+                // quietly ignore, as the last returned node was removed\n+                // by the list or some other iterator\n+                // by ignoring it, we keep this iterator independent from\n+                // other changes as much as possible\n+            } else {\n+                checkModCount();\n+                parent.removeNode(getLastNodeReturned());\n+            }\n+            currentRemovedByAnother = false;\n+        }\n+\n+        /**\n+         * Adds an object to the list.\n+         * The object added here will be the new 'previous' in the iterator.\n+         * \n+         * @param obj  the object to add\n+         */\n+        @Override\n+        public void add(E obj) {\n+            // overridden, as the nodeInserted() method updates the iterator state\n+            super.add(obj);\n+            // matches the (next.previous == node) clause in nodeInserted()\n+            // thus next gets changed - reset it again here\n+            next = next.next;\n+        }\n+        \n+        // set is not overridden, as it works ok\n+        // note that we want it to throw an exception if the element being\n+        // set has been removed from the real list (compare this with the\n+        // remove method where we silently ignore this case)\n+\n+        /**\n+         * Gets the index of the next element to be returned.\n+         * \n+         * @return the next index\n+         */\n+        @Override\n+        public int nextIndex() {\n+            if (nextIndexValid == false) {\n+                if (next == parent.header) {\n+                    nextIndex = parent.size();\n+                } else {\n+                    int pos = 0;\n+                    Node<E> temp = parent.header.next;\n+                    while (temp != next) {\n+                        pos++;\n+                        temp = temp.next;\n+                    }\n+                    nextIndex = pos;\n+                }\n+                nextIndexValid = true;\n+            }\n+            return nextIndex;\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has changed.\n+         * \n+         * @param node  the node that changed\n+         */\n+        protected void nodeChanged(Node<E> node) {\n+            // do nothing\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has been removed.\n+         * \n+         * @param node  the node that was removed\n+         */\n+        protected void nodeRemoved(Node<E> node) {\n+            if (node == next && node == current) {\n+                // state where next() followed by previous()\n+                next = node.next;\n+                current = null;\n+                currentRemovedByAnother = true;\n+            } else if (node == next) {\n+                // state where next() not followed by previous()\n+                // and we are matching next node\n+                next = node.next;\n+                currentRemovedByAnother = false;\n+            } else if (node == current) {\n+                // state where next() not followed by previous()\n+                // and we are matching current (last returned) node\n+                current = null;\n+                currentRemovedByAnother = true;\n+                nextIndex--;\n+            } else {\n+                nextIndexValid = false;\n+                currentRemovedByAnother = false;\n+            }\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has been added.\n+         * \n+         * @param node  the node that was added\n+         */\n+        protected void nodeInserted(Node<E> node) {\n+            if (node.previous == current) {\n+                next = node;\n+            } else if (next.previous == node) {\n+                next = node;\n+            } else {\n+                nextIndexValid = false;\n+            }\n+        }\n+\n+        /**\n+         * Override superclass modCount check, and replace it with our valid flag.\n+         */\n+        @Override\n+        protected void checkModCount() {\n+            if (!valid) {\n+                throw new ConcurrentModificationException(\"Cursor closed\");\n+            }\n+        }\n+\n+        /**\n+         * Mark this cursor as no longer being needed. Any resources\n+         * associated with this cursor are immediately released.\n+         * In previous versions of this class, it was mandatory to close\n+         * all cursor objects to avoid memory leaks. It is <i>no longer</i>\n+         * necessary to call this close method; an instance of this class\n+         * can now be treated exactly like a normal iterator.\n+         */\n+        public void close() {\n+            if (valid) {\n+                ((CursorableLinkedList<E>) parent).unregisterCursor(this);\n+                valid = false;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A cursor for the sublist based on LinkedSubListIterator.\n+     *\n+     * @since Commons Collections 3.2\n+     */\n+    protected static class SubCursor<E> extends Cursor<E> {\n+\n+        /** The parent list */\n+        protected final LinkedSubList<E> sub;\n+\n+        /**\n+         * Constructs a new cursor.\n+         * \n+         * @param index  the index to start from\n+         */\n+        protected SubCursor(LinkedSubList<E> sub, int index) {\n+            super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n+            this.sub = sub;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return (nextIndex() < sub.size);\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+            return (previousIndex() >= 0);\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+            return (super.nextIndex() - sub.offset);\n+        }\n+\n+        @Override\n+        public void add(E obj) {\n+            super.add(obj);\n+            sub.expectedModCount = parent.modCount;\n+            sub.size++;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            sub.expectedModCount = parent.modCount;\n+            sub.size--;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/FixedSizeList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.BoundedCollection;\n+import org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>List</code> to fix the size preventing add/remove.\n+ * <p>\n+ * The add, remove, clear and retain operations are unsupported.\n+ * The set method is allowed (as it doesn't change the list size).\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class FixedSizeList<E>\n+        extends AbstractSerializableListDecorator<E>\n+        implements BoundedCollection<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2218010673611160319L;\n+\n+    /**\n+     * Factory method to create a fixed size list.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> List<E> fixedSizeList(List<E> list) {\n+        return new FixedSizeList<E>(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected FixedSizeList(List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(E object) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public void add(int index, E object) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public E get(int index) {\n+        return decorated().get(index);\n+    }\n+\n+    @Override\n+    public int indexOf(Object object) {\n+        return decorated().indexOf(object);\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public int lastIndexOf(Object object) {\n+        return decorated().lastIndexOf(object);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return new FixedSizeListIterator(decorated().listIterator(0));\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(int index) {\n+        return new FixedSizeListIterator(decorated().listIterator(index));\n+    }\n+\n+    @Override\n+    public E remove(int index) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public E set(int index, E object) {\n+        return decorated().set(index, object);\n+    }\n+\n+    @Override\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new FixedSizeList<E>(sub);\n+    }\n+\n+    /**\n+     * List iterator that only permits changes via set()\n+     */\n+    private class FixedSizeListIterator extends AbstractListIteratorDecorator<E> {\n+        protected FixedSizeListIterator(ListIterator<E> iterator) {\n+            super(iterator);\n+        }\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException(\"List is fixed size\");\n+        }\n+        @Override\n+        public void add(Object object) {\n+            throw new UnsupportedOperationException(\"List is fixed size\");\n+        }\n+    }\n+\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    public int maxSize() {\n+        return size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/GrowthList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Decorates another <code>List</code> to make it seamlessly grow when\n+ * indices larger than the list size are used on add and set,\n+ * avoiding most IndexOutOfBoundsExceptions.\n+ * <p>\n+ * This class avoids errors by growing when a set or add method would\n+ * normally throw an IndexOutOfBoundsException.\n+ * Note that IndexOutOfBoundsException IS returned for invalid negative indices.\n+ * <p>\n+ * Trying to set or add to an index larger than the size will cause the list\n+ * to grow (using <code>null</code> elements). Clearly, care must be taken\n+ * not to use excessively large indices, as the internal list will grow to\n+ * match.\n+ * <p>\n+ * Trying to use any method other than add or set with an invalid index will\n+ * call the underlying list and probably result in an IndexOutOfBoundsException.\n+ * <p>\n+ * Take care when using this list with <code>null</code> values, as\n+ * <code>null</code> is the value added when growing the list.\n+ * <p>\n+ * All sub-lists will access the underlying list directly, and will throw\n+ * IndexOutOfBoundsExceptions.\n+ * <p>\n+ * This class differs from {@link LazyList} because here growth occurs on\n+ * set and add, where <code>LazyList</code> grows on get. However, they\n+ * can be used together by decorating twice.\n+ *\n+ * @see LazyList\n+ * @since Commons Collections 3.2\n+ * @version $Revision: 155406 $ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Legato\n+ */\n+public class GrowthList<E> extends AbstractSerializableListDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3620001881672L;\n+\n+    /**\n+     * Factory method to create a growth list.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> List<E> growthList(List<E> list) {\n+        return new GrowthList<E>(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that uses an ArrayList internally.\n+     */\n+    public GrowthList() {\n+        super(new ArrayList<E>());\n+    }\n+\n+    /**\n+     * Constructor that uses an ArrayList internally.\n+     *\n+     * @param initialSize  the initial size of the ArrayList\n+     * @throws IllegalArgumentException if initial size is invalid\n+     */\n+    public GrowthList(int initialSize) {\n+        super(new ArrayList<E>(initialSize));\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected GrowthList(List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the add method to perform the growth behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will\n+     * grow to the new size. Indices between the old size and the requested\n+     * size will be filled with <code>null</code>.\n+     * <p>\n+     * If the index is less than the current size, the value will be added to\n+     * the underlying list directly.\n+     * If the index is less than zero, the underlying list is called, which\n+     * will probably throw an IndexOutOfBoundsException.\n+     *\n+     * @param index  the index to add at\n+     * @param element  the object to add at the specified index\n+     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n+     * @throws ClassCastException if the underlying list rejects the element\n+     * @throws IllegalArgumentException if the underlying list rejects the element\n+     */\n+    @Override\n+    public void add(int index, E element) {\n+        int size = decorated().size();\n+        if (index > size) {\n+            decorated().addAll(Collections.<E>nCopies(index - size, null));\n+        }\n+        decorated().add(index, element);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the addAll method to perform the growth behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will\n+     * grow to the new size. Indices between the old size and the requested\n+     * size will be filled with <code>null</code>.\n+     * <p>\n+     * If the index is less than the current size, the values will be added to\n+     * the underlying list directly.\n+     * If the index is less than zero, the underlying list is called, which\n+     * will probably throw an IndexOutOfBoundsException.\n+     *\n+     * @param index  the index to add at\n+     * @param coll  the collection to add at the specified index\n+     * @return true if the list changed\n+     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n+     * @throws ClassCastException if the underlying list rejects the element\n+     * @throws IllegalArgumentException if the underlying list rejects the element\n+     */\n+    @Override\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        int size = decorated().size();\n+        boolean result = false;\n+        if (index > size) {\n+            decorated().addAll(Collections.<E>nCopies(index - size, null));\n+            result = true;\n+        }\n+        return (decorated().addAll(index, coll) | result);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the set method to perform the growth behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will\n+     * grow to the new size. Indices between the old size and the requested\n+     * size will be filled with <code>null</code>.\n+     * <p>\n+     * If the index is less than the current size, the value will be set onto\n+     * the underlying list directly.\n+     * If the index is less than zero, the underlying list is called, which\n+     * will probably throw an IndexOutOfBoundsException.\n+     *\n+     * @param index  the index to set\n+     * @param element  the object to set at the specified index\n+     * @return the object previously at that index\n+     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n+     * @throws ClassCastException if the underlying list rejects the element\n+     * @throws IllegalArgumentException if the underlying list rejects the element\n+     */\n+    @Override\n+    public E set(int index, E element) {\n+        int size = decorated().size();\n+        if (index >= size) {\n+            decorated().addAll(Collections.<E>nCopies((index - size) + 1, null));\n+        }\n+        return decorated().set(index, element);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/LazyList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.List;\n+\n+import org.apache.commons.collections.Factory;\n+\n+/**\n+ * Decorates another <code>List</code> to create objects in the list on demand.\n+ * <p>\n+ * When the {@link #get(int)} method is called with an index greater than\n+ * the size of the list, the list will automatically grow in size and return\n+ * a new object from the specified factory. The gaps will be filled by null.\n+ * If a get method call encounters a null, it will be replaced with a new\n+ * object from the factory. Thus this list is unsuitable for storing null\n+ * objects.\n+ * <p>\n+ * For instance:\n+ *\n+ * <pre>\n+ * Factory factory = new Factory() {\n+ *     public Object create() {\n+ *         return new Date();\n+ *     }\n+ * }\n+ * List lazy = LazyList.decorate(new ArrayList(), factory);\n+ * Object obj = lazy.get(3);\n+ * </pre>\n+ *\n+ * After the above code is executed, <code>obj</code> will contain\n+ * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+ * instance is the fourth element in the list.  The first, second, \n+ * and third element are all set to <code>null</code>.\n+ * <p>\n+ * This class differs from {@link GrowthList} because here growth occurs on\n+ * get, where <code>GrowthList</code> grows on set and add. However, they\n+ * could easily be used together by decorating twice.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @see GrowthList\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Arron Bates\n+ * @author Paul Jack\n+ */\n+public class LazyList<E> extends AbstractSerializableListDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1708388017160694542L;\n+\n+    /** The factory to use to lazily instantiate the objects */\n+    protected final Factory<? extends E> factory;\n+\n+    /**\n+     * Factory method to create a lazily instantiating list.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param factory  the factory to use for creation, must not be null\n+     * @throws IllegalArgumentException if list or factory is null\n+     */\n+    public static <E> List<E> lazyList(List<E> list, Factory<? extends E> factory) {\n+        return new LazyList<E>(list, factory);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param factory  the factory to use for creation, must not be null\n+     * @throws IllegalArgumentException if list or factory is null\n+     */\n+    protected LazyList(List<E> list, Factory<? extends E> factory) {\n+        super(list);\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        this.factory = factory;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the get method to perform the lazy behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will \n+     * grow to the new size and a new object will be returned from the factory.\n+     * Indexes in-between the old size and the requested size are left with a \n+     * placeholder that is replaced with a factory object when requested.\n+     * \n+     * @param index  the index to retrieve\n+     */\n+    @Override\n+    public E get(int index) {\n+        int size = decorated().size();\n+        if (index < size) {\n+            // within bounds, get the object\n+            E object = decorated().get(index);\n+            if (object == null) {\n+                // item is a place holder, create new one, set and return\n+                object = factory.create();\n+                decorated().set(index, object);\n+                return object;\n+            }\n+            // good and ready to go\n+            return object;\n+        }\n+        // we have to grow the list\n+        for (int i = size; i < index; i++) {\n+            decorated().add(null);\n+        }\n+        // create our last object, set and return\n+        E object = factory.create();\n+        decorated().add(object);\n+        return object;\n+    }\n+\n+    @Override\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new LazyList<E>(sub, factory);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+/**\n+ * A <code>List</code> implementation that stores a cache of internal Node objects\n+ * in an effort to reduce wasteful object creation.\n+ * <p>\n+ * A linked list creates one Node for each item of data added. This can result in\n+ * a lot of object creation and garbage collection. This implementation seeks to\n+ * avoid that by maintaining a store of cached nodes.\n+ * <p>\n+ * This implementation is suitable for long-lived lists where both add and remove\n+ * are used. Short-lived lists, or lists which only grow will have worse performance\n+ * using this class.\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b>\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Jeff Varszegi\n+ * @author Rich Dougherty\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class NodeCachingLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6897789178562232073L;\n+\n+    /**\n+     * The default value for {@link #maximumCacheSize}.\n+     */\n+    protected static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;\n+\n+    /**\n+     * The first cached node, or <code>null</code> if no nodes are cached.\n+     * Cached nodes are stored in a singly-linked list with\n+     * <code>next</code> pointing to the next element.\n+     */\n+    protected transient Node<E> firstCachedNode;\n+    \n+    /**\n+     * The size of the cache.\n+     */\n+    protected transient int cacheSize;\n+\n+    /**\n+     * The maximum size of the cache.\n+     */\n+    protected int maximumCacheSize;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates.\n+     */\n+    public NodeCachingLinkedList() {\n+        this(DEFAULT_MAXIMUM_CACHE_SIZE);\n+    }\n+\n+    /**\n+     * Constructor that copies the specified collection\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    public NodeCachingLinkedList(Collection<E> coll) {\n+        super(coll);\n+        this.maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n+    }\n+    \n+    /**\n+     * Constructor that species the maximum cache size.\n+     *\n+     * @param maximumCacheSize  the maximum cache size\n+     */\n+    public NodeCachingLinkedList(int maximumCacheSize) {\n+        super();\n+        this.maximumCacheSize = maximumCacheSize;\n+        init();  // must call init() as use super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the maximum size of the cache.\n+     * \n+     * @return the maximum cache size\n+     */\n+    protected int getMaximumCacheSize() {\n+        return maximumCacheSize;\n+    }\n+\n+    /**\n+     * Sets the maximum size of the cache.\n+     * \n+     * @param maximumCacheSize  the new maximum cache size\n+     */\n+    protected void setMaximumCacheSize(int maximumCacheSize) {\n+        this.maximumCacheSize = maximumCacheSize;\n+        shrinkCacheToMaximumSize();\n+    }\n+\n+    /**\n+     * Reduce the size of the cache to the maximum, if necessary.\n+     */\n+    protected void shrinkCacheToMaximumSize() {\n+        // Rich Dougherty: This could be more efficient.\n+        while (cacheSize > maximumCacheSize) {\n+            getNodeFromCache();\n+        }\n+    }\n+    \n+    /**\n+     * Gets a node from the cache. If a node is returned, then the value of\n+     * {@link #cacheSize} is decreased accordingly. The node that is returned\n+     * will have <code>null</code> values for next, previous and element.\n+     *\n+     * @return a node, or <code>null</code> if there are no nodes in the cache.\n+     */\n+    protected Node<E> getNodeFromCache() {\n+        if (cacheSize == 0) {\n+            return null;\n+        }\n+        Node<E> cachedNode = firstCachedNode;\n+        firstCachedNode = cachedNode.next;\n+        cachedNode.next = null; // This should be changed anyway, but defensively\n+                                // set it to null.                    \n+        cacheSize--;\n+        return cachedNode;\n+    }\n+    \n+    /**\n+     * Checks whether the cache is full.\n+     * \n+     * @return true if the cache is full\n+     */\n+    protected boolean isCacheFull() {\n+        return cacheSize >= maximumCacheSize;\n+    }\n+    \n+    /**\n+     * Adds a node to the cache, if the cache isn't full.\n+     * The node's contents are cleared to so they can be garbage collected.\n+     * \n+     * @param node  the node to add to the cache\n+     */\n+    protected void addNodeToCache(Node<E> node) {\n+        if (isCacheFull()) {\n+            // don't cache the node.\n+            return;\n+        }\n+        // clear the node's contents and add it to the cache.\n+        Node<E> nextCachedNode = firstCachedNode;\n+        node.previous = null;\n+        node.next = nextCachedNode;\n+        node.setValue(null);\n+        firstCachedNode = node;\n+        cacheSize++;\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a new node, either by reusing one from the cache or creating\n+     * a new one.\n+     * \n+     * @param value  value of the new node\n+     * @return the newly created node\n+     */\n+    @Override\n+    protected Node<E> createNode(E value) {\n+        Node<E> cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createNode(value);\n+        }\n+        cachedNode.setValue(value);\n+        return cachedNode;\n+    }\n+\n+    /**\n+     * Removes the node from the list, storing it in the cache for reuse\n+     * if the cache is not yet full.\n+     * \n+     * @param node  the node to remove\n+     */\n+    @Override\n+    protected void removeNode(Node<E> node) {\n+        super.removeNode(node);\n+        addNodeToCache(node);\n+    }\n+    \n+    /**\n+     * Removes all the nodes from the list, storing as many as required in the\n+     * cache for reuse.\n+     * \n+     */\n+    @Override\n+    protected void removeAllNodes() {\n+        // Add the removed nodes to the cache, then remove the rest.\n+        // We can add them to the cache before removing them, since\n+        // {@link AbstractLinkedList.removeAllNodes()} removes the\n+        // nodes by removing references directly from {@link #header}.\n+        int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n+        Node<E> node = header.next;\n+        for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n+            Node<E> oldNode = node;\n+            node = node.next;\n+            addNodeToCache(oldNode);\n+        }\n+        super.removeAllNodes();        \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/PredicatedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+import org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Decorates another <code>List</code> to validate that all additions\n+ * match a specified predicate.\n+ * <p>\n+ * This list exists to provide validation for the decorated list.\n+ * It is normally created to decorate an empty list.\n+ * If an object cannot be added to the list, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the list.\n+ * <pre>List list = PredicatedList.decorate(new ArrayList(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedList<E> extends PredicatedCollection<E> implements List<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5722039223898659102L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) list.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return the decorated list\n+     * @throws IllegalArgumentException if list or predicate is null\n+     * @throws IllegalArgumentException if the list contains invalid elements\n+     */\n+    public static <T> List<T> predicatedList(List<T> list, Predicate<? super T> predicate) {\n+        return new PredicatedList<T>(list, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if list or predicate is null\n+     * @throws IllegalArgumentException if the list contains invalid elements\n+     */\n+    protected PredicatedList(List<E> list, Predicate<? super E> predicate) {\n+        super(list, predicate);\n+    }\n+\n+    /**\n+     * Gets the list being decorated.\n+     * \n+     * @return the decorated list\n+     */\n+    @Override\n+    protected List<E> decorated() {\n+        return (List<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E get(int index) {\n+        return decorated().get(index);\n+    }\n+\n+    public int indexOf(Object object) {\n+        return decorated().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(Object object) {\n+        return decorated().lastIndexOf(object);\n+    }\n+\n+    public E remove(int index) {\n+        return decorated().remove(index);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void add(int index, E object) {\n+        validate(object);\n+        decorated().add(index, object);\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        for (E aColl : coll) {\n+            validate(aColl);\n+        }\n+        return decorated().addAll(index, coll);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return listIterator(0);\n+    }\n+\n+    public ListIterator<E> listIterator(int i) {\n+        return new PredicatedListIterator(decorated().listIterator(i));\n+    }\n+\n+    public E set(int index, E object) {\n+        validate(object);\n+        return decorated().set(index, object);\n+    }\n+\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new PredicatedList<E>(sub, predicate);\n+    }\n+\n+    /**\n+     * Inner class Iterator for the PredicatedList\n+     */\n+    protected class PredicatedListIterator extends AbstractListIteratorDecorator<E> {\n+        \n+        protected PredicatedListIterator(ListIterator<E> iterator) {\n+            super(iterator);\n+        }\n+        \n+        @Override\n+        public void add(E object) {\n+            validate(object);\n+            iterator.add(object);\n+        }\n+        \n+        @Override\n+        public void set(E object) {\n+            validate(object);\n+            iterator.set(object);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/SetUniqueList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates a <code>List</code> to ensure that no duplicates are present\n+ * much like a <code>Set</code>.\n+ * <p>\n+ * The <code>List</code> interface makes certain assumptions/requirements.\n+ * This implementation breaks these in certain ways, but this is merely the\n+ * result of rejecting duplicates.\n+ * Each violation is explained in the method, but it should not affect you.\n+ * Bear in mind that Sets require immutable objects to function correctly.\n+ * <p>\n+ * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n+ * class provides an alternative approach, by wrapping an existing Set and\n+ * retaining insertion order in the iterator.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ * @author Tom Dunham\n+ */\n+public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7196982186153478694L;\n+\n+    /**\n+     * Internal Set to maintain uniqueness.\n+     */\n+    protected final Set<E> set;\n+\n+    /**\n+     * Factory method to create a SetList using the supplied list to retain order.\n+     * <p>\n+     * If the list contains duplicates, these are removed (first indexed one kept).\n+     * A <code>HashSet</code> is used for the set behaviour.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> SetUniqueList<E> setUniqueList(List<E> list) {\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (list.isEmpty()) {\n+            return new SetUniqueList<E>(list, new HashSet<E>());\n+        }\n+        List<E> temp = new ArrayList<E>(list);\n+        list.clear();\n+        SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n+        sl.addAll(temp);\n+        return sl;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) the List and specifies the set to use.\n+     * <p>\n+     * The set and list must both be correctly initialised to the same elements.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if set or list is null\n+     */\n+    protected SetUniqueList(List<E> list, Set<E> set) {\n+        super(list);\n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        this.set = set;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an unmodifiable view as a Set.\n+     *\n+     * @return an unmodifiable set view\n+     */\n+    public Set<E> asSet() {\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds an element to the list if it is not already present.\n+     * <p>\n+     * <i>(Violation)</i>\n+     * The <code>List</code> interface requires that this method returns\n+     * <code>true</code> always. However this class may return <code>false</code>\n+     * because of the <code>Set</code> behaviour.\n+     *\n+     * @param object the object to add\n+     * @return true if object was added\n+     */\n+    @Override\n+    public boolean add(E object) {\n+        // gets initial size\n+        final int sizeBefore = size();\n+\n+        // adds element if unique\n+        add(size(), object);\n+\n+        // compares sizes to detect if collection changed\n+        return (sizeBefore != size());\n+    }\n+\n+    /**\n+     * Adds an element to a specific index in the list if it is not already present.\n+     * <p>\n+     * <i>(Violation)</i>\n+     * The <code>List</code> interface makes the assumption that the element is\n+     * always inserted. This may not happen with this implementation.\n+     *\n+     * @param index  the index to insert at\n+     * @param object  the object to add\n+     */\n+    @Override\n+    public void add(int index, E object) {\n+        // adds element if it is not contained already\n+        if (set.contains(object) == false) {\n+            super.add(index, object);\n+            set.add(object);\n+        }\n+    }\n+\n+    /**\n+     * Adds a collection of objects to the end of the list avoiding duplicates.\n+     * <p>\n+     * Only elements that are not already in this list will be added, and\n+     * duplicates from the specified collection will be ignored.\n+     * <p>\n+     * <i>(Violation)</i>\n+     * The <code>List</code> interface makes the assumption that the elements\n+     * are always inserted. This may not happen with this implementation.\n+     *\n+     * @param coll  the collection to add in iterator order\n+     * @return true if this collection changed\n+     */\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        return addAll(size(), coll);\n+    }\n+\n+    /**\n+     * Adds a collection of objects a specific index in the list avoiding \n+     * duplicates.\n+     * <p>\n+     * Only elements that are not already in this list will be added, and\n+     * duplicates from the specified collection will be ignored.\n+     * <p>\n+     * <i>(Violation)</i>\n+     * The <code>List</code> interface makes the assumption that the elements\n+     * are always inserted. This may not happen with this implementation.\n+     *\n+     * @param index  the index to insert at\n+     * @param coll  the collection to add in iterator order\n+     * @return true if this collection changed\n+     */\n+    @Override\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        HashSet<E> temp = new HashSet<E>(coll);\n+        temp.removeAll(set);\n+        if (temp.isEmpty()) {\n+            return false;\n+        }\n+        for (E e : coll) {\n+            if (temp.contains(e)) {\n+                add(index, e);\n+                index++;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the value at the specified index avoiding duplicates.\n+     * <p>\n+     * The object is set into the specified index.\n+     * Afterwards, any previous duplicate is removed\n+     * If the object is not already in the list then a normal set occurs.\n+     * If it is present, then the old version is removed.\n+     *\n+     * @param index  the index to insert at\n+     * @param object  the object to set\n+     * @return the previous object\n+     */\n+    @Override\n+    public E set(int index, E object) {\n+        int pos = indexOf(object);\n+        E removed = super.set(index, object);\n+\n+        if (pos != -1 && pos != index) {\n+            // the object is already in the uniq list\n+            // (and it hasn't been swapped with itself)\n+            super.remove(pos);  // remove the duplicate by index\n+        }\n+\n+        set.add(object);      // add the new item to the unique set\n+        set.remove(removed);  // remove the item deleted by the set\n+\n+        return removed;  // return the item deleted by the set\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        boolean result = super.remove(object);\n+        set.remove(object);\n+        return result;\n+    }\n+\n+    @Override\n+    public E remove(int index) {\n+        E result = super.remove(index);\n+        set.remove(result);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        boolean result = super.removeAll(coll);\n+        set.removeAll(coll);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        boolean result = super.retainAll(coll);\n+        set.retainAll(coll);\n+        return result;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        set.clear();\n+    }\n+\n+    @Override\n+    public boolean contains(Object object) {\n+        return set.contains(object);\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> coll) {\n+        return set.containsAll(coll);\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new SetListIterator<E>(super.iterator(), set);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return new SetListListIterator<E>(super.listIterator(), set);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(int index) {\n+        return new SetListListIterator<E>(super.listIterator(index), set);\n+    }\n+\n+    @Override\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> superSubList = super.subList(fromIndex, toIndex);\n+        Set<E> subSet = createSetBasedOnList(set, superSubList);\n+        return new SetUniqueList<E>(superSubList, subSet);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected Set<E> createSetBasedOnList(Set<E> set, List<E> list) {\n+        Set<E> subSet;\n+        if (set.getClass().equals(HashSet.class)) {\n+            subSet = new HashSet<E>(list.size());\n+        } else {\n+            try {\n+                subSet = set.getClass().newInstance();\n+            } catch (InstantiationException ie) {\n+                subSet = new HashSet<E>();\n+            } catch (IllegalAccessException iae) {\n+                subSet = new HashSet<E>();\n+            }\n+        }\n+        subSet.addAll(list);\n+        return subSet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class iterator.\n+     */\n+    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListIterator(Iterator<E> it, Set<E> set) {\n+            super(it);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+    }\n+\n+    /**\n+     * Inner class iterator.\n+     */\n+    static class SetListListIterator<E> extends AbstractListIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListListIterator(ListIterator<E> it, Set<E> set) {\n+            super(it);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public E previous() {\n+            last = super.previous();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+\n+        @Override\n+        public void add(E object) {\n+            if (set.contains(object) == false) {\n+                super.add(object);\n+                set.add(object);\n+            }\n+        }\n+\n+        @Override\n+        public void set(E object) {\n+            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/SynchronizedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+\n+/**\n+ * Decorates another <code>List</code> to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated list.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedList<E> extends SynchronizedCollection<E> implements List<E> {\n+\n+    /** Serialization version */\n+     private static final long serialVersionUID = -1403835447328619437L;\n+\n+    /**\n+     * Factory method to create a synchronized list.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <T> List<T> synchronizedList(List<T> list) {\n+        return new SynchronizedList<T>(list);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected SynchronizedList(List<E> list) {\n+        super(list);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param lock  the lock to use, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected SynchronizedList(List<E> list, Object lock) {\n+        super(list, lock);\n+    }\n+\n+    /**\n+     * Gets the decorated list.\n+     * \n+     * @return the decorated list\n+     */\n+    protected List<E> getList() {\n+        return (List<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void add(int index, E object) {\n+        synchronized (lock) {\n+            getList().add(index, object);\n+        }\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        synchronized (lock) {\n+            return getList().addAll(index, coll);\n+        }\n+    }\n+\n+    public E get(int index) {\n+        synchronized (lock) {\n+            return getList().get(index);\n+        }\n+    }\n+\n+    public int indexOf(Object object) {\n+        synchronized (lock) {\n+            return getList().indexOf(object);\n+        }\n+    }\n+\n+    public int lastIndexOf(Object object) {\n+        synchronized (lock) {\n+            return getList().lastIndexOf(object);\n+        }\n+    }\n+\n+    /**\n+     * Iterators must be manually synchronized.\n+     * <pre>\n+     * synchronized (coll) {\n+     *   ListIterator it = coll.listIterator();\n+     *   // do stuff with iterator\n+     * }\n+     * \n+     * @return an iterator that must be manually synchronized on the collection\n+     */\n+    public ListIterator<E> listIterator() {\n+        return getList().listIterator();\n+    }\n+\n+    /**\n+     * Iterators must be manually synchronized.\n+     * <pre>\n+     * synchronized (coll) {\n+     *   ListIterator it = coll.listIterator(3);\n+     *   // do stuff with iterator\n+     * }\n+     * \n+     * @return an iterator that must be manually synchronized on the collection\n+     */\n+    public ListIterator<E> listIterator(int index) {\n+        return getList().listIterator(index);\n+    }\n+\n+    public E remove(int index) {\n+        synchronized (lock) {\n+            return getList().remove(index);\n+        }\n+    }\n+\n+    public E set(int index, E object) {\n+        synchronized (lock) {\n+            return getList().set(index, object);\n+        }\n+    }\n+\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        synchronized (lock) {\n+            List<E> list = getList().subList(fromIndex, toIndex);\n+            // the lock is passed into the constructor here to ensure that the sublist is\n+            // synchronized on the same lock as the parent list\n+            return new SynchronizedList<E>(list, lock);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/TransformedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+import org.apache.commons.collections.iterators.AbstractListIteratorDecorator;\n+\n+/**\n+ * Decorates another <code>List</code> to transform objects that are added.\n+ * <p>\n+ * The add and set methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedList<E> extends TransformedCollection<E> implements List<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1077193035000013141L;\n+\n+    /**\n+     * Factory method to create a transforming list.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedList(List, Transformer)}.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if list or transformer is null\n+     */\n+    public static <E> List<E> transformingList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedList<E>(list, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming list that will transform\n+     * existing contents of the specified list.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingList(List, Transformer)}.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed List\n+     * @throws IllegalArgumentException if list or transformer is null\n+     * @since Commons Collections 3.3\n+     */\n+    public static <E> List<E> transformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+        TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n+        if (transformer != null && list != null && list.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // list is of type E\n+            E[] values = (E[]) list.toArray();\n+            list.clear();\n+            for(int i=0; i<values.length; i++) {\n+                decorated.decorated().add(transformer.transform(values[i]));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if list or transformer is null\n+     */\n+    protected TransformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+        super(list, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated list.\n+     * \n+     * @return the decorated list\n+     */\n+    protected List<E> getList() {\n+        return (List<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E get(int index) {\n+        return getList().get(index);\n+    }\n+\n+    public int indexOf(Object object) {\n+        return getList().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(Object object) {\n+        return getList().lastIndexOf(object);\n+    }\n+\n+    public E remove(int index) {\n+        return getList().remove(index);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void add(int index, E object) {\n+        object = transform(object);\n+        getList().add(index, object);\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        coll = transform(coll);\n+        return getList().addAll(index, coll);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return listIterator(0);\n+    }\n+\n+    public ListIterator<E> listIterator(int i) {\n+        return new TransformedListIterator(getList().listIterator(i));\n+    }\n+\n+    public E set(int index, E object) {\n+        object = transform(object);\n+        return getList().set(index, object);\n+    }\n+\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> sub = getList().subList(fromIndex, toIndex);\n+        return new TransformedList<E>(sub, transformer);\n+    }\n+\n+    /**\n+     * Inner class Iterator for the TransformedList\n+     */\n+    protected class TransformedListIterator extends AbstractListIteratorDecorator<E> {\n+\n+        protected TransformedListIterator(ListIterator<E> iterator) {\n+            super(iterator);\n+        }\n+\n+        @Override\n+        public void add(E object) {\n+            object = transform(object);\n+            iterator.add(object);\n+        }\n+\n+        @Override\n+        public void set(E object) {\n+            object = transform(object);\n+            iterator.set(object);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/TreeList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.OrderedIterator;\n+\n+/**\n+ * A <code>List</code> implementation that is optimised for fast insertions and\n+ * removals at any index in the list.\n+ * <p>\n+ * This list implementation utilises a tree structure internally to ensure that\n+ * all insertions and removals are O(log n). This provides much faster performance\n+ * than both an <code>ArrayList</code> and a <code>LinkedList</code> where elements\n+ * are inserted and removed repeatedly from anywhere in the list.\n+ * <p>\n+ * The following relative performance statistics are indicative of this class:\n+ * <pre>\n+ *              get  add  insert  iterate  remove\n+ * TreeList       3    5       1       2       1\n+ * ArrayList      1    1      40       1      40\n+ * LinkedList  5800    1     350       2     325\n+ * </pre>\n+ * <code>ArrayList</code> is a good general purpose list implementation.\n+ * It is faster than <code>TreeList</code> for most operations except inserting\n+ * and removing in the middle of the list. <code>ArrayList</code> also uses less\n+ * memory as <code>TreeList</code> uses one object per entry.\n+ * <p>\n+ * <code>LinkedList</code> is rarely a good choice of implementation.\n+ * <code>TreeList</code> is almost always a good replacement for it, although it\n+ * does use slightly more memory.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Joerg Schmuecker\n+ * @author Stephen Colebourne\n+ */\n+public class TreeList<E> extends AbstractList<E> {\n+//    add; toArray; iterator; insert; get; indexOf; remove\n+//    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n+//   ArrayList =  220;1480;1760; 6870;    50;1540; 7200;\n+//  LinkedList =  270;7360;3350;55860;290720;2910;55200;\n+\n+    /** The root node in the AVL tree */\n+    private AVLNode<E> root;\n+\n+    /** The current size of the list */\n+    private int size;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty list.\n+     */\n+    public TreeList() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty list that copies the specified list.\n+     *\n+     * @param coll  the collection to copy\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public TreeList(Collection<E> coll) {\n+        super();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the element at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the element at the specified index\n+     */\n+    @Override\n+    public E get(int index) {\n+        checkInterval(index, 0, size() - 1);\n+        return root.get(index).getValue();\n+    }\n+\n+    /**\n+     * Gets the current size of the list.\n+     *\n+     * @return the current size\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Gets an iterator over the list.\n+     *\n+     * @return an iterator over the list\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        // override to go 75% faster\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Gets a ListIterator over the list.\n+     *\n+     * @return the new iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        // override to go 75% faster\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Gets a ListIterator over the list.\n+     *\n+     * @param fromIndex  the index to start from\n+     * @return the new iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator(int fromIndex) {\n+        // override to go 75% faster\n+        // cannot use EmptyIterator as iterator.add() must work\n+        checkInterval(fromIndex, 0, size());\n+        return new TreeListIterator<E>(this, fromIndex);\n+    }\n+\n+    /**\n+     * Searches for the index of an object in the list.\n+     *\n+     * @return the index of the object, -1 if not found\n+     */\n+    @Override\n+    public int indexOf(Object object) {\n+        // override to go 75% faster\n+        if (root == null) {\n+            return -1;\n+        }\n+        return root.indexOf(object, root.relativePosition);\n+    }\n+\n+    /**\n+     * Searches for the presence of an object in the list.\n+     *\n+     * @return true if the object is found\n+     */\n+    @Override\n+    public boolean contains(Object object) {\n+        return (indexOf(object) >= 0);\n+    }\n+\n+    /**\n+     * Converts the list into an array.\n+     *\n+     * @return the list as an array\n+     */\n+    @Override\n+    public Object[] toArray() {\n+        // override to go 20% faster\n+        Object[] array = new Object[size()];\n+        if (root != null) {\n+            root.toArray(array, root.relativePosition);\n+        }\n+        return array;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new element to the list.\n+     *\n+     * @param index  the index to add before\n+     * @param obj  the element to add\n+     */\n+    @Override\n+    public void add(int index, E obj) {\n+        modCount++;\n+        checkInterval(index, 0, size());\n+        if (root == null) {\n+            root = new AVLNode<E>(index, obj, null, null);\n+        } else {\n+            root = root.insert(index, obj);\n+        }\n+        size++;\n+    }\n+\n+    /**\n+     * Sets the element at the specified index.\n+     *\n+     * @param index  the index to set\n+     * @param obj  the object to store at the specified index\n+     * @return the previous object at that index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    @Override\n+    public E set(int index, E obj) {\n+        checkInterval(index, 0, size() - 1);\n+        AVLNode<E> node = root.get(index);\n+        E result = node.value;\n+        node.setValue(obj);\n+        return result;\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index to remove\n+     * @return the previous object at that index\n+     */\n+    @Override\n+    public E remove(int index) {\n+        modCount++;\n+        checkInterval(index, 0, size() - 1);\n+        E result = get(index);\n+        root = root.remove(index);\n+        size--;\n+        return result;\n+    }\n+\n+    /**\n+     * Clears the list, removing all entries.\n+     */\n+    @Override\n+    public void clear() {\n+        modCount++;\n+        root = null;\n+        size = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the index is valid.\n+     *\n+     * @param index  the index to check\n+     * @param startIndex  the first allowed index\n+     * @param endIndex  the last allowed index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    private void checkInterval(int index, int startIndex, int endIndex) {\n+        if (index < startIndex || index > endIndex) {\n+            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements an AVLNode which keeps the offset updated.\n+     * <p>\n+     * This node contains the real work.\n+     * TreeList is just there to implement {@link java.util.List}.\n+     * The nodes don't know the index of the object they are holding.  They\n+     * do know however their position relative to their parent node.\n+     * This allows to calculate the index of a node while traversing the tree.\n+     * <p>\n+     * The Faedelung calculation stores a flag for both the left and right child\n+     * to indicate if they are a child (false) or a link as in linked list (true).\n+     */\n+    static class AVLNode<E> {\n+        /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n+        private AVLNode<E> left;\n+        /** Flag indicating that left reference is not a subtree but the predecessor. */\n+        private boolean leftIsPrevious;\n+        /** The right child node or the successor if {@link #rightIsNext}. */\n+        private AVLNode<E> right;\n+        /** Flag indicating that right reference is not a subtree but the successor. */\n+        private boolean rightIsNext;\n+        /** How many levels of left/right are below this one. */\n+        private int height;\n+        /** The relative position, root holds absolute position. */\n+        private int relativePosition;\n+        /** The stored element. */\n+        private E value;\n+\n+        /**\n+         * Constructs a new node with a relative position.\n+         *\n+         * @param relativePosition  the relative position of the node\n+         * @param obj  the value for the ndoe\n+         * @param rightFollower the node with the value following this one\n+         * @param leftFollower the node with the value leading this one\n+         */\n+        private AVLNode(int relativePosition, E obj, AVLNode<E> rightFollower, AVLNode<E> leftFollower) {\n+            this.relativePosition = relativePosition;\n+            value = obj;\n+            rightIsNext = true;\n+            leftIsPrevious = true;\n+            right = rightFollower;\n+            left = leftFollower;\n+        }\n+\n+        /**\n+         * Gets the value.\n+         *\n+         * @return the value of this node\n+         */\n+        E getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the value.\n+         *\n+         * @param obj  the value to store\n+         */\n+        void setValue(E obj) {\n+            this.value = obj;\n+        }\n+\n+        /**\n+         * Locate the element with the given index relative to the\n+         * offset of the parent of this node.\n+         */\n+        AVLNode<E> get(int index) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe == 0) {\n+                return this;\n+            }\n+\n+            AVLNode<E> nextNode = ((indexRelativeToMe < 0) ? getLeftSubTree() : getRightSubTree());\n+            if (nextNode == null) {\n+                return null;\n+            }\n+            return nextNode.get(indexRelativeToMe);\n+        }\n+\n+        /**\n+         * Locate the index that contains the specified object.\n+         */\n+        int indexOf(Object object, int index) {\n+            if (getLeftSubTree() != null) {\n+                int result = left.indexOf(object, index + left.relativePosition);\n+                if (result != -1) {\n+                    return result;\n+                }\n+            }\n+            if (value == null ? value == object : value.equals(object)) {\n+                return index;\n+            }\n+            if (getRightSubTree() != null) {\n+                return right.indexOf(object, index + right.relativePosition);\n+            }\n+            return -1;\n+        }\n+\n+        /**\n+         * Stores the node and its children into the array specified.\n+         *\n+         * @param array the array to be filled\n+         * @param index the index of this node\n+         */\n+        void toArray(Object[] array, int index) {\n+            array[index] = value;\n+            if (getLeftSubTree() != null) {\n+                left.toArray(array, index + left.relativePosition);\n+            }\n+            if (getRightSubTree() != null) {\n+                right.toArray(array, index + right.relativePosition);\n+            }\n+        }\n+\n+        /**\n+         * Gets the next node in the list after this one.\n+         *\n+         * @return the next node\n+         */\n+        AVLNode<E> next() {\n+            if (rightIsNext || right == null) {\n+                return right;\n+            }\n+            return right.min();\n+        }\n+\n+        /**\n+         * Gets the node in the list before this one.\n+         *\n+         * @return the previous node\n+         */\n+        AVLNode<E> previous() {\n+            if (leftIsPrevious || left == null) {\n+                return left;\n+            }\n+            return left.max();\n+        }\n+\n+        /**\n+         * Inserts a node at the position index.\n+         *\n+         * @param index is the index of the position relative to the position of\n+         * the parent node.\n+         * @param obj is the object to be stored in the position.\n+         */\n+        AVLNode<E> insert(int index, E obj) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe <= 0) {\n+                return insertOnLeft(indexRelativeToMe, obj);\n+            }\n+            return insertOnRight(indexRelativeToMe, obj);\n+        }\n+\n+        private AVLNode<E> insertOnLeft(int indexRelativeToMe, E obj) {\n+            AVLNode<E> ret = this;\n+\n+            if (getLeftSubTree() == null) {\n+                setLeft(new AVLNode<E>(-1, obj, this, left), null);\n+            } else {\n+                setLeft(left.insert(indexRelativeToMe, obj), null);\n+            }\n+\n+            if (relativePosition >= 0) {\n+                relativePosition++;\n+            }\n+            ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        private AVLNode<E> insertOnRight(int indexRelativeToMe, E obj) {\n+            AVLNode<E> ret = this;\n+\n+            if (getRightSubTree() == null) {\n+                setRight(new AVLNode<E>(+1, obj, right, this), null);\n+            } else {\n+                setRight(right.insert(indexRelativeToMe, obj), null);\n+            }\n+            if (relativePosition < 0) {\n+                relativePosition--;\n+            }\n+            ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the left node, returning null if its a faedelung.\n+         */\n+        private AVLNode<E> getLeftSubTree() {\n+            return (leftIsPrevious ? null : left);\n+        }\n+\n+        /**\n+         * Gets the right node, returning null if its a faedelung.\n+         */\n+        private AVLNode<E> getRightSubTree() {\n+            return (rightIsNext ? null : right);\n+        }\n+\n+        /**\n+         * Gets the rightmost child of this node.\n+         *\n+         * @return the rightmost child (greatest index)\n+         */\n+        private AVLNode<E> max() {\n+            return (getRightSubTree() == null) ? this : right.max();\n+        }\n+\n+        /**\n+         * Gets the leftmost child of this node.\n+         *\n+         * @return the leftmost child (smallest index)\n+         */\n+        private AVLNode<E> min() {\n+            return (getLeftSubTree() == null) ? this : left.min();\n+        }\n+\n+        /**\n+         * Removes the node at a given position.\n+         *\n+         * @param index is the index of the element to be removed relative to the position of\n+         * the parent node of the current node.\n+         */\n+        AVLNode<E> remove(int index) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe == 0) {\n+                return removeSelf();\n+            }\n+            if (indexRelativeToMe > 0) {\n+                setRight(right.remove(indexRelativeToMe), right.right);\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                setLeft(left.remove(indexRelativeToMe), left.left);\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode<E> removeMax() {\n+            if (getRightSubTree() == null) {\n+                return removeSelf();\n+            }\n+            setRight(right.removeMax(), right.right);\n+            if (relativePosition < 0) {\n+                relativePosition++;\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode<E> removeMin() {\n+            if (getLeftSubTree() == null) {\n+                return removeSelf();\n+            }\n+            setLeft(left.removeMin(), left.left);\n+            if (relativePosition > 0) {\n+                relativePosition--;\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        /**\n+         * Removes this node from the tree.\n+         *\n+         * @return the node that replaces this one in the parent\n+         */\n+        private AVLNode<E> removeSelf() {\n+            if (getRightSubTree() == null && getLeftSubTree() == null) {\n+                return null;\n+            }\n+            if (getRightSubTree() == null) {\n+                if (relativePosition > 0) {\n+                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n+                }\n+                left.max().setRight(null, right);\n+                return left;\n+            }\n+            if (getLeftSubTree() == null) {\n+                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n+                right.min().setLeft(null, left);\n+                return right;\n+            }\n+\n+            if (heightRightMinusLeft() > 0) {\n+                // more on the right, so delete from the right\n+                AVLNode<E> rightMin = right.min();\n+                value = rightMin.value;\n+                if (leftIsPrevious) {\n+                    left = rightMin.left;\n+                }\n+                right = right.removeMin();\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                // more on the left or equal, so delete from the left\n+                AVLNode<E> leftMax = left.max();\n+                value = leftMax.value;\n+                if (rightIsNext) {\n+                    right = leftMax.right;\n+                }\n+                AVLNode<E> leftPrevious = left.left;\n+                left = left.removeMax();\n+                if (left == null) {\n+                    // special case where left that was deleted was a double link\n+                    // only occurs when height difference is equal\n+                    left = leftPrevious;\n+                    leftIsPrevious = true;\n+                }\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return this;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Balances according to the AVL algorithm.\n+         */\n+        private AVLNode<E> balance() {\n+            switch (heightRightMinusLeft()) {\n+                case 1 :\n+                case 0 :\n+                case -1 :\n+                    return this;\n+                case -2 :\n+                    if (left.heightRightMinusLeft() > 0) {\n+                        setLeft(left.rotateLeft(), null);\n+                    }\n+                    return rotateRight();\n+                case 2 :\n+                    if (right.heightRightMinusLeft() < 0) {\n+                        setRight(right.rotateRight(), null);\n+                    }\n+                    return rotateLeft();\n+                default :\n+                    throw new RuntimeException(\"tree inconsistent!\");\n+            }\n+        }\n+\n+        /**\n+         * Gets the relative position.\n+         */\n+        private int getOffset(AVLNode<E> node) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            return node.relativePosition;\n+        }\n+\n+        /**\n+         * Sets the relative position.\n+         */\n+        private int setOffset(AVLNode<E> node, int newOffest) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            int oldOffset = getOffset(node);\n+            node.relativePosition = newOffest;\n+            return oldOffset;\n+        }\n+\n+        /**\n+         * Sets the height by calculation.\n+         */\n+        private void recalcHeight() {\n+            height = Math.max(\n+                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n+                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n+        }\n+\n+        /**\n+         * Returns the height of the node or -1 if the node is null.\n+         */\n+        private int getHeight(AVLNode<E> node) {\n+            return (node == null ? -1 : node.height);\n+        }\n+\n+        /**\n+         * Returns the height difference right - left\n+         */\n+        private int heightRightMinusLeft() {\n+            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n+        }\n+\n+        private AVLNode<E> rotateLeft() {\n+            AVLNode<E> newTop = right; // can't be faedelung!\n+            AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n+\n+            int newTopPosition = relativePosition + getOffset(newTop);\n+            int myNewPosition = -newTop.relativePosition;\n+            int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+\n+            setRight(movedNode, newTop);\n+            newTop.setLeft(this, null);\n+\n+            setOffset(newTop, newTopPosition);\n+            setOffset(this, myNewPosition);\n+            setOffset(movedNode, movedPosition);\n+            return newTop;\n+        }\n+\n+        private AVLNode<E> rotateRight() {\n+            AVLNode<E> newTop = left; // can't be faedelung\n+            AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n+\n+            int newTopPosition = relativePosition + getOffset(newTop);\n+            int myNewPosition = -newTop.relativePosition;\n+            int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+\n+            setLeft(movedNode, newTop);\n+            newTop.setRight(this, null);\n+\n+            setOffset(newTop, newTopPosition);\n+            setOffset(this, myNewPosition);\n+            setOffset(movedNode, movedPosition);\n+            return newTop;\n+        }\n+\n+        /**\n+         * Sets the left field to the node, or the previous node if that is null\n+         *\n+         * @param node  the new left subtree node\n+         * @param previous  the previous node in the linked list\n+         */\n+        private void setLeft(AVLNode<E> node, AVLNode<E> previous) {\n+            leftIsPrevious = (node == null);\n+            left = (leftIsPrevious ? previous : node);\n+            recalcHeight();\n+        }\n+\n+        /**\n+         * Sets the right field to the node, or the next node if that is null\n+         *\n+         * @param node  the new left subtree node\n+         * @param next  the next node in the linked list\n+         */\n+        private void setRight(AVLNode<E> node, AVLNode<E> next) {\n+            rightIsNext = (node == null);\n+            right = (rightIsNext ? next : node);\n+            recalcHeight();\n+        }\n+\n+//      private void checkFaedelung() {\n+//          AVLNode maxNode = left.max();\n+//          if (!maxNode.rightIsFaedelung || maxNode.right != this) {\n+//              throw new RuntimeException(maxNode + \" should right-faedel to \" + this);\n+//          }\n+//          AVLNode minNode = right.min();\n+//          if (!minNode.leftIsFaedelung || minNode.left != this) {\n+//              throw new RuntimeException(maxNode + \" should left-faedel to \" + this);\n+//          }\n+//      }\n+//\n+//        private int checkTreeDepth() {\n+//            int hright = (getRightSubTree() == null ? -1 : getRightSubTree().checkTreeDepth());\n+//            //          System.out.print(\"checkTreeDepth\");\n+//            //          System.out.print(this);\n+//            //          System.out.print(\" left: \");\n+//            //          System.out.print(_left);\n+//            //          System.out.print(\" right: \");\n+//            //          System.out.println(_right);\n+//\n+//            int hleft = (left == null ? -1 : left.checkTreeDepth());\n+//            if (height != Math.max(hright, hleft) + 1) {\n+//                throw new RuntimeException(\n+//                    \"height should be max\" + hleft + \",\" + hright + \" but is \" + height);\n+//            }\n+//            return height;\n+//        }\n+//\n+//        private int checkLeftSubNode() {\n+//            if (getLeftSubTree() == null) {\n+//                return 0;\n+//            }\n+//            int count = 1 + left.checkRightSubNode();\n+//            if (left.relativePosition != -count) {\n+//                throw new RuntimeException();\n+//            }\n+//            return count + left.checkLeftSubNode();\n+//        }\n+//\n+//        private int checkRightSubNode() {\n+//            AVLNode right = getRightSubTree();\n+//            if (right == null) {\n+//                return 0;\n+//            }\n+//            int count = 1;\n+//            count += right.checkLeftSubNode();\n+//            if (right.relativePosition != count) {\n+//                throw new RuntimeException();\n+//            }\n+//            return count + right.checkRightSubNode();\n+//        }\n+\n+        /**\n+         * Used for debugging.\n+         */\n+        @Override\n+        public String toString() {\n+            return \"AVLNode(\" + relativePosition + \",\" + (left != null) + \",\" + value +\n+                \",\" + (getRightSubTree() != null) + \", faedelung \" + rightIsNext + \" )\";\n+        }\n+    }\n+\n+    /**\n+     * A list iterator over the linked list.\n+     */\n+    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n+        /** The parent list */\n+        protected final TreeList<E> parent;\n+        /**\n+         * Cache of the next node that will be returned by {@link #next()}.\n+         */\n+        protected AVLNode<E> next;\n+        /**\n+         * The index of the next node to be returned.\n+         */\n+        protected int nextIndex;\n+        /**\n+         * Cache of the last node that was returned by {@link #next()}\n+         * or {@link #previous()}.\n+         */\n+        protected AVLNode<E> current;\n+        /**\n+         * The index of the last node that was returned.\n+         */\n+        protected int currentIndex;\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         *\n+         * @param parent  the parent list\n+         * @param fromIndex  the index to start at\n+         */\n+        protected TreeListIterator(TreeList<E> parent, int fromIndex) throws IndexOutOfBoundsException {\n+            super();\n+            this.parent = parent;\n+            this.expectedModCount = parent.modCount;\n+            this.next = (parent.root == null ? null : parent.root.get(fromIndex));\n+            this.nextIndex = fromIndex;\n+            this.currentIndex = -1;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         *\n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return (nextIndex < parent.size());\n+        }\n+\n+        public E next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n+            }\n+            if (next == null) {\n+                next = parent.root.get(nextIndex);\n+            }\n+            E value = next.getValue();\n+            current = next;\n+            currentIndex = nextIndex++;\n+            next = next.next();\n+            return value;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (nextIndex > 0);\n+        }\n+\n+        public E previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            if (next == null) {\n+                next = parent.root.get(nextIndex - 1);\n+            } else {\n+                next = next.previous();\n+            }\n+            E value = next.getValue();\n+            current = next;\n+            currentIndex = --nextIndex;\n+            return value;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            return nextIndex() - 1;\n+        }\n+\n+        public void remove() {\n+            checkModCount();\n+            if (currentIndex == -1) {\n+                throw new IllegalStateException();\n+            }\n+            if (nextIndex == currentIndex) {\n+                // remove() following previous()\n+                next = next.next();\n+                parent.remove(currentIndex);\n+            } else {\n+                // remove() following next()\n+                parent.remove(currentIndex);\n+                nextIndex--;\n+            }\n+            current = null;\n+            currentIndex = -1;\n+            expectedModCount++;\n+        }\n+\n+        public void set(E obj) {\n+            checkModCount();\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            current.setValue(obj);\n+        }\n+\n+        public void add(E obj) {\n+            checkModCount();\n+            parent.add(nextIndex, obj);\n+            current = null;\n+            currentIndex = -1;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/UnmodifiableList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections.iterators.UnmodifiableListIterator;\n+\n+/**\n+ * Decorates another <code>List</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableList<E>\n+        extends AbstractSerializableListDecorator<E>\n+        implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6595182819922443652L;\n+\n+    /**\n+     * Factory method to create an unmodifiable list.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> List<E> unmodifiableList(List<E> list) {\n+        if (list instanceof Unmodifiable) {\n+            return list;\n+        }\n+        return new UnmodifiableList<E>(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     * @since Commons Collection 5\n+     */\n+    public UnmodifiableList(List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return UnmodifiableListIterator.umodifiableListIterator(decorated().listIterator());\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(int index) {\n+        return UnmodifiableListIterator.umodifiableListIterator(decorated().listIterator(index));\n+    }\n+\n+    @Override\n+    public void add(int index, E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public E remove(int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public E set(int index, E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new UnmodifiableList<E>(sub);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.EmptyMapIterator;\n+\n+/**\n+ * An abstract implementation of a hash-based map which provides numerous points for\n+ * subclasses to override.\n+ * <p>\n+ * This class implements all the features necessary for a subclass hash-based map.\n+ * Key-value entries are stored in instances of the <code>HashEntry</code> class,\n+ * which can be overridden and replaced. The iterators can similarly be replaced,\n+ * without the need to replace the KeySet, EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * NOTE: From Commons Collections 3.1 this class extends AbstractMap.\n+ * This is to provide backwards compatibility for ReferenceMap between v3.0 and v3.1.\n+ * This extends clause will be removed in v4.0.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author java util HashMap\n+ * @author Stephen Colebourne\n+ * @author Christian Siefkes\n+ */\n+public class AbstractHashedMap<K, V> extends AbstractMap<K, V> implements IterableMap<K, V> {\n+\n+    protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";\n+    protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";\n+    protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";\n+    protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";\n+    protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";\n+    protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";\n+\n+    /** The default capacity to use */\n+    protected static final int DEFAULT_CAPACITY = 16;\n+    /** The default threshold to use */\n+    protected static final int DEFAULT_THRESHOLD = 12;\n+    /** The default load factor to use */\n+    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+    /** The maximum capacity allowed */\n+    protected static final int MAXIMUM_CAPACITY = 1 << 30;\n+    /** An object for masking null */\n+    protected static final Object NULL = new Object();\n+\n+    /** Load factor, normally 0.75 */\n+    protected transient float loadFactor;\n+    /** The size of the map */\n+    protected transient int size;\n+    /** Map entries */\n+    protected transient HashEntry<K, V>[] data;\n+    /** Size at which to rehash */\n+    protected transient int threshold;\n+    /** Modification count for iterators */\n+    protected transient int modCount;\n+    /** Entry set */\n+    protected transient EntrySet<K, V> entrySet;\n+    /** Key set */\n+    protected transient KeySet<K> keySet;\n+    /** Values */\n+    protected transient Values<V> values;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractHashedMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor which performs no validation on the passed in parameters.\n+     *\n+     * @param initialCapacity  the initial capacity, must be a power of two\n+     * @param loadFactor  the load factor, must be &gt; 0.0f and generally &lt; 1.0f\n+     * @param threshold  the threshold, must be sensible\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected AbstractHashedMap(int initialCapacity, float loadFactor, int threshold) {\n+        super();\n+        this.loadFactor = loadFactor;\n+        this.data = new HashEntry[initialCapacity];\n+        this.threshold = threshold;\n+        init();\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * default load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    protected AbstractHashedMap(int initialCapacity) {\n+        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IlleagalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than or equal to zero \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected AbstractHashedMap(int initialCapacity, float loadFactor) {\n+        super();\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"Initial capacity must be a non negative number\");  \n+        }\n+        if (loadFactor <= 0.0f || Float.isNaN(loadFactor)) {\n+            throw new IllegalArgumentException(\"Load factor must be greater than 0\");\n+        }\n+        this.loadFactor = loadFactor;\n+        initialCapacity = calculateNewCapacity(initialCapacity);\n+        this.threshold = calculateThreshold(initialCapacity, loadFactor);\n+        this.data = new HashEntry[initialCapacity];\n+        init();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    protected AbstractHashedMap(Map<K, V> map) {\n+        this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n+        _putAll(map);\n+    }\n+\n+    /**\n+     * Initialise subclasses during construction, cloning or deserialization.\n+     */\n+    protected void init() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    @Override\n+    public V get(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map.\n+     *\n+     * @return the size\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     *\n+     * @return true if the map is currently size zero\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return (size == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     *\n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    @Override\n+    public boolean containsKey(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    public boolean containsValue(Object value) {\n+        if (value == null) {\n+            for (int i = 0, isize = data.length; i < isize; i++) {\n+                HashEntry<K, V> entry = data[i];\n+                while (entry != null) {\n+                    if (entry.getValue() == null) {\n+                        return true;\n+                    }\n+                    entry = entry.next;\n+                }\n+            }\n+        } else {\n+            for (int i = 0, isize = data.length; i < isize; i++) {\n+                HashEntry<K, V> entry = data[i];\n+                while (entry != null) {\n+                    if (isEqualValue(value, entry.getValue())) {\n+                        return true;\n+                    }\n+                    entry = entry.next;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map.\n+     *\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    @Override\n+    public V put(K key, V value) {\n+        Object convertedKey = convertKey(key);\n+        int hashCode = hash(convertedKey);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry<K, V> entry = data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(convertedKey, entry.key)) {\n+                V oldValue = entry.getValue();\n+                updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+\n+        addMapping(index, hashCode, key, value);\n+        return null;\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     * <p>\n+     * This implementation iterates around the specified map and\n+     * uses {@link #put(Object, Object)}.\n+     *\n+     * @param map  the map to add\n+     * @throws NullPointerException if the map is null\n+     */\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        _putAll(map);\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     * <p>\n+     * This implementation iterates around the specified map and\n+     * uses {@link #put(Object, Object)}.\n+     * <p>\n+     * It is private to allow the constructor to still call it \n+     * even when putAll is overriden. \n+     * \n+     * @param map  the map to add\n+     * @throws NullPointerException if the map is null\n+     */\n+    private void _putAll(Map<? extends K, ? extends V> map) {\n+        int mapSize = map.size();\n+        if (mapSize == 0) {\n+            return;\n+        }\n+        int newSize = (int) ((size + mapSize) / loadFactor + 1);\n+        ensureCapacity(calculateNewCapacity(newSize));\n+        for (Map.Entry<? extends K, ? extends V> entry: map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     *\n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    @Override\n+    public V remove(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry<K, V> entry = data[index];\n+        HashEntry<K, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                V oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    @Override\n+    public void clear() {\n+        modCount++;\n+        HashEntry<K, V>[] data = this.data;\n+        for (int i = data.length - 1; i >= 0; i--) {\n+            data[i] = null;\n+        }\n+        size = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts input keys to another object for storage in the map.\n+     * This implementation masks nulls.\n+     * Subclasses can override this to perform alternate key conversions.\n+     * <p>\n+     * The reverse conversion can be changed, if required, by overriding the\n+     * getKey() method in the hash entry.\n+     *\n+     * @param key  the key convert\n+     * @return the converted key\n+     */\n+    protected Object convertKey(Object key) {\n+        return (key == null ? NULL : key);\n+    }\n+\n+    /**\n+     * Gets the hash code for the key specified.\n+     * This implementation uses the additional hashing routine from JDK1.4.\n+     * Subclasses can override this to return alternate hash codes.\n+     *\n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    protected int hash(Object key) {\n+        // same as JDK 1.4\n+        int h = key.hashCode();\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Compares two keys, in internal converted form, to see if they are equal.\n+     * This implementation uses the equals method and assumes neither key is null.\n+     * Subclasses can override this to match differently.\n+     *\n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal\n+     */\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        return (key1 == key2 || key1.equals(key2));\n+    }\n+\n+    /**\n+     * Compares two values, in external form, to see if they are equal.\n+     * This implementation uses the equals method and assumes neither value is null.\n+     * Subclasses can override this to match differently.\n+     *\n+     * @param value1  the first value to compare passed in from outside\n+     * @param value2  the second value extracted from the entry via <code>getValue()</code>\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(Object value1, Object value2) {\n+        return (value1 == value2 || value1.equals(value2));\n+    }\n+\n+    /**\n+     * Gets the index into the data storage for the hashCode specified.\n+     * This implementation uses the least significant bits of the hashCode.\n+     * Subclasses can override this to return alternate bucketing.\n+     *\n+     * @param hashCode  the hash code to use\n+     * @param dataSize  the size of the data to pick a bucket from\n+     * @return the bucket index\n+     */\n+    protected int hashIndex(int hashCode, int dataSize) {\n+        return hashCode & (dataSize - 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     * <p>\n+     * This method exists for subclasses that may need to perform a multi-step\n+     * process accessing the entry. The public methods in this class don't use this\n+     * method to gain a small performance boost.\n+     *\n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    protected HashEntry<K, V> getEntry(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry;\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates an existing key-value mapping to change the value.\n+     * <p>\n+     * This implementation calls <code>setValue()</code> on the entry.\n+     * Subclasses could override to handle changes to the map.\n+     *\n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     */\n+    protected void updateEntry(HashEntry<K, V> entry, V newValue) {\n+        entry.setValue(newValue);\n+    }\n+\n+    /**\n+     * Reuses an existing key-value mapping, storing completely new data.\n+     * <p>\n+     * This implementation sets all the data fields on the entry.\n+     * Subclasses could populate additional entry fields.\n+     *\n+     * @param entry  the entry to update, not null\n+     * @param hashIndex  the index in the data array\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void reuseEntry(HashEntry<K, V> entry, int hashIndex, int hashCode, K key, V value) {\n+        entry.next = data[hashIndex];\n+        entry.hashCode = hashCode;\n+        entry.key = key;\n+        entry.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new key-value mapping into this map.\n+     * <p>\n+     * This implementation calls <code>createEntry()</code>, <code>addEntry()</code>\n+     * and <code>checkCapacity()</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control adds to the map.\n+     *\n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void addMapping(int hashIndex, int hashCode, K key, V value) {\n+        modCount++;\n+        HashEntry<K, V> entry = createEntry(data[hashIndex], hashCode, key, value);\n+        addEntry(entry, hashIndex);\n+        size++;\n+        checkCapacity();\n+    }\n+\n+    /**\n+     * Creates an entry to store the key-value data.\n+     * <p>\n+     * This implementation creates a new HashEntry instance.\n+     * Subclasses can override this to return a different storage class,\n+     * or implement caching.\n+     *\n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    protected HashEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new HashEntry<K, V>(next, hashCode, convertKey(key), value);\n+    }\n+\n+    /**\n+     * Adds an entry into this map.\n+     * <p>\n+     * This implementation adds the entry to the data storage table.\n+     * Subclasses could override to handle changes to the map.\n+     *\n+     * @param entry  the entry to add\n+     * @param hashIndex  the index into the data array to store at\n+     */\n+    protected void addEntry(HashEntry<K, V> entry, int hashIndex) {\n+        data[hashIndex] = entry;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes a mapping from the map.\n+     * <p>\n+     * This implementation calls <code>removeEntry()</code> and <code>destroyEntry()</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control removals from the map.\n+     *\n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeMapping(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n+        modCount++;\n+        removeEntry(entry, hashIndex, previous);\n+        size--;\n+        destroyEntry(entry);\n+    }\n+\n+    /**\n+     * Removes an entry from the chain stored in a particular index.\n+     * <p>\n+     * This implementation removes the entry from the data storage table.\n+     * The size is not updated.\n+     * Subclasses could override to handle changes to the map.\n+     *\n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeEntry(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n+        if (previous == null) {\n+            data[hashIndex] = entry.next;\n+        } else {\n+            previous.next = entry.next;\n+        }\n+    }\n+\n+    /**\n+     * Kills an entry ready for the garbage collector.\n+     * <p>\n+     * This implementation prepares the HashEntry for garbage collection.\n+     * Subclasses can override this to implement caching (override clear as well).\n+     *\n+     * @param entry  the entry to destroy\n+     */\n+    protected void destroyEntry(HashEntry<K, V> entry) {\n+        entry.next = null;\n+        entry.key = null;\n+        entry.value = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the capacity of the map and enlarges it if necessary.\n+     * <p>\n+     * This implementation uses the threshold to check if the map needs enlarging\n+     */\n+    protected void checkCapacity() {\n+        if (size >= threshold) {\n+            int newCapacity = data.length * 2;\n+            if (newCapacity <= MAXIMUM_CAPACITY) {\n+                ensureCapacity(newCapacity);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Changes the size of the data structure to the capacity proposed.\n+     *\n+     * @param newCapacity  the new capacity of the array (a power of two, less or equal to max)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void ensureCapacity(int newCapacity) {\n+        int oldCapacity = data.length;\n+        if (newCapacity <= oldCapacity) {\n+            return;\n+        }\n+        if (size == 0) {\n+            threshold = calculateThreshold(newCapacity, loadFactor);\n+            data = new HashEntry[newCapacity];\n+        } else {\n+            HashEntry<K, V> oldEntries[] = data;\n+            HashEntry<K, V> newEntries[] = new HashEntry[newCapacity];\n+\n+            modCount++;\n+            for (int i = oldCapacity - 1; i >= 0; i--) {\n+                HashEntry<K, V> entry = oldEntries[i];\n+                if (entry != null) {\n+                    oldEntries[i] = null;  // gc\n+                    do {\n+                        HashEntry<K, V> next = entry.next;\n+                        int index = hashIndex(entry.hashCode, newCapacity);\n+                        entry.next = newEntries[index];\n+                        newEntries[index] = entry;\n+                        entry = next;\n+                    } while (entry != null);\n+                }\n+            }\n+            threshold = calculateThreshold(newCapacity, loadFactor);\n+            data = newEntries;\n+        }\n+    }\n+\n+    /**\n+     * Calculates the new capacity of the map.\n+     * This implementation normalizes the capacity to a power of two.\n+     *\n+     * @param proposedCapacity  the proposed capacity\n+     * @return the normalized new capacity\n+     */\n+    protected int calculateNewCapacity(int proposedCapacity) {\n+        int newCapacity = 1;\n+        if (proposedCapacity > MAXIMUM_CAPACITY) {\n+            newCapacity = MAXIMUM_CAPACITY;\n+        } else {\n+            while (newCapacity < proposedCapacity) {\n+                newCapacity <<= 1;  // multiply by two\n+            }\n+            if (newCapacity > MAXIMUM_CAPACITY) {\n+                newCapacity = MAXIMUM_CAPACITY;\n+            }\n+        }\n+        return newCapacity;\n+    }\n+\n+    /**\n+     * Calculates the new threshold of the map, where it will be resized.\n+     * This implementation uses the load factor.\n+     *\n+     * @param newCapacity  the new capacity\n+     * @param factor  the load factor\n+     * @return the new resize threshold\n+     */\n+    protected int calculateThreshold(int newCapacity, float factor) {\n+        return (int) (newCapacity * factor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the <code>next</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>next</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since Commons Collections 3.1\n+     */\n+    protected HashEntry<K, V> entryNext(HashEntry<K, V> entry) {\n+        return entry.next;\n+    }\n+\n+    /**\n+     * Gets the <code>hashCode</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>hashCode</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since Commons Collections 3.1\n+     */\n+    protected int entryHashCode(HashEntry<K, V> entry) {\n+        return entry.hashCode;\n+    }\n+\n+    /**\n+     * Gets the <code>key</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>key</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since Commons Collections 3.1\n+     */\n+    protected K entryKey(HashEntry<K, V> entry) {\n+        return entry.getKey();\n+    }\n+\n+    /**\n+     * Gets the <code>value</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>value</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since Commons Collections 3.1\n+     */\n+    protected V entryValue(HashEntry<K, V> entry) {\n+        return entry.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Map.Entry object.\n+     *\n+     * @return the map iterator\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        if (size == 0) {\n+            return EmptyMapIterator.<K, V>emptyMapIterator();\n+        }\n+        return new HashMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * MapIterator implementation.\n+     */\n+    protected static class HashMapIterator<K, V> extends HashIterator<K, V> implements MapIterator<K, V> {\n+\n+        protected HashMapIterator(AbstractHashedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public K getKey() {\n+            HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public V setValue(V value) {\n+            HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     *\n+     * @return the entrySet view\n+     */\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet<K, V>(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @return the entrySet iterator\n+     */\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n+        if (size() == 0) {\n+            return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n+        }\n+        return new EntrySetIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * EntrySet implementation.\n+     */\n+    protected static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        /** The parent map */\n+        protected final AbstractHashedMap<K, V> parent;\n+\n+        protected EntrySet(AbstractHashedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(Object entry) {\n+            if (entry instanceof Map.Entry) {\n+                Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n+                Entry<K, V> match = parent.getEntry(e.getKey());\n+                return (match != null && match.equals(e));\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            if (contains(obj) == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            parent.remove(entry.getKey());\n+            return true;\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return parent.createEntrySetIterator();\n+        }\n+    }\n+\n+    /**\n+     * EntrySet iterator.\n+     */\n+    protected static class EntrySetIterator<K, V> extends HashIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        protected EntrySetIterator(AbstractHashedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return super.nextEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     *\n+     * @return the keySet view\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet<K>(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @return the keySet iterator\n+     */\n+    protected Iterator<K> createKeySetIterator() {\n+        if (size() == 0) {\n+            return EmptyIterator.<K>emptyIterator();\n+        }\n+        return new KeySetIterator<K>(this);\n+    }\n+\n+    /**\n+     * KeySet implementation.\n+     */\n+    protected static class KeySet<K> extends AbstractSet<K> {\n+        /** The parent map */\n+        protected final AbstractHashedMap<K, ?> parent;\n+\n+        protected KeySet(AbstractHashedMap<K, ?> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(Object key) {\n+            return parent.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean remove(Object key) {\n+            boolean result = parent.containsKey(key);\n+            parent.remove(key);\n+            return result;\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return parent.createKeySetIterator();\n+        }\n+    }\n+\n+    /**\n+     * KeySet iterator.\n+     */\n+    protected static class KeySetIterator<K> extends HashIterator<K, Object> implements Iterator<K> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySetIterator(AbstractHashedMap<K, ?> parent) {\n+            super((AbstractHashedMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     *\n+     * @return the values view\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new Values<V>(this);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @return the values iterator\n+     */\n+    protected Iterator<V> createValuesIterator() {\n+        if (size() == 0) {\n+            return EmptyIterator.<V>emptyIterator();\n+        }\n+        return new ValuesIterator<V>(this);\n+    }\n+\n+    /**\n+     * Values implementation.\n+     */\n+    protected static class Values<V> extends AbstractCollection<V> {\n+        /** The parent map */\n+        protected final AbstractHashedMap<?, V> parent;\n+\n+        protected Values(AbstractHashedMap<?, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(Object value) {\n+            return parent.containsValue(value);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return parent.createValuesIterator();\n+        }\n+    }\n+\n+    /**\n+     * Values iterator.\n+     */\n+    protected static class ValuesIterator<V> extends HashIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(AbstractHashedMap<?, V> parent) {\n+            super((AbstractHashedMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            return super.nextEntry().getValue();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * HashEntry used to store the data.\n+     * <p>\n+     * If you subclass <code>AbstractHashedMap</code> but not <code>HashEntry</code>\n+     * then you will not be able to access the protected fields.\n+     * The <code>entryXxx()</code> methods on <code>AbstractHashedMap</code> exist\n+     * to provide the necessary access.\n+     */\n+    protected static class HashEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n+        /** The next entry in the hash chain */\n+        protected HashEntry<K, V> next;\n+        /** The hash code of the key */\n+        protected int hashCode;\n+        /** The key */\n+        protected Object key;\n+        /** The value */\n+        protected Object value;\n+\n+        protected HashEntry(HashEntry<K, V> next, int hashCode, Object key, V value) {\n+            super();\n+            this.next = next;\n+            this.hashCode = hashCode;\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public K getKey() {\n+            if (key == NULL) {\n+                return null;\n+            }\n+            return (K) key;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V getValue() {\n+            return (V) value;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V setValue(V value) {\n+            Object old = this.value;\n+            this.value = value;\n+            return (V) old;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            return\n+                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n+                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (getKey() == null ? 0 : getKey().hashCode()) ^\n+                   (getValue() == null ? 0 : getValue().hashCode());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringBuilder().append(getKey()).append('=').append(getValue()).toString();\n+        }\n+    }\n+\n+    /**\n+     * Base Iterator\n+     */\n+    protected static abstract class HashIterator<K, V> {\n+\n+        /** The parent map */\n+        protected final AbstractHashedMap<K, V> parent;\n+        /** The current index into the array of buckets */\n+        protected int hashIndex;\n+        /** The last returned entry */\n+        protected HashEntry<K, V> last;\n+        /** The next entry */\n+        protected HashEntry<K, V> next;\n+        /** The modification count expected */\n+        protected int expectedModCount;\n+\n+        protected HashIterator(AbstractHashedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            HashEntry<K, V>[] data = parent.data;\n+            int i = data.length;\n+            HashEntry<K, V> next = null;\n+            while (i > 0 && next == null) {\n+                next = data[--i];\n+            }\n+            this.next = next;\n+            this.hashIndex = i;\n+            this.expectedModCount = parent.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            return (next != null);\n+        }\n+\n+        protected HashEntry<K, V> nextEntry() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            HashEntry<K, V> newCurrent = next;\n+            if (newCurrent == null)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            HashEntry<K, V>[] data = parent.data;\n+            int i = hashIndex;\n+            HashEntry<K, V> n = newCurrent.next;\n+            while (n == null && i > 0) {\n+                n = data[--i];\n+            }\n+            next = n;\n+            hashIndex = i;\n+            last = newCurrent;\n+            return newCurrent;\n+        }\n+\n+        protected HashEntry<K, V> currentEntry() {\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (last == null) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            parent.remove(last.getKey());\n+            last = null;\n+            expectedModCount = parent.modCount;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Writes the map data to the stream. This method must be overridden if a\n+     * subclass must be setup before <code>put()</code> is used.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to serialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>writeObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if they have a specific field that must be present\n+     * on read before this implementation will work. Generally, the read determines\n+     * what must be serialized here, if anything.\n+     *\n+     * @param out  the output stream\n+     */\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        out.writeFloat(loadFactor);\n+        out.writeInt(data.length);\n+        out.writeInt(size);\n+        for (MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+            out.writeObject(it.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Reads the map data from the stream. This method must be overridden if a\n+     * subclass must be setup before <code>put()</code> is used.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to deserialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>readObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if the subclass has a specific field that must be present\n+     * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n+     *\n+     * @param in  the input stream\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        loadFactor = in.readFloat();\n+        int capacity = in.readInt();\n+        int size = in.readInt();\n+        init();\n+        threshold = calculateThreshold(capacity, loadFactor);\n+        data = new HashEntry[capacity];\n+        for (int i = 0; i < size; i++) {\n+            K key = (K) in.readObject();\n+            V value = (V) in.readObject();\n+            put(key, value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     * <p>\n+     * To implement <code>clone()</code>, a subclass must implement the\n+     * <code>Cloneable</code> interface and make this method public.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected AbstractHashedMap<K, V> clone() {\n+        try {\n+            AbstractHashedMap<K, V> cloned = (AbstractHashedMap<K, V>) super.clone();\n+            cloned.data = new HashEntry[data.length];\n+            cloned.entrySet = null;\n+            cloned.keySet = null;\n+            cloned.values = null;\n+            cloned.modCount = 0;\n+            cloned.size = 0;\n+            cloned.init();\n+            cloned.putAll(this);\n+            return cloned;\n+        } catch (CloneNotSupportedException ex) {\n+            return null;  // should never happen\n+        }\n+    }\n+\n+    /**\n+     * Compares this map with another.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map<?,?> map = (Map<?,?>) obj;\n+        if (map.size() != size()) {\n+            return false;\n+        }\n+        MapIterator<?,?> it = mapIterator();\n+        try {\n+            while (it.hasNext()) {\n+                Object key = it.next();\n+                Object value = it.getValue();\n+                if (value == null) {\n+                    if (map.get(key) != null || map.containsKey(key) == false) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (value.equals(map.get(key)) == false) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } catch (ClassCastException ignored)   {\n+            return false;\n+        } catch (NullPointerException ignored) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     *\n+     * @return the hash code defined in the Map interface\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        Iterator<Map.Entry<K, V>> it = createEntrySetIterator();\n+        while (it.hasNext()) {\n+            total += it.next().hashCode();\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     *\n+     * @return a string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"{}\";\n+        }\n+        StringBuilder buf = new StringBuilder(32 * size());\n+        buf.append('{');\n+\n+        MapIterator<K, V> it = mapIterator();\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            K key = it.next();\n+            V value = it.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key)\n+               .append('=')\n+               .append(value == this ? \"(this Map)\" : value);\n+\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(',').append(' ');\n+            }\n+        }\n+\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.reflect.Array;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.keyvalue.AbstractMapEntryDecorator;\n+import org.apache.commons.collections.set.AbstractSetDecorator;\n+\n+/**\n+ * An abstract base class that simplifies the task of creating map decorators.\n+ * <p>\n+ * The Map API is very difficult to decorate correctly, and involves implementing\n+ * lots of different classes. This class exists to provide a simpler API.\n+ * <p>\n+ * Special hook methods are provided that are called when objects are added to\n+ * the map. By overriding these methods, the input can be validated or manipulated.\n+ * In addition to the main map methods, the entrySet is also affected, which is\n+ * the hardest part of writing map implementations.\n+ * <p>\n+ * This class is package-scoped, and may be withdrawn or replaced in future\n+ * versions of Commons Collections.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+abstract class AbstractInputCheckedMapDecorator<K, V>\n+        extends AbstractMapDecorator<K, V> {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractInputCheckedMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected AbstractInputCheckedMapDecorator(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Hook method called when a value is being set using <code>setValue</code>.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the map may not be changed by setValue\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected abstract V checkSetValue(V value);\n+\n+    /**\n+     * Hook method called to determine if <code>checkSetValue</code> has any effect.\n+     * <p>\n+     * An implementation should return false if the <code>checkSetValue</code> method\n+     * has no effect as this optimises the implementation.\n+     * <p>\n+     * This implementation returns <code>true</code>.\n+     * \n+     * @return true always\n+     */\n+    protected boolean isSetValueChecking() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (isSetValueChecking()) {\n+            return new EntrySet(map.entrySet(), this);\n+        }\n+        return map.entrySet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set that checks additions via setValue.\n+     */\n+    @SuppressWarnings(\"serial\")\n+    private class EntrySet extends AbstractSetDecorator<Map.Entry<K, V>> {\n+        \n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n+\n+        protected EntrySet(Set<Map.Entry<K, V>> set, AbstractInputCheckedMapDecorator<K, V> parent) {\n+            super(set);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return new EntrySetIterator(collection.iterator(), parent);\n+        }\n+        \n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Object[] toArray() {\n+            Object[] array = collection.toArray();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n+            }\n+            return array;\n+        }\n+        \n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] array) {\n+            Object[] result = array;\n+            if (array.length > 0) {\n+                // we must create a new array to handle multi-threaded situations\n+                // where another thread could access data before we decorate it\n+                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+            }\n+            result = collection.toArray(result);\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = new MapEntry((Map.Entry<K, V>) result[i], parent);\n+            }\n+\n+            // check to see if result should be returned straight\n+            if (result.length > array.length) {\n+                return (T[]) result;\n+            }\n+\n+            // copy back into input array to fulfil the method contract\n+            System.arraycopy(result, 0, array, 0, result.length);\n+            if (array.length > result.length) {\n+                array[result.length] = null;\n+            }\n+            return array;\n+        }\n+    }\n+\n+    /**\n+     * Implementation of an entry set iterator that checks additions via setValue.\n+     */\n+    private class EntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n+\n+        protected EntrySetIterator(Iterator<Map.Entry<K, V>> iterator, AbstractInputCheckedMapDecorator<K, V> parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public Map.Entry<K, V> next() {\n+            Map.Entry<K, V> entry = iterator.next();\n+            return new MapEntry(entry, parent);\n+        }\n+    }\n+\n+    /**\n+     * Implementation of a map entry that checks additions via setValue.\n+     */\n+    private class MapEntry extends AbstractMapEntryDecorator<K, V> {\n+\n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n+\n+        protected MapEntry(Map.Entry<K, V> entry, AbstractInputCheckedMapDecorator<K, V> parent) {\n+            super(entry);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public V setValue(V value) {\n+            value = parent.checkSetValue(value);\n+            return entry.setValue(value);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractIterableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+\n+/**\n+ * Provide a basic {@link IterableMap} implementation.\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matt Benson\n+ */\n+public abstract class AbstractIterableMap<K, V> implements IterableMap<K, V> {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        return new EntrySetToMapIteratorAdapter<K, V>(entrySet());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.OrderedIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n+\n+/**\n+ * An abstract implementation of a hash-based map that links entries to create an\n+ * ordered map and which provides numerous points for subclasses to override.\n+ * <p>\n+ * This class implements all the features necessary for a subclass linked\n+ * hash-based map. Key-value entries are stored in instances of the\n+ * <code>LinkEntry</code> class which can be overridden and replaced.\n+ * The iterators can similarly be replaced, without the need to replace the KeySet,\n+ * EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * This implementation maintains order by original insertion, but subclasses\n+ * may work differently. The <code>OrderedMap</code> interface is implemented\n+ * to provide access to bidirectional iteration and extra convenience methods.\n+ * <p>\n+ * The <code>orderedMapIterator()</code> method provides direct access to a\n+ * bidirectional iterator. The iterators from the other views can also be cast\n+ * to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * The implementation is also designed to be subclassed, with lots of useful\n+ * methods exposed.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author java util LinkedHashMap\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractLinkedMap<K, V> extends AbstractHashedMap<K, V> implements OrderedMap<K, V> {\n+    \n+    /** Header in the linked list */\n+    protected transient LinkEntry<K, V> header;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractLinkedMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor which performs no validation on the passed in parameters.\n+     * \n+     * @param initialCapacity  the initial capacity, must be a power of two\n+     * @param loadFactor  the load factor, must be > 0.0f and generally < 1.0f\n+     * @param threshold  the threshold, must be sensible\n+     */\n+    protected AbstractLinkedMap(int initialCapacity, float loadFactor, int threshold) {\n+        super(initialCapacity, loadFactor, threshold);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    protected AbstractLinkedMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    protected AbstractLinkedMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    protected AbstractLinkedMap(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Initialise this subclass during construction.\n+     * <p>\n+     * NOTE: As from v3.2 this method calls\n+     * {@link #createEntry(HashEntry, int, Object, Object)} to create\n+     * the map entry object.\n+     */\n+    @Override\n+    protected void init() {\n+        header = createEntry(null, -1, null, null);\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    public boolean containsValue(Object value) {\n+        // override uses faster iterator\n+        if (value == null) {\n+            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n+                if (entry.getValue() == null) {\n+                    return true;\n+                }\n+            }\n+        } else {\n+            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n+                if (isEqualValue(value, entry.getValue())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    @Override\n+    public void clear() {\n+        // override to reset the linked list\n+        super.clear();\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first key in the map, which is the first inserted.\n+     * \n+     * @return the eldest key\n+     */\n+    public K firstKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.after.getKey();\n+    }\n+\n+    /**\n+     * Gets the last key in the map, which is the most recently inserted.\n+     * \n+     * @return the most recently inserted key\n+     */\n+    public K lastKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.before.getKey();\n+    }\n+\n+    /**\n+     * Gets the next key in sequence.\n+     * \n+     * @param key  the key to get after\n+     * @return the next key\n+     */\n+    public K nextKey(Object key) {\n+        LinkEntry<K, V> entry = getEntry(key);\n+        return (entry == null || entry.after == header ? null : entry.after.getKey());\n+    }\n+\n+    @Override\n+    protected LinkEntry<K, V> getEntry(Object key) {\n+        return (LinkEntry<K, V>) super.getEntry(key);\n+    }\n+\n+    /**\n+     * Gets the previous key in sequence.\n+     * \n+     * @param key  the key to get before\n+     * @return the previous key\n+     */\n+    public K previousKey(Object key) {\n+        LinkEntry<K, V> entry = getEntry(key);\n+        return (entry == null || entry.before == header ? null : entry.before.getKey());\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected LinkEntry<K, V> getEntry(int index) {\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index \" + index + \" is less than zero\");\n+        }\n+        if (index >= size) {\n+            throw new IndexOutOfBoundsException(\"Index \" + index + \" is invalid for size \" + size);\n+        }\n+        LinkEntry<K, V> entry;\n+        if (index < (size / 2)) {\n+            // Search forwards\n+            entry = header.after;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                entry = entry.after;\n+            }\n+        } else {\n+            // Search backwards\n+            entry = header;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                entry = entry.before;\n+            }\n+        }\n+        return entry;\n+    }\n+    \n+    /**\n+     * Adds an entry into this map, maintaining insertion order.\n+     * <p>\n+     * This implementation adds the entry to the data storage table and\n+     * to the end of the linked list.\n+     * \n+     * @param link  the entry to add\n+     * @param hashIndex  the index into the data array to store at\n+     */\n+    @Override\n+    protected void addEntry(HashEntry<K, V> entry, int hashIndex) {\n+        LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n+        link.after  = header;\n+        link.before = header.before;\n+        header.before.after = link;\n+        header.before = link;\n+        data[hashIndex] = link;\n+    }\n+\n+    /**\n+     * Creates an entry to store the data.\n+     * <p>\n+     * This implementation creates a new LinkEntry instance.\n+     * \n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    @Override\n+    protected LinkEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new LinkEntry<K, V>(next, hashCode, convertKey(key), value);\n+    }\n+\n+    /**\n+     * Removes an entry from the map and the linked list.\n+     * <p>\n+     * This implementation removes the entry from the linked list chain, then\n+     * calls the superclass implementation.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    @Override\n+    protected void removeEntry(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n+        LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n+        link.before.after = link.after;\n+        link.after.before = link.before;\n+        link.after = null;\n+        link.before = null;\n+        super.removeEntry(entry, hashIndex, previous);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the <code>before</code> field from a <code>LinkEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     * \n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>before</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since Commons Collections 3.1\n+     */\n+    protected LinkEntry<K, V> entryBefore(LinkEntry<K, V> entry) {\n+        return entry.before;\n+    }\n+\n+    /**\n+     * Gets the <code>after</code> field from a <code>LinkEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     * \n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>after</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since Commons Collections 3.1\n+     */\n+    protected LinkEntry<K, V> entryAfter(LinkEntry<K, V> entry) {\n+        return entry.after;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        if (size == 0) {\n+            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n+        }\n+        return new LinkMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * MapIterator implementation.\n+     */\n+    protected static class LinkMapIterator<K, V> extends LinkIterator<K, V> implements\n+            OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n+        protected LinkMapIterator(AbstractLinkedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public K previous() {\n+            return super.previousEntry().getKey();\n+        }\n+\n+        public K getKey() {\n+            LinkEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            LinkEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public V setValue(V value) {\n+            LinkEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the entrySet iterator\n+     */\n+    @Override\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n+        if (size() == 0) {\n+            return EmptyOrderedIterator.<Map.Entry<K, V>>emptyOrderedIterator();\n+        }\n+        return new EntrySetIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * EntrySet iterator.\n+     */\n+    protected static class EntrySetIterator<K, V> extends LinkIterator<K, V> implements\n+            OrderedIterator<Map.Entry<K, V>>, ResettableIterator<Map.Entry<K, V>> {\n+\n+        protected EntrySetIterator(AbstractLinkedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return super.nextEntry();\n+        }\n+\n+        public Map.Entry<K, V> previous() {\n+            return super.previousEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the keySet iterator\n+     */\n+    @Override\n+    protected Iterator<K> createKeySetIterator() {\n+        if (size() == 0) {\n+            return EmptyOrderedIterator.<K>emptyOrderedIterator();\n+        }\n+        return new KeySetIterator<K>(this);\n+    }\n+\n+    /**\n+     * KeySet iterator.\n+     */\n+    protected static class KeySetIterator<K> extends LinkIterator<K, Object> implements\n+            OrderedIterator<K>, ResettableIterator<K> {\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySetIterator(AbstractLinkedMap<K, ?> parent) {\n+            super((AbstractLinkedMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public K previous() {\n+            return super.previousEntry().getKey();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the values iterator\n+     */\n+    @Override\n+    protected Iterator<V> createValuesIterator() {\n+        if (size() == 0) {\n+            return EmptyOrderedIterator.<V>emptyOrderedIterator();\n+        }\n+        return new ValuesIterator<V>(this);\n+    }\n+\n+    /**\n+     * Values iterator.\n+     */\n+    protected static class ValuesIterator<V> extends LinkIterator<Object, V> implements\n+            OrderedIterator<V>, ResettableIterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(AbstractLinkedMap<?, V> parent) {\n+            super((AbstractLinkedMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            return super.nextEntry().getValue();\n+        }\n+\n+        public V previous() {\n+            return super.previousEntry().getValue();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LinkEntry that stores the data.\n+     * <p>\n+     * If you subclass <code>AbstractLinkedMap</code> but not <code>LinkEntry</code>\n+     * then you will not be able to access the protected fields.\n+     * The <code>entryXxx()</code> methods on <code>AbstractLinkedMap</code> exist\n+     * to provide the necessary access.\n+     */\n+    protected static class LinkEntry<K, V> extends HashEntry<K, V> {\n+        /** The entry before this one in the order */\n+        protected LinkEntry<K, V> before;\n+        /** The entry after this one in the order */\n+        protected LinkEntry<K, V> after;\n+\n+        /**\n+         * Constructs a new entry.\n+         * \n+         * @param next  the next entry in the hash bucket sequence\n+         * @param hashCode  the hash code\n+         * @param key  the key\n+         * @param value  the value\n+         */\n+        protected LinkEntry(HashEntry<K, V> next, int hashCode, Object key, V value) {\n+            super(next, hashCode, key, value);\n+        }\n+    }\n+\n+    /**\n+     * Base Iterator that iterates in link order.\n+     */\n+    protected static abstract class LinkIterator<K, V> {\n+\n+        /** The parent map */\n+        protected final AbstractLinkedMap<K, V> parent;\n+        /** The current (last returned) entry */\n+        protected LinkEntry<K, V> last;\n+        /** The next entry */\n+        protected LinkEntry<K, V> next;\n+        /** The modification count expected */\n+        protected int expectedModCount;\n+\n+        protected LinkIterator(AbstractLinkedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            this.next = parent.header.after;\n+            this.expectedModCount = parent.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            return (next != parent.header);\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (next.before != parent.header);\n+        }\n+\n+        protected LinkEntry<K, V> nextEntry() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (next == parent.header)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            last = next;\n+            next = next.after;\n+            return last;\n+        }\n+\n+        protected LinkEntry<K, V> previousEntry() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            LinkEntry<K, V> previous = next.before;\n+            if (previous == parent.header)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n+            }\n+            next = previous;\n+            last = previous;\n+            return last;\n+        }\n+\n+        protected LinkEntry<K, V> currentEntry() {\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (last == null) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            parent.remove(last.getKey());\n+            last = null;\n+            expectedModCount = parent.modCount;\n+        }\n+\n+        public void reset() {\n+            last = null;\n+            next = parent.header.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a Map via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with\n+ * {@link #entrySet()}, {@link #keySet()} or {@link #values()}. Instead\n+ * it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating\n+ * implementation it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Daniel Rall\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractMapDecorator<K, V> extends AbstractIterableMap<K, V> {\n+\n+    /** The map to decorate */\n+    protected transient Map<K, V> map;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractMapDecorator(Map<K, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        this.map = map;\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected Map<K, V> decorated() {\n+        return map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return decorated().containsKey(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return decorated().containsValue(value);\n+    }\n+\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return decorated().entrySet();\n+    }\n+\n+    public V get(Object key) {\n+        return decorated().get(key);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public Set<K> keySet() {\n+        return decorated().keySet();\n+    }\n+\n+    public V put(K key, V value) {\n+        return decorated().put(key, value);\n+    }\n+\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        decorated().putAll(mapToCopy);\n+    }\n+\n+    public V remove(Object key) {\n+        return decorated().remove(key);\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Collection<V> values() {\n+        return decorated().values();\n+    }\n+   \n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractOrderedMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to an OrderedMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractOrderedMapDecorator<K, V> extends AbstractMapDecorator<K, V>\n+        implements OrderedMap<K, V> {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractOrderedMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractOrderedMapDecorator(OrderedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected OrderedMap<K, V> decorated() {\n+        return (OrderedMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    public K nextKey(K key) {\n+        return decorated().nextKey(key);\n+    }\n+\n+    public K previousKey(K key) {\n+        return decorated().previousKey(key);\n+    }\n+\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n+\n+/**\n+ * An abstract implementation of a hash-based map that allows the entries to\n+ * be removed by the garbage collector.\n+ * <p>\n+ * This class implements all the features necessary for a subclass reference\n+ * hash-based map. Key-value entries are stored in instances of the\n+ * <code>ReferenceEntry</code> class which can be overridden and replaced.\n+ * The iterators can similarly be replaced, without the need to replace the KeySet,\n+ * EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * When you construct an <code>AbstractReferenceMap</code>, you can specify what\n+ * kind of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The keys can be configured to be weak but the values hard,\n+ * in which case this class will behave like a\n+ * <a href=\"http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html\">\n+ * <code>WeakHashMap</code></a>. However, you can also specify hard keys and\n+ * weak values, or any other combination. The default constructor uses\n+ * hard keys and soft values, providing a memory-sensitive cache.\n+ * <p>\n+ * This {@link Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a\n+ * <code>NullPointerException</code>.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to\n+ * provide synchronized access to a <code>ReferenceMap</code>.\n+ *\n+ * @see java.lang.ref.Reference\n+ * @since Commons Collections 3.1 (extracted from ReferenceMap in 3.0)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractReferenceMap<K, V> extends AbstractHashedMap<K, V> {\n+\n+    /**\n+     * Reference type enum.\n+     */\n+    public static enum ReferenceStrength {\n+        HARD(0), SOFT(1), WEAK(2);\n+\n+        /** value */\n+        public final int value;\n+\n+        /**\n+         * Resolve enum from int.\n+         * @param value\n+         * @return ReferenceType\n+         * @throws IllegalArgumentException if the specified value is invalid.\n+         */\n+        public static ReferenceStrength resolve(int value) {\n+            switch (value) {\n+            case 0:\n+                return HARD;\n+            case 1:\n+                return SOFT;\n+            case 2:\n+                return WEAK;\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private ReferenceStrength(int value) {\n+            this.value = value;\n+        }\n+\n+    }\n+\n+    /**\n+     * The reference type for keys.\n+     */\n+    protected ReferenceStrength keyType;\n+\n+    /**\n+     * The reference type for values.\n+     */\n+    protected ReferenceStrength valueType;\n+\n+    /**\n+     * Should the value be automatically purged when the associated key has been collected?\n+     */\n+    protected boolean purgeValues;\n+\n+    /**\n+     * ReferenceQueue used to eliminate stale mappings.\n+     * See purge.\n+     */\n+    private transient ReferenceQueue<Object> queue;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor used during deserialization.\n+     */\n+    protected AbstractReferenceMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty map with the specified reference types,\n+     * load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the\n+     *   key is garbage collected\n+     */\n+    protected AbstractReferenceMap(\n+            ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n+            float loadFactor, boolean purgeValues) {\n+        super(capacity, loadFactor);\n+        this.keyType = keyType;\n+        this.valueType = valueType;\n+        this.purgeValues = purgeValues;\n+    }\n+\n+    /**\n+     * Initialise this subclass during construction, cloning or deserialization.\n+     */\n+    @Override\n+    protected void init() {\n+        queue = new ReferenceQueue<Object>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of the map.\n+     *\n+     * @return the size\n+     */\n+    @Override\n+    public int size() {\n+        purgeBeforeRead();\n+        return super.size();\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     *\n+     * @return true if the map is currently size zero\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        purgeBeforeRead();\n+        return super.isEmpty();\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified key.\n+     *\n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    @Override\n+    public boolean containsKey(Object key) {\n+        purgeBeforeRead();\n+        Entry<K, V> entry = getEntry(key);\n+        if (entry == null) {\n+            return false;\n+        }\n+        return (entry.getValue() != null);\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    public boolean containsValue(Object value) {\n+        purgeBeforeRead();\n+        if (value == null) {\n+            return false;\n+        }\n+        return super.containsValue(value);\n+    }\n+\n+    /**\n+     * Gets the value mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    @Override\n+    public V get(Object key) {\n+        purgeBeforeRead();\n+        Entry<K, V> entry = getEntry(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getValue();\n+    }\n+\n+\n+    /**\n+     * Puts a key-value mapping into this map.\n+     * Neither the key nor the value may be null.\n+     *\n+     * @param key  the key to add, must not be null\n+     * @param value  the value to add, must not be null\n+     * @return the value previously mapped to this key, null if none\n+     * @throws NullPointerException if either the key or value is null\n+     */\n+    @Override\n+    public V put(K key, V value) {\n+        if (key == null) {\n+            throw new NullPointerException(\"null keys not allowed\");\n+        }\n+        if (value == null) {\n+            throw new NullPointerException(\"null values not allowed\");\n+        }\n+\n+        purgeBeforeWrite();\n+        return super.put(key, value);\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     *\n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    @Override\n+    public V remove(Object key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        purgeBeforeWrite();\n+        return super.remove(key);\n+    }\n+\n+    /**\n+     * Clears this map.\n+     */\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        while (queue.poll() != null) {} // drain the queue\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a MapIterator over the reference map.\n+     * The iterator only returns valid key/value pairs.\n+     *\n+     * @return a map iterator\n+     */\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        return new ReferenceMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Returns a set view of this map's entries.\n+     * An iterator returned entry is valid until <code>next()</code> is called again.\n+     * The <code>setValue()</code> method on the <code>toArray</code> entries has no effect.\n+     *\n+     * @return a set view of this map's entries\n+     */\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new ReferenceEntrySet<K, V>(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Returns a set view of this map's keys.\n+     *\n+     * @return a set view of this map's keys\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new ReferenceKeySet<K>(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Returns a collection view of this map's values.\n+     *\n+     * @return a set view of this map's values\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new ReferenceValues<V>(this);\n+        }\n+        return values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Purges stale mappings from this map before read operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     */\n+    protected void purgeBeforeRead() {\n+        purge();\n+    }\n+\n+    /**\n+     * Purges stale mappings from this map before write operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     */\n+    protected void purgeBeforeWrite() {\n+        purge();\n+    }\n+\n+    /**\n+     * Purges stale mappings from this map.\n+     * <p>\n+     * Note that this method is not synchronized!  Special\n+     * care must be taken if, for instance, you want stale\n+     * mappings to be removed on a periodic basis by some\n+     * background thread.\n+     */\n+    protected void purge() {\n+        Reference<?> ref = queue.poll();\n+        while (ref != null) {\n+            purge(ref);\n+            ref = queue.poll();\n+        }\n+    }\n+\n+    /**\n+     * Purges the specified reference.\n+     *\n+     * @param ref  the reference to purge\n+     */\n+    protected void purge(Reference<?> ref) {\n+        // The hashCode of the reference is the hashCode of the\n+        // mapping key, even if the reference refers to the\n+        // mapping value...\n+        int hash = ref.hashCode();\n+        int index = hashIndex(hash, data.length);\n+        HashEntry<K, V> previous = null;\n+        HashEntry<K, V> entry = data[index];\n+        while (entry != null) {\n+            if (((ReferenceEntry<K, V>) entry).purge(ref)) {\n+                if (previous == null) {\n+                    data[index] = entry.next;\n+                } else {\n+                    previous.next = entry.next;\n+                }\n+                this.size--;\n+                return;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    @Override\n+    protected HashEntry<K, V> getEntry(Object key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        return super.getEntry(key);\n+    }\n+\n+    /**\n+     * Gets the hash code for a MapEntry.\n+     * Subclasses can override this, for example to use the identityHashCode.\n+     *\n+     * @param key  the key to get a hash code for, may be null\n+     * @param value  the value to get a hash code for, may be null\n+     * @return the hash code, as per the MapEntry specification\n+     */\n+    protected int hashEntry(Object key, Object value) {\n+        return (key == null ? 0 : key.hashCode()) ^\n+               (value == null ? 0 : value.hashCode());\n+    }\n+\n+    /**\n+     * Compares two keys, in internal converted form, to see if they are equal.\n+     * <p>\n+     * This implementation converts the key from the entry to a real reference\n+     * before comparison.\n+     *\n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        key2 = (keyType == ReferenceStrength.HARD ? key2 : ((Reference<K>) key2).get());\n+        return (key1 == key2 || key1.equals(key2));\n+    }\n+\n+    /**\n+     * Creates a ReferenceEntry instead of a HashEntry.\n+     *\n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    @Override\n+    protected ReferenceEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new ReferenceEntry<K, V>(this, next, hashCode, key, value);\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     *\n+     * @return the entrySet iterator\n+     */\n+    @Override\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n+        return new ReferenceEntrySetIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Creates an key set iterator.\n+     *\n+     * @return the keySet iterator\n+     */\n+    @Override\n+    protected Iterator<K> createKeySetIterator() {\n+        return new ReferenceKeySetIterator<K>(this);\n+    }\n+\n+    /**\n+     * Creates an values iterator.\n+     *\n+     * @return the values iterator\n+     */\n+    @Override\n+    protected Iterator<V> createValuesIterator() {\n+        return new ReferenceValuesIterator<V>(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * EntrySet implementation.\n+     */\n+    static class ReferenceEntrySet<K, V> extends EntrySet<K, V> {\n+\n+        protected ReferenceEntrySet(AbstractHashedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(T[] arr) {\n+            // special implementation to handle disappearing entries\n+            ArrayList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>();\n+            for (Map.Entry<K, V> entry : this) {\n+                list.add(new DefaultMapEntry<K, V>(entry));\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * KeySet implementation.\n+     */\n+    static class ReferenceKeySet<K> extends KeySet<K> {\n+\n+        protected ReferenceKeySet(AbstractHashedMap<K, ?> parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(T[] arr) {\n+            // special implementation to handle disappearing keys\n+            List<K> list = new ArrayList<K>(parent.size());\n+            for (K key : this) {\n+                list.add(key);\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Values implementation.\n+     */\n+    static class ReferenceValues<V> extends Values<V> {\n+\n+        protected ReferenceValues(AbstractHashedMap<?, V> parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(T[] arr) {\n+            // special implementation to handle disappearing values\n+            List<V> list = new ArrayList<V>(parent.size());\n+            for (V value : this) {\n+                list.add(value);\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A MapEntry implementation for the map.\n+     * <p>\n+     * If getKey() or getValue() returns null, it means\n+     * the mapping is stale and should be removed.\n+     *\n+     * @since Commons Collections 3.1\n+     */\n+    protected static class ReferenceEntry<K, V> extends HashEntry<K, V> {\n+        /** The parent map */\n+        protected final AbstractReferenceMap<K, V> parent;\n+\n+        /**\n+         * Creates a new entry object for the ReferenceMap.\n+         *\n+         * @param parent  the parent map\n+         * @param next  the next entry in the hash bucket\n+         * @param hashCode  the hash code of the key\n+         * @param key  the key\n+         * @param value  the value\n+         */\n+        public ReferenceEntry(AbstractReferenceMap<K, V> parent, HashEntry<K, V> next, int hashCode, K key, V value) {\n+            super(next, hashCode, null, null);\n+            this.parent = parent;\n+            this.key = toReference(parent.keyType, key, hashCode);\n+            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately\n+        }\n+\n+        /**\n+         * Gets the key from the entry.\n+         * This method dereferences weak and soft keys and thus may return null.\n+         *\n+         * @return the key, which may be null if it was garbage collected\n+         */\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public K getKey() {\n+            return (K) ((parent.keyType == ReferenceStrength.HARD) ? key : ((Reference<K>) key).get());\n+        }\n+\n+        /**\n+         * Gets the value from the entry.\n+         * This method dereferences weak and soft value and thus may return null.\n+         *\n+         * @return the value, which may be null if it was garbage collected\n+         */\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V getValue() {\n+            return (V) ((parent.valueType == ReferenceStrength.HARD) ? value : ((Reference<V>) value).get());\n+        }\n+\n+        /**\n+         * Sets the value of the entry.\n+         *\n+         * @param obj  the object to store\n+         * @return the previous value\n+         */\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V setValue(V obj) {\n+            V old = getValue();\n+            if (parent.valueType != ReferenceStrength.HARD) {\n+                ((Reference<V>) value).clear();\n+            }\n+            value = toReference(parent.valueType, obj, hashCode);\n+            return old;\n+        }\n+\n+        /**\n+         * Compares this map entry to another.\n+         * <p>\n+         * This implementation uses <code>isEqualKey</code> and\n+         * <code>isEqualValue</code> on the main map for comparison.\n+         *\n+         * @param obj  the other map entry to compare to\n+         * @return true if equal, false if not\n+         */\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>)obj;\n+            Object entryKey = entry.getKey();  // convert to hard reference\n+            Object entryValue = entry.getValue();  // convert to hard reference\n+            if ((entryKey == null) || (entryValue == null)) {\n+                return false;\n+            }\n+            // compare using map methods, aiding identity subclass\n+            // note that key is direct access and value is via method\n+            return parent.isEqualKey(entryKey, key) &&\n+                   parent.isEqualValue(entryValue, getValue());\n+        }\n+\n+        /**\n+         * Gets the hashcode of the entry using temporary hard references.\n+         * <p>\n+         * This implementation uses <code>hashEntry</code> on the main map.\n+         *\n+         * @return the hashcode of the entry\n+         */\n+        @Override\n+        public int hashCode() {\n+            return parent.hashEntry(getKey(), getValue());\n+        }\n+\n+        /**\n+         * Constructs a reference of the given type to the given referent.\n+         * The reference is registered with the queue for later purging.\n+         *\n+         * @param type  HARD, SOFT or WEAK\n+         * @param referent  the object to refer to\n+         * @param hash  the hash code of the <i>key</i> of the mapping;\n+         *    this number might be different from referent.hashCode() if\n+         *    the referent represents a value and not a key\n+         */\n+        protected <T> Object toReference(ReferenceStrength type, T referent, int hash) {\n+            if (type == ReferenceStrength.HARD) {\n+                return referent;\n+            }\n+            if (type == ReferenceStrength.SOFT) {\n+                return new SoftRef<T>(hash, referent, parent.queue);\n+            }\n+            if (type == ReferenceStrength.WEAK) {\n+                return new WeakRef<T>(hash, referent, parent.queue);\n+            }\n+            throw new Error();\n+        }\n+\n+        /**\n+         * Purges the specified reference\n+         * @param ref  the reference to purge\n+         * @return true or false\n+         */\n+        boolean purge(Reference<?> ref) {\n+            boolean r = (parent.keyType != ReferenceStrength.HARD) && (key == ref);\n+            r = r || ((parent.valueType != ReferenceStrength.HARD) && (value == ref));\n+            if (r) {\n+                if (parent.keyType != ReferenceStrength.HARD) {\n+                    ((Reference<?>) key).clear();\n+                }\n+                if (parent.valueType != ReferenceStrength.HARD) {\n+                    ((Reference<?>) value).clear();\n+                } else if (parent.purgeValues) {\n+                    value = null;\n+                }\n+            }\n+            return r;\n+        }\n+\n+        /**\n+         * Gets the next entry in the bucket.\n+         *\n+         * @return the next entry in the bucket\n+         */\n+        protected ReferenceEntry<K, V> next() {\n+            return (ReferenceEntry<K, V>) next;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Base iterator class.\n+     */\n+    static class ReferenceBaseIterator<K, V> {\n+        /** The parent map */\n+        final AbstractReferenceMap<K, V> parent;\n+\n+        // These fields keep track of where we are in the table.\n+        int index;\n+        ReferenceEntry<K, V> entry;\n+        ReferenceEntry<K, V> previous;\n+\n+        // These Object fields provide hard references to the\n+        // current and next entry; this assures that if hasNext()\n+        // returns true, next() will actually return a valid element.\n+        K currentKey, nextKey;\n+        V currentValue, nextValue;\n+\n+        int expectedModCount;\n+\n+        public ReferenceBaseIterator(AbstractReferenceMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            index = (parent.size() != 0 ? parent.data.length : 0);\n+            // have to do this here!  size() invocation above\n+            // may have altered the modCount.\n+            expectedModCount = parent.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            checkMod();\n+            while (nextNull()) {\n+                ReferenceEntry<K, V> e = entry;\n+                int i = index;\n+                while ((e == null) && (i > 0)) {\n+                    i--;\n+                    e = (ReferenceEntry<K, V>) parent.data[i];\n+                }\n+                entry = e;\n+                index = i;\n+                if (e == null) {\n+                    currentKey = null;\n+                    currentValue = null;\n+                    return false;\n+                }\n+                nextKey = e.getKey();\n+                nextValue = e.getValue();\n+                if (nextNull()) {\n+                    entry = entry.next();\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private void checkMod() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        private boolean nextNull() {\n+            return (nextKey == null) || (nextValue == null);\n+        }\n+\n+        protected ReferenceEntry<K, V> nextEntry() {\n+            checkMod();\n+            if (nextNull() && !hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            previous = entry;\n+            entry = entry.next();\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+            nextKey = null;\n+            nextValue = null;\n+            return previous;\n+        }\n+\n+        protected ReferenceEntry<K, V> currentEntry() {\n+            checkMod();\n+            return previous;\n+        }\n+\n+        public void remove() {\n+            checkMod();\n+            if (previous == null) {\n+                throw new IllegalStateException();\n+            }\n+            parent.remove(currentKey);\n+            previous = null;\n+            currentKey = null;\n+            currentValue = null;\n+            expectedModCount = parent.modCount;\n+        }\n+    }\n+\n+    /**\n+     * The EntrySet iterator.\n+     */\n+    static class ReferenceEntrySetIterator<K, V> extends ReferenceBaseIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        public ReferenceEntrySetIterator(AbstractReferenceMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+    }\n+\n+    /**\n+     * The keySet iterator.\n+     */\n+    static class ReferenceKeySetIterator<K> extends ReferenceBaseIterator<K, Object> implements Iterator<K> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReferenceKeySetIterator(AbstractReferenceMap<K, ?> parent) {\n+            super((AbstractReferenceMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+    }\n+\n+    /**\n+     * The values iterator.\n+     */\n+    static class ReferenceValuesIterator<V> extends ReferenceBaseIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReferenceValuesIterator(AbstractReferenceMap<?, V> parent) {\n+            super((AbstractReferenceMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            return nextEntry().getValue();\n+        }\n+    }\n+\n+    /**\n+     * The MapIterator implementation.\n+     */\n+    static class ReferenceMapIterator<K, V> extends ReferenceBaseIterator<K, V> implements MapIterator<K, V> {\n+\n+        protected ReferenceMapIterator(AbstractReferenceMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+\n+        public K getKey() {\n+            HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public V setValue(V value) {\n+            HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // These two classes store the hashCode of the key of\n+    // of the mapping, so that after they're dequeued a quick\n+    // lookup of the bucket in the table can occur.\n+\n+    /**\n+     * A soft reference holder.\n+     */\n+    static class SoftRef<T> extends SoftReference<T> {\n+        /** the hashCode of the key (even if the reference points to a value) */\n+        private final int hash;\n+\n+        public SoftRef(int hash, T r, ReferenceQueue<? super T> q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+    /**\n+     * A weak reference holder.\n+     */\n+    static class WeakRef<T> extends WeakReference<T> {\n+        /** the hashCode of the key (even if the reference points to a value) */\n+        private final int hash;\n+\n+        public WeakRef(int hash, T r, ReferenceQueue<? super T> q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the superclass method to store the state of this class.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to serialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>writeObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if they have a specific field that must be present\n+     * on read before this implementation will work. Generally, the read determines\n+     * what must be serialized here, if anything.\n+     *\n+     * @param out  the output stream\n+     */\n+    @Override\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        out.writeInt(keyType.value);\n+        out.writeInt(valueType.value);\n+        out.writeBoolean(purgeValues);\n+        out.writeFloat(loadFactor);\n+        out.writeInt(data.length);\n+        for (MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+            out.writeObject(it.getValue());\n+        }\n+        out.writeObject(null);  // null terminate map\n+        // do not call super.doWriteObject() as code there doesn't work for reference map\n+    }\n+\n+    /**\n+     * Replaces the superclassm method to read the state of this class.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to deserialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>readObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if the subclass has a specific field that must be present\n+     * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n+     *\n+     * @param in  the input stream\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        this.keyType = ReferenceStrength.resolve(in.readInt());\n+        this.valueType = ReferenceStrength.resolve(in.readInt());\n+        this.purgeValues = in.readBoolean();\n+        this.loadFactor = in.readFloat();\n+        int capacity = in.readInt();\n+        init();\n+        data = new HashEntry[capacity];\n+        while (true) {\n+            K key = (K) in.readObject();\n+            if (key == null) {\n+                break;\n+            }\n+            V value = (V) in.readObject();\n+            put(key, value);\n+        }\n+        threshold = calculateThreshold(data.length, loadFactor);\n+        // do not call super.doReadObject() as code there doesn't work for reference map\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractSortedMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.IterableSortedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.iterators.ListIteratorWrapper;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a Map via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractSortedMapDecorator<K, V> extends AbstractMapDecorator<K, V> implements\n+        IterableSortedMap<K, V> {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractSortedMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractSortedMapDecorator(SortedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected SortedMap<K, V> decorated() {\n+        return (SortedMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Comparator<? super K> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return decorated().subMap(fromKey, toKey);\n+    }\n+\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return decorated().headMap(toKey);\n+    }\n+\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return decorated().tailMap(fromKey);\n+    }\n+\n+    public K previousKey(K key) {\n+        SortedMap<K, V> headMap = headMap(key);\n+        return headMap.isEmpty() ? null : headMap.lastKey();\n+    }\n+\n+    public K nextKey(K key) {\n+        Iterator<K> it = tailMap(key).keySet().iterator();\n+        it.next();\n+        return it.hasNext() ? it.next() : null;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new SortedMapIterator<K, V>(entrySet());\n+    }\n+\n+    /**\n+     * OrderedMapIterator implementation.\n+     *\n+     * @param <K>\n+     * @param <V>\n+     */\n+    protected static class SortedMapIterator<K, V> extends EntrySetToMapIteratorAdapter<K, V>\n+            implements OrderedMapIterator<K, V> {\n+\n+        /**\n+         * Create a new AbstractSortedMapDecorator.SortedMapIterator.\n+         */\n+        protected SortedMapIterator(Set<Map.Entry<K, V>> entrySet) {\n+            super(entrySet);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public synchronized void reset() {\n+            super.reset();\n+            iterator = new ListIteratorWrapper<Map.Entry<K, V>>(iterator);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean hasPrevious() {\n+            return ((ListIterator<Map.Entry<K, V>>) iterator).hasPrevious();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K previous() {\n+            entry = ((ListIterator<Map.Entry<K, V>>) iterator).previous();\n+            return getKey();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/CaseInsensitiveMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * A case-insensitive <code>Map</code>.\n+ * <p>\n+ * Before keys are added to the map or compared to other existing keys, they are converted\n+ * to all lowercase in a locale-independent fashion by using information from the Unicode\n+ * data file.\n+ * <p>\n+ * Null keys are supported.  \n+ * <p>\n+ * The <code>keySet()</code> method returns all lowercase keys, or nulls.\n+ * <p>\n+ * Example:\n+ * <pre><code>\n+ *  Map map = new CaseInsensitiveMap();\n+ *  map.put(\"One\", \"One\");\n+ *  map.put(\"Two\", \"Two\");\n+ *  map.put(null, \"Three\");\n+ *  map.put(\"one\", \"Four\");\n+ * </code></pre>\n+ * creates a <code>CaseInsensitiveMap</code> with three entries.<br>\n+ * <code>map.get(null)</code> returns <code>\"Three\"</code> and <code>map.get(\"ONE\")</code>\n+ * returns <code>\"Four\".</code>  The <code>Set</code> returned by <code>keySet()</code>\n+ * equals <code>{\"one\", \"two\", null}.</code>\n+ * <p>\n+ * <strong>This map will violate the detail of various Map and map view contracts.</note>\n+ * As a general rule, don't compare this map to other maps. In particular, you can't\n+ * use decorators like {@link ListOrderedMap} on it, which silently assume that these\n+ * contracts are fulfilled.\n+ * <p>\n+ * <strong>Note that CaseInsensitiveMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Commons-Collections team\n+ */\n+public class CaseInsensitiveMap<K, V> extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -7074655917369299456L;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public CaseInsensitiveMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public CaseInsensitiveMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public CaseInsensitiveMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p>\n+     * Keys will be converted to lower case strings, which may cause\n+     * some entries to be removed (if string representation of keys differ\n+     * only by character case).\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public CaseInsensitiveMap(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overrides convertKey() from {@link AbstractHashedMap} to convert keys to \n+     * lower case.\n+     * <p>\n+     * Returns {@link AbstractHashedMap#NULL} if key is null.\n+     * \n+     * @param key  the key convert\n+     * @return the converted key\n+     */\n+    @Override\n+    protected Object convertKey(Object key) {\n+        if (key != null) {\n+            char[] chars = key.toString().toCharArray();\n+            for (int i = chars.length - 1; i >= 0; i--) {\n+                chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i]));\n+            }\n+            return new String(chars);\n+        }\n+        return AbstractHashedMap.NULL;\n+    }   \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public CaseInsensitiveMap<K, V> clone() {\n+        return (CaseInsensitiveMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+ \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/CompositeMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.Serializable;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.collection.CompositeCollection;\n+import org.apache.commons.collections.set.CompositeSet;\n+\n+/**\n+ * Decorates a map of other maps to provide a single unified view.\n+ * <p>\n+ * Changes made to this map will actually be made on the decorated map.\n+ * Add and remove operations require the use of a pluggable strategy. If no\n+ * strategy is provided then add and remove are unsupported.\n+ * <p>\n+ * <strong>Note that CompositeMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Brian McCallister\n+ */\n+public class CompositeMap<K, V> extends AbstractIterableMap<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -6096931280583808322L;\n+\n+    /** Array of all maps in the composite */\n+    private Map<K, V>[] composite;\n+\n+    /** Handle mutation operations */\n+    private MapMutator<K, V> mutator;\n+\n+    /**\n+     * Create a new, empty, CompositeMap.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap() {\n+        this(new Map[] {}, null);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap with two composited Map instances.\n+     *\n+     * @param one  the first Map to be composited\n+     * @param two  the second Map to be composited\n+     * @throws IllegalArgumentException if there is a key collision\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(Map<K, V> one, Map<K, V> two) {\n+        this(new Map[] { one, two }, null);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap with two composited Map instances.\n+     *\n+     * @param one  the first Map to be composited\n+     * @param two  the second Map to be composited\n+     * @param mutator  MapMutator to be used for mutation operations\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(Map<K, V> one, Map<K, V> two, MapMutator<K, V> mutator) {\n+        this(new Map[] { one, two }, mutator);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap which composites all of the Map instances in the\n+     * argument. It copies the argument array, it does not use it directly.\n+     *\n+     * @param composite  the Maps to be composited\n+     * @throws IllegalArgumentException if there is a key collision\n+     */\n+    public CompositeMap(Map<K, V>... composite) {\n+        this(composite, null);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap which composites all of the Map instances in the\n+     * argument. It copies the argument array, it does not use it directly.\n+     *\n+     * @param composite  Maps to be composited\n+     * @param mutator  MapMutator to be used for mutation operations\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(Map<K, V>[] composite, MapMutator<K, V> mutator) {\n+        this.mutator = mutator;\n+        this.composite = new Map[0];\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            this.addComposited(composite[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify the MapMutator to be used by mutation operations.\n+     *\n+     * @param mutator  the MapMutator to be used for mutation delegation\n+     */\n+    public void setMutator(MapMutator<K, V> mutator) {\n+        this.mutator = mutator;\n+    }\n+\n+    /**\n+     * Add an additional Map to the composite.\n+     *\n+     * @param map  the Map to be added to the composite\n+     * @throws IllegalArgumentException if there is a key collision and there is no\n+     *         MapMutator set to handle it.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized void addComposited(Map<K, V> map) throws IllegalArgumentException {\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            Collection<K> intersect = CollectionUtils.intersection(this.composite[i].keySet(), map.keySet());\n+            if (intersect.size() != 0) {\n+                if (this.mutator == null) {\n+                    throw new IllegalArgumentException(\"Key collision adding Map to CompositeMap\");\n+                }\n+                this.mutator.resolveCollision(this, this.composite[i], map, intersect);\n+            }\n+        }\n+        Map<K, V>[] temp = new Map[this.composite.length + 1];\n+        System.arraycopy(this.composite, 0, temp, 0, this.composite.length);\n+        temp[temp.length - 1] = map;\n+        this.composite = temp;\n+    }\n+\n+    /**\n+     * Remove a Map from the composite.\n+     *\n+     * @param map  the Map to be removed from the composite\n+     * @return The removed Map or <code>null</code> if map is not in the composite\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized Map<K, V> removeComposited(Map<K, V> map) {\n+        int size = this.composite.length;\n+        for (int i = 0; i < size; ++i) {\n+            if (this.composite[i].equals(map)) {\n+                Map<K, V>[] temp = new Map[size - 1];\n+                System.arraycopy(this.composite, 0, temp, 0, i);\n+                System.arraycopy(this.composite, i + 1, temp, i, size - i - 1);\n+                this.composite = temp;\n+                return map;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calls <code>clear()</code> on all composited Maps.\n+     *\n+     * @throws UnsupportedOperationException if any of the composited Maps do not support clear()\n+     */\n+    public void clear() {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            this.composite[i].clear();\n+        }\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains a mapping for the specified\n+     * key.  More formally, returns <tt>true</tt> if and only if\n+     * this map contains at a mapping for a key <tt>k</tt> such that\n+     * <tt>(key==null ? k==null : key.equals(k))</tt>.  (There can be\n+     * at most one such mapping.)\n+     *\n+     * @param key  key whose presence in this map is to be tested.\n+     * @return <tt>true</tt> if this map contains a mapping for the specified\n+     *         key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     *         this map (optional).\n+     * @throws NullPointerException if the key is <tt>null</tt> and this map\n+     *            does not not permit <tt>null</tt> keys (optional).\n+     */\n+    public boolean containsKey(Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map maps one or more keys to the\n+     * specified value.  More formally, returns <tt>true</tt> if and only if\n+     * this map contains at least one mapping to a value <tt>v</tt> such that\n+     * <tt>(value==null ? v==null : value.equals(v))</tt>.  This operation\n+     * will probably require time linear in the map size for most\n+     * implementations of the <tt>Map</tt> interface.\n+     *\n+     * @param value value whose presence in this map is to be tested.\n+     * @return <tt>true</tt> if this map maps one or more keys to the\n+     *         specified value.\n+     * @throws ClassCastException if the value is of an inappropriate type for\n+     *         this map (optional).\n+     * @throws NullPointerException if the value is <tt>null</tt> and this map\n+     *            does not not permit <tt>null</tt> values (optional).\n+     */\n+    public boolean containsValue(Object value) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsValue(value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a set view of the mappings contained in this map.  Each element\n+     * in the returned set is a <code>Map.Entry</code>.  The set is backed by the\n+     * map, so changes to the map are reflected in the set, and vice-versa.\n+     * If the map is modified while an iteration over the set is in progress,\n+     * the results of the iteration are undefined.  The set supports element\n+     * removal, which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n+     * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not support\n+     * the <tt>add</tt> or <tt>addAll</tt> operations.\n+     * <p>\n+     * This implementation returns a <code>CompositeSet</code> which\n+     * composites the entry sets from all of the composited maps.\n+     *\n+     * @see CompositeSet\n+     * @return a set view of the mappings contained in this map.\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        CompositeSet<Map.Entry<K, V>> entries = new CompositeSet<Map.Entry<K,V>>();\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            entries.addComposited(composite[i].entrySet());\n+        }\n+        return entries;\n+    }\n+\n+    /**\n+     * Returns the value to which this map maps the specified key.  Returns\n+     * <tt>null</tt> if the map contains no mapping for this key.  A return\n+     * value of <tt>null</tt> does not <i>necessarily</i> indicate that the\n+     * map contains no mapping for the key; it's also possible that the map\n+     * explicitly maps the key to <tt>null</tt>.  The <tt>containsKey</tt>\n+     * operation may be used to distinguish these two cases.\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * <tt>k</tt> to a value <tt>v</tt> such that <tt>(key==null ? k==null :\n+     * key.equals(k))</tt>, then this method returns <tt>v</tt>; otherwise\n+     * it returns <tt>null</tt>.  (There can be at most one such mapping.)\n+     *\n+     * @param key key whose associated value is to be returned.\n+     * @return the value to which this map maps the specified key, or\n+     *         <tt>null</tt> if the map contains no mapping for this key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     *         this map (optional).\n+     * @throws NullPointerException key is <tt>null</tt> and this map does not\n+     *         not permit <tt>null</tt> keys (optional).\n+     *\n+     * @see #containsKey(Object)\n+     */\n+    public V get(Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) {\n+                return this.composite[i].get(key);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains no key-value mappings.\n+     *\n+     * @return <tt>true</tt> if this map contains no key-value mappings.\n+     */\n+    public boolean isEmpty() {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (!this.composite[i].isEmpty()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns a set view of the keys contained in this map.  The set is\n+     * backed by the map, so changes to the map are reflected in the set, and\n+     * vice-versa.  If the map is modified while an iteration over the set is\n+     * in progress, the results of the iteration are undefined.  The set\n+     * supports element removal, which removes the corresponding mapping from\n+     * the map, via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,\n+     * <tt>removeAll</tt> <tt>retainAll</tt>, and <tt>clear</tt> operations.\n+     * It does not support the add or <tt>addAll</tt> operations.\n+     * <p>\n+     * This implementation returns a <code>CompositeSet</code> which\n+     * composites the key sets from all of the composited maps.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set<K> keySet() {\n+        CompositeSet<K> keys = new CompositeSet<K>();\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            keys.addComposited(this.composite[i].keySet());\n+        }\n+        return keys;\n+    }\n+\n+    /**\n+     * Associates the specified value with the specified key in this map\n+     * (optional operation).  If the map previously contained a mapping for\n+     * this key, the old value is replaced by the specified value.  (A map\n+     * <tt>m</tt> is said to contain a mapping for a key <tt>k</tt> if and only\n+     * if {@link #containsKey(Object) m.containsKey(k)} would return\n+     * <tt>true</tt>.))\n+     *\n+     * @param key key with which the specified value is to be associated.\n+     * @param value value to be associated with the specified key.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     *         if there was no mapping for key.  A <tt>null</tt> return can\n+     *         also indicate that the map previously associated <tt>null</tt>\n+     *         with the specified key, if the implementation supports\n+     *         <tt>null</tt> values.\n+     *\n+     * @throws UnsupportedOperationException if no MapMutator has been specified\n+     * @throws ClassCastException if the class of the specified key or value\n+     *            prevents it from being stored in this map.\n+     * @throws IllegalArgumentException if some aspect of this key or value\n+     *            prevents it from being stored in this map.\n+     * @throws NullPointerException this map does not permit <tt>null</tt>\n+     *            keys or values, and the specified key or value is\n+     *            <tt>null</tt>.\n+     */\n+    public V put(K key, V value) {\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\"No mutator specified\");\n+        }\n+        return this.mutator.put(this, this.composite, key, value);\n+    }\n+\n+    /**\n+     * Copies all of the mappings from the specified map to this map\n+     * (optional operation).  The effect of this call is equivalent to that\n+     * of calling {@link #put(Object,Object) put(k, v)} on this map once\n+     * for each mapping from key <tt>k</tt> to value <tt>v</tt> in the\n+     * specified map.  The behavior of this operation is unspecified if the\n+     * specified map is modified while the operation is in progress.\n+     *\n+     * @param map Mappings to be stored in this map.\n+     *\n+     * @throws UnsupportedOperationException if the <tt>putAll</tt> method is\n+     *         not supported by this map.\n+     *\n+     * @throws ClassCastException if the class of a key or value in the\n+     *         specified map prevents it from being stored in this map.\n+     *\n+     * @throws IllegalArgumentException some aspect of a key or value in the\n+     *         specified map prevents it from being stored in this map.\n+     * @throws NullPointerException the specified map is <tt>null</tt>, or if\n+     *         this map does not permit <tt>null</tt> keys or values, and the\n+     *         specified map contains <tt>null</tt> keys or values.\n+     */\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\"No mutator specified\");\n+        }\n+        this.mutator.putAll(this, this.composite, map);\n+    }\n+\n+    /**\n+     * Removes the mapping for this key from this map if it is present\n+     * (optional operation).   More formally, if this map contains a mapping\n+     * from key <tt>k</tt> to value <tt>v</tt> such that\n+     * <code>(key==null ?  k==null : key.equals(k))</code>, that mapping\n+     * is removed.  (The map can contain at most one such mapping.)\n+     *\n+     * <p>Returns the value to which the map previously associated the key, or\n+     * <tt>null</tt> if the map contained no mapping for this key.  (A\n+     * <tt>null</tt> return can also indicate that the map previously\n+     * associated <tt>null</tt> with the specified key if the implementation\n+     * supports <tt>null</tt> values.)  The map will not contain a mapping for\n+     * the specified  key once the call returns.\n+     *\n+     * @param key key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     *         if there was no mapping for key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     *         the composited map (optional).\n+     * @throws NullPointerException if the key is <tt>null</tt> and the composited map\n+     *            does not not permit <tt>null</tt> keys (optional).\n+     * @throws UnsupportedOperationException if the <tt>remove</tt> method is\n+     *         not supported by the composited map containing the key\n+     */\n+    public V remove(Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) {\n+                return this.composite[i].remove(key);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the number of key-value mappings in this map.  If the\n+     * map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns\n+     * <tt>Integer.MAX_VALUE</tt>.\n+     *\n+     * @return the number of key-value mappings in this map.\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            size += this.composite[i].size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Returns a collection view of the values contained in this map.  The\n+     * collection is backed by the map, so changes to the map are reflected in\n+     * the collection, and vice-versa.  If the map is modified while an\n+     * iteration over the collection is in progress, the results of the\n+     * iteration are undefined.  The collection supports element removal,\n+     * which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\n+     * <tt>removeAll</tt>, <tt>retainAll</tt> and <tt>clear</tt> operations.\n+     * It does not support the add or <tt>addAll</tt> operations.\n+     *\n+     * @return a collection view of the values contained in this map.\n+     */\n+    public Collection<V> values() {\n+        CompositeCollection<V> values = new CompositeCollection<V>();\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            values.addComposited(composite[i].values());\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Checks if this Map equals another as per the Map specification.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if the maps are equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof Map) {\n+            Map<?, ?> map = (Map<?, ?>) obj;\n+            return (this.entrySet().equals(map.entrySet()));\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for the Map as per the Map specification.\n+     */\n+    @Override\n+    public int hashCode() {\n+        int code = 0;\n+        for (Map.Entry<K, V> entry : entrySet()) {\n+            code += entry.hashCode();\n+        }\n+        return code;\n+    }\n+\n+    /**\n+     * This interface allows definition for all of the indeterminate\n+     * mutators in a CompositeMap, as well as providing a hook for\n+     * callbacks on key collisions.\n+     */\n+    public static interface MapMutator<K, V> extends Serializable {\n+        /**\n+         * Called when adding a new Composited Map results in a\n+         * key collision.\n+         *\n+         * @param composite  the CompositeMap with the collision\n+         * @param existing  the Map already in the composite which contains the\n+         *        offending key\n+         * @param added  the Map being added\n+         * @param intersect  the intersection of the keysets of the existing and added maps\n+         */\n+        public void resolveCollision(CompositeMap<K, V> composite, Map<K, V> existing,\n+                Map<K, V> added, Collection<K> intersect);\n+\n+        /**\n+         * Called when the CompositeMap.put() method is invoked.\n+         *\n+         * @param map  the CompositeMap which is being modified\n+         * @param composited  array of Maps in the CompositeMap being modified\n+         * @param key  key with which the specified value is to be associated.\n+         * @param value  value to be associated with the specified key.\n+         * @return previous value associated with specified key, or <tt>null</tt>\n+         *         if there was no mapping for key.  A <tt>null</tt> return can\n+         *         also indicate that the map previously associated <tt>null</tt>\n+         *         with the specified key, if the implementation supports\n+         *         <tt>null</tt> values.\n+         *\n+         * @throws UnsupportedOperationException if not defined\n+         * @throws ClassCastException if the class of the specified key or value\n+         *            prevents it from being stored in this map.\n+         * @throws IllegalArgumentException if some aspect of this key or value\n+         *            prevents it from being stored in this map.\n+         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         *            keys or values, and the specified key or value is\n+         *            <tt>null</tt>.\n+         */\n+        public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, V value);\n+\n+        /**\n+         * Called when the CompositeMap.putAll() method is invoked.\n+         *\n+         * @param map  the CompositeMap which is being modified\n+         * @param composited  array of Maps in the CompositeMap being modified\n+         * @param mapToAdd  Mappings to be stored in this CompositeMap\n+         *\n+         * @throws UnsupportedOperationException if not defined\n+         * @throws ClassCastException if the class of the specified key or value\n+         *            prevents it from being stored in this map.\n+         * @throws IllegalArgumentException if some aspect of this key or value\n+         *            prevents it from being stored in this map.\n+         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         *            keys or values, and the specified key or value is\n+         *            <tt>null</tt>.\n+         */\n+        public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited,\n+                Map<? extends K, ? extends V> mapToAdd);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/DefaultedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.functors.ConstantTransformer;\n+import org.apache.commons.collections.functors.FactoryTransformer;\n+\n+/**\n+ * Decorates another <code>Map</code> returning a default value if the map\n+ * does not contain the requested key.\n+ * <p>\n+ * When the {@link #get(Object)} method is called with a key that does not\n+ * exist in the map, this map will return the default value specified in\n+ * the constructor/factory. Only the get method is altered, so the\n+ * {@link Map#containsKey(Object)} can be used to determine if a key really\n+ * is in the map or not.\n+ * <p>\n+ * The defaulted value is not added to the map.\n+ * Compare this behaviour with {@link LazyMap}, which does add the value\n+ * to the map (via a Transformer).\n+ * <p>\n+ * For instance:\n+ * <pre>\n+ * Map map = new DefaultedMap(\"NULL\");\n+ * Object obj = map.get(\"Surname\");\n+ * // obj == \"NULL\"\n+ * </pre>\n+ * After the above code is executed the map is still empty.\n+ * <p>\n+ * <strong>Note that DefaultedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.2\n+ * @version $Revision: 1.7 $ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Rafael U.C. Afonso\n+ * @see LazyMap\n+ */\n+public class DefaultedMap<K, V> extends AbstractMapDecorator<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 19698628745827L;\n+\n+    /** The transformer to use if the map does not contain a key */\n+    private final Transformer<? super K, ? extends V> value;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create a defaulting map.\n+     * <p>\n+     * The value specified is returned when a missing key is found.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param defaultValue  the default value to return when the key is not found\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> Map<K, V> defaultedMap(Map<K, V> map, V defaultValue) {\n+        return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n+    }\n+\n+    /**\n+     * Factory method to create a defaulting map.\n+     * <p>\n+     * The factory specified is called when a missing key is found.\n+     * The result will be returned as the result of the map get(key) method.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use to create entries, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> IterableMap<K, V> defaultedMap(Map<K, V> map, Factory<? extends V> factory) {\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n+    }\n+\n+    /**\n+     * Factory method to create a defaulting map.\n+     * <p>\n+     * The transformer specified is called when a missing key is found.\n+     * The key is passed to the transformer as the input, and the result\n+     * will be returned as the result of the map get(key) method.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param transformer  the transformer to use as a factory to create entries, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> Map<K, V> defaultedMap(Map<K, V> map, Transformer<? super K, ? extends V> transformer) {\n+        if (transformer == null) {\n+           throw new IllegalArgumentException(\"Transformer must not be null\");\n+       }\n+       return new DefaultedMap<K, V>(map, transformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty <code>DefaultedMap</code> that decorates\n+     * a <code>HashMap</code>.\n+     * <p>\n+     * The object passed in will be returned by the map whenever an\n+     * unknown key is requested.\n+     * \n+     * @param defaultValue  the default value to return when the key is not found\n+     */\n+    public DefaultedMap(V defaultValue) {\n+        this(ConstantTransformer.constantTransformer(defaultValue));\n+    }\n+\n+    /**\n+     * Constructs a new empty <code>DefaultedMap</code> that decorates\n+     * a <code>HashMap</code>.\n+     * <p>\n+     * @param defaultValueTransformer transformer to use to generate missing values.\n+     */\n+    public DefaultedMap(Transformer<? super K, ? extends V> defaultValueTransformer) {\n+        this(new HashMap<K, V>(), defaultValueTransformer);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param value  the value to use\n+     * @throws IllegalArgumentException if map or transformer is null\n+     */\n+    protected DefaultedMap(Map<K, V> map, Transformer<? super K, ? extends V> defaultValueTransformer) {\n+        super(map);\n+        this.value = defaultValueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V get(Object key) {\n+        // create value for key if key is not currently in the map\n+        if (map.containsKey(key) == false) {\n+            return value.transform((K) key);\n+        }\n+        return map.get(key);\n+    }\n+\n+    // no need to wrap keySet, entrySet or values as they are views of\n+    // existing map entries - you can't do a map-style get on them.\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/EntrySetToMapIteratorAdapter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * Adapts a Map entrySet to the MapIterator interface.\n+ *\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matt Benson\n+ */\n+public class EntrySetToMapIteratorAdapter<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+    /** The adapted Map entry Set. */\n+    protected Set<Map.Entry<K, V>> entrySet;\n+\n+    /** The resettable iterator in use. */\n+    protected transient Iterator<Map.Entry<K, V>> iterator;\n+\n+    /** The currently positioned Map entry. */\n+    protected transient Map.Entry<K, V> entry;\n+\n+    /**\n+     * Create a new EntrySetToMapIteratorAdapter.\n+     */\n+    public EntrySetToMapIteratorAdapter(Set<Map.Entry<K, V>> entrySet) {\n+        this.entrySet = entrySet;\n+        reset();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K getKey() {\n+        return current().getKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V getValue() {\n+        return current().getValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V setValue(V value) {\n+        return current().setValue(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K next() {\n+        entry = iterator.next();\n+        return getKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized void reset() {\n+        iterator = entrySet.iterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void remove() {\n+        iterator.remove();\n+        entry = null;\n+    }\n+\n+    /**\n+     * Get the currently active entry.\n+     * @return Map.Entry<K, V>\n+     */\n+    protected synchronized Map.Entry<K, V> current() { \n+        if (entry == null) {\n+            throw new IllegalStateException();\n+        }\n+        return entry;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/FixedSizeMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>Map</code> to fix the size, preventing add/remove.\n+ * <p>\n+ * Any action that would change the size of the map is disallowed.\n+ * The put method is allowed to change the value associated with an existing\n+ * key however.\n+ * <p>\n+ * If trying to remove or clear the map, an UnsupportedOperationException is\n+ * thrown. If trying to put a new mapping into the map, an \n+ * IllegalArgumentException is thrown. This is because the put method can \n+ * succeed if the mapping's key already exists in the map, so the put method\n+ * is not always unsupported.\n+ * <p>\n+ * <strong>Note that FixedSizeMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class FixedSizeMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements Map<K, V>, BoundedMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7450927208116179316L;\n+\n+    /**\n+     * Factory method to create a fixed size map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> IterableMap<K, V> fixedSizeMap(Map<K, V> map) {\n+        return new FixedSizeMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected FixedSizeMap(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(K key, V value) {\n+        if (map.containsKey(key) == false) {\n+            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+        }\n+        return map.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        for (K key : mapToCopy.keySet()) {\n+            if (!containsKey(key)) {\n+                throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+            }\n+        }\n+        map.putAll(mapToCopy);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = map.entrySet();\n+        // unmodifiable set will still allow modification via Map.Entry objects\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        Set<K> set = map.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        Collection<V> coll = map.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    public int maxSize() {\n+        return size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>SortedMap</code> to fix the size blocking add/remove.\n+ * <p>\n+ * Any action that would change the size of the map is disallowed.\n+ * The put method is allowed to change the value associated with an existing\n+ * key however.\n+ * <p>\n+ * If trying to remove or clear the map, an UnsupportedOperationException is\n+ * thrown. If trying to put a new mapping into the map, an \n+ * IllegalArgumentException is thrown. This is because the put method can \n+ * succeed if the mapping's key already exists in the map, so the put method\n+ * is not always unsupported.\n+ * <p>\n+ * <strong>Note that FixedSizeSortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class FixedSizeSortedMap<K, V>\n+        extends AbstractSortedMapDecorator<K, V>\n+        implements SortedMap<K, V>, BoundedMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3126019624511683653L;\n+\n+    /**\n+     * Factory method to create a fixed size sorted map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(SortedMap<K, V> map) {\n+        return new FixedSizeSortedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected FixedSizeSortedMap(SortedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(K key, V value) {\n+        if (map.containsKey(key) == false) {\n+            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+        }\n+        return map.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        if (CollectionUtils.isSubCollection(mapToCopy.keySet(), keySet())) {\n+            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+        }\n+        map.putAll(mapToCopy);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return UnmodifiableSet.unmodifiableSet(map.entrySet());\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        return UnmodifiableSet.unmodifiableSet(map.keySet());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        return UnmodifiableCollection.unmodifiableCollection(map.values());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().subMap(fromKey, toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().headMap(toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().tailMap(fromKey));\n+    }\n+\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    public int maxSize() {\n+        return size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/Flat3Map.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.EmptyMapIterator;\n+\n+/**\n+ * A <code>Map</code> implementation that stores data in simple fields until\n+ * the size is greater than 3.\n+ * <p>\n+ * This map is designed for performance and can outstrip HashMap.\n+ * It also has good garbage collection characteristics.\n+ * <ul>\n+ * <li>Optimised for operation at size 3 or less.\n+ * <li>Still works well once size 3 exceeded.\n+ * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n+ * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n+ * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n+ * </ul>\n+ * The design uses two distinct modes of operation - flat and delegate.\n+ * While the map is size 3 or less, operations map straight onto fields using\n+ * switch statements. Once size 4 is reached, the map switches to delegate mode\n+ * and only switches back when cleared. In delegate mode, all operations are\n+ * forwarded straight to a HashMap resulting in the 5% performance loss.\n+ * <p>\n+ * The performance gains on puts are due to not needing to create a Map Entry\n+ * object. This is a large saving not only in performance but in garbage collection.\n+ * <p>\n+ * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n+ * This is because it contains no complex objects or arrays which slow the progress.\n+ * <p>\n+ * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n+ * <p>\n+ * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class Flat3Map<K, V> implements IterableMap<K, V>, Serializable, Cloneable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -6701087419741928296L;\n+\n+    /** The size of the map, used while in flat mode */\n+    private transient int size;\n+    /** Hash, used while in flat mode */\n+    private transient int hash1;\n+    /** Hash, used while in flat mode */\n+    private transient int hash2;\n+    /** Hash, used while in flat mode */\n+    private transient int hash3;\n+    /** Key, used while in flat mode */\n+    private transient K key1;\n+    /** Key, used while in flat mode */\n+    private transient K key2;\n+    /** Key, used while in flat mode */\n+    private transient K key3;\n+    /** Value, used while in flat mode */\n+    private transient V value1;\n+    /** Value, used while in flat mode */\n+    private transient V value2;\n+    /** Value, used while in flat mode */\n+    private transient V value3;\n+    /** Map, used while in delegate mode */\n+    private transient AbstractHashedMap<K, V> delegateMap;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public Flat3Map() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public Flat3Map(Map<? extends K, ? extends V> map) {\n+        super();\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(Object key) {\n+        if (delegateMap != null) {\n+            return delegateMap.get(key);\n+        }\n+        if (key == null) {\n+            switch (size) {\n+                // drop through\n+                case 3:\n+                    if (key3 == null) return value3;\n+                case 2:\n+                    if (key2 == null) return value2;\n+                case 1:\n+                    if (key1 == null) return value1;\n+            }\n+        } else {\n+            if (size > 0) {\n+                int hashCode = key.hashCode();\n+                switch (size) {\n+                    // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) return value3;\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) return value2;\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) return value1;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map.\n+     *\n+     * @return the size\n+     */\n+    public int size() {\n+        if (delegateMap != null) {\n+            return delegateMap.size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     *\n+     * @return true if the map is currently size zero\n+     */\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     *\n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        if (delegateMap != null) {\n+            return delegateMap.containsKey(key);\n+        }\n+        if (key == null) {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (key3 == null) return true;\n+                case 2:\n+                    if (key2 == null) return true;\n+                case 1:\n+                    if (key1 == null) return true;\n+            }\n+        } else {\n+            if (size > 0) {\n+                int hashCode = key.hashCode();\n+                switch (size) {  // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) return true;\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) return true;\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsValue(Object value) {\n+        if (delegateMap != null) {\n+            return delegateMap.containsValue(value);\n+        }\n+        if (value == null) {  // drop through\n+            switch (size) {\n+                case 3:\n+                    if (value3 == null) return true;\n+                case 2:\n+                    if (value2 == null) return true;\n+                case 1:\n+                    if (value1 == null) return true;\n+            }\n+        } else {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (value.equals(value3)) return true;\n+                case 2:\n+                    if (value.equals(value2)) return true;\n+                case 1:\n+                    if (value.equals(value1)) return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map.\n+     *\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    public V put(K key, V value) {\n+        if (delegateMap != null) {\n+            return delegateMap.put(key, value);\n+        }\n+        // change existing mapping\n+        if (key == null) {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (key3 == null) {\n+                        V old = value3;\n+                        value3 = value;\n+                        return old;\n+                    }\n+                case 2:\n+                    if (key2 == null) {\n+                        V old = value2;\n+                        value2 = value;\n+                        return old;\n+                    }\n+                case 1:\n+                    if (key1 == null) {\n+                        V old = value1;\n+                        value1 = value;\n+                        return old;\n+                    }\n+            }\n+        } else {\n+            if (size > 0) {\n+                int hashCode = key.hashCode();\n+                switch (size) {  // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            V old = value3;\n+                            value3 = value;\n+                            return old;\n+                        }\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            V old = value2;\n+                            value2 = value;\n+                            return old;\n+                        }\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            V old = value1;\n+                            value1 = value;\n+                            return old;\n+                        }\n+                }\n+            }\n+        }\n+\n+        // add new mapping\n+        switch (size) {\n+            default:\n+                convertToMap();\n+                delegateMap.put(key, value);\n+                return null;\n+            case 2:\n+                hash3 = (key == null ? 0 : key.hashCode());\n+                key3 = key;\n+                value3 = value;\n+                break;\n+            case 1:\n+                hash2 = (key == null ? 0 : key.hashCode());\n+                key2 = key;\n+                value2 = value;\n+                break;\n+            case 0:\n+                hash1 = (key == null ? 0 : key.hashCode());\n+                key1 = key;\n+                value1 = value;\n+                break;\n+        }\n+        size++;\n+        return null;\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     *\n+     * @param map  the map to add\n+     * @throws NullPointerException if the map is null\n+     */\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        int size = map.size();\n+        if (size == 0) {\n+            return;\n+        }\n+        if (delegateMap != null) {\n+            delegateMap.putAll(map);\n+            return;\n+        }\n+        if (size < 4) {\n+            for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        } else {\n+            convertToMap();\n+            delegateMap.putAll(map);\n+        }\n+    }\n+\n+    /**\n+     * Converts the flat map data to a map.\n+     */\n+    private void convertToMap() {\n+        delegateMap = createDelegateMap();\n+        switch (size) {  // drop through\n+            case 3:\n+                delegateMap.put(key3, value3);\n+            case 2:\n+                delegateMap.put(key2, value2);\n+            case 1:\n+                delegateMap.put(key1, value1);\n+        }\n+\n+        size = 0;\n+        hash1 = hash2 = hash3 = 0;\n+        key1 = key2 = key3 = null;\n+        value1 = value2 = value3 = null;\n+    }\n+\n+    /**\n+     * Create an instance of the map used for storage when in delegation mode.\n+     * <p>\n+     * This can be overridden by subclasses to provide a different map implementation.\n+     * Not every AbstractHashedMap is suitable, identity and reference based maps\n+     * would be poor choices.\n+     *\n+     * @return a new AbstractHashedMap or subclass\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractHashedMap<K, V> createDelegateMap() {\n+        return new HashedMap<K, V>();\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     *\n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(Object key) {\n+        if (delegateMap != null) {\n+            return delegateMap.remove(key);\n+        }\n+        if (size == 0) {\n+            return null;\n+        }\n+        if (key == null) {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (key3 == null) {\n+                        V old = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n+                        return old;\n+                    }\n+                    if (key2 == null) {\n+                        V old = value2;\n+                        hash2 = hash3;\n+                        key2 = key3;\n+                        value2 = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n+                        return old;\n+                    }\n+                    if (key1 == null) {\n+                        V old = value1;\n+                        hash1 = hash3;\n+                        key1 = key3;\n+                        value1 = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n+                        return old;\n+                    }\n+                    return null;\n+                case 2:\n+                    if (key2 == null) {\n+                        V old = value2;\n+                        hash2 = 0;\n+                        key2 = null;\n+                        value2 = null;\n+                        size = 1;\n+                        return old;\n+                    }\n+                    if (key1 == null) {\n+                        V old = value1;\n+                        hash1 = hash2;\n+                        key1 = key2;\n+                        value1 = value2;\n+                        hash2 = 0;\n+                        key2 = null;\n+                        value2 = null;\n+                        size = 1;\n+                        return old;\n+                    }\n+                    return null;\n+                case 1:\n+                    if (key1 == null) {\n+                        V old = value1;\n+                        hash1 = 0;\n+                        key1 = null;\n+                        value1 = null;\n+                        size = 0;\n+                        return old;\n+                    }\n+            }\n+        } else {\n+            if (size > 0) {\n+                int hashCode = key.hashCode();\n+                switch (size) {  // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            V old = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n+                            return old;\n+                        }\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            V old = value2;\n+                            hash2 = hash3;\n+                            key2 = key3;\n+                            value2 = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n+                            return old;\n+                        }\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            V old = value1;\n+                            hash1 = hash3;\n+                            key1 = key3;\n+                            value1 = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n+                            return old;\n+                        }\n+                        return null;\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            V old = value2;\n+                            hash2 = 0;\n+                            key2 = null;\n+                            value2 = null;\n+                            size = 1;\n+                            return old;\n+                        }\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            V old = value1;\n+                            hash1 = hash2;\n+                            key1 = key2;\n+                            value1 = value2;\n+                            hash2 = 0;\n+                            key2 = null;\n+                            value2 = null;\n+                            size = 1;\n+                            return old;\n+                        }\n+                        return null;\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            V old = value1;\n+                            hash1 = 0;\n+                            key1 = null;\n+                            value1 = null;\n+                            size = 0;\n+                            return old;\n+                        }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    public void clear() {\n+        if (delegateMap != null) {\n+            delegateMap.clear();  // should aid gc\n+            delegateMap = null;  // switch back to flat mode\n+        } else {\n+            size = 0;\n+            hash1 = hash2 = hash3 = 0;\n+            key1 = key2 = key3 = null;\n+            value1 = value2 = value3 = null;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Map Entry object.\n+     *\n+     * @return the map iterator\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        if (delegateMap != null) {\n+            return delegateMap.mapIterator();\n+        }\n+        if (size == 0) {\n+            return EmptyMapIterator.<K, V>emptyMapIterator();\n+        }\n+        return new FlatMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * FlatMapIterator\n+     */\n+    static class FlatMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+        private final Flat3Map<K, V> parent;\n+        private int nextIndex = 0;\n+        private boolean canRemove = false;\n+\n+        FlatMapIterator(Flat3Map<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        public boolean hasNext() {\n+            return (nextIndex < parent.size);\n+        }\n+\n+        public K next() {\n+            if (hasNext() == false) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            canRemove = true;\n+            nextIndex++;\n+            return getKey();\n+        }\n+\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            parent.remove(getKey());\n+            nextIndex--;\n+            canRemove = false;\n+        }\n+\n+        public K getKey() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.key3;\n+                case 2:\n+                    return parent.key2;\n+                case 1:\n+                    return parent.key1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V getValue() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.value3;\n+                case 2:\n+                    return parent.value2;\n+                case 1:\n+                    return parent.value1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V setValue(V value) {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            V old = getValue();\n+            switch (nextIndex) {\n+                case 3:\n+                    parent.value3 = value;\n+                    break;\n+                case 2:\n+                    parent.value2 = value;\n+                    break;\n+                case 1:\n+                    parent.value1 = value;\n+                    break;\n+            }\n+            return old;\n+        }\n+\n+        public void reset() {\n+            nextIndex = 0;\n+            canRemove = false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (canRemove) {\n+                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made to the view affect this map.\n+     * The Map Entry is not an independent object and changes as the\n+     * iterator progresses.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     *\n+     * @return the entrySet view\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (delegateMap != null) {\n+            return delegateMap.entrySet();\n+        }\n+        return new EntrySet<K, V>(this);\n+    }\n+\n+    /**\n+     * EntrySet\n+     */\n+    static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        private final Flat3Map<K, V> parent;\n+\n+        EntrySet(Flat3Map<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            Object key = entry.getKey();\n+            boolean result = parent.containsKey(key);\n+            parent.remove(key);\n+            return result;\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.entrySet().iterator();\n+            }\n+            if (parent.size() == 0) {\n+                return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n+            }\n+            return new EntrySetIterator<K, V>(parent);\n+        }\n+    }\n+\n+    static abstract class EntryIterator<K, V> implements Map.Entry<K, V> {\n+        private final Flat3Map<K, V> parent;\n+        private int nextIndex = 0;\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Create a new Flat3Map.EntryIterator.\n+         */\n+        public EntryIterator(Flat3Map<K, V> parent) {\n+            this.parent = parent;\n+        }\n+\n+        public boolean hasNext() {\n+            return (nextIndex < parent.size);\n+        }\n+\n+        public Map.Entry<K, V> nextEntry() {\n+            if (hasNext() == false) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            canRemove = true;\n+            nextIndex++;\n+            return this;\n+        }\n+\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            parent.remove(getKey());\n+            nextIndex--;\n+            canRemove = false;\n+        }\n+\n+        public K getKey() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.key3;\n+                case 2:\n+                    return parent.key2;\n+                case 1:\n+                    return parent.key1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V getValue() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.value3;\n+                case 2:\n+                    return parent.value2;\n+                case 1:\n+                    return parent.value1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V setValue(V value) {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            V old = getValue();\n+            switch (nextIndex) {\n+                case 3:\n+                    parent.value3 = value;\n+                    break;\n+                case 2:\n+                    parent.value2 = value;\n+                    break;\n+                case 1:\n+                    parent.value1 = value;\n+                    break;\n+            }\n+            return old;\n+        }\n+    }\n+\n+    /**\n+     * EntrySetIterator and MapEntry\n+     */\n+    static class EntrySetIterator<K, V> extends EntryIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        EntrySetIterator(Flat3Map<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (canRemove == false) {\n+                return false;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            Object key = getKey();\n+            Object value = getValue();\n+            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n+                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (canRemove == false) {\n+                return 0;\n+            }\n+            Object key = getKey();\n+            Object value = getValue();\n+            return (key == null ? 0 : key.hashCode()) ^\n+                   (value == null ? 0 : value.hashCode());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (canRemove) {\n+                return getKey() + \"=\" + getValue();\n+            }\n+            return \"\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     *\n+     * @return the keySet view\n+     */\n+    public Set<K> keySet() {\n+        if (delegateMap != null) {\n+            return delegateMap.keySet();\n+        }\n+        return new KeySet<K>(this);\n+    }\n+\n+    /**\n+     * KeySet\n+     */\n+    static class KeySet<K> extends AbstractSet<K> {\n+        private final Flat3Map<K, ?> parent;\n+\n+        KeySet(Flat3Map<K, ?> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(Object key) {\n+            return parent.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean remove(Object key) {\n+            boolean result = parent.containsKey(key);\n+            parent.remove(key);\n+            return result;\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.keySet().iterator();\n+            }\n+            if (parent.size() == 0) {\n+                return EmptyIterator.<K>emptyIterator();\n+            }\n+            return new KeySetIterator<K>(parent);\n+        }\n+    }\n+\n+    /**\n+     * KeySetIterator\n+     */\n+    static class KeySetIterator<K> extends EntryIterator<K, Object> implements Iterator<K>{\n+\n+        @SuppressWarnings(\"unchecked\")\n+        KeySetIterator(Flat3Map<K, ?> parent) {\n+            super((Flat3Map<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            nextEntry();\n+            return getKey();\n+        }\n+    }\n+\n+    /**\n+     * Gets the values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     *\n+     * @return the values view\n+     */\n+    public Collection<V> values() {\n+        if (delegateMap != null) {\n+            return delegateMap.values();\n+        }\n+        return new Values<V>(this);\n+    }\n+\n+    /**\n+     * Values\n+     */\n+    static class Values<V> extends AbstractCollection<V> {\n+        private final Flat3Map<?, V> parent;\n+\n+        Values(Flat3Map<?, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(Object value) {\n+            return parent.containsValue(value);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.values().iterator();\n+            }\n+            if (parent.size() == 0) {\n+                return EmptyIterator.<V>emptyIterator();\n+            }\n+            return new ValuesIterator<V>(parent);\n+        }\n+    }\n+\n+    /**\n+     * ValuesIterator\n+     */\n+    static class ValuesIterator<V> extends EntryIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ValuesIterator(Flat3Map<?, V> parent) {\n+            super((Flat3Map<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            nextEntry();\n+            return getValue();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(size());\n+        for (MapIterator<?, ?> it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());  // key\n+            out.writeObject(it.getValue());  // value\n+        }\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        int count = in.readInt();\n+        if (count > 3) {\n+            delegateMap = createDelegateMap();\n+        }\n+        for (int i = count; i > 0; i--) {\n+            put((K) in.readObject(), (V) in.readObject());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     * @since Commons Collections 3.1\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Flat3Map<K, V> clone() {\n+        try {\n+            Flat3Map<K, V> cloned = (Flat3Map<K, V>) super.clone();\n+            if (cloned.delegateMap != null) {\n+                cloned.delegateMap = cloned.delegateMap.clone();\n+            }\n+            return cloned;\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Compares this map with another.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (delegateMap != null) {\n+            return delegateMap.equals(obj);\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map<?, ?> other = (Map<?, ?>) obj;\n+        if (size != other.size()) {\n+            return false;\n+        }\n+        if (size > 0) {\n+            Object otherValue = null;\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (other.containsKey(key3) == false) {\n+                        return false;\n+                    }\n+                    otherValue = other.get(key3);\n+                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n+                        return false;\n+                    }\n+                case 2:\n+                    if (other.containsKey(key2) == false) {\n+                        return false;\n+                    }\n+                    otherValue = other.get(key2);\n+                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n+                        return false;\n+                    }\n+                case 1:\n+                    if (other.containsKey(key1) == false) {\n+                        return false;\n+                    }\n+                    otherValue = other.get(key1);\n+                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n+                        return false;\n+                    }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     *\n+     * @return the hash code defined in the Map interface\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (delegateMap != null) {\n+            return delegateMap.hashCode();\n+        }\n+        int total = 0;\n+        switch (size) {  // drop through\n+            case 3:\n+                total += (hash3 ^ (value3 == null ? 0 : value3.hashCode()));\n+            case 2:\n+                total += (hash2 ^ (value2 == null ? 0 : value2.hashCode()));\n+            case 1:\n+                total += (hash1 ^ (value1 == null ? 0 : value1.hashCode()));\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     *\n+     * @return a string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        if (delegateMap != null) {\n+            return delegateMap.toString();\n+        }\n+        if (size == 0) {\n+            return \"{}\";\n+        }\n+        StringBuilder buf = new StringBuilder(128);\n+        buf.append('{');\n+        switch (size) {  // drop through\n+            case 3:\n+                buf.append((key3 == this ? \"(this Map)\" : key3));\n+                buf.append('=');\n+                buf.append((value3 == this ? \"(this Map)\" : value3));\n+                buf.append(',');\n+            case 2:\n+                buf.append((key2 == this ? \"(this Map)\" : key2));\n+                buf.append('=');\n+                buf.append((value2 == this ? \"(this Map)\" : value2));\n+                buf.append(',');\n+            case 1:\n+                buf.append((key1 == this ? \"(this Map)\" : key1));\n+                buf.append('=');\n+                buf.append((value1 == this ? \"(this Map)\" : value1));\n+        }\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/HashedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * A <code>Map</code> implementation that is a general purpose alternative\n+ * to <code>HashMap</code>.\n+ * <p>\n+ * This implementation improves on the JDK1.4 HashMap by adding the\n+ * {@link org.apache.commons.collections.MapIterator MapIterator}\n+ * functionality and many methods for subclassing.\n+ * <p>\n+ * <strong>Note that HashedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class HashedMap<K, V>\n+        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -1788199231038721040L;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public HashedMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public HashedMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public HashedMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public HashedMap(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public HashedMap<K, V> clone() {\n+        return (HashedMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/IdentityMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * A <code>Map</code> implementation that matches keys and values based\n+ * on <code>==</code> not <code>equals()</code>.\n+ * <p>\n+ * <strong>This map will violate the detail of various Map and map view contracts.</note>\n+ * As a general rule, don't compare this map to other maps. In particular, you can't\n+ * use decorators like {@link ListOrderedMap} on it, which silently assume that these\n+ * contracts are fulfilled.\n+ * <p>\n+ * <strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author java util HashMap\n+ * @author Stephen Colebourne\n+ */\n+public class IdentityMap<K, V>\n+        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = 2028493495224302329L;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public IdentityMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public IdentityMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public IdentityMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public IdentityMap(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hash code for the key specified.\n+     * This implementation uses the identity hash code.\n+     *\n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    @Override\n+    protected int hash(Object key) {\n+        return System.identityHashCode(key);\n+    }\n+\n+    /**\n+     * Compares two keys for equals.\n+     * This implementation uses <code>==</code>.\n+     *\n+     * @param key1  the first key to compare\n+     * @param key2  the second key to compare\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        return (key1 == key2);\n+    }\n+\n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses <code>==</code>.\n+     *\n+     * @param value1  the first value to compare\n+     * @param value2  the second value to compare\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualValue(Object value1, Object value2) {\n+        return (value1 == value2);\n+    }\n+\n+    /**\n+     * Creates an entry to store the data.\n+     * This implementation creates an IdentityEntry instance.\n+     *\n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    @Override\n+    protected IdentityEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        return new IdentityEntry<K, V>(next, hashCode, key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * HashEntry\n+     */\n+    protected static class IdentityEntry<K, V> extends HashEntry<K, V> {\n+\n+        protected IdentityEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+            super(next, hashCode, key, value);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            return\n+                (getKey() == other.getKey()) &&\n+                (getValue() == other.getValue());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(getKey()) ^\n+                   System.identityHashCode(getValue());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public IdentityMap<K, V> clone() {\n+        return (IdentityMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/LRUMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.MapIterator;\n+\n+/**\n+ * A <code>Map</code> implementation with a fixed maximum size which removes\n+ * the least recently used entry if an entry is added when full.\n+ * <p>\n+ * The least recently used algorithm works on the get and put operations only.\n+ * Iteration of any kind, including setting the value by iteration, does not\n+ * change the order. Queries such as containsKey and containsValue or access\n+ * via views also do not change the order.\n+ * <p>\n+ * A somewhat subtle ramification of the least recently used\n+ * algorithm is that calls to {@link #get(Object)} stand a very good chance\n+ * of modifying the map's iteration order and thus invalidating any\n+ * iterators currently in use.  It is therefore suggested that iterations\n+ * over an {@link LRUMap} instance access entry values only through a\n+ * {@link MapIterator} or {@link #entrySet()} iterator.\n+ * <p>\n+ * The map implements <code>OrderedMap</code> and entries may be queried using\n+ * the bidirectional <code>OrderedMapIterator</code>. The order returned is\n+ * least recently used to most recently used. Iterators from map views can\n+ * also be cast to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * <strong>Note that LRUMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * <code>NullPointerException</code>'s when accessed by concurrent threads.\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v1.0)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ * @author Mike Pettypiece\n+ * @author Mario Ivankovits\n+ */\n+public class LRUMap<K, V>\n+        extends AbstractLinkedMap<K, V> implements BoundedMap<K, V>, Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -612114643488955218L;\n+    /** Default maximum size */\n+    protected static final int DEFAULT_MAX_SIZE = 100;\n+\n+    /** Maximum size */\n+    private transient int maxSize;\n+    /** Scan behaviour */\n+    private boolean scanUntilRemovable;\n+\n+    /**\n+     * Constructs a new empty map with a maximum size of 100.\n+     */\n+    public LRUMap() {\n+        this(DEFAULT_MAX_SIZE, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified maximum size.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     */\n+    public LRUMap(int maxSize) {\n+        this(maxSize, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified maximum size.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @since Commons Collections 3.1\n+     */\n+    public LRUMap(int maxSize, boolean scanUntilRemovable) {\n+        this(maxSize, DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public LRUMap(int maxSize, float loadFactor) {\n+        this(maxSize, loadFactor, false);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param maxSize  the maximum size of the ma\n+     * @param loadFactor  the load factor\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     * @since Commons Collections 3.1\n+     */\n+    public LRUMap(int maxSize, float loadFactor, boolean scanUntilRemovable) {\n+        super((maxSize < 1 ? DEFAULT_CAPACITY : maxSize), loadFactor);\n+        if (maxSize < 1) {\n+            throw new IllegalArgumentException(\"LRUMap max size must be greater than 0\");\n+        }\n+        this.maxSize = maxSize;\n+        this.scanUntilRemovable = scanUntilRemovable;\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p>\n+     * The maximum size is set from the map's size.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     */\n+    public LRUMap(Map<K, V> map) {\n+        this(map, false);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p/>\n+     * The maximum size is set from the map's size.\n+     *\n+     * @param map  the map to copy\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @since Commons Collections 3.1\n+     */\n+    public LRUMap(Map<K, V> map, boolean scanUntilRemovable) {\n+        this(map.size(), DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * <p>\n+     * This operation changes the position of the key in the map to the\n+     * most recently used position (first).\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    @Override\n+    public V get(Object key) {\n+        LinkEntry<K, V> entry = getEntry(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        moveToMRU(entry);\n+        return entry.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Moves an entry to the MRU position at the end of the list.\n+     * <p>\n+     * This implementation moves the updated entry to the end of the list.\n+     *\n+     * @param entry  the entry to update\n+     */\n+    protected void moveToMRU(LinkEntry<K, V> entry) {\n+        if (entry.after != header) {\n+            modCount++;\n+            // remove\n+            if(entry.before == null) {\n+                throw new IllegalStateException(\"Entry.before is null.\" + \n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+            }\n+            entry.before.after = entry.after;\n+            entry.after.before = entry.before;\n+            // add first\n+            entry.after = header;\n+            entry.before = header.before;\n+            header.before.after = entry;\n+            header.before = entry;\n+        } else if (entry == header) {\n+            throw new IllegalStateException(\"Can't move header to MRU\" +\n+                \" (please report this to dev@commons.apache.org)\");\n+        }\n+    }\n+\n+    /**\n+     * Updates an existing key-value mapping.\n+     * <p>\n+     * This implementation moves the updated entry to the top of the list\n+     * using {@link #moveToMRU(AbstractLinkedMap.LinkEntry)}.\n+     *\n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     */\n+    @Override\n+    protected void updateEntry(HashEntry<K, V> entry, V newValue) {\n+        moveToMRU((LinkEntry<K, V>) entry);  // handles modCount\n+        entry.setValue(newValue);\n+    }\n+\n+    /**\n+     * Adds a new key-value mapping into this map.\n+     * <p>\n+     * This implementation checks the LRU size and determines whether to\n+     * discard an entry or not using {@link #removeLRU(AbstractLinkedMap.LinkEntry)}.\n+     * <p>\n+     * From Commons Collections 3.1 this method uses {@link #isFull()} rather\n+     * than accessing <code>size</code> and <code>maxSize</code> directly.\n+     * It also handles the scanUntilRemovable functionality.\n+     *\n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    @Override\n+    protected void addMapping(int hashIndex, int hashCode, K key, V value) {\n+        if (isFull()) {\n+            LinkEntry<K, V> reuse = header.after;\n+            boolean removeLRUEntry = false;\n+            if (scanUntilRemovable) {\n+                while (reuse != header && reuse != null) {\n+                    if (removeLRU(reuse)) {\n+                        removeLRUEntry = true;\n+                        break;\n+                    }\n+                    reuse = reuse.after;\n+                }\n+                if (reuse == null) {\n+                    throw new IllegalStateException(\n+                        \"Entry.after=null, header.after\" + header.after + \" header.before\" + header.before +\n+                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                        \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                        \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+                }\n+            } else {\n+                removeLRUEntry = removeLRU(reuse);\n+            }\n+\n+            if (removeLRUEntry) {\n+                if (reuse == null) {\n+                    throw new IllegalStateException(\n+                        \"reuse=null, header.after=\" + header.after + \" header.before\" + header.before +\n+                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                        \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                        \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+                }\n+                reuseMapping(reuse, hashIndex, hashCode, key, value);\n+            } else {\n+                super.addMapping(hashIndex, hashCode, key, value);\n+            }\n+        } else {\n+            super.addMapping(hashIndex, hashCode, key, value);\n+        }\n+    }\n+\n+    /**\n+     * Reuses an entry by removing it and moving it to a new place in the map.\n+     * <p>\n+     * This method uses {@link #removeEntry}, {@link #reuseEntry} and {@link #addEntry}.\n+     *\n+     * @param entry  the entry to reuse\n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void reuseMapping(LinkEntry<K, V> entry, int hashIndex, int hashCode, K key, V value) {\n+        // find the entry before the entry specified in the hash table\n+        // remember that the parameters (except the first) refer to the new entry,\n+        // not the old one\n+        try {\n+            int removeIndex = hashIndex(entry.hashCode, data.length);\n+            HashEntry<K, V>[] tmp = data;  // may protect against some sync issues\n+            HashEntry<K, V> loop = tmp[removeIndex];\n+            HashEntry<K, V> previous = null;\n+            while (loop != entry && loop != null) {\n+                previous = loop;\n+                loop = loop.next;\n+            }\n+            if (loop == null) {\n+                throw new IllegalStateException(\n+                    \"Entry.next=null, data[removeIndex]=\" + data[removeIndex] + \" previous=\" + previous +\n+                    \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+            }\n+\n+            // reuse the entry\n+            modCount++;\n+            removeEntry(entry, removeIndex, previous);\n+            reuseEntry(entry, hashIndex, hashCode, key, value);\n+            addEntry(entry, hashIndex);\n+        } catch (NullPointerException ex) {\n+            throw new IllegalStateException(\n+                    \"NPE, entry=\" + entry + \" entryIsHeader=\" + (entry==header) +\n+                    \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+        }\n+    }\n+\n+    /**\n+     * Subclass method to control removal of the least recently used entry from the map.\n+     * <p>\n+     * This method exists for subclasses to override. A subclass may wish to\n+     * provide cleanup of resources when an entry is removed. For example:\n+     * <pre>\n+     * protected boolean removeLRU(LinkEntry entry) {\n+     *   releaseResources(entry.getValue());  // release resources held by entry\n+     *   return true;  // actually delete entry\n+     * }\n+     * </pre>\n+     * <p>\n+     * Alternatively, a subclass may choose to not remove the entry or selectively\n+     * keep certain LRU entries. For example:\n+     * <pre>\n+     * protected boolean removeLRU(LinkEntry entry) {\n+     *   if (entry.getKey().toString().startsWith(\"System.\")) {\n+     *     return false;  // entry not removed from LRUMap\n+     *   } else {\n+     *     return true;  // actually delete entry\n+     *   }\n+     * }\n+     * </pre>\n+     * The effect of returning false is dependent on the scanUntilRemovable flag.\n+     * If the flag is true, the next LRU entry will be passed to this method and so on\n+     * until one returns false and is removed, or every entry in the map has been passed.\n+     * If the scanUntilRemovable flag is false, the map will exceed the maximum size.\n+     * <p>\n+     * NOTE: Commons Collections 3.0 passed the wrong entry to this method.\n+     * This is fixed in version 3.1 onwards.\n+     *\n+     * @param entry  the entry to be removed\n+     */\n+    protected boolean removeLRU(LinkEntry<K, V> entry) {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if this map is full and no new mappings can be added.\n+     *\n+     * @return <code>true</code> if the map is full\n+     */\n+    public boolean isFull() {\n+        return (size >= maxSize);\n+    }\n+\n+    /**\n+     * Gets the maximum size of the map (the bound).\n+     *\n+     * @return the maximum number of elements the map can hold\n+     */\n+    public int maxSize() {\n+        return maxSize;\n+    }\n+\n+    /**\n+     * Whether this LRUMap will scan until a removable entry is found when the\n+     * map is full.\n+     *\n+     * @return true if this map scans\n+     * @since Commons Collections 3.1\n+     */\n+    public boolean isScanUntilRemovable() {\n+        return scanUntilRemovable;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public LRUMap<K, V> clone() {\n+        return (LRUMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+    /**\n+     * Writes the data necessary for <code>put()</code> to work in deserialization.\n+     */\n+    @Override\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        out.writeInt(maxSize);\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Reads the data necessary for <code>put()</code> to work in the superclass.\n+     */\n+    @Override\n+    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        maxSize = in.readInt();\n+        super.doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/LazyMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.functors.FactoryTransformer;\n+\n+/**\n+ * Decorates another <code>Map</code> to create objects in the map on demand.\n+ * <p>\n+ * When the {@link #get(Object)} method is called with a key that does not\n+ * exist in the map, the factory is used to create the object. The created\n+ * object will be added to the map using the requested key.\n+ * <p>\n+ * For instance:\n+ * <pre>\n+ * Factory factory = new Factory() {\n+ *     public Object create() {\n+ *         return new Date();\n+ *     }\n+ * }\n+ * Map lazy = Lazy.map(new HashMap(), factory);\n+ * Object obj = lazy.get(\"NOW\");\n+ * </pre>\n+ *\n+ * After the above code is executed, <code>obj</code> will contain\n+ * a new <code>Date</code> instance. Furthermore, that <code>Date</code>\n+ * instance is mapped to the \"NOW\" key in the map.\n+ * <p>\n+ * <strong>Note that LazyMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class LazyMap<K, V> extends AbstractMapDecorator<K, V> implements Map<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7990956402564206740L;\n+\n+    /** The factory to use to construct elements */\n+    protected final Transformer<? super K, ? extends V> factory;\n+\n+    /**\n+     * Factory method to create a lazily instantiated map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> LazyMap<K, V> lazyMap(Map<K, V> map, Factory< ? extends V> factory) {\n+        return new LazyMap<K,V>(map, factory);\n+    }\n+\n+    /**\n+     * Factory method to create a lazily instantiated map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <V, K> LazyMap<K, V> lazyMap(Map<K, V> map, Transformer<? super K, ? extends V> factory) {\n+        return new LazyMap<K,V>(map, factory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazyMap(Map<K,V> map, Factory<? extends V> factory) {\n+        super(map);\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        this.factory = FactoryTransformer.factoryTransformer(factory);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazyMap(Map<K,V> map, Transformer<? super K, ? extends V> factory) {\n+        super(map);\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        this.factory = factory;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V get(Object key) {\n+        // create value for key if key is not currently in the map\n+        if (map.containsKey(key) == false) {\n+            K castKey = cast(key);\n+            V value = factory.transform(castKey);\n+            map.put(castKey, value);\n+            return value;\n+        }\n+        return map.get(key);\n+    }\n+\n+    /**\n+     * Method just to cast {@link Object}s to K where necessary.  This is done to ensure that the SuppressWarnings does not \n+     * cover other stuff that it shouldn't\n+     * @param key .\n+     * @return the cast key.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private K cast(Object key) {\n+        return (K) key;\n+    }\n+\n+    // no need to wrap keySet, entrySet or values as they are views of\n+    // existing map entries - you can't do a map-style get on them.\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/LazySortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Decorates another <code>SortedMap</code> to create objects in the map on demand.\n+ * <p>\n+ * When the {@link #get(Object)} method is called with a key that does not\n+ * exist in the map, the factory is used to create the object. The created\n+ * object will be added to the map using the requested key.\n+ * <p>\n+ * For instance:\n+ * <pre>\n+ * Factory factory = new Factory() {\n+ *     public Object create() {\n+ *         return new Date();\n+ *     }\n+ * }\n+ * SortedMap lazy = Lazy.sortedMap(new HashMap(), factory);\n+ * Object obj = lazy.get(\"NOW\");\n+ * </pre>\n+ *\n+ * After the above code is executed, <code>obj</code> will contain\n+ * a new <code>Date</code> instance. Furthermore, that <code>Date</code>\n+ * instance is mapped to the \"NOW\" key in the map.\n+ * <p>\n+ * <strong>Note that LazySortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class LazySortedMap<K,V>\n+        extends LazyMap<K,V>\n+        implements SortedMap<K,V> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2715322183617658933L;\n+\n+    /**\n+     * Factory method to create a lazily instantiated sorted map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map, Factory<? extends V> factory) {\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    /**\n+     * Factory method to create a lazily instantiated sorted map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map, Transformer<? super K, ? extends V> factory) {\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazySortedMap(SortedMap<K,V> map, Factory<? extends V> factory) {\n+        super(map, factory);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazySortedMap(SortedMap<K,V> map, Transformer<? super K, ? extends V> factory) {\n+        super(map, factory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K,V> getSortedMap() {\n+        return (SortedMap<K,V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return getSortedMap().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return getSortedMap().lastKey();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return getSortedMap().comparator();\n+    }\n+\n+    public SortedMap<K,V> subMap(K fromKey, K toKey) {\n+        SortedMap<K,V> map = getSortedMap().subMap(fromKey, toKey);\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    public SortedMap<K,V> headMap(K toKey) {\n+        SortedMap<K,V> map = getSortedMap().headMap(toKey);\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    public SortedMap<K,V> tailMap(K fromKey) {\n+        SortedMap<K,V> map = getSortedMap().tailMap(fromKey);\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/LinkedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections.iterators.UnmodifiableListIterator;\n+import org.apache.commons.collections.list.UnmodifiableList;\n+\n+/**\n+ * A <code>Map</code> implementation that maintains the order of the entries.\n+ * In this implementation order is maintained by original insertion.\n+ * <p>\n+ * This implementation improves on the JDK1.4 LinkedHashMap by adding the \n+ * {@link org.apache.commons.collections.MapIterator MapIterator}\n+ * functionality, additional convenience methods and allowing\n+ * bidirectional iteration. It also implements <code>OrderedMap</code>.\n+ * In addition, non-interface methods are provided to access the map by index.\n+ * <p>\n+ * The <code>orderedMapIterator()</code> method provides direct access to a\n+ * bidirectional iterator. The iterators from the other views can also be cast\n+ * to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * The implementation is also designed to be subclassed, with lots of useful\n+ * methods exposed.\n+ * <p>\n+ * <strong>Note that LinkedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class LinkedMap<K, V> extends AbstractLinkedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = 9077234323521161066L;\n+    \n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public LinkedMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public LinkedMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public LinkedMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public LinkedMap(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public LinkedMap<K, V> clone() {\n+        return (LinkedMap<K, V>) super.clone();\n+    }\n+    \n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public K get(int index) {\n+        return getEntry(index).getKey();\n+    }\n+    \n+    /**\n+     * Gets the value at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the value at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V getValue(int index) {\n+        return getEntry(index).getValue();\n+    }\n+    \n+    /**\n+     * Gets the index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int indexOf(Object key) {\n+        key = convertKey(key);\n+        int i = 0;\n+        for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after, i++) {\n+            if (isEqualKey(key, entry.key)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index of the object to remove\n+     * @return the previous value corresponding the <code>key</code>,\n+     *  or <code>null</code> if none existed\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V remove(int index) {\n+        return remove(get(index));\n+    }\n+\n+    /**\n+     * Gets an unmodifiable List view of the keys.\n+     * <p>\n+     * The returned list is unmodifiable because changes to the values of\n+     * the list (using {@link java.util.ListIterator#set(Object)}) will\n+     * effectively remove the value from the list and reinsert that value at\n+     * the end of the list, which is an unexpected side effect of changing the\n+     * value of a list.  This occurs because changing the key, changes when the\n+     * mapping is added to the map and thus where it appears in the list.\n+     * <p>\n+     * An alternative to this method is to use {@link #keySet()}.\n+     *\n+     * @see #keySet()\n+     * @return The ordered list of keys.  \n+     */\n+    public List<K> asList() {\n+        return new LinkedMapList<K>(this);\n+    }\n+\n+    /**\n+     * List view of map.\n+     */\n+    static class LinkedMapList<K> extends AbstractList<K> {\n+\n+        final LinkedMap<K, ?> parent;\n+\n+        LinkedMapList(LinkedMap<K, ?> parent) {\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public K get(int index) {\n+            return parent.get(index);\n+        }\n+\n+        @Override\n+        public boolean contains(Object obj) {\n+            return parent.containsKey(obj);\n+        }\n+\n+        @Override\n+        public int indexOf(Object obj) {\n+            return parent.indexOf(obj);\n+        }\n+\n+        @Override\n+        public int lastIndexOf(Object obj) {\n+            return parent.indexOf(obj);\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> coll) {\n+            return parent.keySet().containsAll(coll);\n+        }\n+\n+        @Override\n+        public K remove(int index) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean removeAll(Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean retainAll(Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return parent.keySet().toArray();\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(T[] array) {\n+            return parent.keySet().toArray(array);\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return UnmodifiableIterator.unmodifiableIterator(parent.keySet().iterator());\n+        }\n+\n+        @Override\n+        public ListIterator<K> listIterator() {\n+            return UnmodifiableListIterator.umodifiableListIterator(super.listIterator());\n+        }\n+\n+        @Override\n+        public ListIterator<K> listIterator(int fromIndex) {\n+            return UnmodifiableListIterator.umodifiableListIterator(super.listIterator(fromIndex));\n+        }\n+\n+        @Override\n+        public List<K> subList(int fromIndexInclusive, int toIndexExclusive) {\n+            return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/ListOrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.iterators.AbstractUntypedIteratorDecorator;\n+import org.apache.commons.collections.keyvalue.AbstractMapEntry;\n+import org.apache.commons.collections.list.UnmodifiableList;\n+\n+/**\n+ * Decorates a <code>Map</code> to ensure that the order of addition is retained\n+ * using a <code>List</code> to maintain order.\n+ * <p>\n+ * The order will be used via the iterators and toArray methods on the views.\n+ * The order is also returned by the <code>MapIterator</code>.\n+ * The <code>orderedMapIterator()</code> method accesses an iterator that can\n+ * iterate both forwards and backwards through the map.\n+ * In addition, non-interface methods are provided to access the map by index.\n+ * <p>\n+ * If an object is added to the Map for a second time, it will remain in the\n+ * original position in the iteration.\n+ * <p>\n+ * <strong>Note that ListOrderedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * <strong>Note that ListOrderedMap doesn't work with {@link IdentityMap},\n+ * {@link CaseInsensitiveMap}, or similar maps that violate the general\n+ * contract of {@link java.util.Map}.</strong> The <code>ListOrderedMap</code>\n+ * (or, more precisely, the underlying <code>List</code>) is relying on\n+ * {@link Object#java.lang.equals(Object) equals()}. This is fine, as long as the\n+ * decorated <code>Map</code> is also based on {@link Object#equals(Object) equals()},\n+ * and {@link Object#hashCode() hashCode()}, which {@link IdentityMap}, and\n+ * {@link CaseInsensitiveMap} don't: The former uses <code>==</code>, and\n+ * the latter uses {@link Object#equals(Object) equals()} on a lowercased\n+ * key.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ * @author Dave Meikle\n+ */\n+public class ListOrderedMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements OrderedMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2728177751851003750L;\n+\n+    /** Internal list to hold the sequence of objects */\n+    protected final List<K> insertOrder = new ArrayList<K>();\n+\n+    /**\n+     * Factory method to create an ordered map.\n+     * <p>\n+     * An <code>ArrayList</code> is used to retain order.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> OrderedMap<K, V> listOrderedMap(Map<K, V> map) {\n+        return new ListOrderedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty <code>ListOrderedMap</code> that decorates\n+     * a <code>HashMap</code>.\n+     * \n+     * @since Commons Collections 3.1\n+     */\n+    public ListOrderedMap() {\n+        this(new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected ListOrderedMap(Map<K, V> map) {\n+        super(map);\n+        insertOrder.addAll(decorated().keySet());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    // Implement OrderedMap\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new ListOrderedMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Gets the first key in this map by insert order.\n+     *\n+     * @return the first key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K firstKey() {\n+        if (size() == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return insertOrder.get(0);\n+    }\n+\n+    /**\n+     * Gets the last key in this map by insert order.\n+     *\n+     * @return the last key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K lastKey() {\n+        if (size() == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return insertOrder.get(size() - 1);\n+    }\n+    \n+    /**\n+     * Gets the next key to the one specified using insert order.\n+     * This method performs a list search to find the key and is O(n).\n+     * \n+     * @param key  the key to find previous for\n+     * @return the next key, null if no match or at start\n+     */\n+    public K nextKey(Object key) {\n+        int index = insertOrder.indexOf(key);\n+        if (index >= 0 && index < size() - 1) {\n+            return insertOrder.get(index + 1);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous key to the one specified using insert order.\n+     * This method performs a list search to find the key and is O(n).\n+     * \n+     * @param key  the key to find previous for\n+     * @return the previous key, null if no match or at start\n+     */\n+    public K previousKey(Object key) {\n+        int index = insertOrder.indexOf(key);\n+        if (index > 0) {\n+            return insertOrder.get(index - 1);\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(K key, V value) {\n+        if (decorated().containsKey(key)) {\n+            // re-adding doesn't change order\n+            return decorated().put(key, value);\n+        } else {\n+            // first add, so add to both map and list\n+            V result = decorated().put(key, value);\n+            insertOrder.add(key);\n+            return result;\n+        }\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Puts the values contained in a supplied Map into the Map starting at\n+     * the specified index.\n+     *\n+     * @param index the index in the Map to start at.\n+     * @param map the Map containing the values to be added.\n+     */\n+    public void putAll(int index, Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            put(index, entry.getKey(), entry.getValue());\n+            index++;\n+        }\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        V result = decorated().remove(key);\n+        insertOrder.remove(key);\n+        return result;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        decorated().clear();\n+        insertOrder.clear();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a view over the keys in the map.\n+     * <p>\n+     * The Collection will be ordered by object insertion into the map.\n+     *\n+     * @see #keyList()\n+     * @return the fully modifiable collection view over the keys\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        return new KeySetView<K>(this);\n+    }\n+\n+    /**\n+     * Gets a view over the keys in the map as a List.\n+     * <p>\n+     * The List will be ordered by object insertion into the map.\n+     * The List is unmodifiable.\n+     *\n+     * @see #keySet()\n+     * @return the unmodifiable list view over the keys\n+     * @since Commons Collections 3.2\n+     */\n+    public List<K> keyList() {\n+        return UnmodifiableList.unmodifiableList(insertOrder);\n+    }\n+\n+    /**\n+     * Gets a view over the values in the map.\n+     * <p>\n+     * The Collection will be ordered by object insertion into the map.\n+     * <p>\n+     * From Commons Collections 3.2, this Collection can be cast\n+     * to a list, see {@link #valueList()}\n+     *\n+     * @see #valueList()\n+     * @return the fully modifiable collection view over the values\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        return new ValuesView<V>(this);\n+    }\n+\n+    /**\n+     * Gets a view over the values in the map as a List.\n+     * <p>\n+     * The List will be ordered by object insertion into the map.\n+     * The List supports remove and set, but does not support add.\n+     *\n+     * @see #values()\n+     * @return the partially modifiable list view over the values\n+     * @since Commons Collections 3.2\n+     */\n+    public List<V> valueList() {\n+        return new ValuesView<V>(this);\n+    }\n+\n+    /**\n+     * Gets a view over the entries in the map.\n+     * <p>\n+     * The Set will be ordered by object insertion into the map.\n+     *\n+     * @return the fully modifiable set view over the entries\n+     */\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return new EntrySetView<K, V>(this, this.insertOrder);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the Map as a string.\n+     * \n+     * @return the Map as a String\n+     */\n+    @Override\n+    public String toString() {\n+        if (isEmpty()) {\n+            return \"{}\";\n+        }\n+        StringBuilder buf = new StringBuilder();\n+        buf.append('{');\n+        boolean first = true;\n+        for (Map.Entry<K, V> entry : entrySet()) {\n+            K key = entry.getKey();\n+            V value = entry.getValue();\n+            if (first) {\n+                first = false;\n+            } else {\n+                buf.append(\", \");\n+            }\n+            buf.append(key == this ? \"(this Map)\" : key);\n+            buf.append('=');\n+            buf.append(value == this ? \"(this Map)\" : value);\n+        }\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public K get(int index) {\n+        return insertOrder.get(index);\n+    }\n+    \n+    /**\n+     * Gets the value at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V getValue(int index) {\n+        return get(insertOrder.get(index));\n+    }\n+    \n+    /**\n+     * Gets the index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int indexOf(Object key) {\n+        return insertOrder.indexOf(key);\n+    }\n+\n+    /**\n+     * Sets the value at the specified index.\n+     *\n+     * @param index  the index of the value to set\n+     * @return the previous value at that index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @since Commons Collections 3.2\n+     */\n+    public V setValue(int index, V value) {\n+        K key = insertOrder.get(index);\n+        return put(key, value);\n+    }\n+\n+    /**\n+     * Puts a key-value mapping into the map at the specified index.\n+     * <p>\n+     * If the map already contains the key, then the original mapping\n+     * is removed and the new mapping added at the specified index.\n+     * The remove may change the effect of the index. The index is\n+     * always calculated relative to the original state of the map.\n+     * <p>\n+     * Thus the steps are: (1) remove the existing key-value mapping,\n+     * then (2) insert the new key-value mapping at the position it\n+     * would have been inserted had the remove not ocurred.\n+     *\n+     * @param index  the index at which the mapping should be inserted\n+     * @param key  the key\n+     * @param value  the value\n+     * @return the value previously mapped to the key\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * @since Commons Collections 3.2\n+     */\n+    public V put(int index, K key, V value) {\n+        Map<K, V> m = decorated();\n+        if (m.containsKey(key)) {\n+            V result = m.remove(key);\n+            int pos = insertOrder.indexOf(key);\n+            insertOrder.remove(pos);\n+            if (pos < index) {\n+                index--;\n+            }\n+            insertOrder.add(index, key);\n+            m.put(key, value);\n+            return result;\n+        } else {\n+            insertOrder.add(index, key);\n+            m.put(key, value);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index of the object to remove\n+     * @return the removed value, or <code>null</code> if none existed\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V remove(int index) {\n+        return remove(get(index));\n+    }\n+\n+    /**\n+     * Gets an unmodifiable List view of the keys which changes as the map changes.\n+     * <p>\n+     * The returned list is unmodifiable because changes to the values of\n+     * the list (using {@link java.util.ListIterator#set(Object)}) will\n+     * effectively remove the value from the list and reinsert that value at\n+     * the end of the list, which is an unexpected side effect of changing the\n+     * value of a list.  This occurs because changing the key, changes when the\n+     * mapping is added to the map and thus where it appears in the list.\n+     * <p>\n+     * An alternative to this method is to use the better named\n+     * {@link #keyList()} or {@link #keySet()}.\n+     *\n+     * @see #keyList()\n+     * @see #keySet()\n+     * @return The ordered list of keys.  \n+     */\n+    public List<K> asList() {\n+        return keyList();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ValuesView<V> extends AbstractList<V> {\n+        private final ListOrderedMap<Object, V> parent;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ValuesView(ListOrderedMap<?, V> parent) {\n+            super();\n+            this.parent = (ListOrderedMap<Object, V>) parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return this.parent.size();\n+        }\n+\n+        @Override\n+        public boolean contains(Object value) {\n+            return this.parent.containsValue(value);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n+                public V next() {\n+                    return getIterator().next().getValue();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public V get(int index) {\n+            return this.parent.getValue(index);\n+        }\n+\n+        @Override\n+        public V set(int index, V value) {\n+            return this.parent.setValue(index, value);\n+        }\n+\n+        @Override\n+        public V remove(int index) {\n+            return this.parent.remove(index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class KeySetView<K> extends AbstractSet<K> {\n+        private final ListOrderedMap<K, Object> parent;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        KeySetView(ListOrderedMap<K, ?> parent) {\n+            super();\n+            this.parent = (ListOrderedMap<K, Object>) parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return this.parent.size();\n+        }\n+\n+        @Override\n+        public boolean contains(Object value) {\n+            return this.parent.containsKey(value);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n+                public K next() {\n+                    return getIterator().next().getKey();\n+                }\n+            };\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        private final ListOrderedMap<K, V> parent;\n+        private final List<K> insertOrder;\n+        private Set<Map.Entry<K, V>> entrySet;\n+\n+        public EntrySetView(ListOrderedMap<K, V> parent, List<K> insertOrder) {\n+            super();\n+            this.parent = parent;\n+            this.insertOrder = insertOrder;\n+        }\n+\n+        private Set<Map.Entry<K, V>> getEntrySet() {\n+            if (entrySet == null) {\n+                entrySet = parent.decorated().entrySet();\n+            }\n+            return entrySet;\n+        }\n+        \n+        @Override\n+        public int size() {\n+            return this.parent.size();\n+        }\n+        @Override\n+        public boolean isEmpty() {\n+            return this.parent.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean contains(Object obj) {\n+            return getEntrySet().contains(obj);\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> coll) {\n+            return getEntrySet().containsAll(coll);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            if (getEntrySet().contains(obj)) {\n+                Object key = ((Map.Entry<K, V>) obj).getKey();\n+                parent.remove(key);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            return getEntrySet().equals(obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return getEntrySet().hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getEntrySet().toString();\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return new ListOrderedIterator<K, V>(parent, insertOrder);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n+        private final ListOrderedMap<K, V> parent;\n+        private K last = null;\n+        \n+        ListOrderedIterator(ListOrderedMap<K, V> parent, List<K> insertOrder) {\n+            super(insertOrder.iterator());\n+            this.parent = parent;\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            last = getIterator().next();\n+            return new ListOrderedMapEntry<K, V>(parent, last);\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            parent.decorated().remove(last);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n+        private final ListOrderedMap<K, V> parent;\n+\n+        ListOrderedMapEntry(ListOrderedMap<K, V> parent, K key) {\n+            super(key, null);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public V getValue() {\n+            return parent.get(key);\n+        }\n+\n+        @Override\n+        public V setValue(V value) {\n+            return parent.decorated().put(key, value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+        private final ListOrderedMap<K, V> parent;\n+        private ListIterator<K> iterator;\n+        private K last = null;\n+        private boolean readable = false;\n+\n+        ListOrderedMapIterator(ListOrderedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            this.iterator = parent.insertOrder.listIterator();\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public K next() {\n+            last = iterator.next();\n+            readable = true;\n+            return last;\n+        }\n+        \n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+\n+        public K previous() {\n+            last = iterator.previous();\n+            readable = true;\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            iterator.remove();\n+            parent.map.remove(last);\n+            readable = false;\n+        }\n+\n+        public K getKey() {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return last;\n+        }\n+\n+        public V getValue() {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return parent.get(last);\n+        }\n+\n+        public V setValue(V value) {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return parent.map.put(last, value);\n+        }\n+\n+        public void reset() {\n+            iterator = parent.insertOrder.listIterator();\n+            last = null;\n+            readable = false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (readable == true) {\n+                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/MultiKeyMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.keyvalue.MultiKey;\n+\n+/**\n+ * A <code>Map</code> implementation that uses multiple keys to map the value.\n+ * <p>\n+ * This class is the most efficient way to uses multiple keys to map to a value.\n+ * The best way to use this class is via the additional map-style methods.\n+ * These provide <code>get</code>, <code>containsKey</code>, <code>put</code> and\n+ * <code>remove</code> for individual keys which operate without extra object creation.\n+ * <p>\n+ * The additional methods are the main interface of this map.\n+ * As such, you will not normally hold this map in a variable of type <code>Map</code>.\n+ * <p>\n+ * The normal map methods take in and return a {@link MultiKey}.\n+ * If you try to use <code>put()</code> with any other object type a\n+ * <code>ClassCastException</code> is thrown. If you try to use <code>null</code> as\n+ * the key in <code>put()</code> a <code>NullPointerException</code> is thrown.\n+ * <p>\n+ * This map is implemented as a decorator of a <code>AbstractHashedMap</code> which\n+ * enables extra behaviour to be added easily.\n+ * <ul>\n+ * <li><code>MultiKeyMap.decorate(new LinkedMap())</code> creates an ordered map.\n+ * <li><code>MultiKeyMap.decorate(new LRUMap())</code> creates an least recently used map.\n+ * <li><code>MultiKeyMap.decorate(new ReferenceMap())</code> creates a garbage collector sensitive map.\n+ * </ul>\n+ * Note that <code>IdentityMap</code> and <code>ReferenceIdentityMap</code> are unsuitable\n+ * for use as the key comparison would work on the whole MultiKey, not the elements within.\n+ * <p>\n+ * As an example, consider a least recently used cache that uses a String airline code\n+ * and a Locale to lookup the airline's name:\n+ * <pre>\n+ * private MultiKeyMap cache = MultiKeyMap.decorate(new LRUMap(50));\n+ *\n+ * public String getAirlineName(String code, String locale) {\n+ *   String name = (String) cache.get(code, locale);\n+ *   if (name == null) {\n+ *     name = getAirlineNameFromDB(code, locale);\n+ *     cache.put(code, locale, name);\n+ *   }\n+ *   return name;\n+ * }\n+ * </pre>\n+ * <p>\n+ * <strong>Note that MultiKeyMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. This class may throw exceptions when accessed\n+ * by concurrent threads without synchronization.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class MultiKeyMap<K, V> extends AbstractMapDecorator<MultiKey<? extends K>, V>\n+        implements IterableMap<MultiKey<? extends K>, V>, Serializable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -1788199231038721040L;\n+\n+    /** The decorated map */\n+    //keep this member around for serialization BC with older Collections releases assuming we want to do that\n+    protected AbstractHashedMap<MultiKey<? extends K>, V> map;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified map to add the MultiKeyMap API and fast query.\n+     * The map must not be null and must be empty.\n+     *\n+     * @param map  the map to decorate, not null\n+     * @throws IllegalArgumentException if the map is null or not empty\n+     */\n+    public static <K, V> MultiKeyMap<K, V> multiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        if (map.size() > 0) {\n+            throw new IllegalArgumentException(\"Map must be empty\");\n+        }\n+        return new MultiKeyMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Constructs a new MultiKeyMap that decorates a <code>HashedMap</code>.\n+     */\n+    public MultiKeyMap() {\n+        this(new HashedMap<MultiKey<? extends K>, V>());\n+    }\n+\n+    /**\n+     * Constructor that decorates the specified map and is called from\n+     * {@link #multiKeyMap(AbstractHashedMap)}.\n+     * The map must not be null and should be empty or only contain valid keys.\n+     * This constructor performs no validation.\n+     *\n+     * @param map  the map to decorate\n+     */\n+    protected MultiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+        super(map);\n+        this.map = map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(Object key1, Object key2) {\n+        int hashCode = hash(key1, key2);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2) {\n+        int hashCode = hash(key1, key2);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(K key1, K key2, V value) {\n+        int hashCode = hash(key1, key2);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(Object key1, Object key2) {\n+        int hashCode = hash(key1, key2);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            Object key1, Object key2) {\n+        MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 2 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key1 != null && key2.equals(multi.getKey(1)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(Object key1, Object key2, Object key3) {\n+        int hashCode = hash(key1, key2, key3);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2, Object key3) {\n+        int hashCode = hash(key1, key2, key3);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(K key1, K key2, K key3, V value) {\n+        int hashCode = hash(key1, key2, key3);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(Object key1, Object key2, Object key3) {\n+        int hashCode = hash(key1, key2, key3);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2, Object key3) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry, Object key1, Object key2, Object key3) {\n+        MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 3 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(Object key1, Object key2, Object key3, Object key4) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2, Object key3, Object key4) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(K key1, K key2, K key3, K key4, V value) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3, key4), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(Object key1, Object key2, Object key3, Object key4) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2, Object key3, Object key4) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        if (key4 != null) {\n+            h ^= key4.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry, Object key1, Object key2, Object key3, Object key4) {\n+        MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 4 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n+            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(K key1, K key2, K key3, K key4, K key5, V value) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3, key4, key5), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        if (key4 != null) {\n+            h ^= key4.hashCode();\n+        }\n+        if (key5 != null) {\n+            h ^= key5.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 5 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n+            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3))) &&\n+            (key5 == multi.getKey(4) || key5 != null && key5.equals(multi.getKey(4)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes all mappings where the first key is that specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has one or more keys, and the first matches that specified.\n+     * \n+     * @param key1  the first key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1) {\n+        boolean modified = false;\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 1 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first two keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has two or more keys, and the first two match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1, Object key2) {\n+        boolean modified = false;\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 2 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first three keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has three or more keys, and the first three match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1, Object key2, Object key3) {\n+        boolean modified = false;\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 3 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first four keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has four or more keys, and the first four match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1, Object key2, Object key3, Object key4) {\n+        boolean modified = false;\n+        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 4 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n+                (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Check to ensure that input keys are valid MultiKey objects.\n+     * \n+     * @param key  the key to check\n+     */\n+    protected void checkKey(MultiKey<?> key) {\n+        if (key == null) {\n+            throw new NullPointerException(\"Key must not be null\");\n+        }\n+    }\n+\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public MultiKeyMap<K, V> clone() {\n+        return new MultiKeyMap<K, V>(decorated().clone());\n+    }\n+\n+    /**\n+     * Puts the key and value into the map, where the key must be a non-null\n+     * MultiKey object.\n+     * \n+     * @param key  the non-null MultiKey object\n+     * @param value  the value to store\n+     * @return the previous value for the key\n+     * @throws NullPointerException if the key is null\n+     * @throws ClassCastException if the key is not a MultiKey\n+     */\n+    @Override\n+    public V put(MultiKey<? extends K> key, V value) {\n+        checkKey(key);\n+        return super.put(key, value);\n+    }\n+\n+    /**\n+     * Copies all of the keys and values from the specified map to this map.\n+     * Each key must be non-null and a MultiKey object.\n+     * \n+     * @param mapToCopy  to this map\n+     * @throws NullPointerException if the mapToCopy or any key within is null\n+     * @throws ClassCastException if any key in mapToCopy is not a MultiKey\n+     */\n+    @Override\n+    public void putAll(Map<? extends MultiKey<? extends K>, ? extends V> mapToCopy) {\n+        for (MultiKey<? extends K> key : mapToCopy.keySet()) {\n+            checkKey(key);\n+        }\n+        super.putAll(mapToCopy);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public MapIterator<MultiKey<? extends K>, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected AbstractHashedMap<MultiKey<? extends K>, V> decorated() {\n+        return map;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/MultiValueMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FunctorException;\n+import org.apache.commons.collections.MultiMap;\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.IteratorChain;\n+\n+/**\n+ * A MultiValueMap decorates another map, allowing it to have\n+ * more than one value for a key.\n+ * <p>\n+ * A <code>MultiMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that key.\n+ * <p>\n+ * This implementation is a decorator, allowing any Map implementation\n+ * to be used as the base.\n+ * <p>\n+ * In addition, this implementation allows the type of collection used\n+ * for the values to be controlled. By default, an <code>ArrayList</code>\n+ * is used, however a <code>Class</code> to instantiate may be specified,\n+ * or a factory that returns a <code>Collection</code> instance.\n+ * <p>\n+ * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. This class may throw exceptions when accessed\n+ * by concurrent threads without synchronization.\n+ *\n+ * @author James Carman\n+ * @author Christopher Berry\n+ * @author James Strachan\n+ * @author Steve Downey\n+ * @author Stephen Colebourne\n+ * @author Julien Buret\n+ * @author Serhiy Yevtushenko\n+ * @version $Revision$ $Date$\n+ * @since Commons Collections 3.2\n+ */\n+public class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2214159910087182007L;\n+\n+    /** The factory for creating value collections. */\n+    private final Factory<? extends Collection<V>> collectionFactory;\n+    /** The cached values. */\n+    private transient Collection<V> valuesView;\n+\n+    /**\n+     * Creates a map which wraps the given map and\n+     * maps keys to ArrayLists.\n+     *\n+     * @param map  the map to wrap\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n+        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * maps keys to collections of type <code>collectionClass</code>.\n+     *\n+     * @param map  the map to wrap\n+     * @param collectionClass  the type of the collection class\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map, Class<C> collectionClass) {\n+        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory (must return a Collection object).\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map, Factory<C> collectionFactory) {\n+        return new MultiValueMap<K, V>(map, collectionFactory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> and\n+     * storing the multiple values in an <code>ArrayList</code>.\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public MultiValueMap() {\n+        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory which must return a Collection instance\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected <C extends Collection<V>> MultiValueMap(Map<K, ? super C> map, Factory<C> collectionFactory) {\n+        super((Map<K, Object>) map);\n+        if (collectionFactory == null) {\n+            throw new IllegalArgumentException(\"The factory must not be null\");\n+        }\n+        this.collectionFactory = collectionFactory;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.3\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.3\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, Object>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clear the map.\n+     */\n+    @Override\n+    public void clear() {\n+        // If you believe that you have GC issues here, try uncommenting this code\n+//        Set pairs = getMap().entrySet();\n+//        Iterator pairsIterator = pairs.iterator();\n+//        while (pairsIterator.hasNext()) {\n+//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+//            Collection coll = (Collection) keyValuePair.getValue();\n+//            coll.clear();\n+//        }\n+        decorated().clear();\n+    }\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, <code>null</code> will be returned\n+     * from a subsequant <code>get(key)</code>.\n+     *\n+     * @param key  the key to remove from\n+     * @param value the value to remove\n+     * @return the value removed (which was passed in), null if nothing removed\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V remove(Object key, Object value) {\n+        Collection<V> valuesForKey = getCollection(key);\n+        if (valuesForKey == null) {\n+            return null;\n+        }\n+        boolean removed = valuesForKey.remove(value);\n+        if (removed == false) {\n+            return null;\n+        }\n+        if (valuesForKey.isEmpty()) {\n+            remove(key);\n+        }\n+        return (V) value;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the value specified.\n+     * <p>\n+     * This checks all collections against all keys for the value, and thus could be slow.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean containsValue(Object value) {\n+        Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n+        if (pairs != null) {\n+            for (Map.Entry<K, Object> entry : pairs) {\n+                if (((Collection<V>) entry.getValue()).contains(value)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     *\n+     * @param key  the key to store against\n+     * @param value  the value to add to the collection at the key\n+     * @return the value added if the map changed and null if the map did not change\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Object put(K key, Object value) {\n+        boolean result = false;\n+        Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            coll = createCollection(1);  // might produce a non-empty collection\n+            coll.add((V) value);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                decorated().put(key, coll);\n+                result = true;  // map definitely changed\n+            }\n+        } else {\n+            result = coll.add((V) value);\n+        }\n+        return (result ? value : null);\n+    }\n+\n+    /**\n+     * Override superclass to ensure that MultiMap instances are\n+     * correctly handled.\n+     * <p>\n+     * If you call this method with a normal map, each entry is\n+     * added using <code>put(Object,Object)</code>.\n+     * If you call this method with a multi map, each entry is\n+     * added using <code>putAll(Object,Collection)</code>.\n+     *\n+     * @param map  the map to copy (either a normal or multi map)\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void putAll(Map<? extends K, ?> map) {\n+        if (map instanceof MultiMap) {\n+            for (Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n+                putAll(entry.getKey(), (Collection<V>) entry.getValue());\n+            }\n+        } else {\n+            for (Map.Entry<? extends K, ?> entry : map.entrySet()) {\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * This returns a collection containing the combination of values from all keys.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<Object> values() {\n+        Collection<V> vs = valuesView;\n+        return (Collection<Object>) (vs != null ? vs : (valuesView = new Values()));\n+    }\n+\n+    /**\n+     * Checks whether the collection at the specified key contains the value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object key, Object value) {\n+        Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            return false;\n+        }\n+        return coll.contains(value);\n+    }\n+\n+    /**\n+     * Gets the collection mapped to the specified key.\n+     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n+     *\n+     * @param key  the key to retrieve\n+     * @return the collection mapped to the key, null if no mapping\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<V> getCollection(Object key) {\n+        return (Collection<V>) decorated().get(key);\n+    }\n+\n+    /**\n+     * Gets the size of the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get size for\n+     * @return the size of the collection at the key, zero if key not in map\n+     */\n+    public int size(Object key) {\n+        Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            return 0;\n+        }\n+        return coll.size();\n+    }\n+\n+    /**\n+     * Adds a collection of values to the collection associated with\n+     * the specified key.\n+     *\n+     * @param key  the key to store against\n+     * @param values  the values to add to the collection at the key, null ignored\n+     * @return true if this map changed\n+     */\n+    public boolean putAll(K key, Collection<V> values) {\n+        if (values == null || values.size() == 0) {\n+            return false;\n+        }\n+        boolean result = false;\n+        Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            coll = createCollection(values.size());  // might produce a non-empty collection\n+            coll.addAll(values);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                decorated().put(key, coll);\n+                result = true;  // map definitely changed\n+            }\n+        } else {\n+            result = coll.addAll(values);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Gets an iterator for the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get an iterator for\n+     * @return the iterator of the collection at the key, empty iterator if key not in map\n+     */\n+    public Iterator<V> iterator(Object key) {\n+        if (!containsKey(key)) {\n+            return EmptyIterator.<V>emptyIterator();\n+        }\n+        return new ValuesIterator(key);\n+    }\n+\n+    /**\n+     * Gets the total size of the map by counting all the values.\n+     *\n+     * @return the total size of the map counting all values\n+     */\n+    public int totalSize() {\n+        int total = 0;\n+        for (Object v : decorated().values()) {\n+            total += CollectionUtils.size(v);\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Creates a new instance of the map value Collection container\n+     * using the factory.\n+     * <p>\n+     * This method can be overridden to perform your own processing\n+     * instead of using the factory.\n+     *\n+     * @param size  the collection size that is about to be added\n+     * @return the new collection\n+     */\n+    protected Collection<V> createCollection(int size) {\n+        return collectionFactory.create();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class that provides the values view.\n+     */\n+    private class Values extends AbstractCollection<V> {\n+        @Override\n+        public Iterator<V> iterator() {\n+            final IteratorChain<V> chain = new IteratorChain<V>();\n+            for (Iterator<K> it = keySet().iterator(); it.hasNext();) {\n+                chain.addIterator(new ValuesIterator(it.next()));\n+            }\n+            return chain;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return totalSize();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            MultiValueMap.this.clear();\n+        }\n+    }\n+\n+    /**\n+     * Inner class that provides the values iterator.\n+     */\n+    private class ValuesIterator implements Iterator<V> {\n+        private final Object key;\n+        private final Collection<V> values;\n+        private final Iterator<V> iterator;\n+\n+        public ValuesIterator(Object key) {\n+            this.key = key;\n+            this.values = getCollection(key);\n+            this.iterator = values.iterator();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            if (values.isEmpty()) {\n+                MultiValueMap.this.remove(key);\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public V next() {\n+            return iterator.next();\n+        }\n+    }\n+\n+    /**\n+     * Inner class that provides a simple reflection factory.\n+     */\n+    private static class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 2986114157496788874L;\n+\n+        private final Class<T> clazz;\n+\n+        public ReflectionFactory(Class<T> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        public T create() {\n+            try {\n+                return clazz.newInstance();\n+            } catch (Exception ex) {\n+                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/PredicatedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Decorates another <code>Map</code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This map exists to provide validation for the decorated map.\n+ * It is normally created to decorate an empty map.\n+ * If an object cannot be added to the map, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null keys are added to the map.\n+ * <pre>Map map = PredicatedSet.decorate(new HashMap(), NotNullPredicate.INSTANCE, null);</pre>\n+ * <p>\n+ * <strong>Note that PredicatedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedMap<K, V>\n+        extends AbstractInputCheckedMapDecorator<K, V>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7412622456128415156L;\n+\n+    /** The key predicate to use */\n+    protected final Predicate<? super K> keyPredicate;\n+\n+    /** The value predicate to use */\n+    protected final Predicate<? super V> valuePredicate;\n+\n+    /**\n+     * Factory method to create a predicated (validating) map.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <K, V> IterableMap<K, V> predicatedMap(Map<K, V> map, Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n+        return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected PredicatedMap(Map<K, V> map, Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n+        super(map);\n+        this.keyPredicate = keyPredicate;\n+        this.valuePredicate = valuePredicate;\n+        \n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<K, V> entry = it.next();\n+            validate(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a key value pair.\n+     * \n+     * @param key  the key to validate\n+     * @param value  the value to validate\n+     * @throws IllegalArgumentException if invalid\n+     */\n+    protected void validate(K key, V value) {\n+        if (keyPredicate != null && keyPredicate.evaluate(key) == false) {\n+            throw new IllegalArgumentException(\"Cannot add key - Predicate rejected it\");\n+        }\n+        if (valuePredicate != null && valuePredicate.evaluate(value) == false) {\n+            throw new IllegalArgumentException(\"Cannot add value - Predicate rejected it\");\n+        }\n+    }\n+\n+    /**\n+     * Override to validate an object set into the map via <code>setValue</code>.\n+     * \n+     * @param value  the value to validate\n+     * @throws IllegalArgumentException if invalid\n+     * @since Commons Collections 3.1\n+     */\n+    @Override\n+    protected V checkSetValue(V value) {\n+        if (valuePredicate.evaluate(value) == false) {\n+            throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Override to only return true when there is a value transformer.\n+     * \n+     * @return true if a value predicate is in use\n+     * @since Commons Collections 3.1\n+     */\n+    @Override\n+    protected boolean isSetValueChecking() {\n+        return (valuePredicate != null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(K key, V value) {\n+        validate(key, value);\n+        return map.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        for (Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n+            validate(entry.getKey(), entry.getValue());\n+        }\n+        super.putAll(mapToCopy);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Decorates another <code>SortedMap </code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This map exists to provide validation for the decorated map.\n+ * It is normally created to decorate an empty map.\n+ * If an object cannot be added to the map, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null keys are added to the map.\n+ * <pre>SortedMap map = PredicatedSortedSet.decorate(new TreeMap(), NotNullPredicate.INSTANCE, null);</pre>\n+ * <p>\n+ * <strong>Note that PredicatedSortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedSortedMap<K, V> extends PredicatedMap<K, V> implements SortedMap<K, V> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3359846175935304332L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) sorted map.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <K, V> SortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n+            Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected PredicatedSortedMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n+            Predicate<? super V> valuePredicate) {\n+        super(map, keyPredicate, valuePredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return getSortedMap().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return getSortedMap().lastKey();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return getSortedMap().comparator();\n+    }\n+\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    public SortedMap<K, V> headMap(K toKey) {\n+        SortedMap<K, V> map = getSortedMap().headMap(toKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.Reference;\n+\n+/**\n+ * A <code>Map</code> implementation that allows mappings to be\n+ * removed by the garbage collector and matches keys and values based\n+ * on <code>==</code> not <code>equals()</code>.\n+ * <p>\n+ * <p>\n+ * When you construct a <code>ReferenceIdentityMap</code>, you can specify what kind\n+ * of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The default constructor uses hard keys and soft values, providing a\n+ * memory-sensitive cache.\n+ * <p>\n+ * This map is similar to\n+ * {@link org.apache.commons.collections.map.ReferenceMap ReferenceMap}.\n+ * It differs in that keys and values in this class are compared using <code>==</code>.\n+ * <p>\n+ * This map will violate the detail of various Map and map view contracts.\n+ * As a general rule, don't compare this map to other maps.\n+ * <p>\n+ * This {@link java.util.Map Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to \n+ * provide synchronized access to a <code>ReferenceIdentityMap</code>.\n+ * Remember that synchronization will not stop the garbage collecter removing entries.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * <strong>Note that ReferenceIdentityMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @see java.lang.ref.Reference\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v2.1)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ReferenceIdentityMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1266190134568365852L;\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use hard references to keys and soft references to values.\n+     */\n+    public ReferenceIdentityMap() {\n+        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n+                DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     */\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param purgeValues should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n+            boolean purgeValues) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> with the\n+     * specified reference types, load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     */\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n+            int capacity, float loadFactor) {\n+        super(keyType, valueType, capacity, loadFactor, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> with the\n+     * specified reference types, load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n+            int capacity, float loadFactor, boolean purgeValues) {\n+        super(keyType, valueType, capacity, loadFactor, purgeValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hash code for the key specified.\n+     * <p>\n+     * This implementation uses the identity hash code.\n+     * \n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    @Override\n+    protected int hash(Object key) {\n+        return System.identityHashCode(key);\n+    }\n+\n+    /**\n+     * Gets the hash code for a MapEntry.\n+     * <p>\n+     * This implementation uses the identity hash code.\n+     * \n+     * @param key  the key to get a hash code for, may be null\n+     * @param value  the value to get a hash code for, may be null\n+     * @return the hash code, as per the MapEntry specification\n+     */\n+    @Override\n+    protected int hashEntry(Object key, Object value) {\n+        return System.identityHashCode(key) ^\n+               System.identityHashCode(value);\n+    }\n+\n+    /**\n+     * Compares two keys for equals.\n+     * <p>\n+     * This implementation converts the key from the entry to a real reference\n+     * before comparison and uses <code>==</code>.\n+     * \n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<?>) key2).get();\n+        return key1 == key2;\n+    }\n+\n+    /**\n+     * Compares two values for equals.\n+     * <p>\n+     * This implementation uses <code>==</code>.\n+     * \n+     * @param value1  the first value to compare passed in from outside\n+     * @param value2  the second value extracted from the entry via <code>getValue()</code>\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualValue(Object value1, Object value2) {\n+        return value1 == value2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/ReferenceMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * A <code>Map</code> implementation that allows mappings to be\n+ * removed by the garbage collector.\n+ * <p>\n+ * When you construct a <code>ReferenceMap</code>, you can specify what kind\n+ * of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link java.lang.ref.Reference Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The keys can be configured to be weak but the values hard,\n+ * in which case this class will behave like a\n+ * <a href=\"http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html\">\n+ * <code>WeakHashMap</code></a>. However, you can also specify hard keys and\n+ * weak values, or any other combination. The default constructor uses\n+ * hard keys and soft values, providing a memory-sensitive cache.\n+ * <p>\n+ * This map is similar to\n+ * {@link org.apache.commons.collections.map.ReferenceIdentityMap ReferenceIdentityMap}.\n+ * It differs in that keys and values in this class are compared using <code>equals()</code>.\n+ * <p>\n+ * This {@link java.util.Map Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to \n+ * provide synchronized access to a <code>ReferenceMap</code>.\n+ * Remember that synchronization will not stop the garbage collecter removing entries.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * <strong>Note that ReferenceMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * NOTE: As from Commons Collections 3.1 this map extends <code>AbstractReferenceMap</code>\n+ * (previously it extended AbstractMap). As a result, the implementation is now\n+ * extensible and provides a <code>MapIterator</code>.\n+ *\n+ * @see java.lang.ref.Reference\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v2.1)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class ReferenceMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1555089888138299607L;\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use hard references to keys and soft references to values.\n+     */\n+    public ReferenceMap() {\n+        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n+                DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     */\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param purgeValues should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, boolean purgeValues) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> with the\n+     * specified reference types, load factor and initial\n+     * capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     */\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n+            float loadFactor) {\n+        super(keyType, valueType, capacity, loadFactor, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> with the\n+     * specified reference types, load factor and initial\n+     * capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n+            float loadFactor, boolean purgeValues) {\n+        super(keyType, valueType, capacity, loadFactor, purgeValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/SingletonMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.Serializable;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.iterators.SingletonIterator;\n+import org.apache.commons.collections.keyvalue.TiedMapEntry;\n+\n+/**\n+ * A <code>Map</code> implementation that holds a single item and is fixed size.\n+ * <p>\n+ * The single key/value pair is specified at creation.\n+ * The map is fixed size so any action that would change the size is disallowed.\n+ * However, the <code>put</code> or <code>setValue</code> methods can <i>change</i>\n+ * the value associated with the key.\n+ * <p>\n+ * If trying to remove or clear the map, an UnsupportedOperationException is thrown.\n+ * If trying to put a new mapping into the map, an  IllegalArgumentException is thrown.\n+ * The put method will only suceed if the key specified is the same as the \n+ * singleton key.\n+ * <p>\n+ * The key and value can be obtained by:\n+ * <ul>\n+ * <li>normal Map methods and views\n+ * <li>the <code>MapIterator</code>, see {@link #mapIterator()}\n+ * <li>the <code>KeyValue</code> interface (just cast - no object creation)\n+ * </ul>\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SingletonMap<K, V>\n+        implements OrderedMap<K, V>, BoundedMap<K, V>, KeyValue<K, V>, Serializable, Cloneable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8931271118676803261L;\n+\n+    /** Singleton key */\n+    private final K key;\n+    /** Singleton value */\n+    private V value;\n+\n+    /**\n+     * Constructor that creates a map of <code>null</code> to <code>null</code>.\n+     */\n+    public SingletonMap() {\n+        super();\n+        this.key = null;\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value.\n+     *\n+     * @param key  the key to use\n+     * @param value  the value to use\n+     */\n+    public SingletonMap(K key, V value) {\n+        super();\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value as a <code>KeyValue</code>.\n+     *\n+     * @param keyValue  the key value pair to use\n+     */\n+    public SingletonMap(KeyValue<K, V> keyValue) {\n+        super();\n+        this.key = keyValue.getKey();\n+        this.value = keyValue.getValue();\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value as a <code>MapEntry</code>.\n+     *\n+     * @param mapEntry  the mapEntry to use\n+     */\n+    public SingletonMap(Map.Entry<K, V> mapEntry) {\n+        super();\n+        this.key = mapEntry.getKey();\n+        this.value = mapEntry.getValue();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy, must be size 1\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the size is not 1\n+     */\n+    public SingletonMap(Map<K, V> map) {\n+        super();\n+        if (map.size() != 1) {\n+            throw new IllegalArgumentException(\"The map size must be 1\");\n+        }\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        this.key = entry.getKey();\n+        this.value = entry.getValue();\n+    }\n+\n+    // KeyValue\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key.\n+     *\n+     * @return the key \n+     */\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Gets the value.\n+     *\n+     * @return the value\n+     */\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Sets the value.\n+     *\n+     * @param value  the new value to set\n+     * @return the old value\n+     */\n+    public V setValue(V value) {\n+        V old = this.value;\n+        this.value = value;\n+        return old;\n+    }\n+\n+    // BoundedMap\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is the map currently full, always true.\n+     *\n+     * @return true always\n+     */\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the maximum size of the map, always 1.\n+     * \n+     * @return 1 always\n+     */\n+    public int maxSize() {\n+        return 1;\n+    }\n+\n+    // Map\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(Object key) {\n+        if (isEqualKey(key)) {\n+            return value;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map, always 1.\n+     * \n+     * @return the size of 1\n+     */\n+    public int size() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty, which it never is.\n+     * \n+     * @return false always\n+     */\n+    public boolean isEmpty() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     * \n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        return (isEqualKey(key));\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsValue(Object value) {\n+        return (isEqualValue(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map where the key must match the existing key.\n+     * <p>\n+     * An IllegalArgumentException is thrown if the key does not match as the map\n+     * is fixed size.\n+     * \n+     * @param key  the key to set, must be the key of the map\n+     * @param value  the value to set\n+     * @return the value previously mapped to this key, null if none\n+     * @throws IllegalArgumentException if the key does not match\n+     */\n+    public V put(K key, V value) {\n+        if (isEqualKey(key)) {\n+            return setValue(value);\n+        }\n+        throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size singleton\");\n+    }\n+\n+    /**\n+     * Puts the values from the specified map into this map.\n+     * <p>\n+     * The map must be of size 0 or size 1.\n+     * If it is size 1, the key must match the key of this map otherwise an\n+     * IllegalArgumentException is thrown.\n+     * \n+     * @param map  the map to add, must be size 0 or 1, and the key must match\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the key does not match\n+     */\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        switch (map.size()) {\n+            case 0:\n+                return;\n+\n+            case 1:\n+                Map.Entry<? extends K, ? extends V> entry = map.entrySet().iterator().next();\n+                put(entry.getKey(), entry.getValue());\n+                return;\n+\n+            default:\n+                throw new IllegalArgumentException(\"The map size must be 0 or 1\");\n+        }\n+    }\n+    \n+    /**\n+     * Unsupported operation.\n+     * \n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     * @throws UnsupportedOperationException always\n+     */\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Unsupported operation.\n+     */\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made via <code>setValue</code> affect this map.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     * \n+     * @return the entrySet view\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Map.Entry<K, V> entry = new TiedMapEntry<K, V>(this, getKey());\n+        return Collections.singleton(entry);\n+    }\n+    \n+    /**\n+     * Gets the unmodifiable keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     * \n+     * @return the keySet view\n+     */\n+    public Set<K> keySet() {\n+        return Collections.singleton(key);\n+    }\n+\n+    /**\n+     * Gets the unmodifiable values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     * \n+     * @return the values view\n+     */\n+    public Collection<V> values() {\n+        return new SingletonValues<V>(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new SingletonMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Gets the first (and only) key in the map.\n+     * \n+     * @return the key\n+     */\n+    public K firstKey() {\n+        return getKey();\n+    }\n+\n+    /**\n+     * Gets the last (and only) key in the map.\n+     * \n+     * @return the key\n+     */\n+    public K lastKey() {\n+        return getKey();\n+    }\n+\n+    /**\n+     * Gets the next key after the key specified, always null.\n+     * \n+     * @param key  the next key\n+     * @return null always\n+     */\n+    public K nextKey(K key) {\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous key before the key specified, always null.\n+     * \n+     * @param key  the next key\n+     * @return null always\n+     */\n+    public K previousKey(K key) {\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares the specified key to the stored key.\n+     * \n+     * @param key  the key to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualKey(Object key) {\n+        return (key == null ? getKey() == null : key.equals(getKey()));\n+    }\n+\n+    /**\n+     * Compares the specified value to the stored value.\n+     * \n+     * @param value  the value to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(Object value) {\n+        return (value == null ? getValue() == null : value.equals(getValue()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * SingletonMapIterator.\n+     */\n+    static class SingletonMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+        private final SingletonMap<K, V> parent;\n+        private boolean hasNext = true;\n+        private boolean canGetSet = false;\n+        \n+        SingletonMapIterator(SingletonMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        public boolean hasNext() {\n+            return hasNext;\n+        }\n+\n+        public K next() {\n+            if (hasNext == false) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            hasNext = false;\n+            canGetSet = true;\n+            return parent.getKey();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (hasNext == false);\n+        }\n+\n+        public K previous() {\n+            if (hasNext == true) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n+            }\n+            hasNext = true;\n+            return parent.getKey();\n+        }\n+\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public K getKey() {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return parent.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return parent.getValue();\n+        }\n+\n+        public V setValue(V value) {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return parent.setValue(value);\n+        }\n+        \n+        public void reset() {\n+            hasNext = true;\n+        }\n+        \n+        @Override\n+        public String toString() {\n+            if (hasNext) {\n+                return \"Iterator[]\";\n+            }\n+            return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+        }\n+    }\n+    \n+    /**\n+     * Values implementation for the SingletonMap.\n+     * This class is needed as values is a view that must update as the map updates.\n+     */\n+    static class SingletonValues<V> extends AbstractSet<V> implements Serializable {\n+        private static final long serialVersionUID = -3689524741863047872L;\n+        private final SingletonMap<?, V> parent;\n+\n+        SingletonValues(SingletonMap<?, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return 1;\n+        }\n+        @Override\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+        @Override\n+        public boolean contains(Object object) {\n+            return parent.containsValue(object);\n+        }\n+        @Override\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new SingletonIterator<V>(parent.getValue(), false);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the key or value.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonMap<K, V> clone() {\n+        try {\n+            return (SingletonMap<K, V>) super.clone();\n+        } catch (CloneNotSupportedException ex) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Compares this map with another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map<?,?> other = (Map<?,?>) obj;\n+        if (other.size() != 1) {\n+            return false;\n+        }\n+        Map.Entry<?,?> entry = other.entrySet().iterator().next();\n+        return isEqualKey(entry.getKey()) && isEqualValue(entry.getValue());\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     * \n+     * @return the hash code defined in the Map interface\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (getValue() == null ? 0 : getValue().hashCode()); \n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     * \n+     * @return a string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(128)\n+            .append('{')\n+            .append((getKey() == this ? \"(this Map)\" : getKey()))\n+            .append('=')\n+            .append((getValue() == this ? \"(this Map)\" : getValue()))\n+            .append('}')\n+            .toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/StaticBucketMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * A StaticBucketMap is an efficient, thread-safe implementation of\n+ * <code>java.util.Map</code> that performs well in in a highly\n+ * thread-contentious environment.  The map supports very efficient\n+ * {@link #get(Object) get}, {@link #put(Object,Object) put}, \n+ * {@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\n+ * operations, assuming (approximate) uniform hashing and\n+ * that the number of entries does not exceed the number of buckets.  If the\n+ * number of entries exceeds the number of buckets or if the hash codes of the\n+ * objects are not uniformly distributed, these operations have a worst case\n+ * scenario that is proportional to the number of elements in the map\n+ * (<i>O(n)</i>).<p>\n+ *\n+ * Each bucket in the hash table has its own monitor, so two threads can \n+ * safely operate on the map at the same time, often without incurring any \n+ * monitor contention.  This means that you don't have to wrap instances\n+ * of this class with {@link java.util.Collections#synchronizedMap(Map)};\n+ * instances are already thread-safe.  Unfortunately, however, this means \n+ * that this map implementation behaves in ways you may find disconcerting.  \n+ * Bulk operations, such as {@link #putAll(Map) putAll} or the\n+ * {@link Collection#retainAll(Collection) retainAll} operation in collection \n+ * views, are <i>not</i> atomic.  If two threads are simultaneously \n+ * executing \n+ *\n+ * <pre>\n+ *   staticBucketMapInstance.putAll(map);\n+ * </pre>\n+ *\n+ * and\n+ *\n+ * <pre>\n+ *   staticBucketMapInstance.entrySet().removeAll(map.entrySet());\n+ * </pre>\n+ *\n+ * then the results are generally random.  Those two statement could cancel\n+ * each other out, leaving <code>staticBucketMapInstance</code> essentially \n+ * unchanged, or they could leave some random subset of <code>map</code> in \n+ * <code>staticBucketMapInstance</code>.<p>\n+ *\n+ * Also, much like an encyclopedia, the results of {@link #size()} and \n+ * {@link #isEmpty()} are out-of-date as soon as they are produced.<p>\n+ *\n+ * The iterators returned by the collection views of this class are <i>not</i>\n+ * fail-fast.  They will <i>never</i> raise a \n+ * {@link java.util.ConcurrentModificationException}.  Keys and values \n+ * added to the map after the iterator is created do not necessarily appear\n+ * during iteration.  Similarly, the iterator does not necessarily fail to \n+ * return keys and values that were removed after the iterator was created.<p>\n+ *\n+ * Finally, unlike {@link java.util.HashMap}-style implementations, this\n+ * class <i>never</i> rehashes the map.  The number of buckets is fixed \n+ * at construction time and never altered.  Performance may degrade if \n+ * you do not allocate enough buckets upfront.<p>\n+ *\n+ * The {@link #atomic(Runnable)} method is provided to allow atomic iterations\n+ * and bulk operations; however, overuse of {@link #atomic(Runnable) atomic}\n+ * will basically result in a map that's slower than an ordinary synchronized\n+ * {@link java.util.HashMap}.\n+ *\n+ * Use this class if you do not require reliable bulk operations and \n+ * iterations, or if you can make your own guarantees about how bulk \n+ * operations will affect the map.<p>\n+ *\n+ * @since Commons Collections 3.0 (previously in main package v2.1)\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Berin Loritsch\n+ * @author Gerhard Froehlich\n+ * @author Michael A. Smith\n+ * @author Paul Jack\n+ * @author Leo Sutic\n+ * @author Janek Bogucki\n+ * @author Kazuya Ujihara\n+ */\n+public final class StaticBucketMap<K, V> extends AbstractIterableMap<K, V> {\n+\n+    /** The default number of buckets to use */\n+    private static final int DEFAULT_BUCKETS = 255;\n+    /** The array of buckets, where the actual data is held */\n+    private final Node<K, V>[] buckets;\n+    /** The matching array of locks */\n+    private final Lock[] locks;\n+\n+    /**\n+     * Initializes the map with the default number of buckets (255).\n+     */\n+    public StaticBucketMap() {\n+        this(DEFAULT_BUCKETS);\n+    }\n+\n+    /**\n+     * Initializes the map with a specified number of buckets.  The number\n+     * of buckets is never below 17, and is always an odd number (StaticBucketMap\n+     * ensures this). The number of buckets is inversely proportional to the\n+     * chances for thread contention.  The fewer buckets, the more chances for\n+     * thread contention.  The more buckets the fewer chances for thread\n+     * contention.\n+     *\n+     * @param numBuckets  the number of buckets for this map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public StaticBucketMap(int numBuckets) {\n+        int size = Math.max(17, numBuckets);\n+\n+        // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n+        if (size % 2 == 0) {\n+            size--;\n+        }\n+\n+        buckets = new Node[size];\n+        locks = new Lock[size];\n+\n+        for (int i = 0; i < size; i++) {\n+            locks[i] = new Lock();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determine the exact hash entry for the key.  The hash algorithm\n+     * is rather simplistic, but it does the job:\n+     *\n+     * <pre>\n+     *   He = |Hk mod n|\n+     * </pre>\n+     *\n+     * <p>\n+     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n+     *   the number of buckets.\n+     * </p>\n+     */\n+    private final int getHash(Object key) {\n+        if (key == null) {\n+            return 0;\n+        }\n+        int hash = key.hashCode();\n+        hash += ~(hash << 15);\n+        hash ^= (hash >>> 10);\n+        hash += (hash << 3);\n+        hash ^= (hash >>> 6);\n+        hash += ~(hash << 11);\n+        hash ^= (hash >>> 16);\n+        hash %= buckets.length;\n+        return (hash < 0) ? hash * -1 : hash;\n+    }\n+\n+    /**\n+     * Gets the current size of the map.\n+     * The value is computed fresh each time the method is called.\n+     * \n+     * @return the current size\n+     */\n+    public int size() {\n+        int cnt = 0;\n+\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized(locks[i]) {\n+                cnt += locks[i].size;\n+            }\n+        }\n+        return cnt;\n+    }\n+\n+    /**\n+     * Checks if the size is currently zero.\n+     * \n+     * @return true if empty\n+     */\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    /**\n+     * Gets the value associated with the key.\n+     * \n+     * @param key  the key to retrieve\n+     * @return the associated value\n+     */\n+    public V get(final Object key) {\n+        int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    return n.value;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks if the map contains the specified key.\n+     * \n+     * @param key  the key to check\n+     * @return true if found\n+     */\n+    public boolean containsKey(final Object key) {\n+        int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    return true;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the map contains the specified value.\n+     * \n+     * @param value  the value to check\n+     * @return true if found\n+     */\n+    public boolean containsValue(final Object value) {\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized (locks[i]) {\n+                Node<K, V> n = buckets[i];\n+\n+                while (n != null) {\n+                    if (n.value == value || (n.value != null && n.value.equals(value))) {\n+                        return true;\n+                    }\n+\n+                    n = n.next;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a new key value mapping into the map.\n+     * \n+     * @param key  the key to use\n+     * @param value  the value to use\n+     * @return the previous mapping for the key\n+     */\n+    public V put(final K key, final V value) {\n+        int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+\n+            if (n == null) {\n+                n = new Node<K, V>();\n+                n.key = key;\n+                n.value = value;\n+                buckets[hash] = n;\n+                locks[hash].size++;\n+                return null;\n+            }\n+\n+            // Set n to the last node in the linked list.  Check each key along the way\n+            //  If the key is found, then change the value of that node and return\n+            //  the old value.\n+            for (Node<K, V> next = n; next != null; next = next.next) {\n+                n = next;\n+\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    V returnVal = n.value;\n+                    n.value = value;\n+                    return returnVal;\n+                }\n+            }\n+\n+            // The key was not found in the current list of nodes, add it to the end\n+            //  in a new node.\n+            Node<K, V> newNode = new Node<K, V>();\n+            newNode.key = key;\n+            newNode.value = value;\n+            n.next = newNode;\n+            locks[hash].size++;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified key from the map.\n+     * \n+     * @param key  the key to remove\n+     * @return the previous value at this key\n+     */\n+    public V remove(Object key) {\n+        int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+            Node<K, V> prev = null;\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    // Remove this node from the linked list of nodes.\n+                    if (null == prev) {\n+                        // This node was the head, set the next node to be the new head.\n+                        buckets[hash] = n.next;\n+                    } else {\n+                        // Set the next node of the previous node to be the node after this one.\n+                        prev.next = n.next;\n+                    }\n+                    locks[hash].size--;\n+                    return n.value;\n+                }\n+\n+                prev = n;\n+                n = n.next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key set.\n+     * \n+     * @return the key set\n+     */\n+    public Set<K> keySet() {\n+        return new KeySet();\n+    }\n+\n+    /**\n+     * Gets the values.\n+     * \n+     * @return the values\n+     */\n+    public Collection<V> values() {\n+        return new Values();\n+    }\n+\n+    /**\n+     * Gets the entry set.\n+     * \n+     * @return the entry set\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return new EntrySet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts all the entries from the specified map into this map.\n+     * This operation is <b>not atomic</b> and may have undesired effects.\n+     * \n+     * @param map  the map of entries to add\n+     */\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Clears the map of all entries.\n+     */\n+    public void clear() {\n+        for (int i = 0; i < buckets.length; i++) {\n+            Lock lock = locks[i];\n+            synchronized (lock) {\n+                buckets[i] = null;\n+                lock.size = 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Compares this map to another, as per the Map specification.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map<?, ?> == false) {\n+            return false;\n+        }\n+        Map<?, ?> other = (Map<?, ?>) obj;\n+        return entrySet().equals(other.entrySet());\n+    }\n+\n+    /**\n+     * Gets the hash code, as per the Map specification.\n+     * \n+     * @return the hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 0;\n+\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized (locks[i]) {\n+                Node<K, V> n = buckets[i];\n+\n+                while (n != null) {\n+                    hashCode += n.hashCode();\n+                    n = n.next;\n+                }\n+            }\n+        }\n+        return hashCode;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The Map.Entry for the StaticBucketMap.\n+     */\n+    private static final class Node<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n+        protected K key;\n+        protected V value;\n+        protected Node<K, V> next;\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return ((key == null ? 0 : key.hashCode()) ^\n+                    (value == null ? 0 : value.hashCode()));\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry<?, ?> == false) {\n+                return false;\n+            }\n+\n+            Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n+            return (\n+                (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n+                (value == null ? e2.getValue() == null : value.equals(e2.getValue())));\n+        }\n+\n+        public V setValue(V obj) {\n+            V retVal = value;\n+            value = obj;\n+            return retVal;\n+        }\n+    }\n+\n+    /**\n+     * The lock object, which also includes a count of the nodes in this lock.\n+     */\n+    private final static class Lock {\n+        public int size;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private class BaseIterator {\n+        private ArrayList<Map.Entry<K, V>> current = new ArrayList<Map.Entry<K,V>>();\n+        private int bucket;\n+        private Map.Entry<K, V> last;\n+\n+        public boolean hasNext() {\n+            if (current.size() > 0) return true;\n+            while (bucket < buckets.length) {\n+                synchronized (locks[bucket]) {\n+                    Node<K, V> n = buckets[bucket];\n+                    while (n != null) {\n+                        current.add(n);\n+                        n = n.next;\n+                    }\n+                    bucket++;\n+                    if (current.size() > 0) return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        protected Map.Entry<K, V> nextEntry() {\n+            if (!hasNext()) throw new NoSuchElementException();\n+            last = current.remove(current.size() - 1);\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (last == null) throw new IllegalStateException();\n+            StaticBucketMap.this.remove(last.getKey());\n+            last = null;\n+        }\n+    }\n+\n+    private class EntryIterator extends BaseIterator implements Iterator<Map.Entry<K, V>> {\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+    }\n+\n+    private class ValueIterator extends BaseIterator implements Iterator<V> {\n+\n+        public V next() {\n+            return nextEntry().getValue();\n+        }\n+\n+    }\n+\n+    private class KeyIterator extends BaseIterator implements Iterator<K> {\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+\n+    }\n+\n+    private class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n+\n+        @Override\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return new EntryIterator();\n+        }\n+\n+        @Override\n+        public boolean contains(Object obj) {\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            int hash = getHash(entry.getKey());\n+            synchronized (locks[hash]) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry<?, ?> == false) {\n+                return false;\n+            }\n+            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            int hash = getHash(entry.getKey());\n+            synchronized (locks[hash]) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) {\n+                        StaticBucketMap.this.remove(n.getKey());\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    }\n+\n+    private class KeySet extends AbstractSet<K> {\n+\n+        @Override\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new KeyIterator();\n+        }\n+\n+        @Override\n+        public boolean contains(Object obj) {\n+            return StaticBucketMap.this.containsKey(obj);\n+        }\n+\n+        @Override\n+        public boolean remove(Object obj) {\n+            int hash = getHash(obj);\n+            synchronized (locks[hash]) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n+                    Object k = n.getKey();\n+                    if ((k == obj) || ((k != null) && k.equals(obj))) {\n+                        StaticBucketMap.this.remove(k);\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    private class Values extends AbstractCollection<V> {\n+\n+        @Override\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new ValueIterator();\n+        }\n+\n+    }\n+\n+    /**\n+     *  Prevents any operations from occurring on this map while the\n+     *  given {@link Runnable} executes.  This method can be used, for\n+     *  instance, to execute a bulk operation atomically: \n+     *\n+     *  <pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            staticBucketMapInstance.putAll(map);\n+     *        }\n+     *    });\n+     *  </pre>\n+     *\n+     *  It can also be used if you need a reliable iterator:\n+     *\n+     *  <pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            Iterator iterator = staticBucketMapInstance.iterator();\n+     *            while (iterator.hasNext()) {\n+     *                foo(iterator.next();\n+     *            }\n+     *        }\n+     *    });\n+     *  </pre>\n+     *\n+     *  <b>Implementation note:</b> This method requires a lot of time\n+     *  and a ton of stack space.  Essentially a recursive algorithm is used\n+     *  to enter each bucket's monitor.  If you have twenty thousand buckets\n+     *  in your map, then the recursive method will be invoked twenty thousand\n+     *  times.  You have been warned.\n+     *\n+     *  @param r  the code to execute atomically\n+     */\n+    public void atomic(Runnable r) {\n+        if (r == null) throw new NullPointerException();\n+        atomic(r, 0);\n+    }\n+\n+    private void atomic(Runnable r, int bucket) {\n+        if (bucket >= buckets.length) {\n+            r.run();\n+            return;\n+        }\n+        synchronized (locks[bucket]) {\n+            atomic(r, bucket + 1);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/TransformedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Decorates another <code>Map</code> to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * @see org.apache.commons.collections.splitmap.TransformedMap\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedMap<K, V>\n+        extends AbstractInputCheckedMapDecorator<K, V>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7023152376788900464L;\n+\n+    /** The transformer to use for the key */\n+    protected final Transformer<? super K, ? extends K> keyTransformer;\n+    /** The transformer to use for the value */\n+    protected final Transformer<? super V, ? extends V> valueTransformer;\n+\n+    /**\n+     * Factory method to create a transforming map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n+     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> IterableMap<K, V> transformingMap(Map<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming map that will transform\n+     * existing contents of the specified map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n+     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @throws IllegalArgumentException if map is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <K, V> Map<K, V> transformedMap(Map<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n+        if (map.size() > 0) {\n+            Map<K, V> transformed = decorated.transformMap(map);\n+            decorated.clear();\n+            decorated.decorated().putAll(transformed);  // avoids double transformation\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n+     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected TransformedMap(Map<K, V> map, Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        super(map);\n+        this.keyTransformer = keyTransformer;\n+        this.valueTransformer = valueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms a key.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object  the object to transform\n+     * @throws the transformed object\n+     */\n+    protected K transformKey(K object) {\n+        if (keyTransformer == null) {\n+            return object;\n+        }\n+        return keyTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a value.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object  the object to transform\n+     * @throws the transformed object\n+     */\n+    protected V transformValue(V object) {\n+        if (valueTransformer == null) {\n+            return object;\n+        }\n+        return valueTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a map.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map  the map to transform\n+     * @throws the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(Map<? extends K, ? extends V> map) {\n+        if (map.isEmpty()) {\n+            return (Map<K, V>) map;\n+        }\n+        Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Override to transform the value when using <code>setValue</code>.\n+     *\n+     * @param value  the value to transform\n+     * @return the transformed value\n+     * @since Commons Collections 3.1\n+     */\n+    @Override\n+    protected V checkSetValue(V value) {\n+        return valueTransformer.transform(value);\n+    }\n+\n+    /**\n+     * Override to only return true when there is a value transformer.\n+     *\n+     * @return true if a value transformer is in use\n+     * @since Commons Collections 3.1\n+     */\n+    @Override\n+    protected boolean isSetValueChecking() {\n+        return (valueTransformer != null);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(K key, V value) {\n+        key = transformKey(key);\n+        value = transformValue(value);\n+        return decorated().put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        mapToCopy = transformMap(mapToCopy);\n+        decorated().putAll(mapToCopy);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/TransformedSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Decorates another <code>SortedMap </code> to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedSortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedSortedMap<K, V>\n+        extends TransformedMap<K, V>\n+        implements SortedMap<K, V> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8751771676410385778L;\n+    \n+    /**\n+     * Factory method to create a transforming sorted map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the predicate to validate the keys, null means no transformation\n+     * @param valueTransformer  the predicate to validate to values, null means no transformation\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <K, V> SortedMap<K, V> transformingSortedMap(SortedMap<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming sorted map that will transform\n+     * existing contents of the specified map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n+     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @throws IllegalArgumentException if map is null\n+     * @since Commons Collections 3.2\n+     */\n+    public static <K, V> SortedMap<K, V> transformedSortedMap(SortedMap<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+        if (map.size() > 0) {\n+            Map<K, V> transformed = decorated.transformMap(map);\n+            decorated.clear();\n+            decorated.decorated().putAll(transformed);  // avoids double transformation\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.</p>\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the predicate to validate the keys, null means no transformation\n+     * @param valueTransformer  the predicate to validate to values, null means no transformation\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected TransformedSortedMap(SortedMap<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        super(map, keyTransformer, valueTransformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return getSortedMap().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return getSortedMap().lastKey();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return getSortedMap().comparator();\n+    }\n+\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    public SortedMap<K, V> headMap(K toKey) {\n+        SortedMap<K, V> map = getSortedMap().headMap(toKey);\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.keyvalue.AbstractMapEntryDecorator;\n+import org.apache.commons.collections.set.AbstractSetDecorator;\n+\n+/**\n+ * Decorates a map entry <code>Set</code> to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableEntrySet<K, V>\n+        extends AbstractSetDecorator<Map.Entry<K, V>> implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1678353579659253473L;\n+\n+    /**\n+     * Factory method to create an unmodifiable set of Map Entry objects.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(Set<Map.Entry<K, V>> set) {\n+        if (set instanceof Unmodifiable) {\n+            return set;\n+        }\n+        return new UnmodifiableEntrySet<K, V>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    private UnmodifiableEntrySet(Set<Map.Entry<K, V>> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(Map.Entry<K, V> object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends Map.Entry<K, V>> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<Map.Entry<K, V>> iterator() {\n+        return new UnmodifiableEntrySetIterator(collection.iterator());\n+    }\n+    \n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Object[] toArray() {\n+        Object[] array = collection.toArray();\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = new UnmodifiableEntry((Map.Entry<K, V>) array[i]);\n+        }\n+        return array;\n+    }\n+    \n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n+        Object[] result = array;\n+        if (array.length > 0) {\n+            // we must create a new array to handle multi-threaded situations\n+            // where another thread could access data before we decorate it\n+            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+        }\n+        result = collection.toArray(result);\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = new UnmodifiableEntry((Map.Entry<K, V>) result[i]);\n+        }\n+\n+        // check to see if result should be returned straight\n+        if (result.length > array.length) {\n+            return (T[]) result;\n+        }\n+\n+        // copy back into input array to fulfill the method contract\n+        System.arraycopy(result, 0, array, 0, result.length);\n+        if (array.length > result.length) {\n+            array[result.length] = null;\n+        }\n+        return array;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set iterator.\n+     */\n+    private class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n+        protected UnmodifiableEntrySetIterator(Iterator<Map.Entry<K, V>> iterator) {\n+            super(iterator);\n+        }\n+\n+        @Override\n+        public Map.Entry<K, V> next() {\n+            return new UnmodifiableEntry(iterator.next());\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of a map entry that is unmodifiable.\n+     */\n+    private class UnmodifiableEntry extends AbstractMapEntryDecorator<K, V> {\n+\n+        protected UnmodifiableEntry(Map.Entry<K, V> entry) {\n+            super(entry);\n+        }\n+\n+        @Override\n+        public V setValue(V obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.EntrySetMapIterator;\n+import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>Map</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements IterableMap<K, V>, Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2737023427269031941L;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableMap(Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        if (map instanceof IterableMap) {\n+            MapIterator<K, V> it = ((IterableMap<K, V>) map).mapIterator();\n+            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+        }\n+        MapIterator<K, V> it = new EntrySetMapIterator<K, V>(map);\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableOrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableOrderedMapIterator;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>OrderedMap</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableOrderedMap<K, V> extends AbstractOrderedMapDecorator<K, V> implements\n+        Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8136428161720526266L;\n+\n+    /**\n+     * Factory method to create an unmodifiable sorted map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(OrderedMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableOrderedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableOrderedMap(OrderedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another <code>SortedMap</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableSortedMap<K, V>\n+        extends AbstractSortedMapDecorator<K, V>\n+        implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5805344239827376360L;\n+\n+    /**\n+     * Factory method to create an unmodifiable sorted map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableSortedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableSortedMap(SortedMap<K, V> map) {\n+        super(map);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since Commons Collections 3.1\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(super.entrySet());\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        return UnmodifiableSet.unmodifiableSet(super.keySet());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        return UnmodifiableCollection.unmodifiableCollection(super.values());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    @Override\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    @Override\n+    public Comparator<? super K> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return new UnmodifiableSortedMap<K, V>(decorated().subMap(fromKey, toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return new UnmodifiableSortedMap<K, V>(decorated().headMap(toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return new UnmodifiableSortedMap<K, V>(decorated().tailMap(fromKey));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/AbstractSerializableSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Set;\n+\n+/**\n+ * Serializable subclass of AbstractSetDecorator.\n+ *\n+ * @author Stephen Colebourne\n+ * @since Commons Collections 3.1\n+ */\n+public abstract class AbstractSerializableSetDecorator<E>\n+        extends AbstractSetDecorator<E>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1229469966212206107L;\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractSerializableSetDecorator(Set<E> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the set out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the set in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/AbstractSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another <code>Set</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated set.\n+ *\n+ * @param <E> the type of the elements in the set\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractSetDecorator<E> extends AbstractCollectionDecorator<E> implements\n+        Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4678668309576958546L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractSetDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected AbstractSetDecorator(Set<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Gets the set being decorated.\n+     * \n+     * @return the decorated set\n+     */\n+    @Override\n+    protected Set<E> decorated() {\n+        return (Set<E>) super.decorated();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/AbstractSortedSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated set.\n+ *\n+ * @param <E> the type of the elements in the sorted set\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractSortedSetDecorator<E>\n+        extends AbstractSetDecorator<E>\n+        implements SortedSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3462240946294214398L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since Commons Collections 3.1\n+     */\n+    protected AbstractSortedSetDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected AbstractSortedSetDecorator(Set<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Gets the set being decorated.\n+     * \n+     * @return the decorated set\n+     */\n+    @Override\n+    protected SortedSet<E> decorated() {\n+        return (SortedSet<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedSet<E> subSet(E fromElement, E toElement) {\n+        return decorated().subSet(fromElement, toElement);\n+    }\n+\n+    public SortedSet<E> headSet(E toElement) {\n+        return decorated().headSet(toElement);\n+    }\n+\n+    public SortedSet<E> tailSet(E fromElement) {\n+        return decorated().tailSet(fromElement);\n+    }\n+\n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/CompositeSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.collection.CompositeCollection;\n+\n+/**\n+ * Decorates a set of other sets to provide a single unified view.\n+ * <p>\n+ * Changes made to this set will actually be made on the decorated set.\n+ * Add operations require the use of a pluggable strategy.\n+ * If no strategy is provided then add is unsupported.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Brian McCallister\n+ */\n+public class CompositeSet<E> extends CompositeCollection<E> implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5185069727540378940L;\n+\n+    /**\n+     * Create an empty CompositeSet\n+     */\n+    public CompositeSet() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a CompositeSet with just <code>set</code> composited\n+     * @param set The initial set in the composite\n+     */\n+    public CompositeSet(Set<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Create a composite set with sets as the initial set of composited Sets\n+     */\n+    public CompositeSet(Set<E>... sets) {\n+        super(sets);\n+    }\n+\n+    /**\n+     * Add a Set to this composite\n+     *\n+     * @param c Must implement Set\n+     * @throws IllegalArgumentException if c does not implement java.util.Set\n+     *         or if a SetMutator is set, but fails to resolve a collision\n+     * @throws UnsupportedOperationException if there is no SetMutator set, or\n+     *         a CollectionMutator is set instead of a SetMutator\n+     * @see org.apache.commons.collections.collection.CompositeCollection.CollectionMutator\n+     * @see SetMutator\n+     */\n+    @Override\n+    public synchronized void addComposited(Collection<E> c) {\n+        if (!(c instanceof Set)) {\n+            throw new IllegalArgumentException(\"Collections added must implement java.util.Set\");\n+        }\n+\n+        for (Set<E> set : getCollections()) {\n+            Collection<E> intersects = CollectionUtils.intersection(set, c);\n+            if (intersects.size() > 0) {\n+                if (this.mutator == null) {\n+                    throw new UnsupportedOperationException(\n+                        \"Collision adding composited collection with no SetMutator set\");\n+                }\n+                else if (!(this.mutator instanceof SetMutator)) {\n+                    throw new UnsupportedOperationException(\n+                        \"Collision adding composited collection to a CompositeSet with a CollectionMutator instead of a SetMutator\");\n+                }\n+                getMutator().resolveCollision(this, set, (Set<E>) c, intersects);\n+                if (CollectionUtils.intersection(set, c).size() > 0) {\n+                    throw new IllegalArgumentException(\n+                        \"Attempt to add illegal entry unresolved by SetMutator.resolveCollision()\");\n+                }\n+            }\n+        }\n+        super.addComposited(c);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public List<? extends Set<E>> getCollections() {\n+        return (List<Set<E>>) super.getCollections();\n+    }\n+\n+    /**\n+     * Add two sets to this composite\n+     *\n+     * @throws IllegalArgumentException if c or d does not implement java.util.Set\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized void addComposited(Collection<E> c, Collection<E> d) {\n+        if (!(c instanceof Set)) throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n+        if (!(d instanceof Set)) throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n+        this.addComposited(new Set[] { (Set<? extends E>) c, (Set<? extends E>) d });\n+    }\n+\n+    /**\n+     * Add an array of sets to this composite\n+     * @param comps\n+     * @throws IllegalArgumentException if any of the collections in comps do not implement Set\n+     */\n+    @Override\n+    public synchronized void addComposited(Collection<E>[] comps) {\n+        for (int i = comps.length - 1; i >= 0; --i) {\n+            this.addComposited(comps[i]);\n+        }\n+    }\n+\n+    /**\n+     * This can receive either a <code>CompositeCollection.CollectionMutator</code>\n+     * or a <code>CompositeSet.SetMutator</code>. If a\n+     * <code>CompositeCollection.CollectionMutator</code> is used than conflicts when adding\n+     * composited sets will throw IllegalArgumentException\n+     * <p>\n+     */\n+    @Override\n+    public void setMutator(CollectionMutator<E> mutator) {\n+        super.setMutator(mutator);\n+    }\n+\n+    /* Set operations */\n+\n+    /**\n+     * If a <code>CollectionMutator</code> is defined for this CompositeSet then this\n+     * method will be called anyway.\n+     *\n+     * @param obj Object to be removed\n+     * @return true if the object is removed, false otherwise\n+     */\n+    @Override\n+    public boolean remove(Object obj) {\n+        for (Set<? extends E> set : getCollections()) {\n+            if (set.contains(obj)) return set.remove(obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @see Set#equals\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof Set) {\n+            Set<?> set = (Set<?>) obj;\n+            return set.containsAll(this) && set.size() == this.size();\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * @see Set#hashCode\n+     */\n+    @Override\n+    public int hashCode() {\n+        int code = 0;\n+        for (E e : this) {\n+            code += (e == null ? 0 : e.hashCode());\n+        }\n+        return code;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected SetMutator<E> getMutator() {\n+        return (SetMutator<E>) super.getMutator();\n+    }\n+\n+    /**\n+     * Define callbacks for mutation operations.\n+     * <p>\n+     * Defining remove() on implementations of SetMutator is pointless\n+     * as they are never called by CompositeSet.\n+     */\n+    public static interface SetMutator<E> extends CompositeCollection.CollectionMutator<E> {\n+\n+        /**\n+         * <p>\n+         * Called when a Set is added to the CompositeSet and there is a\n+         * collision between existing and added sets.\n+         * </p>\n+         * <p>\n+         * If <code>added</code> and <code>existing</code> still have any intersects\n+         * after this method returns an IllegalArgumentException will be thrown.\n+         * </p>\n+         * @param comp The CompositeSet being modified\n+         * @param existing The Set already existing in the composite\n+         * @param added the Set being added to the composite\n+         * @param intersects the intersection of th existing and added sets\n+         */\n+        public void resolveCollision(CompositeSet<E> comp, Set<E> existing, Set<E> added, Collection<E> intersects);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.OrderedIterator;\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.list.UnmodifiableList;\n+\n+/**\n+ * Decorates another <code>Set</code> to ensure that the order of addition\n+ * is retained and used by the iterator.\n+ * <p>\n+ * If an object is added to the set for a second time, it will remain in the\n+ * original position in the iteration.\n+ * The order can be observed from the set via the iterator or toArray methods.\n+ * <p>\n+ * The ListOrderedSet also has various useful direct methods. These include many\n+ * from <code>List</code>, such as <code>get(int)</code>, <code>remove(int)</code>\n+ * and <code>indexOf(int)</code>. An unmodifiable <code>List</code> view of\n+ * the set can be obtained via <code>asList()</code>.\n+ * <p>\n+ * This class cannot implement the <code>List</code> interface directly as\n+ * various interface methods (notably equals/hashCode) are incompatable with a set.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Henning P. Schmiedehausen\n+ */\n+public class ListOrderedSet<E> extends AbstractSerializableSetDecorator<E> implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -228664372470420141L;\n+\n+    /** Internal list to hold the sequence of objects */\n+    protected final List<E> setOrder;\n+\n+    /**\n+     * Factory method to create an ordered set specifying the list and set to use.\n+     * <p>\n+     * The list and set must both be empty.\n+     *\n+     * @param set  the set to decorate, must be empty and not null\n+     * @param list  the list to decorate, must be empty and not null\n+     * @throws IllegalArgumentException if set or list is null\n+     * @throws IllegalArgumentException if either the set or list is not empty\n+     * @since Commons Collections 3.1\n+     */\n+    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set, List<E> list) {\n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (set.size() > 0 || list.size() > 0) {\n+            throw new IllegalArgumentException(\"Set and List must be empty\");\n+        }\n+        return new ListOrderedSet<E>(set, list);\n+    }\n+\n+    /**\n+     * Factory method to create an ordered set.\n+     * <p>\n+     * An <code>ArrayList</code> is used to retain order.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set) {\n+        return new ListOrderedSet<E>(set);\n+    }\n+\n+    /**\n+     * Factory method to create an ordered set using the supplied list to retain order.\n+     * <p>\n+     * A <code>HashSet</code> is used for the set behaviour.\n+     * <p>\n+     * NOTE: If the list contains duplicates, the duplicates are removed,\n+     * altering the specified list.\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> ListOrderedSet<E> listOrderedSet(List<E> list) {\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        Set<E> set = new HashSet<E>(list);\n+        list.retainAll(set);\n+\n+        return new ListOrderedSet<E>(set, list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty <code>ListOrderedSet</code> using\n+     * a <code>HashSet</code> and an <code>ArrayList</code> internally.\n+     *\n+     * @since Commons Collections 3.1\n+     */\n+    public ListOrderedSet() {\n+        super(new HashSet<E>());\n+        setOrder = new ArrayList<E>();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected ListOrderedSet(Set<E> set) {\n+        super(set);\n+        setOrder = new ArrayList<E>(set);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies) the Set and specifies the list to use.\n+     * <p>\n+     * The set and list must both be correctly initialised to the same elements.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if set or list is null\n+     */\n+    protected ListOrderedSet(Set<E> set, List<E> list) {\n+        super(set);\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        setOrder = list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an unmodifiable view of the order of the Set.\n+     *\n+     * @return an unmodifiable list view\n+     */\n+    public List<E> asList() {\n+        return UnmodifiableList.unmodifiableList(setOrder);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        collection.clear();\n+        setOrder.clear();\n+    }\n+\n+    @Override\n+    public OrderedIterator<E> iterator() {\n+        return new OrderedSetIterator<E>(setOrder.listIterator(), collection);\n+    }\n+\n+    @Override\n+    public boolean add(E object) {\n+        if (collection.add(object)) {\n+            setOrder.add(object);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        boolean result = false;\n+        for (E e : coll) {\n+            result |= add(e);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        boolean result = collection.remove(object);\n+        setOrder.remove(object);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        boolean result = false;\n+        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n+            result |= remove(it.next());\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        boolean result = collection.retainAll(coll);\n+        if (result == false) {\n+            return false;\n+        }\n+        if (collection.size() == 0) {\n+            setOrder.clear();\n+        } else {\n+            for (Iterator<E> it = setOrder.iterator(); it.hasNext();) {\n+                if (!collection.contains(it.next())) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object[] toArray() {\n+        return setOrder.toArray();\n+    }\n+\n+    @Override\n+    public <T> T[] toArray(T a[]) {\n+        return setOrder.toArray(a);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E get(int index) {\n+        return setOrder.get(index);\n+    }\n+\n+    public int indexOf(Object object) {\n+        return setOrder.indexOf(object);\n+    }\n+\n+    public void add(int index, E object) {\n+        if (!contains(object)) {\n+            collection.add(object);\n+            setOrder.add(index, object);\n+        }\n+    }\n+\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        boolean changed = false;\n+        for (E e : coll) {\n+            if (contains(e)) {\n+                continue;\n+            }\n+            collection.add(e);\n+            setOrder.add(index++, e);\n+            changed = true;\n+        }\n+        return changed;\n+    }\n+\n+    public Object remove(int index) {\n+        Object obj = setOrder.remove(index);\n+        remove(obj);\n+        return obj;\n+    }\n+\n+    /**\n+     * Uses the underlying List's toString so that order is achieved.\n+     * This means that the decorated Set's toString is not used, so\n+     * any custom toStrings will be ignored.\n+     */\n+    // Fortunately List.toString and Set.toString look the same\n+    @Override\n+    public String toString() {\n+        return setOrder.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal iterator handle remove.\n+     */\n+    static class OrderedSetIterator<E> extends AbstractIteratorDecorator<E> implements OrderedIterator<E> {\n+\n+        /** Object we iterate on */\n+        protected final Collection<E> set;\n+\n+        /** Last object retrieved */\n+        protected E last;\n+\n+        private OrderedSetIterator(ListIterator<E> iterator, Collection<E> set) {\n+            super(iterator);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = iterator.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            set.remove(last);\n+            iterator.remove();\n+            last = null;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return ((ListIterator<E>) iterator).hasPrevious();\n+        }\n+\n+        public E previous() {\n+            last = ((ListIterator<E>) iterator).previous();\n+            return last;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/MapBackedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Decorates a <code>Map</code> to obtain <code>Set</code> behaviour.\n+ * <p>\n+ * This class is used to create a <code>Set</code> with the same properties as\n+ * the key set of any map. Thus, a ReferenceSet can be created by wrapping a\n+ * <code>ReferenceMap</code> in an instance of this class.\n+ * <p>\n+ * Most map implementation can be used to create a set by passing in dummy values.\n+ * Exceptions include <code>BidiMap</code> implementations, as they require unique values.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class MapBackedSet<E, V> implements Set<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6723912213766056587L;\n+\n+    /** The map being used as the backing store */\n+    protected final Map<E, ? super V> map;\n+\n+    /** The dummyValue to use */\n+    protected final V dummyValue;\n+\n+    /**\n+     * Factory method to create a set from a map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E, V> Set<E> mapBackedSet(Map<E, ? super V> map) {\n+        return mapBackedSet(map, null);\n+    }\n+\n+    /**\n+     * Factory method to create a set from a map.\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param dummyValue  the dummy value to use\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <E, V> Set<E> mapBackedSet(Map<E, ? super V> map, V dummyValue) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"The map must not be null\");\n+        }\n+        return new MapBackedSet<E, V>(map, dummyValue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param dummyValue  the dummy value to use\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private MapBackedSet(Map<E, ? super V> map, V dummyValue) {\n+        super();\n+        this.map = map;\n+        this.dummyValue = dummyValue;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return map.keySet().iterator();\n+    }\n+\n+    public boolean contains(Object obj) {\n+        return map.containsKey(obj);\n+    }\n+\n+    public boolean containsAll(Collection<?> coll) {\n+        return map.keySet().containsAll(coll);\n+    }\n+\n+    public boolean add(E obj) {\n+        int size = map.size();\n+        map.put(obj, dummyValue);\n+        return (map.size() != size);\n+    }\n+\n+    public boolean addAll(Collection<? extends E> coll) {\n+        int size = map.size();\n+        for (E e : coll) {\n+            map.put(e, dummyValue);\n+        }\n+        return (map.size() != size);\n+    }\n+\n+    public boolean remove(Object obj) {\n+        int size = map.size();\n+        map.remove(obj);\n+        return (map.size() != size);\n+    }\n+\n+    public boolean removeAll(Collection<?> coll) {\n+        return map.keySet().removeAll(coll);\n+    }\n+\n+    public boolean retainAll(Collection<?> coll) {\n+        return map.keySet().retainAll(coll);\n+    }\n+\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    public Object[] toArray() {\n+        return map.keySet().toArray();\n+    }\n+\n+    public <T> T[] toArray(T[] array) {\n+        return map.keySet().toArray(array);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return map.keySet().equals(obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return map.keySet().hashCode();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/PredicatedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+\n+/**\n+ * Decorates another <code>Set</code> to validate that all additions\n+ * match a specified predicate.\n+ * <p>\n+ * This set exists to provide validation for the decorated set.\n+ * It is normally created to decorate an empty set.\n+ * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the set.\n+ * <pre>Set set = PredicatedSet.decorate(new HashSet(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedSet<E> extends PredicatedCollection<E> implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -684521469108685117L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a decorated set\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    public static <T> Set<T> predicatedSet(Set<T> set, Predicate<? super T> predicate) {\n+        return new PredicatedSet<T>(set, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    protected PredicatedSet(Set<E> set, Predicate<? super E> predicate) {\n+        super(set, predicate);\n+    }\n+\n+    /**\n+     * Gets the set being decorated.\n+     * \n+     * @return the decorated set\n+     */\n+    @Override\n+    protected Set<E> decorated() {\n+        return (Set<E>) super.decorated();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/PredicatedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Comparator;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to validate that all additions\n+ * match a specified predicate.\n+ * <p>\n+ * This set exists to provide validation for the decorated set.\n+ * It is normally created to decorate an empty set.\n+ * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the set.\n+ * <pre>SortedSet set = PredicatedSortedSet.decorate(new TreeSet(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Paul Jack\n+ */\n+public class PredicatedSortedSet<E> extends PredicatedSet<E> implements SortedSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -9110948148132275052L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) sorted set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated sorted set.\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    public static <T> SortedSet<T> predicatedSortedSet(SortedSet<T> set, Predicate<? super T> predicate) {\n+        return new PredicatedSortedSet<T>(set, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    protected PredicatedSortedSet(SortedSet<E> set, Predicate<? super E> predicate) {\n+        super(set, predicate);\n+    }\n+\n+    /**\n+     * Gets the sorted set being decorated.\n+     * \n+     * @return the decorated sorted set\n+     */\n+    @Override\n+    protected SortedSet<E> decorated() {\n+        return (SortedSet<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public SortedSet<E> subSet(E fromElement, E toElement) {\n+        SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n+        return new PredicatedSortedSet<E>(sub, predicate);\n+    }\n+\n+    public SortedSet<E> headSet(E toElement) {\n+        SortedSet<E> sub = decorated().headSet(toElement);\n+        return new PredicatedSortedSet<E>(sub, predicate);\n+    }\n+\n+    public SortedSet<E> tailSet(E fromElement) {\n+        SortedSet<E> sub = decorated().tailSet(fromElement);\n+        return new PredicatedSortedSet<E>(sub, predicate);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/SynchronizedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+\n+/**\n+ * Decorates another <code>Set</code> to synchronize its behaviour for a\n+ * multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated set.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedSet<E> extends SynchronizedCollection<E> implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8304417378626543635L;\n+\n+    /**\n+     * Factory method to create a synchronized set.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <T> Set<T> synchronizedSet(Set<T> set) {\n+        return new SynchronizedSet<T>(set);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected SynchronizedSet(Set<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param lock  the lock object to use, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected SynchronizedSet(Set<E> set, Object lock) {\n+        super(set, lock);\n+    }\n+\n+    /**\n+     * Gets the decorated set.\n+     * \n+     * @return the decorated set\n+     */\n+    protected Set<E> getSet() {\n+        return (Set<E>) collection;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/SynchronizedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Comparator;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated set.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SynchronizedSortedSet<E> extends SynchronizedCollection<E> implements SortedSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2775582861954500111L;\n+\n+    /**\n+     * Factory method to create a synchronized set.\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> set) {\n+        return new SynchronizedSortedSet<T>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected SynchronizedSortedSet(SortedSet<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param set  the set to decorate, must not be null\n+     * @param lock  the lock object to use, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected SynchronizedSortedSet(SortedSet<E> set, Object lock) {\n+        super(set, lock);\n+    }\n+\n+    /**\n+     * Gets the decorated set.\n+     *\n+     * @return the decorated set\n+     */\n+    protected SortedSet<E> getSortedSet() {\n+        return (SortedSet<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedSet<E> subSet(E fromElement, E toElement) {\n+        synchronized (lock) {\n+            SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n+            // the lock is passed into the constructor here to ensure that the\n+            // subset is synchronized on the same lock as the parent\n+            return new SynchronizedSortedSet<E>(set, lock);\n+        }\n+    }\n+\n+    public SortedSet<E> headSet(E toElement) {\n+        synchronized (lock) {\n+            SortedSet<E> set = getSortedSet().headSet(toElement);\n+            // the lock is passed into the constructor here to ensure that the\n+            // headset is synchronized on the same lock as the parent\n+            return new SynchronizedSortedSet<E>(set, lock);\n+        }\n+    }\n+\n+    public SortedSet<E> tailSet(E fromElement) {\n+        synchronized (lock) {\n+            SortedSet<E> set = getSortedSet().tailSet(fromElement);\n+            // the lock is passed into the constructor here to ensure that the\n+            // tailset is synchronized on the same lock as the parent\n+            return new SynchronizedSortedSet<E>(set, lock);\n+        }\n+    }\n+\n+    public E first() {\n+        synchronized (lock) {\n+            return getSortedSet().first();\n+        }\n+    }\n+\n+    public E last() {\n+        synchronized (lock) {\n+            return getSortedSet().last();\n+        }\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        synchronized (lock) {\n+            return getSortedSet().comparator();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/TransformedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+\n+/**\n+ * Decorates another <code>Set</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedSet<E> extends TransformedCollection<E> implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 306127383500410386L;\n+\n+    /**\n+     * Factory method to create a transforming set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedSet(Set, Transformer)}.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    public static <E> Set<E> transformingSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSet<E>(set, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming set that will transform\n+     * existing contents of the specified set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSet(Set, Transformer)}.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Set\n+     * @throws IllegalArgumentException if set or transformer is null\n+     * @since Commons Collections 3.3\n+     */\n+    public static <E> Set<E> transformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+        TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n+        if (transformer != null && set != null && set.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // set is type E\n+            E[] values = (E[]) set.toArray();\n+            set.clear();\n+            for(int i=0; i<values.length; i++) {\n+                decorated.decorated().add(transformer.transform(values[i]));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    protected TransformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+        super(set, transformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/TransformedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Comparator;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedSortedSet<E> extends TransformedSet<E> implements SortedSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1675486811351124386L;\n+\n+    /**\n+     * Factory method to create a transforming sorted set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    public static <E> SortedSet<E> transformingSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming sorted set that will transform\n+     * existing contents of the specified sorted set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed SortedSet\n+     * @throws IllegalArgumentException if set or transformer is null\n+     * @since Commons Collections 3.3\n+     */\n+    public static <E> SortedSet<E> transformedSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+        TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n+        if (transformer != null && set != null && set.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // set is type E\n+            E[] values = (E[]) set.toArray();\n+            set.clear();\n+            for(int i=0; i<values.length; i++) {\n+                decorated.decorated().add(transformer.transform(values[i]));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    protected TransformedSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+        super(set, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated set.\n+     * \n+     * @return the decorated set\n+     */\n+    protected SortedSet<E> getSortedSet() {\n+        return (SortedSet<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E first() {\n+        return getSortedSet().first();\n+    }\n+\n+    public E last() {\n+        return getSortedSet().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return getSortedSet().comparator();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedSet<E> subSet(E fromElement, E toElement) {\n+        SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+\n+    public SortedSet<E> headSet(E toElement) {\n+        SortedSet<E> set = getSortedSet().headSet(toElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+\n+    public SortedSet<E> tailSet(E fromElement) {\n+        SortedSet<E> set = getSortedSet().tailSet(fromElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/UnmodifiableSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>Set</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableSet<E>\n+        extends AbstractSerializableSetDecorator<E>\n+        implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6499119872185240161L;\n+\n+    /**\n+     * Factory method to create an unmodifiable set.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E> Set<E> unmodifiableSet(Set<E> set) {\n+        if (set instanceof Unmodifiable) {\n+            return set;\n+        }\n+        return new UnmodifiableSet<E>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    private UnmodifiableSet(Set<E> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.<E>unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/set/UnmodifiableSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public final class UnmodifiableSortedSet<E>\n+        extends AbstractSortedSetDecorator<E>\n+        implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -725356885467962424L;\n+\n+    /**\n+     * Factory method to create an unmodifiable set.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> set) {\n+        if (set instanceof Unmodifiable) {\n+            return set;\n+        }\n+        return new UnmodifiableSortedSet<T>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    private UnmodifiableSortedSet(SortedSet<E> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedSet<E> subSet(E fromElement, E toElement) {\n+        SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n+        return new UnmodifiableSortedSet<E>(sub);\n+    }\n+\n+    @Override\n+    public SortedSet<E> headSet(E toElement) {\n+        SortedSet<E> sub = decorated().headSet(toElement);\n+        return new UnmodifiableSortedSet<E>(sub);\n+    }\n+\n+    @Override\n+    public SortedSet<E> tailSet(E fromElement) {\n+        SortedSet<E> sub = decorated().tailSet(fromElement);\n+        return new UnmodifiableSortedSet<E>(sub);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Get;\n+import org.apache.commons.collections.IterableGet;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.map.EntrySetToMapIteratorAdapter;\n+\n+/**\n+ * {@link IterableGet} that uses a {@link Map}<K, V> for the {@link Get}<K, V>\n+ * implementation.\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matt Benson\n+ */\n+public class AbstractIterableGetMapDecorator<K, V> implements IterableGet<K, V> {\n+    /** The map to decorate */\n+    protected transient Map<K, V> map;\n+\n+    /**\n+     * Create a new AbstractSplitMapDecorator.\n+     * @param decorated the Map to decorate\n+     */\n+    public AbstractIterableGetMapDecorator(Map<K, V> decorated) {\n+        this.map = decorated;\n+    }\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractIterableGetMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     *\n+     * @return the decorated map\n+     */\n+    protected Map<K, V> decorated() {\n+        return map;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsKey(Object key) {\n+        return decorated().containsKey(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsValue(Object value) {\n+        return decorated().containsValue(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return decorated().entrySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V get(Object key) {\n+        return decorated().get(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V remove(Object key) {\n+        return decorated().remove(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<K> keySet() {\n+        return decorated().keySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Collection<V> values() {\n+        return decorated().values();\n+    }\n+\n+    /**\n+     * Get a MapIterator over this Get.\n+     * @return MapIterator<K, V>\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        return new EntrySetToMapIteratorAdapter<K, V>(entrySet());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return decorated().equals(object);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/splitmap/SplitMapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Get;\n+import org.apache.commons.collections.IterableGet;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.collections.Put;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections.map.EntrySetToMapIteratorAdapter;\n+import org.apache.commons.collections.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections.set.UnmodifiableSet;\n+\n+/**\n+ * Utilities for working with \"split maps:\" objects that implement {@link Put}\n+ * and/or {@link Get} but not {@link Map}.\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Revision$ $Date$\n+ * @see Get\n+ * @see Put\n+ * @author Matt Benson\n+ */\n+public class SplitMapUtils {\n+\n+    /**\n+     * <code>SplitMapUtils</code> should not normally be instantiated.\n+     */\n+    public SplitMapUtils() {\n+    }\n+\n+    private static class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n+        private final Get<K, V> get;\n+\n+        private WrappedGet(Get<K, V> get) {\n+            this.get = get;\n+        }\n+\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsKey(Object key) {\n+            return get.containsKey(key);\n+        }\n+\n+        public boolean containsValue(Object value) {\n+            return get.containsValue(value);\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n+        }\n+\n+        @Override\n+        public boolean equals(Object arg0) {\n+            if (arg0 == this) {\n+                return true;\n+            }\n+            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(this.get);\n+        }\n+\n+        public V get(Object key) {\n+            return get.get(key);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedGet\".hashCode() << 4) | get.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            return get.isEmpty();\n+        }\n+\n+        public Set<K> keySet() {\n+            return UnmodifiableSet.unmodifiableSet(get.keySet());\n+        }\n+\n+        public V put(K key, V value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void putAll(Map<? extends K, ? extends V> t) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V remove(Object key) {\n+            return get.remove(key);\n+        }\n+\n+        public int size() {\n+            return get.size();\n+        }\n+\n+        public Collection<V> values() {\n+            return UnmodifiableCollection.unmodifiableCollection(get.values());\n+        }\n+\n+        public MapIterator<K, V> mapIterator() {\n+            MapIterator<K, V> it;\n+            if (get instanceof IterableGet) {\n+                it = ((IterableGet<K, V>) get).mapIterator();\n+            } else {\n+                it = new EntrySetToMapIteratorAdapter<K, V>(get.entrySet());\n+            }\n+            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+        }\n+    }\n+\n+    private static class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n+        private final Put<K, V> put;\n+\n+        private WrappedPut(Put<K, V> put) {\n+            this.put = put;\n+        }\n+\n+        public void clear() {\n+            put.clear();\n+        }\n+\n+        public boolean containsKey(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsValue(Object value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(this.put);\n+        }\n+\n+        public V get(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedPut\".hashCode() << 4) | put.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<K> keySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V put(K key, V value) {\n+            return (V) put.put(key, value);\n+        }\n+\n+        public void putAll(Map<? extends K, ? extends V> t) {\n+            put.putAll(t);\n+        }\n+\n+        public V remove(Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int size() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Collection<V> values() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    /**\n+     * Get the specified {@link Get} as an instance of {@link IterableMap}.\n+     * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n+     * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n+     * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n+     * @param <K>\n+     * @param <V>\n+     * @param get to wrap, must not be null\n+     * @return {@link IterableMap}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> IterableMap<K, V> readableMap(Get<K, V> get) {\n+        if (get == null) {\n+            throw new IllegalArgumentException(\"Get must not be null\");\n+        }\n+        if (get instanceof Map) {\n+            return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils\n+                    .iterableMap((Map<K, V>) get);\n+        }\n+        return new WrappedGet<K, V>(get);\n+    }\n+\n+    /**\n+     * Get the specified {@link Put} as an instanceof {@link Map}.\n+     * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n+     * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n+     * it is recommended that the result of #put(K, V) be discarded as it likely will not\n+     * match <code>V</code> at runtime.\n+     *\n+     * @param <K>\n+     * @param <V>\n+     * @param put to wrap, must not be null\n+     * @return {@link Map}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> Map<K, V> writableMap(Put<K, V> put) {\n+        if (put == null) {\n+            throw new IllegalArgumentException(\"Put must not be null\");\n+        }\n+        if (put instanceof Map) {\n+            return (Map<K, V>) put;\n+        }\n+        return new WrappedPut<K, V>(put);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/splitmap/TransformedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Get;\n+import org.apache.commons.collections.Put;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.map.LinkedMap;\n+\n+/**\n+ * Decorates another <code>Map</code> to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must use\n+ * the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. The simplest approach\n+ * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n+ * This class may throw exceptions when accessed by concurrent threads without\n+ * synchronization.\n+ * <p>\n+ * The \"put\" and \"get\" type constraints of this class are mutually independent;\n+ * contrast with {@link org.apache.commons.collections.map.TransformedMap} which,\n+ * by virtue of its implementing {@link Map}&lt;K, V&gt;, must be constructed in such\n+ * a way that its read and write parameters are generalized to a common (super-)type.\n+ * In practice this would often mean <code>&gt;Object, Object&gt;</code>, defeating\n+ * much of the usefulness of having parameterized types.\n+ * <p>\n+ * On the downside, this class is not drop-in compatible with {@link java.util.Map}\n+ * but is intended to be worked with either directly or by {@link Put} and {@link Get}\n+ * generalizations.\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Revision$ $Date$\n+ * @see SplitMapUtils#readableMap(Get)\n+ * @see SplitMapUtils#writableMap(Put)\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class TransformedMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V> implements\n+        Put<J, U>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5966875321133456994L;\n+\n+    /** The transformer to use for the key */\n+    private final Transformer<? super J, ? extends K> keyTransformer;\n+    /** The transformer to use for the value */\n+    private final Transformer<? super U, ? extends V> valueTransformer;\n+\n+    /**\n+     * Factory method to create a transforming map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they are\n+     * NOT transformed.\n+     *\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     * means no transformation\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     * means no transformation\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <J, K, U, V> TransformedMap<J, K, U, V> transformingMap(Map<K, V> map,\n+            Transformer<? super J, ? extends K> keyTransformer,\n+            Transformer<? super U, ? extends V> valueTransformer) {\n+        return new TransformedMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     * means no conversion\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     * means no conversion\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected TransformedMap(Map<K, V> map, Transformer<? super J, ? extends K> keyTransformer,\n+            Transformer<? super U, ? extends V> valueTransformer) {\n+        super(map);\n+        if (keyTransformer == null) {\n+            throw new IllegalArgumentException(\"keyTransformer cannot be null\");\n+        }\n+        this.keyTransformer = keyTransformer;\n+        if (valueTransformer == null) {\n+            throw new IllegalArgumentException(\"valueTransformer cannot be null\");\n+        }\n+        this.valueTransformer = valueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     *\n+     * @param out the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(decorated());\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     *\n+     * @param in the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since Commons Collections 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms a key.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @throws the transformed object\n+     */\n+    protected K transformKey(J object) {\n+        return keyTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a value.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @throws the transformed object\n+     */\n+    protected V transformValue(U object) {\n+        return valueTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a map.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map the map to transform\n+     * @throws the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(Map<? extends J, ? extends U> map) {\n+        if (map.isEmpty()) {\n+            return (Map<K, V>) map;\n+        }\n+        Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (Map.Entry<? extends J, ? extends U> entry : map.entrySet()) {\n+            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Override to transform the value when using <code>setValue</code>.\n+     *\n+     * @param value the value to transform\n+     * @return the transformed value\n+     */\n+    protected V checkSetValue(U value) {\n+        return valueTransformer.transform(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V put(J key, U value) {\n+        return decorated().put(transformKey(key), transformValue(value));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void putAll(Map<? extends J, ? extends U> mapToCopy) {\n+        decorated().putAll(transformMap(mapToCopy));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void clear() {\n+        decorated().clear();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractDecoratedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.junit.Before;\n+\n+public abstract class AbstractDecoratedCollectionTest<C> {\n+    /**\n+     * The {@link Collection} being decorated.\n+     */\n+    protected Collection<C> original;\n+    /**\n+     * The Collection under test that decorates {@link #original}.\n+     */\n+    protected Collection<C> decorated;\n+    \n+    @Before\n+    public void setUpDecoratedCollection() throws Exception {\n+        original = new ArrayList<C>();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractTestArrayList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.collections.list.AbstractTestList;\n+\n+/**\n+ * Abstract test class for ArrayList.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Jason van Zyl\n+ */\n+public abstract class AbstractTestArrayList<E> extends AbstractTestList<E> {\n+\n+    public AbstractTestArrayList(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract ArrayList<E> makeObject();\n+\n+    //-----------------------------------------------------------------------\n+    public void testNewArrayList() {\n+        ArrayList<E> list = makeObject();\n+        assertTrue(\"New list is empty\", list.isEmpty());\n+        assertEquals(\"New list has size zero\", 0, list.size());\n+\n+        try {\n+            list.get(1);\n+            fail(\"get(int i) should have thrown IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected result\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        ArrayList<E> list = makeObject();\n+        list.add((E) \"First Item\");\n+        list.add((E) \"Last Item\");\n+        assertEquals(\"First item is 'First Item'\", \"First Item\", list.get(0));\n+        assertEquals(\"Last Item is 'Last Item'\", \"Last Item\", list.get(1));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractTestLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.list.AbstractTestList;\n+\n+/**\n+ * Tests base {@link java.util.LinkedList} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject()} method.\n+ * <p>\n+ * If your {@link LinkedList} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link List} fails.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rich Dougherty\n+ */\n+public abstract class AbstractTestLinkedList<T> extends AbstractTestList<T> {\n+\n+    public AbstractTestLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public abstract LinkedList<T> makeObject();\n+\n+    /**\n+     *  Returns the {@link #collection} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the collection field as a List\n+     */\n+    @Override\n+    public LinkedList<T> getCollection() {\n+        return (LinkedList<T>) super.getCollection();\n+    }\n+\n+    /**\n+     *  Returns the {@link #confirmed} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the confirmed field as a List\n+     */\n+    protected LinkedList<T> getConfirmedLinkedList() {\n+        return (LinkedList<T>) getConfirmed();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addFirst(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLinkedListAddFirst() {\n+        if (!isAddSupported()) return;\n+        T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+\n+        resetFull();\n+        getCollection().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addLast(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLinkedListAddLast() {\n+        if (!isAddSupported()) return;\n+        T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+\n+        resetFull();\n+        getCollection().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getFirst()}.\n+     */\n+    public void testLinkedListGetFirst() {\n+        resetEmpty();\n+        try {\n+            getCollection().getFirst();\n+            fail(\"getFirst() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        Object first = getCollection().getFirst();\n+        Object confirmedFirst = getConfirmedLinkedList().getFirst();\n+        assertEquals(\"Result returned by getFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getLast()}.\n+     */\n+    public void testLinkedListGetLast() {\n+        resetEmpty();\n+        try {\n+            getCollection().getLast();\n+            fail(\"getLast() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        Object last = getCollection().getLast();\n+        Object confirmedLast = getConfirmedLinkedList().getLast();\n+        assertEquals(\"Result returned by getLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeFirst()}.\n+     */\n+    public void testLinkedListRemoveFirst() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().removeFirst();\n+            fail(\"removeFirst() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        Object first = getCollection().removeFirst();\n+        Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n+        assertEquals(\"Result returned by removeFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeLast()}.\n+     */\n+    public void testLinkedListRemoveLast() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().removeLast();\n+            fail(\"removeLast() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        Object last = getCollection().removeLast();\n+        Object confirmedLast = getConfirmedLinkedList().removeLast();\n+        assertEquals(\"Result returned by removeLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Returns an empty {@link LinkedList}.\n+     */\n+    @Override\n+    public Collection<T> makeConfirmedCollection() {\n+        return new LinkedList<T>();\n+    }\n+\n+    /**\n+     *  Returns a full {@link LinkedList}.\n+     */\n+    @Override\n+    public Collection<T> makeConfirmedFullCollection() {\n+        List<T> list = new LinkedList<T>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractTestObject.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * Abstract test class for {@link java.lang.Object} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject()} method.\n+ * <p>\n+ * If your {@link Object} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link Object} fails.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Stephen Colebourne\n+ * @author Anonymous\n+ */\n+public abstract class AbstractTestObject extends BulkTest {\n+\n+    /** Current major release for Collections */\n+    public static final int COLLECTIONS_MAJOR_VERSION = 3;\n+    \n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestObject(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return the object to test.\n+     * \n+     * @return the object to test\n+     */\n+    public abstract Object makeObject();\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize an \"empty\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsEmptyCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize a \"full\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsFullCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Is serialization testing supported.\n+     * Default is true.\n+     */\n+    public boolean isTestSerialization() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports equals() comparisons.\n+     * This implementation returns true;\n+     */\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testObjectEqualsSelf() {\n+        Object obj = makeObject();\n+        assertEquals(\"A Object should equal itself\", obj, obj);\n+    }\n+\n+    public void testEqualsNull() {\n+        Object obj = makeObject();\n+        assertEquals(false, obj.equals(null)); // make sure this doesn't throw NPE either\n+    }\n+\n+    public void testObjectHashCodeEqualsSelfHashCode() {\n+        Object obj = makeObject();\n+        assertEquals(\"hashCode should be repeatable\", obj.hashCode(), obj.hashCode());\n+    }\n+\n+    public void testObjectHashCodeEqualsContract() {\n+        Object obj1 = makeObject();\n+        if (obj1.equals(obj1)) {\n+            assertEquals(\n+                \"[1] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj1.hashCode());\n+        }\n+        Object obj2 = makeObject();\n+        if (obj1.equals(obj2)) {\n+            assertEquals(\n+                \"[2] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj2.hashCode());\n+            assertTrue(\n+                \"When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true\",\n+                obj2.equals(obj1));\n+        }\n+    }\n+\n+    protected Object serializeDeserialize(Object obj) throws Exception {\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(obj);\n+        out.close();\n+\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        Object dest = in.readObject();\n+        in.close();\n+\n+        return dest;\n+    }\n+\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Object obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            Object dest = serializeDeserialize(obj);\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj))\", obj, dest);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sanity check method, makes sure that any Serializable\n+     * class can be serialized and de-serialized in memory, \n+     * using the handy makeObject() method\n+     * \n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    public void testSimpleSerialization() throws Exception {\n+        Object o = makeObject();\n+        if (o instanceof Serializable && isTestSerialization()) {\n+            byte[] objekt = writeExternalFormToBytes((Serializable) o);\n+            readExternalFormFromBytes(objekt);\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalEmptyCollectionExists() {\n+        if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                String name = getCanonicalEmptyCollectionName(object);\n+                assertTrue(\n+                    \"Canonical empty collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalFullCollectionExists() {\n+        if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                String name = getCanonicalFullCollectionName(object);\n+                assertTrue(\n+                    \"Canonical full collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    // protected implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the version of Collections that this object tries to\n+     * maintain serialization compatibility with. Defaults to 1, the\n+     * earliest Collections version. (Note: some collections did not\n+     * even exist in this version).\n+     * \n+     * This constant makes it possible for TestMap (and other subclasses,\n+     * if necessary) to automatically check SVN for a versionX copy of a\n+     * Serialized object, so we can make sure that compatibility is maintained.\n+     * See, for example, TestMap.getCanonicalFullMapName(Map map).\n+     * Subclasses can override this variable, indicating compatibility\n+     * with earlier Collections versions.\n+     * \n+     * @return The version, or <code>null</code> if this object shouldn't be\n+     * tested for compatibility with previous versions.\n+     */\n+    public String getCompatibilityVersion() {\n+        return \"1\";\n+    }\n+\n+    protected String getCanonicalEmptyCollectionName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(\"data/test/\");\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".emptyCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    protected String getCanonicalFullCollectionName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(\"data/test/\");\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".fullCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Write a Serializable or Externalizable object as\n+     * a file at the given path.  NOT USEFUL as part\n+     * of a unit test; this is just a utility method\n+     * for creating disk-based objects in SVN that can become\n+     * the basis for compatibility tests using\n+     * readExternalFormFromDisk(String path)\n+     * \n+     * @param o Object to serialize\n+     * @param path path to write the serialized Object\n+     * @exception IOException\n+     */\n+    protected void writeExternalFormToDisk(Serializable o, String path) throws IOException {\n+        FileOutputStream fileStream = new FileOutputStream(path);\n+        writeExternalFormToStream(o, fileStream);\n+    }\n+\n+    /**\n+     * Converts a Serializable or Externalizable object to\n+     * bytes.  Useful for in-memory tests of serialization\n+     * \n+     * @param o Object to convert to bytes\n+     * @return serialized form of the Object\n+     * @exception IOException\n+     */\n+    protected byte[] writeExternalFormToBytes(Serializable o) throws IOException {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n+        writeExternalFormToStream(o, byteStream);\n+        return byteStream.toByteArray();\n+    }\n+\n+    /**\n+     * Reads a Serialized or Externalized Object from disk.\n+     * Useful for creating compatibility tests between\n+     * different SVN versions of the same class\n+     * \n+     * @param path path to the serialized Object\n+     * @return the Object at the given path\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromDisk(String path) throws IOException, ClassNotFoundException {\n+        FileInputStream stream = new FileInputStream(path);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    /**\n+     * Read a Serialized or Externalized Object from bytes.\n+     * Useful for verifying serialization in memory.\n+     * \n+     * @param b byte array containing a serialized Object\n+     * @return Object contained in the bytes\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromBytes(byte[] b) throws IOException, ClassNotFoundException {\n+        ByteArrayInputStream stream = new ByteArrayInputStream(b);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    protected boolean skipSerializedCanonicalTests() {\n+        return Boolean.getBoolean(\"org.apache.commons.collections:with-clover\");\n+    }\n+\n+    // private implementation\n+    //-----------------------------------------------------------------------\n+    private Object readExternalFormFromStream(InputStream stream) throws IOException, ClassNotFoundException {\n+        ObjectInputStream oStream = new ObjectInputStream(stream);\n+        return oStream.readObject();\n+    }\n+\n+    private void writeExternalFormToStream(Serializable o, OutputStream stream) throws IOException {\n+        ObjectOutputStream oStream = new ObjectOutputStream(stream);\n+        oStream.writeObject(o);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractTestTreeMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.AbstractTestMap;\n+\n+/**\n+ * Tests TreeMap.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Jason van Zyl\n+ */\n+public abstract class AbstractTestTreeMap<K, V> extends AbstractTestMap<K, V> {\n+\n+    public AbstractTestTreeMap(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract TreeMap<K, V> makeObject();\n+\n+    public void testNewMap() {\n+        TreeMap<K, V> map = makeObject();\n+        assertTrue(\"New map is empty\", map.isEmpty());\n+        assertEquals(\"New map has size zero\", 0, map.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        TreeMap<K, V> map = makeObject();\n+        map.put((K) \"first\", (V) \"First Item\");\n+        map.put((K) \"second\", (V) \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\",\n+            \"First Item\", map.get(\"first\"));\n+        assertEquals(\"Next Item is 'First Item'\",\n+            \"Second Item\", map.get(\"second\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractTestTypedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Tests TypedCollection.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestTypedCollection<T> extends BulkTest {\n+\n+    public AbstractTestTypedCollection(String name) {\n+        super(name);\n+    }\n+\n+    protected abstract Collection<T> typedCollection();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected Class<T> getType() {\n+        return (Class<T>) String.class;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        Collection<T> c = typedCollection();\n+        Integer i = new Integer(3);\n+        try {\n+            c.add((T) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(i));   \n+    }\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        Collection<T> c = typedCollection();\n+        List<Object> elements = new ArrayList<Object>();\n+        elements.add(\"one\");\n+        elements.add(\"two\");\n+        elements.add(new Integer(3));\n+        elements.add(\"four\");\n+        try {\n+            c.addAll((Collection<? extends T>) elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"one\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"two\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(new Integer(3)));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"four\"));   \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/BulkTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * A {@link TestCase} that can define both simple and bulk test methods.\n+ * <p>\n+ * A <I>simple test method</I> is the type of test traditionally \n+ * supplied by by {@link TestCase}.  To define a simple test, create a public \n+ * no-argument method whose name starts with \"test\".  You can specify the\n+ * the name of simple test in the constructor of <code>BulkTest</code>;\n+ * a subsequent call to {@link TestCase#run} will run that simple test.\n+ * <p>\n+ * A <I>bulk test method</I>, on the other hand, returns a new instance\n+ * of <code>BulkTest</code>, which can itself define new simple and bulk\n+ * test methods.  By using the {@link #makeSuite} method, you can \n+ * automatically create a hierarchal suite of tests and child bulk tests.\n+ * <p>\n+ * For instance, consider the following two classes:\n+ *\n+ * <Pre>\n+ *  public class TestSet extends BulkTest {\n+ *\n+ *      private Set set;\n+ *\n+ *      public TestSet(Set set) {\n+ *          this.set = set;\n+ *      }\n+ *\n+ *      public void testContains() {\n+ *          boolean r = set.contains(set.iterator().next()));\n+ *          assertTrue(\"Set should contain first element, r);\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          set.clear();\n+ *          assertTrue(\"Set should be empty after clear\", set.isEmpty());\n+ *      }\n+ *  }\n+ *\n+ *\n+ *  public class TestHashMap extends BulkTest {\n+ *\n+ *      private Map makeFullMap() {\n+ *          HashMap result = new HashMap();\n+ *          result.put(\"1\", \"One\");\n+ *          result.put(\"2\", \"Two\");\n+ *          return result;\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          Map map = makeFullMap();\n+ *          map.clear();\n+ *          assertTrue(\"Map empty after clear\", map.isEmpty());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestKeySet() {\n+ *          return new TestSet(makeFullMap().keySet());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestEntrySet() {\n+ *          return new TestSet(makeFullMap().entrySet());\n+ *      }\n+ *  }\n+ *  </Pre>\n+ *\n+ *  In the above examples, <code>TestSet</code> defines two\n+ *  simple test methods and no bulk test methods; <code>TestHashMap</code>\n+ *  defines one simple test method and two bulk test methods.  When\n+ *  <code>makeSuite(TestHashMap.class).run</code> is executed, \n+ *  <I>five</I> simple test methods will be run, in this order:<P>\n+ *\n+ *  <Ol>\n+ *  <Li>TestHashMap.testClear()\n+ *  <Li>TestHashMap.bulkTestKeySet().testContains();\n+ *  <Li>TestHashMap.bulkTestKeySet().testClear();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testContains();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testClear();\n+ *  </Ol>\n+ *\n+ *  In the graphical junit test runners, the tests would be displayed in\n+ *  the following tree:<P>\n+ *\n+ *  <UL>\n+ *  <LI>TestHashMap</LI>\n+ *      <UL>\n+ *      <LI>testClear\n+ *      <LI>bulkTestKeySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      <LI>bulkTestEntrySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      </UL>\n+ *  </UL>\n+ *\n+ *  A subclass can override a superclass's bulk test by\n+ *  returning <code>null</code> from the bulk test method.  If you only\n+ *  want to override specific simple tests within a bulk test, use the\n+ *  {@link #ignoredTests} method.<P>\n+ *\n+ *  Note that if you want to use the bulk test methods, you <I>must</I>\n+ *  define your <code>suite()</code> method to use {@link #makeSuite}.\n+ *  The ordinary {@link TestSuite} constructor doesn't know how to \n+ *  interpret bulk test methods.\n+ *\n+ *  @author Paul Jack\n+ *  @version $Id$\n+ */\n+public class BulkTest extends TestCase implements Cloneable {\n+\n+\n+    // Note:  BulkTest is Cloneable to make it easier to construct \n+    // BulkTest instances for simple test methods that are defined in \n+    // anonymous inner classes.  Basically we don't have to worry about\n+    // finding weird constructors.  (And even if we found them, technically\n+    // it'd be illegal for anyone but the outer class to invoke them).  \n+    // Given one BulkTest instance, we can just clone it and reset the \n+    // method name for every simple test it defines.  \n+\n+\n+    /**\n+     *  The full name of this bulk test instance.  This is the full name\n+     *  that is compared to {@link #ignoredTests} to see if this\n+     *  test should be ignored.  It's also displayed in the text runner\n+     *  to ease debugging.\n+     */\n+    String verboseName;\n+\n+\n+    /**\n+     *  Constructs a new <code>BulkTest</code> instance that will run the\n+     *  specified simple test.\n+     *\n+     *  @param name  the name of the simple test method to run\n+     */\n+    public BulkTest(String name) {\n+        super(name);\n+        this.verboseName = getClass().getName();\n+    }\n+\n+\n+    /**\n+     *  Creates a clone of this <code>BulkTest</code>.<P>\n+     *\n+     *  @return  a clone of this <code>BulkTest</code>\n+     */\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new Error(); // should never happen\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns an array of test names to ignore.<P>\n+     *\n+     *  If a test that's defined by this <code>BulkTest</code> or\n+     *  by one of its bulk test methods has a name that's in the returned\n+     *  array, then that simple test will not be executed.<P>\n+     *\n+     *  A test's name is formed by taking the class name of the\n+     *  root <code>BulkTest</code>, eliminating the package name, then\n+     *  appending the names of any bulk test methods that were invoked\n+     *  to get to the simple test, and then appending the simple test\n+     *  method name.  The method names are delimited by periods:\n+     *\n+     *  <pre>\n+     *  TestHashMap.bulkTestEntrySet.testClear\n+     *  </pre>\n+     *\n+     *  is the name of one of the simple tests defined in the sample classes\n+     *  described above.  If the sample <code>TestHashMap</code> class\n+     *  included this method:\n+     *\n+     *  <pre>\n+     *  public String[] ignoredTests() {\n+     *      return new String[] { \"TestHashMap.bulkTestEntrySet.testClear\" };\n+     *  }\n+     *  </pre>\n+     *\n+     *  then the entry set's clear method wouldn't be tested, but the key\n+     *  set's clear method would.\n+     *\n+     *  @return an array of the names of tests to ignore, or null if\n+     *   no tests should be ignored\n+     */\n+    public String[] ignoredTests() {\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Returns the display name of this <code>BulkTest</code>.\n+     *\n+     *  @return the display name of this <code>BulkTest</code>\n+     */\n+    @Override\n+    public String toString() {\n+        return getName() + \"(\" + verboseName + \") \";\n+    }\n+\n+\n+    /**\n+     *  Returns a {@link TestSuite} for testing all of the simple tests\n+     *  <I>and</I> all the bulk tests defined by the given class.<P>\n+     *\n+     *  The class is examined for simple and bulk test methods; any child\n+     *  bulk tests are also examined recursively; and the results are stored\n+     *  in a hierarchal {@link TestSuite}.<P>\n+     *\n+     *  The given class must be a subclass of <code>BulkTest</code> and must\n+     *  not be abstract.<P>\n+     *\n+     *  @param c  the class to examine for simple and bulk tests\n+     *  @return  a {@link TestSuite} containing all the simple and bulk tests\n+     *    defined by that class\n+     */\n+    public static TestSuite makeSuite(Class<? extends BulkTest> c) {\n+        if (Modifier.isAbstract(c.getModifiers())) {\n+            throw new IllegalArgumentException(\"Class must not be abstract.\");\n+        }\n+        if (!BulkTest.class.isAssignableFrom(c)) {\n+            throw new IllegalArgumentException(\"Class must extend BulkTest.\");\n+        }\n+        return new BulkTestSuiteMaker(c).make();\n+    }\n+\n+}\n+\n+\n+// It was easier to use a separate class to do all the reflection stuff\n+// for making the TestSuite instances.  Having permanent state around makes\n+// it easier to handle the recursion.\n+class BulkTestSuiteMaker {\n+\n+    /** The class that defines simple and bulk tests methods. */\n+    private Class<? extends BulkTest> startingClass;\n+\n+    /** List of ignored simple test names. */\n+    private List<String> ignored;\n+   \n+    /** The TestSuite we're currently populating.  Can change over time. */\n+    private TestSuite result;\n+\n+    /** \n+     *  The prefix for simple test methods.  Used to check if a test is in \n+     *  the ignored list.\n+     */ \n+    private String prefix;\n+\n+    /** \n+     *  Constructor.\n+     *\n+     *  @param startingClass  the starting class\n+     */     \n+    public BulkTestSuiteMaker(Class<? extends BulkTest> startingClass) {\n+        this.startingClass = startingClass;\n+    }\n+\n+    /**\n+     *  Makes a hierarchal TestSuite based on the starting class.\n+     *\n+     *  @return  the hierarchal TestSuite for startingClass\n+     */\n+    public TestSuite make() {\n+         this.result = new TestSuite();\n+         this.prefix = getBaseName(startingClass);\n+         result.setName(prefix);\n+\n+         BulkTest bulk = makeFirstTestCase(startingClass);\n+         ignored = new ArrayList<String>();\n+         String[] s = bulk.ignoredTests();\n+         if (s != null) {\n+             ignored.addAll(Arrays.asList(s));\n+         }\n+         make(bulk);\n+         return result;\n+    }\n+\n+    /**\n+     *  Appends all the simple tests and bulk tests defined by the given\n+     *  instance's class to the current TestSuite.\n+     *\n+     *  @param bulk  An instance of the class that defines simple and bulk\n+     *    tests for us to append\n+     */\n+    void make(BulkTest bulk) {\n+        Class<? extends BulkTest> c = bulk.getClass();\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) addTest(bulk, all[i]);\n+            if (isBulk(all[i])) addBulk(bulk, all[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Adds the simple test defined by the given method to the TestSuite.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *   (I know it's weird.  But the point is, we can clone the instance\n+     *   and not have to worry about constructors.)\n+     *  @param m  The simple test method\n+     */\n+    void addTest(BulkTest bulk, Method m) {\n+        BulkTest bulk2 = (BulkTest)bulk.clone();\n+        bulk2.setName(m.getName());\n+        bulk2.verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(bulk2.verboseName)) return;\n+        result.addTest(bulk2);\n+    }\n+\n+    /**\n+     *  Adds a whole new suite of tests that are defined by the result of\n+     *  the given bulk test method.  In other words, the given bulk test\n+     *  method is invoked, and the resulting BulkTest instance is examined\n+     *  for yet more simple and bulk tests.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *  @param m  The bulk test method\n+     */\n+    void addBulk(BulkTest bulk, Method m) {\n+        String verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(verboseName)) return;\n+        \n+        BulkTest bulk2;\n+        try {\n+            bulk2 = (BulkTest)m.invoke(bulk, (Object[]) null);\n+            if (bulk2 == null) return;\n+        } catch (InvocationTargetException ex) {\n+            ex.getTargetException().printStackTrace();\n+            throw new Error(); // FIXME;\n+        } catch (IllegalAccessException ex) {\n+            ex.printStackTrace();\n+            throw new Error(); // FIXME;\n+        }\n+\n+        // Save current state on the stack.\n+        String oldPrefix = prefix;\n+        TestSuite oldResult = result;\n+\n+        prefix = prefix + \".\" + m.getName();\n+        result = new TestSuite();\n+        result.setName(m.getName());\n+\n+        make(bulk2);\n+\n+        oldResult.addTest(result);\n+\n+        // Restore the old state\n+        prefix = oldPrefix;\n+        result = oldResult;\n+    }\n+\n+    /**\n+     *  Returns the base name of the given class.\n+     *\n+     *  @param c  the class\n+     *  @return the name of that class, minus any package names\n+     */\n+    private static String getBaseName(Class<?> c) {\n+        String name = c.getName();\n+        int p = name.lastIndexOf('.');\n+        if (p > 0) {\n+            name = name.substring(p + 1);\n+        }\n+        return name;\n+    }\n+\n+\n+    // These three methods are used to create a valid BulkTest instance\n+    // from a class.\n+\n+    private static <T> Constructor<T> getTestCaseConstructor(Class<T> c) {\n+        try {\n+            return c.getConstructor(new Class[] { String.class });\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalArgumentException(c + \" must provide \" +\n+             \"a (String) constructor\");\n+        }\n+    }\n+\n+    private static <T extends BulkTest> BulkTest makeTestCase(Class<T> c, Method m) {\n+        Constructor<T> con = getTestCaseConstructor(c);\n+        try {\n+            return con.newInstance(new Object[] { m.getName() });\n+        } catch (InvocationTargetException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(); // FIXME;\n+        } catch (IllegalAccessException e) {\n+            throw new Error(); // should never occur\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(); // FIXME;\n+        }\n+    }\n+\n+    private static <T extends BulkTest> BulkTest makeFirstTestCase(Class<T> c) {\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) return makeTestCase(c, all[i]);\n+        }\n+        throw new IllegalArgumentException(c.getName() + \" must provide \" \n+          + \" at least one test method.\");\n+    }\n+\n+    /**\n+     *  Returns true if the given method is a simple test method.\n+     */\n+    private static boolean isTest(Method m) {\n+        if (!m.getName().startsWith(\"test\")) return false;\n+        if (m.getReturnType() != Void.TYPE) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns true if the given method is a bulk test method.\n+     */\n+    private static boolean isBulk(Method m) {\n+        if (!m.getName().startsWith(\"bulkTest\")) return false;\n+        if (m.getReturnType() != BulkTest.class) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/LocalTestNode.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Class LocalTestNode, a helper class for TestDoubleOrderedMap\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Marc Johnson (marcj at users dot sourceforge dot net)\n+ */\n+class LocalTestNode<K extends Comparable<K>, V extends Comparable<V>> implements Comparable<LocalTestNode<K, V>> {\n+\n+    private K key;\n+    private V value;\n+\n+    @SuppressWarnings(\"boxing\")\n+    static LocalTestNode<Integer, String> createLocalTestNode(final int key) {\n+        return new LocalTestNode<Integer, String>(key, String.valueOf(key));\n+    }\n+\n+    /**\n+     * construct a LocalTestNode\n+     *\n+     * @param key value used to create the key and value\n+     */\n+    private LocalTestNode(K key, V value) {\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * @param key the unique key associated with the current node.\n+     */\n+    void setKey(K key) {\n+        this.key = key;\n+    }\n+\n+    /**\n+     * @return the unique key associated with the current node\n+     */\n+    K getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * @param value the unique value associated with the current node.\n+     */\n+    void setValue(V value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * @return the unique value associated with the current node\n+     */\n+    V getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Method compareTo\n+     *\n+     * @param other\n+     *\n+     * @return a negative integer, zero, or a positive integer\n+     *  as this object is less than, equal to, or greater than the specified object.\n+     */\n+    public int compareTo(LocalTestNode<K, V> other) {\n+\n+        int rval = getKey().compareTo(other.getKey());\n+\n+        if (rval == 0) {\n+            rval = getValue().compareTo(other.getValue());\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * Method equals\n+     *\n+     * @param o\n+     *\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+\n+        if (o == null) {\n+            return false;\n+        }\n+\n+        if (!(o.getClass().equals(this.getClass()))) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\") // o has the correct class - see above\n+        LocalTestNode<K, V> node = (LocalTestNode<K, V>) o;\n+\n+        return (getKey().equals(node.getKey())\n+                && getValue().equals(node.getValue()));\n+    }\n+\n+    /**\n+     * @return hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return getKey().hashCode() ^ getValue().hashCode();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/MapPerformance.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+//import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+//import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.Flat3Map;\n+\n+/** \n+ * <code>TestMapPerformance</code> is designed to perform basic Map performance tests.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class MapPerformance {\n+\n+    /** The total number of runs for each test */    \n+    private static final int RUNS = 20000000;\n+    \n+    /**\n+     * Main method\n+     */\n+    public static void main(String[] args) {\n+        testAll();\n+    }\n+    \n+    private static void testAll() {\n+        Map<String, String> dummyMap = new DummyMap<String, String>();\n+        Map<String, String> hashMap = new HashMap<String, String>();\n+//        hashMap.put(\"Alpha\", \"A\");\n+//        hashMap.put(\"Beta\", \"B\");\n+//        hashMap.put(\"Gamma\", \"C\");\n+//        hashMap.put(\"Delta\", \"D\");\n+        Map<String, String> flatMap = new Flat3Map<String, String>(hashMap);\n+        System.out.println(flatMap);\n+//        Map<String, String> unmodHashMap = Collections.unmodifiableMap(new HashMap<String, String>(hashMap));\n+//        Map fastHashMap = new FastHashMap(hashMap);\n+//        Map<String, String> treeMap = new TreeMap<String, String>(hashMap);\n+//        Map linkedMap = new LinkedHashMap(hashMap);\n+//        Map syncMap = Collections.unmodifiableMap(new HashMap(hashMap));\n+//        Map bucketMap = new StaticBucketMap();\n+//        bucketMap.putAll(hashMap);\n+//        Map doubleMap = new DoubleOrderedMap(hashMap);\n+        \n+        // dummy is required as the VM seems to hotspot the first call to the\n+        // test method with the given type\n+        test(dummyMap,      \"         Dummy \");\n+        test(dummyMap,      \"         Dummy \");\n+        test(dummyMap,      \"         Dummy \");\n+        test(flatMap,       \"         Flat3 \");\n+        test(hashMap,       \"       HashMap \");\n+        \n+        test(flatMap,       \"         Flat3 \");\n+        test(flatMap,       \"         Flat3 \");\n+        test(flatMap,       \"         Flat3 \");\n+        \n+        test(hashMap,       \"       HashMap \");\n+        test(hashMap,       \"       HashMap \");\n+        test(hashMap,       \"       HashMap \");\n+        \n+//        test(treeMap,       \"       TreeMap \");\n+//        test(treeMap,       \"       TreeMap \");\n+//        test(treeMap,       \"       TreeMap \");\n+        \n+//        test(unmodHashMap,  \"Unmod(HashMap) \");\n+//        test(unmodHashMap,  \"Unmod(HashMap) \");\n+//        test(unmodHashMap,  \"Unmod(HashMap) \");\n+//        \n+//        test(syncMap,       \" Sync(HashMap) \");\n+//        test(syncMap,       \" Sync(HashMap) \");\n+//        test(syncMap,       \" Sync(HashMap) \");\n+//        \n+//        test(fastHashMap,   \"   FastHashMap \");\n+//        test(fastHashMap,   \"   FastHashMap \");\n+//        test(fastHashMap,   \"   FastHashMap \");\n+//        \n+//        test(seqMap,        \"    SeqHashMap \");\n+//        test(seqMap,        \"    SeqHashMap \");\n+//        test(seqMap,        \"    SeqHashMap \");\n+//        \n+//        test(linkedMap,     \" LinkedHashMap \");\n+//        test(linkedMap,     \" LinkedHashMap \");\n+//        test(linkedMap,     \" LinkedHashMap \");\n+//        \n+//        test(bucketMap,     \"     BucketMap \");\n+//        test(bucketMap,     \"     BucketMap \");\n+//        test(bucketMap,     \"     BucketMap \");\n+//        \n+//        test(doubleMap,     \"     DoubleMap \");\n+//        test(doubleMap,     \"     DoubleMap \");\n+//        test(doubleMap,     \"     DoubleMap \");\n+    }\n+\n+    private static void test(Map<String, String> map, String name) {\n+        long start = 0, end = 0;\n+//        int total = 0;\n+        start = System.currentTimeMillis();\n+        for (int i = RUNS; i > 0; i--) {\n+//            if (map.get(\"Alpha\") != null) total++;\n+//            if (map.get(\"Beta\") != null) total++;\n+//            if (map.get(\"Gamma\") != null) total++;\n+            map.put(\"Alpha\", \"A\");\n+            map.put(\"Beta\", \"B\");\n+            map.put(\"Beta\", \"C\");\n+            map.put(\"Gamma\", \"D\");\n+//            map.remove(\"Gamma\");\n+//            map.remove(\"Beta\");\n+//            map.remove(\"Alpha\");\n+            map.put(\"Delta\", \"E\");\n+            map.clear();\n+        }\n+        end = System.currentTimeMillis();\n+        System.out.println(name + (end - start));\n+    }\n+\n+    // ----------------------------------------------------------------------\n+\n+    private static class DummyMap<K, V> implements Map<K, V> {\n+        public void clear() {\n+        }\n+        public boolean containsKey(Object key) {\n+            return false;\n+        }\n+        public boolean containsValue(Object value) {\n+            return false;\n+        }\n+        public Set<Map.Entry<K, V>> entrySet() {\n+            return null;\n+        }\n+        public V get(Object key) {\n+            return null;\n+        }\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+        public Set<K> keySet() {\n+            return null;\n+        }\n+        public V put(K key, V value) {\n+            return null;\n+        }\n+        public void putAll(Map<? extends K, ? extends V> t) {\n+        }\n+        public V remove(Object key) {\n+            return null;\n+        }\n+        public int size() {\n+            return 0;\n+        }\n+        public Collection<V> values() {\n+            return null;\n+        }\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/MockTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.easymock.EasyMock;\n+import org.easymock.IExpectationSetters;\n+\n+/**\n+ * Provides utilities for making mock-based tests.  Most notable is the generic \"type-safe\"\n+ * {@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods\n+ * that call the respective methods on all created mock objects.\n+ * \n+ * @author Stephen Kestle\n+ */\n+public abstract class MockTestCase {\n+    private List<Object> mockObjects = new ArrayList<Object>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T createMock(Class<?> name) {\n+        T mock = (T) EasyMock.createMock(name);\n+        return registerMock(mock);\n+    }\n+\n+    private <T> T registerMock(T mock) {\n+        mockObjects.add(mock);\n+        return mock;\n+    }\n+\n+    protected <T> IExpectationSetters<T> expect(T t) {\n+        return EasyMock.expect(t);\n+    }\n+\n+    protected final void replay() {\n+        for (Object o : mockObjects) {\n+            EasyMock.replay(o);\n+        }\n+    }\n+\n+    protected final void verify() {\n+        for (ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {\n+            try {\n+                EasyMock.verify(i.next());\n+            } catch (AssertionError e) {\n+                throw new AssertionError((i.previousIndex() + 1) + \"\"\n+                        + e.getMessage());\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestArrayStack.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.EmptyStackException;\n+\n+import junit.framework.Test;\n+\n+/**\n+ * Tests ArrayStack.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Craig McClanahan\n+ */\n+public class TestArrayStack<E> extends AbstractTestArrayList<E> {\n+    \n+    public TestArrayStack(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestArrayStack.class);\n+    }\n+\n+    @Override\n+    public ArrayStack<E> makeObject() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNewStack() {\n+        ArrayStack<E> stack = makeObject();\n+        assertTrue(\"New stack is empty\", stack.empty());\n+        assertEquals(\"New stack has size zero\", 0, stack.size());\n+\n+        try {\n+            stack.peek();\n+            fail(\"peek() should have thrown EmptyStackException\");\n+        } catch (EmptyStackException e) {\n+            // Expected result\n+        }\n+\n+        try {\n+            stack.pop();\n+            fail(\"pop() should have thrown EmptyStackException\");\n+        } catch (EmptyStackException e) {\n+            // Expected result\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPushPeekPop() {\n+        ArrayStack<E> stack = makeObject();\n+\n+        stack.push((E) \"First Item\");\n+        assertTrue(\"Stack is not empty\", !stack.empty());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+        assertEquals(\"Top item is 'First Item'\",\n+                     \"First Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+\n+        stack.push((E) \"Second Item\");\n+        assertEquals(\"Stack size is two\", 2, stack.size());\n+        assertEquals(\"Top item is 'Second Item'\",\n+                     \"Second Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is two\", 2, stack.size());\n+\n+        assertEquals(\"Popped item is 'Second Item'\",\n+                     \"Second Item\", (String) stack.pop());\n+        assertEquals(\"Top item is 'First Item'\",\n+                     \"First Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+\n+        assertEquals(\"Popped item is 'First Item'\",\n+                     \"First Item\", (String) stack.pop());\n+        assertEquals(\"Stack size is zero\", 0, stack.size());\n+\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        ArrayStack<E> stack = makeObject();\n+\n+        stack.push((E) \"First Item\");\n+        stack.push((E) \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\",\n+                     1, stack.search(\"Second Item\"));\n+        assertEquals(\"Next Item is 'First Item'\",\n+                     2, stack.search(\"First Item\"));\n+        assertEquals(\"Cannot find 'Missing Item'\",\n+                     -1, stack.search(\"Missing Item\"));\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestBagUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.bag.HashBag;\n+import org.apache.commons.collections.bag.PredicatedBag;\n+import org.apache.commons.collections.bag.PredicatedSortedBag;\n+import org.apache.commons.collections.bag.SynchronizedBag;\n+import org.apache.commons.collections.bag.SynchronizedSortedBag;\n+import org.apache.commons.collections.bag.TransformedBag;\n+import org.apache.commons.collections.bag.TransformedSortedBag;\n+import org.apache.commons.collections.bag.TreeBag;\n+import org.apache.commons.collections.bag.UnmodifiableBag;\n+import org.apache.commons.collections.bag.UnmodifiableSortedBag;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Tests for BagUtils factory methods.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestBagUtils extends BulkTest {\n+\n+    public TestBagUtils(String name) {\n+        super(name);\n+    }\n+\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBagUtils.class);\n+    }\n+\n+    //----------------------------------------------------------------------\n+\n+    protected Class<?> stringClass = this.getName().getClass();\n+    protected Predicate<Object> truePredicate = TruePredicate.truePredicate();\n+    protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();\n+\n+    //----------------------------------------------------------------------\n+\n+    public void testSynchronizedBag() {\n+        Bag<Object> bag = BagUtils.synchronizedBag(new HashBag<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedBag.\",\n+            bag instanceof SynchronizedBag);\n+        try {\n+            bag = BagUtils.synchronizedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testUnmodifiableBag() {\n+        Bag<Object> bag = BagUtils.unmodifiableBag(new HashBag<Object>());\n+        assertTrue(\"Returned object should be an UnmodifiableBag.\",\n+            bag instanceof UnmodifiableBag);\n+        try {\n+            bag = BagUtils.unmodifiableBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPredicatedBag() {\n+        Bag<Object> bag = BagUtils.predicatedBag(new HashBag<Object>(), truePredicate);\n+        assertTrue(\"Returned object should be a PredicatedBag.\",\n+            bag instanceof PredicatedBag);\n+        try {\n+            bag = BagUtils.predicatedBag(null,truePredicate);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.predicatedBag(new HashBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+     public void testTransformedBag() {\n+        Bag<Object> bag = BagUtils.transformingBag(new HashBag<Object>(), nopTransformer);\n+        assertTrue(\"Returned object should be an TransformedBag.\",\n+            bag instanceof TransformedBag);\n+        try {\n+            bag = BagUtils.transformingBag(null, nopTransformer);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.transformingBag(new HashBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSynchronizedSortedBag() {\n+        Bag<Object> bag = BagUtils.synchronizedSortedBag(new TreeBag<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedSortedBag.\",\n+            bag instanceof SynchronizedSortedBag);\n+        try {\n+            bag = BagUtils.synchronizedSortedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testUnmodifiableSortedBag() {\n+        Bag<Object> bag = BagUtils.unmodifiableSortedBag(new TreeBag<Object>());\n+        assertTrue(\"Returned object should be an UnmodifiableSortedBag.\",\n+            bag instanceof UnmodifiableSortedBag);\n+        try {\n+            bag = BagUtils.unmodifiableSortedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPredicatedSortedBag() {\n+        Bag<Object> bag = BagUtils.predicatedSortedBag(new TreeBag<Object>(), truePredicate);\n+        assertTrue(\"Returned object should be a PredicatedSortedBag.\",\n+            bag instanceof PredicatedSortedBag);\n+        try {\n+            bag = BagUtils.predicatedSortedBag(null, truePredicate);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.predicatedSortedBag(new TreeBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testTransformedSortedBag() {\n+        Bag<Object> bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), nopTransformer);\n+        assertTrue(\"Returned object should be an TransformedSortedBag\",\n+            bag instanceof TransformedSortedBag);\n+        try {\n+            bag = BagUtils.transformingSortedBag(null, nopTransformer);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestBufferUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.buffer.PredicatedBuffer;\n+\n+/**\n+ * Tests for BufferUtils.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Unknown\n+ */\n+public class TestBufferUtils extends BulkTest {\n+\n+    public TestBufferUtils(String name) {\n+        super(name);\n+    }\n+\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBufferUtils.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public void testpredicatedBuffer() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        Buffer<Object> buffer = BufferUtils.predicatedBuffer(new ArrayStack<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedBuffer\",\n+            buffer instanceof PredicatedBuffer);\n+        try {\n+            buffer = BufferUtils.predicatedBuffer(new ArrayStack<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            buffer = BufferUtils.predicatedBuffer(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null buffer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestClosureUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionClosure;\n+import org.apache.commons.collections.functors.FalsePredicate;\n+import org.apache.commons.collections.functors.NOPClosure;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Tests the org.apache.commons.collections.ClosureUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestClosureUtils extends TestCase {\n+\n+    private static final Object cString = \"Hello\";\n+\n+    /**\n+     * Construct\n+     */\n+    public TestClosureUtils(String name) {\n+        super(name);\n+    }\n+\n+    static class MockClosure<T> implements Closure<T> {\n+        int count = 0;\n+\n+        public void execute(T object) {\n+            count++;\n+        }\n+\n+        public void reset() {\n+            count = 0;\n+        }\n+    }\n+\n+    static class MockTransformer<T> implements Transformer<T, T> {\n+        int count = 0;\n+\n+        public T transform(T object) {\n+            count++;\n+            return object;\n+        }\n+    }\n+\n+    // exceptionClosure\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionClosure() {\n+        assertNotNull(ClosureUtils.exceptionClosure());\n+        assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());\n+        try {\n+            ClosureUtils.exceptionClosure().execute(null);\n+        } catch (FunctorException ex) {\n+            try {\n+                ClosureUtils.exceptionClosure().execute(cString);\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nopClosure\n+    //------------------------------------------------------------------\n+\n+    public void testNopClosure() {\n+        StringBuilder buf = new StringBuilder(\"Hello\");\n+        ClosureUtils.nopClosure().execute(null);\n+        assertEquals(\"Hello\", buf.toString());\n+        ClosureUtils.nopClosure().execute(\"Hello\");\n+        assertEquals(\"Hello\", buf.toString());\n+    }\n+\n+    // invokeClosure\n+    //------------------------------------------------------------------\n+\n+    public void testInvokeClosure() {\n+        StringBuffer buf = new StringBuffer(\"Hello\"); // Only StringBuffer has setLength() method\n+        ClosureUtils.invokerClosure(\"reverse\").execute(buf);\n+        assertEquals(\"olleH\", buf.toString());\n+        buf = new StringBuffer(\"Hello\");\n+        ClosureUtils.invokerClosure(\"setLength\", new Class[] {Integer.TYPE}, new Object[] {new Integer(2)}).execute(buf);\n+        assertEquals(\"He\", buf.toString());\n+    }\n+\n+    // forClosure\n+    //------------------------------------------------------------------\n+\n+    public void testForClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.forClosure(5, cmd).execute(null);\n+        assertEquals(5, cmd.count);\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure<Object>()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(-1, new MockClosure<Object>()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(1, null));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(3, null));\n+        assertSame(cmd, ClosureUtils.forClosure(1, cmd));\n+    }\n+\n+    // whileClosure\n+    //------------------------------------------------------------------\n+\n+    public void testWhileClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), cmd).execute(null);\n+        assertEquals(0, cmd.count);\n+\n+        cmd = new MockClosure<Object>();\n+        ClosureUtils.whileClosure(PredicateUtils.uniquePredicate(), cmd).execute(null);\n+        assertEquals(1, cmd.count);\n+\n+        try {\n+            ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.whileClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // doWhileClosure\n+    //------------------------------------------------------------------\n+\n+    public void testDoWhileClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.doWhileClosure(cmd, FalsePredicate.falsePredicate()).execute(null);\n+        assertEquals(1, cmd.count);\n+\n+        cmd = new MockClosure<Object>();\n+        ClosureUtils.doWhileClosure(cmd, PredicateUtils.uniquePredicate()).execute(null);\n+        assertEquals(2, cmd.count);\n+\n+        try {\n+            ClosureUtils.doWhileClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // chainedClosure\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testChainedClosure() {\n+        MockClosure<Object> a = new MockClosure<Object>();\n+        MockClosure<Object> b = new MockClosure<Object>();\n+        ClosureUtils.chainedClosure(a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.<Object>chainedClosure(new Closure[] {a, b, a}).execute(null);\n+        assertEquals(2, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        Collection<Closure<Object>> coll = new ArrayList<Closure<Object>>();\n+        coll.add(b);\n+        coll.add(a);\n+        coll.add(b);\n+        ClosureUtils.<Object>chainedClosure(coll).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(2, b.count);\n+\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(new Closure[0]));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(Collections.<Closure<Object>>emptyList()));\n+\n+        try {\n+            ClosureUtils.chainedClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure((Closure[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure(new Closure[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList<Closure<Object>>();\n+            coll.add(null);\n+            coll.add(null);\n+            ClosureUtils.chainedClosure(coll);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // ifClosure\n+    //------------------------------------------------------------------\n+\n+    public void testIfClosure() {\n+        MockClosure<Object> a = new MockClosure<Object>();\n+        MockClosure<Object> b = null;\n+        ClosureUtils.ifClosure(TruePredicate.truePredicate(), a).execute(null);\n+        assertEquals(1, a.count);\n+\n+        a = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a).execute(null);\n+        assertEquals(0, a.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(TruePredicate.<Object>truePredicate(), a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a, b).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+    }\n+\n+    // switchClosure\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSwitchClosure() {\n+        MockClosure<String> a = new MockClosure<String>();\n+        MockClosure<String> b = new MockClosure<String>();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }).execute(\"HELLO\");\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        MockClosure<String> c = new MockClosure<String>();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }, c).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        a.reset();\n+        b.reset();\n+        Map<Predicate<String>, Closure<String>> map = new HashMap<Predicate<String>, Closure<String>>();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        ClosureUtils.<String>switchClosure(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        ClosureUtils.switchClosure(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        c.reset();\n+        map.clear();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        map.put(null, c);\n+        ClosureUtils.switchClosure(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new Predicate[0], new Closure[0]));\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new HashMap<Predicate<String>, Closure<String>>()));\n+        map.clear();\n+        map.put(null, null);\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchClosure(map));\n+\n+        try {\n+            ClosureUtils.switchClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure(\n+                    new Predicate[] { TruePredicate.<String>truePredicate() },\n+                    new Closure[] { a, b });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // switchMapClosure\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchMapClosure() {\n+        MockClosure<String> a = new MockClosure<String>();\n+        MockClosure<String> b = new MockClosure<String>();\n+        Map<String, Closure<String>> map = new HashMap<String, Closure<String>>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ClosureUtils.switchMapClosure(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ClosureUtils.switchMapClosure(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        MockClosure<String> c = new MockClosure<String>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        map.put(null, c);\n+        ClosureUtils.switchMapClosure(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchMapClosure(new HashMap<String, Closure<String>>()));\n+\n+        try {\n+            ClosureUtils.switchMapClosure(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // asClosure\n+    //------------------------------------------------------------------\n+\n+    public void testTransformerClosure() {\n+        MockTransformer<Object> mock = new MockTransformer<Object>();\n+        Closure<Object> closure = ClosureUtils.asClosure(mock);\n+        closure.execute(null);\n+        assertEquals(1, mock.count);\n+        closure.execute(null);\n+        assertEquals(2, mock.count);\n+\n+        assertEquals(ClosureUtils.nopClosure(), ClosureUtils.asClosure(null));\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Closure singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionClosure.INSTANCE,\n+                NOPClosure.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestCollectionUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import static junit.framework.Assert.assertFalse;\n+import static org.apache.commons.collections.functors.EqualPredicate.equalPredicate;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.*;\n+\n+import org.apache.commons.collections.bag.HashBag;\n+import org.apache.commons.collections.buffer.BoundedFifoBuffer;\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Tests for CollectionUtils.\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ * @author Steven Melzer\n+ * @author Neil O'Toole\n+ * @author Stephen Smith\n+ * @author Stephen Kestle\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestCollectionUtils extends MockTestCase {\n+\n+    /**\n+     * Collection of {@link Integer}s\n+     */\n+    private List<Integer> collectionA = null;\n+\n+    /**\n+     * Collection of {@link Long}s\n+     */\n+    private List<Long> collectionB = null;\n+\n+    /**\n+     * Collection of {@link Integer}s that are equivalent to the Longs in\n+     * collectionB.\n+     */\n+    private Collection<Integer> collectionC = null;\n+\n+    /**\n+     * Collection of {@link Integer}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionA2 = null;\n+\n+    /**\n+     * Collection of {@link Long}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionB2 = null;\n+\n+    /**\n+     * Collection of {@link Integer}s (cast as {@link Number}s) that are\n+     * equivalent to the Longs in collectionB.\n+     */\n+    private Collection<Number> collectionC2 = null;\n+\n+    private Iterable<Integer> iterableA = null;\n+\n+    private Iterable<Long> iterableB = null;\n+\n+    private Iterable<Integer> iterableC = null;\n+\n+    private Iterable<Number> iterableA2 = null;\n+\n+    private Iterable<Number> iterableB2 = null;\n+\n+    @Before\n+    public void setUp() {\n+        collectionA = new ArrayList<Integer>();\n+        collectionA.add(1);\n+        collectionA.add(2);\n+        collectionA.add(2);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionB = new LinkedList<Long>();\n+        collectionB.add(5L);\n+        collectionB.add(4L);\n+        collectionB.add(4L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+\n+        collectionC = new ArrayList<Integer>();\n+        for (Long l : collectionB) {\n+            collectionC.add(l.intValue());\n+        }\n+\n+        iterableA = collectionA;\n+        iterableB = collectionB;\n+        iterableC = collectionC;\n+        collectionA2 = new ArrayList<Number>(collectionA);\n+        collectionB2 = new LinkedList<Number>(collectionB);\n+        collectionC2 = new LinkedList<Number>(collectionC);\n+        iterableA2 = collectionA2;\n+        iterableB2 = collectionB2;\n+    }\n+\n+    @Test\n+    public void getCardinalityMap() {\n+        Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);\n+        assertEquals(1, (int) freqA.get(1));\n+        assertEquals(2, (int) freqA.get(2));\n+        assertEquals(3, (int) freqA.get(3));\n+        assertEquals(4, (int) freqA.get(4));\n+        assertNull(freqA.get(5));\n+\n+        Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);\n+        assertNull(freqB.get(1L));\n+        assertEquals(4, (int) freqB.get(2L));\n+        assertEquals(3, (int) freqB.get(3L));\n+        assertEquals(2, (int) freqB.get(4L));\n+        assertEquals(1, (int) freqB.get(5L));\n+    }\n+\n+    @Test\n+    public void cardinality() {\n+        assertEquals(1, CollectionUtils.cardinality(1, iterableA));\n+        assertEquals(2, CollectionUtils.cardinality(2, iterableA));\n+        assertEquals(3, CollectionUtils.cardinality(3, iterableA));\n+        assertEquals(4, CollectionUtils.cardinality(4, iterableA));\n+        assertEquals(0, CollectionUtils.cardinality(5, iterableA));\n+\n+        assertEquals(0, CollectionUtils.cardinality(1L, iterableB));\n+        assertEquals(4, CollectionUtils.cardinality(2L, iterableB));\n+        assertEquals(3, CollectionUtils.cardinality(3L, iterableB));\n+        assertEquals(2, CollectionUtils.cardinality(4L, iterableB));\n+        assertEquals(1, CollectionUtils.cardinality(5L, iterableB));\n+\n+        // Ensure that generic bounds accept valid parameters, but return\n+        // expected results\n+        // e.g. no longs in the \"int\" Iterable<Number>, and vice versa.\n+        assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));\n+        assertEquals(0, CollectionUtils.cardinality(2, iterableB2));\n+\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"A\");\n+        set.add(\"C\");\n+        set.add(\"E\");\n+        set.add(\"E\");\n+        assertEquals(1, CollectionUtils.cardinality(\"A\", set));\n+        assertEquals(0, CollectionUtils.cardinality(\"B\", set));\n+        assertEquals(1, CollectionUtils.cardinality(\"C\", set));\n+        assertEquals(0, CollectionUtils.cardinality(\"D\", set));\n+        assertEquals(1, CollectionUtils.cardinality(\"E\", set));\n+\n+        Bag<String> bag = new HashBag<String>();\n+        bag.add(\"A\", 3);\n+        bag.add(\"C\");\n+        bag.add(\"E\");\n+        bag.add(\"E\");\n+        assertEquals(3, CollectionUtils.cardinality(\"A\", bag));\n+        assertEquals(0, CollectionUtils.cardinality(\"B\", bag));\n+        assertEquals(1, CollectionUtils.cardinality(\"C\", bag));\n+        assertEquals(0, CollectionUtils.cardinality(\"D\", bag));\n+        assertEquals(2, CollectionUtils.cardinality(\"E\", bag));\n+    }\n+\n+    @Test\n+    public void cardinalityOfNull() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertNull(freq.get(null));\n+        }\n+        list.add(\"A\");\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertNull(freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(1), freq.get(null));\n+        }\n+        list.add(\"B\");\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(1), freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(2), freq.get(null));\n+        }\n+        list.add(\"B\");\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(2), freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(3, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(3), freq.get(null));\n+        }\n+    }\n+\n+    @Test\n+    public void containsAny() {\n+        Collection<String> empty = new ArrayList<String>(0);\n+        Collection<String> one = new ArrayList<String>(1);\n+        one.add(\"1\");\n+        Collection<String> two = new ArrayList<String>(1);\n+        two.add(\"2\");\n+        Collection<String> three = new ArrayList<String>(1);\n+        three.add(\"3\");\n+        Collection<String> odds = new ArrayList<String>(2);\n+        odds.add(\"1\");\n+        odds.add(\"3\");\n+\n+        assertTrue(\"containsAny({1},{1,3}) should return true.\", CollectionUtils.containsAny(one, odds));\n+        assertTrue(\"containsAny({1,3},{1}) should return true.\", CollectionUtils.containsAny(odds, one));\n+        assertTrue(\"containsAny({3},{1,3}) should return true.\", CollectionUtils.containsAny(three, odds));\n+        assertTrue(\"containsAny({1,3},{3}) should return true.\", CollectionUtils.containsAny(odds, three));\n+        assertTrue(\"containsAny({2},{2}) should return true.\", CollectionUtils.containsAny(two, two));\n+        assertTrue(\"containsAny({1,3},{1,3}) should return true.\", CollectionUtils.containsAny(odds, odds));\n+\n+        assertTrue(\"containsAny({2},{1,3}) should return false.\", !CollectionUtils.containsAny(two, odds));\n+        assertTrue(\"containsAny({1,3},{2}) should return false.\", !CollectionUtils.containsAny(odds, two));\n+        assertTrue(\"containsAny({1},{3}) should return false.\", !CollectionUtils.containsAny(one, three));\n+        assertTrue(\"containsAny({3},{1}) should return false.\", !CollectionUtils.containsAny(three, one));\n+        assertTrue(\"containsAny({1,3},{}) should return false.\", !CollectionUtils.containsAny(odds, empty));\n+        assertTrue(\"containsAny({},{1,3}) should return false.\", !CollectionUtils.containsAny(empty, odds));\n+        assertTrue(\"containsAny({},{}) should return false.\", !CollectionUtils.containsAny(empty, empty));\n+    }\n+\n+    @Test\n+    public void union() {\n+        Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertEquals(Integer.valueOf(4), freq.get(2));\n+        assertEquals(Integer.valueOf(3), freq.get(3));\n+        assertEquals(Integer.valueOf(4), freq.get(4));\n+        assertEquals(Integer.valueOf(1), freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(4), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(4), freq2.get(4));\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+    }\n+\n+    @Test\n+    public void intersection() {\n+        Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertNull(freq.get(1));\n+        assertEquals(Integer.valueOf(2), freq.get(2));\n+        assertEquals(Integer.valueOf(3), freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertNull(freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertNull(freq2.get(5));\n+    }\n+\n+    @Test\n+    public void disjunction() {\n+        Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertEquals(Integer.valueOf(2), freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertEquals(Integer.valueOf(1), freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertNull(freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+    }\n+\n+    @Test\n+    public void testDisjunctionAsUnionMinusIntersection() {\n+        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);\n+        Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));\n+    }\n+\n+    @Test\n+    public void testDisjunctionAsSymmetricDifference() {\n+        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);\n+        Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertNull(freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+        assertNull(freq2.get(4));\n+        assertNull(freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertNull(freq2.get(1));\n+    }\n+\n+    @Test\n+    public void testSubtractWithPredicate() {\n+        // greater than 3\n+        Predicate<Number> predicate = new Predicate<Number>() {\n+            public boolean evaluate(Number n) {\n+                return n.longValue() > 3L;\n+            }\n+        };\n+        \n+        Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertNull(freq2.get(5));\n+    }\n+\n+    @Test\n+    public void testIsSubCollectionOfSelf() {\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n+    public void testIsSubCollection() {\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsSubCollection2() {\n+        Collection<Integer> c = new ArrayList<Integer>();\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(1);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(5);\n+        assertTrue(!CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionToSelf() {\n+        assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isEqualCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollection() {\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionReturnsFalse() {\n+        List<Integer> b = new ArrayList<Integer>(collectionA);\n+        // remove an extra '2', and add a 5.  This will increase the size of the cardinality\n+        b.remove(1);\n+        b.add(5);\n+        assertFalse(CollectionUtils.isEqualCollection(collectionA, b));\n+        assertFalse(CollectionUtils.isEqualCollection(b, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollection2() {\n+        Collection<String> a = new ArrayList<String>();\n+        Collection<String> b = new ArrayList<String>();\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"1\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"2\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"2\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"1\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+    }\n+\n+    @Test\n+    public void testIsProperSubCollection() {\n+        Collection<String> a = new ArrayList<String>();\n+        Collection<String> b = new ArrayList<String>();\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isProperSubCollection(a, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, a));\n+        a.add(\"1\");\n+        a.add(\"2\");\n+        b.add(\"2\");\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n+        a.add(\"1\");\n+        assertTrue(CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.intersection(collectionA, collectionC), collectionA));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.subtract(a, b), a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, CollectionUtils.subtract(a, b)));\n+    }\n+\n+    @Test\n+    public void find() {\n+        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n+        Integer test = CollectionUtils.find(collectionA, testPredicate);\n+        assertTrue(test.equals(4));\n+        testPredicate = equalPredicate((Number) 45);\n+        test = CollectionUtils.find(collectionA, testPredicate);\n+        assertTrue(test == null);\n+        assertNull(CollectionUtils.find(null,testPredicate));\n+        assertNull(CollectionUtils.find(collectionA, null));\n+    }\n+\n+    @Test\n+    public void forAllDo() {\n+        Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        col.add(collectionA);\n+        col.add(collectionB);\n+        Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col, testClosure);\n+        assertSame(testClosure, resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo(col, null);\n+        assertNull(resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo(null, testClosure);\n+        col.add(null);\n+        // null should be OK\n+        CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @Test(expected = FunctorException.class)\n+    public void forAllDoFailure() {\n+        Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<String> col = new ArrayList<String>();\n+        col.add(\"x\");\n+        CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @Test\n+    public void getFromMap() {\n+        // Unordered map, entries exist\n+        Map<String, String> expected = new HashMap<String, String>();\n+        expected.put(\"zeroKey\", \"zero\");\n+        expected.put(\"oneKey\", \"one\");\n+\n+        Map<String, String> found = new HashMap<String, String>();\n+        Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);\n+        found.put(entry.getKey(), entry.getValue());\n+        entry = CollectionUtils.get(expected, 1);\n+        found.put(entry.getKey(), entry.getValue());\n+        assertEquals(expected, found);\n+\n+        // Map index out of range\n+        try {\n+            CollectionUtils.get(expected, 2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            CollectionUtils.get(expected, -2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        // Sorted map, entries exist, should respect order\n+        SortedMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"zeroKey\", \"zero\");\n+        map.put(\"oneKey\", \"one\");\n+        Map.Entry<String, String> test = CollectionUtils.get(map, 1);\n+        assertEquals(\"zeroKey\", test.getKey());\n+        assertEquals(\"zero\", test.getValue());\n+        test = CollectionUtils.get(map, 0);\n+        assertEquals(\"oneKey\", test.getKey());\n+        assertEquals(\"one\", test.getValue());\n+    }\n+\n+    /**\n+     * Tests that {@link List}s are handled correctly - e.g. using\n+     * {@link List#get(int)}.\n+     */\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getFromList() throws Exception {\n+        // List, entry exists\n+        List<String> list = createMock(List.class);\n+        expect(list.get(0)).andReturn(\"zero\");\n+        expect(list.get(1)).andReturn(\"one\");\n+        replay();\n+        String string = CollectionUtils.get(list, 0);\n+        assertEquals(\"zero\", string);\n+        assertEquals(\"one\", CollectionUtils.get(list, 1));\n+        // list, non-existent entry -- IndexOutOfBoundsException\n+        CollectionUtils.get(new ArrayList<Object>(), 2);\n+    }\n+\n+    @Test\n+    public void getFromIterator() throws Exception {\n+        // Iterator, entry exists\n+        Iterator<Integer> iterator = iterableA.iterator();\n+        assertEquals(1, (int) CollectionUtils.get(iterator, 0));\n+        iterator = iterableA.iterator();\n+        assertEquals(2, (int) CollectionUtils.get(iterator, 1));\n+\n+        // Iterator, non-existent entry\n+        try {\n+            CollectionUtils.get(iterator, 10);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!iterator.hasNext());\n+    }\n+\n+    @Test\n+    public void getFromEnumeration() throws Exception {\n+        // Enumeration, entry exists\n+        Vector<String> vector = new Vector<String>();\n+        vector.addElement(\"zero\");\n+        vector.addElement(\"one\");\n+        Enumeration<String> en = vector.elements();\n+        assertEquals(\"zero\", CollectionUtils.get(en, 0));\n+        en = vector.elements();\n+        assertEquals(\"one\", CollectionUtils.get(en, 1));\n+\n+        // Enumerator, non-existent entry\n+        try {\n+            CollectionUtils.get(en, 3);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!en.hasMoreElements());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromIterable() throws Exception {\n+        // Collection, entry exists\n+        Bag<String> bag = new HashBag<String>();\n+        bag.add(\"element\", 1);\n+        assertEquals(\"element\", CollectionUtils.get(bag, 0));\n+\n+        // Collection, non-existent entry\n+        CollectionUtils.get(bag, 1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromObjectArray() throws Exception {\n+        // Object array, entry exists\n+        Object[] objArray = new Object[2];\n+        objArray[0] = \"zero\";\n+        objArray[1] = \"one\";\n+        assertEquals(\"zero\", CollectionUtils.get(objArray, 0));\n+        assertEquals(\"one\", CollectionUtils.get(objArray, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(objArray, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromPrimativeArray() throws Exception {\n+        // Primitive array, entry exists\n+        int[] array = new int[2];\n+        array[0] = 10;\n+        array[1] = 20;\n+        assertEquals(10, CollectionUtils.get(array, 0));\n+        assertEquals(20, CollectionUtils.get(array, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(array, 2);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void getFromObject() throws Exception {\n+        // Invalid object\n+        Object obj = new Object();\n+        CollectionUtils.get(obj, 0);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testSize_List() {\n+        List<String> list = null;\n+        assertEquals(0, CollectionUtils.size(list));\n+        list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.size(list));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list));\n+    }\n+\n+    @Test\n+    public void testSize_Map() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        assertEquals(0, CollectionUtils.size(map));\n+        map.put(\"1\", \"a\");\n+        assertEquals(1, CollectionUtils.size(map));\n+        map.put(\"2\", \"b\");\n+        assertEquals(2, CollectionUtils.size(map));\n+    }\n+\n+    @Test\n+    public void testSize_Array() {\n+        Object[] objectArray = new Object[0];\n+        assertEquals(0, CollectionUtils.size(objectArray));\n+\n+        String[] stringArray = new String[3];\n+        assertEquals(3, CollectionUtils.size(stringArray));\n+        stringArray[0] = \"a\";\n+        stringArray[1] = \"b\";\n+        stringArray[2] = \"c\";\n+        assertEquals(3, CollectionUtils.size(stringArray));\n+    }\n+\n+    @Test\n+    public void testSize_PrimitiveArray() {\n+        int[] intArray = new int[0];\n+        assertEquals(0, CollectionUtils.size(intArray));\n+\n+        double[] doubleArray = new double[3];\n+        assertEquals(3, CollectionUtils.size(doubleArray));\n+        doubleArray[0] = 0.0d;\n+        doubleArray[1] = 1.0d;\n+        doubleArray[2] = 2.5d;\n+        assertEquals(3, CollectionUtils.size(doubleArray));\n+    }\n+\n+    @Test\n+    public void testSize_Enumeration() {\n+        Vector<String> list = new Vector<String>();\n+        assertEquals(0, CollectionUtils.size(list.elements()));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list.elements()));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list.elements()));\n+    }\n+\n+    @Test\n+    public void testSize_Iterator() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.size(list.iterator()));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list.iterator()));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list.iterator()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testSize_Other() {\n+        CollectionUtils.size(\"not a list\");\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testSizeIsEmpty_Null() {\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(null));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_List() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Map() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(map));\n+        map.put(\"1\", \"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(map));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Array() {\n+        Object[] objectArray = new Object[0];\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(objectArray));\n+\n+        String[] stringArray = new String[3];\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n+        stringArray[0] = \"a\";\n+        stringArray[1] = \"b\";\n+        stringArray[2] = \"c\";\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_PrimitiveArray() {\n+        int[] intArray = new int[0];\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(intArray));\n+\n+        double[] doubleArray = new double[3];\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n+        doubleArray[0] = 0.0d;\n+        doubleArray[1] = 1.0d;\n+        doubleArray[2] = 2.5d;\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Enumeration() {\n+        Vector<String> list = new Vector<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list.elements()));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list.elements()));\n+        Enumeration<String> en = list.elements();\n+        en.nextElement();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(en));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Iterator() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list.iterator()));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list.iterator()));\n+        Iterator<String> it = list.iterator();\n+        it.next();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(it));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Other() {\n+        try {\n+            CollectionUtils.sizeIsEmpty(\"not a list\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testIsEmptyWithEmptyCollection() {\n+        Collection<Object> coll = new ArrayList<Object>();\n+        assertEquals(true, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsEmptyWithNonEmptyCollection() {\n+        Collection<String> coll = new ArrayList<String>();\n+        coll.add(\"item\");\n+        assertEquals(false, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsEmptyWithNull() {\n+        Collection<?> coll = null;\n+        assertEquals(true, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithEmptyCollection() {\n+        Collection<Object> coll = new ArrayList<Object>();\n+        assertEquals(false, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithNonEmptyCollection() {\n+        Collection<String> coll = new ArrayList<String>();\n+        coll.add(\"item\");\n+        assertEquals(true, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithNull() {\n+        Collection<?> coll = null;\n+        assertEquals(false, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n+        public boolean evaluate(Number input) {\n+            return (input.intValue() == 2);\n+        }\n+    };\n+\n+//Up to here\n+    @SuppressWarnings(\"cast\")\n+    @Test\n+    public void filter() {\n+        List<Integer> ints = new ArrayList<Integer>();\n+        ints.add(1);\n+        ints.add(2);\n+        ints.add(3);\n+        ints.add(3);\n+        Iterable<Integer> iterable = ints;\n+        assertTrue(CollectionUtils.filter(iterable, EQUALS_TWO));\n+        assertEquals(1, (int) ints.size());\n+        assertEquals(2, (int) ints.get(0));\n+    }\n+\n+    @Test\n+    public void filterNullParameters() throws Exception {\n+        List<Long> longs = Collections.nCopies(4, 10L);\n+        assertFalse(CollectionUtils.filter(longs, null));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filter(null, EQUALS_TWO));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filter(null, null));\n+        assertEquals(4, longs.size());\n+    }\n+\n+    @Test\n+    public void countMatches() {\n+        assertEquals(4, CollectionUtils.countMatches(iterableB, EQUALS_TWO));\n+        assertEquals(0, CollectionUtils.countMatches(iterableA, null));\n+        assertEquals(0, CollectionUtils.countMatches(null, EQUALS_TWO));\n+        assertEquals(0, CollectionUtils.countMatches(null, null));\n+    }\n+\n+    @Test\n+    public void exists() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        assertFalse(CollectionUtils.exists(null, null));\n+        assertFalse(CollectionUtils.exists(list, null));\n+        assertFalse(CollectionUtils.exists(null, EQUALS_TWO));\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+        list.add(1);\n+        list.add(3);\n+        list.add(4);\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+\n+        list.add(2);\n+        assertEquals(true, CollectionUtils.exists(list, EQUALS_TWO));\n+    }\n+\n+    @Test\n+    public void select() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        // Ensure that the collection is the input type or a super type\n+        Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);\n+        Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);\n+        HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(1, output1.size());\n+        assertEquals(2, output2.iterator().next());\n+    }\n+\n+    @Test\n+    public void selectRejected() {\n+        List<Long> list = new ArrayList<Long>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        list.add(4L);\n+        Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(3, output1.size());\n+        assertTrue(output1.contains(1L));\n+        assertTrue(output1.contains(3L));\n+        assertTrue(output1.contains(4L));\n+    }\n+\n+    @Test\n+    public void collect() {\n+        Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);\n+        Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertCollectResult(collection);\n+\n+        ArrayList<Number> list;\n+        list = CollectionUtils.collect(collectionA, transformer, new ArrayList<Number>());\n+        assertTrue(list.size() == collectionA.size());\n+        assertCollectResult(list);\n+\n+        Iterator<Integer> iterator = null;\n+        list = CollectionUtils.collect(iterator, transformer, new ArrayList<Number>());\n+\n+        iterator = iterableA.iterator();\n+        list = CollectionUtils.collect(iterator, transformer, list);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertCollectResult(collection);\n+\n+        iterator = collectionA.iterator();\n+        collection = CollectionUtils.<Integer, Number>collect(iterator, transformer);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+        collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);\n+        assertTrue(collection.size() == 0);\n+\n+        int size = collectionA.size();\n+        collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n+        CollectionUtils.collect(collectionB, null, collectionA);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n+\n+    }\n+\n+    private void assertCollectResult(Collection<Number> collection) {\n+        assertTrue(collectionA.contains(1) && !collectionA.contains(2L));\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+    }\n+\n+    Transformer<Object, Integer> TRANSFORM_TO_INTEGER = new Transformer<Object, Integer>() {\n+        public Integer transform(Object input) {\n+            return new Integer(((Long)input).intValue());\n+        }\n+    };\n+\n+    @Test\n+    public void transform1() {\n+        List<Number> list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        CollectionUtils.transform(list, TRANSFORM_TO_INTEGER);\n+        assertEquals(3, list.size());\n+        assertEquals(1, list.get(0));\n+        assertEquals(2, list.get(1));\n+        assertEquals(3, list.get(2));\n+\n+        list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        CollectionUtils.transform(null, TRANSFORM_TO_INTEGER);\n+        assertEquals(3, list.size());\n+        CollectionUtils.transform(list, null);\n+        assertEquals(3, list.size());\n+        CollectionUtils.transform(null, null);\n+        assertEquals(3, list.size());\n+    }\n+\n+    @Test\n+    public void transform2() {\n+        Set<Number> set = new HashSet<Number>();\n+        set.add(1L);\n+        set.add(2L);\n+        set.add(3L);\n+        CollectionUtils.transform(set, new Transformer<Object, Integer>() {\n+            public Integer transform(Object input) {\n+                return 4;\n+            }\n+        });\n+        assertEquals(1, set.size());\n+        assertEquals(4, set.iterator().next());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void addIgnoreNull() {\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        assertFalse(CollectionUtils.addIgnoreNull(set, null));\n+        assertEquals(3, set.size());\n+        assertFalse(CollectionUtils.addIgnoreNull(set, \"1\"));\n+        assertEquals(3, set.size());\n+        assertEquals(true, CollectionUtils.addIgnoreNull(set, \"4\"));\n+        assertEquals(4, set.size());\n+        assertEquals(true, set.contains(\"4\"));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void predicatedCollection() {\n+        Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n+        Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection);\n+        try {\n+            collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            CollectionUtils.predicatedCollection(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void isFull() {\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        try {\n+            CollectionUtils.isFull(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+        assertFalse(CollectionUtils.isFull(set));\n+\n+        BoundedFifoBuffer<String> buf = new BoundedFifoBuffer<String>(set);\n+        assertEquals(true, CollectionUtils.isFull(buf));\n+        buf.remove(\"2\");\n+        assertFalse(CollectionUtils.isFull(buf));\n+        buf.add(\"2\");\n+        assertEquals(true, CollectionUtils.isFull(buf));\n+\n+        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n+        assertEquals(true, CollectionUtils.isFull(buf2));\n+        buf2.remove(\"2\");\n+        assertFalse(CollectionUtils.isFull(buf2));\n+        buf2.add(\"2\");\n+        assertEquals(true, CollectionUtils.isFull(buf2));\n+    }\n+\n+    @Test\n+    public void isEmpty() {\n+        assertFalse(CollectionUtils.isNotEmpty(null));\n+        assertTrue(CollectionUtils.isNotEmpty(collectionA));\n+    }\n+\n+    @Test\n+    public void maxSize() {\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        try {\n+            CollectionUtils.maxSize(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+        assertEquals(-1, CollectionUtils.maxSize(set));\n+\n+        Buffer<String> buf = new BoundedFifoBuffer<String>(set);\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+        buf.remove(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+        buf.add(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+\n+        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n+        assertEquals(3, CollectionUtils.maxSize(buf2));\n+        buf2.remove(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf2));\n+        buf2.add(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf2));\n+    }\n+\n+    @Test\n+    public void intersectionUsesMethodEquals() {\n+        // Let elta and eltb be objects...\n+        Integer elta = new Integer(17);\n+        Integer eltb = new Integer(17);\n+\n+        // ...which are equal...\n+        assertEquals(elta, eltb);\n+        assertEquals(eltb, elta);\n+\n+        // ...but not the same (==).\n+        assertTrue(elta != eltb);\n+\n+        // Let cola and colb be collections...\n+        Collection<Number> cola = new ArrayList<Number>();\n+        Collection<Integer> colb = new ArrayList<Integer>();\n+\n+        // ...which contain elta and eltb,\n+        // respectively.\n+        cola.add(elta);\n+        colb.add(eltb);\n+\n+        // Then the intersection of the two\n+        // should contain one element.\n+        Collection<Number> intersection = CollectionUtils.intersection(cola, colb);\n+        assertEquals(1, intersection.size());\n+\n+        // In practice, this element will be the same (==) as elta\n+        // or eltb, although this isn't strictly part of the\n+        // contract.\n+        Object eltc = intersection.iterator().next();\n+        assertTrue((eltc == elta && eltc != eltb) || (eltc != elta && eltc == eltb));\n+\n+        // In any event, this element remains equal,\n+        // to both elta and eltb.\n+        assertEquals(elta, eltc);\n+        assertEquals(eltc, elta);\n+        assertEquals(eltb, eltc);\n+        assertEquals(eltc, eltb);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    //Up to here\n+    @Test\n+    public void testRetainAll() {\n+        List<String> base = new ArrayList<String>();\n+        base.add(\"A\");\n+        base.add(\"B\");\n+        base.add(\"C\");\n+        List<Object> sub = new ArrayList<Object>();\n+        sub.add(\"A\");\n+        sub.add(\"C\");\n+        sub.add(\"X\");\n+\n+        Collection<String> result = CollectionUtils.retainAll(base, sub);\n+        assertEquals(2, result.size());\n+        assertEquals(true, result.contains(\"A\"));\n+        assertFalse(result.contains(\"B\"));\n+        assertEquals(true, result.contains(\"C\"));\n+        assertEquals(3, base.size());\n+        assertEquals(true, base.contains(\"A\"));\n+        assertEquals(true, base.contains(\"B\"));\n+        assertEquals(true, base.contains(\"C\"));\n+        assertEquals(3, sub.size());\n+        assertEquals(true, sub.contains(\"A\"));\n+        assertEquals(true, sub.contains(\"C\"));\n+        assertEquals(true, sub.contains(\"X\"));\n+\n+        try {\n+            CollectionUtils.retainAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    @Test\n+    public void testRemoveAll() {\n+        List<String> base = new ArrayList<String>();\n+        base.add(\"A\");\n+        base.add(\"B\");\n+        base.add(\"C\");\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(\"A\");\n+        sub.add(\"C\");\n+        sub.add(\"X\");\n+\n+        Collection<String> result = CollectionUtils.removeAll(base, sub);\n+        assertEquals(1, result.size());\n+        assertFalse(result.contains(\"A\"));\n+        assertEquals(true, result.contains(\"B\"));\n+        assertFalse(result.contains(\"C\"));\n+        assertEquals(3, base.size());\n+        assertEquals(true, base.contains(\"A\"));\n+        assertEquals(true, base.contains(\"B\"));\n+        assertEquals(true, base.contains(\"C\"));\n+        assertEquals(3, sub.size());\n+        assertEquals(true, sub.contains(\"A\"));\n+        assertEquals(true, sub.contains(\"C\"));\n+        assertEquals(true, sub.contains(\"X\"));\n+\n+        try {\n+            CollectionUtils.removeAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testTransformedCollection() {\n+        Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n+        Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), transformer);\n+        assertTrue(\"returned object should be a TransformedCollection\", collection instanceof TransformedCollection);\n+        try {\n+            collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            collection = CollectionUtils.transformingCollection(null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testTransformedCollection_2() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);\n+        assertEquals(true, result.contains(\"1\")); // untransformed\n+        assertEquals(true, result.contains(\"2\")); // untransformed\n+        assertEquals(true, result.contains(\"3\")); // untransformed\n+    }\n+\n+    @Test\n+    public void testSynchronizedCollection() {\n+        Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedCollection.\", col instanceof SynchronizedCollection);\n+        try {\n+            col = CollectionUtils.synchronizedCollection(null);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testUnmodifiableCollection() {\n+        Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a UnmodifiableCollection.\", col instanceof UnmodifiableCollection);\n+        try {\n+            col = CollectionUtils.unmodifiableCollection(null);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void emptyCollection() throws Exception {\n+        Collection<Number> coll = CollectionUtils.emptyCollection();\n+        assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);\n+    }\n+\n+    /**\n+     * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.\n+     * Specifically, it uses mocks to ensure that if the passed in\n+     * {@link Iterable} is a {@link Collection} then\n+     * {@link Collection#addAll(Collection)} is called instead of iterating.\n+     */\n+    @Test\n+    public void addAllForIterable() {\n+        Collection<Integer> inputCollection = createMock(Collection.class);\n+        Iterable<Integer> inputIterable = inputCollection;\n+        Iterable<Long> iterable = createMock(Iterable.class);\n+        Iterator<Long> iterator = createMock(Iterator.class);\n+        Collection<Number> c = createMock(Collection.class);\n+\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        next(iterator, 2L);\n+        next(iterator, 3L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(true);\n+        expect(c.add(2L)).andReturn(true);\n+        expect(c.add(3L)).andReturn(true);\n+        // Check that the collection is added using\n+        // Collection.addAll(Collection)\n+        expect(c.addAll(inputCollection)).andReturn(true);\n+\n+        // Ensure the method returns false if nothing is added\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(false);\n+        expect(c.addAll(inputCollection)).andReturn(false);\n+\n+        replay();\n+        assertTrue(CollectionUtils.addAll(c, iterable));\n+        assertTrue(CollectionUtils.addAll(c, inputIterable));\n+\n+        assertFalse(CollectionUtils.addAll(c, iterable));\n+        assertFalse(CollectionUtils.addAll(c, inputIterable));\n+        verify();\n+    }\n+\n+    @Test\n+    public void addAllForEnumeration() {\n+        Hashtable<Integer, Integer> h = new Hashtable<Integer, Integer>();\n+        h.put(5, 5);\n+        Enumeration<? extends Integer> enumeration = h.keys();\n+        CollectionUtils.addAll(collectionA, enumeration);\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test\n+    public void addAllForElements() {\n+        CollectionUtils.addAll(collectionA, new Integer[]{5});\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getNegative() {\n+        CollectionUtils.get((Object)collectionA, -3);\n+    }\n+\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getPositiveOutOfBounds() {\n+        CollectionUtils.get((Object)collectionA.iterator(), 30);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void get1() {\n+        CollectionUtils.get((Object)null, 0);\n+    }\n+\n+    @Test\n+    public void get() {\n+        assertEquals(2, CollectionUtils.get((Object)collectionA, 2));\n+        assertEquals(2, CollectionUtils.get((Object)collectionA.iterator(), 2));\n+        Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);\n+        assertEquals(map.entrySet().iterator().next(), CollectionUtils.get(\n+                (Object)map, 0));\n+    }\n+\n+    /**\n+     * TODO: Should {@link CollectionUtils} be able to be extended? If it is extended, subclasses must 'override' the static methods with\n+     * call-throughs anyhow, otherwise java compiler warnings will result\n+     */\n+    @Test\n+    public void ensureCollectionUtilsCanBeExtended() {\n+        new CollectionUtils() {};\n+    }\n+\n+    @Test\n+    public void reverse() {\n+        CollectionUtils.reverseArray(new Object[] {});\n+        Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);\n+        CollectionUtils.reverseArray(a);\n+        // assume our implementation is correct if it returns the same order as the Java function\n+        Collections.reverse(collectionA);\n+        assertEquals(collectionA, Arrays.asList(a));\n+    }\n+\n+    @Test\n+    public void extractSingleton() {\n+        ArrayList<String> coll = null;\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(null)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        coll = new ArrayList<String>();\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(empty)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        coll.add(\"foo\");\n+        assertEquals(\"foo\", CollectionUtils.extractSingleton(coll));\n+        coll.add(\"bar\");\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(size == 2)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    /**\n+     * Records the next object returned for a mock iterator\n+     */\n+    private <T> void next(Iterator<T> iterator, T t) {\n+        expect(iterator.hasNext()).andReturn(true);\n+        expect(iterator.next()).andReturn(t);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestEnumerationUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+\n+/**\n+ * Tests EnumerationUtils.\n+ *\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class TestEnumerationUtils extends BulkTest {\n+\n+    public TestEnumerationUtils(String name) {\n+        super(name);\n+    }\n+\n+    public static final String TO_LIST_FIXTURE = \"this is a test\";\n+    \n+    public void testToListWithStringTokenizer() {\n+        List<String> expectedList1 = new ArrayList<String>();\n+        StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n+             while (st.hasMoreTokens()) {\n+                 expectedList1.add(st.nextToken());\n+             }\n+        List<String> expectedList2 = new ArrayList<String>();\n+        expectedList2.add(\"this\");\n+        expectedList2.add(\"is\");\n+        expectedList2.add(\"a\");\n+        expectedList2.add(\"test\");\n+        List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n+        Assert.assertEquals(expectedList1, expectedList2);\n+        Assert.assertEquals(expectedList1, actualList);\n+        Assert.assertEquals(expectedList2, actualList);\n+    }\n+\n+    public void testToListWithHashtable() {\n+        Hashtable<String, Integer> expected = new Hashtable<String, Integer>();\n+        expected.put(\"one\", new Integer(1));\n+        expected.put(\"two\", new Integer(2));\n+        expected.put(\"three\", new Integer(3));\n+        // validate elements.\n+        List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());\n+        Assert.assertEquals(expected.size(), actualEltList.size());\n+        Assert.assertTrue(actualEltList.contains(new Integer(1)));\n+        Assert.assertTrue(actualEltList.contains(new Integer(2)));\n+        Assert.assertTrue(actualEltList.contains(new Integer(3)));\n+        List<Integer> expectedEltList = new ArrayList<Integer>();\n+        expectedEltList.add(new Integer(1));\n+        expectedEltList.add(new Integer(2));\n+        expectedEltList.add(new Integer(3));\n+        Assert.assertTrue(actualEltList.containsAll(expectedEltList));\n+\n+        // validate keys.\n+        List<String> actualKeyList = EnumerationUtils.toList(expected.keys());\n+        Assert.assertEquals(expected.size(), actualEltList.size());\n+        Assert.assertTrue(actualKeyList.contains(\"one\"));\n+        Assert.assertTrue(actualKeyList.contains(\"two\"));\n+        Assert.assertTrue(actualKeyList.contains(\"three\"));\n+        List<String> expectedKeyList = new ArrayList<String>();\n+        expectedKeyList.add(\"one\");\n+        expectedKeyList.add(\"two\");\n+        expectedKeyList.add(\"three\");\n+        Assert.assertTrue(actualKeyList.containsAll(expectedKeyList));\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestEnumerationUtils.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestExtendedProperties.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Properties;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests some basic functions of the ExtendedProperties class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Geir Magnusson Jr.\n+ * @author Mohan Kishore\n+ * @author Stephen Colebourne\n+ * @author Shinobu Kawai\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ */\n+public class TestExtendedProperties extends TestCase {\n+    \n+    protected ExtendedProperties eprop = new ExtendedProperties();\n+\n+    public TestExtendedProperties(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testRetrieve() {\n+        /*\n+         * should be empty and return null\n+         */\n+        assertNull(\"This returns null\", eprop.getProperty(\"foo\"));\n+\n+        /*\n+         *  add a real value, and get it two different ways\n+         */\n+        eprop.setProperty(\"number\", \"1\");\n+        assertEquals(\"This returns '1'\", \"1\", eprop.getProperty(\"number\"));\n+        assertEquals(\"This returns '1'\", \"1\", eprop.getString(\"number\"));\n+\n+        /*\n+         * now add another and get a Vector/list\n+         */\n+        eprop.addProperty(\"number\", \"2\");\n+        assertTrue(\"This returns array\", (eprop.getVector(\"number\") instanceof java.util.Vector));\n+        assertTrue(\"This returns array\", (eprop.getList(\"number\") instanceof java.util.List));\n+\n+        /*\n+         *  now test dan's new fix where we get the first scalar \n+         *  when we access a vector/list valued\n+         *  property\n+         */\n+        assertTrue(\"This returns scalar\", (eprop.getString(\"number\") instanceof String));\n+\n+        /*\n+         * test comma separated string properties\n+         */\n+        String prop = \"hey, that's a test\";\n+        eprop.setProperty(\"prop.string\", prop);\n+        assertTrue(\"This returns vector\", (eprop.getVector(\"prop.string\") instanceof java.util.Vector));\n+        assertTrue(\"This returns list\", (eprop.getList(\"prop.string\") instanceof java.util.List));\n+\n+        String prop2 = \"hey\\\\, that's a test\";\n+        eprop.remove(\"prop.string\");\n+        eprop.setProperty(\"prop.string\", prop2);\n+        assertTrue(\"This returns array\", (eprop.getString(\"prop.string\") instanceof java.lang.String));\n+\n+        /*\n+         * test subset : we want to make sure that the EP doesn't reprocess the data \n+         *  elements when generating the subset\n+         */\n+\n+        ExtendedProperties subEprop = eprop.subset(\"prop\");\n+\n+        assertTrue(\"Returns the full string\", subEprop.getString(\"string\").equals(prop));\n+        assertTrue(\"This returns string for subset\", (subEprop.getString(\"string\") instanceof java.lang.String));\n+        assertTrue(\"This returns array for subset\", (subEprop.getVector(\"string\") instanceof java.util.Vector));\n+        assertTrue(\"This returns array for subset\", (subEprop.getList(\"string\") instanceof java.util.List));\n+\n+    }\n+\n+    public void testInterpolation() {\n+        eprop.setProperty(\"applicationRoot\", \"/home/applicationRoot\");\n+        eprop.setProperty(\"db\", \"${applicationRoot}/db/hypersonic\");\n+        String dbProp = \"/home/applicationRoot/db/hypersonic\";\n+        assertTrue(\"Checking interpolated variable\", eprop.getString(\"db\").equals(dbProp));\n+    }\n+\n+    public void testSaveAndLoad() {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+        ExtendedProperties ep2 = new ExtendedProperties();\n+\n+        try {\n+            /* initialize value:\n+            one=Hello\\World\n+            two=Hello\\,World\n+            three=Hello,World\n+            */\n+            String s1 = \"one=Hello\\\\World\\ntwo=Hello\\\\,World\\nthree=Hello,World\";\n+            byte[] bytes = s1.getBytes();\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            ep1.load(bais);\n+            assertEquals(\"Back-slashes not interpreted properly\", \n+                    \"Hello\\\\World\", ep1.getString(\"one\"));\n+            assertEquals(\"Escaped commas not interpreted properly\", \n+                    \"Hello,World\", ep1.getString(\"two\"));\n+            assertEquals(\"Commas not interpreted properly\", \n+                    2, ep1.getVector(\"three\").size());\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"Hello\", ep1.getVector(\"three\").get(0));\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"World\", ep1.getVector(\"three\").get(1));\n+\n+            assertEquals(\"Commas not interpreted properly\", \n+                    2, ep1.getList(\"three\").size());\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"Hello\", ep1.getList(\"three\").get(0));\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"World\", ep1.getList(\"three\").get(1));\n+                    \n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            ep1.save(baos, null);\n+            bytes = baos.toByteArray();\n+            bais = new ByteArrayInputStream(bytes);\n+            ep2.load(bais);\n+            assertEquals(\"Back-slash not same after being saved and loaded\",\n+                    ep1.getString(\"one\"), ep2.getString(\"one\"));\n+            assertEquals(\"Escaped comma not same after being saved and loaded\",\n+                    ep1.getString(\"two\"), ep2.getString(\"two\"));\n+            assertEquals(\"Comma not same after being saved and loaded\",\n+                    ep1.getString(\"three\"), ep2.getString(\"three\"));\n+        } catch (IOException ioe) {\n+            fail(\"There was an exception saving and loading the EP\");\n+        }\n+    }\n+\n+    public void testTrailingBackSlash() {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        try {\n+            /*\n+            initialize using:\n+            one=ONE\n+            two=TWO \\\\\n+            three=THREE\n+            */\n+            String s1 = \"one=ONE\\ntwo=TWO \\\\\\\\\\nthree=THREE\";\n+            byte[] bytes = s1.getBytes();\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            ep1.load(bais);\n+            assertEquals(\"Trailing back-slashes not interpreted properly\", \n+                    3, ep1.size());\n+            assertEquals(\"Back-slash not escaped properly\", \n+                    \"TWO \\\\\", ep1.getString(\"two\"));\n+        } catch (IOException ioe) {\n+            fail(\"There was an exception loading the EP\");\n+        }\n+    }\n+    \n+    public void testMultipleSameKey1() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a\n+        one=b,c\n+        */\n+        String s1 = \"one=a\\none=b,c\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(3, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+\n+        assertEquals(3, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+    }\n+    \n+    public void testMultipleSameKey2() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a,b\n+        one=c,d\n+        */\n+        String s1 = \"one=a,b\\none=c,d\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(4, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getVector(\"one\").get(3));\n+\n+        assertEquals(4, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getList(\"one\").get(3));\n+    }\n+    \n+    public void testMultipleSameKey3() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a,b\n+        one=c\n+        */\n+        String s1 = \"one=a,b\\none=c\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(3, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+\n+        assertEquals(3, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+    }\n+    \n+    public void testMultipleSameKeyByCode() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        ep1.addProperty(\"one\", \"a\");\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(1, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+\n+        assertEquals(1, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        \n+        ep1.addProperty(\"one\", Boolean.TRUE);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(2, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getVector(\"one\").get(1));\n+\n+        assertEquals(2, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getList(\"one\").get(1));\n+        \n+        ep1.addProperty(\"one\", \"c,d\");\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(4, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getVector(\"one\").get(3));\n+\n+        assertEquals(4, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getList(\"one\").get(3));\n+    }\n+\n+    public void testInheritDefaultProperties() {\n+        Properties defaults = new Properties();\n+        defaults.setProperty(\"resource.loader\", \"class\");\n+\n+        Properties properties = new Properties(defaults);\n+        properties.setProperty(\"test\", \"foo\");\n+\n+        ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n+\n+        assertEquals(\"foo\", extended.getString(\"test\"));\n+        assertEquals(\"class\", extended.getString(\"resource.loader\"));\n+    }\n+\n+    public void testInclude() {\n+        ExtendedProperties a = new ExtendedProperties();\n+        ExtendedProperties b = new ExtendedProperties();\n+        \n+        assertEquals(\"include\", a.getInclude());\n+        assertEquals(\"include\", b.getInclude());\n+        \n+        a.setInclude(\"import\");\n+        assertEquals(\"import\", a.getInclude());\n+        assertEquals(\"include\", b.getInclude());\n+        \n+        a.setInclude(null);\n+        assertEquals(null, a.getInclude());\n+        assertEquals(\"include\", b.getInclude());\n+    }\n+\n+    public void testKeySet1() {\n+            ExtendedProperties p = new ExtendedProperties();\n+            p.addProperty(\"a\", \"foo\");\n+            p.addProperty(\"b\", \"bar\");\n+            p.addProperty(\"c\", \"bar\");\n+\n+            Iterator it = p.getKeys();\n+            assertEquals(\"a\", (String) it.next());\n+            assertEquals(\"b\", (String) it.next());\n+            assertEquals(\"c\", (String) it.next());\n+            assertFalse(it.hasNext());\n+    }\n+\n+    public void testKeySet2() {\n+        ExtendedProperties p = new ExtendedProperties();\n+        p.put(\"a\", \"foo\");\n+        p.put(\"b\", \"bar\");\n+        p.put(\"c\", \"bar\");\n+\n+        Iterator it = p.getKeys();\n+        assertEquals(\"a\", (String) it.next());\n+        assertEquals(\"b\", (String) it.next());\n+        assertEquals(\"c\", (String) it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+\n+    public void testKeySet3() {\n+        ExtendedProperties q = new ExtendedProperties();\n+        q.addProperty(\"a\", \"foo\");\n+        q.addProperty(\"b\", \"bar\");\n+        q.addProperty(\"c\", \"bar\");\n+\n+        ExtendedProperties p = new ExtendedProperties();\n+        p.putAll(q);\n+\n+        Iterator it = p.getKeys();\n+        assertEquals(\"a\", (String) it.next());\n+        assertEquals(\"b\", (String) it.next());\n+        assertEquals(\"c\", (String) it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testKeySet4() {\n+        ExtendedProperties q = new ExtendedProperties();\n+        q.addProperty(\"a\", \"foo\");\n+        q.addProperty(\"b\", \"bar\");\n+        q.addProperty(\"c\", \"bar\");\n+\n+        q.remove(\"b\");\n+\n+        Iterator it = q.getKeys();\n+        assertEquals(\"a\", (String) it.next());\n+        assertEquals(\"c\", (String) it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testCollections271() {\n+        ExtendedProperties props = new ExtendedProperties();\n+        props.setProperty(\"test\", \"\\\\\\\\\\\\\\\\192.168.1.91\\\\\\\\test\");\n+        props.getProperty(\"test\");\n+        assertEquals( \"\\\\\\\\192.168.1.91\\\\test\", props.getProperty(\"test\") );\n+\n+        ExtendedProperties props2 = new ExtendedProperties();\n+        props2.combine(props);\n+        assertEquals( \"\\\\\\\\192.168.1.91\\\\test\", props2.getProperty(\"test\") );\n+\n+        ExtendedProperties props3 = new ExtendedProperties();\n+        props3.setProperty(\"sub.test\", \"foo\");\n+        props2.combine(props3);\n+        assertEquals(\"foo\", props2.getProperty(\"sub.test\"));\n+\n+        ExtendedProperties subs = props2.subset(\"sub\");\n+        assertNotNull(subs);\n+        assertEquals(\"foo\", subs.getProperty(\"test\"));\n+    }\n+\n+    public void testCollections238() throws IOException {\n+        ExtendedProperties props = new ExtendedProperties();\n+        String txt = \"x=1\\ny=\\nz=3\";\n+        byte[] bytes = txt.getBytes();\n+        ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n+        props.load(in);\n+        assertEquals(\"1\", props.getProperty(\"x\"));\n+        assertEquals(\"3\", props.getProperty(\"z\"));\n+        assertEquals(\"\", props.getProperty(\"y\"));\n+        assertEquals(3, props.size());\n+    }\n+\n+    public void testCollections299() {\n+        Properties defaults = new Properties();\n+        defaults.put(\"objectTrue\", Boolean.TRUE);\n+\n+        Properties properties = new Properties(defaults);\n+        properties.put(\"objectFalse\", Boolean.FALSE);\n+\n+        ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n+\n+        assertNull(extended.getString(\"objectTrue\"));\n+        assertNull(extended.getString(\"objectFalse\"));\n+\n+        assertNull(extended.get(\"objectTrue\"));\n+        assertNull(extended.get(\"objectFalse\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestFactoryUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.collections.functors.ConstantFactory;\n+import org.apache.commons.collections.functors.ExceptionFactory;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the org.apache.commons.collections.FactoryUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestFactoryUtils extends junit.framework.TestCase {\n+\n+    /**\n+     * Construct\n+     */\n+    public TestFactoryUtils(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() {\n+    }\n+\n+    // exceptionFactory\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionFactory() {\n+        assertNotNull(FactoryUtils.exceptionFactory());\n+        assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());\n+        try {\n+            FactoryUtils.exceptionFactory().create();\n+        } catch (FunctorException ex) {\n+            try {\n+                FactoryUtils.exceptionFactory().create();\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nullFactory\n+    //------------------------------------------------------------------\n+\n+    public void testNullFactory() {\n+        Factory<Object> factory = FactoryUtils.nullFactory();\n+        assertNotNull(factory);\n+        Object created = factory.create();\n+        assertNull(created);\n+    }\n+\n+    // constantFactory\n+    //------------------------------------------------------------------\n+\n+    public void testConstantFactoryNull() {\n+        Factory<Object> factory = FactoryUtils.constantFactory(null);\n+        assertNotNull(factory);\n+        Object created = factory.create();\n+        assertNull(created);\n+    }\n+\n+    public void testConstantFactoryConstant() {\n+        Integer constant = new Integer(9);\n+        Factory<Integer> factory = FactoryUtils.constantFactory(constant);\n+        assertNotNull(factory);\n+        Integer created = factory.create();\n+        assertSame(constant, created);\n+    }\n+\n+    // prototypeFactory\n+    //------------------------------------------------------------------\n+\n+    public void testPrototypeFactoryNull() {\n+        assertSame(ConstantFactory.NULL_INSTANCE, FactoryUtils.prototypeFactory(null));\n+    }\n+\n+    public void testPrototypeFactoryPublicCloneMethod() throws Exception {\n+        Date proto = new Date();\n+        Factory<Date> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        Date created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicCopyConstructor() throws Exception {\n+        Mock1 proto = new Mock1(6);\n+        Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n+        assertNotNull(factory);\n+        Object created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        try {\n+            out.writeObject(factory);\n+        } catch (NotSerializableException ex) {\n+            out.close();\n+        }\n+        factory = FactoryUtils.<Object>prototypeFactory(new Mock2(\"S\"));\n+        buffer = new ByteArrayOutputStream();\n+        out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicSerialization() throws Exception {\n+        Integer proto = new Integer(9);\n+        Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        Integer created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicSerializationError() {\n+        Mock2 proto = new Mock2(new Object());\n+        Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n+        assertNotNull(factory);\n+        try {\n+            factory.create();\n+        } catch (FunctorException ex) {\n+            assertTrue(ex.getCause() instanceof IOException);\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testPrototypeFactoryPublicBad() {\n+        Object proto = new Object();\n+        try {\n+            FactoryUtils.prototypeFactory(proto);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public static class Mock1 {\n+        private final int iVal;\n+        public Mock1(int val) {\n+            iVal = val;\n+        }\n+        public Mock1(Mock1 mock) {\n+            iVal = mock.iVal;\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof Mock1) {\n+                if (iVal == ((Mock1) obj).iVal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class Mock2 implements Serializable {\n+        private final Object iVal;\n+        public Mock2(Object val) {\n+            iVal = val;\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof Mock2) {\n+                if (iVal == ((Mock2) obj).iVal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static class Mock3 {\n+        private static int cCounter = 0;\n+        private final int iVal;\n+        public Mock3() {\n+            iVal = cCounter++;\n+        }\n+        public int getValue() {\n+            return iVal;\n+        }\n+    }\n+\n+    // instantiateFactory\n+    //------------------------------------------------------------------\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryNull() {\n+        FactoryUtils.instantiateFactory(null);\n+    }\n+\n+    @Test\n+    public void instantiateFactorySimple() {\n+        Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);\n+        assertNotNull(factory);\n+        Mock3 created = factory.create();\n+        assertEquals(0, created.getValue());\n+        created = factory.create();\n+        assertEquals(1, created.getValue());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryMismatch() {\n+        FactoryUtils.instantiateFactory(Date.class, null, new Object[] {null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryNoConstructor() {\n+        FactoryUtils.instantiateFactory(Date.class, new Class[] {Long.class}, new Object[] {null});\n+    }\n+\n+    @Test\n+    public void instantiateFactoryComplex() {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n+        // 2nd Jan 1970\n+        Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,\n+            new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},\n+            new Object[] {new Integer(70), new Integer(0), new Integer(2)});\n+        assertNotNull(factory);\n+        Date created = factory.create();\n+        // long time of 1 day (== 2nd Jan 1970)\n+        assertEquals(new Date(1000 * 60 * 60 * 24), created);\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Factory singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionFactory.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestIndexedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import static java.util.Arrays.asList;\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertNull;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+@SuppressWarnings(\"boxing\")\n+public class TestIndexedCollection extends AbstractDecoratedCollectionTest<String> {\n+    private IndexedCollection<Integer, String> indexed;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n+            public Integer transform(String input) {\n+                return Integer.parseInt(input);\n+            }\n+        });\n+        decorated = indexed;\n+    }\n+    \n+    @Test\n+    public void addedObjectsCanBeRetrievedByKey() throws Exception {\n+        decorated.add(\"12\");\n+        decorated.add(\"16\");\n+        decorated.add(\"1\");\n+        decorated.addAll(asList(\"2\",\"3\",\"4\"));\n+        assertEquals(\"12\", indexed.get(12));\n+        assertEquals(\"16\", indexed.get(16));\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+        assertEquals(\"4\", indexed.get(4));\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void ensureDuplicateObjectsCauseException() throws Exception {\n+        decorated.add(\"1\");\n+        decorated.add(\"1\");\n+    }\n+    \n+    @Test\n+    public void decoratedCollectionIsIndexedOnCreation() throws Exception {\n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+        \n+        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n+            public Integer transform(String input) {\n+                return Integer.parseInt(input);\n+            }\n+        });\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+    \n+    @Test\n+    public void reindexUpdatesIndexWhenTheDecoratedCollectionIsModifiedSeparately() throws Exception {\n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+        \n+        assertNull(indexed.get(1));\n+        assertNull(indexed.get(2));\n+        assertNull(indexed.get(3));\n+        indexed.reindex();\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestIteratorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.EmptyListIterator;\n+import org.apache.commons.collections.iterators.EmptyMapIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n+\n+/**\n+ * Tests for IteratorUtils.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Unknown\n+ */\n+public class TestIteratorUtils extends BulkTest {\n+\n+    public TestIteratorUtils(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestIteratorUtils.class);\n+    }\n+\n+    public void testAsIterable() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        Iterator<Integer> iterator = list.iterator();\n+        \n+        Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);\n+        int expected = 0;\n+        for(Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+\n+        // single use iterator\n+        for(Integer actual : iterable) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+\n+    public void testAsIterableNull() {\n+        try {\n+            IteratorUtils.asIterable(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testAsMultipleIterable() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        Iterator<Integer> iterator = list.iterator();\n+        \n+        Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);\n+        int expected = 0;\n+        for(Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+\n+        // multiple use iterator\n+        expected = 0;\n+        for(Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+    }\n+\n+    public void testAsMultipleIterableNull() {\n+        try {\n+            IteratorUtils.asMultipleUseIterable(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testToList() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.add(new Integer(1));\n+        list.add(\"Two\");\n+        list.add(null);\n+        List<Object> result = IteratorUtils.toList(list.iterator());\n+        assertEquals(list, result);\n+    }\n+\n+    public void testToArray() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.add(new Integer(1));\n+        list.add(\"Two\");\n+        list.add(null);\n+        Object[] result = IteratorUtils.toArray(list.iterator());\n+        assertEquals(list, Arrays.asList(result));\n+    }\n+\n+    public void testToArray2() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(null);\n+        String[] result = IteratorUtils.toArray(list.iterator(), String.class);\n+        assertEquals(list, Arrays.asList(result));\n+    }\n+\n+    public void testArrayIterator() {\n+        Object[] objArray = {\"a\", \"b\", \"c\"};\n+        ResettableIterator<Object> iterator = IteratorUtils.arrayIterator(objArray);\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.next().equals(\"b\"));\n+        iterator.reset();\n+        assertTrue(iterator.next().equals(\"a\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(new Integer(0));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+                // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 1);\n+        assertTrue(iterator.next().equals(\"b\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 3);\n+        assertTrue(!iterator.hasNext());\n+        iterator.reset();\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 2, 3);\n+        assertTrue(iterator.next().equals(\"c\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        int[] intArray = {0, 1, 2};\n+        iterator = IteratorUtils.arrayIterator(intArray);\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        iterator.reset();\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 1);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 3);\n+        assertTrue(!iterator.hasNext());\n+        iterator.reset();\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 2, 3);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testArrayListIterator() {\n+        Object[] objArray = {\"a\", \"b\", \"c\", \"d\"};\n+        ResettableListIterator<Object> iterator = IteratorUtils.arrayListIterator(objArray);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.previous().equals(\"a\"));\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(\"b\"));\n+        assertTrue(iterator.next().equals(\"c\"));\n+        assertTrue(iterator.next().equals(\"d\"));\n+        assertTrue(iterator.nextIndex() == 4); // size of list\n+        assertTrue(iterator.previousIndex() == 3);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(new Integer(0));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+                // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 1);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(\"b\"));\n+        assertTrue(iterator.previousIndex() == 0);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 3);\n+        assertTrue(iterator.hasNext());\n+        try {\n+            iterator.previous();\n+            fail(\"Expecting NoSuchElementException.\");\n+        } catch (NoSuchElementException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 5);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 2, 3);\n+        assertTrue(iterator.next().equals(\"c\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 2, 5);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        int[] intArray = {0, 1, 2};\n+        iterator = IteratorUtils.arrayListIterator(intArray);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previousIndex() == 1);\n+        assertTrue(iterator.nextIndex() == 2);\n+        assertTrue(iterator.previous().equals(new Integer(1)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 1);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previous().equals(new Integer(1)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+        assertTrue(iterator.previousIndex() == 1);\n+        assertTrue(iterator.nextIndex() == 2);\n+        assertTrue(iterator.previous().equals(new Integer(2)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 3);\n+        assertTrue(!iterator.hasNext());\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 2, 3);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+        assertTrue(iterator.hasPrevious());\n+        assertTrue(!iterator.hasNext());\n+\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     * Gets an immutable Iterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n+     */\n+    private Iterator<String> getImmutableIterator() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        list.add(\"c\");\n+        list.add(\"d\");\n+        return IteratorUtils.unmodifiableIterator(list.iterator());\n+    }\n+\n+    /**\n+     * Gets an immutable ListIterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n+     */\n+    private ListIterator<String> getImmutableListIterator() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        list.add(\"c\");\n+        list.add(\"d\");\n+        return IteratorUtils.unmodifiableListIterator(list.listIterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty iterator\n+     */\n+    public void testEmptyIterator() {\n+        assertSame(EmptyIterator.INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n+        assertSame(EmptyIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof OrderedIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR.hasNext());\n+        IteratorUtils.EMPTY_ITERATOR.reset();\n+        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.EMPTY_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.emptyIterator());\n+        try {\n+            IteratorUtils.EMPTY_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty list iterator\n+     */\n+    public void testEmptyListIterator() {\n+        assertSame(EmptyListIterator.INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertSame(EmptyListIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ListIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_LIST_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_LIST_ITERATOR.hasNext());\n+        assertEquals(0, IteratorUtils.EMPTY_LIST_ITERATOR.nextIndex());\n+        assertEquals(-1, IteratorUtils.EMPTY_LIST_ITERATOR.previousIndex());\n+        IteratorUtils.EMPTY_LIST_ITERATOR.reset();\n+        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.emptyListIterator());\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.set(null);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.add(null);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyMapIterator() {\n+        assertSame(EmptyMapIterator.INSTANCE, IteratorUtils.EMPTY_MAP_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof MapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedMapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR.hasNext());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_MAP_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.EMPTY_MAP_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.emptyMapIterator());\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.getKey();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.getValue();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.setValue(null);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyOrderedIterator() {\n+        assertSame(EmptyOrderedIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof OrderedIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR.hasNext());\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR.hasPrevious());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.emptyOrderedIterator());\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyOrderedMapIterator() {\n+        assertSame(EmptyOrderedMapIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof MapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof OrderedMapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasNext());\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasPrevious());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.emptyOrderedMapIterator());\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getKey();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getValue();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.setValue(null);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test next() and hasNext() for an immutable Iterator.\n+     */\n+    public void testUnmodifiableIteratorIteration() {\n+        Iterator<String> iterator = getImmutableIterator();\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"a\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"b\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"c\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"d\", iterator.next());\n+\n+        assertTrue(!iterator.hasNext());\n+    }\n+\n+    /**\n+     * Test next(), hasNext(), previous() and hasPrevious() for an immutable\n+     * ListIterator.\n+     */\n+    public void testUnmodifiableListIteratorIteration() {\n+        ListIterator<String> listIterator = getImmutableListIterator();\n+\n+        assertTrue(!listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"a\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"b\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"c\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"d\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(!listIterator.hasNext());\n+\n+        assertEquals(\"d\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"c\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"b\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"a\", listIterator.previous());\n+\n+        assertTrue(!listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+    }\n+\n+    /**\n+     * Test remove() for an immutable Iterator.\n+     */\n+    public void testUnmodifiableIteratorImmutability() {\n+        Iterator<String> iterator = getImmutableIterator();\n+\n+        try {\n+            iterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        iterator.next();\n+\n+        try {\n+            iterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+    }\n+\n+    /**\n+     * Test remove() for an immutable ListIterator.\n+     */\n+    public void testUnmodifiableListIteratorImmutability() {\n+        ListIterator<String> listIterator = getImmutableListIterator();\n+\n+        try {\n+            listIterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.set(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"set(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.add(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"add(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        listIterator.next();\n+\n+        try {\n+            listIterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.set(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"set(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.add(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"add(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestListUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.list.PredicatedList;\n+\n+/**\n+ * Tests for ListUtils.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Neil O'Toole\n+ * @author Matthew Hawthorne\n+ * @author Dave Meikle\n+ */\n+public class TestListUtils extends BulkTest {\n+\n+    private static final String a = \"a\";\n+    private static final String b = \"b\";\n+    private static final String c = \"c\";\n+    private static final String d = \"d\";\n+    private static final String e = \"e\";\n+    private static final String x = \"x\";\n+\n+    private String[] fullArray;\n+    private List<String> fullList;\n+\n+    public TestListUtils(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestListUtils.class);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        fullArray = new String[]{a, b, c, d, e};\n+        fullList = new ArrayList<String>(Arrays.asList(fullArray));\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an empty list.\n+     */\n+    public void testIntersectNonEmptyWithEmptyList() {\n+        final List<String> empty = Collections.<String>emptyList();\n+        assertTrue(\"result not empty\", ListUtils.intersection(empty, fullList).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an empty list.\n+     */\n+    public void testIntersectEmptyWithEmptyList() {\n+        final List<?> empty = Collections.EMPTY_LIST;\n+        assertTrue(\"result not empty\", ListUtils.intersection(empty, empty).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an subset of iteself.\n+     */\n+    public void testIntersectNonEmptySubset() {\n+        // create a copy\n+        final List<String> other = new ArrayList<String>(fullList);\n+\n+        // remove a few items\n+        assertNotNull(other.remove(0));\n+        assertNotNull(other.remove(1));\n+\n+        // make sure the intersection is equal to the copy\n+        assertEquals(other, ListUtils.intersection(fullList, other));\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an subset of iteself.\n+     */\n+    public void testIntersectListWithNoOverlapAndDifferentTypes() {\n+        @SuppressWarnings(\"boxing\")\n+        final List<Integer> other = Arrays.asList(1, 23);\n+        assertTrue(ListUtils.intersection(fullList, other).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with iteself.\n+     */\n+    public void testIntersectListWithSelf() {\n+        assertEquals(fullList, ListUtils.intersection(fullList, fullList));\n+    }\n+\n+    /**\n+     * Tests intersecting two lists in different orders.\n+     */\n+    public void testIntersectionOrderInsensitivity() {\n+        List<String> one = new ArrayList<String>();\n+        List<String> two = new ArrayList<String>();\n+        one.add(\"a\");\n+        one.add(\"b\");\n+        two.add(\"a\");\n+        two.add(\"a\");\n+        two.add(\"b\");\n+        two.add(\"b\");\n+        assertEquals(ListUtils.intersection(one,two),ListUtils.intersection(two, one));\n+    }\n+\n+    public void testPredicatedList() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        List<Object> list = ListUtils.predicatedList(new ArrayStack<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedList\", list instanceof PredicatedList);\n+        try {\n+            list = ListUtils.predicatedList(new ArrayStack<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            list = ListUtils.predicatedList(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null list.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyList() {\n+        List<Integer> list = ListUtils.lazyList(new ArrayList<Integer>(), new Factory<Integer>() {\n+\n+            private int index;\n+\n+            public Integer create() {\n+                index++;\n+                return new Integer(index);\n+            }\n+        });\n+\n+        assertNotNull(list.get(5));\n+        assertEquals(6, list.size());\n+\n+        assertNotNull(list.get(5));\n+        assertEquals(6, list.size());\n+    }\n+\n+    public void testEquals() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        List<String> a = new ArrayList<String>( data );\n+        List<String> b = new ArrayList<String>( data );\n+\n+        assertEquals(true, a.equals(b));\n+        assertEquals(true, ListUtils.isEqualList(a, b));\n+        a.clear();\n+        assertEquals(false, ListUtils.isEqualList(a, b));\n+        assertEquals(false, ListUtils.isEqualList(a, null));\n+        assertEquals(false, ListUtils.isEqualList(null, b));\n+        assertEquals(true, ListUtils.isEqualList(null, null));\n+    }\n+\n+    public void testHashCode() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        List<String> a = new ArrayList<String>(data);\n+        List<String> b = new ArrayList<String>(data);\n+\n+        assertEquals(true, a.hashCode() == b.hashCode());\n+        assertEquals(true, a.hashCode() == ListUtils.hashCodeForList(a));\n+        assertEquals(true, b.hashCode() == ListUtils.hashCodeForList(b));\n+        assertEquals(true, ListUtils.hashCodeForList(a) == ListUtils.hashCodeForList(b));\n+        a.clear();\n+        assertEquals(false, ListUtils.hashCodeForList(a) == ListUtils.hashCodeForList(b));\n+        assertEquals(0, ListUtils.hashCodeForList(null));\n+    }\n+\n+    public void testRetainAll() {\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        List<String> retained = ListUtils.retainAll(fullList, sub);\n+        assertTrue(retained.size() == 2);\n+        sub.remove(x);\n+        assertTrue(retained.equals(sub));\n+        fullList.retainAll(sub);\n+        assertTrue(retained.equals(fullList));\n+\n+        try {\n+            ListUtils.retainAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(NullPointerException npe){} // this is what we want\n+    }\n+\n+    public void testRemoveAll() {\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        List<String> remainder = ListUtils.removeAll(fullList, sub);\n+        assertTrue(remainder.size() == 3);\n+        fullList.removeAll(sub);\n+        assertTrue(remainder.equals(fullList));\n+\n+        try {\n+            ListUtils.removeAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(NullPointerException npe) {} // this is what we want\n+    }\n+\n+    /**\n+     * Tests the <code>indexOf</code> method in <code>ListUtils</code> class..\n+     */\n+    public void testIndexOf() {\n+        Predicate<String> testPredicate = EqualPredicate.equalPredicate(\"d\");\n+        int index = ListUtils.indexOf(fullList, testPredicate);\n+        assertEquals(d, fullList.get(index));\n+\n+        testPredicate = EqualPredicate.equalPredicate(\"de\");\n+        index = ListUtils.indexOf(fullList, testPredicate);\n+        assertEquals(index, -1);\n+        \n+        assertEquals(ListUtils.indexOf(null,testPredicate), -1);\n+        assertEquals(ListUtils.indexOf(fullList, null), -1);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestMapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.ListResourceBundle;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.keyvalue.DefaultKeyValue;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n+import org.apache.commons.collections.map.HashedMap;\n+import org.apache.commons.collections.map.LazyMap;\n+import org.apache.commons.collections.map.PredicatedMap;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Tests for MapUtils.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Arun Mammen Thomas\n+ * @author Max Rydahl Andersen\n+ * @author Janek Bogucki\n+ * @author Neil O'Toole\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestMapUtils extends BulkTest {\n+\n+    public TestMapUtils(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestMapUtils.class);\n+    }\n+\n+    public Predicate<Object> getPredicate() {\n+        return new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+    public void testPredicatedMap() {\n+        Predicate<Object> p = getPredicate();\n+        Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<Object, Object>(), p, p);\n+        assertTrue(\"returned object should be a PredicatedMap\", map instanceof PredicatedMap);\n+        try {\n+            map = MapUtils.predicatedMap(null, p, p);\n+            fail(\"Expecting IllegalArgumentException for null map.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyMapFactory() {\n+        Factory<Integer> factory = FactoryUtils.constantFactory(new Integer(5));\n+        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), factory);\n+        assertTrue(map instanceof LazyMap);\n+        try {\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Factory<Object>) null);\n+            fail(\"Expecting IllegalArgumentException for null factory\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, factory);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n+        map = MapUtils.lazyMap(new HashMap<Object, Object>(), transformer);\n+        assertTrue(map instanceof LazyMap);\n+        try {\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Transformer<Object, Object>) null);\n+            fail(\"Expecting IllegalArgumentException for null transformer\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyMapTransformer() {\n+        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), new Transformer<Object, Object>() {\n+            public Object transform(Object mapKey) {\n+                if (mapKey instanceof String) {\n+                    return new Integer((String) mapKey);\n+                }\n+                return null;\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        Integer i1 = (Integer) map.get(\"5\");\n+        assertEquals(new Integer(5), i1);\n+        assertEquals(1, map.size());\n+        Integer i2 = (Integer) map.get(new String(new char[] {'5'}));\n+        assertEquals(new Integer(5), i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+    }\n+\n+    public void testInvertMap() {\n+        final Map<String, String> in = new HashMap<String, String>(5, 1);\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n+\n+        final Set<String> inKeySet = new HashSet<String>(in.keySet());\n+        final Set<String> inValSet = new HashSet<String>(in.values());\n+\n+        final Map<String, String> out =  MapUtils.invertMap(in);\n+\n+        final Set<String> outKeySet = new HashSet<String>(out.keySet());\n+        final Set<String> outValSet = new HashSet<String>(out.values());\n+\n+        assertTrue( inKeySet.equals( outValSet ));\n+        assertTrue( inValSet.equals( outKeySet ));\n+\n+        assertEquals( \"1\", out.get(\"A\"));\n+        assertEquals( \"2\", out.get(\"B\"));\n+        assertEquals( \"3\", out.get(\"C\"));\n+        assertEquals( \"4\", out.get(\"D\"));\n+        assertEquals( \"5\", out.get(\"E\"));\n+    }\n+\n+    public void testPutAll_Map_array() {\n+        try {\n+            MapUtils.putAll(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            MapUtils.putAll(null, new Object[0]);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+\n+        Map<String, String> test = MapUtils.putAll(new HashMap<String, String>(), new String[0]);\n+        assertEquals(0, test.size());\n+\n+        // sub array\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+            {\"RED\", \"#FF0000\"},\n+            {\"GREEN\", \"#00FF00\"},\n+            {\"BLUE\", \"#0000FF\"}\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                null,\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                {\"GREEN\"},\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                {},\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        // flat array\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n+            \"RED\", \"#FF0000\",\n+            \"GREEN\", \"#00FF00\",\n+            \"BLUE\", \"#0000FF\"\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n+            \"RED\", \"#FF0000\",\n+            \"GREEN\", \"#00FF00\",\n+            \"BLUE\", \"#0000FF\",\n+            \"PURPLE\" // ignored\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        // map entry\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultMapEntry<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultMapEntry<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultMapEntry<String, String>(\"BLUE\", \"#0000FF\")\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        // key value\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultKeyValue<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultKeyValue<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultKeyValue<String, String>(\"BLUE\", \"#0000FF\")\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+    }\n+\n+    public void testConvertResourceBundle() {\n+        final Map<String, String> in = new HashMap<String, String>( 5 , 1 );\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n+\n+        ResourceBundle b = new ListResourceBundle() {\n+            @Override\n+            public Object[][] getContents() {\n+                final Object[][] contents = new Object[ in.size() ][2];\n+                final Iterator<String> i = in.keySet().iterator();\n+                int n = 0;\n+                while ( i.hasNext() ) {\n+                    final Object key = i.next();\n+                    final Object val = in.get( key );\n+                    contents[ n ][ 0 ] = key;\n+                    contents[ n ][ 1 ] = val;\n+                    ++n;\n+                }\n+                return contents;\n+            }\n+        };\n+\n+        final Map<String, Object> out = MapUtils.toMap(b);\n+\n+        assertTrue( in.equals(out));\n+    }\n+\n+    public void testDebugAndVerbosePrintCasting() {\n+        final Map<Integer, String> inner = new HashMap<Integer, String>(2, 1);\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new HashMap<Integer, Object>(2, 1);\n+        outer.put(0, inner);\n+        outer.put(1, \"A\");\n+\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        try {\n+            MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n+        } catch (final ClassCastException e) {\n+            fail(\"No Casting should be occurring!\");\n+        }\n+    }\n+\n+    public void testDebugAndVerbosePrintNullMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        outPrint.println(LABEL + \" = \" + String.valueOf((Object) null));\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"3 = C\");\n+        outPrint.println(INDENT + \"4 = null\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"4 = null\");\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        outPrint.println(\"null\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        outPrint.println(\"null\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullStream() {\n+        try {\n+            MapUtils.verbosePrint(null, \"Map\", new HashMap<Object, Object>());\n+            fail(\"Should generate NullPointerException\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    public void testDebugPrintNullStream() {\n+        try {\n+            MapUtils.debugPrint(null, \"Map\", new HashMap<Object, Object>());\n+            fail(\"Should generate NullPointerException\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    public void testDebugPrintNullKey() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = A \" + String.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKey() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = A\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullKeyToMap1() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = (this Map) \" + HashMap.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKeyToMap1() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = (this Map)\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullKeyToMap2() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + \"} \" + HashMap.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKeyToMap2() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = C\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(INDENT + \"7 = (this Map)\");\n+        outPrint.println(\"}\");\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n+\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"7 = (this Map) \" + TreeMap.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n+\n+        MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map)\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"}\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", grandfather);\n+\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+        MapUtils.debugPrint(outPrint, \"Print Map\", grandfather);\n+\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsEmptyWithEmptyMap() {\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        assertEquals(true, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNonEmptyMap() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertEquals(false, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNull() {\n+        Map<Object, Object> map = null;\n+        assertEquals(true, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithEmptyMap() {\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        assertEquals(false, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithNonEmptyMap() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertEquals(true, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithNull() {\n+        Map<Object, Object> map = null;\n+        assertEquals(false, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testPopulateMap() {\n+        // Setup Test Data\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"1\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+        list.add(\"7\");\n+        list.add(\"2\");\n+        list.add(\"4\");\n+        list.add(\"6\");\n+\n+        // Now test key transform population\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        MapUtils.populateMap(map, list, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(list.size(), map.size());\n+\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(true, map.containsKey(new Integer(list.get(i))));\n+            assertEquals(false, map.containsKey(list.get(i)));\n+            assertEquals(true, map.containsValue(list.get(i)));\n+            assertEquals(list.get(i), map.get(new Integer(list.get(i))));\n+        }\n+\n+        // Now test both Key-Value transform population\n+        map = new HashMap<Object, Object>();\n+        MapUtils.populateMap(map, list, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+\n+        assertEquals(list.size(), map.size());\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(true, map.containsKey(new Integer(list.get(i))));\n+            assertEquals(false, map.containsKey(list.get(i)));\n+            assertEquals(true, map.containsValue(new Integer(list.get(i))));\n+            assertEquals(new Integer(list.get(i)), map.get(new Integer(list.get(i))));\n+        }\n+    }\n+\n+    public void testIterableMap() {\n+        try {\n+            MapUtils.iterableMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        HashMap<String, String> map = new HashMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        IterableMap<String, String> iMap = MapUtils.iterableMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        HashedMap<String, String> hMap = new HashedMap<String, String>(map);\n+        assertSame(hMap, MapUtils.iterableMap(hMap));\n+    }\n+\n+    public void testIterableSortedMap() {\n+        try {\n+            MapUtils.iterableSortedMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        TreeMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        assertSame(iMap, MapUtils.iterableMap(iMap));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestPredicateUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import static org.apache.commons.collections.functors.NullPredicate.nullPredicate;\n+import static org.apache.commons.collections.functors.TruePredicate.truePredicate;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.functors.AllPredicate;\n+import org.apache.commons.collections.functors.BasicPredicateTestBase;\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionPredicate;\n+import org.apache.commons.collections.functors.FalsePredicate;\n+import org.apache.commons.collections.functors.NotNullPredicate;\n+import org.apache.commons.collections.functors.NullPredicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the org.apache.commons.collections.PredicateUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestPredicateUtils extends BasicPredicateTestBase {\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown() {\n+    }\n+\n+    // exceptionPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testExceptionPredicate() {\n+        assertNotNull(PredicateUtils.exceptionPredicate());\n+        assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());\n+        try {\n+            PredicateUtils.exceptionPredicate().evaluate(null);\n+        } catch (FunctorException ex) {\n+            try {\n+                PredicateUtils.exceptionPredicate().evaluate(cString);\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // notNullPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testIsNotNullPredicate() {\n+        assertNotNull(PredicateUtils.notNullPredicate());\n+        assertSame(PredicateUtils.notNullPredicate(), PredicateUtils.notNullPredicate());\n+        assertEquals(false, PredicateUtils.notNullPredicate().evaluate(null));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cObject));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cString));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cInteger));\n+    }\n+\n+    // identityPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testIdentityPredicate() {\n+        assertSame(nullPredicate(), PredicateUtils.identityPredicate(null));\n+        assertNotNull(PredicateUtils.identityPredicate(new Integer(6)));\n+        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(null));\n+        assertEquals(false, PredicateUtils.<Object>identityPredicate(new Integer(6)).evaluate(cObject));\n+        assertEquals(false, PredicateUtils.<Object>identityPredicate(new Integer(6)).evaluate(cString));\n+        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(cInteger));\n+        assertEquals(true, PredicateUtils.identityPredicate(cInteger).evaluate(cInteger));\n+    }\n+\n+    // truePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testTruePredicate() {\n+        assertNotNull(TruePredicate.truePredicate());\n+        assertSame(TruePredicate.truePredicate(), TruePredicate.truePredicate());\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(null));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cObject));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cString));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cInteger));\n+    }\n+\n+    // falsePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testFalsePredicate() {\n+        assertNotNull(FalsePredicate.falsePredicate());\n+        assertSame(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate());\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(null));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cObject));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cString));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cInteger));\n+    }\n+\n+    // notPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNotPredicate() {\n+        assertNotNull(PredicateUtils.notPredicate(TruePredicate.truePredicate()));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cObject));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cString));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cInteger));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testNotPredicateEx() {\n+        PredicateUtils.notPredicate(null);\n+    }\n+\n+    // andPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testAndPredicate() {\n+        assertEquals(true, PredicateUtils.andPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAndPredicateEx() {\n+        PredicateUtils.andPredicate(null, null);\n+    }\n+\n+    // allPredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testAllPredicate() {\n+        assertTrue(AllPredicate.allPredicate(new Predicate[] {}), null);\n+        assertEquals(true, AllPredicate.allPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(AllPredicate.allPredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(AllPredicate.allPredicate(coll), null);\n+        coll.clear();\n+        assertTrue(AllPredicate.allPredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx1() {\n+        AllPredicate.allPredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx2() {\n+        AllPredicate.<Object>allPredicate(new Predicate[] { null });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx3() {\n+        AllPredicate.allPredicate(new Predicate[] { null, null });\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx4() {\n+        AllPredicate.allPredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testAllPredicateEx5() {\n+        AllPredicate.allPredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        AllPredicate.allPredicate(coll);\n+    }\n+\n+    // orPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testOrPredicate() {\n+        assertEquals(true, PredicateUtils.orPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.orPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testOrPredicateEx() {\n+        PredicateUtils.orPredicate(null, null);\n+    }\n+\n+    // anyPredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testAnyPredicate() {\n+        assertFalse(PredicateUtils.anyPredicate(new Predicate[] {}), null);\n+\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.anyPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(PredicateUtils.anyPredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(PredicateUtils.anyPredicate(coll), null);\n+        coll.clear();\n+        assertFalse(PredicateUtils.anyPredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx1() {\n+        PredicateUtils.anyPredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx2() {\n+        PredicateUtils.anyPredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx3() {\n+        PredicateUtils.anyPredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx4() {\n+        PredicateUtils.anyPredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testAnyPredicateEx5() {\n+        PredicateUtils.anyPredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.anyPredicate(coll);\n+    }\n+\n+    // eitherPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testEitherPredicate() {\n+        assertEquals(false, PredicateUtils.eitherPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.eitherPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testEitherPredicateEx() {\n+        PredicateUtils.eitherPredicate(null, null);\n+    }\n+\n+    // onePredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testOnePredicate() {\n+        assertFalse(PredicateUtils.onePredicate((Predicate<Object>[]) new Predicate[] {}), null);\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+            TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), TruePredicate.truePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(PredicateUtils.onePredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(PredicateUtils.onePredicate(coll), null);\n+        coll.clear();\n+        assertFalse(PredicateUtils.onePredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testOnePredicateEx1() {\n+        PredicateUtils.onePredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx2() {\n+        PredicateUtils.onePredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx3() {\n+        PredicateUtils.onePredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx4() {\n+        PredicateUtils.onePredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testOnePredicateEx5() {\n+        PredicateUtils.onePredicate(Collections.EMPTY_LIST);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.onePredicate(coll);\n+    }\n+\n+    // neitherPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNeitherPredicate() {\n+        assertEquals(false, PredicateUtils.neitherPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.neitherPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNeitherPredicateEx() {\n+        PredicateUtils.neitherPredicate(null, null);\n+    }\n+\n+    // nonePredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testNonePredicate() {\n+        assertTrue(PredicateUtils.nonePredicate(new Predicate[] {}), null);\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(true, PredicateUtils.nonePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate() }).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(true, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertTrue(PredicateUtils.nonePredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertFalse(PredicateUtils.nonePredicate(coll), null);\n+        coll.clear();\n+        assertTrue(PredicateUtils.nonePredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx1() {\n+        PredicateUtils.nonePredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx2() {\n+        PredicateUtils.nonePredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx3() {\n+        PredicateUtils.nonePredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx4() {\n+        PredicateUtils.nonePredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testNonePredicateEx5() {\n+        PredicateUtils.nonePredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.nonePredicate(coll);\n+    }\n+\n+    // instanceofPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInstanceOfPredicate() {\n+        assertNotNull(PredicateUtils.instanceofPredicate(String.class));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(null));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cObject));\n+        assertEquals(true, PredicateUtils.instanceofPredicate(String.class).evaluate(cString));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cInteger));\n+    }\n+\n+    // uniquePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testUniquePredicate() {\n+        Predicate<Object> p = PredicateUtils.uniquePredicate();\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(cString));\n+        assertEquals(false, p.evaluate(cString));\n+        assertEquals(false, p.evaluate(cString));\n+    }\n+\n+    // asPredicate(Transformer)\n+    //------------------------------------------------------------------\n+\n+    @Test public void testAsPredicateTransformer() {\n+        assertEquals(false, PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(false));\n+        assertEquals(true, PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(true));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testAsPredicateTransformerEx1() {\n+        PredicateUtils.asPredicate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testAsPredicateTransformerEx2() {\n+        PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(null);\n+    }\n+\n+    // invokerPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInvokerPredicate() {\n+        List<Object> list = new ArrayList<Object>();\n+        assertEquals(true, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n+        list.add(new Object());\n+        assertEquals(false, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testInvokerPredicateEx1() {\n+        PredicateUtils.invokerPredicate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicateEx2() {\n+        PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicateEx3() {\n+        PredicateUtils.invokerPredicate(\"noSuchMethod\").evaluate(new Object());\n+    }\n+\n+    // invokerPredicate2\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInvokerPredicate2() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(false, PredicateUtils.invokerPredicate(\n+            \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n+        list.add(cString);\n+        assertEquals(true, PredicateUtils.invokerPredicate(\n+            \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testInvokerPredicate2Ex1() {\n+        PredicateUtils.invokerPredicate(null, null, null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicate2Ex2() {\n+        PredicateUtils.invokerPredicate(\"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicate2Ex3() {\n+        PredicateUtils.invokerPredicate(\n+                \"noSuchMethod\", new Class[] {Object.class}, new Object[] {cString}).evaluate(new Object());\n+    }\n+\n+    // nullIsException\n+    //------------------------------------------------------------------\n+\n+    @Test(expected=FunctorException.class)\n+    public void testNullIsExceptionPredicate() {\n+        assertEquals(true, PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsExceptionPredicateEx1() {\n+        PredicateUtils.nullIsExceptionPredicate(null);\n+    }\n+\n+    // nullIsTrue\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNullIsTruePredicate() {\n+        assertEquals(true, PredicateUtils.nullIsTruePredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.nullIsTruePredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        assertEquals(false, PredicateUtils.nullIsTruePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsTruePredicateEx1() {\n+        PredicateUtils.nullIsTruePredicate(null);\n+    }\n+\n+    // nullIsFalse\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNullIsFalsePredicate() {\n+        assertEquals(false, PredicateUtils.nullIsFalsePredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.nullIsFalsePredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        assertEquals(false, PredicateUtils.nullIsFalsePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsFalsePredicateEx1() {\n+        PredicateUtils.nullIsFalsePredicate(null);\n+    }\n+\n+    // transformed\n+    //------------------------------------------------------------------\n+\n+    @Test public void testTransformedPredicate() {\n+        assertEquals(true, PredicateUtils.transformedPredicate(\n+                TransformerUtils.nopTransformer(),\n+                TruePredicate.truePredicate()).evaluate(new Object()));\n+\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        map.put(Boolean.TRUE, \"Hello\");\n+        Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);\n+        Predicate<Object> p = EqualPredicate.<Object>equalPredicate(\"Hello\");\n+        assertEquals(false, PredicateUtils.transformedPredicate(t, p).evaluate(null));\n+        assertEquals(true, PredicateUtils.transformedPredicate(t, p).evaluate(Boolean.TRUE));\n+        try {\n+            PredicateUtils.transformedPredicate(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Predicate singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    @Test public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionPredicate.INSTANCE,\n+                FalsePredicate.INSTANCE,\n+                NotNullPredicate.INSTANCE,\n+                NullPredicate.INSTANCE,\n+                TruePredicate.INSTANCE\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return truePredicate();  //Just return something to satisfy super class.\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestSetUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.set.PredicatedSet;\n+\n+/**\n+ * Tests for SetUtils.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Neil O'Toole\n+ * @author Matthew Hawthorne\n+ */\n+public class TestSetUtils extends BulkTest {\n+\n+    public TestSetUtils(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestSetUtils.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public void testpredicatedSet() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        Set<Object> set = SetUtils.predicatedSet(new HashSet<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedSet\", set instanceof PredicatedSet);\n+        try {\n+            set = SetUtils.predicatedSet(new HashSet<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            set = SetUtils.predicatedSet(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null set.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testEquals() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        Set<String> a = new HashSet<String>(data);\n+        Set<String> b = new HashSet<String>(data);\n+\n+        assertEquals(true, a.equals(b));\n+        assertEquals(true, SetUtils.isEqualSet(a, b));\n+        a.clear();\n+        assertEquals(false, SetUtils.isEqualSet(a, b));\n+        assertEquals(false, SetUtils.isEqualSet(a, null));\n+        assertEquals(false, SetUtils.isEqualSet(null, b));\n+        assertEquals(true, SetUtils.isEqualSet(null, null));\n+    }\n+\n+    public void testHashCode() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        Set<String> a = new HashSet<String>(data);\n+        Set<String> b = new HashSet<String>(data);\n+\n+        assertEquals(true, a.hashCode() == b.hashCode());\n+        assertEquals(true, a.hashCode() == SetUtils.hashCodeForSet(a));\n+        assertEquals(true, b.hashCode() == SetUtils.hashCodeForSet(b));\n+        assertEquals(true, SetUtils.hashCodeForSet(a) == SetUtils.hashCodeForSet(b));\n+        a.clear();\n+        assertEquals(false, SetUtils.hashCodeForSet(a) == SetUtils.hashCodeForSet(b));\n+        assertEquals(0, SetUtils.hashCodeForSet(null));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestTransformerUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.functors.CloneTransformer;\n+import org.apache.commons.collections.functors.ConstantTransformer;\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionTransformer;\n+import org.apache.commons.collections.functors.FalsePredicate;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+import org.apache.commons.collections.functors.StringValueTransformer;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Tests the org.apache.commons.collections.TransformerUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author James Carman\n+ */\n+public class TestTransformerUtils extends junit.framework.TestCase {\n+\n+    private static final Object cObject = new Object();\n+    private static final Object cString = \"Hello\";\n+    private static final Object cInteger = new Integer(6);\n+\n+    /**\n+     * Construct\n+     */\n+    public TestTransformerUtils(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() {\n+    }\n+\n+    // exceptionTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionTransformer() {\n+        assertNotNull(TransformerUtils.exceptionTransformer());\n+        assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer());\n+        try {\n+            TransformerUtils.exceptionTransformer().transform(null);\n+        } catch (FunctorException ex) {\n+            try {\n+                TransformerUtils.exceptionTransformer().transform(cString);\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nullTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testNullTransformer() {\n+        assertNotNull(TransformerUtils.nullTransformer());\n+        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(null));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cObject));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cString));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cInteger));\n+    }\n+\n+    // nopTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testNopTransformer() {\n+        assertNotNull(TransformerUtils.nullTransformer());\n+        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n+        assertEquals(null, TransformerUtils.nopTransformer().transform(null));\n+        assertEquals(cObject, TransformerUtils.nopTransformer().transform(cObject));\n+        assertEquals(cString, TransformerUtils.nopTransformer().transform(cString));\n+        assertEquals(cInteger, TransformerUtils.nopTransformer().transform(cInteger));\n+    }\n+\n+    // constantTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testConstantTransformer() {\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(null));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cObject));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cString));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cInteger));\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.constantTransformer(null));\n+    }\n+\n+    // cloneTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testCloneTransformer() {\n+        assertEquals(null, TransformerUtils.cloneTransformer().transform(null));\n+        assertEquals(cString, TransformerUtils.cloneTransformer().transform(cString));\n+        assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));\n+        try {\n+            assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject));\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // mapTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testMapTransformer() {\n+        Map<Object, Integer> map = new HashMap<Object, Integer>();\n+        map.put(null, 0);\n+        map.put(cObject, 1);\n+        map.put(cString, 2);\n+        assertEquals(new Integer(0), TransformerUtils.mapTransformer(map).transform(null));\n+        assertEquals(new Integer(1), TransformerUtils.mapTransformer(map).transform(cObject));\n+        assertEquals(new Integer(2), TransformerUtils.mapTransformer(map).transform(cString));\n+        assertEquals(null, TransformerUtils.mapTransformer(map).transform(cInteger));\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.mapTransformer(null));\n+    }\n+\n+    // commandTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testExecutorTransformer() {\n+        assertEquals(null, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));\n+        assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));\n+        assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));\n+        assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Closure<Object>) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // predicateTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testPredicateTransformer() {\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(null));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cObject));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cString));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Predicate<Object>) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // factoryTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testFactoryTransformer() {\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(null));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cObject));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cString));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Factory<Object>) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // chainedTransformer\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testChainedTransformer() {\n+        Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer(\"A\");\n+        Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) \"B\");\n+\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).transform(null));\n+        assertEquals(\"B\", TransformerUtils.chainedTransformer(a, b).transform(null));\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(new Transformer[] { b, a }).transform(null));\n+        Collection<Transformer<Object, Object>> coll = new ArrayList<Transformer<Object, Object>>();\n+        coll.add(b);\n+        coll.add(a);\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(coll).transform(null));\n+\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(new Transformer[0]));\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(Collections.<Transformer<Object, Object>>emptyList()));\n+\n+        try {\n+            TransformerUtils.chainedTransformer(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer((Transformer[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer(new Transformer[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList<Transformer<Object, Object>>();\n+            coll.add(null);\n+            coll.add(null);\n+            TransformerUtils.chainedTransformer(coll);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // switchTransformer\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSwitchTransformer() {\n+        Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n+\n+        assertEquals(null, TransformerUtils.<Object, String>switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"THERE\"));\n+\n+        assertEquals(\"C\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }, c).transform(\"WELL\"));\n+\n+        Map<Predicate<String>, Transformer<String, String>> map = new HashMap<Predicate<String>, Transformer<String,String>>();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        assertEquals(null, TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(map).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(map).transform(\"THERE\"));\n+        map.put(null, c);\n+        assertEquals(\"C\", TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n+\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]));\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new HashMap<Predicate<Object>, Transformer<Object, Object>>()));\n+        map = new HashMap<Predicate<String>, Transformer<String, String>>();\n+        map.put(null, null);\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(map));\n+\n+        try {\n+            TransformerUtils.switchTransformer(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer((Predicate[]) null, (Transformer[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer((Map<Predicate<Object>, Transformer<Object, Object>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer(\n+                    new Predicate[] { TruePredicate.truePredicate() },\n+                    new Transformer[] { a, b });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // switchMapTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchMapTransformer() {\n+        Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+\n+        Map<String, Transformer<String, String>> map = new HashMap<String, Transformer<String,String>>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        assertEquals(null, TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchMapTransformer(map).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchMapTransformer(map).transform(\"THERE\"));\n+        map.put(null, c);\n+        assertEquals(\"C\", TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n+\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(new HashMap<Object, Transformer<Object, Object>>()));\n+        map = new HashMap<String, Transformer<String, String>>();\n+        map.put(null, null);\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(map));\n+\n+        try {\n+            TransformerUtils.switchMapTransformer(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // invokerTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testInvokerTransformer() {\n+        List<Object> list = new ArrayList<Object>();\n+        assertEquals(new Integer(0), TransformerUtils.invokerTransformer(\"size\").transform(list));\n+        list.add(new Object());\n+        assertEquals(new Integer(1), TransformerUtils.invokerTransformer(\"size\").transform(list));\n+        assertEquals(null, TransformerUtils.invokerTransformer(\"size\").transform(null));\n+\n+        try {\n+            TransformerUtils.invokerTransformer(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"noSuchMethod\").transform(new Object());\n+            fail();\n+        } catch (FunctorException ex) {}\n+    }\n+\n+    // invokerTransformer2\n+    //------------------------------------------------------------------\n+\n+    public void testInvokerTransformer2() {\n+        List<Object> list = new ArrayList<Object>();\n+        assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n+        list.add(cString);\n+        assertEquals(Boolean.TRUE, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n+        assertEquals(null, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(null));\n+\n+        try {\n+            TransformerUtils.invokerTransformer(null, null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"noSuchMethod\", new Class[] { Object.class },\n+                    new Object[] { cString }).transform(new Object());\n+            fail();\n+        } catch (FunctorException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", null, new Object[] { cString });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", new Class[] { Object.class }, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", new Class[] {}, new Object[] { cString });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // stringValueTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testStringValueTransformer() {\n+        assertNotNull( \"StringValueTransformer should NEVER return a null value.\",\n+           TransformerUtils.stringValueTransformer().transform(null));\n+        assertEquals( \"StringValueTransformer should return \\\"null\\\" when given a null argument.\", \"null\",\n+            TransformerUtils.stringValueTransformer().transform(null));\n+        assertEquals( \"StringValueTransformer should return toString value\", \"6\",\n+            TransformerUtils.stringValueTransformer().transform(new Integer(6)));\n+    }\n+\n+    // instantiateFactory\n+    //------------------------------------------------------------------\n+\n+    public void testInstantiateTransformerNull() {\n+        try {\n+            TransformerUtils.instantiateTransformer(null, new Object[] { \"str\" });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.instantiateTransformer(new Class[] {}, new Object[] { \"str\" });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        Transformer<Class<?>, Object> trans = TransformerUtils.instantiateTransformer(new Class[] { Long.class }, new Object[] { null });\n+        try {\n+            trans.transform(String.class);\n+            fail();\n+        } catch (FunctorException ex) {}\n+\n+        trans = TransformerUtils.instantiateTransformer();\n+        assertEquals(\"\", trans.transform(String.class));\n+\n+        trans = TransformerUtils.instantiateTransformer(new Class[] { Long.TYPE }, new Object[] { new Long(1000L) });\n+        assertEquals(new Date(1000L), trans.transform(Date.class));\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Transformer singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                CloneTransformer.INSTANCE,\n+                ExceptionTransformer.INSTANCE,\n+                NOPTransformer.INSTANCE,\n+                StringValueTransformer.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestUtils.java\n+package org.apache.commons.collections;\n+\n+import static org.junit.Assert.assertSame;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+public final class TestUtils {\n+\n+    private TestUtils() {\n+    }\n+\n+    /**\n+     * Asserts that deserialization of the object returns the same object as the\n+     * one that was serialized. Object is first serialized, then deserialized\n+     * and finally check is preformed to see if original and deserialized\n+     * object references are the same.\n+     * <p>\n+     * This method is especially good for testing singletone pattern on classes\n+     * that support serialization.\n+     *\n+     * @param msg the identifying message for the <code>AssertionError</code>.\n+     * @param o object that will be tested.\n+     * @see #assertSameAfterSerialization(Object)\n+     */\n+    public static void assertSameAfterSerialization(String msg, Object o) {\n+        try {\n+            // write object to byte buffer\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final ObjectOutputStream oos = new ObjectOutputStream(baos);\n+            oos.writeObject(o);\n+            oos.close();\n+\n+            // read same object from byte buffer\n+            final InputStream is = new ByteArrayInputStream(baos.toByteArray());\n+            final ObjectInputStream ois = new ObjectInputStream(is);\n+            final Object object = ois.readObject();\n+            ois.close();\n+\n+            // assert that original object and deserialized objects are the same\n+            assertSame(msg, o, object);\n+        } catch (IOException e) {\n+            // should never happen\n+            throw new RuntimeException(e);\n+        } catch (ClassNotFoundException e) {\n+            // should never happen\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Asserts that deserialization of the object returns the same object as the\n+     * one that was serialized.\n+     * <p>\n+     * Effect of method call is the same as:\n+     * <code>assertSameAfterSerialization(null, o)</code>.\n+     *\n+     * @param o object that will be tested.\n+     * @see #assertSameAfterSerialization(String, Object)\n+     */\n+    public static void assertSameAfterSerialization(Object o) {\n+        assertSameAfterSerialization(null, o);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/AbstractTestBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.Bag;\n+\n+/**\n+ * Abstract test class for {@link org.apache.commons.collections.Bag Bag} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject} method.\n+ * <p>\n+ * If your bag fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your bag fails.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestBag<T> extends AbstractTestObject {\n+//  TODO: this class should really extend from TestCollection, but the bag\n+//  implementations currently do not conform to the Collection interface.  Once\n+//  those are fixed or at least a strategy is made for resolving the issue, this\n+//  can be changed back to extend TestCollection instead.\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestBag(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return a new, empty bag to used for testing.\n+     * \n+     * @return the bag to be tested\n+     */\n+    @Override\n+    public abstract Bag<T> makeObject();\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBagAdd() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        assertTrue(\"Should contain 'A'\", bag.contains(\"A\"));\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n+        bag.add((T) \"A\");\n+        assertTrue(\"Should contain 'A'\", bag.contains(\"A\"));\n+        assertEquals(\"Should have count of 2\", 2, bag.getCount(\"A\"));\n+        bag.add((T) \"B\");\n+        assertTrue(bag.contains(\"A\"));\n+        assertTrue(bag.contains(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBagEqualsSelf() {\n+        Bag<T> bag = makeObject();\n+        assertTrue(bag.equals(bag));\n+        bag.add((T) \"elt\");\n+        assertTrue(bag.equals(bag));\n+        bag.add((T) \"elt\"); // again\n+        assertTrue(bag.equals(bag));\n+        bag.add((T) \"elt2\");\n+        assertTrue(bag.equals(bag));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n+        bag.remove(\"A\");\n+        assertEquals(\"Should have count of 0\", 0, bag.getCount(\"A\"));\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have count of 4\", 4, bag.getCount(\"A\"));\n+        bag.remove(\"A\", 0);\n+        assertEquals(\"Should have count of 4\", 4, bag.getCount(\"A\"));\n+        bag.remove(\"A\", 2);\n+        assertEquals(\"Should have count of 2\", 2, bag.getCount(\"A\"));\n+        bag.remove(\"A\");\n+        assertEquals(\"Should have count of 0\", 0, bag.getCount(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveAll() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\", 2);\n+        assertEquals(\"Should have count of 2\", 2, bag.getCount(\"A\"));\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        assertEquals(\"Should have count of 4\", 4, bag.size());\n+        List<String> delete = new ArrayList<String>();\n+        delete.add(\"A\");\n+        delete.add(\"B\");\n+        bag.removeAll(delete);\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n+        assertEquals(\"Should have count of 0\", 0, bag.getCount(\"B\"));\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"C\"));\n+        assertEquals(\"Should have count of 2\", 2, bag.size());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testContains() {\n+        Bag<T> bag = makeObject();\n+        \n+        assertEquals(\"Bag does not have at least 1 'A'\", false, bag.contains(\"A\"));\n+        assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n+        \n+        bag.add((T) \"A\");  // bag 1A\n+        assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n+        assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n+        \n+        bag.add((T) \"A\");  // bag 2A\n+        assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n+        assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n+        \n+        bag.add((T) \"B\");  // bag 2A,1B\n+        assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n+        assertEquals(\"Bag has at least 1 'B'\", true, bag.contains(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsAll() {\n+        Bag<T> bag = makeObject();\n+        List<String> known = new ArrayList<String>();\n+        List<String> known1A = new ArrayList<String>();\n+        known1A.add(\"A\");\n+        List<String> known2A = new ArrayList<String>();\n+        known2A.add(\"A\");\n+        known2A.add(\"A\");\n+        List<String> known1B = new ArrayList<String>();\n+        known1B.add(\"B\");\n+        List<String> known1A1B = new ArrayList<String>();\n+        known1A1B.add(\"A\");\n+        known1A1B.add(\"B\");\n+        \n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag does not containsAll of 1 'A'\", false, bag.containsAll(known1A));\n+        assertEquals(\"Bag does not containsAll of 2 'A'\", false, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"A\");  // bag 1A\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag does not containsAll of 2 'A'\", false, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"A\");  // bag 2A\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"A\");  // bag 3A\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"B\");  // bag 3A1B\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n+        assertEquals(\"Bag containsAll of 1 'B'\", true, bag.containsAll(known1B));\n+        assertEquals(\"Bag containsAll of 1 'A' 1 'B'\", true, bag.containsAll(known1A1B));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        Bag<T> bag = makeObject();\n+        assertEquals(\"Should have 0 total items\", 0, bag.size());\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have 1 total items\", 1, bag.size());\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have 2 total items\", 2, bag.size());\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have 3 total items\", 3, bag.size());\n+        bag.add((T) \"B\");\n+        assertEquals(\"Should have 4 total items\", 4, bag.size());\n+        bag.add((T) \"B\");\n+        assertEquals(\"Should have 5 total items\", 5, bag.size());\n+        bag.remove(\"A\", 2);\n+        assertEquals(\"Should have 1 'A'\", 1, bag.getCount(\"A\"));\n+        assertEquals(\"Should have 3 total items\", 3, bag.size());\n+        bag.remove(\"B\");\n+        assertEquals(\"Should have 1 total item\", 1, bag.size());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        List<String> retains = new ArrayList<String>();\n+        retains.add(\"B\");\n+        retains.add(\"C\");\n+        bag.retainAll(retains);\n+        assertEquals(\"Should have 2 total items\", 2, bag.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        assertEquals(\"Bag should have 3 items\", 3, bag.size());\n+        Iterator<T> i = bag.iterator();\n+    \n+        boolean foundA = false;\n+        while (i.hasNext()) {\n+            String element = (String) i.next();\n+            // ignore the first A, remove the second via Iterator.remove()\n+            if (element.equals(\"A\")) {\n+                if (foundA == false) {\n+                    foundA = true;\n+                } else {\n+                    i.remove();\n+                }\n+            }\n+        }\n+    \n+        assertTrue(\"Bag should still contain 'A'\", bag.contains(\"A\"));\n+        assertEquals(\"Bag should have 2 items\", 2, bag.size());\n+        assertEquals(\"Bag should have 1 'A'\", 1, bag.getCount(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorFail() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        Iterator<T> it = bag.iterator();\n+        it.next();\n+        bag.remove(\"A\");\n+        try {\n+            it.next();\n+            fail(\"Should throw ConcurrentModificationException\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorFailNoMore() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        Iterator<T> it = bag.iterator();\n+        it.next();\n+        it.next();\n+        it.next();\n+        try {\n+            it.next();\n+            fail(\"Should throw NoSuchElementException\");\n+        } catch (NoSuchElementException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorFailDoubleRemove() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        Iterator<T> it = bag.iterator();\n+        it.next();\n+        it.next();\n+        assertEquals(3, bag.size());\n+        it.remove();\n+        assertEquals(2, bag.size());\n+        try {\n+            it.remove();\n+            fail(\"Should throw IllegalStateException\");\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        }\n+        assertEquals(2, bag.size());\n+        it.next();\n+        it.remove();\n+        assertEquals(1, bag.size());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorRemoveProtectsInvariants() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        assertEquals(2, bag.size());\n+        Iterator<T> it = bag.iterator();\n+        assertEquals(\"A\", it.next());\n+        assertEquals(true, it.hasNext());\n+        it.remove();\n+        assertEquals(1, bag.size());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(\"A\", it.next());\n+        assertEquals(false, it.hasNext());\n+        it.remove();\n+        assertEquals(0, bag.size());\n+        assertEquals(false, it.hasNext());\n+        \n+        Iterator<T> it2 = bag.iterator();\n+        assertEquals(false, it2.hasNext());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testToArray() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        Object[] array = bag.toArray();\n+        int a = 0, b = 0, c = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            a += (array[i].equals(\"A\") ? 1 : 0);\n+            b += (array[i].equals(\"B\") ? 1 : 0);\n+            c += (array[i].equals(\"C\") ? 1 : 0);\n+        }\n+        assertEquals(2, a);\n+        assertEquals(2, b);\n+        assertEquals(1, c);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToArrayPopulate() {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        String[] array = bag.toArray(new String[0]);\n+        int a = 0, b = 0, c = 0;\n+        for (int i = 0; i < array.length; i++) {\n+            a += (array[i].equals(\"A\") ? 1 : 0);\n+            b += (array[i].equals(\"B\") ? 1 : 0);\n+            c += (array[i].equals(\"C\") ? 1 : 0);\n+        }\n+        assertEquals(2, a);\n+        assertEquals(2, b);\n+        assertEquals(1, c);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals() {\n+        Bag<T> bag = makeObject();\n+        Bag<T> bag2 = makeObject();\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        assertEquals(false, bag.equals(bag2));\n+        bag2.add((T) \"A\");\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"C\");\n+        assertEquals(true, bag.equals(bag2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsHashBag() {\n+        Bag<T> bag = makeObject();\n+        Bag<T> bag2 = new HashBag<T>();\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        assertEquals(false, bag.equals(bag2));\n+        bag2.add((T) \"A\");\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"C\");\n+        assertEquals(true, bag.equals(bag2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHashCode() {\n+        Bag<T> bag = makeObject();\n+        Bag<T> bag2 = makeObject();\n+        assertEquals(0, bag.hashCode());\n+        assertEquals(0, bag2.hashCode());\n+        assertEquals(bag.hashCode(), bag2.hashCode());\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"C\");\n+        assertEquals(bag.hashCode(), bag2.hashCode());\n+        \n+        int total = 0;\n+        total += (\"A\".hashCode() ^ 2);\n+        total += (\"B\".hashCode() ^ 2);\n+        total += (\"C\".hashCode() ^ 1);\n+        assertEquals(total, bag.hashCode());\n+        assertEquals(total, bag2.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEmptyBagSerialization() throws IOException, ClassNotFoundException {\n+        Bag<T> bag = makeObject();\n+        if (!(bag instanceof Serializable && isTestSerialization())) return;\n+        \n+        byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n+        Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Bag should be empty\",0, bag.size());\n+        assertEquals(\"Bag should be empty\",0, bag2.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullBagSerialization() throws IOException, ClassNotFoundException {\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        int size = bag.size();\n+        if (!(bag instanceof Serializable && isTestSerialization())) return;\n+        \n+        byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n+        Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Bag should be same size\", size, bag.size());\n+        assertEquals(\"Bag should be same size\", size, bag2.size());\n+    }\n+\n+    /**\n+     * Skip the serialized cannonical tests for now.\n+     *\n+     * @return true\n+     *\n+     * TODO: store a new serialized object on the disk.\n+     */\n+    @Override\n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Bag\n+     * against the canonical version in SVN.\n+     */\n+    public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {\n+        // test to make sure the canonical form has been preserved\n+        Bag<T> bag = makeObject();\n+        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));\n+            assertTrue(\"Bag is empty\",bag2.size()  == 0);\n+            assertEquals(bag, bag2);\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Bag\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullBagCompatibility() throws IOException, ClassNotFoundException {\n+        // test to make sure the canonical form has been preserved\n+        Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));\n+            assertEquals(\"Bag is the right size\",bag.size(), bag2.size());\n+            assertEquals(bag, bag2);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/AbstractTestSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import org.apache.commons.collections.SortedBag;\n+\n+/**\n+ * Abstract test class for\n+ * {@link org.apache.commons.collections.SortedBag SortedBag}\n+ * methods and contracts.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestSortedBag<T> extends AbstractTestBag<T> {\n+\n+    public AbstractTestSortedBag(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedBag<T> makeObject();\n+\n+    // TODO: Add the SortedBag tests!\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/TestHashBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import org.apache.commons.collections.Bag;\n+\n+/**\n+ * Extension of {@link AbstractTestBag} for exercising the {@link HashBag}\n+ * implementation.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ */\n+public class TestHashBag<T> extends AbstractTestBag<T> {\n+    \n+    public TestHashBag(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Bag<T> makeObject() {\n+        return new HashBag<T>();\n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeBag();\n+//        writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/HashBag.emptyCollection.version3.obj\");\n+//        bag = makeBag();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/HashBag.fullCollection.version3.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/TestPredicatedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractTestBag} for exercising the {@link PredicatedBag}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedBag<T> extends AbstractTestBag<T> {\n+\n+    public TestPredicatedBag(String testName) {\n+        super(testName);\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    protected Predicate<T> stringPredicate() {\n+        return new Predicate<T>() {\n+            public boolean evaluate(T o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n+\n+    protected Bag<T> decorateBag(HashBag<T> bag, Predicate<T> predicate) {\n+        return PredicatedBag.predicatedBag(bag, predicate);\n+    }\n+\n+    @Override\n+    public Bag<T> makeObject() {\n+        return decorateBag(new HashBag<T>(), truePredicate);\n+    }\n+\n+    protected Bag<T> makeTestBag() {\n+        return decorateBag(new HashBag<T>(), stringPredicate());\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testlegalAddRemove() {\n+        Bag<T> bag = makeTestBag();\n+        assertEquals(0, bag.size());\n+        T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\n+        for (int i = 0; i < els.length; i++) {\n+            bag.add(els[i]);\n+            assertEquals(i + 1, bag.size());\n+            assertEquals(true, bag.contains(els[i]));\n+        }\n+        Set<T> set = ((PredicatedBag<T>) bag).uniqueSet();\n+        assertTrue(\"Unique set contains the first element\",set.contains(els[0]));\n+        assertEquals(true, bag.remove(els[0]));\n+        set = ((PredicatedBag<T>) bag).uniqueSet();\n+        assertTrue(\"Unique set now does not contain the first element\",\n+            !set.contains(els[0]));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        Bag<T> bag = makeTestBag();\n+        Integer i = new Integer(3);\n+        try {\n+            bag.add((T) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !bag.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalDecorate() {\n+        HashBag<Object> elements = new HashBag<Object>();\n+        elements.add(\"one\");\n+        elements.add(\"two\");\n+        elements.add(new Integer(3));\n+        elements.add(\"four\");\n+        try {\n+            decorateBag((HashBag<T>) elements, stringPredicate());\n+            fail(\"Bag contains an element that should fail the predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            decorateBag(new HashBag<T>(), null);\n+            fail(\"Expectiing IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeBag();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/PredicatedBag.emptyCollection.version3.1.obj\");\n+//        bag = makeBag();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/PredicatedBag.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/TestPredicatedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.SortedBag;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedBag} for exercising the {@link PredicatedSortedBag}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedSortedBag<T> extends AbstractTestSortedBag<T> {\n+\n+    private SortedBag<T> nullBag = null;\n+\n+    public TestPredicatedSortedBag(String testName) {\n+        super(testName);\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    protected Predicate<T> stringPredicate() {\n+        return new Predicate<T>() {\n+            public boolean evaluate(T o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n+\n+    protected SortedBag<T> decorateBag(SortedBag<T> bag, Predicate<T> predicate) {\n+        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n+    }\n+\n+    @Override\n+    public SortedBag<T> makeObject() {\n+        return decorateBag(new TreeBag<T>(), truePredicate);\n+    }\n+\n+    protected SortedBag<T> makeTestBag() {\n+        return decorateBag(new TreeBag<T>(), stringPredicate());\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testDecorate() {\n+        SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n+        ((PredicatedSortedBag<T>) bag).decorated();\n+        try {\n+            decorateBag(new TreeBag<T>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate\");\n+        } catch (IllegalArgumentException e) {}\n+        try {\n+            decorateBag(nullBag, stringPredicate());\n+            fail(\"Expecting IllegalArgumentException for null bag\");\n+        } catch (IllegalArgumentException e) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSortOrder() {\n+        SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n+        String one = \"one\";\n+        String two = \"two\";\n+        String three = \"three\";\n+        bag.add((T) one);\n+        bag.add((T) two);\n+        bag.add((T) three);\n+        assertEquals(\"first element\", bag.first(), one);\n+        assertEquals(\"last element\", bag.last(), two);\n+        Comparator<? super T> c = bag.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeBag();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/PredicatedSortedBag.emptyCollection.version3.1.obj\");\n+//        bag = makeBag();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/PredicatedSortedBag.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/TestTransformedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestBag} for exercising the {@link TransformedBag}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedBag<T> extends AbstractTestBag<T> {\n+\n+    public TestTransformedBag(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Bag<T> makeObject() {\n+        return TransformedBag.transformingBag(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedBag() {\n+        //T had better be Object!\n+        Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, bag.size());\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            bag.add((T) els[i]);\n+            assertEquals(i + 1, bag.size());\n+            assertEquals(true, bag.contains(new Integer((String) els[i])));\n+            assertEquals(false, bag.contains(els[i]));\n+        }\n+\n+        assertEquals(false, bag.remove(els[0]));\n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+    }\n+\n+    // TODO: Generics\n+    public void testTransformedBag_decorateTransform() {\n+        Bag originalBag = new HashBag();\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            originalBag.add(els[i]);\n+        }\n+        Bag bag = TransformedBag.transformedBag(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, bag.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, bag.contains(new Integer((String) els[i])));\n+            assertEquals(false, bag.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, bag.remove(els[0]));\n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeBag();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/TransformedBag.emptyCollection.version3.1.obj\");\n+//        bag = makeBag();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/TransformedBag.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/TestTransformedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.SortedBag;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedBag} for exercising the {@link TransformedSortedBag}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedSortedBag<T> extends AbstractTestSortedBag<T> {\n+\n+    public TestTransformedSortedBag(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedBag<T> makeObject() {\n+        return TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedBag() {\n+        SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, bag.size());\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            bag.add((T) els[i]);\n+            assertEquals(i + 1, bag.size());\n+            assertEquals(true, bag.contains(new Integer((String) els[i])));\n+        }\n+\n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+\n+    }\n+\n+    public void testTransformedBag_decorateTransform() {\n+        Bag<Object> originalBag = new TreeBag<Object>();\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            originalBag.add(els[i]);\n+        }\n+        Bag<?> bag = TransformedBag.transformedBag(originalBag, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, bag.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, bag.contains(new Integer((String) els[i])));\n+        }\n+        \n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeBag();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/TransformedSortedBag.emptyCollection.version3.1.obj\");\n+//        bag = makeBag();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"D:/dev/collections/data/test/TransformedSortedBag.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bag/TestTreeBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bag;\n+\n+import org.apache.commons.collections.Bag;\n+import org.apache.commons.collections.SortedBag;\n+\n+/**\n+ * Extension of {@link AbstractTestBag} for exercising the {@link TreeBag}\n+ * implementation.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Chuck Burdick\n+ */\n+public class TestTreeBag<T> extends AbstractTestSortedBag<T> {\n+\n+    public TestTreeBag(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public SortedBag<T> makeObject() {\n+        return new TreeBag<T>();\n+    }\n+\n+   // TODO: Generics (for example... is this even needed?)\n+   public void testCollections265() {\n+       Bag<Object> bag = new TreeBag<Object>();\n+       try {\n+           bag.add(new Object());\n+           fail(\"IllegalArgumentException expected\");\n+       } catch(IllegalArgumentException iae) {\n+           // expected;\n+       }\n+   }\n+   \n+    @SuppressWarnings(\"unchecked\")\n+    public SortedBag<T> setupBag() {\n+        SortedBag<T> bag = makeObject();\n+        bag.add((T) \"C\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"D\");\n+        return bag;\n+    }\n+\n+    public void testOrdering() {\n+        Bag<T> bag = setupBag();\n+        assertEquals(\"Should get elements in correct order\", \"A\", bag.toArray()[0]);\n+        assertEquals(\"Should get elements in correct order\", \"B\", bag.toArray()[1]);\n+        assertEquals(\"Should get elements in correct order\", \"C\", bag.toArray()[2]);\n+        assertEquals(\"Should get first key\", \"A\", ((SortedBag<T>) bag).first());\n+        assertEquals(\"Should get last key\", \"D\", ((SortedBag<T>) bag).last());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //   public void testCreate() throws Exception {\n+    //       Bag bag = makeBag();\n+    //       writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/TreeBag.emptyCollection.version3.obj\");\n+    //       bag = makeBag();\n+    //       bag.add(\"A\");\n+    //       bag.add(\"A\");\n+    //       bag.add(\"B\");\n+    //       bag.add(\"B\");\n+    //       bag.add(\"C\");\n+    //       writeExternalFormToDisk((Serializable) bag, \"D:/dev/collections/data/test/TreeBag.fullCollection.version3.obj\");\n+    //   }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractTestBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+import org.apache.commons.collections.map.AbstractTestIterableMap;\n+\n+/**\n+ * Abstract test class for {@link BidiMap} methods and contracts.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestBidiMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public AbstractTestBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public AbstractTestBidiMap() {\n+        super(\"Inverse\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to create a full <code>BidiMap</code> other than the default.\n+     *\n+     * @return a full <code>BidiMap</code> implementation.\n+     */\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        return (BidiMap<K, V>) super.makeFullMap();\n+    }\n+\n+    /**\n+     * Override to return the empty BidiMap.\n+     */\n+    @Override\n+    public abstract BidiMap<K, V> makeObject();\n+\n+    /**\n+     * Override to indicate to AbstractTestMap this is a BidiMap.\n+     */\n+    @Override\n+    public boolean isAllowDuplicateValues() {\n+        return false;\n+    }\n+\n+    /**\n+     * Override as DualHashBidiMap didn't exist until version 3.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    // BidiPut\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBidiPut() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+\n+        BidiMap<K, V> map = makeObject();\n+        BidiMap<V, K> inverse = map.inverseBidiMap();\n+        assertEquals(0, map.size());\n+        assertEquals(map.size(), inverse.size());\n+\n+        map.put((K) \"A\", (V) \"B\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"B\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"B\"));\n+\n+        map.put((K) \"A\", (V) \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"C\"));\n+\n+        map.put((K) \"B\", (V) \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"B\"));\n+        assertEquals(\"B\", inverse.get(\"C\"));\n+\n+        map.put((K) \"E\", (V) \"F\");\n+        assertEquals(2, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"F\", map.get(\"E\"));\n+        assertEquals(\"E\", inverse.get(\"F\"));\n+    }\n+\n+    /**\n+     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     * <p>\n+     * This implementation checks the inverse map as well.\n+     */\n+    @Override\n+    public void verify() {\n+        verifyInverse();\n+        super.verify();\n+    }\n+\n+    public void verifyInverse() {\n+        assertEquals(map.size(), ((BidiMap<K, V>) map).inverseBidiMap().size());\n+        Map<K, V> map1 = new HashMap<K, V>(map);\n+        Map<V, K> map2 = new HashMap<V, K>(((BidiMap<K, V>) map).inverseBidiMap());\n+        Set<K> keys1 = map1.keySet();\n+        Set<V> keys2 = map2.keySet();\n+        Collection<V> values1 = map1.values();\n+        Collection<K> values2 = map2.values();\n+        assertEquals(true, keys1.containsAll(values2));\n+        assertEquals(true, values2.containsAll(keys1));\n+        assertEquals(true, values1.containsAll(keys2));\n+        assertEquals(true, keys2.containsAll(values1));\n+    }\n+\n+    // testGetKey\n+    //-----------------------------------------------------------------------\n+    public void testBidiGetKey() {\n+        doTestGetKey(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+    }\n+\n+    public void testBidiGetKeyInverse() {\n+        doTestGetKey(\n+            makeFullMap().inverseBidiMap(),\n+            getSampleValues()[0],\n+            getSampleKeys()[0]);\n+    }\n+\n+    private final void doTestGetKey(BidiMap<?, ?> map, Object key, Object value) {\n+        assertEquals(\"Value not found for key.\", value, map.get(key));\n+        assertEquals(\"Key not found for value.\", key, map.getKey(value));\n+    }\n+\n+    // testInverse\n+    //-----------------------------------------------------------------------\n+    public void testBidiInverse() {\n+        final BidiMap<K, V> map = makeFullMap();\n+        final BidiMap<V, K> inverseMap = map.inverseBidiMap();\n+\n+        assertSame(\n+            \"Inverse of inverse is not equal to original.\",\n+            map,\n+            inverseMap.inverseBidiMap());\n+\n+        assertEquals(\n+            \"Value not found for key.\",\n+            getSampleKeys()[0],\n+            inverseMap.get(getSampleValues()[0]));\n+\n+        assertEquals(\n+            \"Key not found for value.\",\n+            getSampleValues()[0],\n+            inverseMap.getKey(getSampleKeys()[0]));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiModifyEntrySet() {\n+        if (isSetValueSupported() == false) return;\n+\n+        modifyEntrySet(makeFullMap());\n+        modifyEntrySet(makeFullMap().inverseBidiMap());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private final <T> void modifyEntrySet(BidiMap<?, T> map) {\n+        // Gets first entry\n+        final Map.Entry<?, T> entry = map.entrySet().iterator().next();\n+\n+        // Gets key and value\n+        final Object key = entry.getKey();\n+        final Object oldValue = entry.getValue();\n+\n+        // Sets new value\n+        final Object newValue = \"newValue\";\n+        entry.setValue((T) newValue);\n+\n+        assertEquals(\n+            \"Modifying entrySet did not affect underlying Map.\",\n+            newValue,\n+            map.get(key));\n+\n+        assertNull(\n+            \"Modifying entrySet did not affect inverse Map.\",\n+            map.getKey(oldValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClear() {\n+        if (isRemoveSupported() == false) {\n+            try {\n+                makeFullMap().clear();\n+                fail();\n+            } catch(UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        BidiMap<?, ?> map = makeFullMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+        // Tests clear on inverse\n+        map = makeFullMap().inverseBidiMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemove() {\n+        if (isRemoveSupported() == false) {\n+            try {\n+                makeFullMap().remove(getSampleKeys()[0]);\n+                fail();\n+            } catch(UnsupportedOperationException ex) {}\n+            try {\n+                makeFullMap().removeValue(getSampleValues()[0]);\n+                fail();\n+            } catch(UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        remove(makeFullMap(), getSampleKeys()[0]);\n+        remove(makeFullMap().inverseBidiMap(), getSampleValues()[0]);\n+\n+        removeValue(makeFullMap(), getSampleValues()[0]);\n+        removeValue(makeFullMap().inverseBidiMap(), getSampleKeys()[0]);\n+\n+        assertEquals(null, makeFullMap().removeValue(\"NotPresent\"));\n+    }\n+\n+    private final void remove(BidiMap<?, ?> map, Object key) {\n+        final Object value = map.remove(key);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    private final void removeValue(BidiMap<?, ?> map, Object value) {\n+        final Object key = map.removeValue(value);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiKeySetValuesOrder() {\n+        resetFull();\n+        Iterator<K> keys = map.keySet().iterator();\n+        Iterator<V> values = map.values().iterator();\n+        for (; keys.hasNext() && values.hasNext();) {\n+            K key = keys.next();\n+            V value = values.next();\n+            assertSame(map.get(key), value);\n+        }\n+        assertEquals(false, keys.hasNext());\n+        assertEquals(false, values.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByKeySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        removeByKeySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+        removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n+    }\n+\n+    private final void removeByKeySet(BidiMap<?, ?> map, Object key, Object value) {\n+        map.keySet().remove(key);\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        removeByEntrySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+        removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n+    }\n+\n+    private final void removeByEntrySet(BidiMap<?, ?> map, Object key, Object value) {\n+        Map<Object, Object> temp = new HashMap<Object, Object>();\n+        temp.put(key, value);\n+        map.entrySet().remove(temp.entrySet().iterator().next());\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public BidiMap<K, V> getMap() {\n+        return (BidiMap<K, V>) super.getMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestBidiMapEntrySet();\n+    }\n+\n+    public class TestBidiMapEntrySet extends TestMapEntrySet {\n+        public TestBidiMapEntrySet() {\n+            super();\n+        }\n+        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n+            K key1 = getSampleKeys()[0];\n+            K key2 = getSampleKeys()[1];\n+            V newValue1 = getNewSampleValues()[0];\n+            V newValue2 = getNewSampleValues()[1];\n+\n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            it = TestBidiMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            TestBidiMapEntrySet.this.verify();\n+\n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            // these checked in superclass\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+\n+            // at this point\n+            // key1=newValue1, key2=newValue2\n+            try {\n+                entry2.setValue(newValue1);  // should remove key1\n+            } catch (IllegalArgumentException ex) {\n+                return;  // simplest way of dealing with tricky situation\n+            }\n+            entryConfirmed2.setValue(newValue1);\n+            AbstractTestBidiMap.this.getConfirmed().remove(key1);\n+            assertEquals(newValue1, entry2.getValue());\n+            assertEquals(true, AbstractTestBidiMap.this.getMap().containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractTestBidiMap.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestBidiMap.this.getMap().get(entry2.getKey()));\n+            assertEquals(false, AbstractTestBidiMap.this.getMap().containsKey(key1));\n+            assertEquals(false, AbstractTestBidiMap.this.getMap().containsValue(newValue2));\n+            TestBidiMapEntrySet.this.verify();\n+\n+            // check for ConcurrentModification\n+            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+            if (isRemoveSupported()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    public BulkTest bulkTestInverseMap() {\n+        return new TestInverseBidiMap(this);\n+    }\n+\n+    public class TestInverseBidiMap extends AbstractTestBidiMap<V, K> {\n+        final AbstractTestBidiMap<K, V> main;\n+\n+        public TestInverseBidiMap(AbstractTestBidiMap<K, V> main) {\n+            super();\n+            this.main = main;\n+        }\n+\n+        @Override\n+        public BidiMap<V, K> makeObject() {\n+            return main.makeObject().inverseBidiMap();\n+        }\n+\n+        @Override\n+        public BidiMap<V, K> makeFullMap() {\n+            return main.makeFullMap().inverseBidiMap();\n+        }\n+\n+        @Override\n+        public V[] getSampleKeys() {\n+            return main.getSampleValues();\n+        }\n+        @Override\n+        public K[] getSampleValues() {\n+            return main.getSampleKeys();\n+        }\n+\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+\n+        @Override\n+        public boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+\n+        @Override\n+        public boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+\n+        @Override\n+        public boolean isSetValueSupported() {\n+            return main.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestBidiMapIterator() {\n+        return new TestBidiMapIterator();\n+    }\n+\n+    public class TestBidiMapIterator extends AbstractTestMapIterator<K, V> {\n+        public TestBidiMapIterator() {\n+            super(\"TestBidiMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractTestBidiMap.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractTestBidiMap.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractTestBidiMap.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractTestBidiMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractTestBidiMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public BidiMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestBidiMap.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestBidiMap.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractTestBidiMap.this.verify();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiMapIteratorSet() {\n+        V newValue1 = getOtherValues()[0];\n+        V newValue2 = getOtherValues()[1];\n+\n+        resetFull();\n+        BidiMap<K, V> bidi = getMap();\n+        MapIterator<K, V> it = bidi.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        K key1 = it.next();\n+\n+        if (isSetValueSupported() == false) {\n+            try {\n+                it.setValue(newValue1);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+\n+        it.setValue(newValue1);\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+\n+        it.setValue(newValue1);  // same value - should be OK\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+\n+        K key2 = it.next();\n+        it.setValue(newValue2);\n+        confirmed.put(key2, newValue2);\n+        assertSame(key2, it.getKey());\n+        assertSame(newValue2, it.getValue());\n+        assertEquals(true, bidi.containsKey(key2));\n+        assertEquals(true, bidi.containsValue(newValue2));\n+        assertEquals(newValue2, bidi.get(key2));\n+        verify();\n+\n+        // at this point\n+        // key1=newValue1, key2=newValue2\n+        try {\n+            it.setValue(newValue1);  // should remove key1\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            return;  // simplest way of dealing with tricky situation\n+        }\n+        confirmed.put(key2, newValue1);\n+        AbstractTestBidiMap.this.getConfirmed().remove(key1);\n+        assertEquals(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(it.getKey()));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(it.getKey()));\n+        assertEquals(false, bidi.containsKey(key1));\n+        assertEquals(false, bidi.containsValue(newValue2));\n+        verify();\n+\n+        // check for ConcurrentModification\n+        it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+        if (isRemoveSupported()) {\n+            it.remove();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractTestOrderedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedBidiMap;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+\n+/**\n+ * Abstract test class for {@link OrderedBidiMap} methods and contracts.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestOrderedBidiMap<K, V> extends AbstractTestBidiMap<K, V> {\n+\n+    public AbstractTestOrderedBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public AbstractTestOrderedBidiMap() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        try {\n+            bidi.firstKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        bidi = getMap();\n+        K confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, bidi.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        try {\n+            bidi.lastKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        bidi = getMap();\n+        K confirmedLast = null;\n+        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, bidi.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNextKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = (OrderedBidiMap<K, V>) map;\n+        assertEquals(null, bidi.nextKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.nextKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+\n+        resetFull();\n+        bidi = (OrderedBidiMap<K, V>) map;\n+        Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.nextKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.nextKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+    }\n+\n+    public void testPreviousKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        assertEquals(null, bidi.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.previousKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+\n+        resetFull();\n+        bidi = getMap();\n+        List<K> list = new ArrayList<K>(confirmed.keySet());\n+        Collections.reverse(list);\n+        Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.previousKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.previousKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestOrderedMapIterator() {\n+        return new TestBidiOrderedMapIterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> getMap() {\n+        return (OrderedBidiMap<K, V>) super.getMap();\n+    }\n+\n+    public class TestBidiOrderedMapIterator extends AbstractTestMapIterator<K, V> {\n+        public TestBidiOrderedMapIterator() {\n+            super(\"TestBidiOrderedMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractTestOrderedBidiMap.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractTestOrderedBidiMap.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractTestOrderedBidiMap.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractTestOrderedBidiMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractTestOrderedBidiMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public Map<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestOrderedBidiMap.this.map;\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestOrderedBidiMap.this.confirmed;\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractTestOrderedBidiMap.this.verify();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractTestSortedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.SortedBidiMap;\n+import org.apache.commons.collections.map.AbstractTestSortedMap;\n+\n+/**\n+ * Abstract test class for {@link SortedBidiMap} methods and contracts.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestSortedBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestOrderedBidiMap<K, V> {\n+\n+    protected List<K> sortedKeys;\n+    protected List<V> sortedValues = new ArrayList<V>();\n+    protected SortedSet<V> sortedNewValues = new TreeSet<V>();\n+\n+    public AbstractTestSortedBidiMap(String testName) {\n+        super(testName);\n+        sortedKeys = getAsList(getSampleKeys());\n+        Collections.sort(sortedKeys);\n+        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+\n+        Map<K, V> map = new TreeMap<K, V>();\n+        addSampleMappings(map);\n+\n+        sortedValues.addAll(map.values());\n+        sortedValues = Collections.unmodifiableList(sortedValues);\n+\n+        sortedNewValues.addAll(this.<V> getAsList(getNewSampleValues()));\n+    }\n+\n+//    public AbstractTestSortedBidiMap() {\n+//        super();\n+//        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n+//        Collections.sort(sortedKeys);\n+//        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+//\n+//        Map map = new TreeMap();\n+//        for (int i = 0; i < getSampleKeys().length; i++) {\n+//            map.put(getSampleValues()[i], getSampleKeys()[i]);\n+//        }\n+//        sortedValues.addAll(map.values());\n+//        sortedValues = Collections.unmodifiableList(sortedValues);\n+//\n+//        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedBidiMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        return (SortedBidiMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiHeadMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K toKey = it.next();\n+        K second = it.next();\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> head = sm.headMap(toKey);\n+        assertEquals(1, head.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, head.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, head.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(false, head.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(false, head.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByHeadMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+        V toKeyValue = sm.get(toKey);\n+\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n+        int size = sm.size();\n+        assertEquals(2, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+\n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        V firstValue = sub.remove(first);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        V secondValue = sub.remove(second);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMapEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        assertEquals(2, sub.size());\n+        assertEquals(2, set.size());\n+\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiTailMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        assertEquals(sm.size() - 1, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByTailMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        int size = sm.size();\n+        assertEquals(size - 3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(3, sm.size());\n+        assertEquals(3, sm.inverseBidiMap().size());\n+\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        Object firstValue = sub.remove(first);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        Object secondValue = sub.remove(second);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMapEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiSubMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+        K third = it.next();\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+        V thirdValue = sm.get(third);\n+\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+        assertEquals(true, sm.containsKey(third));\n+        assertEquals(false, sub.containsKey(third));\n+        assertEquals(true, sm.containsValue(thirdValue));\n+        assertEquals(false, sub.containsValue(thirdValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearBySubMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        V fromKeyValue = sm.get(fromKey);\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+        V toKeyValue = sm.get(toKey);\n+\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        int size = sm.size();\n+        assertEquals(3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 3, sm.size());\n+        assertEquals(size - 3, sm.inverseBidiMap().size());\n+\n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+\n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        V firstValue = sub.remove(first);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        V secondValue = sub.remove(second);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMapEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        assertEquals(3, set.size());\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestHeadMap() {\n+        return new AbstractTestSortedMap.TestHeadMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new AbstractTestSortedMap.TestTailMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new AbstractTestSortedMap.TestSubMap<K, V>(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestAbstractOrderedBidiMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.OrderedBidiMap;\n+\n+/**\n+ * Test class for AbstractOrderedBidiMapDecorator.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class TestAbstractOrderedBidiMapDecorator<K, V>\n+        extends AbstractTestOrderedBidiMap<K, V> {\n+\n+    public TestAbstractOrderedBidiMapDecorator(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return new TestOrderedBidiMap<K, V>();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isSetValueSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Simple class to actually test.\n+     */\n+    private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {\n+\n+        private TestOrderedBidiMap<V, K> inverse = null;\n+\n+        public TestOrderedBidiMap() {\n+            super(new DualTreeBidiMap<K, V>());\n+        }\n+\n+        public TestOrderedBidiMap(OrderedBidiMap<K, V> map) {\n+            super(map);\n+        }\n+\n+        @Override\n+        public OrderedBidiMap<V, K> inverseBidiMap() {\n+            if (inverse == null) {\n+                inverse = new TestOrderedBidiMap<V, K>(decorated().inverseBidiMap());\n+                inverse.inverse = this;\n+            }\n+            return inverse;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestDualHashBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class TestDualHashBidiMap<K, V> extends AbstractTestBidiMap<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestDualHashBidiMap.class);\n+    }\n+\n+    public TestDualHashBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualHashBidiMap<K, V> makeObject() {\n+        return new DualHashBidiMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] { \"TestDualHashBidiMap.bulkTestInverseMap.bulkTestInverseMap\" };\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualHashBidiMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualHashBidiMap.fullCollection.version3.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestDualTreeBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ */\n+public class TestDualTreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestSortedBidiMap<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestDualTreeBidiMap.class);\n+    }\n+\n+    public TestDualTreeBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"TestDualTreeBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.fullCollection.version3.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestDualTreeBidiMap2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.SortedBidiMap;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ * @author Jonas Van Poucke\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestDualTreeBidiMap2<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestSortedBidiMap<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestDualTreeBidiMap2.class);\n+    }\n+\n+    public TestDualTreeBidiMap2(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>(\n+                new ReverseComparator<K>(ComparableComparator.<K> comparableComparator()),\n+                new ReverseComparator<V>(ComparableComparator.<V> comparableComparator()));\n+    }\n+\n+    @Override\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n+    }\n+\n+    public void testComparator() {\n+        resetEmpty();\n+        SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;\n+        assertNotNull(bidi.comparator());\n+        assertTrue(bidi.comparator() instanceof ReverseComparator);\n+    }\n+\n+    public void testComparator2() {\n+        DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<String, Integer>(\n+                String.CASE_INSENSITIVE_ORDER, null);\n+        dtbm.put(\"two\", 0);\n+        dtbm.put(\"one\", 1);\n+        assertEquals(\"one\", dtbm.firstKey());\n+        assertEquals(\"two\", dtbm.lastKey());\n+        \n+    }\n+\n+    public void testSerializeDeserializeCheckComparator() throws Exception {\n+        SortedBidiMap<?, ?> obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            Object dest = in.readObject();\n+            in.close();\n+\n+            SortedBidiMap<?,?> bidi = (SortedBidiMap<?,?>) dest;\n+            assertNotNull(obj.comparator());\n+            assertNotNull(bidi.comparator());\n+            assertTrue(bidi.comparator() instanceof ReverseComparator);\n+        }\n+    }\n+\n+    private static class IntegerComparator implements Comparator<Integer>, java.io.Serializable{\n+        private static final long serialVersionUID = 1L;\n+        public int compare(Integer o1, Integer o2) {\n+            return o1.compareTo(o2);\n+        }\n+    }\n+\n+    public void testCollections364() throws Exception {\n+        DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<String, Integer>(\n+                String.CASE_INSENSITIVE_ORDER, new IntegerComparator());\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(original);\n+        out.close();\n+\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        @SuppressWarnings(\"unchecked\")\n+        DualTreeBidiMap<String, Integer> deserialised = (DualTreeBidiMap<String, Integer>) in.readObject();\n+        in.close();\n+\n+        assertNotNull(original.comparator());\n+        assertNotNull(deserialised.comparator());\n+        assertEquals(original.comparator().getClass(), deserialised.comparator().getClass());\n+        assertEquals(original.valueComparator().getClass(), deserialised.valueComparator().getClass());\n+    }\n+\n+    public void testSortOrder() throws Exception {\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+\n+        // Sort by the comparator used in the makeEmptyBidiMap() method\n+        List<K> newSortedKeys = getAsList(getSampleKeys());\n+        Collections.sort(newSortedKeys, new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n+        newSortedKeys = Collections.unmodifiableList(newSortedKeys);\n+\n+        Iterator<K> mapIter = sm.keySet().iterator();\n+        Iterator<K> expectedIter = newSortedKeys.iterator();\n+        while (expectedIter.hasNext()) {\n+            K expectedKey = expectedIter.next();\n+            K mapKey = mapIter.next();\n+            assertNotNull(\"key in sorted list may not be null\", expectedKey);\n+            assertNotNull(\"key in map may not be null\", mapKey);\n+            assertEquals(\"key from sorted list and map must be equal\", expectedKey, mapKey);\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.Test2\";\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"TestDualTreeBidiMap2.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.emptyCollection.version3.Test2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.fullCollection.version3.Test2.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestTreeBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestOrderedBidiMap<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestTreeBidiMap.class);\n+    }\n+\n+    public TestTreeBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeObject() {\n+        return new TreeBidiMap<K, V>();\n+    }\n+    \n+    @Override\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"TestTreeBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public boolean isSetValueSupported() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/TreeBidiMap.emptyCollection.version3.3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/TreeBidiMap.fullCollection.version3.3.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestUnmodifiableBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableBidiMap<K, V> extends AbstractTestBidiMap<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnmodifiableBidiMap.class);\n+    }\n+\n+    public TestUnmodifiableBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeObject() {\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(new DualHashBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        BidiMap<K, V> bidi = new DualHashBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"TestUnmodifiableBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestUnmodifiableOrderedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.OrderedBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableOrderedBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestOrderedBidiMap<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnmodifiableOrderedBidiMap.class);\n+    }\n+\n+    public TestUnmodifiableOrderedBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(new TreeBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        OrderedBidiMap<K, V> bidi = new TreeBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"TestUnmodifiableOrderedBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TestUnmodifiableSortedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.SortedBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableSortedBidiMap<K extends Comparable<K>, V extends Comparable<V>> extends AbstractTestSortedBidiMap<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnmodifiableSortedBidiMap.class);\n+    }\n+\n+    public TestUnmodifiableSortedBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedBidiMap<K, V> makeObject() {\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(new DualTreeBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        SortedBidiMap<K, V> bidi = new DualTreeBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        // Override to prevent infinite recursion of tests.\n+        return new String[] {\"TestUnmodifiableSortedBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestBlockingBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.Set;\n+\n+/**\n+ * Extension of {@link AbstractTestObject} for exercising the\n+ * {@link BlockingBuffer} implementation.\n+ *\n+ * @author Janek Bogucki\n+ * @author Phil Steitz\n+ * @version $Revision$\n+ * @since Commons Collections 3.0\n+ */\n+public class TestBlockingBuffer<E> extends AbstractTestObject {\n+\n+    public TestBlockingBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return BlockingBuffer.blockingBuffer(new MyBuffer<E>());\n+    }\n+\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected E makeElement() {\n+        return (E) new Object();\n+    }\n+    \n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#add(Object)}.\n+     */\n+    public void testGetWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    public void testGetWithAddTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj, 100).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)}.\n+     */\n+    public void testGetWithAddAll() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    public void testGetWithAddAllTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj, 100).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#add(Object)}.\n+     */\n+    public void testRemoveWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.remove());\n+    }\n+\n+    public void testRemoveWithAddTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n+        E obj = makeElement();\n+        new DelayedAdd<E>(blockingBuffer, obj, 500).start();\n+        try {\n+            blockingBuffer.remove();\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)}.\n+     */\n+    public void testRemoveWithAddAll() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.remove());\n+    }\n+\n+    public void testRemoveWithAddAllTimeout() {\n+        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n+        E obj = makeElement();\n+        new DelayedAddAll<E>(blockingBuffer, obj, 500).start();\n+        try {\n+            blockingBuffer.remove();\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#add(Object)} using multiple read threads. <p/> Two\n+     * read threads should block on an empty buffer until one object is added\n+     * then both threads should complete.\n+     */\n+    public void testBlockedGetWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will get and compare -- must wait for add\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+\n+        // notifyAll should allow both read threads to complete\n+        blockingBuffer.add(obj);\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#get()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * singleton is added then both threads should complete.\n+     */\n+    public void testBlockedGetWithAddAll() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will get and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+\n+        // notifyAll should allow both read threads to complete\n+        blockingBuffer.addAll(Collections.singleton(obj));\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests interrupted {@link BlockingBuffer#get()}.\n+     */\n+    public void testInterruptedGet() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // spawn a read thread to wait on the empty buffer\n+        ArrayList<String> exceptionList = new ArrayList<String>();\n+        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList);\n+        thread.start();\n+\n+        // Interrupting the thread should cause it to throw BufferUnderflowException\n+        thread.interrupt();\n+\n+        // Chill, so thread can throw and add message to exceptionList\n+        delay();\n+        assertTrue(\"Thread interrupt should have led to underflow\", exceptionList\n+                .contains(\"BufferUnderFlow\"));\n+        if (thread.isAlive()) {\n+            fail(\"Read thread has hung.\");\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#add(Object)} using multiple read threads. <p/> Two\n+     * read threads should block on an empty buffer until one object is added\n+     * then one thread should complete. The remaining thread should complete\n+     * after the addition of a second object.\n+     */\n+    public void testBlockedRemoveWithAdd() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will remove and compare -- must wait for add\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+        blockingBuffer.add(obj);\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should be one thread waiting.\n+        assertTrue(\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+        blockingBuffer.add(obj);\n+\n+        // allow notified thread to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * singleton collection is added then one thread should complete. The\n+     * remaining thread should complete after the addition of a second\n+     * singleton.\n+     */\n+    public void testBlockedRemoveWithAddAll1() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // run methods will remove and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+        blockingBuffer.addAll(Collections.singleton(obj));\n+\n+        // allow notified threads to complete \n+        delay();\n+\n+        // There should be one thread waiting.\n+        assertTrue(\"There is one thread waiting\", thread1.isAlive() ^ thread2.isAlive());\n+        blockingBuffer.addAll(Collections.singleton(obj));\n+\n+        // allow notified thread to complete \n+        delay();\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests {@link BlockingBuffer#remove()} in combination with\n+     * {@link BlockingBuffer#addAll(java.util.Collection)} using multiple read\n+     * threads. <p/> Two read threads should block on an empty buffer until a\n+     * collection with two distinct objects is added then both threads should\n+     * complete. Each thread should have read a different object.\n+     */\n+    public void testBlockedRemoveWithAddAll2() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj1 = makeElement();\n+        E obj2 = makeElement();\n+        Set<E> objs = Collections.synchronizedSet(new HashSet<E>());\n+        objs.add(obj1);\n+        objs.add(obj2);\n+\n+        // run methods will remove and compare -- must wait for addAll\n+        Thread thread1 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n+        Thread thread2 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n+        thread1.start();\n+        thread2.start();\n+\n+        // give hungry read threads ample time to hang\n+        delay();\n+        blockingBuffer.addAll(objs);\n+\n+        // allow notified threads to complete \n+        delay();\n+        assertEquals(\"Both objects were removed\", 0, objs.size());\n+\n+        // There should not be any threads waiting.\n+        if (thread1.isAlive() || thread2.isAlive()) {\n+            fail(\"Live thread(s) when both should be dead.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Tests interrupted remove.\n+     */\n+    public void testInterruptedRemove() {\n+        Buffer<E> blockingBuffer = makeObject();\n+        E obj = makeElement();\n+\n+        // spawn a read thread to wait on the empty buffer\n+        ArrayList<String> exceptionList = new ArrayList<String>();\n+        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList, \"remove\");\n+        thread.start();\n+\n+        // Interrupting the thread should cause it to throw BufferUnderflowException\n+        thread.interrupt();\n+\n+        // Chill, so thread can throw and add message to exceptionList\n+        delay();\n+        assertTrue(\"Thread interrupt should have led to underflow\", exceptionList\n+                .contains(\"BufferUnderFlow\"));\n+        if (thread.isAlive()) {\n+            fail(\"Read thread has hung.\");\n+        }\n+\n+    }\n+\n+    public void testTimeoutGet() {\n+        final BlockingBuffer<E> buffer = new BlockingBuffer<E>(new MyBuffer<E>());\n+        try {\n+            buffer.get(100);\n+            fail(\"Get should have timed out.\");\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    public void testTimeoutRemove() {\n+        final BlockingBuffer<E> buffer = new BlockingBuffer<E>(new MyBuffer<E>());\n+        try {\n+            buffer.remove(100);\n+            fail(\"Get should have timed out.\");\n+        } catch (BufferUnderflowException e) {\n+        }\n+    }\n+\n+    protected static class DelayedAdd<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        E obj;\n+\n+        long delay = 1000;\n+\n+        public DelayedAdd(Buffer<E> buffer, E obj, long delay) {\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.delay = delay;\n+        }\n+\n+        DelayedAdd(Buffer<E> buffer, E obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                // wait for other thread to block on get() or remove()\n+                Thread.sleep(delay);\n+            } catch (InterruptedException e) {\n+            }\n+            buffer.add(obj);\n+        }\n+    }\n+\n+    protected static class DelayedAddAll<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        E obj;\n+\n+        long delay = 100;\n+\n+        public DelayedAddAll(Buffer<E> buffer, E obj, long delay) {\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.delay = delay;\n+        }\n+\n+        DelayedAddAll(Buffer<E> buffer, E obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                // wait for other thread to block on get() or remove()\n+                Thread.sleep(delay);\n+            } catch (InterruptedException e) {\n+            }\n+            buffer.addAll(Collections.singleton(obj));\n+        }\n+    }\n+\n+    protected static class ReadThread<E> extends Thread {\n+\n+        Buffer<E> buffer;\n+\n+        Object obj;\n+\n+        ArrayList<String> exceptionList = null;\n+\n+        String action = \"get\";\n+\n+        Set<E> objs;\n+\n+        ReadThread(Buffer<E> buffer, Object obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+\n+        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.exceptionList = exceptionList;\n+        }\n+\n+        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList, String action) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.exceptionList = exceptionList;\n+            this.action = action;\n+        }\n+\n+        ReadThread(Buffer<E> buffer, Set<E> objs, String action) {\n+            super();\n+            this.buffer = buffer;\n+            this.objs = objs;\n+            this.action = action;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                if (action == \"get\") {\n+                    assertSame(obj, buffer.get());\n+                } else {\n+                    if (null != obj) {\n+                        assertSame(obj, buffer.remove());\n+                    } else {\n+                        assertTrue(objs.remove(buffer.remove()));\n+                    }\n+                }\n+            } catch (BufferUnderflowException ex) {\n+                exceptionList.add(\"BufferUnderFlow\");\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    protected static class MyBuffer<E> extends LinkedList<E> implements Buffer<E> {\n+\n+        public E get() {\n+            if (isEmpty()) {\n+                throw new BufferUnderflowException();\n+            }\n+            return get(0);\n+        }\n+\n+        @Override\n+        public E remove() {\n+            if (isEmpty()) {\n+                throw new BufferUnderflowException();\n+            }\n+            return remove(0);\n+        }\n+    }\n+\n+    private void delay() {\n+        try {\n+            Thread.sleep( 200 );\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    //    public void testCreate() throws Exception {\n+    //        Buffer buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n+    //        writeExternalFormToDisk((java.io.Serializable) buffer,\n+    //        \"D:/dev/collections/data/test/BlockingBuffer.emptyCollection.version3.1.obj\");\n+    //        buffer = BlockingBuffer.decorate(new UnboundedFifoBuffer());\n+    //        buffer.add(\"A\");\n+    //        buffer.add(\"B\");\n+    //        buffer.add(\"C\");\n+    //        writeExternalFormToDisk((java.io.Serializable) buffer,\n+    //        \"D:/dev/collections/data/test/BlockingBuffer.fullCollection.version3.1.obj\");\n+    //    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.BoundedCollection;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferOverflowException;\n+\n+import java.util.Iterator;\n+import java.util.Collections;\n+import java.util.Arrays;\n+\n+public class TestBoundedBuffer<E> extends AbstractTestObject {\n+\n+    public TestBoundedBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMaxSize() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n+        BoundedCollection<?> bc = (BoundedCollection<?>) bounded;\n+        assertEquals(2, bc.maxSize());\n+        assertEquals(false, bc.isFull());\n+        bounded.add((E) \"A\");\n+        assertEquals(false, bc.isFull());\n+        bounded.add((E) \"B\");\n+        assertEquals(true, bc.isFull());\n+        bounded.remove();\n+        assertEquals(false, bc.isFull());\n+        try {\n+            BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 0);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), -1);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddToFullBufferNoTimeout() {\n+        final Buffer<E> bounded = makeObject();\n+        bounded.add((E) \"Hello\");\n+        try {\n+            bounded.add((E) \"World\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToFullBufferNoTimeout() {\n+        final Buffer<E> bounded = makeObject();\n+        bounded.add((E) \"Hello\");\n+        try {\n+            bounded.addAll(Collections.singleton((E) \"World\"));\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToEmptyBufferExceedMaxSizeNoTimeout() {\n+        final Buffer<E> bounded = makeObject();\n+        try {\n+            bounded.addAll(Collections.nCopies(2, (E) \"test\"));\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddToFullBufferRemoveViaIterator() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1, 500);\n+        bounded.add((E) \"Hello\");\n+        new DelayedIteratorRemove(bounded, 200).start();\n+        bounded.add((E) \"World\");\n+        assertEquals(1, bounded.size());\n+        assertEquals(\"World\", bounded.get());\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToFullBufferRemoveViaIterator() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n+        bounded.add((E) \"Hello\");\n+        bounded.add((E) \"World\");\n+        new DelayedIteratorRemove(bounded, 200, 2).start();\n+        bounded.addAll(Arrays.asList((E[]) new String[] { \"Foo\", \"Bar\" }));\n+        assertEquals(2, bounded.size());\n+        assertEquals(\"Foo\", bounded.remove());\n+        assertEquals(\"Bar\", bounded.remove());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddToFullBufferWithTimeout() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 1, 500);\n+        bounded.add((E) \"Hello\");\n+        new DelayedRemove(bounded, 200).start();\n+        bounded.add((E) \"World\");\n+        assertEquals(1, bounded.size());\n+        assertEquals(\"World\", bounded.get());\n+        try {\n+            bounded.add((E) \"!\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToFullBufferWithTimeout() {\n+        final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n+        bounded.add((E) \"Hello\");\n+        bounded.add((E) \"World\");\n+        new DelayedRemove(bounded, 200, 2).start();\n+\n+        bounded.addAll(Arrays.asList((E[]) new String[] { \"Foo\", \"Bar\" }));\n+        assertEquals(2, bounded.size());\n+        assertEquals(\"Foo\", bounded.get());\n+        try {\n+            bounded.add((E) \"!\");\n+            fail();\n+        } catch (BufferOverflowException e) {\n+        }\n+    }\n+\n+    private class DelayedIteratorRemove extends Thread {\n+\n+        private final Buffer<?> buffer;\n+\n+        private final long delay;\n+\n+        private final int nToRemove;\n+\n+        public DelayedIteratorRemove(Buffer<?> buffer, long delay, int nToRemove) {\n+            this.buffer = buffer;\n+            this.delay = delay;\n+            this.nToRemove = nToRemove;\n+        }\n+\n+        public DelayedIteratorRemove(Buffer<?> buffer, long delay) {\n+            this(buffer, delay, 1);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Thread.sleep(delay);\n+                Iterator<?> iter = buffer.iterator();\n+                for (int i = 0; i < nToRemove; ++i) {\n+                    iter.next();\n+                    iter.remove();\n+                }\n+\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private class DelayedRemove extends Thread {\n+\n+        private final Buffer<?> buffer;\n+\n+        private final long delay;\n+\n+        private final int nToRemove;\n+\n+        public DelayedRemove(Buffer<?> buffer, long delay, int nToRemove) {\n+            this.buffer = buffer;\n+            this.delay = delay;\n+            this.nToRemove = nToRemove;\n+        }\n+\n+        public DelayedRemove(Buffer<?> buffer, long delay) {\n+            this(buffer, delay, 1);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Thread.sleep(delay);\n+                for (int i = 0; i < nToRemove; ++i) {\n+                    buffer.remove();\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestBoundedFifoBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Test cases for BoundedFifoBuffer.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ */\n+public class TestBoundedFifoBuffer<E> extends AbstractTestCollection<E> {\n+\n+    public TestBoundedFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBoundedFifoBuffer.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that\n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            E o1 = iterator1.next();\n+            E o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    @Override\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    @Override\n+    public List<E> makeConfirmedFullCollection() {\n+        List<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty BoundedFifoBuffer that won't overflow.\n+     *\n+     *  @return an empty BoundedFifoBuffer\n+     */\n+    @Override\n+    public BoundedFifoBuffer<E> makeObject() {\n+        return new BoundedFifoBuffer<E>(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testBoundedFifoBufferRemove() {\n+        resetFull();\n+        int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            E o1 = getCollection().remove();\n+            E o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            getCollection().remove();\n+            fail(\"Empty buffer should raise Underflow.\");\n+        } catch (BufferUnderflowException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new BoundedFifoBuffer<E>(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new BoundedFifoBuffer<E>(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new BoundedFifoBuffer<E>(null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    // BZ 33071 -- gets start=end=1 before removal of interior element\n+    @SuppressWarnings(\"unchecked\")\n+    public void testShift() {\n+        BoundedFifoBuffer<E> fifo = new BoundedFifoBuffer<E>(3);\n+        fifo.add((E) \"a\");\n+        fifo.add((E) \"b\");\n+        fifo.add((E) \"c\");\n+        fifo.remove();\n+        fifo.add((E) \"e\");\n+        fifo.remove(\"c\");\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/BoundedFifoBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/BoundedFifoBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public BoundedFifoBuffer<E> getCollection() {\n+        return (BoundedFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestBoundedFifoBuffer2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BufferOverflowException;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Runs tests against a full BoundedFifoBuffer, since many of the algorithms\n+ * differ depending on whether the fifo is full or not.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Unknown\n+ */\n+public class TestBoundedFifoBuffer2<E> extends TestBoundedFifoBuffer<E> {\n+\n+    public TestBoundedFifoBuffer2(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBoundedFifoBuffer2.class);\n+    }\n+\n+    /**\n+     *  Returns a BoundedFifoBuffer that's filled to capacity.\n+     *  Any attempt to add to the returned buffer will result in a \n+     *  BufferOverflowException.\n+     *\n+     *  @return a full BoundedFifoBuffer\n+     */\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        return new BoundedFifoBuffer<E>(Arrays.asList(getFullElements()));\n+    }\n+\n+    /**\n+     *  Overridden to skip the add tests.  All of them would fail with a \n+     *  BufferOverflowException.\n+     *\n+     *  @return false\n+     */\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     *  Overridden because the add operations raise BufferOverflowException\n+     *  instead of UnsupportedOperationException.\n+     */\n+    @Override\n+    public void testUnsupportedAdd() {\n+    }\n+\n+    /**\n+     *  Tests to make sure the add operations raise BufferOverflowException.\n+     */\n+    public void testBufferOverflow() {\n+        resetFull();\n+        try {\n+            getCollection().add(getOtherElements()[0]);\n+            fail(\"add should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getOtherElements()));\n+            fail(\"addAll should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     * Tests is full\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIsFull() {\n+        resetFull();\n+        assertEquals(true, getCollection().isFull());\n+        getCollection().remove();\n+        assertEquals(false, getCollection().isFull());\n+        getCollection().add((E) \"jj\");\n+        assertEquals(true, getCollection().isFull());\n+    }\n+\n+    /**\n+     * Tests max size\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMaxSize() {\n+        resetFull();\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+        getCollection().remove();\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+        getCollection().add((E) \"jj\");\n+        assertEquals(getFullElements().length, getCollection().maxSize());\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestCircularFifoBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Test cases for CircularFifoBuffer.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestCircularFifoBuffer<E> extends AbstractTestCollection<E> {\n+\n+    public TestCircularFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestCircularFifoBuffer.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that\n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty ArrayList.\n+     *\n+     * @return an empty ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     * Returns a full ArrayList.\n+     *\n+     * @return a full ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Returns an empty BoundedFifoBuffer that won't overflow.\n+     *\n+     * @return an empty BoundedFifoBuffer\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new CircularFifoBuffer<E>(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCircularFifoBufferCircular() {\n+        List<E> list = new ArrayList<E>();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        Buffer<E> buf = new CircularFifoBuffer<E>(list);\n+\n+        assertEquals(true, buf.contains(\"A\"));\n+        assertEquals(true, buf.contains(\"B\"));\n+        assertEquals(true, buf.contains(\"C\"));\n+\n+        buf.add((E) \"D\");\n+\n+        assertEquals(false, buf.contains(\"A\"));\n+        assertEquals(true, buf.contains(\"B\"));\n+        assertEquals(true, buf.contains(\"C\"));\n+        assertEquals(true, buf.contains(\"D\"));\n+\n+        assertEquals(\"B\", buf.get());\n+        assertEquals(\"B\", buf.remove());\n+        assertEquals(\"C\", buf.remove());\n+        assertEquals(\"D\", buf.remove());\n+    }\n+\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testCircularFifoBufferRemove() {\n+        resetFull();\n+        int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            Object o1 = getCollection().remove();\n+            Object o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            getCollection().remove();\n+            fail(\"Empty buffer should raise Underflow.\");\n+        } catch (BufferUnderflowException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new CircularFifoBuffer<E>(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new CircularFifoBuffer<E>(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new CircularFifoBuffer<E>(null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError1() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[1, 2, 5]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError2() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+        fifo.add((E) \"6\");\n+\n+        assertEquals(5, fifo.size());\n+        assertEquals(\"[2, 3, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[2, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError3() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.add((E) \"6\");\n+        fifo.add((E) \"7\");\n+        assertEquals(\"[2, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError4() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");  // remove element in middle of array, after start\n+        assertEquals(\"[3, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError5() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"5\");  // remove element at last pos in array\n+        assertEquals(\"[3, 4, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError6() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"6\");  // remove element at position zero in array\n+        assertEquals(\"[3, 4, 5, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError7() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array\n+        assertEquals(\"[3, 4, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError8() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array, need to shift 8\n+        assertEquals(\"[4, 5, 6, 8]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError9() throws Exception {\n+        // based on bug 33071\n+        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"8\");  // remove element at position two in array\n+        assertEquals(\"[4, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRepeatedSerialization() throws Exception {\n+        // bug 31433\n+        CircularFifoBuffer<E> b = new CircularFifoBuffer<E>(2);\n+        b.add((E) \"a\");\n+        assertEquals(1, b.size());\n+        assertEquals(true, b.contains(\"a\"));\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b);\n+\n+        CircularFifoBuffer<E> b2 = (CircularFifoBuffer<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(1, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        b2.add((E) \"b\");\n+        assertEquals(2, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        assertEquals(true, b2.contains(\"b\"));\n+\n+        bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b2);\n+\n+        CircularFifoBuffer<E> b3 = (CircularFifoBuffer<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"a\"));\n+        assertEquals(true, b3.contains(\"b\"));\n+        b3.add((E) \"c\");\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"b\"));\n+        assertEquals(true, b3.contains(\"c\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/CircularFifoBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/CircularFifoBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CircularFifoBuffer<E> getCollection() {\n+        return (CircularFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestPredicatedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.collection.TestPredicatedCollection;\n+\n+/**\n+ * Extension of {@link TestPredicatedCollection} for exercising the\n+ * {@link PredicatedBuffer} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedBuffer<E> extends TestPredicatedCollection<E> {\n+\n+    public TestPredicatedBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    //---------------------------------------------------------------\n+\n+    protected Buffer<E> decorateCollection(Buffer<E> buffer, Predicate<E> predicate) {\n+        return PredicatedBuffer.predicatedBuffer(buffer, predicate);\n+    }\n+\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return decorateCollection(new ArrayStack<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n+        list.addAll(java.util.Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //------------------------------------------------------------\n+\n+    public Buffer<E> makeTestBuffer() {\n+        return decorateCollection(new ArrayStack<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGet() {\n+        Buffer<E> buffer = makeTestBuffer();\n+        try {\n+            buffer.get();\n+            fail(\"Expecting BufferUnderflowException\");\n+        } catch (BufferUnderflowException ex) {\n+            // expected\n+        }\n+        buffer.add((E) \"one\");\n+        buffer.add((E) \"two\");\n+        buffer.add((E) \"three\");\n+        assertEquals(\"Buffer get\", \"three\", buffer.get());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        Buffer<E> buffer = makeTestBuffer();\n+        buffer.add((E) \"one\");\n+        assertEquals(\"Buffer get\", \"one\", buffer.remove());\n+        try {\n+            buffer.remove();\n+            fail(\"Expecting BufferUnderflowException\");\n+        } catch (BufferUnderflowException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestPriorityBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Random;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.ComparatorUtils;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+\n+/**\n+ * Tests the PriorityBuffer.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Michael A. Smith\n+ * @author Steve Phelps\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestPriorityBuffer<E> extends AbstractTestCollection<E> {\n+\n+    public TestPriorityBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void verify() {\n+        super.verify();\n+        PriorityBuffer<E> heap = getCollection();\n+\n+        Comparator<? super E> c = heap.comparator;\n+        if (c == null) {\n+            c = ComparatorUtils.NATURAL_COMPARATOR;\n+        }\n+        if (!heap.ascendingOrder) {\n+            c = ComparatorUtils.reversedComparator(c);\n+        }\n+\n+        E[] tree = heap.elements;\n+        for (int i = 1; i <= heap.size; i++) {\n+            E parent = tree[i];\n+            if (i * 2 <= heap.size) {\n+                assertTrue(\"Parent is less than or equal to its left child\", c.compare(parent, tree[i * 2]) <= 0);\n+            }\n+            if (i * 2 + 1 < heap.size) {\n+                assertTrue(\"Parent is less than or equal to its right child\", c.compare(parent, tree[i * 2 + 1]) <= 0);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because BinaryBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     * Return a new, empty {@link Object} to used for testing.\n+     */\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return new PriorityBuffer<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) getFullNonNullStringElements();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherElements() {\n+        return (E[]) getOtherNonNullStringElements();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBufferEmpty() {\n+        resetEmpty();\n+        Buffer<E> buffer = getCollection();\n+\n+        assertEquals(0, buffer.size());\n+        assertEquals(true, buffer.isEmpty());\n+        try {\n+            buffer.get();\n+            fail();\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            buffer.remove();\n+            fail();\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasicOps() {\n+        PriorityBuffer<E> heap = new PriorityBuffer<E>();\n+        heap.add((E) \"a\");\n+        heap.add((E) \"c\");\n+        heap.add((E) \"e\");\n+        heap.add((E) \"b\");\n+        heap.add((E) \"d\");\n+        heap.add((E) \"n\");\n+        heap.add((E) \"m\");\n+        heap.add((E) \"l\");\n+        heap.add((E) \"k\");\n+        heap.add((E) \"j\");\n+        heap.add((E) \"i\");\n+        heap.add((E) \"h\");\n+        heap.add((E) \"g\");\n+        heap.add((E) \"f\");\n+\n+        assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+            assertEquals(\n+                \"get using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.get());\n+\n+            assertEquals(\n+                \"remove using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.remove());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are removed\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are removed\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasicComparatorOps() {\n+        PriorityBuffer<E> heap = new PriorityBuffer<E>(new ReverseComparator<E>((Comparator<E>) ComparableComparator.INSTANCE));\n+\n+        assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called before any elements are added\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called before any elements are added\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        heap.add((E) \"a\");\n+        heap.add((E) \"c\");\n+        heap.add((E) \"e\");\n+        heap.add((E) \"b\");\n+        heap.add((E) \"d\");\n+        heap.add((E) \"n\");\n+        heap.add((E) \"m\");\n+        heap.add((E) \"l\");\n+        heap.add((E) \"k\");\n+        heap.add((E) \"j\");\n+        heap.add((E) \"i\");\n+        heap.add((E) \"h\");\n+        heap.add((E) \"g\");\n+        heap.add((E) \"f\");\n+\n+        assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+\n+            // note: since we're using a comparator that reverses items, the\n+            // \"minimum\" item is \"n\", and the \"maximum\" item is \"a\".\n+\n+            assertEquals(\n+                \"get using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.get());\n+\n+            assertEquals(\n+                \"remove using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.remove());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are removed\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are removed\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    /**\n+     * Illustrates bad internal heap state reported in Bugzilla PR #235818.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddRemove() {\n+        resetEmpty();\n+        PriorityBuffer heap = getCollection();\n+        heap.add(0);\n+        heap.add(2);\n+        heap.add(4);\n+        heap.add(3);\n+        heap.add(8);\n+        heap.add(10);\n+        heap.add(12);\n+        heap.add(3);\n+        getConfirmed().addAll(heap);\n+        // System.out.println(heap);\n+        heap.remove(10);\n+        getConfirmed().remove(10);\n+        // System.out.println(heap);\n+        verify();\n+    }\n+\n+    /**\n+     * Generate heaps staring with Integers from 0 - heapSize - 1.\n+     * Then perform random add / remove operations, checking\n+     * heap order after modifications. Alternates minHeaps, maxHeaps.\n+     *\n+     * Based on code provided by Steve Phelps in PR #25818\n+     *\n+     */\n+    public void testRandom() {\n+        int iterations = 500;\n+        int heapSize = 100;\n+        int operations = 20;\n+        Random randGenerator = new Random();\n+        PriorityBuffer<Integer> h = null;\n+        for (int i = 0; i < iterations; i++) {\n+            if (i < iterations / 2) {\n+                h = new PriorityBuffer<Integer>(true);\n+            } else {\n+                h = new PriorityBuffer<Integer>(false);\n+            }\n+            for (int r = 0; r < heapSize; r++) {\n+                h.add(randGenerator.nextInt(heapSize));\n+            }\n+            for (int r = 0; r < operations; r++) {\n+                h.remove(new Integer(r));\n+                h.add(randGenerator.nextInt(heapSize));\n+            }\n+            checkOrder(h);\n+        }\n+    }\n+\n+    /**\n+     * Pops all elements from the heap and verifies that the elements come off\n+     * in the correct order.  NOTE: this method empties the heap.\n+     */\n+    protected void checkOrder(PriorityBuffer<?> h) {\n+        Integer lastNum = null;\n+        Integer num = null;\n+        while (!h.isEmpty()) {\n+            num = (Integer) h.remove();\n+            if (h.ascendingOrder) {\n+                assertTrue(lastNum == null || num.intValue() >= lastNum.intValue());\n+            } else { // max heap\n+                assertTrue(lastNum == null || num.intValue() <= lastNum.intValue());\n+            }\n+            lastNum = num;\n+            num = null;\n+        }\n+    }\n+\n+    /**\n+     * Returns a string showing the contents of the heap formatted as a tree.\n+     * Makes no attempt at padding levels or handling wrapping.\n+     */\n+    protected String showTree(PriorityBuffer<?> h) {\n+        int count = 1;\n+        StringBuilder buffer = new StringBuilder();\n+        for (int offset = 1; count < h.size() + 1; offset *= 2) {\n+            for (int i = offset; i < offset * 2; i++) {\n+                if (i < h.elements.length && h.elements[i] != null)\n+                    buffer.append(h.elements[i] + \" \");\n+                count++;\n+            }\n+            buffer.append('\\n');\n+        }\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * Generates 500 randomly initialized heaps of size 100\n+     * and tests that after serializing and restoring them to a byte array\n+     * that the following conditions hold:\n+     *\n+     *  - the size of the restored heap is the same\n+     *      as the size of the orignal heap\n+     *\n+     *  - all elements in the original heap are present in the restored heap\n+     *\n+     *  - the heap order of the restored heap is intact as\n+     *      verified by checkOrder()\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() {\n+        int iterations = 500;\n+        int heapSize = 100;\n+        PriorityBuffer h;\n+        Random randGenerator = new Random();\n+        for (int i = 0; i < iterations; i++) {\n+            if (i < iterations / 2) {\n+                h = new PriorityBuffer<E>(true);\n+            } else {\n+                h = new PriorityBuffer<E>(false);\n+            }\n+            for (int r = 0; r < heapSize; r++) {\n+                h.add(new Integer(randGenerator.nextInt(heapSize)));\n+            }\n+            assertTrue(h.size() == heapSize);\n+            PriorityBuffer<?> h1 = serializeAndRestore(h);\n+            assertTrue(h1.size() == heapSize);\n+            Iterator<?> hit = h.iterator();\n+            while (hit.hasNext()) {\n+                Integer n = (Integer) hit.next();\n+                assertTrue(h1.contains(n));\n+            }\n+            checkOrder(h1);\n+        }\n+    }\n+\n+    public PriorityBuffer<?> serializeAndRestore(PriorityBuffer<E> h) {\n+        PriorityBuffer<?> h1 = null;\n+        try {\n+            byte[] objekt = writeExternalFormToBytes(h);\n+            h1 = (PriorityBuffer<?>) readExternalFormFromBytes(objekt);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            fail(e.toString());\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+            fail(e.toString());\n+        }\n+        return h1;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/PriorityBuffer.emptyCollection.version3.2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/PriorityBuffer.fullCollection.version3.2.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public PriorityBuffer<E> getCollection() {\n+        return (PriorityBuffer<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestSynchronizedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the\n+ * {@link SynchronizedBuffer} implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class TestSynchronizedBuffer<E> extends AbstractTestCollection<E> {\n+\n+    public TestSynchronizedBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Buffer<E> makeObject() {\n+        return SynchronizedBuffer.synchronizedBuffer(new UnboundedFifoBuffer<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n+        buffer.addAll(Arrays.asList(getFullElements()));\n+        return SynchronizedBuffer.synchronizedBuffer(buffer);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestTransformedBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link TestCase} for exercising the {@link TransformedBuffer}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedBuffer extends TestCase {\n+    \n+    public TestTransformedBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testTransformedBuffer() {\n+        Buffer<Object> buffer = TransformedBuffer.transformingBuffer(new ArrayStack<Object>(), TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, buffer.size());\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            buffer.add(els[i]);\n+            assertEquals(i + 1, buffer.size());\n+            assertEquals(true, buffer.contains(new Integer((String) els[i])));\n+            assertEquals(false, buffer.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, buffer.remove(els[0]));\n+        assertEquals(true, buffer.remove(new Integer((String) els[0])));\n+        \n+    }\n+\n+    public void testTransformedBuffer_decorateTransform() {\n+        Buffer originalBuffer = new ArrayStack();\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            originalBuffer.add(els[i]);\n+        }\n+        Buffer buffer = TransformedBuffer.transformedBuffer(originalBuffer, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, buffer.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, buffer.contains(new Integer((String) els[i])));\n+            assertEquals(false, buffer.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, buffer.remove(els[0]));\n+        assertEquals(true, buffer.remove(new Integer((String) els[0])));\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Test cases for UnboundedFifoBuffer.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Unknown\n+ */\n+public class TestUnboundedFifoBuffer<E> extends AbstractTestCollection<E> {\n+\n+    public TestUnboundedFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnboundedFifoBuffer.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that the ArrayList has the same elements in the same \n+     *  sequence as the UnboundedFifoBuffer.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        Iterator<E> iterator1 = getCollection().iterator();\n+        Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty UnboundedFifoBuffer with a small capacity.\n+     *\n+     *  @return an empty UnboundedFifoBuffer\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new UnboundedFifoBuffer<E>(5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests that UnboundedFifoBuffer removes elements in the right order.\n+     */\n+    public void testUnboundedFifoBufferRemove() {\n+        resetFull();\n+        int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            E o1 = getCollection().remove();\n+            E o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new UnboundedFifoBuffer<E>(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new UnboundedFifoBuffer<E>(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateAdd() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(2);\n+        assertEquals(3, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"A\");\n+        assertEquals(3, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(1, test.tail);\n+        test.add((E) \"B\");\n+        assertEquals(3, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        test.add((E) \"C\");  // forces buffer increase\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(4, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateAddWithWrap() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"A\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(1, test.tail);\n+        test.add((E) \"B\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        test.add((E) \"C\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        test.remove(\"A\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+        test.remove(\"B\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(3, test.tail);\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateRemove1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.remove(\"A\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(4, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateRemove2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.remove(\"B\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemove1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        it.next();\n+        it.remove();\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(4, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemove2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        \n+        Iterator<E> it = test.iterator();\n+        it.next();\n+        it.next();\n+        it.remove();\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(2, test.tail);\n+        \n+        test.add((E) \"D\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithTailAtEnd1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"B\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithTailAtEnd2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"B\", it.next());\n+        assertEquals(\"C\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithTailAtEnd3() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"B\", it.next());\n+        assertEquals(\"C\", it.next());\n+        assertEquals(\"D\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(3, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithWrap1() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.remove(\"B\");\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"C\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(3, test.head);\n+        assertEquals(1, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithWrap2() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.remove(\"B\");\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"C\", it.next());\n+        assertEquals(\"D\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalStateIteratorRemoveWithWrap3() {\n+        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.remove(\"B\");\n+        test.add((E) \"D\");\n+        test.add((E) \"E\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(1, test.tail);\n+        \n+        Iterator<E> it = test.iterator();\n+        assertEquals(\"C\", it.next());\n+        assertEquals(\"D\", it.next());\n+        assertEquals(\"E\", it.next());\n+        it.remove();\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(2, test.head);\n+        assertEquals(0, test.tail);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testCollections220() throws Exception {\n+         UnboundedFifoBuffer<String> buffer = new UnboundedFifoBuffer<String>();\n+         \n+         buffer = (UnboundedFifoBuffer<String>) serializeDeserialize(buffer);\n+\n+         // test size() gets incremented\n+         buffer.add(\"Foo\");\n+         assertEquals(1, buffer.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnboundedFifoBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnboundedFifoBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public UnboundedFifoBuffer<E> getCollection() {\n+        return (UnboundedFifoBuffer<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/buffer/TestUnmodifiableBuffer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the\n+ * {@link UnmodifiableBuffer} implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableBuffer<E> extends AbstractTestCollection<E> {\n+\n+    public TestUnmodifiableBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return UnmodifiableBuffer.unmodifiableBuffer(new UnboundedFifoBuffer<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n+        buffer.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableBuffer.unmodifiableBuffer(buffer);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayStack<E> list = new ArrayStack<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    public void testBufferRemove() {\n+        resetEmpty();\n+        try {\n+            getCollection().remove();\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableBuffer.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableBuffer.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Buffer<E> getCollection() {\n+        return (Buffer<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/AbstractTestCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+\n+/**\n+ * Abstract test class for {@link java.util.Collection} methods and contracts.\n+ * <p>\n+ * You should create a concrete subclass of this class to test any custom\n+ * {@link Collection} implementation.  At minimum, you'll have to\n+ * implement the {@link #makeCollection()} method.  You might want to\n+ * override some of the additional public methods as well:\n+ * <p>\n+ * <b>Element Population Methods</b>\n+ * <p>\n+ * Override these if your collection restricts what kind of elements are\n+ * allowed (for instance, if <code>null</code> is not permitted):\n+ * <ul>\n+ * <li>{@link #getFullElements()}\n+ * <li>{@link #getOtherElements()}\n+ * </ul>\n+ * <p>\n+ * <b>Supported Operation Methods</b>\n+ * <p>\n+ * Override these if your collection doesn't support certain operations:\n+ * <ul>\n+ * <li>{@link #isAddSupported()}\n+ * <li>{@link #isRemoveSupported()}\n+ * <li>{@link #areEqualElementsDistinguishable()}\n+ * <li>{@link #isNullSupported()}\n+ * <li>{@link #isFailFastSupported()}\n+ * </ul>\n+ * <p>\n+ * <b>Fixture Methods</b>\n+ * <p>\n+ * Fixtures are used to verify that the the operation results in correct state\n+ * for the collection.  Basically, the operation is performed against your\n+ * collection implementation, and an identical operation is performed against a\n+ * <i>confirmed</i> collection implementation.  A confirmed collection\n+ * implementation is something like <code>java.util.ArrayList</code>, which is\n+ * known to conform exactly to its collection interface's contract.  After the\n+ * operation takes place on both your collection implementation and the\n+ * confirmed collection implementation, the two collections are compared to see\n+ * if their state is identical.  The comparison is usually much more involved\n+ * than a simple <code>equals</code> test.  This verification is used to ensure\n+ * proper modifications are made along with ensuring that the collection does\n+ * not change when read-only modifications are made.\n+ * <p>\n+ * The {@link #collection} field holds an instance of your collection\n+ * implementation; the {@link #confirmed} field holds an instance of the\n+ * confirmed collection implementation.  The {@link #resetEmpty()} and\n+ * {@link #resetFull()} methods set these fields to empty or full collections,\n+ * so that tests can proceed from a known state.\n+ * <p>\n+ * After a modification operation to both {@link #collection} and\n+ * {@link #confirmed}, the {@link #verify()} method is invoked to compare\n+ * the results.  You may want to override {@link #verify()} to perform\n+ * additional verifications.  For instance, when testing the collection\n+ * views of a map, {@link org.apache.commons.collections.map.AbstractTestMap AbstractTestMap} \n+ * would override {@link #verify()} to make\n+ * sure the map is changed after the collection view is changed.\n+ * <p>\n+ * If you're extending this class directly, you will have to provide\n+ * implementations for the following:\n+ * <ul>\n+ * <li>{@link #makeConfirmedCollection()}\n+ * <li>{@link #makeConfirmedFullCollection()}\n+ * </ul>\n+ * <p>\n+ * Those methods should provide a confirmed collection implementation\n+ * that's compatible with your collection implementation.\n+ * <p>\n+ * If you're extending {@link org.apache.commons.collections.list.AbstractTestList AbstractTestList},\n+ * {@link org.apache.commons.collections.set.AbstractTestSet AbstractTestSet},\n+ * or {@link org.apache.commons.collections.bag.AbstractTestBag AbstractTestBag}, \n+ * you probably don't have to worry about the\n+ * above methods, because those three classes already override the methods\n+ * to provide standard JDK confirmed collections.<P>\n+ * <p>\n+ * <b>Other notes</b>\n+ * <p>\n+ * If your {@link Collection} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link Collection} fails.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Paul Jack\n+ * @author Michael A. Smith\n+ * @author Neil O'Toole\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestCollection<E> extends AbstractTestObject {\n+\n+    //\n+    // NOTE:\n+    //\n+    // Collection doesn't define any semantics for equals, and recommends you\n+    // use reference-based default behavior of Object.equals.  (And a test for\n+    // that already exists in AbstractTestObject).  Tests for equality of lists, sets\n+    // and bags will have to be written in test subclasses.  Thus, there is no\n+    // tests on Collection.equals nor any for Collection.hashCode.\n+    //\n+\n+    // These fields are used by reset() and verify(), and any test\n+    // method that tests a modification.\n+\n+    /**\n+     *  A collection instance that will be used for testing.\n+     */\n+    private Collection<E> collection;\n+\n+    /**\n+     *  Confirmed collection.  This is an instance of a collection that is\n+     *  confirmed to conform exactly to the java.util.Collection contract.\n+     *  Modification operations are tested by performing a mod on your\n+     *  collection, performing the exact same mod on an equivalent confirmed\n+     *  collection, and then calling verify() to make sure your collection\n+     *  still matches the confirmed collection.\n+     */\n+    private Collection<E> confirmed;\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractTestCollection(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Specifies whether equal elements in the collection are, in fact,\n+     *  distinguishable with information not readily available.  That is, if a\n+     *  particular value is to be removed from the collection, then there is\n+     *  one and only one value that can be removed, even if there are other\n+     *  elements which are equal to it.\n+     *\n+     *  <P>In most collection cases, elements are not distinguishable (equal is\n+     *  equal), thus this method defaults to return false.  In some cases,\n+     *  however, they are.  For example, the collection returned from the map's\n+     *  values() collection view are backed by the map, so while there may be\n+     *  two values that are equal, their associated keys are not.  Since the\n+     *  keys are distinguishable, the values are.\n+     *\n+     *  <P>This flag is used to skip some verifications for iterator.remove()\n+     *  where it is impossible to perform an equivalent modification on the\n+     *  confirmed collection because it is not possible to determine which\n+     *  value in the confirmed collection to actually remove.  Tests that\n+     *  override the default (i.e. where equal elements are distinguishable),\n+     *  should provide additional tests on iterator.remove() to make sure the\n+     *  proper elements are removed when remove() is called on the iterator.\n+     **/\n+    public boolean areEqualElementsDistinguishable() {\n+        return false;\n+    }\n+\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>add</code> and <code>addAll</code>\n+     *  operations.<P>\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support add or addAll.\n+     */\n+    public boolean isAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>remove</code>, <code>removeAll</code>,\n+     *  <code>retainAll</code>, <code>clear</code> and\n+     *  <code>iterator().remove()</code> methods.\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support removal operations.\n+     */\n+    public boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports holding null.\n+     * The default implementation returns true;\n+     */\n+    public boolean isNullSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports fail fast iterators.\n+     * The default implementation returns true;\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports equals() comparisons.\n+     * This implementation returns false;\n+     */\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that {@link #collection} and {@link #confirmed} have\n+     *  identical state.\n+     */\n+    public void verify() {\n+        int confirmedSize = getConfirmed().size();\n+        assertEquals(\"Collection size should match confirmed collection's\", confirmedSize,\n+                getCollection().size());\n+        assertEquals(\"Collection isEmpty() result should match confirmed collection's\",\n+                getConfirmed().isEmpty(), getCollection().isEmpty());\n+\n+        // verify the collections are the same by attempting to match each\n+        // object in the collection and confirmed collection.  To account for\n+        // duplicates and differing orders, each confirmed element is copied\n+        // into an array and a flag is maintained for each element to determine\n+        // whether it has been matched once and only once.  If all elements in\n+        // the confirmed collection are matched once and only once and there\n+        // aren't any elements left to be matched in the collection,\n+        // verification is a success.\n+\n+        // copy each collection value into an array\n+        Object[] confirmedValues = new Object[confirmedSize];\n+\n+        Iterator<E> iter;\n+\n+        iter = getConfirmed().iterator();\n+        int pos = 0;\n+        while (iter.hasNext()) {\n+            confirmedValues[pos++] = iter.next();\n+        }\n+\n+        // allocate an array of boolean flags for tracking values that have\n+        // been matched once and only once.\n+        boolean[] matched = new boolean[confirmedSize];\n+\n+        // now iterate through the values of the collection and try to match\n+        // the value with one in the confirmed array.\n+        iter = getCollection().iterator();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            boolean match = false;\n+            for (int i = 0; i < confirmedSize; i++) {\n+                if (matched[i]) {\n+                    // skip values already matched\n+                    continue;\n+                }\n+                if (o == confirmedValues[i] || (o != null && o.equals(confirmedValues[i]))) {\n+                    // values matched\n+                    matched[i] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            // no match found!\n+            if (!match) {\n+                fail(\"Collection should not contain a value that the \"\n+                        + \"confirmed collection does not have: \" + o + \"\\nTest: \" + getCollection()\n+                        + \"\\nReal: \" + getConfirmed());\n+            }\n+        }\n+\n+        // make sure there aren't any unmatched values\n+        for (int i = 0; i < confirmedSize; i++) {\n+            if (!matched[i]) {\n+                // the collection didn't match all the confirmed values\n+                fail(\"Collection should contain all values that are in the confirmed collection\"\n+                        + \"\\nTest: \" + getCollection() + \"\\nReal: \" + getConfirmed());\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    public void resetEmpty() {\n+        this.setCollection(makeObject());\n+        this.setConfirmed(makeConfirmedCollection());\n+    }\n+\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to full\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    public void resetFull() {\n+        this.setCollection(makeFullCollection());\n+        this.setConfirmed(makeConfirmedFullCollection());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a confirmed empty collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.\n+     *\n+     *  @return a confirmed empty collection\n+     */\n+    public abstract Collection<E> makeConfirmedCollection();\n+\n+    /**\n+     *  Returns a confirmed full collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.  The returned collection\n+     *  should contain the elements returned by {@link #getFullElements()}.\n+     *\n+     *  @return a confirmed full collection\n+     */\n+    public abstract Collection<E> makeConfirmedFullCollection();\n+\n+    /**\n+     * Return a new, empty {@link Collection} to be used for testing.\n+     */\n+    @Override\n+    public abstract Collection<E> makeObject();\n+\n+    /**\n+     *  Returns a full collection to be used for testing.  The collection\n+     *  returned by this method should contain every element returned by\n+     *  {@link #getFullElements()}.  The default implementation, in fact,\n+     *  simply invokes <code>addAll</code> on an empty collection with\n+     *  the results of {@link #getFullElements()}.  Override this default\n+     *  if your collection doesn't support addAll.\n+     */\n+    public Collection<E> makeFullCollection() {\n+        Collection<E> c = makeObject();\n+        c.addAll(Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Creates a new Map Entry that is independent of the first and the map.\n+     */\n+    public Map.Entry<E, E> cloneMapEntry(Map.Entry<E, E> entry) {\n+        HashMap<E, E> map = new HashMap<E, E>();\n+        map.put(entry.getKey(), entry.getValue());\n+        return map.entrySet().iterator().next();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an array of objects that are contained in a collection\n+     *  produced by {@link #makeFullCollection()}.  Every element in the\n+     *  returned array <I>must</I> be an element in a full collection.<P>\n+     *  The default implementation returns a heterogenous array of\n+     *  objects with some duplicates. null is added if allowed.\n+     *  Override if you require specific testing elements.  Note that if you\n+     *  override {@link #makeFullCollection()}, you <I>must</I> override\n+     *  this method to reflect the contents of a full collection.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        if (isNullSupported()) {\n+            ArrayList<E> list = new ArrayList<E>();\n+            list.addAll(Arrays.asList(getFullNonNullElements()));\n+            list.add(4, null);\n+            return (E[]) list.toArray();\n+        }\n+        return getFullNonNullElements().clone();\n+    }\n+\n+    /**\n+     *  Returns an array of elements that are <I>not</I> contained in a\n+     *  full collection.  Every element in the returned array must\n+     *  not exist in a collection returned by {@link #makeFullCollection()}.\n+     *  The default implementation returns a heterogenous array of elements\n+     *  without null.  Note that some of the tests add these elements\n+     *  to an empty or full collection, so if your collection restricts\n+     *  certain kinds of elements, you should override this method.\n+     */\n+    public E[] getOtherElements() {\n+        return getOtherNonNullElements();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a list of elements suitable for return by\n+     *  {@link #getFullElements()}.  The array returned by this method\n+     *  does not include null, but does include a variety of objects\n+     *  of different types.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  the null element.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        return (E[]) new Object[] {\n+            new String(\"\"),\n+            new String(\"One\"),\n+            new Integer(2),\n+            \"Three\",\n+            new Integer(4),\n+            \"One\",\n+            new Double(5),\n+            new Float(6),\n+            \"Seven\",\n+            \"Eight\",\n+            new String(\"Nine\"),\n+            new Integer(10),\n+            new Short((short)11),\n+            new Long(12),\n+            \"Thirteen\",\n+            \"14\",\n+            \"15\",\n+            new Byte((byte)16)\n+        };\n+    }\n+\n+    /**\n+     *  Returns the default list of objects returned by\n+     *  {@link #getOtherElements()}.  Includes many objects\n+     *  of different types.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n+        return (E[]) new Object[] {\n+            new Integer(0),\n+            new Float(0),\n+            new Double(0),\n+            \"Zero\",\n+            new Short((short)0),\n+            new Byte((byte)0),\n+            new Long(0),\n+            new Character('\\u0000'),\n+            \"0\"\n+        };\n+    }\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link #getFullElements()}.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public Object[] getFullNonNullStringElements() {\n+        return new Object[] {\n+            \"If\", \"the\", \"dull\", \"substance\", \"of\", \"my\", \"flesh\", \"were\",\n+                \"thought\", \"Injurious\", \"distance\", \"could\", \"not\", \"stop\", \"my\", \"way\",\n+        };\n+    }\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link #getOtherElements()}.  Override getOtherElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\", \"then\", \"despite\",/* of */\"space\", \"I\", \"would\", \"be\",\n+                \"brought\", \"From\", \"limits\", \"far\", \"remote\", \"where\", \"thou\", \"dost\", \"stay\"\n+        };\n+    }\n+\n+    // Tests\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link Collection#add(Object)}.\n+     */\n+    public void testCollectionAdd() {\n+        if (!isAddSupported()) return;\n+\n+        E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            resetEmpty();\n+            boolean r = getCollection().add(elements[i]);\n+            getConfirmed().add(elements[i]);\n+            verify();\n+            assertTrue(\"Empty collection changed after add\", r);\n+            assertEquals(\"Collection size is 1 after first add\", 1, getCollection().size());\n+        }\n+\n+        resetEmpty();\n+        int size = 0;\n+        for (int i = 0; i < elements.length; i++) {\n+            boolean r = getCollection().add(elements[i]);\n+            getConfirmed().add(elements[i]);\n+            verify();\n+            if (r) size++;\n+            assertEquals(\"Collection size should grow after add\", size, getCollection().size());\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(elements[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#addAll(Collection)}.\n+     */\n+    public void testCollectionAddAll() {\n+        if (!isAddSupported()) return;\n+\n+        resetEmpty();\n+        E[] elements = getFullElements();\n+        boolean r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Empty collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(elements[i]));\n+        }\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        elements = getOtherElements();\n+        r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Full collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain added element\",\n+                    getCollection().contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\", size + elements.length, getCollection().size());\n+\n+        resetFull();\n+        size = getCollection().size();\n+        r = getCollection().addAll(Arrays.asList(getFullElements()));\n+        getConfirmed().addAll(Arrays.asList(getFullElements()));\n+        verify();\n+        if (r) {\n+            assertTrue(\"Size should increase if addAll returns true\", size < getCollection().size());\n+        } else {\n+            assertEquals(\"Size should not change if addAll returns false\", size, getCollection().size());\n+        }\n+    }\n+\n+    /**\n+     *  If {@link #isAddSupported()} returns false, tests that add operations\n+     *  raise <code>UnsupportedOperationException.\n+     */\n+    public void testUnsupportedAdd() {\n+        if (isAddSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().add(getFullNonNullElements()[0]);\n+            fail(\"Empty collection should not support add.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getFullElements()));\n+            fail(\"Empty collection should not support addAll.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        resetFull();\n+        try {\n+            getCollection().add(getFullNonNullElements()[0]);\n+            fail(\"Full collection should not support add.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getOtherElements()));\n+            fail(\"Full collection should not support addAll.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+    }\n+\n+    /**\n+     *  Test {@link Collection#clear()}.\n+     */\n+    public void testCollectionClear() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        getCollection().clear(); // just to make sure it doesn't raise anything\n+        verify();\n+\n+        resetFull();\n+        getCollection().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#contains(Object)}.\n+     */\n+    public void testCollectionContains() {\n+        Object[] elements;\n+\n+        resetEmpty();\n+        elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        elements = getOtherElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain element[\" + i + \"]\",\n+                    getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getOtherElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection shouldn't contain element\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#containsAll(Collection)}.\n+     */\n+    public void testCollectionContainsAll() {\n+        resetEmpty();\n+        Collection<E> col = new HashSet<E>();\n+        assertTrue(\"Every Collection should contain all elements of an \" +\n+                \"empty Collection.\", getCollection().containsAll(col));\n+        col.addAll(Arrays.asList(getOtherElements()));\n+        assertTrue(\"Empty Collection shouldn't contain all elements of \" +\n+                \"a non-empty Collection.\", !getCollection().containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection shouldn't contain other elements\",\n+                !getCollection().containsAll(col));\n+\n+        col.clear();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll full elements\",\n+                getCollection().containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        int min = (getFullElements().length < 2 ? 0 : 2);\n+        int max = (getFullElements().length == 1 ? 1 :\n+                (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n+        col = Arrays.asList(getFullElements()).subList(min, max);\n+        assertTrue(\"Full collection should containAll partial full elements\",\n+                getCollection().containsAll(col));\n+        assertTrue(\"Full collection should containAll itself\", getCollection().containsAll(getCollection()));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        col = new ArrayList<E>();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll duplicate full elements\",\n+                getCollection().containsAll(col));\n+\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#isEmpty()}.\n+     */\n+    public void testCollectionIsEmpty() {\n+        resetEmpty();\n+        assertEquals(\"New Collection should be empty.\", true, getCollection().isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Full collection shouldn't be empty\", false, getCollection().isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests the read-only functionality of {@link Collection#iterator()}.\n+     */\n+    public void testCollectionIterator() {\n+        resetEmpty();\n+        Iterator<E> it1 = getCollection().iterator();\n+        assertEquals(\"Iterator for empty Collection shouldn't have next.\", false, it1.hasNext());\n+        try {\n+            it1.next();\n+            fail(\"Iterator at end of Collection should throw \"\n+                    + \"NoSuchElementException when next is called.\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+        // make sure nothing has changed after non-modification\n+        verify();\n+\n+        resetFull();\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            assertTrue(\"Iterator for full collection should haveNext\", it1.hasNext());\n+            it1.next();\n+        }\n+        assertTrue(\"Iterator should be finished\", !it1.hasNext());\n+\n+        ArrayList<E> list = new ArrayList<E>();\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            E next = it1.next();\n+            assertTrue(\"Collection should contain element returned by its iterator\",\n+                    getCollection().contains(next));\n+            list.add(next);\n+        }\n+        try {\n+            it1.next();\n+            fail(\"iterator.next() should raise NoSuchElementException after it finishes\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+        // make sure nothing has changed after non-modification\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests removals from {@link Collection#iterator()}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCollectionIteratorRemove() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().iterator().remove();\n+            fail(\"New iterator.remove should raise IllegalState\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            iter.hasNext();\n+            iter.remove();\n+            fail(\"New iterator.remove should raise IllegalState even after hasNext\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        Iterator<E> iter = getCollection().iterator();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            // TreeMap reuses the Map Entry, so the verify below fails\n+            // Clone it here if necessary\n+            if (o instanceof Map.Entry) {\n+                o = cloneMapEntry((Map.Entry<E, E>) o);\n+            }\n+            iter.remove();\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how).\n+            //\n+            // see areEqualElementsDistinguishable()\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(o);\n+                verify();\n+            }\n+\n+            size--;\n+            assertEquals(\"Collection should shrink by one after iterator.remove\", size,\n+                    getCollection().size());\n+        }\n+        assertTrue(\"Collection should be empty after iterator purge\", getCollection().isEmpty());\n+\n+        resetFull();\n+        iter = getCollection().iterator();\n+        iter.next();\n+        iter.remove();\n+        try {\n+            iter.remove();\n+            fail(\"Second iter.remove should raise IllegalState\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#remove(Object)}.\n+     */\n+    public void testCollectionRemove() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent element\", !getCollection().remove(elements[i]));\n+            verify();\n+        }\n+\n+        E[] other = getOtherElements();\n+\n+        resetFull();\n+        for (int i = 0; i < other.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent other element\", !getCollection().remove(other[i]));\n+            verify();\n+        }\n+\n+        int size = getCollection().size();\n+        for (int i = 0; i < elements.length; i++) {\n+            resetFull();\n+            assertTrue(\"Collection should remove extant element: \" + elements[i],\n+                    getCollection().remove(elements[i]));\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how).\n+            //\n+            // see areEqualElementsDistinguishable()\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(elements[i]);\n+                verify();\n+            }\n+\n+            assertEquals(\"Collection should shrink after remove\", size - 1, getCollection().size());\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#removeAll(Collection)}.\n+     */\n+    public void testCollectionRemoveAll() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        assertTrue(\"Empty collection removeAll should return false for empty input\",\n+                !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty collection removeAll should return false for nonempty input\",\n+                   !getCollection().removeAll(new ArrayList<E>(getCollection())));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection removeAll should return false for empty input\",\n+                   !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return false for other elements\",\n+                   !getCollection().removeAll(Arrays.asList(getOtherElements())));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return true for full elements\",\n+                getCollection().removeAll(new HashSet<E>(getCollection())));\n+        getConfirmed().removeAll(new HashSet<E>(getConfirmed()));\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        int min = (getFullElements().length < 2 ? 0 : 2);\n+        int max = (getFullElements().length == 1 ? 1 :\n+                (getFullElements().length <= 5 ? getFullElements().length - 1 : 5));\n+        Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n+        assertTrue(\"Full collection removeAll should work\", getCollection().removeAll(all));\n+        getConfirmed().removeAll(all);\n+        verify();\n+\n+        assertTrue(\"Collection should shrink after removeAll\", getCollection().size() < size);\n+        Iterator<E> iter = all.iterator();\n+        while (iter.hasNext()) {\n+            assertTrue(\"Collection shouldn't contain removed element\",\n+                    !getCollection().contains(iter.next()));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#retainAll(Collection)}.\n+     */\n+    public void testCollectionRetainAll() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        List<E> elements = Arrays.asList(getFullElements());\n+        List<E> other = Arrays.asList(getOtherElements());\n+\n+        assertTrue(\"Empty retainAll() should return false\",\n+                !getCollection().retainAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty retainAll() should return false\", !getCollection().retainAll(elements));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection should change from retainAll empty\",\n+                getCollection().retainAll(Collections.EMPTY_SET));\n+        getConfirmed().retainAll(Collections.EMPTY_SET);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection changed from retainAll other\", getCollection().retainAll(other));\n+        getConfirmed().retainAll(other);\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        assertTrue(\"Collection shouldn't change from retainAll elements\",\n+                   !getCollection().retainAll(elements));\n+        verify();\n+        assertEquals(\"Collection size shouldn't change\", size, getCollection().size());\n+\n+        if (getFullElements().length > 1) {\n+            resetFull();\n+            size = getCollection().size();\n+            int min = (getFullElements().length < 2 ? 0 : 2);\n+            int max = (getFullElements().length <= 5 ? getFullElements().length - 1 : 5);\n+            assertTrue(\"Collection should changed by partial retainAll\",\n+                    getCollection().retainAll(elements.subList(min, max)));\n+            getConfirmed().retainAll(elements.subList(min, max));\n+            verify();\n+\n+            Iterator<E> iter = getCollection().iterator();\n+            while (iter.hasNext()) {\n+                assertTrue(\"Collection only contains retained element\",\n+                        elements.subList(min, max).contains(iter.next()));\n+            }\n+        }\n+\n+        resetFull();\n+        HashSet<E> set = new HashSet<E>(elements);\n+        size = getCollection().size();\n+        assertTrue(\"Collection shouldn't change from retainAll without \" +\n+                   \"duplicate elements\", !getCollection().retainAll(set));\n+        verify();\n+        assertEquals(\"Collection size didn't change from nonduplicate \" +\n+                     \"retainAll\", size, getCollection().size());\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#size()}.\n+     */\n+    public void testCollectionSize() {\n+        resetEmpty();\n+        assertEquals(\"Size of new Collection is 0.\", 0, getCollection().size());\n+\n+        resetFull();\n+        assertTrue(\"Size of full collection should be greater than zero\", getCollection().size() > 0);\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#toArray()}.\n+     */\n+    public void testCollectionToArray() {\n+        resetEmpty();\n+        assertEquals(\"Empty Collection should return empty array for toArray\",\n+                     0, getCollection().toArray().length);\n+\n+        resetFull();\n+        Object[] array = getCollection().toArray();\n+        assertEquals(\"Full collection toArray should be same size as collection\",\n+                array.length, getCollection().size());\n+        Object[] confirmedArray = getConfirmed().toArray();\n+        assertEquals(\"length of array from confirmed collection should \"\n+                + \"match the length of the collection's array\", confirmedArray.length, array.length);\n+        boolean[] matched = new boolean[array.length];\n+\n+        for (int i = 0; i < array.length; i++) {\n+            assertTrue(\"Collection should contain element in toArray\",\n+                    getCollection().contains(array[i]));\n+\n+            boolean match = false;\n+            // find a match in the confirmed array\n+            for (int j = 0; j < array.length; j++) {\n+                // skip already matched\n+                if (matched[j])\n+                    continue;\n+                if (array[i] == confirmedArray[j]\n+                        || (array[i] != null && array[i].equals(confirmedArray[j]))) {\n+                    matched[j] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            if (!match) {\n+                fail(\"element \" + i + \" in returned array should be found \"\n+                        + \"in the confirmed collection's array\");\n+            }\n+        }\n+        for (int i = 0; i < matched.length; i++) {\n+            assertEquals(\"Collection should return all its elements in \" + \"toArray\", true,\n+                    matched[i]);\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#toArray(Object[])}.\n+     */\n+    public void testCollectionToArray2() {\n+        resetEmpty();\n+        Object[] a = new Object[] { new Object(), null, null };\n+        Object[] array = getCollection().toArray(a);\n+        assertEquals(\"Given array shouldn't shrink\", array, a);\n+        assertNull(\"Last element should be set to null\", a[0]);\n+        verify();\n+\n+        resetFull();\n+        try {\n+            array = getCollection().toArray(new Void[0]);\n+            fail(\"toArray(new Void[0]) should raise ArrayStore\");\n+        } catch (ArrayStoreException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            array = getCollection().toArray(null);\n+            fail(\"toArray(null) should raise NPE\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        array = getCollection().toArray(new Object[0]);\n+        a = getCollection().toArray();\n+        assertEquals(\"toArrays should be equal\",\n+                     Arrays.asList(array), Arrays.asList(a));\n+\n+        // Figure out if they're all the same class\n+        // TODO: It'd be nicer to detect a common superclass\n+        HashSet<Class<?>> classes = new HashSet<Class<?>>();\n+        for (int i = 0; i < array.length; i++) {\n+            classes.add((array[i] == null) ? null : array[i].getClass());\n+        }\n+        if (classes.size() > 1) return;\n+\n+        Class<?> cl = classes.iterator().next();\n+        if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet\n+            cl = Map.Entry.class;\n+        }\n+        a = (Object[]) Array.newInstance(cl, 0);\n+        array = getCollection().toArray(a);\n+        assertEquals(\"toArray(Object[]) should return correct array type\",\n+                a.getClass(), array.getClass());\n+        assertEquals(\"type-specific toArrays should be equal\",\n+                Arrays.asList(array),\n+                Arrays.asList(getCollection().toArray()));\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests <code>toString</code> on a collection.\n+     */\n+    public void testCollectionToString() {\n+        resetEmpty();\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+\n+        resetFull();\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+    }\n+\n+    /**\n+     *  If isRemoveSupported() returns false, tests to see that remove\n+     *  operations raise an UnsupportedOperationException.\n+     */\n+    public void testUnsupportedRemove() {\n+        if (isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().clear();\n+            fail(\"clear should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().removeAll(null);\n+            fail(\"removeAll should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().retainAll(null);\n+            fail(\"removeAll should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iterator = getCollection().iterator();\n+            iterator.next();\n+            iterator.remove();\n+            fail(\"iterator.remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+    }\n+\n+    /**\n+     *  Tests that the collection's iterator is fail-fast.\n+     */\n+    public void testCollectionIteratorFailFast() {\n+        if (!isFailFastSupported()) return;\n+\n+        if (isAddSupported()) {\n+            resetFull();\n+            try {\n+                Iterator<E> iter = getCollection().iterator();\n+                E o = getOtherElements()[0];\n+                getCollection().add(o);\n+                getConfirmed().add(o);\n+                iter.next();\n+                fail(\"next after add should raise ConcurrentModification\");\n+            } catch (ConcurrentModificationException e) {\n+                // expected\n+            }\n+            verify();\n+\n+            resetFull();\n+            try {\n+                Iterator<E> iter = getCollection().iterator();\n+                getCollection().addAll(Arrays.asList(getOtherElements()));\n+                getConfirmed().addAll(Arrays.asList(getOtherElements()));\n+                iter.next();\n+                fail(\"next after addAll should raise ConcurrentModification\");\n+            } catch (ConcurrentModificationException e) {\n+                // expected\n+            }\n+            verify();\n+        }\n+\n+        if (!isRemoveSupported()) return;\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            getCollection().clear();\n+            iter.next();\n+            fail(\"next after clear should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        } catch (NoSuchElementException e) {\n+            // (also legal given spec)\n+        }\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            getCollection().remove(getFullElements()[0]);\n+            iter.next();\n+            fail(\"next after remove should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().removeAll(sublist);\n+            iter.next();\n+            fail(\"next after removeAll should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            Iterator<E> iter = getCollection().iterator();\n+            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().retainAll(sublist);\n+            iter.next();\n+            fail(\"next after retainAll should raise ConcurrentModification\");\n+        } catch (ConcurrentModificationException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Object obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            Object dest = in.readObject();\n+            in.close();\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj)) - EMPTY Collection\", obj, dest);\n+            }\n+        }\n+        obj = makeFullCollection();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            Object dest = in.readObject();\n+            in.close();\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj)) - FULL Collection\", obj, dest);\n+            }\n+        }\n+    }\n+\n+    public Collection<E> getCollection() {\n+        return collection;\n+    }\n+\n+    /**\n+     * Set the collection.\n+     * @param collection the Collection<E> to set\n+     */\n+    public void setCollection(Collection<E> collection) {\n+        this.collection = collection;\n+    }\n+\n+    public Collection<E> getConfirmed() {\n+        return confirmed;\n+    }\n+\n+    /**\n+     * Set the confirmed.\n+     * @param confirmed the Collection<E> to set\n+     */\n+    public void setConfirmed(Collection<E> confirmed) {\n+        this.confirmed = confirmed;\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#contains(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotCollectionContains(Collection<?> coll, Object element) {\n+        try {\n+            assertFalse(coll.contains(element));\n+        } catch (ClassCastException e) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotCollectionContainsAll(Collection<?> coll, Collection<?> sub) {\n+        try {\n+            assertFalse(coll.containsAll(sub));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#remove(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotRemoveFromCollection(Collection<?> coll, Object element) {\n+        try {\n+            assertFalse(coll.remove(element));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#removeAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotRemoveAllFromCollection(Collection<?> coll, Collection<?> sub) {\n+        try {\n+            assertFalse(coll.removeAll(sub));\n+        } catch (ClassCastException cce) {\n+            //apparently not\n+        } catch (NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/TestCompositeCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the\n+ * {@link CompositeCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Brian McCallister\n+ * @author Phil Steitz\n+ */\n+public class TestCompositeCollection<E> extends AbstractTestCollection<E> {\n+\n+    public TestCompositeCollection(String name) {\n+        super(name);\n+    }\n+\n+ //-----------------------------------------------------------------------------\n+    /**\n+     * Run stock collection tests without Mutator, so turn off add, remove\n+     */\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Empty collection is empty composite\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new CompositeCollection<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"2\", \"3\", \"4\" };\n+    }\n+\n+    /**\n+     * Full collection consists of 4 collections, each with one element\n+     */\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        CompositeCollection<E> compositeCollection = new CompositeCollection<E>();\n+        E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            Collection<E> summand = new HashSet<E>();\n+            summand.add(elements[i]);\n+            compositeCollection.addComposited(summand);\n+        }\n+        return compositeCollection;\n+    }\n+\n+    /**\n+     * Full collection should look like a collection with 4 elements\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> collection = new HashSet<E>();\n+        collection.addAll(Arrays.asList(getFullElements()));\n+        return collection;\n+    }\n+\n+    /**\n+     * Override testUnsupportedRemove, since the default impl expects removeAll,\n+     * retainAll and iterator().remove to throw\n+     */\n+    @Override\n+    public void testUnsupportedRemove() {\n+        resetFull();\n+        try {\n+            getCollection().remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    protected CompositeCollection<E> c;\n+    protected Collection<E> one;\n+    protected Collection<E> two;\n+\n+    protected void setUpTest() {\n+        c = new CompositeCollection<E>();\n+        one = new HashSet<E>();\n+        two = new HashSet<E>();\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    protected void setUpMutatorTest() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, E obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+                for (Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Object obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.remove(obj);\n+                }\n+                return true;\n+            }\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        setUpTest();\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"a\");\n+        set.add((E) \"b\");\n+        c.addComposited(set);\n+        assertEquals(set.size(), c.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMultipleCollectionsSize() {\n+        setUpTest();\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"a\");\n+        set.add((E) \"b\");\n+        c.addComposited(set);\n+        HashSet<E> other = new HashSet<E>();\n+        other.add((E) \"c\");\n+        c.addComposited(other);\n+        assertEquals(set.size() + other.size(), c.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIsEmpty() {\n+        setUpTest();\n+        assertTrue(c.isEmpty());\n+        HashSet<E> empty = new HashSet<E>();\n+        c.addComposited(empty);\n+        assertTrue(c.isEmpty());\n+        empty.add((E) \"a\");\n+        assertTrue(!c.isEmpty());\n+    }\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one);\n+        c.addComposited(two);\n+        Iterator<E> i = c.iterator();\n+        E next = i.next();\n+        assertTrue(c.contains(next));\n+        assertTrue(one.contains(next));\n+        next = i.next();\n+        i.remove();\n+        assertTrue(!c.contains(next));\n+        assertTrue(!two.contains(next));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClear() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        c.clear();\n+        assertTrue(one.isEmpty());\n+        assertTrue(two.isEmpty());\n+        assertTrue(c.isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsAll() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"1\");\n+        c.addComposited(one);\n+        assertTrue(c.containsAll(two));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        one.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one);\n+        c.retainAll(two);\n+        assertTrue(!c.contains(\"2\"));\n+        assertTrue(!one.contains(\"2\"));\n+        assertTrue(c.contains(\"1\"));\n+        assertTrue(one.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"serial\" })\n+    public void testAddAllMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, E obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+                for (Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Object obj) {\n+                return false;\n+            }\n+        });\n+\n+        c.addComposited(one);\n+        two.add((E) \"foo\");\n+        c.addAll(two);\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"serial\" })\n+    public void testAddMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, E obj) {\n+                for (Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+                for (Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Object obj) {\n+                return false;\n+            }\n+        });\n+\n+        c.addComposited(one);\n+        c.add((E) \"foo\");\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToCollection() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        Collection<E> foo = c.toCollection();\n+        assertTrue(foo.containsAll(c));\n+        assertEquals(c.size(), foo.size());\n+        one.add((E) \"3\");\n+        assertTrue(!foo.containsAll(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToCollection() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        Collection<E> toCollection = new HashSet<E>();\n+        toCollection.addAll(c);\n+        assertTrue(toCollection.containsAll(c));\n+        assertEquals(c.size(), toCollection.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one, two);\n+        c.remove(\"1\");\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveAll() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        // need separate list to remove, as otherwise one clears itself\n+        Collection<E> removing = new ArrayList<E>(one);\n+        c.addComposited(one, two);\n+        c.removeAll(removing);\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one, two);\n+        c.removeComposited(one);\n+        assertTrue(c.contains(\"1\"));\n+        assertEquals(2, c.size());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"/tmp/CompositeCollection.emptyCollection.version3.3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"/tmp/CompositeCollection.fullCollection.version3.3.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/TestPredicatedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the \n+ * {@link PredicatedCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedCollection<E> extends AbstractTestCollection<E> {\n+\n+    public TestPredicatedCollection(String name) {\n+        super(name);\n+    }\n+\n+   //------------------------------------------------------------------------\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected Collection<E> decorateCollection(\n+                Collection<E> collection, Predicate<E> predicate) {\n+        return PredicatedCollection.predicatedCollection(collection, predicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeObject() {\n+        return decorateCollection(new ArrayList<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return decorateCollection(list, truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(E o) {\n+                return o instanceof String;\n+            }\n+        };\n+\n+    public Collection<E> makeTestCollection() {\n+        return decorateCollection(new ArrayList<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        Collection<E> c = makeTestCollection();\n+        Integer i = new Integer(3);\n+        try {\n+            c.add((E) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !c.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        Collection<E> c = makeTestCollection();\n+        List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n+        try {\n+            c.addAll(elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"one\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"two\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(new Integer(3)));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"four\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/TestSynchronizedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the\n+ * {@link SynchronizedCollection} implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class TestSynchronizedCollection<E> extends AbstractTestCollection<E> {\n+\n+    public TestSynchronizedCollection(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return SynchronizedCollection.synchronizedCollection(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/TestTransformedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the {@link TransformedCollection}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedCollection extends AbstractTestCollection<Object> {\n+    \n+    private static class StringToInteger implements Transformer<Object, Object> {\n+        public Object transform(Object input) {\n+            return new Integer((String) input);\n+        }\n+    }\n+    \n+    public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n+    public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n+\n+    public TestTransformedCollection(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<Object> makeConfirmedCollection() {\n+        return new ArrayList<Object>();\n+    }\n+\n+    @Override\n+    public Collection<Object> makeConfirmedFullCollection() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+    \n+    @Override\n+    public Collection<Object> makeObject() {\n+        return TransformedCollection.transformingCollection(new ArrayList<Object>(), NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    public Collection<Object> makeFullCollection() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Object[] getFullElements() {\n+        return new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+    }\n+\n+    @Override\n+    public Object[] getOtherElements() {\n+        return new Object[] {\"9\", \"88\", \"678\", \"87\", \"98\", \"78\", \"99\"};\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTransformedCollection() {\n+        Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, coll.size());\n+        Object[] els = getFullElements();\n+        for (int i = 0; i < els.length; i++) {\n+            coll.add(els[i]);\n+            assertEquals(i + 1, coll.size());\n+            assertEquals(true, coll.contains(new Integer((String) els[i])));\n+            assertEquals(false, coll.contains(els[i]));\n+        }\n+        \n+        assertEquals(true, coll.remove(new Integer((String) els[0])));\n+    }\n+\n+    public void testTransformedCollection_decorateTransform() {\n+        Collection originalCollection = new ArrayList();\n+        Object[] els = getFullElements();\n+        for (int i = 0; i < els.length; i++) {\n+            originalCollection.add(els[i]);\n+        }\n+        Collection collection = TransformedCollection.transformedCollection(originalCollection, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, collection.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, collection.contains(new Integer((String) els[i])));\n+            assertEquals(false, collection.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, collection.remove(els[0]));\n+        assertEquals(true, collection.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/TestUnmodifiableCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractTestCollection} for exercising the\n+ * {@link UnmodifiableCollection} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableCollection<E> extends AbstractTestCollection<E> {\n+\n+    public TestUnmodifiableCollection(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return UnmodifiableCollection.unmodifiableCollection(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableCollection.unmodifiableCollection(list);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableCollection.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableCollection.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/AbstractTestComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+\n+/**\n+ * Abstract test class for testing the Comparator interface.\n+ * <p>\n+ * Concrete subclasses declare the comparator to be tested.\n+ * They also declare certain aspects of the tests.\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestComparator<T> extends AbstractTestObject {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestComparator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Implement this method to return a list of sorted objects.\n+     * \n+     * @return sorted objects\n+     */\n+    public abstract List<T> getComparableObjectsOrdered();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements the abstract superclass method to return the comparator.\n+     * \n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract Comparator<T> makeObject();\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsEmptyCollections() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsFullCollections() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overrides superclass to set the compatability to version 2\n+     * as there were no Comparators in version 1.x.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"2\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverse the list.\n+     */\n+    protected void reverseObjects(List<?> list) {\n+        Collections.reverse(list);\n+    }\n+\n+    /**\n+     * Randomize the list.\n+     */\n+    protected void randomizeObjects(List<?> list) {\n+        Collections.shuffle(list);\n+    }\n+\n+    /**\n+     * Sort the list.\n+     */\n+    protected void sortObjects(List<T> list, Comparator<? super T> comparator) {\n+        Collections.sort(list, comparator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test sorting an empty list\n+     */\n+    public void testEmptyListSort() {\n+        List<T> list = new LinkedList<T>();\n+        sortObjects(list, makeObject());\n+\n+        List<T> list2 = new LinkedList<T>();\n+\n+        assertTrue(\"Comparator cannot sort empty lists\", list2.equals(list));\n+    }\n+\n+    /**\n+     * Test sorting a reversed list.\n+     */\n+    public void testReverseListSort() {\n+        Comparator<T> comparator = makeObject();\n+\n+        List<T> randomList = getComparableObjectsOrdered();\n+        reverseObjects(randomList);\n+        sortObjects(randomList, comparator);\n+\n+        List<T> orderedList = getComparableObjectsOrdered();\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+    }\n+\n+    /**\n+     * Test sorting a random list.\n+     */\n+    public void testRandomListSort() {\n+        Comparator<T> comparator = makeObject();\n+\n+        List<T> randomList = getComparableObjectsOrdered();\n+        randomizeObjects(randomList);\n+        sortObjects(randomList,comparator);\n+\n+        List<T> orderedList = getComparableObjectsOrdered();\n+\n+        /* debug \n+        Iterator i = randomList.iterator();\n+        while (i.hasNext()) {\n+            System.out.println(i.next());\n+        }\n+        */\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+\n+    }\n+\n+    /**\n+     * Nearly all Comparators should be Serializable.\n+     */\n+    public void testComparatorIsSerializable() {\n+        Comparator<T> comparator = makeObject();\n+        assertTrue(\"This comparator should be Serializable.\",\n+                   comparator instanceof Serializable);\n+    }\n+\n+    public String getCanonicalComparatorName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(\"data/test/\");\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\")+1,colName.length());\n+        retval.append(colName);\n+        retval.append(\".version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Comparator\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testComparatorCompatibility() throws IOException, ClassNotFoundException {\n+        if (!skipSerializedCanonicalTests()) {\n+            Comparator<T> comparator = null;\n+    \n+            // test to make sure the canonical form has been preserved\n+            try {\n+                comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));\n+            } catch (FileNotFoundException exception) {\n+    \n+                boolean autoCreateSerialized = false;\n+    \n+                if (autoCreateSerialized) {\n+                      comparator = makeObject();\n+                    String fileName = getCanonicalComparatorName(comparator);\n+                    writeExternalFormToDisk((Serializable) comparator, fileName);\n+                    fail(\"Serialized form could not be found.  A serialized version \"\n+                            + \"has now been written (and should be added to CVS): \" + fileName);\n+                } else {\n+                    fail(\"The Serialized form could be located to test serialization \"\n+                            + \"compatibility: \" + exception.getMessage());\n+                }\n+            }\n+    \n+            \n+            // make sure the canonical form produces the ordering we currently\n+            // expect\n+            List<T> randomList = getComparableObjectsOrdered();\n+            reverseObjects(randomList);\n+            sortObjects(randomList, comparator);\n+    \n+            List<T> orderedList = getComparableObjectsOrdered();\n+    \n+            assertTrue(\"Comparator did not reorder the List correctly\",\n+                       orderedList.equals(randomList));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/AbstractTestNullComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test the NullComparator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Michael A. Smith\n+ */\n+public abstract class AbstractTestNullComparator extends AbstractTestComparator<Integer> {\n+\n+    public AbstractTestNullComparator(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AbstractTestNullComparator.class.getName());\n+        suite.addTest(new TestSuite(TestNullComparator1.class));\n+        suite.addTest(new TestSuite(TestNullComparator2.class));\n+        return suite;\n+    }\n+\n+    /**\n+     *  Test the NullComparator with nulls high, using comparable comparator\n+     **/\n+    public static class TestNullComparator1 extends AbstractTestNullComparator {\n+\n+        public TestNullComparator1(String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public Comparator<Integer> makeObject() {\n+            return new NullComparator<Integer>();\n+        }\n+\n+        @Override\n+        public List<Integer> getComparableObjectsOrdered() {\n+            List<Integer> list = new LinkedList<Integer>();\n+            list.add(new Integer(1));\n+            list.add(new Integer(2));\n+            list.add(new Integer(3));\n+            list.add(new Integer(4));\n+            list.add(new Integer(5));\n+            list.add(null);\n+            return list;\n+        }\n+\n+        @Override\n+        public String getCanonicalComparatorName(Object object) {\n+            return super.getCanonicalComparatorName(object) + \"1\";\n+        }\n+    }\n+\n+    /**\n+     *  Test the NullComparator with nulls low using the comparable comparator\n+     **/\n+    public static class TestNullComparator2 extends AbstractTestNullComparator {\n+\n+        public TestNullComparator2(String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public Comparator<Integer> makeObject() {\n+            return new NullComparator<Integer>(false);\n+        }\n+\n+        @Override\n+        public List<Integer> getComparableObjectsOrdered() {\n+            List<Integer> list = new LinkedList<Integer>();\n+            list.add(null);\n+            list.add(new Integer(1));\n+            list.add(new Integer(2));\n+            list.add(new Integer(3));\n+            list.add(new Integer(4));\n+            list.add(new Integer(5));\n+            return list;\n+        }\n+\n+        @Override\n+        public String getCanonicalComparatorName(Object object) {\n+            return super.getCanonicalComparatorName(object) + \"2\";\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/TestBooleanComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * Tests for {@link BooleanComparator}.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestBooleanComparator extends AbstractTestComparator<Boolean> {\n+\n+    // conventional\n+    // ------------------------------------------------------------------------\n+\n+    public TestBooleanComparator(String testName) {\n+        super(testName);\n+    }\n+\n+    // collections testing framework\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public Comparator<Boolean> makeObject() {\n+        return new BooleanComparator();\n+    }\n+\n+    @Override\n+    public List<Boolean> getComparableObjectsOrdered() {\n+        List<Boolean> list = new ArrayList<Boolean>();\n+        list.add(new Boolean(false));\n+        list.add(Boolean.FALSE);\n+        list.add(new Boolean(false));\n+        list.add(Boolean.TRUE);\n+        list.add(new Boolean(true));\n+        list.add(true);\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    // tests\n+    // ------------------------------------------------------------------------\n+\n+    public void testConstructors() {\n+        allTests(false,new BooleanComparator());\n+        allTests(false,new BooleanComparator(false));\n+        allTests(true,new BooleanComparator(true));\n+    }\n+\n+    public void testStaticFactoryMethods() {\n+        allTests(false,BooleanComparator.getFalseFirstComparator());\n+        allTests(false,BooleanComparator.booleanComparator(false));\n+        allTests(true,BooleanComparator.getTrueFirstComparator());\n+        allTests(true,BooleanComparator.booleanComparator(true));\n+    }\n+\n+    public void testEqualsCompatibleInstance() {\n+        assertEquals(new BooleanComparator(),new BooleanComparator(false));\n+        assertEquals(new BooleanComparator(false),new BooleanComparator(false));\n+        assertEquals(new BooleanComparator(false),BooleanComparator.getFalseFirstComparator());\n+        assertSame(BooleanComparator.getFalseFirstComparator(),BooleanComparator.booleanComparator(false));\n+\n+        assertEquals(new BooleanComparator(true),new BooleanComparator(true));\n+        assertEquals(new BooleanComparator(true),BooleanComparator.getTrueFirstComparator());\n+        assertSame(BooleanComparator.getTrueFirstComparator(),BooleanComparator.booleanComparator(true));\n+\n+        assertTrue(!(new BooleanComparator().equals(new BooleanComparator(true))));\n+        assertTrue(!(new BooleanComparator(true).equals(new BooleanComparator(false))));\n+    }\n+\n+    // utilities\n+    // ------------------------------------------------------------------------\n+\n+    protected void allTests(boolean trueFirst, BooleanComparator comp) {\n+        orderIndependentTests(comp);\n+        if(trueFirst) {\n+            trueFirstTests(comp);\n+        } else {\n+            falseFirstTests(comp);\n+        }\n+    }\n+\n+    protected void trueFirstTests(BooleanComparator comp) {\n+        assertNotNull(comp);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) > 0);\n+        assertTrue(comp.compare(true, false) < 0);\n+    }\n+\n+    protected void falseFirstTests(BooleanComparator comp) {\n+        assertNotNull(comp);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) < 0);\n+        assertTrue(comp.compare(true, false) > 0);\n+    }\n+\n+    protected void orderIndependentTests(BooleanComparator comp) {\n+        nullArgumentTests(comp);\n+    }\n+\n+    protected void nullArgumentTests(BooleanComparator comp) {\n+        assertNotNull(comp);\n+        try {\n+            comp.compare(null,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(Boolean.TRUE,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(Boolean.FALSE,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(null,Boolean.TRUE);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(null,Boolean.FALSE);\n+            fail(\"Expected NullPointerException\");\n+        } catch(NullPointerException e) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/TestComparableComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Tests for ComparableComparator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestComparableComparator extends AbstractTestComparator<Integer> {\n+\n+    public TestComparableComparator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+        return new ComparableComparator<Integer>();\n+    }\n+\n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        List<Integer> list = new LinkedList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        list.add(5);\n+        return list;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/TestComparatorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Tests for ComparatorChain.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Unknown\n+ */\n+public class TestComparatorChain extends AbstractTestComparator<TestComparatorChain.PseudoRow> {\n+\n+    public TestComparatorChain(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Comparator<PseudoRow> makeObject() {\n+        ComparatorChain<PseudoRow> chain = new ComparatorChain<PseudoRow>(new ColumnComparator(0));\n+        chain.addComparator(new ColumnComparator(1), true); // reverse the second column\n+        chain.addComparator(new ColumnComparator(2), false);\n+        return chain;\n+    }\n+\n+    public void testNoopComparatorChain() {\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+        chain.addComparator(new ComparableComparator<Integer>());\n+\n+        int correctValue = i1.compareTo(i2);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n+    }\n+\n+    public void testBadNoopComparatorChain() {\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+        try {\n+            chain.compare(i1,i2);\n+            fail(\"An exception should be thrown when a chain contains zero comparators.\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    public void testListComparatorChain() {\n+        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        list.add(new ComparableComparator<Integer>());\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+\n+        int correctValue = i1.compareTo(i2);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n+    }\n+\n+    public void testBadListComparatorChain() {\n+        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        Integer i1 = new Integer(4);\n+        Integer i2 = new Integer(6);\n+        try {\n+            chain.compare(i1, i2);\n+            fail(\"An exception should be thrown when a chain contains zero comparators.\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    public void testComparatorChainOnMinvaluedCompatator() {\n+        // -1 * Integer.MIN_VALUE is less than 0,\n+        // test that ComparatorChain handles this edge case correctly\n+        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        chain.addComparator(new Comparator<Integer>() {\n+            public int compare(Integer a, Integer b) {\n+                int result = a.compareTo(b);\n+                if (result < 0) {\n+                    return Integer.MIN_VALUE;\n+                }\n+                if (result > 0) {\n+                    return Integer.MAX_VALUE;\n+                }\n+                return 0;\n+            }\n+        }, true);\n+\n+        assertTrue(chain.compare(new Integer(4), new Integer(5)) > 0);\n+        assertTrue(chain.compare(new Integer(5), new Integer(4)) < 0);\n+        assertTrue(chain.compare(new Integer(4), new Integer(4)) == 0);\n+    }\n+\n+    @Override\n+    public List<PseudoRow> getComparableObjectsOrdered() {\n+        List<PseudoRow> list = new LinkedList<PseudoRow>();\n+        // this is the correct order assuming a\n+        // \"0th forward, 1st reverse, 2nd forward\" sort\n+        list.add(new PseudoRow(1, 2, 3));\n+        list.add(new PseudoRow(2, 3, 5));\n+        list.add(new PseudoRow(2, 2, 4));\n+        list.add(new PseudoRow(2, 2, 8));\n+        list.add(new PseudoRow(3, 1, 0));\n+        list.add(new PseudoRow(4, 4, 4));\n+        list.add(new PseudoRow(4, 4, 7));\n+        return list;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class PseudoRow implements Serializable {\n+\n+        public int cols[] = new int[3];\n+\n+        public PseudoRow(int col1, int col2, int col3) {\n+            cols[0] = col1;\n+            cols[1] = col2;\n+            cols[2] = col3;\n+        }\n+\n+        public int getColumn(int colIndex) {\n+            return cols[colIndex];\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(\"[\");\n+            buf.append(cols[0]);\n+            buf.append(\",\");\n+            buf.append(cols[1]);\n+            buf.append(\",\");\n+            buf.append(cols[2]);\n+            buf.append(\"]\");\n+            return buf.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof PseudoRow)) {\n+                return false;\n+            }\n+\n+            PseudoRow row = (PseudoRow) o;\n+            if (getColumn(0) != row.getColumn(0)) {\n+                return false;\n+            }\n+\n+            if (getColumn(1) != row.getColumn(1)) {\n+                return false;\n+            }\n+\n+            if (getColumn(2) != row.getColumn(2)) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+    }\n+\n+    public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {\n+        private static final long serialVersionUID = -2284880866328872105L;\n+\n+        protected int colIndex = 0;\n+\n+        public ColumnComparator(int colIndex) {\n+            this.colIndex = colIndex;\n+        }\n+\n+        public int compare(PseudoRow o1, PseudoRow o2) {\n+\n+            int col1 = o1.getColumn(colIndex);\n+            int col2 = o2.getColumn(colIndex);\n+\n+            if (col1 > col2) {\n+                return 1;\n+            }\n+            if (col1 < col2) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return colIndex;\n+        }\n+\n+        @Override\n+        public boolean equals(Object that) {\n+            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/TestFixedOrderComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test class for FixedOrderComparator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author David Leppik\n+ * @author Stephen Colebourne\n+ */\n+public class TestFixedOrderComparator extends TestCase {\n+\n+    /**\n+     * Top cities of the world, by population including metro areas.\n+     */\n+    private static final String topCities[] = new String[] {\n+        \"Tokyo\",\n+        \"Mexico City\",\n+        \"Mumbai\",\n+        \"Sao Paulo\",\n+        \"New York\",\n+        \"Shanghai\",\n+        \"Lagos\",\n+        \"Los Angeles\",\n+        \"Calcutta\",\n+        \"Buenos Aires\"\n+    };\n+\n+    //\n+    // Initialization and busywork\n+    //\n+\n+    public TestFixedOrderComparator(String name) {\n+        super(name);\n+    }\n+\n+    //\n+    // Set up and tear down\n+    //\n+\n+\n+\n+    //\n+    // The tests\n+    //\n+\n+    /**\n+     * Tests that the constructor plus add method compares items properly.\n+     */\n+    public void testConstructorPlusAdd() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>();\n+        for (int i = 0; i < topCities.length; i++) {\n+            comparator.add(topCities[i]);\n+        }\n+        String[] keys = topCities.clone();\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests that the array constructor compares items properly.\n+     */\n+    public void testArrayConstructor() {\n+        String[] keys = topCities.clone();\n+        String[] topCitiesForTest = topCities.clone();\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest[0] = \"Brighton\";\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests the list constructor.\n+     */\n+    public void testListConstructor() {\n+        String[] keys = topCities.clone();\n+        List<String> topCitiesForTest = new LinkedList<String>(Arrays.asList(topCities));\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest.set(0, \"Brighton\");\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests addAsEqual method.\n+     */\n+    public void testAddAsEqual() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+        assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n+        assertEquals(1, comparator.compare(\"Shanghai\", \"Minneapolis\"));\n+    }\n+\n+    /**\n+     * Tests whether or not updates are disabled after a comparison is made.\n+     */\n+    public void testLock() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        assertEquals(false, comparator.isLocked());\n+        comparator.compare(\"New York\", \"Tokyo\");\n+        assertEquals(true, comparator.isLocked());\n+        try {\n+            comparator.add(\"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+\n+        try {\n+            comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+    }\n+\n+    public void testUnknownObjectBehavior() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        try {\n+            comparator.compare(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        try {\n+            comparator.compare(\"Minneapolis\", \"New York\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());\n+        LinkedList<String> keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.addFirst(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals( 1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n+        keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.add(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals( 1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+    }\n+\n+    //\n+    // Helper methods\n+    //\n+\n+    /** Shuffles the keys and asserts that the comparator sorts them back to\n+     * their original order.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    private void assertComparatorYieldsOrder(String[] orderedObjects,\n+                                             Comparator<String> comparator) {\n+        String[] keys = orderedObjects.clone();\n+\n+        // shuffle until the order changes.  It's extremely rare that\n+        // this requires more than one shuffle.\n+\n+        boolean isInNewOrder = false;\n+        Random rand = new Random();\n+        while (keys.length > 1 && isInNewOrder == false) {\n+            // shuffle:\n+            for (int i = keys.length-1; i > 0; i--) {\n+                String swap = keys[i];\n+                int j = rand.nextInt(i+1);\n+                keys[i] = keys[j];\n+                keys[j] = swap;\n+            }\n+\n+            // testShuffle\n+            for (int i = 0; i < keys.length && !isInNewOrder; i++) {\n+                if( !orderedObjects[i].equals(keys[i])) {\n+                    isInNewOrder = true;\n+                }\n+            }\n+        }\n+\n+        // The real test:  sort and make sure they come out right.\n+\n+        Arrays.sort(keys, comparator);\n+\n+        for (int i = 0; i < orderedObjects.length; i++) {\n+            assertEquals(orderedObjects[i], keys[i]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/comparators/TestReverseComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.comparators;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * Tests for ReverseComparator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Unknown\n+ */\n+public class TestReverseComparator extends AbstractTestComparator<Integer> {\n+\n+    public TestReverseComparator(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * For the purposes of this test, return a\n+     * ReverseComparator that wraps the java.util.Collections.reverseOrder()\n+     * Comparator.  The resulting comparator should\n+     * sort according to natural Order.  (Note: we wrap\n+     * a Comparator taken from the JDK so that we can\n+     * save a \"canonical\" form in SVN.\n+     *\n+     * @return Comparator that returns \"natural\" order\n+     */\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+        return new ReverseComparator<Integer>(Collections.<Integer>reverseOrder());\n+    }\n+\n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        List<Integer> list = new LinkedList<Integer>();\n+        list.add(new Integer(1));\n+        list.add(new Integer(2));\n+        list.add(new Integer(3));\n+        list.add(new Integer(4));\n+        list.add(new Integer(5));\n+        return list;\n+    }\n+\n+    /**\n+     * Override this inherited test since Collections.reverseOrder\n+     * doesn't adhere to the \"soft\" Comparator contract, and we've\n+     * already \"cannonized\" the comparator returned by makeComparator.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Comparator comp = new ReverseComparator(new ComparableComparator());\n+\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(comp);\n+        out.close();\n+\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        Object dest = in.readObject();\n+        in.close();\n+        assertEquals(\"obj != deserialize(serialize(obj))\",comp,dest);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/AbstractTestAnyAllOnePredicate.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Predicate;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+\n+/**\n+ * Base class for tests of AnyPredicate, AllPredicate, and OnePredicate.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 468603 $ $Date: 2006-10-27 17:52:37 -0700 (Fri, 27 Oct 2006) $\n+ *\n+ * @author Edwin Tellman\n+ */\n+public abstract class AbstractTestAnyAllOnePredicate<T> extends AbstractTestCompositePredicate<T> {\n+\n+    /**\n+     * Creates a new <code>TestCompositePredicate</code>.\n+     *\n+     * @param testValue the value which the mock predicates should expect to see (may be null).\n+     */\n+    protected AbstractTestAnyAllOnePredicate(final T testValue) {\n+        super(testValue);\n+    }\n+\n+    /**\n+     * Tests whether <code>getInstance</code> with a one element array returns the first element in the array.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public final void singleElementArrayToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(predicate);\n+        assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests that passing a singleton collection to <code>getInstance</code> returns the single element in the\n+     * collection.\n+     */\n+    @Override\n+    @Test\n+    public final void singletonCollectionToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(\n+                Collections.<Predicate<T>>singleton(predicate));\n+        assertSame(\"expected singleton collection member to be returned by getInstance()\",\n+                predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests creating composite predicate instances with single predicates and verifies that the composite returns\n+     * the same value as the single predicate does. \n+     */\n+    @SuppressWarnings(\"boxing\")\n+    public final void singleValues() {\n+        assertTrue(getPredicateInstance(true).evaluate(null));\n+        assertFalse(getPredicateInstance(false).evaluate(null));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/AbstractTestCompositePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+/**\n+ * Base class for tests of composite predicates.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 468603 $ $Date: 2006-10-27 17:52:37 -0700 (Fri, 27 Oct 2006) $\n+ *\n+ * @author Edwin Tellman\n+ */\n+public abstract class AbstractTestCompositePredicate<T> extends MockPredicateTestBase<T> {\n+\n+    /**\n+     * Creates a new <code>TestCompositePredicate</code>.\n+     *\n+     * @param testValue the value which the mock predicates should expect to see (may be null).\n+     */\n+    protected AbstractTestCompositePredicate(final T testValue) {\n+        super(testValue);\n+    }\n+\n+    /**\n+     * Creates an instance of the predicate to test.\n+     *\n+     * @param predicates the arguments to <code>getInstance</code>.\n+     *\n+     * @return a predicate to test.\n+     */\n+    protected abstract Predicate<T> getPredicateInstance(final Predicate<? super T> ... predicates);\n+\n+    /**\n+     * Creates an instance of the predicate to test.\n+     *\n+     * @param predicates the argument to <code>getInstance</code>.\n+     *\n+     * @return a predicate to test.\n+     */\n+    protected abstract Predicate<T> getPredicateInstance(final Collection<Predicate<T>> predicates);\n+\n+    /**\n+     * Creates an instance of the predicate to test.\n+     *\n+     * @param mockReturnValues the return values for the mock predicates, or null if that mock is not expected\n+     *                         to be called\n+     *\n+     * @return a predicate to test.\n+     */\n+    protected final Predicate<T> getPredicateInstance(final Boolean... mockReturnValues) {\n+        final List<Predicate<T>> predicates = new ArrayList<Predicate<T>>();\n+        for (Boolean returnValue : mockReturnValues) {\n+            predicates.add(createMockPredicate(returnValue));\n+        }\n+        return getPredicateInstance(predicates);\n+    }\n+\n+    /**\n+     * Tests whether <code>getInstance</code> with a one element array returns the first element in the array.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void singleElementArrayToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(predicate);\n+        Assert.assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests that passing a singleton collection to <code>getInstance</code> returns the single element in the\n+     * collection.\n+     */\n+    public void singletonCollectionToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(\n+                Collections.<Predicate<T>>singleton(predicate));\n+        Assert.assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with a null predicate array.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullArrayToGetInstance() {\n+        getPredicateInstance((Predicate<T>[]) null);\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with a single null element in the predicate array.\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullElementInArrayToGetInstance() {\n+        getPredicateInstance(new Predicate[] { null });\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with two null elements in the predicate array.\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullElementsInArrayToGetInstance() {\n+        getPredicateInstance(new Predicate[] { null, null });\n+    }\n+\n+\n+    /**\n+     * Tests <code>getInstance</code> with a null predicate collection\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullCollectionToGetInstance() {\n+        getPredicateInstance((Collection<Predicate<T>>) null);\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with a predicate collection that contains null elements\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullElementsInCollectionToGetInstance() {\n+        final Collection<Predicate<T>> coll = new ArrayList<Predicate<T>>();\n+        coll.add(null);\n+        coll.add(null);\n+        getPredicateInstance(coll);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/BasicClosureTestBase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Closure;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public abstract class BasicClosureTestBase {\n+\n+    @Test\n+    public void closureSanityTests() throws Exception {\n+        Closure<?> closure = generateClosure();\n+        Assert.assertNotNull(closure);\n+    }\n+\n+    /**\n+     * @return a closure for general sanity tests.\n+     */\n+    protected abstract <T> Closure<T> generateClosure();\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/BasicPredicateTestBase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public abstract class BasicPredicateTestBase {\n+    protected Object cObject;\n+    protected String cString;\n+    protected Integer cInteger;\n+\n+    @Before\n+    public void initialiseTestObjects() throws Exception {\n+        cObject = new Object();\n+        cString = \"Hello\";\n+        cInteger = new Integer(6);\n+    }\n+    \n+    @Test\n+    public void predicateSanityTests() throws Exception {\n+        Predicate<?> predicate = generatePredicate();\n+        Assert.assertNotNull(predicate);\n+    }\n+\n+    /**\n+     * @return a predicate for general sanity tests.\n+     */\n+    protected abstract Predicate<?> generatePredicate();\n+\n+    protected <T> void assertFalse(Predicate<T> predicate, T testObject) {\n+        Assert.assertFalse(predicate.evaluate(testObject));\n+    }\n+\n+    protected <T> void assertTrue(Predicate<T> predicate, T testObject) {\n+        Assert.assertTrue(predicate.evaluate(testObject));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/MockPredicateTestBase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import static org.easymock.EasyMock.verify;\n+import static org.easymock.EasyMock.replay;\n+import org.junit.Before;\n+import org.junit.After;\n+import org.apache.commons.collections.Predicate;\n+import org.easymock.EasyMock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Base class for tests of predicates which delegate to other predicates when evaluating an object.  This class\n+ * provides methods to create and verify mock predicates to which to delegate.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 468603 $ $Date: 2006-10-27 17:52:37 -0700 (Fri, 27 Oct 2006) $\n+ *\n+ * @author Edwin Tellman\n+ */\n+public abstract class MockPredicateTestBase<T> {\n+    /**\n+     * Mock predicates created by a single test case which need to be verified after the test completes.\n+     */\n+    private List<Predicate<? super T>> mockPredicatesToVerify;\n+    \n+    /**\n+     * The value to pass to mocks.\n+     */\n+    private final T testValue;\n+\n+    /**\n+     * Creates a new <code>PredicateTestBase</code>.\n+     *\n+     * @param testValue the value to pass to mock predicates.\n+     */\n+    protected MockPredicateTestBase(final T testValue) {\n+        this.testValue = testValue;\n+    }\n+\n+    /**\n+     * Creates the list of predicates to verify.\n+     */\n+    @Before\n+    public final void createVerifyList()\n+    {\n+        mockPredicatesToVerify = new ArrayList<Predicate<? super T>>();\n+    }\n+\n+    /**\n+     * Verifies all the mock predicates created for the test.\n+     */\n+    @After\n+    public final void verifyPredicates()\n+    {\n+        for (Predicate<? super T> predicate : mockPredicatesToVerify) {\n+            verify(predicate);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value which will be passed to the mock predicates.\n+     *\n+     * @return the test value.\n+     */\n+    protected final T getTestValue() {\n+        return testValue;\n+    }\n+\n+    /**\n+     * Creates a single mock predicate.\n+     *\n+     * @param returnValue the return value for the mock predicate, or null if the mock is not expected to be called.\n+     *\n+     * @return a single mock predicate.\n+     */\n+    @SuppressWarnings({\"unchecked\", \"boxing\"})\n+    protected final Predicate<T> createMockPredicate(final Boolean returnValue) {\n+        final Predicate<T> mockPredicate = EasyMock.createMock(Predicate.class);\n+        if (returnValue != null) {\n+            EasyMock.expect(mockPredicate.evaluate(testValue)).andReturn(returnValue);\n+        }\n+        replay(mockPredicate);\n+        mockPredicatesToVerify.add(mockPredicate);\n+\n+        return mockPredicate;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/TestAllPredicate.java\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+import static org.apache.commons.collections.functors.AllPredicate.allPredicate;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * Tests the org.apache.commons.collections.functors.AllPredicate class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 468603 $ $Date: 2006-10-27 17:52:37 -0700 (Fri, 27 Oct 2006) $\n+ *\n+ * @author Edwin Tellman\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestAllPredicate extends AbstractTestAnyAllOnePredicate<Integer> {\n+\n+    /**\n+     * Creates a new <code>TestAllPredicate</code>.\n+     */\n+    public TestAllPredicate() {\n+        super(42);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected final Predicate<Integer> getPredicateInstance(final Predicate<? super Integer> ... predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */    \n+    @Override\n+    protected final Predicate<Integer> getPredicateInstance(final Collection<Predicate<Integer>> predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * Verifies that providing an empty predicate array evaluates to true.\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    @Test\n+    public void emptyArrayToGetInstance() {\n+        assertTrue(\"empty array not true\", getPredicateInstance(new Predicate[] {}).evaluate(null));\n+    }\n+\n+    /**\n+     * Verifies that providing an empty predicate collection evaluates to true.\n+     */\n+    @Test\n+    public void emptyCollectionToGetInstance() {\n+        final Predicate<Integer> allPredicate = getPredicateInstance(\n+                Collections.<Predicate<Integer>>emptyList());\n+        assertTrue(\"empty collection not true\", allPredicate.evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether a single true predicate evaluates to true.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void oneTruePredicate() {\n+        // use the constructor directly, as getInstance() returns the original predicate when passed\n+        // an array of size one.\n+        final Predicate<Integer> predicate = createMockPredicate(true);\n+        \n+        assertTrue(\"single true predicate evaluated to false\",\n+                allPredicate(predicate).evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether a single false predicate evaluates to true.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void oneFalsePredicate() {\n+        // use the constructor directly, as getInstance() returns the original predicate when passed\n+        // an array of size one.\n+        final Predicate<Integer> predicate = createMockPredicate(false);\n+        assertFalse(\"single false predicate evaluated to true\",\n+                allPredicate(predicate).evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether multiple true predicates evaluates to true.\n+     */\n+    @Test\n+    public void allTrue() {\n+        assertTrue(\"multiple true predicates evaluated to false\",\n+                getPredicateInstance(true, true).evaluate(getTestValue()));\n+        assertTrue(\"multiple true predicates evaluated to false\",\n+                getPredicateInstance(true, true, true).evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether combining some true and one false evalutes to false.  Also verifies that only the first\n+     * false predicate is actually evaluated\n+     */\n+    @Test\n+    public void trueAndFalseCombined() {\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(false, null).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(false, null, null).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(true, false, null).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(true, true, false).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(true, true, false, null).evaluate(getTestValue()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/TestCatchAndRethrowClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.FunctorException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestCatchAndRethrowClosure extends BasicClosureTestBase {\n+\n+    private static <T> Closure<T> generateIOExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(T input) throws IOException  {\n+                throw new IOException();\n+            }\n+        };\n+    }\n+\n+    private static <T> Closure<T> generateNullPointerExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(T input) {\n+                throw new NullPointerException();\n+            }\n+        };\n+    }\n+\n+    private static <T> Closure<T> generateNoExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(T input) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected <T> Closure<T> generateClosure() {\n+        return generateNoExceptionClosure();\n+    }\n+    \n+    @Test\n+    public void testThrowingClosure() {\n+        Closure<Integer> closure = generateNoExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+        } catch (FunctorException ex) {\n+            Assert.fail();\n+        } catch (RuntimeException ex) {\n+            Assert.fail();\n+        }\n+        \n+        closure = generateIOExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+            Assert.fail();\n+        } catch (FunctorException ex) {\n+            Assert.assertTrue(ex.getCause() instanceof IOException);\n+        } catch (RuntimeException ex) {\n+            Assert.fail();\n+        }\n+\n+        closure = generateNullPointerExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+            Assert.fail();\n+        } catch (FunctorException ex) {\n+            Assert.fail();\n+        } catch (RuntimeException ex) {\n+            Assert.assertTrue(ex instanceof NullPointerException);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/TestComparatorPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import static org.apache.commons.collections.functors.ComparatorPredicate.*;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.junit.Test;\n+\n+\n+public class TestComparatorPredicate extends BasicPredicateTestBase {\n+    private class TestComparator<T extends Comparable<T>> implements Comparator<T> {\n+        public int compare(T first, T second) {\n+            return first.compareTo(second);\n+        }\n+    }\n+\n+    @Test\n+    public void compareEquals() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareGreater() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);\n+        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n+        assertFalse(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareLess() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertFalse(p, Integer.valueOf(value.intValue()));\n+        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareGreaterOrEqual() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n+        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareLessOrEqual() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+    \n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/TestEqualPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import static org.apache.commons.collections.functors.EqualPredicate.equalPredicate;\n+import static org.apache.commons.collections.functors.NullPredicate.nullPredicate;\n+import static org.junit.Assert.assertSame;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.junit.Test;\n+\n+\n+public class TestEqualPredicate extends BasicPredicateTestBase {\n+    private static final EqualsTestObject FALSE_OBJECT = new EqualsTestObject(false);\n+    private static final EqualsTestObject TRUE_OBJECT = new EqualsTestObject(true);\n+\n+    @Override\n+    protected Predicate<Object> generatePredicate() {\n+       return equalPredicate(null);\n+    }\n+    \n+    @Test\n+    public void testNullArgumentEqualsNullPredicate() throws Exception {\n+        assertSame(nullPredicate(), equalPredicate(null));\n+    }\n+    \n+    @Test\n+    public void objectFactoryUsesEqualsForTest() throws Exception {\n+        Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);\n+        assertFalse(predicate, FALSE_OBJECT);\n+        assertTrue(equalPredicate(TRUE_OBJECT), TRUE_OBJECT);\n+    }\n+    \n+    @SuppressWarnings(\"boxing\")\n+    @Test\n+    public void testPredicateTypeCanBeSuperClassOfObject() throws Exception {\n+        Predicate<Number> predicate = equalPredicate((Number) 4);\n+        assertTrue(predicate, 4);\n+    }\n+\n+    public static class EqualsTestObject {\n+        private final boolean b;\n+\n+        public EqualsTestObject(boolean b) {\n+            this.b = b;\n+        }\n+        \n+        @Override\n+        public boolean equals(Object obj) {\n+            return b;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/functors/TestNullPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import static org.apache.commons.collections.functors.NullPredicate.nullPredicate;\n+import static org.junit.Assert.assertSame;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.junit.Test;\n+\n+\n+public class TestNullPredicate extends BasicPredicateTestBase {\n+    @Test\n+    public void testNullPredicate() {\n+        assertSame(NullPredicate.nullPredicate(), NullPredicate.nullPredicate());\n+        assertTrue(nullPredicate(), null);\n+    }\n+    \n+    public void ensurePredicateCanBeTypedWithoutWarning() throws Exception {\n+        Predicate<String> predicate = NullPredicate.nullPredicate();\n+        assertFalse(predicate, cString);\n+    }\n+\n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return nullPredicate();\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractTestIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+\n+/**\n+ * Abstract class for testing the Iterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of Iterator.\n+ * Concrete subclasses must provide the iterator to be tested.\n+ * They must also specify certain details of how the iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestIterator<E> extends AbstractTestObject {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractTestIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return an iterator over an empty collection.\n+     * \n+     * @return an empty iterator\n+     */\n+    public abstract Iterator<E> makeEmptyIterator();\n+\n+    /**\n+     * Implements the abstract superclass method to return the full iterator.\n+     * \n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract Iterator<E> makeObject();\n+\n+    /**\n+     * Whether or not we are testing an iterator that can be empty.\n+     * Default is true.\n+     * \n+     * @return true if Iterator can be empty\n+     */\n+    public boolean supportsEmptyIterator() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether or not we are testing an iterator that can contain elements.\n+     * Default is true.\n+     * \n+     * @return true if Iterator can be full\n+     */\n+    public boolean supportsFullIterator() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports remove().\n+     * Default is true.\n+     * \n+     * @return true if Iterator supports remove\n+     */\n+    public boolean supportsRemove() {\n+        return true;\n+    }\n+\n+    /**\n+     * Allows subclasses to add complex cross verification\n+     */\n+    public void verify() {\n+        // do nothing\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test the empty iterator.\n+     */\n+    public void testEmptyIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        Iterator<E> it = makeEmptyIterator();\n+        \n+        // hasNext() should return false\n+        assertEquals(\"hasNext() should return false for empty iterators\", false, it.hasNext());\n+        \n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown when Iterator is exhausted\");\n+        } catch (NoSuchElementException e) {\n+        }\n+        verify();\n+        \n+        assertNotNull(it.toString());\n+    }\n+\n+    /**\n+     * Test normal iteration behaviour.\n+     */\n+    public void testFullIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        Iterator<E> it = makeObject();\n+\n+        // hasNext() must be true (ensure makeFullIterator is correct!)\n+        assertEquals(\"hasNext() should return true for at least one element\", true, it.hasNext());\n+\n+        // next() must not throw exception (ensure makeFullIterator is correct!)\n+        try {\n+            it.next();\n+        } catch (NoSuchElementException e) {\n+            fail(\"Full iterators must have at least one element\");\n+        }\n+\n+        // iterate through\n+        while (it.hasNext()) {\n+            it.next();\n+            verify();\n+        }\n+\n+        // next() must throw NoSuchElementException now\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown when Iterator is exhausted\");\n+        } catch (NoSuchElementException e) {\n+        }\n+        \n+        assertNotNull(it.toString());\n+    }\n+\n+    /**\n+     * Test remove behaviour.\n+     */\n+    public void testRemove() {\n+        Iterator<E> it = makeObject();\n+        \n+        if (supportsRemove() == false) {\n+            // check for UnsupportedOperationException if not supported\n+            try {\n+                it.remove();\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+        \n+        // should throw IllegalStateException before next() called\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        verify();\n+        \n+        // remove after next should be fine\n+        it.next();\n+        it.remove();\n+        \n+        // should throw IllegalStateException for second remove()\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractTestListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Abstract class for testing the ListIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of ListIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestListIterator<E> extends AbstractTestIterator<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractTestListIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements the abstract superclass method to return the list iterator.\n+     *\n+     * @return an empty iterator\n+     */\n+    @Override\n+    public abstract ListIterator<E> makeEmptyIterator();\n+\n+    /**\n+     * Implements the abstract superclass method to return the list iterator.\n+     *\n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract ListIterator<E> makeObject();\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports add().\n+     * Default is true.\n+     *\n+     * @return true if Iterator supports add\n+     */\n+    public boolean supportsAdd() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports set().\n+     * Default is true.\n+     *\n+     * @return true if Iterator supports set\n+     */\n+    public boolean supportsSet() {\n+        return true;\n+    }\n+\n+    /**\n+     * The value to be used in the add and set tests.\n+     * Default is null.\n+     */\n+    public E addSetValue() {\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    public void testEmptyListIteratorIsIndeedEmpty() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        ListIterator<E> it = makeEmptyIterator();\n+\n+        assertEquals(false, it.hasNext());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+\n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (NoSuchElementException e) {\n+        }\n+\n+        // previous() should throw a NoSuchElementException\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (NoSuchElementException e) {\n+        }\n+    }\n+\n+    /**\n+     * Test navigation through the iterator.\n+     */\n+    public void testWalkForwardAndBack() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        ListIterator<E> it = makeObject();\n+        while (it.hasNext()) {\n+            list.add(it.next());\n+        }\n+\n+        // check state at end\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n+        } catch (NoSuchElementException e) {\n+        }\n+\n+        // loop back through comparing\n+        for (int i = list.size() - 1; i >= 0; i--) {\n+            assertEquals(i + 1, it.nextIndex());\n+            assertEquals(i, it.previousIndex());\n+\n+            Object obj = list.get(i);\n+            assertEquals(obj, it.previous());\n+        }\n+\n+        // check state at start\n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from previous at start of ListIterator\");\n+        } catch (NoSuchElementException e) {\n+        }\n+    }\n+\n+    /**\n+     * Test add behaviour.\n+     */\n+    public void testAdd() {\n+        ListIterator<E> it = makeObject();\n+\n+        E addValue = addSetValue();\n+        if (supportsAdd() == false) {\n+            // check for UnsupportedOperationException if not supported\n+            try {\n+                it.add(addValue);\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        // add at start should be OK, added should be previous\n+        it = makeObject();\n+        it.add(addValue);\n+        assertEquals(addValue, it.previous());\n+\n+        // add at start should be OK, added should not be next\n+        it = makeObject();\n+        it.add(addValue);\n+        assertTrue(addValue != it.next());\n+\n+        // add in middle and at end should be OK\n+        it = makeObject();\n+        while (it.hasNext()) {\n+            it.next();\n+            it.add(addValue);\n+            // check add OK\n+            assertEquals(addValue, it.previous());\n+            it.next();\n+        }\n+    }\n+\n+    /**\n+     * Test set behaviour.\n+     */\n+    public void testSet() {\n+        ListIterator<E> it = makeObject();\n+\n+        if (supportsSet() == false) {\n+            // check for UnsupportedOperationException if not supported\n+            try {\n+                it.set(addSetValue());\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        // should throw IllegalStateException before next() called\n+        try {\n+            it.set(addSetValue());\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+\n+        // set after next should be fine\n+        it.next();\n+        it.set(addSetValue());\n+\n+        // repeated set calls should be fine\n+        it.set(addSetValue());\n+\n+    }\n+\n+    public void testRemoveThenSet() {\n+        ListIterator<E> it = makeObject();\n+        if (supportsRemove() && supportsSet()) {\n+            it.next();\n+            it.remove();\n+            try {\n+                it.set(addSetValue());\n+                fail(\"IllegalStateException must be thrown from set after remove\");\n+            } catch (IllegalStateException e) {\n+            }\n+        }\n+    }\n+\n+    public void testAddThenSet() {\n+        ListIterator<E> it = makeObject();\n+        // add then set\n+        if (supportsAdd() && supportsSet()) {\n+            it.next();\n+            it.add(addSetValue());\n+            try {\n+                it.set(addSetValue());\n+                fail(\"IllegalStateException must be thrown from set after add\");\n+            } catch (IllegalStateException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test remove after add behaviour.\n+     */\n+    public void testAddThenRemove() {\n+        ListIterator<E> it = makeObject();\n+\n+        // add then remove\n+        if (supportsAdd() && supportsRemove()) {\n+            it.next();\n+            it.add(addSetValue());\n+            try {\n+                it.remove();\n+                fail(\"IllegalStateException must be thrown from remove after add\");\n+            } catch (IllegalStateException e) {\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractTestMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.MapIterator;\n+\n+/**\n+ * Abstract class for testing the MapIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of MapIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestMapIterator<K, V> extends AbstractTestIterator<K> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractTestMapIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return a map iterator over an empty map.\n+     *\n+     * @return an empty iterator\n+     */\n+    @Override\n+    public abstract MapIterator<K, V> makeEmptyIterator();\n+\n+    /**\n+     * Implement this method to return a map iterator over a map with elements.\n+     *\n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract MapIterator<K, V> makeObject();\n+\n+    /**\n+     * Implement this method to return the map which contains the same data as the\n+     * iterator.\n+     *\n+     * @return a full map which can be updated\n+     */\n+    public abstract Map<K, V> getMap();\n+\n+    /**\n+     * Implement this method to return the confirmed map which contains the same\n+     * data as the iterator.\n+     *\n+     * @return a full map which can be updated\n+     */\n+    public abstract Map<K, V> getConfirmedMap();\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports setValue().\n+     * Default is true.\n+     *\n+     * @return true if Iterator supports set\n+     */\n+    public boolean supportsSetValue() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether the get operation on the map structurally modifies the map,\n+     * such as with LRUMap. Default is false.\n+     *\n+     * @return true if the get method structurally modifies the map\n+     */\n+    public boolean isGetStructuralModify() {\n+        return false;\n+    }\n+\n+    /**\n+     * The values to be used in the add and set tests.\n+     * Default is two strings.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] addSetValues() {\n+        return (V[]) new Object[] { \"A\", \"B\" };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    public void testEmptyMapIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        MapIterator<K, V> it = makeEmptyIterator();\n+        assertEquals(false, it.hasNext());\n+\n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        // getKey() should throw an IllegalStateException\n+        try {\n+            it.getKey();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+\n+        // getValue() should throw an IllegalStateException\n+        try {\n+            it.getValue();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+\n+        if (supportsSetValue() == false) {\n+            // setValue() should throw an UnsupportedOperationException/IllegalStateException\n+            try {\n+                it.setValue(addSetValues()[0]);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            } catch (IllegalStateException ex) {}\n+        } else {\n+            // setValue() should throw an IllegalStateException\n+            try {\n+                it.setValue(addSetValues()[0]);\n+                fail();\n+            } catch (IllegalStateException ex) {}\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the full list iterator contract is correct.\n+     */\n+    public void testFullMapIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+        assertEquals(true, it.hasNext());\n+\n+        assertEquals(true, it.hasNext());\n+        Set<K> set = new HashSet<K>();\n+        while (it.hasNext()) {\n+            // getKey\n+            K key = it.next();\n+            assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.add(key));\n+\n+            // getValue\n+            V value = it.getValue();\n+            if (isGetStructuralModify() == false) {\n+                assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            }\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+\n+            verify();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorSet() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        V newValue = addSetValues()[0];\n+        V newValue2 = (addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1]);\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+        Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+        V value = it.getValue();\n+\n+        if (supportsSetValue() == false) {\n+            try {\n+                it.setValue(newValue);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+        V old = it.setValue(newValue);\n+        confirmed.put(key, newValue);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        assertSame(\"setValue must return old value\", value, old);\n+        assertEquals(\"Map must contain key\", true, map.containsKey(key));\n+        // test against confirmed, as map may contain value twice\n+        assertEquals(\"Map must not contain old value\",\n+            confirmed.containsValue(old), map.containsValue(old));\n+        assertEquals(\"Map must contain new value\", true, map.containsValue(newValue));\n+        verify();\n+\n+        it.setValue(newValue);  // same value - should be OK\n+        confirmed.put(key, newValue);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        verify();\n+\n+        it.setValue(newValue2);  // new value\n+        confirmed.put(key, newValue2);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue2, it.getValue());\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testRemove() { // override\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+        Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n+        if (supportsRemove() == false) {\n+            try {\n+                it.remove();\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+\n+        it.remove();\n+        confirmed.remove(key);\n+        assertEquals(false, map.containsKey(key));\n+        verify();\n+\n+        try {\n+            it.remove();  // second remove fails\n+        } catch (IllegalStateException ex) {\n+        }\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorSetRemoveSet() {\n+        if (supportsSetValue() == false || supportsRemove() == false) {\n+            return;\n+        }\n+        V newValue = addSetValues()[0];\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n+        it.setValue(newValue);\n+        it.remove();\n+        confirmed.remove(key);\n+        verify();\n+\n+        try {\n+            it.setValue(newValue);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorRemoveGetKey() {\n+        if (supportsRemove() == false) {\n+            return;\n+        }\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n+        it.remove();\n+        confirmed.remove(key);\n+        verify();\n+\n+        try {\n+            it.getKey();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorRemoveGetValue() {\n+        if (supportsRemove() == false) {\n+            return;\n+        }\n+        MapIterator<K, V> it = makeObject();\n+        Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        K key = it.next();\n+\n+        it.remove();\n+        confirmed.remove(key);\n+        verify();\n+\n+        try {\n+            it.getValue();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        verify();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractTestOrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.OrderedMapIterator;\n+\n+/**\n+ * Abstract class for testing the OrderedMapIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of MapIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestOrderedMapIterator<K, V> extends AbstractTestMapIterator<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractTestOrderedMapIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public abstract OrderedMapIterator<K, V> makeEmptyIterator();\n+\n+    @Override\n+    public abstract OrderedMapIterator<K, V> makeObject();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    @Override\n+    public void testEmptyMapIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        super.testEmptyMapIterator();\n+\n+        OrderedMapIterator<K, V> it = makeEmptyIterator();\n+        assertEquals(false, it.hasPrevious());\n+        try {\n+            it.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the full list iterator contract is correct.\n+     */\n+    @Override\n+    public void testFullMapIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        super.testFullMapIterator();\n+\n+        OrderedMapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        Set<K> set = new HashSet<K>();\n+        while (it.hasNext()) {\n+            // getKey\n+            K key = it.next();\n+            assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.add(key));\n+\n+            // getValue\n+            V value = it.getValue();\n+            if (isGetStructuralModify() == false) {\n+                assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            }\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+\n+            assertEquals(true, it.hasPrevious());\n+\n+            verify();\n+        }\n+        while (it.hasPrevious()) {\n+            // getKey\n+            Object key = it.previous();\n+            assertSame(\"it.previous() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.remove(key));\n+\n+            // getValue\n+            Object value = it.getValue();\n+            if (isGetStructuralModify() == false) {\n+                assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            }\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+\n+            assertEquals(true, it.hasNext());\n+\n+            verify();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the iterator order matches the keySet order.\n+     */\n+    public void testMapIteratorOrder() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        OrderedMapIterator<K, V> it = makeObject();\n+        Map<K, V> map = getMap();\n+\n+        assertEquals(\"keySet() not consistent\", new ArrayList<K>(map.keySet()), new ArrayList<K>(map.keySet()));\n+\n+        Iterator<K> it2 = map.keySet().iterator();\n+        assertEquals(true, it.hasNext());\n+        assertEquals(true, it2.hasNext());\n+        List<K> list = new ArrayList<K>();\n+        while (it.hasNext()) {\n+            K key = it.next();\n+            assertEquals(it2.next(), key);\n+            list.add(key);\n+        }\n+        assertEquals(map.size(), list.size());\n+        while (it.hasPrevious()) {\n+            K key = it.previous();\n+            assertEquals(list.get(list.size() - 1), key);\n+            list.remove(list.size() - 1);\n+        }\n+        assertEquals(0, list.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestArrayIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Tests the ArrayIterator to ensure that the next() method will actually\n+ * perform the iteration rather than the hasNext() method.\n+ * The code of this test was supplied by Mauricio S. Moura.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Mauricio S. Moura\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ */\n+public class TestArrayIterator<E> extends AbstractTestIterator<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+\n+    public TestArrayIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeEmptyIterator() {\n+        return new ArrayIterator<E>(new Object[0]);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeObject() {\n+        return new ArrayIterator<E>(testArray);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    public void testIterator() {\n+        Iterator<E> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+\n+    public void testNullArray() {\n+        try {\n+            new ArrayIterator<Object>(null);\n+            fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+\n+        ArrayIterator<Object> iter = new ArrayIterator<Object>();\n+        try {\n+            iter.setArray(null);\n+\n+            fail(\"setArray(null) should throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testReset() {\n+        ArrayIterator<E> it = makeObject();\n+        it.next();\n+        it.reset();\n+        assertEquals(\"One\", it.next());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestArrayIterator2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Tests the ArrayIterator with primitive type arrays.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Morgan Delagrange\n+ * @author James Strachan\n+ */\n+public class TestArrayIterator2<E> extends AbstractTestIterator<E> {\n+\n+    protected int[] testArray = { 2, 4, 6, 8 };\n+\n+    public TestArrayIterator2(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeEmptyIterator() {\n+        return new ArrayIterator<E>(new int[0]);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeObject() {\n+        return new ArrayIterator<E>(testArray);\n+    }\n+\n+    public ArrayIterator<E> makeArrayIterator(Object array) {\n+        return new ArrayIterator<E>(array);\n+    }\n+\n+    public ArrayIterator<E> makeArrayIterator(Object array, int index) {\n+        return new ArrayIterator<E>(array, index);\n+    }\n+\n+    public ArrayIterator<E> makeArrayIterator(Object array, int start, int end) {\n+        return new ArrayIterator<E>(array, start, end);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    public void testIterator() {\n+        Iterator<E> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n+            Integer testValue = new Integer(testArray[i]);\n+            Number iterValue = (Number) iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+\n+    // proves that an ArrayIterator set with the constructor has the same number of elements\n+    // as an ArrayIterator set with setArray(Object)\n+    public void testSetArray() {\n+        Iterator<E> iter1 = makeArrayIterator(testArray);\n+        int count1 = 0;\n+        while (iter1.hasNext()) {\n+            ++count1;\n+            iter1.next();\n+        }\n+\n+        assertEquals(\"the count should be right using the constructor\", count1, testArray.length);\n+\n+        ArrayIterator<E> iter2 = makeObject();\n+        iter2.setArray(testArray);\n+        int count2 = 0;\n+        while (iter2.hasNext()) {\n+            ++count2;\n+            iter2.next();\n+        }\n+\n+        assertEquals(\"the count should be right using setArray(Object)\", count2, testArray.length);\n+    }\n+\n+    public void testIndexedArray() {\n+        Iterator<E> iter = makeArrayIterator(testArray, 2);\n+        int count = 0;\n+        while (iter.hasNext()) {\n+            ++count;\n+            iter.next();\n+        }\n+\n+        assertEquals(\"the count should be right using ArrayIterator(Object,2) \", count, testArray.length - 2);\n+\n+        iter = makeArrayIterator(testArray, 1, testArray.length - 1);\n+        count = 0;\n+        while (iter.hasNext()) {\n+            ++count;\n+            iter.next();\n+        }\n+\n+        assertEquals(\n+            \"the count should be right using ArrayIterator(Object,1,\" + (testArray.length - 1) + \") \",\n+            count,\n+            testArray.length - 2);\n+\n+        try {\n+            iter = makeArrayIterator(testArray, -1);\n+            fail(\"new ArrayIterator(Object,-1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, testArray.length + 1);\n+            fail(\"new ArrayIterator(Object,length+1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, 0, -1);\n+            fail(\"new ArrayIterator(Object,0,-1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, 0, testArray.length + 1);\n+            fail(\"new ArrayIterator(Object,0,length+1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, 1, 1);\n+            // expected not to fail\n+        } catch (IllegalArgumentException iae) {\n+            // MODIFIED: an iterator over a zero-length section of array\n+            //  should be perfectly legal behavior\n+            fail(\"new ArrayIterator(Object,1,1) should NOT throw an IllegalArgumentException\");\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, testArray.length - 1, testArray.length - 2);\n+            fail(\"new ArrayIterator(Object,length-2,length-1) should throw an IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestArrayListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Arrays;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Test the ArrayListIterator class.\n+ *\n+ * @version $Revision$ $Date$\n+ * @author Neil O'Toole\n+ */\n+public class TestArrayListIterator<E> extends TestArrayIterator<E> {\n+\n+    public TestArrayListIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeEmptyIterator() {\n+        return new ArrayListIterator<E>(new Object[0]);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeObject() {\n+        return new ArrayListIterator<E>(testArray);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(Object array) {\n+        return new ArrayListIterator<E>(array);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    /**\n+     * Test the basic ListIterator functionality - going backwards using\n+     * <code>previous()</code>.\n+     */\n+    public void testListIterator() {\n+        ListIterator<E> iter = makeObject();\n+\n+        // TestArrayIterator#testIterator() has already tested the iterator forward,\n+        //  now we need to test it in reverse\n+\n+        // fast-forward the iterator to the end...\n+        while (iter.hasNext()) {\n+            iter.next();\n+        }\n+\n+        for (int x = testArray.length - 1; x >= 0; x--) {\n+            Object testValue = testArray[x];\n+            Object iterValue = iter.previous();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasPrevious());\n+\n+        try {\n+            iter.previous();\n+        } catch (Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+\n+    }\n+\n+    /**\n+     * Tests the {@link java.util.ListIterator#set} operation.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorSet() {\n+        String[] testData = new String[] { \"a\", \"b\", \"c\" };\n+\n+        String[] result = new String[] { \"0\", \"1\", \"2\" };\n+\n+        ListIterator<E> iter = makeArrayListIterator(testData);\n+        int x = 0;\n+\n+        while (iter.hasNext()) {\n+            iter.next();\n+            iter.set((E) Integer.toString(x));\n+            x++;\n+        }\n+\n+        assertTrue(\"The two arrays should have the same value, i.e. {0,1,2}\", Arrays.equals(testData, result));\n+\n+        // a call to set() before a call to next() or previous() should throw an IllegalStateException\n+        iter = makeArrayListIterator(testArray);\n+\n+        try {\n+            iter.set((E) \"should fail\");\n+            fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        } catch (Throwable t) { // should never happen\n+            fail(t.toString());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestArrayListIterator2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+/**\n+ * Test the ArrayListIterator class with primitives.\n+ *\n+ * @version $Revision$ $Date$\n+ * @author Neil O'Toole\n+ */\n+public class TestArrayListIterator2<E> extends TestArrayIterator2<E> {\n+\n+    public TestArrayListIterator2(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeEmptyIterator() {\n+        return new ArrayListIterator<E>(new int[0]);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeObject() {\n+        return new ArrayListIterator<E>(testArray);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(Object array) {\n+        return new ArrayListIterator<E>(array);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(Object array, int index) {\n+        return new ArrayListIterator<E>(array, index);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(Object array, int start, int end) {\n+        return new ArrayListIterator<E>(array, start, end);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestCollatingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+\n+/**\n+ * Unit test suite for {@link CollatingIterator}.\n+ *\n+ * @version $Revision$ $Date$\n+ * @author Rodney Waldhoff\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestCollatingIterator extends AbstractTestIterator<Integer> {\n+\n+    //------------------------------------------------------------ Conventional\n+\n+    public TestCollatingIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    //--------------------------------------------------------------- Lifecycle\n+\n+    private Comparator<Integer> comparator = null;\n+    private ArrayList<Integer> evens = null;\n+    private ArrayList<Integer> odds = null;\n+    private ArrayList<Integer> fib = null;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        comparator = new ComparableComparator<Integer>();\n+        evens = new ArrayList<Integer>();\n+        odds = new ArrayList<Integer>();\n+        for (int i = 0; i < 20; i++) {\n+            if (0 == i % 2) {\n+                evens.add(i);\n+            } else {\n+                odds.add(i);\n+            }\n+        }\n+        fib = new ArrayList<Integer>();\n+        fib.add(1);\n+        fib.add(1);\n+        fib.add(2);\n+        fib.add(3);\n+        fib.add(5);\n+        fib.add(8);\n+        fib.add(13);\n+        fib.add(21);\n+    }\n+\n+    //---------------------------------------------------- TestIterator Methods\n+\n+    @Override\n+    public CollatingIterator<Integer> makeEmptyIterator() {\n+        return new CollatingIterator<Integer>(comparator);\n+    }\n+\n+    @Override\n+    public CollatingIterator<Integer> makeObject() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(odds.iterator());\n+        iter.addIterator(fib.iterator());\n+        return iter;\n+    }\n+\n+    //------------------------------------------------------------------- Tests\n+\n+    public void testGetSetComparator() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>();\n+        assertNull(iter.getComparator());\n+        iter.setComparator(comparator);\n+        assertSame(comparator, iter.getComparator());\n+        iter.setComparator(null);\n+        assertNull(iter.getComparator());\n+    }\n+\n+    public void testIterateEven() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        for (int i = 0; i < evens.size(); i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n+            assertEquals(0,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateEvenOdd() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, evens.iterator(), odds.iterator());\n+        for (int i = 0; i < 20; i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(new Integer(i), iter.next());\n+            assertEquals(i % 2,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateOddEven() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, odds.iterator(), evens.iterator());\n+        for (int i = 0; i < 20; i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(new Integer(i),iter.next());\n+            assertEquals((i % 2) == 0 ? 1 : 0,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateEvenEven() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(evens.iterator());\n+        for (int i = 0; i < evens.size(); i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n+            assertEquals(0,iter.getIteratorIndex());\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n+            assertEquals(1,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateFibEvenOdd() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(fib.iterator());\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(odds.iterator());\n+\n+        assertEquals(new Integer(0),iter.next());  // even   0\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(1),iter.next());  // fib    1\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(1),iter.next());  // fib    1\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(1),iter.next());  // odd    1\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(2),iter.next());  // fib    2\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(2),iter.next());  // even   2\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(3),iter.next());  // fib    3\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(3),iter.next());  // odd    3\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(4),iter.next());  // even   4\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(5),iter.next());  // fib    5\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(5),iter.next());  // odd    5\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(6),iter.next());  // even   6\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(7),iter.next());  // odd    7\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(8),iter.next());  // fib    8\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(8),iter.next());  // even   8\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(9),iter.next());  // odd    9\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(10),iter.next()); // even  10\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(11),iter.next()); // odd   11\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(12),iter.next()); // even  12\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(13),iter.next()); // fib   13\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(13),iter.next()); // odd   13\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(14),iter.next()); // even  14\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(15),iter.next()); // odd   15\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(16),iter.next()); // even  16\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(17),iter.next()); // odd   17\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(18),iter.next()); // even  18\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(19),iter.next()); // odd   19\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(21),iter.next()); // fib   21\n+        assertEquals(0,iter.getIteratorIndex());\n+\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testRemoveFromSingle() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        int expectedSize = evens.size();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            Integer val = (Integer) o;\n+            if (val.intValue() % 4 == 0) {\n+                expectedSize--;\n+                iter.remove();\n+            }\n+        }\n+        assertEquals(expectedSize,evens.size());\n+    }\n+\n+    public void testRemoveFromDouble() {\n+        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(odds.iterator());\n+        int expectedSize = evens.size() + odds.size();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            Integer val = (Integer) o;\n+            if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {\n+                expectedSize--;\n+                iter.remove();\n+            }\n+        }\n+        assertEquals(expectedSize, (evens.size() + odds.size()));\n+    }\n+\n+    public void testNullComparator() {\n+       List<Integer> l1 = Arrays.asList(1, 3, 5);\n+       List<Integer> l2 = Arrays.asList(2, 4, 6);\n+\n+       CollatingIterator<Integer> collatingIterator1 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n+       try {\n+           collatingIterator1.next();\n+       } catch (NullPointerException e) {\n+           assertTrue(e.getMessage().startsWith(\"You must invoke setComparator\"));\n+       }\n+\n+       int i = 0;\n+       CollatingIterator<Integer> collatingIterator2 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n+       collatingIterator2.setComparator(new ComparableComparator<Integer>());\n+       for ( ; collatingIterator2.hasNext(); i++ ) {\n+          Integer n = (Integer)collatingIterator2.next();\n+          assertEquals(\"wrong order\", (int)n, i + 1);\n+       }\n+       assertEquals(\"wrong size\", i, l1.size() + l2.size());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestFilterIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import static org.apache.commons.collections.functors.TruePredicate.truePredicate;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.NotNullPredicate;\n+\n+/**\n+ * Test the filter iterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Jan Sorensen\n+ * @author Ralph Wagner\n+ * @author Huw Roberts\n+ */\n+public class TestFilterIterator<E> extends AbstractTestIterator<E> {\n+\n+    /** Creates new TestFilterIterator */\n+    public TestFilterIterator(String name) {\n+        super(name);\n+    }\n+\n+    private String[] array;\n+    private List<E> list;\n+    private FilterIterator<E> iterator;\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+        array = new String[] { \"a\", \"b\", \"c\" };\n+        initIterator();\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() throws Exception {\n+        iterator = null;\n+    }\n+\n+    /**\n+     * Returns an full iterator wrapped in a\n+     * FilterIterator that blocks all the elements\n+     *\n+     * @return \"empty\" FilterIterator\n+     */\n+    @Override\n+    public FilterIterator<E> makeEmptyIterator() {\n+        return makeBlockAllFilter(new ArrayIterator<E>(array));\n+    }\n+\n+    /**\n+     * Returns an array with elements wrapped in a pass-through\n+     * FilterIterator\n+     * \n+     * @return a filtered iterator\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public FilterIterator<E> makeObject() {\n+        list = new ArrayList<E>(Arrays.asList((E[]) array));\n+        return makePassThroughFilter(list.iterator());\n+    }\n+\n+    public void testRepeatedHasNext() {\n+        for (int i = 0; i <= array.length; i++) {\n+            assertTrue(iterator.hasNext());\n+        }\n+    }\n+\n+    public void testRepeatedNext() {\n+        for (int i = 0; i < array.length; i++) {\n+            iterator.next();\n+        }\n+        verifyNoMoreElements();\n+    }\n+\n+    public void testReturnValues() {\n+        verifyElementsInPredicate(new String[0]);\n+        verifyElementsInPredicate(new String[] { \"a\" });\n+        verifyElementsInPredicate(new String[] { \"b\" });\n+        verifyElementsInPredicate(new String[] { \"c\" });\n+        verifyElementsInPredicate(new String[] { \"a\", \"b\" });\n+        verifyElementsInPredicate(new String[] { \"a\", \"c\" });\n+        verifyElementsInPredicate(new String[] { \"b\", \"c\" });\n+        verifyElementsInPredicate(new String[] { \"a\", \"b\", \"c\" });\n+    }\n+\n+    /**\n+     * Test that when the iterator is changed, the hasNext method returns the\n+     * correct response for the new iterator.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetIterator() {\n+        Iterator<E> iter1 = Collections.singleton((E) new Object()).iterator();\n+        Iterator<E> iter2 = Collections.<E>emptyList().iterator();\n+\n+        FilterIterator<E> filterIterator = new FilterIterator<E>(iter1);\n+        filterIterator.setPredicate(truePredicate());\n+        // this iterator has elements\n+        assertEquals(true, filterIterator.hasNext());\n+\n+        // this iterator has no elements\n+        filterIterator.setIterator(iter2);\n+        assertEquals(false, filterIterator.hasNext());\n+    }\n+\n+    /**\n+     * Test that when the predicate is changed, the hasNext method returns the\n+     * correct response for the new predicate.\n+     */\n+    public void testSetPredicate() {\n+        Iterator<E> iter = Collections.singleton((E) null).iterator();\n+\n+        FilterIterator<E> filterIterator = new FilterIterator<E>(iter);\n+        filterIterator.setPredicate(truePredicate());\n+        // this predicate matches\n+        assertEquals(true, filterIterator.hasNext());\n+\n+        // this predicate doesn't match\n+        filterIterator.setPredicate(NotNullPredicate.notNullPredicate());\n+        assertEquals(false, filterIterator.hasNext());\n+    }\n+\n+    private void verifyNoMoreElements() {\n+        assertTrue(!iterator.hasNext());\n+        try {\n+            iterator.next();\n+            fail(\"NoSuchElementException expected\");\n+        }\n+        catch (NoSuchElementException e) {\n+            // success\n+        }\n+    }\n+\n+    private void verifyElementsInPredicate(final String[] elements) {\n+        Predicate<E> pred = new Predicate<E>() {\n+            public boolean evaluate(E x) {\n+                for (int i = 0; i < elements.length; i++) {\n+                    if (elements[i].equals(x)) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }\n+        };\n+        initIterator();\n+        iterator.setPredicate(pred);\n+        for (int i = 0; i < elements.length; i++) {\n+            String s = (String)iterator.next();\n+            assertEquals(elements[i], s);\n+            assertTrue(i == elements.length - 1 ? !iterator.hasNext() : iterator.hasNext());\n+        }\n+        verifyNoMoreElements();\n+\n+        // test removal\n+        initIterator();\n+        iterator.setPredicate(pred);\n+        if (iterator.hasNext()) {\n+            Object last = iterator.next();\n+            iterator.remove();\n+            assertTrue(\"Base of FilterIterator still contains removed element.\", !list.contains(last));\n+        }\n+    }\n+\n+    private void initIterator() {\n+        iterator = makeObject();\n+    }\n+\n+    /**\n+     * Returns a FilterIterator that does not filter\n+     * any of its elements\n+     *\n+     * @param i      the Iterator to \"filter\"\n+     * @return \"filtered\" iterator\n+     */\n+    protected FilterIterator<E> makePassThroughFilter(Iterator<E> i) {\n+        Predicate<E> pred = new Predicate<E>() {\n+                public boolean evaluate(E x) { return true; }\n+        };\n+        return new FilterIterator<E>(i, pred);\n+    }\n+\n+    /**\n+     * Returns a FilterIterator that blocks\n+     * all of its elements\n+     *\n+     * @param i      the Iterator to \"filter\"\n+     * @return \"filtered\" iterator\n+     */\n+    protected FilterIterator<E> makeBlockAllFilter(Iterator<E> i) {\n+        Predicate<E> pred = new Predicate<E>() {\n+                public boolean evaluate(E x) { return false; }\n+        };\n+        return new FilterIterator<E>(i, pred);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestFilterListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Random;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.PredicateUtils;\n+import org.apache.commons.collections.list.GrowthList;\n+import org.junit.Assert;\n+\n+/**\n+ * Tests the FilterListIterator class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestFilterListIterator extends TestCase {\n+    public TestFilterListIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    private ArrayList<Integer> list = null;\n+    private ArrayList<Integer> odds = null;\n+    private ArrayList<Integer> evens = null;\n+    private ArrayList<Integer> threes = null;\n+    private ArrayList<Integer> fours = null;\n+    private ArrayList<Integer> sixes = null;\n+    private Predicate<Integer> truePred = null;\n+    private Predicate<Integer> falsePred = null;\n+    private Predicate<Integer> evenPred = null;\n+    private Predicate<Integer> oddPred = null;\n+    private Predicate<Integer> threePred = null;\n+    private Predicate<Integer> fourPred = null;\n+    private Random random = new Random();\n+\n+    @Override\n+    public void setUp() {\n+        list = new ArrayList<Integer>();\n+        odds = new ArrayList<Integer>();\n+        evens = new ArrayList<Integer>();\n+        threes = new ArrayList<Integer>();\n+        fours = new ArrayList<Integer>();\n+        sixes = new ArrayList<Integer>();\n+        for (int i = 0; i < 20; i++) {\n+            list.add(new Integer(i));\n+            if (i % 2 == 0) { evens.add(new Integer(i)); }\n+            if (i % 2 == 1) { odds.add(new Integer(i)); }\n+            if (i % 3 == 0) { threes.add(new Integer(i)); }\n+            if (i % 4 == 0) { fours.add(new Integer(i)); }\n+            if (i % 6 == 0) { sixes.add(new Integer(i)); }\n+        }\n+\n+        truePred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return true;\n+            }\n+        };\n+\n+        falsePred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return true;\n+            }\n+        };\n+\n+        evenPred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 2 == 0;\n+            }\n+        };\n+\n+        oddPred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 2 == 1;\n+            }\n+        };\n+\n+        threePred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 3 == 0;\n+            }\n+        };\n+\n+        fourPred = new Predicate<Integer>() {\n+            public boolean evaluate(Integer x) { \n+                return x % 4 == 0;\n+            }\n+        };\n+\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        list = null;\n+        odds = null;\n+        evens = null;\n+        threes = null;\n+        fours = null;\n+        sixes = null;\n+        truePred = null;\n+        falsePred = null;\n+        evenPred = null;\n+        oddPred = null;\n+        threePred = null;\n+        fourPred = null;\n+    }\n+\n+    public void testWalkLists() {\n+        // this just confirms that our walkLists method works OK\n+        walkLists(list,list.listIterator());\n+    }\n+\n+    public void testManual() {\n+        // do this one \"by hand\" as a sanity check\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+        \n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(18), filtered.next());\n+\n+        assertEquals(new Integer(18), filtered.previous());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(0), filtered.previous());\n+    \n+        assertTrue(!filtered.hasPrevious());\n+\n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(18), filtered.next());\n+\n+        assertTrue(!filtered.hasNext());\n+\n+        assertEquals(new Integer(18), filtered.previous());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(0), filtered.previous());\n+\n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(0), filtered.previous());\n+        assertEquals(new Integer(0), filtered.next());\n+\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+    }\n+\n+    public void testTruePredicate() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+        walkLists(list, filtered);\n+    }\n+    \n+    public void testFalsePredicate() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), falsePred);\n+        walkLists(new ArrayList<Integer>(), filtered);\n+    }\n+\n+    public void testEvens() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), evenPred);\n+        walkLists(evens, filtered);\n+    }\n+    \n+    public void testOdds() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), oddPred);\n+        walkLists(odds, filtered);\n+    }\n+\n+    public void testThrees() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+        walkLists(threes, filtered);\n+    }\n+\n+    public void testFours() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        walkLists(fours, filtered);\n+    }\n+\n+    public void testNestedSixes() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), threePred),\n+                                        evenPred\n+                                      );\n+        walkLists(sixes, filtered);\n+    }\n+\n+    public void testNestedSixes2() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), evenPred),\n+                                        threePred\n+                                      );\n+        walkLists(sixes, filtered);\n+    }\n+\n+    public void testNestedSixes3() {        \n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), threePred),\n+                                        evenPred\n+                                      );\n+        walkLists(sixes, new FilterListIterator<Integer>(filtered, truePred));\n+    }\n+\n+    public void testNextChangesPrevious() {\n+        {\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            nextNextPrevious(threes.listIterator(), filtered);\n+        }\n+    \n+        {\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            nextNextPrevious(list.listIterator(), filtered);\n+        }\n+    }\n+\n+    public void testPreviousChangesNext() {\n+        {\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            ListIterator<Integer> expected = threes.listIterator();\n+            walkForward(expected,filtered);\n+            previousPreviousNext(expected,filtered);\n+        }\n+        {\n+            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            ListIterator<Integer> expected = list.listIterator();\n+            walkForward(expected, filtered);\n+            previousPreviousNext(expected, filtered);\n+        }\n+    }\n+\n+    public void testFailingHasNextBug() {\n+        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        ListIterator<Integer> expected = fours.listIterator();\n+        while (expected.hasNext()) {\n+            expected.next();\n+            filtered.next();\n+        }\n+        assertTrue(filtered.hasPrevious());\n+        assertTrue(!filtered.hasNext());\n+        assertEquals(expected.previous(), filtered.previous());\n+    }\n+\n+    /**\n+     * Test for {@link https://issues.apache.org/jira/browse/COLLECTIONS-360 COLLECTIONS-360}.\n+     */\n+    public void testCollections360() throws Throwable {\n+        Collection<Predicate<Object>> var7 = new GrowthList<Predicate<Object>>();\n+        Predicate<Object> var9 = PredicateUtils.anyPredicate(var7);\n+        FilterListIterator<Object> var13 = new FilterListIterator<Object>(var9);\n+        Assert.assertFalse(var13.hasNext());\n+        FilterListIterator<Object> var14 = new FilterListIterator<Object>(var9);\n+        Assert.assertFalse(var14.hasPrevious());\n+    }\n+\n+    // Utilities\n+\n+    private void walkForward(ListIterator<?> expected, ListIterator<?> testing) {\n+        while (expected.hasNext()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n+            assertTrue(testing.hasNext());\n+            assertEquals(expected.next(), testing.next());\n+        }\n+    }\n+\n+    private void walkBackward(ListIterator<?> expected, ListIterator<?> testing) {\n+        while (expected.hasPrevious()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n+            assertTrue(testing.hasPrevious());\n+            assertEquals(expected.previous(), testing.previous());\n+        }\n+    }\n+\n+    private void nextNextPrevious(ListIterator<?> expected, ListIterator<?> testing) {\n+        // calls to next() should change the value returned by previous()\n+        // even after previous() has been set by a call to hasPrevious()\n+        assertEquals(expected.next(), testing.next());\n+        assertEquals(expected.hasPrevious(), testing.hasPrevious());\n+        Object expecteda = expected.next();\n+        Object testinga = testing.next();\n+        assertEquals(expecteda, testinga);\n+        Object expectedb = expected.previous();\n+        Object testingb = testing.previous();\n+        assertEquals(expecteda, expectedb);\n+        assertEquals(testinga, testingb);\n+    }\n+\n+    private void previousPreviousNext(ListIterator<?> expected, ListIterator<?> testing) {\n+        // calls to previous() should change the value returned by next()\n+        // even after next() has been set by a call to hasNext()\n+        assertEquals(expected.previous(), testing.previous());\n+        assertEquals(expected.hasNext(), testing.hasNext());\n+        Object expecteda = expected.previous();\n+        Object testinga = testing.previous();\n+        assertEquals(expecteda, testinga);\n+        Object expectedb = expected.next();\n+        Object testingb = testing.next();\n+        assertEquals(expecteda, testingb);\n+        assertEquals(expecteda, expectedb);\n+        assertEquals(testinga, testingb);\n+    }\n+\n+    private <E> void walkLists(List<E> list, ListIterator<E> testing) {\n+        ListIterator<E> expected = list.listIterator();\n+\n+        // walk all the way forward\n+        walkForward(expected,testing);\n+\n+        // walk all the way back\n+        walkBackward(expected,testing);\n+\n+        // forward,back,forward\n+        while (expected.hasNext()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n+            assertTrue(testing.hasNext());\n+            assertEquals(expected.next(), testing.next());\n+            assertTrue(testing.hasPrevious());\n+            assertEquals(expected.previous(), testing.previous());\n+            assertTrue(testing.hasNext());\n+            assertEquals(expected.next(), testing.next());\n+        }\n+\n+        // walk all the way back\n+        walkBackward(expected, testing);\n+\n+        for (int i = 0; i < list.size(); i++) {\n+            // walk forward i\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasNext());\n+                assertEquals(expected.next(), testing.next());\n+            }\n+            // walk back i/2\n+            for (int j = 0; j < i / 2; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasPrevious());\n+                assertEquals(expected.previous(), testing.previous());\n+            }\n+            // walk forward i/2\n+            for (int j = 0; j < i / 2; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasNext());\n+                assertEquals(expected.next(), testing.next());\n+            }\n+            // walk back i\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasPrevious());\n+                assertEquals(expected.previous(), testing.previous());\n+            }\n+        }\n+\n+        // random walk\n+        StringBuilder walkdescr = new StringBuilder(500);\n+        for (int i = 0; i < 500; i++) {\n+            if (random.nextBoolean()) {\n+                // step forward\n+                walkdescr.append(\"+\");\n+                if (expected.hasNext()) {\n+                    assertEquals(walkdescr.toString(), expected.next(), testing.next());\n+                }\n+            } else {\n+                // step backward\n+                walkdescr.append(\"-\");\n+                if (expected.hasPrevious()) {\n+                    assertEquals(walkdescr.toString(), expected.previous(), testing.previous());\n+                }\n+            }\n+            assertEquals(walkdescr.toString(), expected.nextIndex(), testing.nextIndex());\n+            assertEquals(walkdescr.toString(), expected.previousIndex(), testing.previousIndex());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestIteratorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Tests the IteratorChain class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Mauricio S. Moura\n+ * @author Morgan Delagrange\n+ */\n+public class TestIteratorChain extends AbstractTestIterator<String> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n+\n+    public TestIteratorChain(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        list1 = new ArrayList<String>();\n+        list1.add(\"One\");\n+        list1.add(\"Two\");\n+        list1.add(\"Three\");\n+        list2 = new ArrayList<String>();\n+        list2.add(\"Four\");\n+        list3 = new ArrayList<String>();\n+        list3.add(\"Five\");\n+        list3.add(\"Six\");        \n+    }\n+\n+    @Override\n+    public IteratorChain<String> makeEmptyIterator() {\n+        ArrayList<String> list = new ArrayList<String>();\n+        return new IteratorChain<String>(list.iterator());\n+    }\n+\n+    @Override\n+    public IteratorChain<String> makeObject() {\n+        IteratorChain<String> chain = new IteratorChain<String>();\n+\n+        chain.addIterator(list1.iterator());\n+        chain.addIterator(list2.iterator());\n+        chain.addIterator(list3.iterator());\n+        return chain;\n+    }\n+\n+    public void testIterator() {\n+        Iterator<String> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];            \n+            Object iterValue = iter.next();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\", \n+                       e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+\n+    public void testRemoveFromFilteredIterator() {\n+\n+        final Predicate<Integer> myPredicate = new Predicate<Integer>() {\n+            public boolean evaluate(Integer i) {\n+                return i.compareTo(new Integer(4)) < 0;\n+            }\n+        };\n+\n+        List<Integer> list1 = new ArrayList<Integer>();\n+        List<Integer> list2 = new ArrayList<Integer>();\n+\n+        list1.add(new Integer(1));\n+        list1.add(new Integer(2));\n+        list2.add(new Integer(3));\n+        list2.add(new Integer(4)); // will be ignored by the predicate\n+\n+        Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n+        Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n+\n+        Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertEquals(0, list1.size());\n+        assertEquals(1, list2.size());\n+    }\n+    \n+    @Override\n+    public void testRemove() {\n+        Iterator<String> iter = makeObject();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Calling remove before the first call to next() should throw an exception\");\n+        } catch (IllegalStateException e) {\n+\n+        }\n+\n+        for (int i = 0; i < testArray.length; i++) {\n+            String testValue = testArray[i];            \n+            String iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+            if (!iterValue.equals(\"Four\")) {\n+                iter.remove();\n+            }\n+        }\n+\n+        assertTrue(\"List is empty\",list1.size() == 0);\n+        assertTrue(\"List is empty\",list2.size() == 1);\n+        assertTrue(\"List is empty\",list3.size() == 0);\n+    }\n+\n+    public void testFirstIteratorIsEmptyBug() {\n+        List<String> empty = new ArrayList<String>();\n+        List<String> notEmpty = new ArrayList<String>();\n+        notEmpty.add(\"A\");\n+        notEmpty.add(\"B\");\n+        notEmpty.add(\"C\");\n+        IteratorChain<String> chain = new IteratorChain<String>();\n+        chain.addIterator(empty.iterator());\n+        chain.addIterator(notEmpty.iterator());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"A\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"B\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"C\",chain.next());\n+        assertTrue(\"should not have next\",!chain.hasNext());\n+    }\n+    \n+    public void testEmptyChain() {\n+        IteratorChain<Object> chain = new IteratorChain<Object>();\n+        assertEquals(false, chain.hasNext());\n+        try {\n+            chain.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            chain.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestIteratorIterable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Tests for IteratorIterable.\n+ * \n+ * @version $Revision: $ $Date: $\n+ */\n+public class TestIteratorIterable extends BulkTest {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestIteratorIterable.class);\n+    }\n+\n+    public TestIteratorIterable(String name) {\n+        super(name);\n+    }\n+\n+    private Iterator<Integer> createIterator() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        Iterator<Integer> iter = list.iterator();\n+        return iter;\n+    }\n+\n+    public void testIterator() {\n+        Iterator<Integer> iter = createIterator();\n+        Iterable<Number> iterable = new IteratorIterable<Number>(iter);\n+        \n+        // first use\n+        verifyIteration(iterable);\n+        \n+        // second use\n+        for (Number actual : iterable) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+\n+    public void testMultipleUserIterator() {\n+        Iterator<Integer> iter = createIterator();\n+\n+        Iterable<Number> iterable = new IteratorIterable<Number>(iter, true);\n+        \n+        // first use\n+        verifyIteration(iterable);\n+        \n+        // second use\n+        verifyIteration(iterable);\n+    }\n+\n+    private void verifyIteration(Iterable<Number> iterable) {\n+        int expected = 0;\n+        for (Number actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        assertTrue(expected > 0);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestListIteratorWrapper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Tests the ListIteratorWrapper to insure that it simulates\n+ * a ListIterator correctly.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Morgan Delagrange\n+ */\n+public class TestListIteratorWrapper<E> extends AbstractTestIterator<E> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<E> list1 = null;\n+\n+    public TestListIteratorWrapper(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void setUp() {\n+        list1 = new ArrayList<E>();\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"Three\");\n+        list1.add((E) \"Four\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Six\");\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeEmptyIterator() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        return new ListIteratorWrapper<E>(list.iterator());\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeObject() {\n+        return new ListIteratorWrapper<E>(list1.iterator());\n+    }\n+\n+    public void testIterator() {\n+        ListIterator<E> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+\n+        // now, read it backwards\n+        for (int i = testArray.length - 1; i > -1; --i) {\n+            Object testValue = testArray[i];\n+            E iterValue = iter.previous();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        try {\n+            iter.previous();\n+        } catch (Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+\n+        // now, read it forwards again\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testRemove() {\n+        ListIterator<E> iter = makeObject();\n+\n+        //initial state:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n+        } catch (IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //establish size:\n+        int sz = list1.size();\n+\n+        //verify initial next() call:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //verify remove():\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        //like we never started iterating:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+ \n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n+        } catch (IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //two consecutive next() calls:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+        //call previous():\n+        assertEquals(list1.get(1), iter.previous());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //dig into cache\n+        assertEquals(list1.get(0), iter.previous());\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper does not support the remove() method while dug into the cache via previous()\");\n+        } catch (IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //dig out of cache, first next() maintains current position:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+        //continue traversing underlying iterator with this next() call, and we're out of the hole, so to speak:\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+        //verify remove() works again:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+    }\n+\n+    public void testReset() {\n+        ResettableListIterator<E> iter = makeObject();\n+        E first = iter.next();\n+        E second = iter.next();\n+\n+        iter.reset();\n+\n+        // after reset, there shouldn't be any previous elements\n+        assertFalse(\"No previous elements after reset()\", iter.hasPrevious());\n+\n+        // after reset, the results should be the same as before\n+        assertEquals(\"First element should be the same\", first, iter.next());\n+        assertEquals(\"Second elment should be the same\", second, iter.next());\n+\n+        // after passing the point, where we resetted, continuation should work as expected\n+        for (int i = 2; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestListIteratorWrapper2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Tests the ListIteratorWrapper to insure that it behaves as expected when wrapping a ListIterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Morgan Delagrange\n+ */\n+public class TestListIteratorWrapper2<E> extends AbstractTestIterator<E> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<E> list1 = null;\n+\n+    public TestListIteratorWrapper2(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void setUp() {\n+        list1 = new ArrayList<E>();\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"Three\");\n+        list1.add((E) \"Four\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Six\");\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeEmptyIterator() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        return new ListIteratorWrapper<E>(list.listIterator());\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeObject() {\n+        return new ListIteratorWrapper<E>(list1.listIterator());\n+    }\n+\n+    public void testIterator() {\n+        ListIterator<E> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+\n+        // now, read it backwards\n+        for (int i = testArray.length - 1; i > -1; --i) {\n+            Object testValue = testArray[i];\n+            E iterValue = iter.previous();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        try {\n+            iter.previous();\n+        } catch (Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+\n+        // now, read it forwards again\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testRemove() {\n+        ListIterator<E> iter = makeObject();\n+\n+        //initial state:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n+        } catch (IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //establish size:\n+        int sz = list1.size();\n+\n+        //verify initial next() call:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //verify remove():\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        //like we never started iterating:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+ \n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n+        } catch (IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //two consecutive next() calls:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+        //call previous():\n+        assertEquals(list1.get(1), iter.previous());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //this would dig into cache on a plain Iterator, but forwards directly to wrapped ListIterator:\n+        assertEquals(list1.get(0), iter.previous());\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //here's the proof; remove() still works:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //further testing would be fairly meaningless:\n+    }\n+\n+    public void testReset() {\n+        ResettableListIterator<E> iter = makeObject();\n+        E first = iter.next();\n+        E second = iter.next();\n+\n+        iter.reset();\n+\n+        // after reset, there shouldn't be any previous elements\n+        assertFalse(\"No previous elements after reset()\", iter.hasPrevious());\n+\n+        // after reset, the results should be the same as before\n+        assertEquals(\"First element should be the same\", first, iter.next());\n+        assertEquals(\"Second elment should be the same\", second, iter.next());\n+\n+        // after passing the point, where we resetted, continuation should work as expected\n+        for (int i = 2; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestLoopingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the LoopingIterator class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Jonathan Carlson\n+ * @author Stephen Colebourne\n+ */\n+public class TestLoopingIterator extends TestCase {\n+\n+    public TestLoopingIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * Tests constructor exception.\n+     */\n+    public void testConstructorEx() throws Exception {\n+        try {\n+            new LoopingIterator<Object>(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+    \n+    /**\n+     * Tests whether an empty looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping0() throws Exception {\n+        List<Object> list = new ArrayList<Object>();\n+        LoopingIterator<Object> loop = new LoopingIterator<Object>(list);\n+        assertTrue(\"hasNext should return false\", loop.hasNext() == false);\n+\n+        try {\n+            loop.next();\n+            fail(\"NoSuchElementException was not thrown during next() call.\");\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether a populated looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping1() throws Exception {\n+        List<String> list = Arrays.asList(new String[] { \"a\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+    }\n+\n+    /**\n+     * Tests whether a populated looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping2() throws Exception {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"b\", loop.next());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+    }\n+\n+    /**\n+     * Tests whether a populated looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping3() throws Exception {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"b\", loop.next());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"c\", loop.next());\n+\n+        assertTrue(\"4th hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+    }\n+\n+    /**\n+     * Tests the remove() method on a LoopingIterator wrapped ArrayList.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testRemoving1() throws Exception {\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        assertEquals(\"list should have 3 elements.\", 3, list.size());\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+        loop.remove();  // removes a\n+        assertEquals(\"list should have 2 elements.\", 2, list.size());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"b\", loop.next());\n+        loop.remove();  // removes b\n+        assertEquals(\"list should have 1 elements.\", 1, list.size());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"c\", loop.next());\n+        loop.remove();  // removes c\n+        assertEquals(\"list should have 0 elements.\", 0, list.size());\n+\n+        assertTrue(\"4th hasNext should return false\", loop.hasNext() == false);\n+        try {\n+            loop.next();\n+            fail(\"Expected NoSuchElementException to be thrown.\");\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests the reset() method on a LoopingIterator wrapped ArrayList.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testReset() throws Exception {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertEquals(\"a\", loop.next());\n+        assertEquals(\"b\", loop.next());\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());\n+        assertEquals(\"b\", loop.next());\n+        assertEquals(\"c\", loop.next());\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());\n+        assertEquals(\"b\", loop.next());\n+        assertEquals(\"c\", loop.next());\n+    }\n+    \n+    /**\n+     * Tests the size() method on a LoopingIterator wrapped ArrayList.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testSize() throws Exception {\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertEquals(3, loop.size());\n+        loop.next();\n+        loop.next();\n+        assertEquals(3, loop.size());\n+        loop.reset();\n+        assertEquals(3, loop.size());\n+        loop.next();\n+        loop.remove();\n+        assertEquals(2, loop.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestLoopingListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the LoopingListIterator class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Eric Crampton <ccesc@eonomine.com>\n+ */\n+public class TestLoopingListIterator extends TestCase {\n+\n+    public TestLoopingListIterator(String testName) {\n+        super(testName);\n+    }\n+    \n+    /**\n+     * Tests constructor exception.\n+     */\n+    public void testConstructorEx() throws Exception {\n+        try {\n+            new LoopingListIterator<Object>(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether an empty looping list iterator works.\n+     */\n+    public void testLooping0() throws Exception {\n+        List<Object> list = new ArrayList<Object>();\n+        LoopingListIterator<Object> loop = new LoopingListIterator<Object>(list);\n+        assertFalse(loop.hasNext());\n+        assertFalse(loop.hasPrevious());\n+        \n+        try {\n+            loop.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+\n+        try {\n+            loop.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether a looping list iterator works on a list with only\n+     * one element.\n+     */\n+    public void testLooping1() throws Exception {\n+        List<String> list = Arrays.asList(new String[] { \"a\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+    }\n+\n+    /**\n+     * Tests whether a looping list iterator works on a list with two\n+     * elements.\n+     */\n+    public void testLooping2() throws Exception {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"b\", loop.next());     // <a> b\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        // Reset the iterator and try using previous.\n+        loop.reset();                       // <a> b\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+    }\n+\n+    /**\n+     * Tests jogging back and forth between two elements, but not over\n+     * the begin/end boundary of the list.\n+     */\n+    public void testJoggingNotOverBoundary() {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+    \n+        // Try jogging back and forth between the elements, but not\n+        // over the begin/end boundary.\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());     // a <b>\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        assertEquals(\"b\", loop.next());     // <a> b\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        assertEquals(\"b\", loop.next());     // <a> b\n+    }\n+\n+    /**\n+     * Tests jogging back and forth between two elements over the\n+     * begin/end boundary of the list.\n+     */\n+    public void testJoggingOverBoundary() {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+    \n+        // Try jogging back and forth between the elements, but not\n+        // over the begin/end boundary.\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        assertEquals(\"b\", loop.next());     // <a> b\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+        assertEquals(\"a\", loop.next());     // a <b>\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+    }\n+\n+    /**\n+     * Tests removing an element from a wrapped ArrayList.\n+     */\n+    public void testRemovingElementsAndIteratingForward() {\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        loop.remove();                  // <b> c\n+        assertEquals(2, list.size());\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"b\", loop.next()); // b <c>\n+        loop.remove();                  // <c>\n+        assertEquals(1, list.size());\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"c\", loop.next()); // <c>\n+        loop.remove();                  // ---\n+        assertEquals(0, list.size());\n+\n+        assertFalse(loop.hasNext());\n+        try {\n+            loop.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests removing an element from a wrapped ArrayList.\n+     */\n+    public void testRemovingElementsAndIteratingBackwards() {\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        loop.remove();                      // <a> b\n+        assertEquals(2, list.size());\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        loop.remove();                      // <a>\n+        assertEquals(1, list.size());\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+        loop.remove();                      // ---\n+        assertEquals(0, list.size());\n+\n+        assertFalse(loop.hasPrevious());\n+        try {\n+            loop.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests the reset method.\n+     */\n+    public void testReset() {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        assertEquals(\"b\", loop.next()); // a b <c>\n+        loop.reset();                   // <a> b c\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        loop.reset();                   // <a> b c\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        assertEquals(\"b\", loop.next()); // a b <c>\n+        assertEquals(\"c\", loop.next()); // <a> b c\n+        loop.reset();                   // <a> b c\n+\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        assertEquals(\"b\", loop.previous()); // a <b> c\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        assertEquals(\"b\", loop.previous()); // a <b> c\n+        assertEquals(\"a\", loop.previous()); // <a> b c\n+    }\n+\n+    /**\n+     * Tests the add method.\n+     */\n+    public void testAdd() {\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <b> e f\n+\n+        loop.add(\"a\");                      // <a> b e f\n+        assertEquals(\"b\", loop.next());     // a <b> e f\n+        loop.reset();                       // <a> b e f\n+        assertEquals(\"a\", loop.next());     // a <b> e f\n+        assertEquals(\"b\", loop.next());     // a b <e> f\n+\n+        loop.add(\"c\");                      // a b c <e> f\n+        assertEquals(\"e\", loop.next());     // a b c e <f>\n+        assertEquals(\"e\", loop.previous()); // a b c <e> f\n+        assertEquals(\"c\", loop.previous()); // a b <c> e f\n+        assertEquals(\"c\", loop.next());     // a b c <e> f\n+        \n+        loop.add(\"d\");                      // a b c d <e> f\n+        loop.reset();                       // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+        assertEquals(\"b\", loop.next());     // a b <c> d e f\n+        assertEquals(\"c\", loop.next());     // a b c <d> e f\n+        assertEquals(\"d\", loop.next());     // a b c d <e> f\n+        assertEquals(\"e\", loop.next());     // a b c d e <f>\n+        assertEquals(\"f\", loop.next());     // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+\n+        list = new ArrayList<String>(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        loop = new LoopingListIterator<String>(list); // <b> e f        \n+\n+        loop.add(\"a\");                      // a <b> e f\n+        assertEquals(\"a\", loop.previous()); // a b e <f>\n+        loop.reset();                       // <a> b e f\n+        assertEquals(\"f\", loop.previous()); // a b e <f>\n+        assertEquals(\"e\", loop.previous()); // a b <e> f\n+\n+        loop.add(\"d\");                      // a b d <e> f\n+        assertEquals(\"d\", loop.previous()); // a b <d> e f\n+\n+        loop.add(\"c\");                      // a b c <d> e f\n+        assertEquals(\"c\", loop.previous()); // a b <c> d e f\n+\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+        assertEquals(\"b\", loop.next());     // a b <c> d e f\n+        assertEquals(\"c\", loop.next());     // a b c <d> e f\n+        assertEquals(\"d\", loop.next());     // a b c d <e> f\n+        assertEquals(\"e\", loop.next());     // a b c d e <f>\n+        assertEquals(\"f\", loop.next());     // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+    }\n+\n+    /**\n+     * Tests nextIndex and previousIndex.\n+     */\n+    public void testNextAndPreviousIndex() {\n+        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.next());        // a <b> c\n+        assertEquals(1, loop.nextIndex());\n+        assertEquals(0, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.previous());    // <a> b c\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+\n+        assertEquals(\"c\", loop.previous());    // a b <c>\n+        assertEquals(2, loop.nextIndex());\n+        assertEquals(1, loop.previousIndex());\n+\n+        assertEquals(\"b\", loop.previous());    // a <b> c\n+        assertEquals(1, loop.nextIndex());\n+        assertEquals(0, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.previous());    // <a> b c\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+    }\n+\n+    /**\n+     * Tests using the set method to change elements.\n+     */\n+    public void testSet() {\n+        List<String> list = Arrays.asList(new String[] { \"q\", \"r\", \"z\" });\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <q> r z\n+\n+        assertEquals(\"z\", loop.previous()); // q r <z>\n+        loop.set(\"c\");                      // q r <c>\n+\n+        loop.reset();                       // <q> r c\n+        assertEquals(\"q\", loop.next());     // q <r> c\n+        loop.set(\"a\");                      // a <r> c\n+        \n+        assertEquals(\"r\", loop.next());     // a r <c>\n+        loop.set(\"b\");                      // a b <c>\n+\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"a\", loop.next());     // a <b> c\n+        assertEquals(\"b\", loop.next());     // a b <c>\n+        assertEquals(\"c\", loop.next());     // <a> b c\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestObjectArrayIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Tests the ObjectArrayIterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Mauricio S. Moura\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ */\n+public class TestObjectArrayIterator<E> extends AbstractTestIterator<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+\n+    public TestObjectArrayIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayIterator<E>((E[]) new Object[0]);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayIterator<E> makeObject() {\n+        return new ObjectArrayIterator<E>((E[]) testArray);\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator() {\n+        return new ObjectArrayIterator<E>();\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator(E[] array) {\n+        return new ObjectArrayIterator<E>(array);\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator(E[] array, int index) {\n+        return new ObjectArrayIterator<E>(array, index);\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator(E[] array, int start, int end) {\n+        return new ObjectArrayIterator<E>(array, start, end);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    public void testIterator() {\n+        Iterator<E> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];\n+            E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+\n+    public void testNullArray() {\n+        try {\n+            makeArrayIterator(null);\n+\n+            fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+\n+        ObjectArrayIterator<E> iter = makeArrayIterator();\n+        try {\n+            iter.setArray(null);\n+\n+            fail(\"setArray(null) should throw a NullPointerException\");\n+        } catch (NullPointerException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testDoubleSet() {\n+        ObjectArrayIterator<E> it = makeArrayIterator();\n+        it.setArray((E[]) new String[0]);\n+        try {\n+            it.setArray((E[]) new String[0]);\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);\n+        it.next();\n+        it.reset();\n+        assertEquals(\"One\", it.next());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestObjectArrayListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Arrays;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Tests the ObjectArrayListIterator class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Neil O'Toole\n+ */\n+public class TestObjectArrayListIterator<E> extends TestObjectArrayIterator<E> {\n+\n+    public TestObjectArrayListIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayListIterator<E>((E[]) new Object[0]);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeObject() {\n+        return new ObjectArrayListIterator<E>((E[]) testArray);\n+    }\n+\n+    public ObjectArrayListIterator<E> makeArrayListIterator(E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n+    }\n+\n+    /**\n+     * Test the basic ListIterator functionality - going backwards using\n+     * <code>previous()</code>.\n+     */\n+    public void testListIterator() {\n+        ListIterator<E> iter = makeObject();\n+\n+        // TestArrayIterator#testIterator() has already tested the iterator forward,\n+        //  now we need to test it in reverse\n+\n+        // fast-forward the iterator to the end...\n+        while (iter.hasNext()) {\n+            iter.next();\n+        }\n+\n+        for (int x = testArray.length - 1; x >= 0; x--) {\n+            Object testValue = testArray[x];\n+            Object iterValue = iter.previous();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasPrevious());\n+\n+        try {\n+            iter.previous();\n+        } catch (Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+\n+    }\n+\n+    /**\n+     * Tests the {@link java.util.ListIterator#set} operation.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorSet() {\n+        String[] testData = new String[] { \"a\", \"b\", \"c\" };\n+\n+        String[] result = new String[] { \"0\", \"1\", \"2\" };\n+\n+        ListIterator<E> iter = makeArrayListIterator((E[]) testData);\n+        int x = 0;\n+\n+        while (iter.hasNext()) {\n+            iter.next();\n+            iter.set((E) Integer.toString(x));\n+            x++;\n+        }\n+\n+        assertTrue(\"The two arrays should have the same value, i.e. {0,1,2}\", Arrays.equals(testData, result));\n+\n+        // a call to set() before a call to next() or previous() should throw an IllegalStateException\n+        iter = makeArrayListIterator((E[]) testArray);\n+\n+        try {\n+            iter.set((E) \"should fail\");\n+            fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        } catch (Throwable t) { // should never happen\n+            fail(t.toString());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestObjectArrayListIterator2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+/**\n+ * Tests the ObjectArrayListIterator class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestObjectArrayListIterator2<E> extends AbstractTestListIterator<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+\n+    public TestObjectArrayListIterator2(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayListIterator<E>((E[]) new Object[0]);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeObject() {\n+        return new ObjectArrayListIterator<E>((E[]) testArray);\n+    }\n+\n+    public ObjectArrayListIterator<E> makeArrayListIterator(E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n+    }\n+\n+    @Override\n+    public boolean supportsAdd() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestObjectGraphIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * Testcase.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestObjectGraphIterator extends AbstractTestIterator<Object> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\" };\n+\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n+    protected List<Iterator<String>> iteratorList = null;\n+\n+    public TestObjectGraphIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        list1 = new ArrayList<String>();\n+        list1.add(\"One\");\n+        list1.add(\"Two\");\n+        list1.add(\"Three\");\n+        list2 = new ArrayList<String>();\n+        list2.add(\"Four\");\n+        list3 = new ArrayList<String>();\n+        list3.add(\"Five\");\n+        list3.add(\"Six\");\n+        iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public ObjectGraphIterator<Object> makeEmptyIterator() {\n+        ArrayList<Object> list = new ArrayList<Object>();\n+        return new ObjectGraphIterator<Object>(list.iterator());\n+    }\n+\n+    @Override\n+    public ObjectGraphIterator<Object> makeObject() {\n+        return new ObjectGraphIterator<Object>(iteratorList.iterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteratorConstructor_null1() {\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructor_null_next() {\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructor_null_remove() {\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteratorConstructorIteration_Empty() {\n+        List<Iterator<Object>> iteratorList = new ArrayList<Iterator<Object>>();\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_Simple() {\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_SimpleNoHasNext() {\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(testArray[i], it.next());\n+        }\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_WithEmptyIterators() {\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorRemove() {\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(testArray[i], it.next());\n+            it.remove();\n+        }\n+        assertEquals(false, it.hasNext());\n+        assertEquals(0, list1.size());\n+        assertEquals(0, list2.size());\n+        assertEquals(0, list3.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteration_IteratorOfIterators() {\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    public void testIteration_IteratorOfIteratorsWithEmptyIterators() {\n+        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteration_RootNull() {\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(null, null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteration_RootNoTransformer() {\n+        Forest forest = new Forest();\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, null);\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(forest, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed1() {\n+        Forest forest = new Forest();\n+        Leaf l1 = forest.addTree().addBranch().addLeaf();\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed2() {\n+        Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        Branch b1 = forest.getTree(0).addBranch();\n+        Branch b2 = forest.getTree(0).addBranch();\n+        Branch b3 = forest.getTree(2).addBranch();\n+        /* Branch b4 = */ forest.getTree(2).addBranch();\n+        Branch b5 = forest.getTree(2).addBranch();\n+        Leaf l1 = b1.addLeaf();\n+        Leaf l2 = b1.addLeaf();\n+        Leaf l3 = b2.addLeaf();\n+        Leaf l4 = b3.addLeaf();\n+        Leaf l5 = b5.addLeaf();\n+\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l2, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l3, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l4, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l5, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed3() {\n+        Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        Branch b1 = forest.getTree(1).addBranch();\n+        Branch b2 = forest.getTree(1).addBranch();\n+        Branch b3 = forest.getTree(2).addBranch();\n+        Branch b4 = forest.getTree(2).addBranch();\n+        /* Branch b5 = */ forest.getTree(2).addBranch();\n+        Leaf l1 = b1.addLeaf();\n+        Leaf l2 = b1.addLeaf();\n+        Leaf l3 = b2.addLeaf();\n+        Leaf l4 = b3.addLeaf();\n+        Leaf l5 = b4.addLeaf();\n+\n+        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l2, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l3, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l4, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l5, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class LeafFinder implements Transformer<Object, Object> {\n+        public Object transform(Object input) {\n+            if (input instanceof Forest) {\n+                return ((Forest) input).treeIterator();\n+            }\n+            if (input instanceof Tree) {\n+                return ((Tree) input).branchIterator();\n+            }\n+            if (input instanceof Branch) {\n+                return ((Branch) input).leafIterator();\n+            }\n+            if (input instanceof Leaf) {\n+                return input;\n+            }\n+            throw new ClassCastException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class Forest {\n+        List<Tree> trees = new ArrayList<Tree>();\n+\n+        Tree addTree() {\n+            trees.add(new Tree());\n+            return getTree(trees.size() - 1);\n+        }\n+\n+        Tree getTree(int index) {\n+            return trees.get(index);\n+        }\n+\n+        Iterator<Tree> treeIterator() {\n+            return trees.iterator();\n+        }\n+    }\n+\n+    static class Tree {\n+        List<Branch> branches = new ArrayList<Branch>();\n+\n+        Branch addBranch() {\n+            branches.add(new Branch());\n+            return getBranch(branches.size() - 1);\n+        }\n+\n+        Branch getBranch(int index) {\n+            return branches.get(index);\n+        }\n+\n+        Iterator<Branch> branchIterator() {\n+            return branches.iterator();\n+        }\n+    }\n+\n+    static class Branch {\n+        List<Leaf> leaves = new ArrayList<Leaf>();\n+\n+        Leaf addLeaf() {\n+            leaves.add(new Leaf());\n+            return getLeaf(leaves.size() - 1);\n+        }\n+\n+        Leaf getLeaf(int index) {\n+            return leaves.get(index);\n+        }\n+\n+        Iterator<Leaf> leafIterator() {\n+            return leaves.iterator();\n+        }\n+    }\n+\n+    static class Leaf {\n+        String colour;\n+\n+        String getColour() {\n+            return colour;\n+        }\n+\n+        void setColour(String colour) {\n+            this.colour = colour;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestReverseListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Tests the ReverseListIterator.\n+ *\n+ * @version $Revision: $ $Date$\n+ */\n+public class TestReverseListIterator<E> extends AbstractTestListIterator<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\" };\n+\n+    public TestReverseListIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ListIterator<E> makeEmptyIterator() {\n+        return new ReverseListIterator<E>(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ReverseListIterator<E> makeObject() {\n+        List<E> list = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+        return new ReverseListIterator<E>(list);\n+    }\n+\n+    // overrides\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testEmptyListIteratorIsIndeedEmpty() {\n+        ListIterator<E> it = makeEmptyIterator();\n+\n+        assertEquals(false, it.hasNext());\n+        assertEquals(-1, it.nextIndex());  // reversed index\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(0, it.previousIndex());  // reversed index\n+\n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (NoSuchElementException e) {\n+        }\n+\n+        // previous() should throw a NoSuchElementException\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (NoSuchElementException e) {\n+        }\n+    }\n+\n+    @Override\n+    public void testWalkForwardAndBack() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        ListIterator<E> it = makeObject();\n+        while (it.hasNext()) {\n+            list.add(it.next());\n+        }\n+\n+        // check state at end\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+\n+        // this had to be commented out, as there is a bug in the JDK before JDK1.5\n+        // where calling previous at the start of an iterator would push the cursor\n+        // back to an invalid negative value\n+//        try {\n+//            it.next();\n+//            fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n+//        } catch (NoSuchElementException e) {\n+//        }\n+\n+        // loop back through comparing\n+        for (int i = list.size() - 1; i >= 0; i--) {\n+            assertEquals(\"\" + i, list.size() - i - 2, it.nextIndex());  // reversed index\n+            assertEquals(list.size() - i - 1, it.previousIndex());  // reversed index\n+\n+            Object obj = list.get(i);\n+            assertEquals(obj, it.previous());\n+        }\n+\n+        // check state at start\n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from previous at start of ListIterator\");\n+        } catch (NoSuchElementException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReverse() {\n+        ListIterator<E> it = makeObject();\n+        assertEquals(true, it.hasNext());\n+        assertEquals(3, it.nextIndex());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(4, it.previousIndex());\n+        assertEquals(\"Four\", it.next());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(3, it.previousIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(\"Three\", it.next());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(2, it.previousIndex());\n+        assertEquals(\"Two\", it.next());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(\"One\", it.next());\n+        assertEquals(false, it.hasNext());\n+        assertEquals(-1, it.nextIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(\"One\", it.previous());\n+        assertEquals(\"Two\", it.previous());\n+        assertEquals(\"Three\", it.previous());\n+        assertEquals(\"Four\", it.previous());\n+    }\n+\n+    public void testReset() {\n+        ResettableListIterator<E> it = makeObject();\n+        assertEquals(\"Four\", it.next());\n+        it.reset();\n+        assertEquals(\"Four\", it.next());\n+        it.next();\n+        it.next();\n+        it.reset();\n+        assertEquals(\"Four\", it.next());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestSingletonIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * Tests the SingletonIterator to ensure that the next() method will actually\n+ * perform the iteration rather than the hasNext() method.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ */\n+public class TestSingletonIterator<E> extends AbstractTestIterator<E> {\n+\n+    private static final Object testValue = \"foo\";\n+\n+    public TestSingletonIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * Returns a SingletonIterator from which\n+     * the element has already been removed.\n+     */\n+    @Override\n+    public SingletonIterator<E> makeEmptyIterator() {\n+        SingletonIterator<E> iter = makeObject();\n+        iter.next();\n+        iter.remove();\n+        iter.reset();\n+        return iter;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeObject() {\n+        return new SingletonIterator<E>((E) testValue);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supportsEmptyIterator() {\n+        return true;\n+    }\n+\n+    public void testIterator() {\n+        Iterator<E> iter = makeObject();\n+        assertTrue(\"Iterator has a first item\", iter.hasNext());\n+\n+        E iterValue = iter.next();\n+        assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSingletonIteratorRemove() {\n+        ResettableIterator<E> iter = new SingletonIterator<E>((E) \"xyzzy\");\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"xyzzy\",iter.next());\n+        iter.remove();\n+        iter.reset();\n+        assertTrue(! iter.hasNext());\n+    }\n+\n+    public void testReset() {\n+        ResettableIterator<E> it = makeObject();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestSingletonIterator2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * Tests the SingletonIterator to ensure that the next() method will actually\n+ * perform the iteration rather than the hasNext() method.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ */\n+public class TestSingletonIterator2<E> extends AbstractTestIterator<E> {\n+\n+    private static final Object testValue = \"foo\";\n+\n+    public TestSingletonIterator2(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeEmptyIterator() {\n+        SingletonIterator<E> iter = new SingletonIterator<E>((E) testValue);\n+        iter.next();\n+        iter.remove();\n+        iter.reset();\n+        return iter;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeObject() {\n+        return new SingletonIterator<E>((E) testValue, false);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsEmptyIterator() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIterator() {\n+        Iterator<E> iter = makeObject();\n+        assertTrue(\"Iterator has a first item\", iter.hasNext());\n+\n+        E iterValue = iter.next();\n+        assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+\n+    public void testReset() {\n+        ResettableIterator<E> it = makeObject();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestSingletonListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.ResettableListIterator;\n+\n+/**\n+ * Tests the SingletonListIterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSingletonListIterator<E> extends AbstractTestListIterator<E> {\n+\n+    private static final Object testValue = \"foo\";\n+    \n+    public TestSingletonListIterator(String testName) {\n+        super(testName);\n+    }\n+    \n+    /**\n+     * Returns a SingletonListIterator from which \n+     * the element has already been removed.\n+     */\n+    @Override\n+    public SingletonListIterator<E> makeEmptyIterator() {\n+        SingletonListIterator<E> iter = makeObject();\n+        iter.next();\n+        iter.remove();\n+        iter.reset();        \n+        return iter;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonListIterator<E> makeObject() {\n+        return new SingletonListIterator<E>((E) testValue);\n+    }\n+\n+    @Override\n+    public boolean supportsAdd() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supportsEmptyIterator() {\n+        return true;\n+    }\n+\n+    public void testIterator() {\n+        ListIterator<E> iter = makeObject();\n+        assertTrue( \"Iterator should have next item\", iter.hasNext() );\n+        assertTrue( \"Iterator should have no previous item\", !iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 0, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", -1, iter.previousIndex() );\n+        \n+        Object iterValue = iter.next();\n+        assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        \n+        assertTrue( \"Iterator should have no next item\", !iter.hasNext() );\n+        assertTrue( \"Iterator should have previous item\", iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 1, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", 0, iter.previousIndex() );\n+\n+        iterValue = iter.previous();\n+        assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        \n+        assertTrue( \"Iterator should have next item\", iter.hasNext() );\n+        assertTrue( \"Iterator should have no previous item\", !iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 0, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", -1, iter.previousIndex() );\n+\n+        iterValue = iter.next();\n+        assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        \n+        assertTrue( \"Iterator should have no next item\", !iter.hasNext() );\n+        assertTrue( \"Iterator should have previous item\", iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 1, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", 0, iter.previousIndex() );\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+          assertTrue(\"NoSuchElementException must be thrown\", \n+             e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+        iter.previous();\n+        try {\n+            iter.previous();\n+        } catch (Exception e) {\n+          assertTrue(\"NoSuchElementException must be thrown\", \n+             e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+    \n+    public void testReset() {\n+        ResettableListIterator<E> it = makeObject();\n+        \n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+\n+        it.reset();\n+        \n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+        \n+        it.reset();\n+        it.reset();\n+        \n+        assertEquals(true, it.hasNext());\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestUniqueFilterIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Tests the UniqueFilterIterator class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author James Strachan\n+ * @author Mauricio S. Moura\n+ * @author Morgan Delagrange\n+ * @author Stephen Colebourne\n+ */\n+public class TestUniqueFilterIterator<E> extends AbstractTestIterator<E> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<E> list1 = null;\n+\n+    public TestUniqueFilterIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void setUp() {\n+        list1 = new ArrayList<E>();\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"Three\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Four\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Six\");\n+        list1.add((E) \"Five\");\n+    }\n+\n+    @Override\n+    public UniqueFilterIterator<E> makeEmptyIterator() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        return new UniqueFilterIterator<E>(list.iterator());\n+    }\n+\n+    @Override\n+    public UniqueFilterIterator<E> makeObject() {\n+        Iterator<E> i = list1.iterator();\n+        return new UniqueFilterIterator<E>(i);\n+    }\n+\n+    public void testIterator() {\n+        Iterator<E> iter = makeObject();\n+        for (int i = 0; i < testArray.length; i++) {\n+            Object testValue = testArray[i];            \n+            E iterValue = iter.next();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", ! iter.hasNext() );\n+\n+        try {\n+            iter.next();\n+        } catch (Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\", \n+                       e.getClass().equals((new NoSuchElementException()).getClass()));\n+        }\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestUnmodifiableIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Tests the UnmodifiableIterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableIterator<E> extends AbstractTestIterator<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+    protected List<E> testList;\n+\n+    public TestUnmodifiableIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testList = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+    }\n+\n+    @Override\n+    public Iterator<E> makeEmptyIterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(Collections.<E>emptyList().iterator());\n+    }\n+\n+    @Override\n+    public Iterator<E> makeObject() {\n+        return UnmodifiableIterator.unmodifiableIterator(testList.iterator());\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        Iterator<E> it = makeObject();\n+        assertSame(it, UnmodifiableIterator.unmodifiableIterator(it));\n+\n+        it = testList.iterator();\n+        assertTrue(it != UnmodifiableIterator.unmodifiableIterator(it));\n+\n+        try {\n+            UnmodifiableIterator.unmodifiableIterator(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestUnmodifiableListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Tests the UnmodifiableListIterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableListIterator<E> extends AbstractTestListIterator<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+    protected List<E> testList;\n+\n+    public TestUnmodifiableListIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testList = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+    }\n+\n+    @Override\n+    public ListIterator<E> makeEmptyIterator() {\n+        return UnmodifiableListIterator.umodifiableListIterator(Collections.<E>emptyList().listIterator());\n+    }\n+\n+    @Override\n+    public ListIterator<E> makeObject() {\n+        return UnmodifiableListIterator.umodifiableListIterator(testList.listIterator());\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsAdd() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSet() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testListIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        ListIterator<E> it = makeObject();\n+        assertSame(it, UnmodifiableListIterator.umodifiableListIterator(it));\n+\n+        it = testList.listIterator();\n+        assertTrue(it != UnmodifiableListIterator.umodifiableListIterator(it));\n+\n+        try {\n+            UnmodifiableListIterator.umodifiableListIterator(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestUnmodifiableMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.bidimap.DualHashBidiMap;\n+\n+/**\n+ * Tests the UnmodifiableMapIterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableMapIterator<K, V> extends AbstractTestMapIterator<K, V> {\n+\n+    public TestUnmodifiableMapIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> makeEmptyIterator() {\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(new DualHashBidiMap<K, V>().mapIterator());\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> makeObject() {\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(getMap().mapIterator());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public IterableMap<K, V> getMap() {\n+        IterableMap<K, V> testMap = new DualHashBidiMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V)\"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> getConfirmedMap() {\n+        Map<K, V> testMap = new HashMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V)\"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSetValue() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        MapIterator<K, V> it = makeObject();\n+        assertSame(it, UnmodifiableMapIterator.unmodifiableMapIterator(it));\n+\n+        it = getMap().mapIterator() ;\n+        assertTrue(it != UnmodifiableMapIterator.unmodifiableMapIterator(it));\n+\n+        try {\n+            UnmodifiableMapIterator.unmodifiableMapIterator(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/TestUnmodifiableOrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.map.ListOrderedMap;\n+\n+/**\n+ * Tests the UnmodifiableOrderedMapIterator.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableOrderedMapIterator<K, V> extends AbstractTestOrderedMapIterator<K, V> {\n+\n+    public TestUnmodifiableOrderedMapIterator(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public OrderedMapIterator<K, V> makeEmptyIterator() {\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(\n+                ListOrderedMap.listOrderedMap(new HashMap<K, V>()).mapIterator());\n+    }\n+\n+    @Override\n+    public OrderedMapIterator<K, V> makeObject() {\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(getMap().mapIterator());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public OrderedMap<K, V> getMap() {\n+        OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V) \"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> getConfirmedMap() {\n+        Map<K, V> testMap = new TreeMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V) \"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSetValue() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testOrderedMapIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        OrderedMapIterator<K, V> it = makeObject();\n+        assertSame(it, UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n+\n+        it = getMap().mapIterator() ;\n+        assertTrue(it != UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n+\n+        try {\n+            UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/AbstractTestMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Abstract tests that can be extended to test any Map.Entry implementation.\n+ * Subclasses must implement {@link #makeMapEntry(Object, Object)} to return\n+ * a new Map.Entry of the type being tested. Subclasses must also implement\n+ * {@link #testConstructors()} to test the constructors of the Map.Entry\n+ * type being tested.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Neil O'Toole\n+ */\n+public abstract class AbstractTestMapEntry<K, V> extends TestCase {\n+    \n+    protected final String key = \"name\";\n+    protected final String value = \"duke\";\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public AbstractTestMapEntry(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * This implementation simply calls {@link #makeMapEntry(Object, Object)}\n+     * with null for key and value. Subclasses can override this method if desired.\n+     */\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return makeMapEntry(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    public abstract Map.Entry<K, V> makeMapEntry(K key, V value);\n+\n+    /**\n+     * Makes a Map.Entry of a type that's known to work correctly.\n+     */\n+    public Map.Entry<K, V> makeKnownMapEntry() {\n+        return makeKnownMapEntry(null, null);\n+    }\n+\n+    /**\n+     * Makes a Map.Entry of a type that's known to work correctly.\n+     */\n+    public Map.Entry<K, V> makeKnownMapEntry(K key, V value) {\n+        Map<K, V> map = new HashMap<K, V>(1);\n+        map.put(key, value);\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        return entry;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+\n+        assertTrue(entry.getKey() == key);\n+\n+        entry.setValue((V) value);\n+        assertTrue(entry.getValue() == value);\n+\n+        // check that null doesn't do anything funny\n+        entry = makeMapEntry(null, null);\n+        assertTrue(entry.getKey() == null);\n+\n+        entry.setValue(null);\n+        assertTrue(entry.getValue() == null);\n+    }\n+\n+    /**\n+     * Subclasses should override this method to test the\n+     * desired behaviour of the class with respect to\n+     * handling of self-references.\n+     *\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        // test that #setValue does not permit\n+        //  the MapEntry to contain itself (and thus cause infinite recursion\n+        //  in #hashCode and #toString)\n+\n+        Map.Entry<K, V> entry = makeMapEntry();\n+\n+        try {\n+            entry.setValue((V) entry);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(entry.getKey() == null && entry.getValue() == null);\n+        }\n+    }\n+\n+    /**\n+     * Subclasses should provide tests for their constructors.\n+     *\n+     */\n+    public abstract void testConstructors();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        // 1. test with object data\n+        Map.Entry<K, V> e1 = makeMapEntry((K) key, (V) value);\n+        Map.Entry<K, V> e2 = makeKnownMapEntry((K) key, (V) value);\n+\n+        assertTrue(e1.equals(e1));\n+        assertTrue(e2.equals(e1));\n+        assertTrue(e1.equals(e2));\n+        assertTrue(e1.hashCode() == e2.hashCode());\n+\n+        // 2. test with nulls\n+        e1 = makeMapEntry();\n+        e2 = makeKnownMapEntry();\n+\n+        assertTrue(e1.equals(e1));\n+        assertTrue(e2.equals(e1));\n+        assertTrue(e1.equals(e2));\n+        assertTrue(e1.hashCode() == e2.hashCode());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToString() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+        assertTrue(entry.toString().equals(entry.getKey() + \"=\" + entry.getValue()));\n+\n+        // test with nulls\n+        entry = makeMapEntry();\n+        assertTrue(entry.toString().equals(entry.getKey() + \"=\" + entry.getValue()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/TestDefaultKeyValue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test the DefaultKeyValue class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Neil O'Toole\n+ */\n+public class TestDefaultKeyValue<K, V> extends TestCase {\n+    \n+    private final String key = \"name\";\n+    private final String value = \"duke\";\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public TestDefaultKeyValue(String testName) {\n+        super(testName);\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of DefaultKeyValue with the default (null) key and value.\n+     * Subclasses should override this method to return a DefaultKeyValue\n+     * of the type being tested.\n+     */\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue() {\n+        return new DefaultKeyValue<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of DefaultKeyValue with the specified key and value.\n+     * Subclasses should override this method to return a DefaultKeyValue\n+     * of the type being tested.\n+     */\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue(K key, V value) {\n+        return new DefaultKeyValue<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+\n+        kv.setKey((K) key);\n+        assertTrue(kv.getKey() == key);\n+\n+        kv.setValue((V) value);\n+        assertTrue(kv.getValue() == value);\n+\n+        // check that null doesn't do anything funny\n+        kv.setKey(null);\n+        assertTrue(kv.getKey() == null);\n+\n+        kv.setValue(null);\n+        assertTrue(kv.getValue() == null);\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        // test that #setKey and #setValue do not permit\n+        //  the KVP to contain itself (and thus cause infinite recursion\n+        //  in #hashCode and #toString)\n+\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+\n+        try {\n+            kv.setKey((K) kv);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(kv.getKey() == null && kv.getValue() == null);\n+        }\n+\n+        try {\n+            kv.setValue((V) kv);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(kv.getKey() == null && kv.getValue() == null);\n+        }\n+    }\n+\n+    /**\n+     * Subclasses should override this method to test their own constructors.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test default constructor\n+        DefaultKeyValue<K, V> kv = new DefaultKeyValue<K, V>();\n+        assertTrue(kv.getKey() == null && kv.getValue() == null);\n+\n+        // 2. test key-value constructor\n+        kv = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        assertTrue(kv.getKey() == key && kv.getValue() == value);\n+\n+        // 3. test copy constructor\n+        DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<K, V>(kv);\n+        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n+\n+        // test that the KVPs are independent\n+        kv.setKey(null);\n+        kv.setValue(null);\n+\n+        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n+\n+        // 4. test Map.Entry constructor\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) key, (V) value);\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+\n+        kv = new DefaultKeyValue<K, V>(entry);\n+        assertTrue(kv.getKey() == key && kv.getValue() == value);\n+\n+        // test that the KVP is independent of the Map.Entry\n+        entry.setValue(null);\n+        assertTrue(kv.getValue() == value);\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        // 1. test with object data\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        DefaultKeyValue<K, V> kv2 = makeDefaultKeyValue((K) key, (V) value);\n+\n+        assertTrue(kv.equals(kv));\n+        assertTrue(kv.equals(kv2));\n+        assertTrue(kv.hashCode() == kv2.hashCode());\n+\n+        // 2. test with nulls\n+        kv = makeDefaultKeyValue(null, null);\n+        kv2 = makeDefaultKeyValue(null, null);\n+\n+        assertTrue(kv.equals(kv));\n+        assertTrue(kv.equals(kv2));\n+        assertTrue(kv.hashCode() == kv2.hashCode());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToString() {\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n+\n+        // test with nulls\n+        kv = makeDefaultKeyValue(null, null);\n+        assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToMapEntry() {\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put(kv.getKey(), kv.getValue());\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+\n+        assertTrue(entry.equals(kv.toMapEntry()));\n+        assertTrue(entry.hashCode() == kv.hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/TestDefaultMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * Test the DefaultMapEntry class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Neil O'Toole\n+ */\n+public class TestDefaultMapEntry<K, V> extends AbstractTestMapEntry<K, V> {\n+\n+    public TestDefaultMapEntry(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new DefaultMapEntry<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        return new DefaultMapEntry<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Subclasses should override this method.\n+     *\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test key-value constructor\n+        Map.Entry<K, V> entry = new DefaultMapEntry<K, V>((K) key, (V) value);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 2. test pair constructor\n+        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        assertSame(key, pair.getKey());\n+        assertSame(value, pair.getValue());\n+\n+        // 3. test copy constructor\n+        Map.Entry<K, V> entry2 = new DefaultMapEntry<K, V>(entry);\n+        assertSame(key, entry2.getKey());\n+        assertSame(value, entry2.getValue());\n+\n+        // test that the objects are independent\n+        entry.setValue(null);\n+        assertSame(value, entry2.getValue());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        Map.Entry<K, V> entry = makeMapEntry();\n+\n+        try {\n+            entry.setValue((V) entry);\n+            assertSame(entry, entry.getValue());\n+\n+        } catch (Exception e) {\n+            fail(\"This Map.Entry implementation supports value self-reference.\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/TestMultiKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.collections.keyvalue.MultiKey}.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestMultiKey extends TestCase {\n+\n+    Integer ONE = new Integer(1);\n+    Integer TWO = new Integer(2);\n+    Integer THREE = new Integer(3);\n+    Integer FOUR = new Integer(4);\n+    Integer FIVE = new Integer(5);\n+\n+    public TestMultiKey(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructors() throws Exception {\n+        MultiKey<Integer> mk = null;\n+        mk = new MultiKey<Integer>(ONE, TWO);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE, FOUR);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE, FOUR, FIVE);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR, FIVE }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(new Integer[] { THREE, FOUR, ONE, TWO }, false);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+    }\n+\n+    public void testConstructorsByArray() throws Exception {\n+        MultiKey<Integer> mk = null;\n+        Integer[] keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        keys[3] = FIVE;  // no effect\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+\n+        keys = new Integer[] {};\n+        mk = new MultiKey<Integer>(keys);\n+        Assert.assertTrue(Arrays.equals(new Object[] {}, mk.getKeys()));\n+\n+        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys, true);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        keys[3] = FIVE;  // no effect\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+\n+        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys, false);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        // change key - don't do this!\n+        // the hashcode of the MultiKey is now broken\n+        keys[3] = FIVE;\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, FIVE }, mk.getKeys()));\n+    }\n+\n+    public void testConstructorsByArrayNull() throws Exception {\n+        Integer[] keys = null;\n+        try {\n+            new MultiKey<Integer>(keys);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey<Integer>(keys, true);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey<Integer>(keys, false);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        Assert.assertEquals(2, new MultiKey<Integer>(ONE, TWO).size());\n+        Assert.assertEquals(2, new MultiKey<Object>(null, null).size());\n+        Assert.assertEquals(3, new MultiKey<Integer>(ONE, TWO, THREE).size());\n+        Assert.assertEquals(3, new MultiKey<Object>(null, null, null).size());\n+        Assert.assertEquals(4, new MultiKey<Integer>(ONE, TWO, THREE, FOUR).size());\n+        Assert.assertEquals(4, new MultiKey<Object>(null, null, null, null).size());\n+        Assert.assertEquals(5, new MultiKey<Integer>(ONE, TWO, THREE, FOUR, FIVE).size());\n+        Assert.assertEquals(5, new MultiKey<Object>(null, null, null, null, null).size());\n+\n+        Assert.assertEquals(0, new MultiKey<Object>(new Object[] {}).size());\n+        Assert.assertEquals(1, new MultiKey<Integer>(new Integer[] { ONE }).size());\n+        Assert.assertEquals(2, new MultiKey<Integer>(new Integer[] { ONE, TWO }).size());\n+        Assert.assertEquals(7, new MultiKey<Integer>(new Integer[] { ONE, TWO, ONE, TWO, ONE, TWO, ONE }).size());\n+    }\n+\n+    public void testGetIndexed() {\n+        MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        Assert.assertSame(ONE, mk.getKey(0));\n+        Assert.assertSame(TWO, mk.getKey(1));\n+        try {\n+            mk.getKey(-1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            mk.getKey(2);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetKeysSimpleConstructor() {\n+        MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        Object[] array = mk.getKeys();\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+\n+    public void testGetKeysArrayConstructorCloned() {\n+        Integer[] keys = new Integer[] { ONE, TWO };\n+        MultiKey<Integer> mk = new MultiKey<Integer>(keys, true);\n+        Object[] array = mk.getKeys();\n+        Assert.assertTrue(array != keys);\n+        Assert.assertTrue(Arrays.equals(array, keys));\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+\n+    public void testGetKeysArrayConstructorNonCloned() {\n+        Integer[] keys = new Integer[] { ONE, TWO };\n+        MultiKey<Integer> mk = new MultiKey<Integer>(keys, false);\n+        Object[] array = mk.getKeys();\n+        Assert.assertTrue(array != keys);  // still not equal\n+        Assert.assertTrue(Arrays.equals(array, keys));\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+\n+    public void testHashCode() {\n+        MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+\n+        Assert.assertTrue(mk1.hashCode() == mk1.hashCode());\n+        Assert.assertTrue(mk1.hashCode() == mk2.hashCode());\n+        Assert.assertTrue(mk1.hashCode() != mk3.hashCode());\n+\n+        int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();\n+        Assert.assertEquals(total, mk1.hashCode());\n+    }\n+\n+    public void testEquals() {\n+        MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+\n+        Assert.assertEquals(mk1, mk1);\n+        Assert.assertEquals(mk1, mk2);\n+        Assert.assertTrue(mk1.equals(mk3) == false);\n+        Assert.assertTrue(mk1.equals(\"\") == false);\n+        Assert.assertTrue(mk1.equals(null) == false);\n+    }\n+\n+    static class SystemHashCodeSimulatingKey implements Serializable {\n+\n+        private static final long serialVersionUID = -1736147315703444603L;\n+        private final String name;\n+        private int hashCode = 1;\n+\n+        public SystemHashCodeSimulatingKey(String name)\n+        {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj)\n+        {\n+            return obj instanceof SystemHashCodeSimulatingKey \n+                && name.equals(((SystemHashCodeSimulatingKey)obj).name);\n+        }\n+\n+        @Override\n+        public int hashCode()\n+        {\n+            return hashCode;\n+        }\n+\n+        private Object readResolve() {\n+            hashCode=2; // simulate different hashCode after deserialization in another process\n+            return this;\n+        }\n+    }\n+    \n+    public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException\n+    {\n+        SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey(\"test\");\n+        MultiKey mk = new MultiKey(ONE, sysKey);\n+        Map map = new HashMap();\n+        map.put(mk, TWO);\n+\n+        // serialize\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(sysKey);\n+        out.writeObject(map);\n+        out.close();\n+\n+        // deserialize\n+        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+        ObjectInputStream in = new ObjectInputStream(bais);\n+        sysKey = (SystemHashCodeSimulatingKey)in.readObject(); // simulate deserialization in another process\n+        Map map2 = (Map) in.readObject();\n+        in.close();\n+\n+        assertEquals(2, sysKey.hashCode()); // different hashCode now\n+\n+        MultiKey mk2 = new MultiKey(ONE, sysKey);\n+        assertEquals(TWO, map2.get(mk2));        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/TestTiedMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Test the TiedMapEntry class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTiedMapEntry<K, V> extends AbstractTestMapEntry<K, V> {\n+\n+    public TestTiedMapEntry(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the instance to test\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put(key, value);\n+        return new TiedMapEntry<K, V>(map, key);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests the constructors.\n+     */\n+    @Override\n+    public void testConstructors() {\n+        // ignore\n+    }\n+\n+    /**\n+     * Tests the constructors.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValue() {\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"A\", (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n+        map.put((K) \"C\", (V) \"c\");\n+        Map.Entry<K, V> entry = new TiedMapEntry<K, V>(map, (K) \"A\");\n+        assertSame(\"A\", entry.getKey());\n+        assertSame(\"a\", entry.getValue());\n+        assertSame(\"a\", entry.setValue((V) \"x\"));\n+        assertSame(\"A\", entry.getKey());\n+        assertSame(\"x\", entry.getValue());\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"B\");\n+        assertSame(\"B\", entry.getKey());\n+        assertSame(\"b\", entry.getValue());\n+        assertSame(\"b\", entry.setValue((V) \"y\"));\n+        assertSame(\"B\", entry.getKey());\n+        assertSame(\"y\", entry.getValue());\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"C\");\n+        assertSame(\"C\", entry.getKey());\n+        assertSame(\"c\", entry.getValue());\n+        assertSame(\"c\", entry.setValue((V) \"z\"));\n+        assertSame(\"C\", entry.getKey());\n+        assertSame(\"z\", entry.getValue());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/TestUnmodifiableMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Test the UnmodifiableMapEntry class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Neil O'Toole\n+ */\n+public class TestUnmodifiableMapEntry<K, V> extends AbstractTestMapEntry<K, V> {\n+\n+    public TestUnmodifiableMapEntry(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new UnmodifiableMapEntry<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        return new UnmodifiableMapEntry<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Subclasses should override this method.\n+     *\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test key-value constructor\n+        Map.Entry<K, V> entry = new UnmodifiableMapEntry<K, V>((K) key, (V) value);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 2. test pair constructor\n+        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        entry = new UnmodifiableMapEntry<K, V>(pair);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 3. test copy constructor\n+        Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<K, V>(entry);\n+        assertSame(key, entry2.getKey());\n+        assertSame(value, entry2.getValue());\n+\n+        assertTrue(entry instanceof Unmodifiable);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // check that null doesn't do anything funny\n+        entry = makeMapEntry(null, null);\n+        assertSame(null, entry.getKey());\n+        assertSame(null, entry.getValue());\n+    }\n+\n+    @Override\n+    public void testSelfReferenceHandling() {\n+        // block\n+    }\n+\n+    public void testUnmodifiable() {\n+        Map.Entry<K, V> entry = makeMapEntry();\n+        try {\n+            entry.setValue(null);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/AbstractTestLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Test case for {@link AbstractLinkedList}.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rich Dougherty\n+ * @author David Hay\n+ * @author Phil Steitz\n+ */\n+public abstract class AbstractTestLinkedList<E> extends AbstractTestList<E> {\n+\n+    public AbstractTestLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFirst() {\n+        resetEmpty();\n+        AbstractLinkedList<E> list = getCollection();\n+        if (isRemoveSupported() == false) {\n+            try {\n+                list.removeFirst();\n+            } catch (UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value1\", list.removeFirst());\n+        checkNodes();\n+        list.addLast((E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.removeFirst());\n+        assertEquals(\"value3\", list.removeFirst());\n+        checkNodes();\n+        list.addLast((E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value4\", list.removeFirst());\n+        checkNodes();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLast() {\n+        resetEmpty();\n+        AbstractLinkedList<E> list = getCollection();\n+        if (isRemoveSupported() == false) {\n+            try {\n+                list.removeLast();\n+            } catch (UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value2\", list.removeLast());\n+        list.addFirst((E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value1\", list.removeLast());\n+        assertEquals(\"value3\", list.removeLast());\n+        list.addFirst((E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value4\", list.removeFirst());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddNodeAfter() {\n+        resetEmpty();\n+        AbstractLinkedList<E> list = getCollection();\n+        if (isAddSupported() == false) {\n+            try {\n+                list.addFirst(null);\n+            } catch (UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addFirst((E) \"value1\");\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value2\");\n+        assertEquals(\"value1\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.removeFirst();\n+        checkNodes();\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        assertEquals(\"value4\", list.get(1));\n+        list.addNodeAfter(list.getNode(2, false), (E) \"value5\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value4\", list.get(1));\n+        assertEquals(\"value3\", list.get(2));\n+        assertEquals(\"value5\", list.getLast());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveNode() {\n+        resetEmpty();\n+        if (isAddSupported() == false || isRemoveSupported() == false) return;\n+        AbstractLinkedList<E> list = getCollection();\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        list.removeNode(list.getNode(0, false));\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.addFirst((E) \"value1\");\n+        list.addFirst((E) \"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value0\", list.getLast());\n+        checkNodes();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGetNode() {\n+        resetEmpty();\n+        AbstractLinkedList<E> list = getCollection();\n+        // get marker\n+        assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n+        try {\n+            list.getNode(0, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        list.addAll( Arrays.asList((E[]) new String[]{\"value1\", \"value2\"}));\n+        checkNodes();\n+        list.addFirst((E) \"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        checkNodes();\n+        try {\n+            list.getNode(2, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        try {\n+            list.getNode(-1, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+         try {\n+            list.getNode(3, true);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+    }\n+\n+    protected void checkNodes() {\n+        AbstractLinkedList<E> list = getCollection();\n+        for (int i = 0; i < list.size; i++) {\n+            assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n+            if (i < list.size - 1) {\n+                assertEquals(list.getNode(i + 1, false).previous,\n+                    list.getNode(i, false));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public AbstractLinkedList<E> getCollection() {\n+        return (AbstractLinkedList<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/AbstractTestList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.iterators.AbstractTestListIterator;\n+\n+/**\n+ * Abstract test class for {@link java.util.List} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject} method.\n+ * <p>\n+ * If your {@link List} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link List} fails or override one of the\n+ * protected methods from AbstractTestCollection.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Neil O'Toole\n+ */\n+public abstract class AbstractTestList<E> extends AbstractTestCollection<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractTestList(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>set operation.<p>\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support set.\n+     */\n+    public boolean isSetSupported() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that the test list implementation matches the confirmed list\n+     *  implementation.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void verify() {\n+        super.verify();\n+\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        assertEquals(\"List should equal confirmed\", list1, list2);\n+        assertEquals(\"Confirmed should equal list\", list2, list1);\n+\n+        assertEquals(\"Hash codes should be equal\", list1.hashCode(), list2.hashCode());\n+\n+        int i = 0;\n+        Iterator<E> iterator1 = list1.iterator();\n+        Iterator<E> iterator2 = list2.iterator();\n+        E[] array = (E[]) list1.toArray();\n+        while (iterator2.hasNext()) {\n+            assertTrue(\"List iterator should have next\", iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(\"Iterator elements should be equal\", o1, o2);\n+            o2 = list1.get(i);\n+            assertEquals(\"get should return correct element\", o1, o2);\n+            o2 = array[i];\n+            assertEquals(\"toArray should have correct element\", o1, o2);\n+            i++;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * List equals method is defined.\n+     */\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns an empty {@link ArrayList}.\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        return list;\n+    }\n+\n+    /**\n+     * Returns a full {@link ArrayList}.\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     * Returns {@link #makeObject()}.\n+     *\n+     * @return an empty list to be used for testing\n+     */\n+    @Override\n+    public abstract List<E> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> makeFullCollection() {\n+        // only works if list supports optional \"addAll(Collection)\"\n+        List<E> list = makeObject();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the {@link #collection} field cast to a {@link List}.\n+     *\n+     * @return the collection field as a List\n+     */\n+    @Override\n+    public List<E> getCollection() {\n+        return (List<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * Returns the {@link #confirmed} field cast to a {@link List}.\n+     *\n+     * @return the confirmed field as a List\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on an\n+     *  empty list.\n+     */\n+    public void testListAddByIndexBoundsChecking() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        List<E> list;\n+        E element = getOtherElements()[0];\n+\n+        try {\n+            list = makeObject();\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeObject();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeObject();\n+            list.add(1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeObject();\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on a\n+     *  full list.\n+     */\n+    public void testListAddByIndexBoundsChecking2() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        List<E> list;\n+        E element = getOtherElements()[0];\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(list.size() + 1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [size + 1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#add(int,Object)}.\n+     */\n+    public void testListAddByIndex() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        E element = getOtherElements()[0];\n+        int max = getFullElements().length;\n+\n+        for (int i = 0; i <= max; i++) {\n+            resetFull();\n+            getCollection().add(i, element);\n+            getConfirmed().add(i, element);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#equals(Object)}.\n+     */\n+    public void testListEquals() {\n+        resetEmpty();\n+        List<E> list = getCollection();\n+        assertEquals(\"Empty lists should be equal\", true, list.equals(getConfirmed()));\n+        verify();\n+        assertEquals(\"Empty list should equal self\", true, list.equals(list));\n+        verify();\n+\n+        List<E> list2 = Arrays.asList(getFullElements());\n+        assertEquals(\"Empty list shouldn't equal full\", false, list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertEquals(\"Empty list shouldn't equal other\", false, list.equals(list2));\n+        verify();\n+\n+        resetFull();\n+        list = getCollection();\n+        assertEquals(\"Full lists should be equal\", true, list.equals(getConfirmed()));\n+        verify();\n+        assertEquals(\"Full list should equal self\", true, list.equals(list));\n+        verify();\n+\n+        list2 = makeObject();\n+        assertEquals(\"Full list shouldn't equal empty\", false, list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertEquals(\"Full list shouldn't equal other\", false, list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getFullElements());\n+        if (list2.size() < 2 && isAddSupported()) {\n+            // main list is only size 1, so lets add other elements to get a better list\n+            list.addAll(Arrays.asList(getOtherElements()));\n+            getConfirmed().addAll(Arrays.asList(getOtherElements()));\n+            list2 = new ArrayList<E>(list2);\n+            list2.addAll(Arrays.asList(getOtherElements()));\n+        }\n+        if (list2.size() > 1) {\n+            Collections.reverse(list2);\n+            assertEquals(\n+                \"Full list shouldn't equal full list with same elements but different order\",\n+                false, list.equals(list2));\n+            verify();\n+        }\n+\n+        resetFull();\n+        list = getCollection();\n+        assertEquals(\"List shouldn't equal String\", false, list.equals(\"\"));\n+        verify();\n+\n+        final List<E> listForC = Arrays.asList(getFullElements());\n+        Collection<E> c = new AbstractCollection<E>() {\n+            @Override\n+            public int size() {\n+                return listForC.size();\n+            }\n+\n+            @Override\n+            public Iterator<E> iterator() {\n+                return listForC.iterator();\n+            }\n+        };\n+\n+        assertEquals(\"List shouldn't equal nonlist with same elements in same order\", false, list.equals(c));\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link List#hashCode()}.\n+     */\n+    public void testListHashCode() {\n+        resetEmpty();\n+        int hash1 = getCollection().hashCode();\n+        int hash2 = getConfirmed().hashCode();\n+        assertEquals(\"Empty lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+\n+        resetFull();\n+        hash1 = getCollection().hashCode();\n+        hash2 = getConfirmed().hashCode();\n+        assertEquals(\"Full lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link List#get(int)}.\n+     */\n+    public void testListGetByIndex() {\n+        resetFull();\n+        List<E> list = getCollection();\n+        E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertEquals(\"List should contain correct elements\", elements[i], list.get(i));\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on an\n+     *  empty list.\n+     */\n+    public void testListGetByIndexBoundsChecking() {\n+        List<E> list = makeObject();\n+\n+        try {\n+            list.get(Integer.MIN_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(-1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(0);\n+            fail(\"List.get should throw IndexOutOfBoundsException [0]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(Integer.MAX_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on a\n+     *  full list.\n+     */\n+    public void testListGetByIndexBoundsChecking2() {\n+        List<E> list = makeFullCollection();\n+\n+        try {\n+            list.get(Integer.MIN_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(-1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(getFullElements().length);\n+            fail(\"List.get should throw IndexOutOfBoundsException [size]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(Integer.MAX_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#indexOf}.\n+     */\n+    public void testListIndexOf() {\n+        resetFull();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        Iterator<E> iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            Object element = iterator.next();\n+            assertEquals(\"indexOf should return correct result\",\n+                list1.indexOf(element), list2.indexOf(element));\n+            verify();\n+        }\n+\n+        E[] other = getOtherElements();\n+        for (int i = 0; i < other.length; i++) {\n+            assertEquals(\"indexOf should return -1 for nonexistent element\",\n+                -1, list1.indexOf(other[i]));\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#lastIndexOf}.\n+     */\n+    public void testListLastIndexOf() {\n+        resetFull();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        Iterator<E> iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            E element = iterator.next();\n+            assertEquals(\"lastIndexOf should return correct result\",\n+              list1.lastIndexOf(element), list2.lastIndexOf(element));\n+            verify();\n+        }\n+\n+        E[] other = getOtherElements();\n+        for (int i = 0; i < other.length; i++) {\n+            assertEquals(\"lastIndexOf should return -1 for nonexistent \" +\n+                \"element\", -1, list1.lastIndexOf(other[i]));\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on an\n+     *  empty list.\n+     */\n+    public void testListSetByIndexBoundsChecking() {\n+        if (!isSetSupported()) {\n+            return;\n+        }\n+\n+        List<E> list = makeObject();\n+        E element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(0, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [0]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on a\n+     *  full list.\n+     */\n+    public void testListSetByIndexBoundsChecking2() {\n+        if (!isSetSupported()) return;\n+\n+        List<E> list = makeFullCollection();\n+        E element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(getFullElements().length, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [size]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Test {@link List#set(int,Object)}.\n+     */\n+    public void testListSetByIndex() {\n+        if (!isSetSupported()) return;\n+\n+        resetFull();\n+        E[] elements = getFullElements();\n+        E[] other = getOtherElements();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            E n = other[i % other.length];\n+            E v = (getCollection()).set(i, n);\n+            assertEquals(\"Set should return correct element\", elements[i], v);\n+            (getConfirmed()).set(i, n);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  If {@link #isSetSupported()} returns false, tests that set operation\n+     *  raises <Code>UnsupportedOperationException.\n+     */\n+    public void testUnsupportedSet() {\n+        if (isSetSupported()) return;\n+\n+        resetFull();\n+        try {\n+            (getCollection()).set(0, getFullElements()[0]);\n+            fail(\"Emtpy collection should not support set.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on an\n+     *  empty list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking() {\n+        if (!isRemoveSupported()) return;\n+\n+        List<E> list = makeObject();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(0);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on a\n+     *  full list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking2() {\n+        if (!isRemoveSupported()) return;\n+\n+        List<E> list = makeFullCollection();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(getFullElements().length);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#remove(int)}.\n+     */\n+    public void testListRemoveByIndex() {\n+        if (!isRemoveSupported()) return;\n+\n+        int max = getFullElements().length;\n+        for (int i = 0; i < max; i++) {\n+            resetFull();\n+            E o1 = (getCollection()).remove(i);\n+            E o2 = (getConfirmed()).remove(i);\n+            assertEquals(\"remove should return correct element\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator()}.\n+     */\n+    public void testListListIterator() {\n+        resetFull();\n+        forwardTest(getCollection().listIterator(), 0);\n+        backwardTest(getCollection().listIterator(), 0);\n+    }\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator(int)}.\n+     */\n+    public void testListListIteratorByIndex() {\n+        resetFull();\n+        try {\n+            getCollection().listIterator(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        resetFull();\n+        try {\n+            getCollection().listIterator(getCollection().size() + 1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        resetFull();\n+        for (int i = 0; i <= getConfirmed().size(); i++) {\n+            forwardTest(getCollection().listIterator(i), i);\n+            backwardTest(getCollection().listIterator(i), i);\n+        }\n+        resetFull();\n+        for (int i = 0; i <= getConfirmed().size(); i++) {\n+            backwardTest(getCollection().listIterator(i), i);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorPreviousRemoveNext() {\n+        if (isRemoveSupported() == false) return;\n+        resetFull();\n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        E two2 = it.previous();\n+        E one2 = it.previous();\n+        assertEquals(one, one2);\n+        assertEquals(two, two2);\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n+        it.remove(); // removed element at index 1 (one)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(two, getCollection().get(1));\n+        E two3 = it.next();  // do next after remove\n+        assertEquals(two, two3);\n+        assertEquals(getCollection().size() > 2, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorPreviousRemovePrevious() {\n+        if (isRemoveSupported() == false) return;\n+        resetFull();\n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        E two2 = it.previous();\n+        E one2 = it.previous();\n+        assertEquals(one, one2);\n+        assertEquals(two, two2);\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n+        it.remove(); // removed element at index 1 (one)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(two, getCollection().get(1));\n+        E zero3 = it.previous();  // do previous after remove\n+        assertEquals(zero, zero3);\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(getCollection().size() > 2, it.hasNext());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorNextRemoveNext() {\n+        if (isRemoveSupported() == false) return;\n+        resetFull();\n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+        E three = getCollection().get(3);\n+\n+        it.remove(); // removed element at index 2 (two)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        E three2 = it.next();  // do next after remove\n+        assertEquals(three, three2);\n+        assertEquals(getCollection().size() > 3, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorNextRemovePrevious() {\n+        if (isRemoveSupported() == false) return;\n+        resetFull();\n+        if (getCollection().size() < 4) return;\n+        ListIterator<E> it = getCollection().listIterator();\n+        E zero = it.next();\n+        E one = it.next();\n+        E two = it.next();\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n+        it.remove(); // removed element at index 2 (two)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        E one2 = it.previous();  // do previous after remove\n+        assertEquals(one, one2);\n+        assertEquals(true, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Traverses to the end of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void forwardTest(ListIterator<E> iter, int i) {\n+        List<E> list = getCollection();\n+        int max = getFullElements().length;\n+\n+        while (i < max) {\n+            assertTrue(\"Iterator should have next\", iter.hasNext());\n+            assertEquals(\"Iterator.nextIndex should work\",\n+                i, iter.nextIndex());\n+            assertEquals(\"Iterator.previousIndex should work\",\n+                i - 1, iter.previousIndex());\n+            Object o = iter.next();\n+            assertEquals(\"Iterator returned correct element\", list.get(i), o);\n+            i++;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have next\", !iter.hasNext());\n+        assertEquals(\"nextIndex should be size\", max, iter.nextIndex());\n+        assertEquals(\"previousIndex should be size - 1\", max - 1, iter.previousIndex());\n+\n+        try {\n+            iter.next();\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Traverses to the beginning of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void backwardTest(ListIterator<E> iter, int i) {\n+        List<E> list = getCollection();\n+\n+        while (i > 0) {\n+            assertTrue(\"Iterator should have previous, i:\" + i,\n+                iter.hasPrevious());\n+            assertEquals(\"Iterator.nextIndex should work, i:\" + i,\n+                i, iter.nextIndex());\n+            assertEquals(\"Iterator.previousIndex should work, i:\" + i,\n+                i - 1, iter.previousIndex());\n+            E o = iter.previous();\n+            assertEquals(\"Iterator returned correct element\",\n+                list.get(i - 1), o);\n+            i--;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have previous\", !iter.hasPrevious());\n+        int nextIndex = iter.nextIndex();\n+        assertEquals(\"nextIndex should be 0\", 0, nextIndex);\n+        int prevIndex = iter.previousIndex();\n+        assertEquals(\"previousIndex should be -1\", -1, prevIndex);\n+\n+        try {\n+            iter.previous();\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Tests the {@link ListIterator#add(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorAdd() {\n+        if (!isAddSupported()) return;\n+\n+        resetEmpty();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        E[] elements = getFullElements();\n+        ListIterator<E> iter1 = list1.listIterator();\n+        ListIterator<E> iter2 = list2.listIterator();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            verify();\n+        }\n+\n+        resetFull();\n+        iter1 = getCollection().listIterator();\n+        iter2 = getConfirmed().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests the {@link ListIterator#set(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorSet() {\n+        if (!isSetSupported()) return;\n+\n+        E[] elements = getFullElements();\n+\n+        resetFull();\n+        ListIterator<E> iter1 = getCollection().listIterator();\n+        ListIterator<E> iter2 = getConfirmed().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.set(elements[i]);\n+            iter2.set(elements[i]);\n+            verify();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyListSerialization() throws IOException, ClassNotFoundException {\n+        List<E> list = makeObject();\n+        if (!(list instanceof Serializable && isTestSerialization())) return;\n+\n+        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Both lists are empty\", 0, list.size());\n+        assertEquals(\"Both lists are empty\", 0, list2.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullListSerialization() throws IOException, ClassNotFoundException {\n+        List<E> list = makeFullCollection();\n+        int size = getFullElements().length;\n+        if (!(list instanceof Serializable && isTestSerialization())) return;\n+\n+        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Both lists are same size\", size, list.size());\n+        assertEquals(\"Both lists are same size\", size, list2.size());\n+    }\n+\n+    /**\n+     * Skip the serialized canonical tests for now.\n+     *\n+     * @return true\n+     *\n+     * TODO: store new serialized objects in CVS.\n+     */\n+    @Override\n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the List\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        List list = makeEmptyList();\n+        if (!(list instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        List<E> list = makeObject();\n+        if (list instanceof Serializable && !skipSerializedCanonicalTests()\n+                && isTestSerialization()) {\n+            List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n+            assertEquals(\"List is empty\", 0, list2.size());\n+            assertEquals(list, list2);\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the List\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullListCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        List list = makeFullList();\n+        if (!(list instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        List<E> list = makeFullCollection();\n+        if(list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n+            if (list2.size() == 4) {\n+                // old serialized tests\n+                return;\n+            }\n+            assertEquals(\"List is the right size\",list.size(), list2.size());\n+            assertEquals(list, list2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.\n+     *  The returned bulk test will run through every <code>TestList</code>\n+     *  method, <i>including</i> another <code>bulkTestSubList</code>.\n+     *  Sublists are tested until the size of the sublist is less than 10.\n+     *  Each sublist is 6 elements smaller than its parent list.\n+     *  (By default this means that two rounds of sublists will be tested).\n+     *  The verify() method is overloaded to test that the original list is\n+     *  modified when the sublist is.\n+     */\n+    public BulkTest bulkTestSubList() {\n+        if (getFullElements().length - 6 < 10) return null;\n+        return new BulkTestSubList<E>(this);\n+    }\n+\n+   public static class BulkTestSubList<E> extends AbstractTestList<E> {\n+\n+       private AbstractTestList<E> outer;\n+\n+       public BulkTestSubList(AbstractTestList<E> outer) {\n+           super(\"\");\n+           this.outer = outer;\n+       }\n+\n+       @Override\n+       @SuppressWarnings(\"unchecked\")\n+       public E[] getFullElements() {\n+           List<E> l = Arrays.asList(outer.getFullElements());\n+           return (E[]) l.subList(3, l.size() - 3).toArray();\n+       }\n+\n+       @Override\n+       public E[] getOtherElements() {\n+           return outer.getOtherElements();\n+       }\n+\n+       @Override\n+       public boolean isAddSupported() {\n+           return outer.isAddSupported();\n+       }\n+\n+       @Override\n+       public boolean isSetSupported() {\n+           return outer.isSetSupported();\n+       }\n+\n+       @Override\n+       public boolean isRemoveSupported() {\n+           return outer.isRemoveSupported();\n+       }\n+\n+       @Override\n+       public List<E> makeObject() {\n+           return outer.makeFullCollection().subList(4, 4);\n+       }\n+\n+       @Override\n+       public List<E> makeFullCollection() {\n+           int size = getFullElements().length;\n+           return outer.makeFullCollection().subList(3, size - 3);\n+       }\n+\n+       @Override\n+       public void resetEmpty() {\n+           outer.resetFull();\n+           this.setCollection(outer.getCollection().subList(4, 4));\n+           this.setConfirmed(outer.getConfirmed().subList(4, 4));\n+       }\n+\n+       @Override\n+       public void resetFull() {\n+           outer.resetFull();\n+           int size = outer.getConfirmed().size();\n+           this.setCollection(outer.getCollection().subList(3, size - 3));\n+           this.setConfirmed(outer.getConfirmed().subList(3, size - 3));\n+       }\n+\n+       @Override\n+       public void verify() {\n+           super.verify();\n+           outer.verify();\n+       }\n+\n+       @Override\n+       public boolean isTestSerialization() {\n+           return false;\n+       }\n+   }\n+\n+   /**\n+    *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n+    *  if elements are added to the original list.\n+    */\n+   public void testListSubListFailFastOnAdd() {\n+       if (!isFailFastSupported()) return;\n+       if (!isAddSupported()) return;\n+\n+       resetFull();\n+       int size = getCollection().size();\n+       List<E> sub = getCollection().subList(1, size);\n+       getCollection().add(getOtherElements()[0]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().add(0, getOtherElements()[0]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().addAll(Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().addAll(0, Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+   }\n+\n+   /**\n+    *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n+    *  if elements are removed from the original list.\n+    */\n+   public void testListSubListFailFastOnRemove() {\n+       if (!isFailFastSupported()) return;\n+       if (!isRemoveSupported()) return;\n+\n+       resetFull();\n+       int size = getCollection().size();\n+       List<E> sub = getCollection().subList(1, size);\n+       getCollection().remove(0);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().remove(getFullElements()[2]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().removeAll(Arrays.asList(getFullElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().retainAll(Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().clear();\n+       failFastAll(sub);\n+   }\n+\n+   /**\n+    *  Invokes all the methods on the given sublist to make sure they raise\n+    *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n+    */\n+   protected void failFastAll(List<E> list) {\n+       Method[] methods = List.class.getMethods();\n+       for (int i = 0; i < methods.length; i++) {\n+           failFastMethod(list, methods[i]);\n+       }\n+   }\n+\n+   /**\n+    *  Invokes the given method on the given sublist to make sure it raises\n+    *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n+    *\n+    *  Unless the method happens to be the equals() method, in which case\n+    *  the test is skipped.  There seems to be a bug in\n+    *  java.util.AbstractList.subList(int,int).equals(Object) -- it never\n+    *  raises a ConcurrentModificationException.\n+    *\n+    *  @param list  the sublist to test\n+    *  @param m     the method to invoke\n+    */\n+   protected void failFastMethod(List<E> list, Method m) {\n+       if (m.getName().equals(\"equals\")) return;\n+\n+       E element = getOtherElements()[0];\n+       Collection<E> c = Collections.singleton(element);\n+\n+       Class<?>[] types = m.getParameterTypes();\n+       Object[] params = new Object[types.length];\n+       for (int i = 0; i < params.length; i++) {\n+           if (types[i] == Integer.TYPE) params[i] = new Integer(0);\n+           else if (types[i] == Collection.class) params[i] = c;\n+           else if (types[i] == Object.class) params[i] = element;\n+           else if (types[i] == Object[].class) params[i] = new Object[0];\n+       }\n+\n+       try {\n+           m.invoke(list, params);\n+           fail(m.getName() + \" should raise ConcurrentModification\");\n+       } catch (IllegalAccessException e) {\n+           // impossible\n+       } catch (InvocationTargetException e) {\n+           Throwable t = e.getTargetException();\n+           if (t instanceof ConcurrentModificationException) {\n+               // expected\n+               return;\n+           } else {\n+               fail(m.getName() + \" raised unexpected \" + e);\n+           }\n+       }\n+   }\n+\n+   //-----------------------------------------------------------------------\n+   public BulkTest bulkTestListIterator() {\n+       return new TestListIterator();\n+   }\n+\n+   public class TestListIterator extends AbstractTestListIterator<E> {\n+       public TestListIterator() {\n+           super(\"TestListIterator\");\n+       }\n+\n+       @Override\n+       public E addSetValue() {\n+           return AbstractTestList.this.getOtherElements()[0];\n+       }\n+\n+       @Override\n+       public boolean supportsRemove() {\n+           return AbstractTestList.this.isRemoveSupported();\n+       }\n+\n+       @Override\n+       public boolean supportsAdd() {\n+           return AbstractTestList.this.isAddSupported();\n+       }\n+\n+       @Override\n+       public boolean supportsSet() {\n+           return AbstractTestList.this.isSetSupported();\n+       }\n+\n+       @Override\n+       public ListIterator<E> makeEmptyIterator() {\n+           resetEmpty();\n+           return AbstractTestList.this.getCollection().listIterator();\n+       }\n+\n+       @Override\n+       public ListIterator<E> makeObject() {\n+           resetFull();\n+           return AbstractTestList.this.getCollection().listIterator();\n+       }\n+   }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestCursorableLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Test class.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Simon Kitching\n+ */\n+public class TestCursorableLinkedList<E> extends AbstractTestLinkedList<E> {\n+    public TestCursorableLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestCursorableLinkedList.class);\n+    }\n+\n+    private CursorableLinkedList<E> list;\n+\n+    @Override\n+    public void setUp() {\n+        list = new CursorableLinkedList<E>();\n+    }\n+\n+    @Override\n+    public CursorableLinkedList<E> makeObject() {\n+        return new CursorableLinkedList<E>();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAdd() {\n+        assertEquals(\"[]\",list.toString());\n+        assertTrue(list.add((E) new Integer(1)));\n+        assertEquals(\"[1]\",list.toString());\n+        assertTrue(list.add((E) new Integer(2)));\n+        assertEquals(\"[1, 2]\",list.toString());\n+        assertTrue(list.add((E) new Integer(3)));\n+        assertEquals(\"[1, 2, 3]\",list.toString());\n+        assertTrue(list.addFirst((E) new Integer(0)));\n+        assertEquals(\"[0, 1, 2, 3]\",list.toString());\n+        assertTrue(list.addLast((E) new Integer(4)));\n+        assertEquals(\"[0, 1, 2, 3, 4]\",list.toString());\n+        list.add(0,(E) new Integer(-2));\n+        assertEquals(\"[-2, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(1,(E) new Integer(-1));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(7,(E) new Integer(5));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5]\",list.toString());\n+\n+        java.util.List<E> list2 = new java.util.LinkedList<E>();\n+        list2.add((E) \"A\");\n+        list2.add((E) \"B\");\n+        list2.add((E) \"C\");\n+\n+        assertTrue(list.addAll(list2));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+        assertTrue(list.addAll(3,list2));\n+        assertEquals(\"[-2, -1, 0, A, B, C, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClear() {\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        list.add((E) \"element\");\n+        assertEquals(1,list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        list.add((E) \"element1\");\n+        list.add((E) \"element2\");\n+        assertEquals(2,list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        for (int i = 0; i < 1000; i++) {\n+            list.add((E) new Integer(i));\n+        }\n+        assertEquals(1000, list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContains() {\n+        assertTrue(!list.contains(\"A\"));\n+        assertTrue(list.add((E) \"A\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.add((E) \"B\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.addFirst((E) \"a\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.remove(\"a\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.remove(\"A\"));\n+        assertTrue(!list.contains(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsAll() {\n+        assertTrue(list.containsAll(list));\n+        java.util.List<E> list2 = new java.util.LinkedList<E>();\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"A\");\n+        assertTrue(!list.containsAll(list2));\n+        list.add((E) \"B\");\n+        list.add((E) \"A\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"B\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"C\");\n+        assertTrue(!list.containsAll(list2));\n+        list.add((E) \"C\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"C\");\n+        assertTrue(list.containsAll(list2));\n+        assertTrue(list.containsAll(list));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNavigation() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"3\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"4\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"5\", it.next());\n+        assertTrue(!it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"5\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"4\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"3\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorSet() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        assertEquals(\"1\", it.next());\n+        it.set((E) \"a\");\n+        assertEquals(\"a\", it.previous());\n+        it.set((E) \"A\");\n+        assertEquals(\"A\", it.next());\n+        assertEquals(\"2\", it.next());\n+        it.set((E) \"B\");\n+        assertEquals(\"3\", it.next());\n+        assertEquals(\"4\", it.next());\n+        it.set((E) \"D\");\n+        assertEquals(\"5\", it.next());\n+        it.set((E) \"E\");\n+        assertEquals(\"[A, B, 3, D, E]\", list.toString());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorRemove() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\", it.next());\n+        assertEquals(\"2\", it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n+        assertEquals(\"3\", it.next());\n+        assertEquals(\"3\", it.previous());\n+        assertEquals(\"1\", it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\", list.toString());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"3\", it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\", list.toString());\n+        try {\n+            it.remove();\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\", it.next());\n+        assertEquals(\"5\", it.next());\n+        it.remove();\n+        assertEquals(\"[4]\", list.toString());\n+        assertEquals(\"4\", it.previous());\n+        it.remove();\n+        assertEquals(\"[]\", list.toString());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorAdd() {\n+        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        it.add((E) \"1\");\n+        assertEquals(\"[1]\", list.toString());\n+        it.add((E) \"3\");\n+        assertEquals(\"[1, 3]\", list.toString());\n+        it.add((E) \"5\");\n+        assertEquals(\"[1, 3, 5]\", list.toString());\n+        assertEquals(\"5\", it.previous());\n+        it.add((E) \"4\");\n+        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n+        assertEquals(\"4\", it.previous());\n+        assertEquals(\"3\", it.previous());\n+        it.add((E) \"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorConcurrentModification() {\n+        // this test verifies that cursors remain valid when the list\n+        // is modified via other means.\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+        list.add((E) \"7\");\n+        list.add((E) \"9\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        CursorableLinkedList.Cursor<E> c2 = list.cursor();\n+        Iterator<E> li = list.iterator();\n+\n+        // test cursors remain valid when list modified by std Iterator\n+        // test cursors skip elements removed via ListIterator\n+        assertEquals(\"1\", li.next());\n+        assertEquals(\"2\", li.next());\n+        li.remove();\n+        assertEquals(\"3\", li.next());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(\"3\", c1.next());\n+        assertEquals(\"1\", c2.next());\n+\n+        // test cursor c1 can remove elements from previously modified list\n+        // test cursor c2 skips elements removed via different cursor\n+        c1.remove();\n+        assertEquals(\"5\", c2.next());\n+        c2.add((E) \"6\");\n+        assertEquals(\"5\", c1.next());\n+        assertEquals(\"6\", c1.next());\n+        assertEquals(\"7\", c1.next());\n+\n+        // test cursors remain valid when list mod via CursorableLinkedList\n+        // test cursor remains valid when elements inserted into list before\n+        // the current position of the cursor.\n+        list.add(0, (E) \"0\");\n+\n+        // test cursor remains valid when element inserted immediately after\n+        // current element of a cursor, and the element is seen on the\n+        // next call to the next method of that cursor.\n+        list.add(5, (E) \"8\");\n+\n+        assertEquals(\"8\", c1.next());\n+        assertEquals(\"9\", c1.next());\n+        c1.add((E) \"10\");\n+        assertEquals(\"7\", c2.next());\n+        assertEquals(\"8\", c2.next());\n+        assertEquals(\"9\", c2.next());\n+        assertEquals(\"10\", c2.next());\n+\n+        try {\n+            c2.next();\n+            fail();\n+        } catch (NoSuchElementException nse) {\n+        }\n+\n+        try {\n+            li.next();\n+            fail();\n+        } catch (ConcurrentModificationException cme) {\n+        }\n+\n+        c1.close(); // not necessary\n+        c2.close(); // not necessary\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexMid() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        Iterator<E> li = list.iterator();\n+\n+        // test cursors remain valid when list modified by std Iterator\n+        // test cursors skip elements removed via ListIterator\n+        assertEquals(\"1\", li.next());\n+        assertEquals(\"2\", li.next());\n+        li.remove();\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"3\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexFirst() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        list.remove(0);\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"2\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"3\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexAddBefore() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        list.add(0, (E) \"0\");\n+        assertEquals(2, c1.nextIndex());\n+        assertEquals(\"2\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexAddNext() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        list.add(0, (E) \"0\");\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"0\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexAddAfter() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        list.add(1, (E) \"0\");\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"0\", c1.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(true, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(\"A\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(true, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextNextRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"C\", c1.next());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(false, c1.nextIndexValid);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(\"C\", c1.current.value);\n+        assertEquals(\"D\", c1.next.value);\n+\n+        assertEquals(\"[A, C, D]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, D]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousRemoveByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        c1.remove();\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextRemoveByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        c1.remove();\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousAddIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        list.add(1, (E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"B\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextAddIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+\n+        list.add(1, (E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"A\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[Z, B, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextAddIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        list.add(1, (E) \"Z\");\n+\n+        assertEquals(false, c1.nextIndexValid);\n+        assertEquals(\"B\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousAddByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        c1.add((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(2, c1.nextIndex);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"B\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextAddByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        c1.add((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(3, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, B, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextRemoveByListSetByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        list.remove(1);\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+        assertEquals(\"[A, C]\", list.toString());\n+\n+        try {\n+            c1.set((E) \"Z\");\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousSetByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        c1.set((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"Z\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextSetByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        c1.set((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(2, c1.nextIndex);\n+        assertEquals(\"Z\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        assertTrue(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+        list.add((E) \"A\");\n+        assertTrue(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+\n+        CursorableLinkedList<E> list2 = new CursorableLinkedList<E>();\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+\n+        java.util.List<E> list3 = new java.util.LinkedList<E>();\n+        assertTrue(!list.equals(list3));\n+        assertTrue(!list3.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list2.add((E) \"A\");\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(!list2.equals(list3));\n+        assertTrue(!list3.equals(list2));\n+\n+        list3.add((E) \"A\");\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add((E) \"B\");\n+        assertTrue(list.equals(list));\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+        assertTrue(!list.equals(list3));\n+        assertTrue(!list3.equals(list));\n+\n+        list2.add((E) \"B\");\n+        list3.add((E) \"B\");\n+        assertTrue(list.equals(list));\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add((E) \"C\");\n+        list2.add((E) \"C\");\n+        list3.add((E) \"C\");\n+        assertTrue(list.equals(list));\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list.hashCode(),list2.hashCode());\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add((E) \"D\");\n+        list2.addFirst((E) \"D\");\n+        assertTrue(list.equals(list));\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGet() {\n+        try {\n+            list.get(0);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        assertTrue(list.add((E) \"A\"));\n+        assertEquals(\"A\",list.get(0));\n+        assertTrue(list.add((E) \"B\"));\n+        assertEquals(\"A\",list.get(0));\n+        assertEquals(\"B\",list.get(1));\n+\n+        try {\n+            list.get(-1);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(2);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIndexOf() {\n+        assertEquals(-1,list.indexOf(\"A\"));\n+        assertEquals(-1,list.lastIndexOf(\"A\"));\n+        list.add((E) \"A\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(-1,list.indexOf(\"B\"));\n+        assertEquals(-1,list.lastIndexOf(\"B\"));\n+        list.add((E) \"B\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(1,list.indexOf(\"B\"));\n+        assertEquals(1,list.lastIndexOf(\"B\"));\n+        list.addFirst((E) \"B\");\n+        assertEquals(1,list.indexOf(\"A\"));\n+        assertEquals(1,list.lastIndexOf(\"A\"));\n+        assertEquals(0,list.indexOf(\"B\"));\n+        assertEquals(2,list.lastIndexOf(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIsEmpty() {\n+        assertTrue(list.isEmpty());\n+        list.add((E) \"element\");\n+        assertTrue(!list.isEmpty());\n+        list.remove(\"element\");\n+        assertTrue(list.isEmpty());\n+        list.add((E) \"element\");\n+        assertTrue(!list.isEmpty());\n+        list.clear();\n+        assertTrue(list.isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        Iterator<E> it = list.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"3\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"4\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"5\", it.next());\n+        assertTrue(!it.hasNext());\n+\n+        it = list.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"1\", it.next());\n+        it.remove();\n+        assertEquals(\"[2, 3, 4, 5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"2\", it.next());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"3\", it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"4\", it.next());\n+        it.remove();\n+        assertEquals(\"[5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"5\", it.next());\n+        it.remove();\n+        assertEquals(\"[]\", list.toString());\n+        assertTrue(!it.hasNext());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorNavigation() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        ListIterator<E> it = list.listIterator();\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(\"3\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(2, it.previousIndex());\n+        assertEquals(3, it.nextIndex());\n+        assertEquals(\"4\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(3, it.previousIndex());\n+        assertEquals(4, it.nextIndex());\n+        assertEquals(\"5\", it.next());\n+        assertTrue(!it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(4, it.previousIndex());\n+        assertEquals(5, it.nextIndex());\n+        assertEquals(\"5\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(3, it.previousIndex());\n+        assertEquals(4, it.nextIndex());\n+        assertEquals(\"4\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(2, it.previousIndex());\n+        assertEquals(3, it.nextIndex());\n+        assertEquals(\"3\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+        assertEquals(0, it.nextIndex());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorSet() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        ListIterator<E> it = list.listIterator();\n+        assertEquals(\"1\", it.next());\n+        it.set((E) \"a\");\n+        assertEquals(\"a\", it.previous());\n+        it.set((E) \"A\");\n+        assertEquals(\"A\", it.next());\n+        assertEquals(\"2\", it.next());\n+        it.set((E) \"B\");\n+        assertEquals(\"3\", it.next());\n+        assertEquals(\"4\", it.next());\n+        it.set((E) \"D\");\n+        assertEquals(\"5\", it.next());\n+        it.set((E) \"E\");\n+        assertEquals(\"[A, B, 3, D, E]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorRemove() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        ListIterator<E> it = list.listIterator();\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\",it.next());\n+        assertEquals(\"2\",it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"3\",it.previous());\n+        assertEquals(\"1\",it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\",it.next());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[4]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorAdd() {\n+        ListIterator<E> it = list.listIterator();\n+        it.add((E) \"1\");\n+        assertEquals(\"[1]\", list.toString());\n+        it.add((E) \"3\");\n+        assertEquals(\"[1, 3]\", list.toString());\n+        it.add((E) \"5\");\n+        assertEquals(\"[1, 3, 5]\", list.toString());\n+        assertEquals(\"5\", it.previous());\n+        it.add((E) \"4\");\n+        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n+        assertEquals(\"4\", it.previous());\n+        assertEquals(\"3\", it.previous());\n+        it.add((E) \"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveAll() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"A\");\n+        set.add((E) \"2\");\n+        set.add((E) \"C\");\n+        set.add((E) \"4\");\n+        set.add((E) \"D\");\n+\n+        assertTrue(list.removeAll(set));\n+        assertEquals(\"[1, 3, 5]\", list.toString());\n+        assertTrue(!list.removeAll(set));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveByIndex() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        assertEquals(\"1\", list.remove(0));\n+        assertEquals(\"[2, 3, 4, 5]\", list.toString());\n+        assertEquals(\"3\", list.remove(1));\n+        assertEquals(\"[2, 4, 5]\", list.toString());\n+        assertEquals(\"4\", list.remove(1));\n+        assertEquals(\"[2, 5]\", list.toString());\n+        assertEquals(\"5\", list.remove(1));\n+        assertEquals(\"[2]\", list.toString());\n+        assertEquals(\"2\", list.remove(0));\n+        assertEquals(\"[]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        list.add((E) \"1\");\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        assertEquals(\"[1, 1, 2, 3, 4, 5, 2, 3, 4, 5]\", list.toString());\n+        assertTrue(!list.remove(\"6\"));\n+        assertTrue(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4, 5]\", list.toString());\n+        assertTrue(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(!list.remove(\"5\"));\n+        assertTrue(list.remove(\"1\"));\n+        assertEquals(\"[1, 2, 3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"1\"));\n+        assertEquals(\"[2, 3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"3\"));\n+        assertEquals(\"[4, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"3\"));\n+        assertEquals(\"[4, 4]\", list.toString());\n+        assertTrue(list.remove(\"4\"));\n+        assertEquals(\"[4]\", list.toString());\n+        assertTrue(list.remove(\"4\"));\n+        assertEquals(\"[]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        list.add((E) \"1\");\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        list.add((E) \"5\");\n+\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"A\");\n+        set.add((E) \"2\");\n+        set.add((E) \"C\");\n+        set.add((E) \"4\");\n+        set.add((E) \"D\");\n+\n+        assertTrue(list.retainAll(set));\n+        assertEquals(\"[2, 2, 4, 4]\", list.toString());\n+        assertTrue(!list.retainAll(set));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSet() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        list.set(0, (E) \"A\");\n+        assertEquals(\"[A, 2, 3, 4, 5]\", list.toString());\n+        list.set(1, (E) \"B\");\n+        assertEquals(\"[A, B, 3, 4, 5]\", list.toString());\n+        list.set(2, (E) \"C\");\n+        assertEquals(\"[A, B, C, 4, 5]\", list.toString());\n+        list.set(3, (E) \"D\");\n+        assertEquals(\"[A, B, C, D, 5]\", list.toString());\n+        list.set(4, (E) \"E\");\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[A, B, C, D, E]\", list.subList(0, 5).toString());\n+        assertEquals(\"[B, C, D, E]\", list.subList(1, 5).toString());\n+        assertEquals(\"[C, D, E]\", list.subList(2, 5).toString());\n+        assertEquals(\"[D, E]\", list.subList(3, 5).toString());\n+        assertEquals(\"[E]\", list.subList(4, 5).toString());\n+        assertEquals(\"[]\", list.subList(5, 5).toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddEnd() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        List<E> sublist = list.subList(5, 5);\n+        sublist.add((E) \"F\");\n+        assertEquals(\"[A, B, C, D, E, F]\", list.toString());\n+        assertEquals(\"[F]\", sublist.toString());\n+        sublist.add((E) \"G\");\n+        assertEquals(\"[A, B, C, D, E, F, G]\", list.toString());\n+        assertEquals(\"[F, G]\", sublist.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddBegin() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        List<E> sublist = list.subList(0, 0);\n+        sublist.add((E) \"a\");\n+        assertEquals(\"[a, A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[a]\", sublist.toString());\n+        sublist.add((E) \"b\");\n+        assertEquals(\"[a, b, A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[a, b]\", sublist.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddMiddle() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        List<E> sublist = list.subList(1, 3);\n+        sublist.add((E) \"a\");\n+        assertEquals(\"[A, B, C, a, D, E]\", list.toString());\n+        assertEquals(\"[B, C, a]\", sublist.toString());\n+        sublist.add((E) \"b\");\n+        assertEquals(\"[A, B, C, a, b, D, E]\", list.toString());\n+        assertEquals(\"[B, C, a, b]\", sublist.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListRemove() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        List<E> sublist = list.subList(1, 4);\n+        assertEquals(\"[B, C, D]\", sublist.toString());\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+        sublist.remove(\"C\");\n+        assertEquals(\"[B, D]\", sublist.toString());\n+        assertEquals(\"[A, B, D, E]\", list.toString());\n+        sublist.remove(1);\n+        assertEquals(\"[B]\", sublist.toString());\n+        assertEquals(\"[A, B, E]\", list.toString());\n+        sublist.clear();\n+        assertEquals(\"[]\", sublist.toString());\n+        assertEquals(\"[A, E]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToArray() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        Object[] elts = list.toArray();\n+        assertEquals(\"1\", elts[0]);\n+        assertEquals(\"2\", elts[1]);\n+        assertEquals(\"3\", elts[2]);\n+        assertEquals(\"4\", elts[3]);\n+        assertEquals(\"5\", elts[4]);\n+        assertEquals(5, elts.length);\n+\n+        String[] elts2 = (list.toArray(new String[0]));\n+        assertEquals(\"1\", elts2[0]);\n+        assertEquals(\"2\", elts2[1]);\n+        assertEquals(\"3\", elts2[2]);\n+        assertEquals(\"4\", elts2[3]);\n+        assertEquals(\"5\", elts2[4]);\n+        assertEquals(5, elts2.length);\n+\n+        String[] elts3 = new String[5];\n+        assertSame(elts3, list.toArray(elts3));\n+        assertEquals(\"1\", elts3[0]);\n+        assertEquals(\"2\", elts3[1]);\n+        assertEquals(\"3\", elts3[2]);\n+        assertEquals(\"4\", elts3[3]);\n+        assertEquals(\"5\", elts3[4]);\n+        assertEquals(5, elts3.length);\n+\n+        String[] elts4 = new String[3];\n+        String[] elts4b = (list.toArray(elts4));\n+        assertTrue(elts4 != elts4b);\n+        assertEquals(\"1\", elts4b[0]);\n+        assertEquals(\"2\", elts4b[1]);\n+        assertEquals(\"3\", elts4b[2]);\n+        assertEquals(\"4\", elts4b[3]);\n+        assertEquals(\"5\", elts4b[4]);\n+        assertEquals(5, elts4b.length);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() throws Exception {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerializationWithOpenCursor() throws Exception {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLongSerialization() throws Exception {\n+        // recursive serialization will cause a stack\n+        // overflow exception with long lists\n+        for (int i = 0; i < 10000; i++) {\n+            list.add((E) new Integer(i));\n+        }\n+\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    /**\n+     *  Ignore the serialization tests for sublists and sub-sublists.\n+     *\n+     *  @return an array of sublist serialization test names\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        ArrayList<String> list = new ArrayList<String>();\n+        String prefix = \"TestCursorableLinkedList\";\n+        String bulk = \".bulkTestSubList\";\n+        String[] ignored = new String[] {\n+                \".testEmptyListSerialization\",\n+                \".testFullListSerialization\",\n+                \".testEmptyListCompatibility\",\n+                \".testFullListCompatibility\",\n+                \".testSimpleSerialization\",\n+                \".testCanonicalEmptyCollectionExists\",\n+                \".testCanonicalFullCollectionExists\",\n+                \".testSerializeDeserializeThenCompare\"\n+        };\n+        for (int i = 0; i < ignored.length; i++) {\n+            list.add(prefix + bulk + ignored[i]);\n+            list.add(prefix + bulk + bulk + ignored[i]);\n+        }\n+        return list.toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.0\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/CursorableLinkedList.emptyCollection.version4.0.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/CursorableLinkedList.fullCollection.version4.0.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestFixedSizeList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractTestList} for exercising the {@link FixedSizeList}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestFixedSizeList<E> extends AbstractTestList<E> {\n+\n+    public TestFixedSizeList(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return FixedSizeList.fixedSizeList(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public List<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return FixedSizeList.fixedSizeList(list);\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/FixedSizeList.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/FixedSizeList.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestGrowthList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractTestList} for exercising the {@link GrowthList}.\n+ *\n+ * @since Commons Collections 3.2\n+ * @version $Revision: 155406 $ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestGrowthList<E> extends AbstractTestList<E> {\n+\n+    public TestGrowthList(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return new GrowthList<E>();\n+    }\n+\n+    @Override\n+    public List<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return GrowthList.growthList(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGrowthAdd() {\n+        Integer one = new Integer(1);\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.add(1, one);\n+        assertEquals(2, grower.size());\n+        assertEquals(null, grower.get(0));\n+        assertEquals(one, grower.get(1));\n+    }\n+\n+    public void testGrowthAddAll() {\n+        Integer one = new Integer(1);\n+        Integer two = new Integer(2);\n+        Collection<Integer> coll = new ArrayList<Integer>();\n+        coll.add(one);\n+        coll.add(two);\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.addAll(1, coll);\n+        assertEquals(3, grower.size());\n+        assertEquals(null, grower.get(0));\n+        assertEquals(one, grower.get(1));\n+        assertEquals(two, grower.get(2));\n+    }\n+\n+    public void testGrowthSet1() {\n+        Integer one = new Integer(1);\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.set(1, one);\n+        assertEquals(2, grower.size());\n+        assertEquals(null, grower.get(0));\n+        assertEquals(one, grower.get(1));\n+    }\n+\n+    public void testGrowthSet2() {\n+        Integer one = new Integer(1);\n+        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.set(0, one);\n+        assertEquals(1, grower.size());\n+        assertEquals(one, grower.get(0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListAddByIndexBoundsChecking() {\n+        List<E> list;\n+        E element = getOtherElements()[0];\n+        try {\n+            list = makeObject();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListAddByIndexBoundsChecking2() {\n+        List<E> list;\n+        E element = getOtherElements()[0];\n+        try {\n+            list = makeFullCollection();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListSetByIndexBoundsChecking() {\n+        List<E> list = makeObject();\n+        E element = getOtherElements()[0];\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListSetByIndexBoundsChecking2() {\n+        List<E> list = makeFullCollection();\n+        E element = getOtherElements()[0];\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/GrowthList.emptyCollection.version3.2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"C:/commons/collections/data/test/GrowthList.fullCollection.version3.2.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestNodeCachingLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Test class for NodeCachingLinkedList, a performance optimised LinkedList.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Jeff Varszegi\n+ * @author Phil Steitz\n+ */\n+public class TestNodeCachingLinkedList<E> extends AbstractTestLinkedList<E> {\n+\n+    public TestNodeCachingLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestNodeCachingLinkedList.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public NodeCachingLinkedList<E> makeObject() {\n+        return new NodeCachingLinkedList<E>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testShrinkCache() {\n+        if (isRemoveSupported() == false || isAddSupported() == false) return;\n+        resetEmpty();\n+        NodeCachingLinkedList<E> list = getCollection();\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        list.removeAllNodes(); // Will dump all 4 elements into cache\n+        list.setMaximumCacheSize(2); // shrink cache\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        checkNodes();\n+        list.removeNode(list.getNode(0, false)); // no room in cache\n+        list.removeNode(list.getNode(0, false));\n+        list.removeNode(list.getNode(0, false));\n+        checkNodes();\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        checkNodes();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void compareSpeed() {\n+        NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<Object>();\n+        LinkedList<Object> ll = new LinkedList<Object>();\n+\n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+\n+        int loopCount = 4000000;\n+\n+        long startTime, endTime;\n+\n+        System.out.println(\"Testing relative execution time of commonly-used methods...\");\n+\n+        startTime = System.currentTimeMillis();\n+        for(int x = loopCount; x > 0; x--) {\n+            // unrolled a few times to minimize effect of loop\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+            //\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+            //\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+        }\n+        endTime = System.currentTimeMillis();\n+        System.out.println(\"Time with LinkedList: \" + (endTime - startTime) + \" ms\");\n+\n+        startTime = System.currentTimeMillis();\n+        for(int x = loopCount; x > 0; x--) {\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+            //\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+            //\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+        }\n+        endTime = System.currentTimeMillis();\n+        System.out.println(\"Time with NodeCachingLinkedList: \" + (endTime - startTime) + \" ms\");\n+\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection,\n+//           \"D:/dev/collections/data/test/NodeCachingLinkedList.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection,\n+//            \"D:/dev/collections/data/test/NodeCachingLinkedList.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public NodeCachingLinkedList<E> getCollection() {\n+        return (NodeCachingLinkedList<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestPredicatedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractTestList} for exercising the \n+ * {@link PredicatedList} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedList<E> extends AbstractTestList<E> {\n+\n+    public TestPredicatedList(String testName) {\n+        super(testName);\n+    }\n+\n+ //-------------------------------------------------------------------\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected List<E> decorateList(List<E> list, Predicate<E> predicate) {\n+        return PredicatedList.predicatedList(list, predicate);\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return decorateList(new ArrayList<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+    }\n+\n+//--------------------------------------------------------------------\n+\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(E o) {\n+                return o instanceof String;\n+            }\n+        };\n+\n+    public List<E> makeTestList() {\n+        return decorateList(new ArrayList<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        List<E> list = makeTestList();\n+        Integer i = new Integer(3);\n+        try {\n+            list.add((E) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !list.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        List<E> list = makeTestList();\n+        List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n+        try {\n+            list.addAll(0, elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"one\"));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"two\"));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(new Integer(3)));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"four\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalSet() {\n+        List<E> list = makeTestList();\n+        try {\n+            list.set(0, (E) new Integer(3));\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLegalAddAll() {\n+        List<E> list = makeTestList();\n+        list.add((E) \"zero\");\n+        List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) \"three\");\n+        list.addAll(1,elements);\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"zero\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"one\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"two\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"three\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedList.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedList.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestSetUniqueList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Matthew Hawthorne\n+ * @author Tom Dunham\n+ */\n+public class TestSetUniqueList<E> extends AbstractTestList<E> {\n+\n+    public TestSetUniqueList(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public List<E> makeObject() {\n+        return new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+    }\n+\n+    @Override\n+    public void testListIteratorSet() {\n+        // override to block\n+        resetFull();\n+        ListIterator<E> it = getCollection().listIterator();\n+        it.next();\n+        try {\n+            it.set(null);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        // override to avoid duplicate \"One\"\n+        return (E[]) new Object[] {\n+                new String(\"\"),\n+                new String(\"One\"),\n+                new Integer(2),\n+                \"Three\",\n+                new Integer(4),\n+                new Double(5),\n+                new Float(6),\n+                \"Seven\",\n+                \"Eight\",\n+                new String(\"Nine\"),\n+                new Integer(10),\n+                new Short((short)11),\n+                new Long(12),\n+                \"Thirteen\",\n+                \"14\",\n+                \"15\",\n+                new Byte((byte)16)\n+        };\n+    }\n+\n+    @Override\n+    public void testListIteratorAdd() {\n+        // override to cope with Set behaviour\n+        resetEmpty();\n+        List<E> list1 = getCollection();\n+        List<E> list2 = getConfirmed();\n+\n+        E[] elements = getOtherElements();  // changed here\n+        ListIterator<E> iter1 = list1.listIterator();\n+        ListIterator<E> iter2 = list2.listIterator();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            super.verify();  // changed here\n+        }\n+\n+        resetFull();\n+        iter1 = getCollection().listIterator();\n+        iter2 = getConfirmed().listIterator();\n+        for (int i = 0; i < elements.length; i++) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.add(elements[i]);\n+            iter2.add(elements[i]);\n+            super.verify();  // changed here\n+        }\n+    }\n+\n+    @Override\n+    public void testCollectionAddAll() {\n+        // override for set behaviour\n+        resetEmpty();\n+        E[] elements = getFullElements();\n+        boolean r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Empty collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Collection should contain added element\",\n+                    getCollection().contains(elements[i]));\n+        }\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        elements = getOtherElements();\n+        r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Full collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain added element \" + i,\n+                    getCollection().contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\",\n+                size + elements.length, getCollection().size());\n+    }\n+\n+    // TODO: Generics\n+    public void testIntCollectionAddAll() {\n+      // make a SetUniqueList with one element\n+      List list = new SetUniqueList(new ArrayList(), new HashSet());\n+      final Integer existingElement = new Integer(1);\n+      list.add(existingElement);\n+\n+      // add two new unique elements at index 0\n+      final Integer firstNewElement = new Integer(2);\n+      final Integer secondNewElement = new Integer(3);\n+      Collection collection = Arrays.asList(new Integer[] {firstNewElement, secondNewElement});\n+      list.addAll(0, collection);\n+      assertEquals(\"Unique elements should be added.\", 3, list.size());\n+      assertEquals(\"First new element should be at index 0\", firstNewElement, list.get(0));\n+      assertEquals(\"Second new element should be at index 1\", secondNewElement, list.get(1));\n+      assertEquals(\"Existing element should shift to index 2\", existingElement, list.get(2));\n+\n+      // add a duplicate element and a unique element at index 0\n+      final Integer thirdNewElement = new Integer(4);\n+      collection = Arrays.asList(new Integer[] {existingElement, thirdNewElement});\n+      list.addAll(0, collection);\n+      assertEquals(\"Duplicate element should not be added, unique element should be added.\",\n+        4, list.size());\n+      assertEquals(\"Third new element should be at index 0\", thirdNewElement, list.get(0));\n+    }\n+    \n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListSetByIndex() {\n+        // override for set behaviour\n+        resetFull();\n+        int size = getCollection().size();\n+        getCollection().set(0, (E) new Long(1000));\n+        assertEquals(size, getCollection().size());\n+\n+        getCollection().set(2, (E) new Long(1000));\n+        assertEquals(size - 1, getCollection().size());\n+        assertEquals(new Long(1000), getCollection().get(1));  // set into 2, but shifted down to 1\n+    }\n+\n+    boolean extraVerify = true;\n+    @Override\n+    public void testCollectionIteratorRemove() {\n+        try {\n+            extraVerify = false;\n+            super.testCollectionIteratorRemove();\n+        } finally {\n+            extraVerify = true;\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void verify() {\n+        super.verify();\n+\n+        if (extraVerify) {\n+            int size = getCollection().size();\n+            getCollection().add((E) new Long(1000));\n+            assertEquals(size + 1, getCollection().size());\n+\n+            getCollection().add((E) new Long(1000));\n+            assertEquals(size + 1, getCollection().size());\n+            assertEquals(new Long(1000), getCollection().get(size));\n+\n+            getCollection().remove(size);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory() {\n+        Integer[] array = new Integer[] { new Integer(1), new Integer(2), new Integer(1) };\n+        ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(array));\n+        final SetUniqueList<Integer> lset = SetUniqueList.setUniqueList(list);\n+\n+        assertEquals(\"Duplicate element was added.\", 2, lset.size());\n+        assertEquals(new Integer(1), lset.get(0));\n+        assertEquals(new Integer(2), lset.get(1));\n+        assertEquals(new Integer(1), list.get(0));\n+        assertEquals(new Integer(2), list.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAdd() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        // Duplicate element\n+        final E obj = (E) new Integer(1);\n+        lset.add(obj);\n+        lset.add(obj);\n+        assertEquals(\"Duplicate element was added.\", 1, lset.size());\n+\n+        // Unique element\n+        lset.add((E) new Integer(2));\n+        assertEquals(\"Unique element was not added.\", 2, lset.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAll() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        lset.addAll(\n+            Arrays.asList((E[]) new Integer[] { new Integer(1), new Integer(1)}));\n+\n+        assertEquals(\"Duplicate element was added.\", 1, lset.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSet() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        // Duplicate element\n+        final E obj1 = (E) new Integer(1);\n+        final E obj2 = (E) new Integer(2);\n+        final E obj3 = (E) new Integer(3);\n+\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(0, obj1);\n+        assertEquals(2, lset.size());\n+        assertSame(obj1, lset.get(0));\n+        assertSame(obj2, lset.get(1));\n+\n+        lset.clear();\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(0, obj2);\n+        assertEquals(1, lset.size());\n+        assertSame(obj2, lset.get(0));\n+\n+        lset.clear();\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(0, obj3);\n+        assertEquals(2, lset.size());\n+        assertSame(obj3, lset.get(0));\n+        assertSame(obj2, lset.get(1));\n+\n+        lset.clear();\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(1, obj1);\n+        assertEquals(1, lset.size());\n+        assertSame(obj1, lset.get(0));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIterator() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        final E obj1 = (E) new Integer(1);\n+        final E obj2 = (E) new Integer(2);\n+        lset.add(obj1);\n+        lset.add(obj2);\n+\n+        // Attempts to add a duplicate object\n+        for (final ListIterator<E> it = lset.listIterator(); it.hasNext();) {\n+            it.next();\n+\n+            if (!it.hasNext()) {\n+                it.add(obj1);\n+                break;\n+            }\n+        }\n+\n+        assertEquals(\"Duplicate element was added\", 2, lset.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUniqueListReInsert() {\n+        List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n+        l.add((E) new Object());\n+        l.add((E) new Object());\n+\n+        E a = l.get(0);\n+\n+        // duplicate is removed\n+        l.set(0, l.get(1));\n+        assertEquals(1, l.size());\n+\n+        // old object is added back in\n+        l.add(1, a);\n+        assertEquals(2, l.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUniqueListDoubleInsert() {\n+        List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n+        l.add((E) new Object());\n+        l.add((E) new Object());\n+\n+        // duplicate is removed\n+        l.set(0, l.get(1));\n+        assertEquals(1, l.size());\n+\n+        // duplicate should be removed again\n+        l.add(1, l.get(0));\n+        assertEquals(1, l.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetDownwardsInList() {\n+        /*\n+         * Checks the following semantics\n+         * [a,b]\n+         * set(0,b): [b]->a\n+         * So UniqList contains [b] and a is returned\n+         */\n+        ArrayList<E> l = new ArrayList<E>();\n+        HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        E a = (E) new Object();\n+        E b = (E) new Object();\n+        ul.add(a);\n+        ul.add(b);\n+        assertEquals(a, l.get(0));\n+        assertEquals(b, l.get(1));\n+        assertTrue(s.contains(a));\n+        assertTrue(s.contains(b));\n+\n+        assertEquals(a, ul.set(0, b));\n+        assertEquals(1, s.size());\n+        assertEquals(1, l.size());\n+        assertEquals(b, l.get(0));\n+        assertTrue(s.contains(b));\n+        assertFalse(s.contains(a));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetInBiggerList() {\n+        /*\n+         * Checks the following semantics\n+         * [a,b,c]\n+         * set(0,b): [b,c]->a\n+         * So UniqList contains [b,c] and a is returned\n+         */\n+        ArrayList<E> l = new ArrayList<E>();\n+        HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        E a = (E) new Object();\n+        E b = (E) new Object();\n+        E c = (E) new Object();\n+\n+        ul.add(a);\n+        ul.add(b);\n+        ul.add(c);\n+        assertEquals(a, l.get(0));\n+        assertEquals(b, l.get(1));\n+        assertEquals(c, l.get(2));\n+        assertTrue(s.contains(a));\n+        assertTrue(s.contains(b));\n+        assertTrue(s.contains(c));\n+\n+        assertEquals(a, ul.set(0, b));\n+        assertEquals(2, s.size());\n+        assertEquals(2, l.size());\n+        assertEquals(b, l.get(0));\n+        assertEquals(c, l.get(1));\n+        assertFalse(s.contains(a));\n+        assertTrue(s.contains(b));\n+        assertTrue(s.contains(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetUpwardsInList() {\n+        /*\n+         * Checks the following semantics\n+         * [a,b,c]\n+         * set(1,a): [a,c]->b\n+         * So UniqList contains [a,c] and b is returned\n+         */\n+        ArrayList<E> l = new ArrayList<E>();\n+        HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        E a = (E) new String(\"A\");\n+        E b = (E) new String(\"B\");\n+        E c = (E) new String(\"C\");\n+\n+        ul.add(a);\n+        ul.add(b);\n+        ul.add(c);\n+        assertEquals(a, l.get(0));\n+        assertEquals(b, l.get(1));\n+        assertEquals(c, l.get(2));\n+        assertTrue(s.contains(a));\n+        assertTrue(s.contains(b));\n+        assertTrue(s.contains(c));\n+\n+        assertEquals(b, ul.set(1, a));\n+        assertEquals(2, s.size());\n+        assertEquals(2, l.size());\n+        assertEquals(a, l.get(0));\n+        assertEquals(c, l.get(1));\n+        assertTrue(s.contains(a));\n+        assertFalse(s.contains(b));\n+        assertTrue(s.contains(c));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SetUniqueList.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SetUniqueList.fullCollection.version3.1.obj\");\n+//    }\n+\n+    // TODO: Generics\n+    public void testCollections304() {\n+        List list = new LinkedList();\n+        SetUniqueList decoratedList = SetUniqueList.setUniqueList(list);\n+        String s1 = \"Apple\";\n+        String s2 = \"Lemon\";\n+        String s3 = \"Orange\";\n+        String s4 = \"Strawberry\";\n+\n+        decoratedList.add(s1);\n+        decoratedList.add(s2);\n+        decoratedList.add(s3);\n+\n+        assertEquals(3, decoratedList.size());\n+\n+        decoratedList.set(1, s4);\n+\n+        assertEquals(3, decoratedList.size());\n+\n+        decoratedList.add(1, s4);\n+\n+        assertEquals(3, decoratedList.size());\n+\n+        decoratedList.add(1, s2);\n+\n+        assertEquals(4, decoratedList.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCollections307() {\n+        List<E> list = new ArrayList<E>();\n+        List<E> uniqueList = SetUniqueList.setUniqueList(list);\n+\n+        String hello = \"Hello\";\n+        String world = \"World\";\n+        uniqueList.add((E) hello);\n+        uniqueList.add((E) world);\n+\n+        List<E> subList = list.subList(0, 0);\n+        List<E> subUniqueList = uniqueList.subList(0, 0);\n+\n+        assertFalse(subList.contains(world)); // passes\n+        assertFalse(subUniqueList.contains(world)); // fails\n+\n+        List<E> worldList = new ArrayList<E>();\n+        worldList.add((E) world);\n+        assertFalse(subList.contains(\"World\")); // passes\n+        assertFalse(subUniqueList.contains(\"World\")); // fails\n+\n+        // repeat the test with a different class than HashSet;\n+        // which means subclassing SetUniqueList below\n+        list = new ArrayList<E>();\n+        uniqueList = new SetUniqueList307(list, new java.util.TreeSet<E>());\n+\n+        uniqueList.add((E) hello);\n+        uniqueList.add((E) world);\n+\n+        subList = list.subList(0, 0);\n+        subUniqueList = uniqueList.subList(0, 0);\n+\n+        assertFalse(subList.contains(world)); // passes\n+        assertFalse(subUniqueList.contains(world)); // fails\n+\n+        worldList = new ArrayList<E>();\n+        worldList.add((E) world);\n+        assertFalse(subList.contains(\"World\")); // passes\n+        assertFalse(subUniqueList.contains(\"World\")); // fails\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    class SetUniqueList307 extends SetUniqueList<E> {\n+        public SetUniqueList307(List<E> list, Set<E> set) {\n+            super(list, set);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestSynchronizedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractTestList} for exercising the {@link SynchronizedList}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSynchronizedList<E> extends AbstractTestList<E> {\n+\n+    public TestSynchronizedList(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return SynchronizedList.synchronizedList(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedList.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedList.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestTransformedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestList} for exercising the {@link TransformedList}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedList<E> extends AbstractTestList<E> {\n+\n+    public TestTransformedList(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public List<E> makeConfirmedFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public List<E> makeObject() {\n+        return TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public List<E> makeFullCollection() {\n+        List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedList.transformingList(list, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedList() {\n+        List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, list.size());\n+        E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            list.add(els[i]);\n+            assertEquals(i + 1, list.size());\n+            assertEquals(true, list.contains(new Integer((String) els[i])));\n+            assertEquals(false, list.contains(els[i]));\n+        }\n+\n+        assertEquals(false, list.remove(els[0]));\n+        assertEquals(true, list.remove(new Integer((String) els[0])));\n+\n+        list.clear();\n+        for (int i = 0; i < els.length; i++) {\n+            list.add(0, els[i]);\n+            assertEquals(i + 1, list.size());\n+            assertEquals(new Integer((String) els[i]), list.get(0));\n+        }\n+\n+        list.set(0, (E) \"22\");\n+        assertEquals(new Integer(22), list.get(0));\n+\n+        ListIterator<E> it = list.listIterator();\n+        it.next();\n+        it.set((E) \"33\");\n+        assertEquals(new Integer(33), list.get(0));\n+        it.add((E) \"44\");\n+        assertEquals(new Integer(44), list.get(1));\n+\n+        List<E> adds = new ArrayList<E>();\n+        adds.add((E) \"1\");\n+        adds.add((E) \"2\");\n+        list.clear();\n+        list.addAll(adds);\n+        assertEquals(new Integer(1), list.get(0));\n+        assertEquals(new Integer(2), list.get(1));\n+\n+        adds.clear();\n+        adds.add((E) \"3\");\n+        list.addAll(1, adds);\n+        assertEquals(new Integer(1), list.get(0));\n+        assertEquals(new Integer(3), list.get(1));\n+        assertEquals(new Integer(2), list.get(2));\n+    }\n+\n+    public void testTransformedList_decorateTransform() {\n+        List originalList = new ArrayList();\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            originalList.add(els[i]);\n+        }\n+        List list = TransformedList.transformedList(originalList, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, list.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, list.contains(new Integer((String) els[i])));\n+            assertEquals(false, list.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, list.remove(els[0]));\n+        assertEquals(true, list.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedList.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedList.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestTreeList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Joerg Schmuecker\n+ */\n+public class TestTreeList<E> extends AbstractTestList<E> {\n+\n+    public TestTreeList(String name) {\n+        super(name);\n+    }\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+//        System.out.println(\"         add; toArray; iterator; insert; get; indexOf; remove\");\n+//        System.out.print(\"   TreeList = \");\n+//        benchmark(new TreeList());\n+//        System.out.print(\"\\n  ArrayList = \");\n+//        benchmark(new java.util.ArrayList());\n+//        System.out.print(\"\\n LinkedList = \");\n+//        benchmark(new java.util.LinkedList());\n+//        benchmark(new NodeCachingLinkedList());\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestTreeList.class);\n+    }\n+\n+    public static void benchmark(List<? super Integer> l) {\n+        long start = System.currentTimeMillis();\n+        for (int i = 0; i < 100000; i++) {\n+            l.add(new Integer(i));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 200; i++) {\n+            l.toArray();\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 100; i++) {\n+            java.util.Iterator<? super Integer> it = l.iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+            }\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 10000; i++) {\n+            int j = (int) (Math.random() * 100000);\n+            l.add(j, new Integer(-j));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 50000; i++) {\n+            int j = (int) (Math.random() * 110000);\n+            l.get(j);\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 200; i++) {\n+            int j = (int) (Math.random() * 100000);\n+            l.indexOf(new Integer(j));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 10000; i++) {\n+            int j = (int) (Math.random() * 100000);\n+            l.remove(j);\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public TreeList<E> makeObject() {\n+        return new TreeList<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddMultiple() {\n+        List<E> l = makeObject();\n+        l.add((E) \"hugo\");\n+        l.add((E) \"erna\");\n+        l.add((E) \"daniel\");\n+        l.add((E) \"andres\");\n+        l.add((E) \"harald\");\n+        l.add(0, null);\n+        assertEquals(null, l.get(0));\n+        assertEquals(\"hugo\", l.get(1));\n+        assertEquals(\"erna\", l.get(2));\n+        assertEquals(\"daniel\", l.get(3));\n+        assertEquals(\"andres\", l.get(4));\n+        assertEquals(\"harald\", l.get(5));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        List<E> l = makeObject();\n+        l.add((E) \"hugo\");\n+        l.add((E) \"erna\");\n+        l.add((E) \"daniel\");\n+        l.add((E) \"andres\");\n+        l.add((E) \"harald\");\n+        l.add(0, null);\n+        int i = 0;\n+        assertEquals(null, l.get(i++));\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"erna\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"andres\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+\n+        l.remove(0);\n+        i = 0;\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"erna\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"andres\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+\n+        i = 0;\n+        l.remove(1);\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"andres\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+\n+        i = 0;\n+        l.remove(2);\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInsertBefore() {\n+        List<E> l = makeObject();\n+        l.add((E) \"erna\");\n+        l.add(0, (E) \"hugo\");\n+        assertEquals(\"hugo\", l.get(0));\n+        assertEquals(\"erna\", l.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIndexOf() {\n+        List<E> l = makeObject();\n+        l.add((E) \"0\");\n+        l.add((E) \"1\");\n+        l.add((E) \"2\");\n+        l.add((E) \"3\");\n+        l.add((E) \"4\");\n+        l.add((E) \"5\");\n+        l.add((E) \"6\");\n+        assertEquals(0, l.indexOf(\"0\"));\n+        assertEquals(1, l.indexOf(\"1\"));\n+        assertEquals(2, l.indexOf(\"2\"));\n+        assertEquals(3, l.indexOf(\"3\"));\n+        assertEquals(4, l.indexOf(\"4\"));\n+        assertEquals(5, l.indexOf(\"5\"));\n+        assertEquals(6, l.indexOf(\"6\"));\n+\n+        l.set(1, (E) \"0\");\n+        assertEquals(0, l.indexOf(\"0\"));\n+\n+        l.set(3, (E) \"3\");\n+        assertEquals(3, l.indexOf(\"3\"));\n+        l.set(2, (E) \"3\");\n+        assertEquals(2, l.indexOf(\"3\"));\n+        l.set(1, (E) \"3\");\n+        assertEquals(1, l.indexOf(\"3\"));\n+        l.set(0, (E) \"3\");\n+        assertEquals(0, l.indexOf(\"3\"));\n+    }\n+\n+//    public void testCheck() {\n+//        List l = makeEmptyList();\n+//        l.add(\"A1\");\n+//        l.add(\"A2\");\n+//        l.add(\"A3\");\n+//        l.add(\"A4\");\n+//        l.add(\"A5\");\n+//        l.add(\"A6\");\n+//    }\n+\n+    public void testBug35258() {\n+        Object objectToRemove = new Integer(3);\n+\n+        List<Integer> treelist = new TreeList<Integer>();\n+        treelist.add(new Integer(0));\n+        treelist.add(new Integer(1));\n+        treelist.add(new Integer(2));\n+        treelist.add(new Integer(3));\n+        treelist.add(new Integer(4));\n+\n+        // this cause inconsistence of ListIterator()\n+        treelist.remove(objectToRemove);\n+\n+        ListIterator<Integer> li = treelist.listIterator();\n+        assertEquals(new Integer(0), li.next());\n+        assertEquals(new Integer(0), li.previous());\n+        assertEquals(new Integer(0), li.next());\n+        assertEquals(new Integer(1), li.next());\n+        // this caused error in bug 35258\n+        assertEquals(new Integer(1), li.previous());\n+        assertEquals(new Integer(1), li.next());\n+        assertEquals(new Integer(2), li.next());\n+        assertEquals(new Integer(2), li.previous());\n+        assertEquals(new Integer(2), li.next());\n+        assertEquals(new Integer(4), li.next());\n+        assertEquals(new Integer(4), li.previous());\n+        assertEquals(new Integer(4), li.next());\n+        assertEquals(false, li.hasNext());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/TestUnmodifiableList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractTestList} for exercising the\n+ * {@link UnmodifiableList} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestUnmodifiableList<E> extends AbstractTestList<E> {\n+\n+    public TestUnmodifiableList(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public UnmodifiableList<E> makeObject() {\n+        return new UnmodifiableList<E>(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public UnmodifiableList<E> makeFullCollection() {\n+        ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return new UnmodifiableList<E>(list);\n+    }\n+\n+    @Override\n+    public boolean isSetSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected UnmodifiableList<E> list;\n+    protected ArrayList<E> array;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected void setupList() {\n+        list = makeFullCollection();\n+        array = new ArrayList<E>();\n+        array.add((E) new Integer(1));\n+    }\n+\n+    /**\n+     * Verify that base list and sublists are not modifiable\n+     */\n+    public void testUnmodifiable() {\n+        setupList();\n+        verifyUnmodifiable(list);\n+        verifyUnmodifiable(list.subList(0, 2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected void verifyUnmodifiable(List<E> list) {\n+        try {\n+            list.add(0, (E) new Integer(0));\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.add((E) new Integer(0));\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.addAll(0, array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.addAll(array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.clear();\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.remove(0);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.remove(new Integer(0));\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.removeAll(array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.retainAll(array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.set(0, (E) new Integer(0));\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Verify that iterator is not modifiable\n+     */\n+    public void testUnmodifiableIterator() {\n+        setupList();\n+        Iterator<E> iterator = list.iterator();\n+        try {\n+            iterator.next();\n+            iterator.remove();\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableList.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableList.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractTestIterableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+\n+/**\n+ * Abstract test class for {@link IterableMap} methods and contracts.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestIterableMap<K, V> extends AbstractTestMap<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractTestIterableMap(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract IterableMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        return (IterableMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFailFastEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+        if (isFailFastExpected() == false) return;\n+        resetFull();\n+        Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();\n+        Map.Entry<K, V> val = it.next();\n+        getMap().remove(val.getKey());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().entrySet().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+    }\n+\n+    public void testFailFastKeySet() {\n+        if (isRemoveSupported() == false) return;\n+        if (isFailFastExpected() == false) return;\n+        resetFull();\n+        Iterator<K> it = getMap().keySet().iterator();\n+        K val = it.next();\n+        getMap().remove(val);\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().keySet().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+    }\n+\n+    public void testFailFastValues() {\n+        if (isRemoveSupported() == false) return;\n+        if (isFailFastExpected() == false) return;\n+        resetFull();\n+        Iterator<V> it = getMap().values().iterator();\n+        it.next();\n+        getMap().remove(getMap().keySet().iterator().next());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().values().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestMapIterator() {\n+        return new InnerTestMapIterator();\n+    }\n+\n+    public class InnerTestMapIterator extends AbstractTestMapIterator<K, V> {\n+        public InnerTestMapIterator() {\n+            super(\"InnerTestMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractTestIterableMap.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractTestIterableMap.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isGetStructuralModify() {\n+            return AbstractTestIterableMap.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractTestIterableMap.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractTestIterableMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractTestIterableMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public Map<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestIterableMap.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestIterableMap.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractTestIterableMap.this.verify();\n+        }\n+    }\n+\n+//  public void testCreate() throws Exception {\n+//      resetEmpty();\n+//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n+//      resetFull();\n+//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n+//  }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public IterableMap<K, V> getMap() {\n+        return (IterableMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractTestMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n+import org.apache.commons.collections.set.AbstractTestSet;\n+\n+/**\n+ * Abstract test class for {@link java.util.Map} methods and contracts.\n+ * <p>\n+ * The forces at work here are similar to those in {@link AbstractTestCollection}.\n+ * If your class implements the full Map interface, including optional\n+ * operations, simply extend this class, and implement the\n+ * {@link #makeObject()} method.\n+ * <p>\n+ * On the other hand, if your map implementation is weird, you may have to\n+ * override one or more of the other protected methods.  They're described\n+ * below.\n+ * <p>\n+ * <b>Entry Population Methods</b>\n+ * <p>\n+ * Override these methods if your map requires special entries:\n+ *\n+ * <ul>\n+ * <li>{@link #getSampleKeys()}\n+ * <li>{@link #getSampleValues()}\n+ * <li>{@link #getNewSampleValues()}\n+ * <li>{@link #getOtherKeys()}\n+ * <li>{@link #getOtherValues()}\n+ * </ul>\n+ *\n+ * <b>Supported Operation Methods</b>\n+ * <p>\n+ * Override these methods if your map doesn't support certain operations:\n+ *\n+ * <ul>\n+ * <li> {@link #isPutAddSupported()}\n+ * <li> {@link #isPutChangeSupported()}\n+ * <li> {@link #isSetValueSupported()}\n+ * <li> {@link #isRemoveSupported()}\n+ * <li> {@link #isGetStructuralModify()}\n+ * <li> {@link #isAllowDuplicateValues()}\n+ * <li> {@link #isAllowNullKey()}\n+ * <li> {@link #isAllowNullValue()}\n+ * </ul>\n+ *\n+ * <b>Fixture Methods</b>\n+ * <p>\n+ * For tests on modification operations (puts and removes), fixtures are used\n+ * to verify that that operation results in correct state for the map and its\n+ * collection views.  Basically, the modification is performed against your\n+ * map implementation, and an identical modification is performed against\n+ * a <I>confirmed</I> map implementation.  A confirmed map implementation is\n+ * something like <Code>java.util.HashMap</Code>, which is known to conform\n+ * exactly to the {@link Map} contract.  After the modification takes place\n+ * on both your map implementation and the confirmed map implementation, the\n+ * two maps are compared to see if their state is identical.  The comparison\n+ * also compares the collection views to make sure they're still the same.<P>\n+ *\n+ * The upshot of all that is that <I>any</I> test that modifies the map in\n+ * <I>any</I> way will verify that <I>all</I> of the map's state is still\n+ * correct, including the state of its collection views.  So for instance\n+ * if a key is removed by the map's key set's iterator, then the entry set\n+ * is checked to make sure the key/value pair no longer appears.<P>\n+ *\n+ * The {@link #map} field holds an instance of your collection implementation.\n+ * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n+ * that map's collection views.  And the {@link #confirmed} field holds\n+ * an instance of the confirmed collection implementation.  The\n+ * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to\n+ * empty or full maps, so that tests can proceed from a known state.<P>\n+ *\n+ * After a modification operation to both {@link #map} and {@link #confirmed},\n+ * the {@link #verify()} method is invoked to compare the results.  The\n+ * {@link #verify} method calls separate methods to verify the map and its three\n+ * collection views ({@link #verifyMap}, {@link #verifyEntrySet},\n+ * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override\n+ * one of the verification methodsto perform additional verifications.  For\n+ * instance, TestDoubleOrderedMap would want override its\n+ * {@link #verifyValues()} method to verify that the values are unique and in\n+ * ascending order.<P>\n+ *\n+ * <b>Other Notes</b>\n+ * <p>\n+ * If your {@link Map} fails one of these tests by design, you may still use\n+ * this base set of cases.  Simply override the test case (method) your map\n+ * fails and/or the methods that define the assumptions used by the test\n+ * cases.  For example, if your map does not allow duplicate values, override\n+ * {@link #isAllowDuplicateValues()} and have it return <code>false</code>\n+ *\n+ * @author Michael Smith\n+ * @author Rodney Waldhoff\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractTestMap<K, V> extends AbstractTestObject {\n+\n+    /**\n+     * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString\n+     * This avoids nulls for JDK1.2\n+     */\n+    private static final boolean JDK12;\n+    static {\n+        String str = System.getProperty(\"java.version\");\n+        JDK12 = str.startsWith(\"1.2\");\n+    }\n+\n+    // These instance variables are initialized with the reset method.\n+    // Tests for map methods that alter the map (put, putAll, remove)\n+    // first call reset() to create the map and its views; then perform\n+    // the modification on the map; perform the same modification on the\n+    // confirmed; and then call verify() to ensure that the map is equal\n+    // to the confirmed, that the already-constructed collection views\n+    // are still equal to the confirmed's collection views.\n+\n+    /** Map created by reset(). */\n+    protected Map<K, V> map;\n+\n+    /** Entry set of map created by reset(). */\n+    protected Set<Map.Entry<K, V>> entrySet;\n+\n+    /** Key set of map created by reset(). */\n+    protected Set<K> keySet;\n+\n+    /** Values collection of map created by reset(). */\n+    protected Collection<V> values;\n+\n+    /** HashMap created by reset(). */\n+    protected Map<K, V> confirmed;\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractTestMap(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>put</code> and <code>putAll</code> operations\n+     * adding new mappings.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support put adding.\n+     */\n+    public boolean isPutAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>put</code> and <code>putAll</code> operations\n+     * changing existing mappings.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support put changing.\n+     */\n+    public boolean isPutChangeSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>setValue</code> operation on entrySet entries.\n+     * <p>\n+     * Default implementation returns isPutChangeSupported().\n+     * Override if your collection class does not support setValue but does\n+     * support put changing.\n+     */\n+    public boolean isSetValueSupported() {\n+        return isPutChangeSupported();\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>remove</code> and <code>clear</code> operations.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support removal operations.\n+     */\n+    public boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * can cause structural modification on a get(). The example is LRUMap.\n+     * <p>\n+     * Default implementation returns false.\n+     * Override if your map class structurally modifies on get.\n+     */\n+    public boolean isGetStructuralModify() {\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether the sub map views of SortedMap are serializable.\n+     * If the class being tested is based around a TreeMap then you should\n+     * override and return false as TreeMap has a bug in deserialization.\n+     *\n+     * @return false\n+     */\n+    public boolean isSubMapViewsSerializable() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports null keys.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support null keys.\n+     */\n+    public boolean isAllowNullKey() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports null values.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support null values.\n+     */\n+    public boolean isAllowNullValue() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports duplicate values.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support duplicate values.\n+     */\n+    public boolean isAllowDuplicateValues() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * provide fail-fast behavior on their various iterators.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support fast failure.\n+     */\n+    public boolean isFailFastExpected() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns the set of keys in the mappings used to test the map.  This\n+     *  method must return an array with the same length as {@link\n+     *  #getSampleValues()} and all array elements must be different. The\n+     *  default implementation constructs a set of String keys, and includes a\n+     *  single null key if {@link #isAllowNullKey()} returns <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        Object[] result = new Object[] {\n+            \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\",\n+            \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n+            \"key\",\n+            \"key2\",\n+            (isAllowNullKey() && !JDK12) ? null : \"nonnullkey\"\n+        };\n+        return (K[]) result;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getOtherKeys() {\n+        return (K[]) getOtherNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getOtherValues() {\n+        return (V[]) getOtherNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <E> List<E> getAsList(Object[] o) {\n+        ArrayList<E> result = new ArrayList<E>();\n+        for (Object element : o) {\n+            result.add((E) element);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a list of string elements suitable for return by\n+     * {@link #getOtherKeys()} or {@link #getOtherValues}.\n+     *\n+     * <p>Override getOtherElements to return the results of this method if your\n+     * collection does not support heterogenous elements or the null element.\n+     * </p>\n+     */\n+    public Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\",\"then\",\"despite\",/* of */\"space\",\"I\",\"would\",\"be\",\"brought\",\n+            \"From\",\"limits\",\"far\",\"remote\",\"where\",\"thou\",\"dost\",\"stay\"\n+        };\n+    }\n+\n+    /**\n+     * Returns the set of values in the mappings used to test the map.  This\n+     * method must return an array with the same length as\n+     * {@link #getSampleKeys()}.  The default implementation constructs a set of\n+     * String values and includes a single null value if\n+     * {@link #isAllowNullValue()} returns <code>true</code>, and includes\n+     * two values that are the same if {@link #isAllowDuplicateValues()} returns\n+     * <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        Object[] result = new Object[] {\n+            \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n+            \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n+            (isAllowNullValue() && !JDK12) ? null : \"nonnullvalue\",\n+            \"value\",\n+            (isAllowDuplicateValues()) ? \"value\" : \"value2\",\n+        };\n+        return (V[]) result;\n+    }\n+\n+    /**\n+     * Returns a the set of values that can be used to replace the values\n+     * returned from {@link #getSampleValues()}.  This method must return an\n+     * array with the same length as {@link #getSampleValues()}.  The values\n+     * returned from this method should not be the same as those returned from\n+     * {@link #getSampleValues()}.  The default implementation constructs a\n+     * set of String values and includes a single null value if\n+     * {@link #isAllowNullValue()} returns <code>true</code>, and includes two values\n+     * that are the same if {@link #isAllowDuplicateValues()} returns\n+     * <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        Object[] result = new Object[] {\n+            (isAllowNullValue() && !JDK12 && isAllowDuplicateValues()) ? null : \"newnonnullvalue\",\n+            \"newvalue\",\n+            (isAllowDuplicateValues()) ? \"newvalue\" : \"newvalue2\",\n+            \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\",\n+            \"newgollyv\", \"newgeev\", \"newhellov\", \"newgoodbyev\", \"newwe'llv\",\n+            \"newseev\", \"newyouv\", \"newallv\", \"newagainv\",\n+        };\n+        return (V[]) result;\n+    }\n+\n+    /**\n+     *  Helper method to add all the mappings described by\n+     * {@link #getSampleKeys()} and {@link #getSampleValues()}.\n+     */\n+    public void addSampleMappings(Map<? super K, ? super V> m) {\n+\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            try {\n+                m.put(keys[i], values[i]);\n+            } catch (NullPointerException exception) {\n+                assertTrue(\"NullPointerException only allowed to be thrown \" +\n+                           \"if either the key or value is null.\",\n+                           keys[i] == null || values[i] == null);\n+\n+                assertTrue(\"NullPointerException on null key, but \" +\n+                           \"isAllowNullKey is not overridden to return false.\",\n+                           keys[i] == null || !isAllowNullKey());\n+\n+                assertTrue(\"NullPointerException on null value, but \" +\n+                           \"isAllowNullValue is not overridden to return false.\",\n+                           values[i] == null || !isAllowNullValue());\n+\n+                assertTrue(\"Unknown reason for NullPointer.\", false);\n+            }\n+        }\n+        assertEquals(\"size must reflect number of mappings added.\",\n+                     keys.length, m.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return a new, empty {@link Map} to be used for testing.\n+     *\n+     * @return the map to be tested\n+     */\n+    @Override\n+    public abstract Map<K,V> makeObject();\n+\n+    /**\n+     * Return a new, populated map.  The mappings in the map should match the\n+     * keys and values returned from {@link #getSampleKeys()} and\n+     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()\n+     * and calls {@link #addSampleMappings} to add all the mappings to the\n+     * map.\n+     *\n+     * @return the map to be tested\n+     */\n+    public Map<K, V> makeFullMap() {\n+        Map<K, V> m = makeObject();\n+        addSampleMappings(m);\n+        return m;\n+    }\n+\n+    /**\n+     * Override to return a map other than HashMap as the confirmed map.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n+    }\n+\n+    /**\n+     * Creates a new Map Entry that is independent of the first and the map.\n+     */\n+    public static <K, V> Map.Entry<K, V> cloneMapEntry(Map.Entry<K, V> entry) {\n+        HashMap<K, V> map = new HashMap<K, V>();\n+        map.put(entry.getKey(), entry.getValue());\n+        return map.entrySet().iterator().next();\n+    }\n+\n+    /**\n+     * Gets the compatability version, needed for package access.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return super.getCompatibilityVersion();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test to ensure the test setup is working properly.  This method checks\n+     * to ensure that the getSampleKeys and getSampleValues methods are\n+     * returning results that look appropriate.  That is, they both return a\n+     * non-null array of equal length.  The keys array must not have any\n+     * duplicate values, and may only contain a (single) null key if\n+     * isNullKeySupported() returns true.  The values array must only have a null\n+     * value if useNullValue() is true and may only have duplicate values if\n+     * isAllowDuplicateValues() returns true.\n+     */\n+    public void testSampleMappings() {\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        Object[] newValues = getNewSampleValues();\n+\n+        assertNotNull(\"failure in test: Must have keys returned from \" +\n+                 \"getSampleKeys.\", keys);\n+\n+        assertNotNull(\"failure in test: Must have values returned from \" +\n+                 \"getSampleValues.\", values);\n+\n+        // verify keys and values have equivalent lengths (in case getSampleX are\n+        // overridden)\n+        assertEquals(\"failure in test: not the same number of sample \" +\n+                   \"keys and values.\",  keys.length, values.length);\n+\n+        assertEquals(\"failure in test: not the same number of values and new values.\",\n+                   values.length, newValues.length);\n+\n+        // verify there aren't duplicate keys, and check values\n+        for (int i = 0; i < keys.length - 1; i++) {\n+            for (int j = i + 1; j < keys.length; j++) {\n+                assertTrue(\"failure in test: duplicate null keys.\",\n+                        (keys[i] != null || keys[j] != null));\n+                assertTrue(\n+                        \"failure in test: duplicate non-null key.\",\n+                        (keys[i] == null || keys[j] == null || (!keys[i].equals(keys[j]) && !keys[j]\n+                                .equals(keys[i]))));\n+            }\n+            assertTrue(\"failure in test: found null key, but isNullKeySupported \" + \"is false.\",\n+                    keys[i] != null || isAllowNullKey());\n+            assertTrue(\n+                    \"failure in test: found null value, but isNullValueSupported \" + \"is false.\",\n+                    values[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: found null new value, but isNullValueSupported \"\n+                    + \"is false.\", newValues[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: values should not be the same as new value\",\n+                    values[i] != newValues[i]\n+                            && (values[i] == null || !values[i].equals(newValues[i])));\n+        }\n+    }\n+\n+    // tests begin here.  Each test adds a little bit of tested functionality.\n+    // Many methods assume previous methods passed.  That is, they do not\n+    // exhaustively recheck things that have already been checked in a previous\n+    // test methods.\n+\n+    /**\n+     * Test to ensure that makeEmptyMap and makeFull returns a new non-null\n+     * map with each invocation.\n+     */\n+    public void testMakeMap() {\n+        Map<K, V> em = makeObject();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        Map<K, V> em2 = makeObject();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        assertTrue(\"failure in test: makeEmptyMap must return a new map \" +\n+                   \"with each invocation.\", em != em2);\n+\n+        Map<K, V> fm = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        Map<K, V> fm2 = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        assertTrue(\"failure in test: makeFullMap must return a new map \" +\n+                   \"with each invocation.\", fm != fm2);\n+    }\n+\n+    /**\n+     * Tests Map.isEmpty()\n+     */\n+    public void testMapIsEmpty() {\n+        resetEmpty();\n+        assertEquals(\"Map.isEmpty() should return true with an empty map\",\n+                     true, getMap().isEmpty());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.isEmpty() should return false with a non-empty map\",\n+                     false, getMap().isEmpty());\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.size()\n+     */\n+    public void testMapSize() {\n+        resetEmpty();\n+        assertEquals(\"Map.size() should be 0 with an empty map\",\n+                     0, getMap().size());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.size() should equal the number of entries \" +\n+                     \"in the map\", getSampleKeys().length, getMap().size());\n+        verify();\n+    }\n+\n+    /**\n+     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}\n+     * can add and remove elements}, then {@link Map#size()} and\n+     * {@link Map#isEmpty()} are used to ensure that map has no elements after\n+     * a call to clear.  If the map does not support adding and removing\n+     * elements, this method checks to ensure clear throws an\n+     * UnsupportedOperationException.\n+     */\n+    public void testMapClear() {\n+        if (!isRemoveSupported()) {\n+            try {\n+                resetFull();\n+                getMap().clear();\n+                fail(\"Expected UnsupportedOperationException on clear\");\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        resetEmpty();\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+\n+        resetFull();\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.containsKey(Object) by verifying it returns false for all\n+     * sample keys on a map created using an empty map and returns true for\n+     * all sample keys returned on a full map.\n+     */\n+    public void testMapContainsKey() {\n+        Object[] keys = getSampleKeys();\n+\n+        resetEmpty();\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must not contain key when map is empty\",\n+                       !getMap().containsKey(keys[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must contain key for a mapping in the map. \" +\n+                       \"Missing: \" + keys[i], getMap().containsKey(keys[i]));\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.containsValue(Object) by verifying it returns false for all\n+     * sample values on an empty map and returns true for all sample values on\n+     * a full map.\n+     */\n+    public void testMapContainsValue() {\n+        Object[] values = getSampleValues();\n+\n+        resetEmpty();\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Empty map must not contain value\",\n+                       !getMap().containsValue(values[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Map must contain value for a mapping in the map.\",\n+                    getMap().containsValue(values[i]));\n+        }\n+        verify();\n+    }\n+\n+\n+    /**\n+     * Tests Map.equals(Object)\n+     */\n+    public void testMapEquals() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps unequal.\", getMap().equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full maps unequal.\", getMap().equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        // modify the HashMap created from the full map and make sure this\n+        // change results in map.equals() to return false.\n+        Iterator<K> iter = confirmed.keySet().iterator();\n+        iter.next();\n+        iter.remove();\n+        assertTrue(\"Different maps equal.\", !getMap().equals(confirmed));\n+\n+        resetFull();\n+        assertTrue(\"equals(null) returned true.\", !getMap().equals(null));\n+        assertTrue(\"equals(new Object()) returned true.\",\n+                   !getMap().equals(new Object()));\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.get(Object)\n+     */\n+    public void testMapGet() {\n+        resetEmpty();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Empty map.get() should return null.\",\n+                    getMap().get(keys[i]) == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+        for (int i = 0; i < keys.length; i++) {\n+            assertEquals(\"Full map.get() should return value from mapping.\",\n+                         values[i], getMap().get(keys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.hashCode()\n+     */\n+    public void testMapHashCode() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n+\n+        resetFull();\n+        assertTrue(\"Equal maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n+    }\n+\n+    /**\n+     * Tests Map.toString().  Since the format of the string returned by the\n+     * toString() method is not defined in the Map interface, there is no\n+     * common way to test the results of the toString() method.  Thereforce,\n+     * it is encouraged that Map implementations override this test with one\n+     * that checks the format matches any format defined in its API.  This\n+     * default implementation just verifies that the toString() method does\n+     * not return null.\n+     */\n+    public void testMapToString() {\n+        resetEmpty();\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testEmptyMapCompatibility() throws Exception {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeEmptyMap();\n+        if (!(map instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        Map<K, V> map = makeObject();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+            assertEquals(\"Map is empty\", 0, map2.size());\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testFullMapCompatibility() throws Exception {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeFullMap();\n+        if (!(map instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        Map<K, V> map = makeFullMap();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+            assertEquals(\"Map is the right size\", getSampleKeys().length, map2.size());\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(Object, Object)\n+     */\n+    public void testMapPut() {\n+        resetEmpty();\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        V[] newValues = getNewSampleValues();\n+\n+        if (isPutAddSupported()) {\n+            for (int i = 0; i < keys.length; i++) {\n+                Object o = getMap().put(keys[i], values[i]);\n+                getConfirmed().put(keys[i], values[i]);\n+                verify();\n+                assertTrue(\"First map.put should return null\", o == null);\n+                assertTrue(\"Map should contain key after put\",\n+                        getMap().containsKey(keys[i]));\n+                assertTrue(\"Map should contain value after put\",\n+                        getMap().containsValue(values[i]));\n+            }\n+            if (isPutChangeSupported()) {\n+                for (int i = 0; i < keys.length; i++) {\n+                    Object o = getMap().put(keys[i], newValues[i]);\n+                    getConfirmed().put(keys[i], newValues[i]);\n+                    verify();\n+                    assertEquals(\"Map.put should return previous value when changed\", values[i], o);\n+                    assertTrue(\"Map should still contain key after put when changed\",\n+                            getMap().containsKey(keys[i]));\n+                    assertTrue(\"Map should contain new value after put when changed\",\n+                            getMap().containsValue(newValues[i]));\n+\n+                    // if duplicates are allowed, we're not guaranteed that the value\n+                    // no longer exists, so don't try checking that.\n+                    if (!isAllowDuplicateValues()) {\n+                        assertTrue(\"Map should not contain old value after put when changed\",\n+                                !getMap().containsValue(values[i]));\n+                    }\n+                }\n+            } else {\n+                try {\n+                    // two possible exception here, either valid\n+                    getMap().put(keys[0], newValues[0]);\n+                    fail(\"Expected IllegalArgumentException or UnsupportedOperationException on put (change)\");\n+                } catch (IllegalArgumentException ex) {\n+                } catch (UnsupportedOperationException ex) {}\n+            }\n+\n+        } else if (isPutChangeSupported()) {\n+            resetEmpty();\n+            try {\n+                getMap().put(keys[0], values[0]);\n+                fail(\"Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size\");\n+            } catch (IllegalArgumentException ex) {\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+\n+            resetFull();\n+            int i = 0;\n+            for (Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n+                K  key = it.next();\n+                V o = getMap().put(key, newValues[i]);\n+                V value = getConfirmed().put(key, newValues[i]);\n+                verify();\n+                assertEquals(\"Map.put should return previous value when changed\", value, o);\n+                assertTrue(\"Map should still contain key after put when changed\", getMap()\n+                        .containsKey(key));\n+                assertTrue(\"Map should contain new value after put when changed\", getMap()\n+                        .containsValue(newValues[i]));\n+\n+                // if duplicates are allowed, we're not guaranteed that the value\n+                // no longer exists, so don't try checking that.\n+                if (!isAllowDuplicateValues()) {\n+                    assertTrue(\"Map should not contain old value after put when changed\",\n+                        !getMap().containsValue(values[i]));\n+                }\n+            }\n+        } else {\n+            try {\n+                getMap().put(keys[0], values[0]);\n+                fail(\"Expected UnsupportedOperationException on put (add)\");\n+            } catch (UnsupportedOperationException ex) {}\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(null, value)\n+     */\n+    public void testMapPutNullKey() {\n+        resetFull();\n+        V[] values = getSampleValues();\n+\n+        if (isPutAddSupported()) {\n+            if (isAllowNullKey()) {\n+                getMap().put(null, values[0]);\n+            } else {\n+                try {\n+                    getMap().put(null, values[0]);\n+                    fail(\"put(null, value) should throw NPE/IAE\");\n+                } catch (NullPointerException ex) {\n+                } catch (IllegalArgumentException ex) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(null, value)\n+     */\n+    public void testMapPutNullValue() {\n+        resetFull();\n+        K[] keys = getSampleKeys();\n+\n+        if (isPutAddSupported()) {\n+            if (isAllowNullValue()) {\n+                getMap().put(keys[0], null);\n+            } else {\n+                try {\n+                    getMap().put(keys[0], null);\n+                    fail(\"put(key, null) should throw NPE/IAE\");\n+                } catch (NullPointerException ex) {\n+                } catch (IllegalArgumentException ex) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.putAll(map)\n+     */\n+    public void testMapPutAll() {\n+        if (!isPutAddSupported()) {\n+            if (!isPutChangeSupported()) {\n+                Map<K, V> temp = makeFullMap();\n+                resetEmpty();\n+                try {\n+                    getMap().putAll(temp);\n+                    fail(\"Expected UnsupportedOperationException on putAll\");\n+                } catch (UnsupportedOperationException ex) {}\n+            }\n+            return;\n+        }\n+\n+        // check putAll OK adding empty map to empty map\n+        resetEmpty();\n+        assertEquals(0, getMap().size());\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(0, getMap().size());\n+\n+        // check putAll OK adding empty map to non-empty map\n+        resetFull();\n+        int size = getMap().size();\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(size, getMap().size());\n+\n+        // check putAll OK adding non-empty map to empty map\n+        resetEmpty();\n+        Map<K, V> m2 = makeFullMap();\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+\n+        // check putAll OK adding non-empty JDK map to empty map\n+        resetEmpty();\n+        m2 = makeConfirmedMap();\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        for(int i = 0; i < keys.length; i++) {\n+            m2.put(keys[i], values[i]);\n+        }\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+\n+        // check putAll OK adding non-empty JDK map to non-empty map\n+        resetEmpty();\n+        m2 = makeConfirmedMap();\n+        getMap().put(keys[0], values[0]);\n+        getConfirmed().put(keys[0], values[0]);\n+        verify();\n+        for(int i = 1; i < keys.length; i++) {\n+            m2.put(keys[i], values[i]);\n+        }\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.remove(Object)\n+     */\n+    public void testMapRemove() {\n+        if (!isRemoveSupported()) {\n+            try {\n+                resetFull();\n+                getMap().remove(getMap().keySet().iterator().next());\n+                fail(\"Expected UnsupportedOperationException on remove\");\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        resetEmpty();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        for (int i = 0; i < keys.length; i++) {\n+            Object o = getMap().remove(keys[i]);\n+            assertTrue(\"First map.remove should return null\", o == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            Object o = getMap().remove(keys[i]);\n+            getConfirmed().remove(keys[i]);\n+            verify();\n+\n+            assertEquals(\"map.remove with valid key should return value\",\n+                         values[i], o);\n+        }\n+\n+        Object[] other = getOtherKeys();\n+\n+        resetFull();\n+        int size = getMap().size();\n+        for (int i = 0; i < other.length; i++) {\n+            Object o = getMap().remove(other[i]);\n+            assertNull(\"map.remove for nonexistent key should return null\", o);\n+            assertEquals(\"map.remove for nonexistent key should not \" +\n+                         \"shrink map\", size, getMap().size());\n+        }\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testValuesClearChangesMap() {\n+        if (!isRemoveSupported()) return;\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(values.size() > 0);\n+        values.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(values.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(values.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(values.size() == 0);\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#keySet} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testKeySetClearChangesMap() {\n+        if (!isRemoveSupported()) return;\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Set<K> keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        keySet.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(keySet.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(keySet.size() == 0);\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#entrySet()} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testEntrySetClearChangesMap() {\n+        if (!isRemoveSupported()) return;\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        entrySet.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEntrySetContains1() {\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        assertEquals(true, entrySet.contains(entry));\n+    }\n+\n+    public void testEntrySetContains2() {\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        Map.Entry<K, V> test = cloneMapEntry(entry);\n+        assertEquals(true, entrySet.contains(test));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySetContains3() {\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+        assertEquals(false, entrySet.contains(test));\n+    }\n+\n+    public void testEntrySetRemove1() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+\n+        assertEquals(true, entrySet.remove(entry));\n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n+    public void testEntrySetRemove2() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+        Map.Entry<K, V> test = cloneMapEntry(entry);\n+\n+        assertEquals(true, entrySet.remove(test));\n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySetRemove3() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+        HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+\n+        assertEquals(false, entrySet.remove(test));\n+        assertEquals(true, getMap().containsKey(key));\n+        assertEquals(size, getMap().size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map by removing from the values collection\n+     * and testing if the value was removed from the map.\n+     * <p>\n+     * We should really test the \"vice versa\" case--that values removed\n+     * from the map are removed from the values collection--also,\n+     * but that's a more difficult test to construct (lacking a\n+     * \"removeValue\" method.)\n+     * </p>\n+     * <p>\n+     * See bug <a href=\"http://issues.apache.org/bugzilla/show_bug.cgi?id=9573\">\n+     * 9573</a>.\n+     * </p>\n+     */\n+    public void testValuesRemoveChangesMap() {\n+        resetFull();\n+        V[] sampleValues = getSampleValues();\n+        Collection<V> values = getMap().values();\n+        for (int i = 0; i < sampleValues.length; i++) {\n+            if (map.containsValue(sampleValues[i])) {\n+                int j = 0;  // loop counter prevents infinite loops when remove is broken\n+                while (values.contains(sampleValues[i]) && j < 10000) {\n+                    try {\n+                        values.remove(sampleValues[i]);\n+                    } catch (UnsupportedOperationException e) {\n+                        // if values.remove is unsupported, just skip this test\n+                        return;\n+                    }\n+                    j++;\n+                }\n+                assertTrue(\"values().remove(obj) is broken\", j < 10000);\n+                assertTrue(\n+                    \"Value should have been removed from the underlying map.\",\n+                    !getMap().containsValue(sampleValues[i]));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests values.removeAll.\n+     */\n+    public void testValuesRemoveAll() {\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        if (!values.equals(sampleValuesAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(values.removeAll(Collections.<V> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.removeAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertEquals(sampleValuesAsList.size(), getMap().size());\n+        try {\n+            assertTrue(values.removeAll(sampleValuesAsList));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.removeAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test values.retainAll.\n+     */\n+    public void testValuesRetainAll() {\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        if (!values.equals(sampleValuesAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(values.retainAll(sampleValuesAsList));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.retainAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertEquals(sampleValuesAsList.size(), getMap().size());\n+        try {\n+            assertTrue(values.retainAll(Collections.<V> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.retainAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verifies that values.iterator.remove changes the underlying map.\n+     */\n+    public void testValuesIteratorRemoveChangesMap() {\n+        resetFull();\n+        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);\n+        Collection<V> values = getMap().values();\n+        for (Iterator<V> iter = values.iterator(); iter.hasNext();) {\n+            V value = iter.next();\n+            Integer count = cardinality.get(value);\n+            if (count == null) {\n+                return;\n+            }\n+            try {\n+                iter.remove();\n+                cardinality.put(value, --count);\n+            } catch (UnsupportedOperationException e) {\n+                // if values.iterator.remove is unsupported, just skip this test\n+                return;\n+            }\n+            boolean expected = count > 0;\n+            StringBuilder msg = new StringBuilder(\"Value should \");\n+            msg.append(expected ? \"yet \" : \"no longer \");\n+            msg.append(\"be present in the underlying map\");\n+            assertEquals(msg.toString(), expected, getMap().containsValue(value));\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#keySet} set is backed by\n+     * the underlying map by removing from the keySet set\n+     * and testing if the key was removed from the map.\n+     */\n+    public void testKeySetRemoveChangesMap() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        Set<K> keys = getMap().keySet();\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            try {\n+                keys.remove(sampleKeys[i]);\n+            } catch (UnsupportedOperationException e) {\n+                // if key.remove is unsupported, just skip this test\n+                return;\n+            }\n+            assertTrue(\n+                \"Key should have been removed from the underlying map.\",\n+                !getMap().containsKey(sampleKeys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Test keySet.removeAll.\n+     */\n+    public void testKeySetRemoveAll() {\n+        resetFull();\n+        Set<K> keys = getMap().keySet();\n+        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(keys.removeAll(Collections.<K> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+            assertTrue(keys.removeAll(sampleKeysAsList));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test keySet.retainAll.\n+     */\n+    public void testKeySetRetainAll() {\n+        resetFull();\n+        Set<K> keys = getMap().keySet();\n+        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(keys.retainAll(sampleKeysAsList));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+            assertTrue(keys.retainAll(Collections.<K> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that keySet.iterator.remove changes the underlying map.\n+     */\n+    public void testKeySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {\n+            K key = iter.next();\n+            try {\n+                iter.remove();\n+            } catch (UnsupportedOperationException e) {\n+                return;\n+            }\n+            assertFalse(getMap().containsKey(key));\n+        }\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#entrySet} set is backed by\n+     * the underlying map by removing from the entrySet set\n+     * and testing if the entry was removed from the map.\n+     */\n+    public void testEntrySetRemoveChangesMap() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        V[] sampleValues = getSampleValues();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            try {\n+                entrySet.remove(new DefaultMapEntry<K, V>(sampleKeys[i], sampleValues[i]));\n+            } catch (UnsupportedOperationException e) {\n+                // if entrySet removal is unsupported, just skip this test\n+                return;\n+            }\n+            assertTrue(\n+                    \"Entry should have been removed from the underlying map.\",\n+                    !getMap().containsKey(sampleKeys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Test entrySet.removeAll.\n+     */\n+    public void testEntrySetRemoveAll() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        V[] sampleValues = getSampleValues();\n+        //verify map looks as expected:\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            if (!getMap().containsKey(sampleKeys[i])) {\n+                return;\n+            }\n+            V value = sampleValues[i];\n+            V test = getMap().get(sampleKeys[i]);\n+            if (value == test || value != null && value.equals(test)) {\n+                continue;\n+            }\n+            return;\n+        }\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        try {\n+            assertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeys.length, getMap().size());\n+        try {\n+            assertTrue(entrySet.removeAll(comparisonSet));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test entrySet.retainAll.\n+     */\n+    public void testEntrySetRetainAll() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        V[] sampleValues = getSampleValues();\n+        //verify map looks as expected:\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            if (!getMap().containsKey(sampleKeys[i])) {\n+                return;\n+            }\n+            V value = sampleValues[i];\n+            V test = getMap().get(sampleKeys[i]);\n+            if (value == test || value != null && value.equals(test)) {\n+                continue;\n+            }\n+            return;\n+        }\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        try {\n+            assertFalse(entrySet.retainAll(comparisonSet));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeys.length, getMap().size());\n+        try {\n+            assertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that entrySet.iterator.remove changes the underlying map.\n+     */\n+    public void testEntrySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {\n+            K key = iter.next().getKey();\n+            try {\n+                iter.remove();\n+            } catch (UnsupportedOperationException e) {\n+                return;\n+            }\n+            assertFalse(getMap().containsKey(key));\n+        }\n+    }\n+\n+    /**\n+     * Utility methods to create an array of Map.Entry objects\n+     * out of the given key and value arrays.<P>\n+     *\n+     * @param keys    the array of keys\n+     * @param values  the array of values\n+     * @return an array of Map.Entry of those keys to those values\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Map.Entry<K, V>[] makeEntryArray(K[] keys, V[] values) {\n+        Map.Entry<K, V>[] result = new Map.Entry[keys.length];\n+        for (int i = 0; i < keys.length; i++) {\n+            Map<K, V> map = makeConfirmedMap();\n+            map.put(keys[i], values[i]);\n+            result[i] = map.entrySet().iterator().next();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Bulk test {@link Map#entrySet()}.  This method runs through all of\n+     * the tests in {@link AbstractTestSet}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractTestSet} instance for testing the map's entry set\n+     */\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestMapEntrySet();\n+    }\n+\n+    public class TestMapEntrySet extends AbstractTestSet<Map.Entry<K, V>> {\n+        public TestMapEntrySet() {\n+            super(\"MapEntrySet\");\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Entry<K, V>[] getFullElements() {\n+            return getFullNonNullElements();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Map.Entry<K, V>[] getFullNonNullElements() {\n+            K[] k = getSampleKeys();\n+            V[] v = getSampleValues();\n+            return makeEntryArray(k, v);\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        @Override\n+        public Map.Entry<K, V>[] getOtherElements() {\n+            K[] k = getOtherKeys();\n+            V[] v = getOtherValues();\n+            return makeEntryArray(k, v);\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, V>> makeObject() {\n+            return AbstractTestMap.this.makeObject().entrySet();\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, V>> makeFullCollection() {\n+            return makeFullMap().entrySet();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            // Collection views don't support add operations.\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            // Entry set should only support remove if map does\n+            return AbstractTestMap.this.isRemoveSupported();\n+        }\n+\n+        public boolean isGetStructuralModify() {\n+            return AbstractTestMap.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractTestMap.this.resetFull();\n+            setCollection(AbstractTestMap.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().entrySet());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractTestMap.this.resetEmpty();\n+            setCollection(AbstractTestMap.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().entrySet());\n+        }\n+\n+        public void testMapEntrySetIteratorEntry() {\n+            resetFull();\n+            Iterator<Map.Entry<K, V>> it = getCollection().iterator();\n+            int count = 0;\n+            while (it.hasNext()) {\n+                Map.Entry<K, V> entry = it.next();\n+                assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry.getKey()));\n+                assertEquals(true, AbstractTestMap.this.getMap().containsValue(entry.getValue()));\n+                if (isGetStructuralModify() == false) {\n+                    assertEquals(AbstractTestMap.this.getMap().get(entry.getKey()), entry.getValue());\n+                }\n+                count++;\n+            }\n+            assertEquals(getCollection().size(), count);\n+        }\n+\n+        public void testMapEntrySetIteratorEntrySetValue() {\n+            K key1 = getSampleKeys()[0];\n+            K key2 = (getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1]);\n+            V newValue1 = getNewSampleValues()[0];\n+            V newValue2 = (getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1]);\n+\n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            it = TestMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            verify();\n+\n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestMap.this.getMap().get(entry1.getKey()));\n+            verify();\n+\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractTestMap.this.getMap().get(entry1.getKey()));\n+            verify();\n+\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+            assertEquals(newValue2, entry2.getValue());\n+            assertEquals(true, AbstractTestMap.this.getMap().containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractTestMap.this.getMap().containsValue(newValue2));\n+            assertEquals(newValue2, AbstractTestMap.this.getMap().get(entry2.getKey()));\n+            verify();\n+        }\n+\n+        public Map.Entry<K, V> getEntry(Iterator<Map.Entry<K, V>> itConfirmed, K key) {\n+            Map.Entry<K, V> entry = null;\n+            while (itConfirmed.hasNext()) {\n+                Map.Entry<K, V> temp = itConfirmed.next();\n+                if (temp.getKey() == null) {\n+                    if (key == null) {\n+                        entry = temp;\n+                        break;\n+                    }\n+                } else if (temp.getKey().equals(key)) {\n+                    entry = temp;\n+                    break;\n+                }\n+            }\n+            assertNotNull(\"No matching entry in map for key '\" + key + \"'\", entry);\n+            return entry;\n+        }\n+\n+        public void testMapEntrySetRemoveNonMapEntry() {\n+            if (isRemoveSupported() == false) return;\n+            resetFull();\n+            assertEquals(false, getCollection().remove(null));\n+            assertEquals(false, getCollection().remove(new Object()));\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractTestMap.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     * Bulk test {@link Map#keySet()}.  This method runs through all of\n+     * the tests in {@link AbstractTestSet}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractTestSet} instance for testing the map's key set\n+     */\n+    public BulkTest bulkTestMapKeySet() {\n+        return new TestMapKeySet();\n+    }\n+\n+    public class TestMapKeySet extends AbstractTestSet<K> {\n+        public TestMapKeySet() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return getSampleKeys();\n+        }\n+\n+        @Override\n+        public K[] getOtherElements() {\n+            return getOtherKeys();\n+        }\n+\n+        @Override\n+        public Set<K> makeObject() {\n+            return AbstractTestMap.this.makeObject().keySet();\n+        }\n+\n+        @Override\n+        public Set<K> makeFullCollection() {\n+            return AbstractTestMap.this.makeFullMap().keySet();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractTestMap.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractTestMap.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractTestMap.this.resetEmpty();\n+            setCollection(AbstractTestMap.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().keySet());\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractTestMap.this.resetFull();\n+            setCollection(AbstractTestMap.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractTestMap.this.getConfirmed().keySet());\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractTestMap.this.verify();\n+        }\n+    }\n+\n+    /**\n+     * Bulk test {@link Map#values()}.  This method runs through all of\n+     * the tests in {@link AbstractTestCollection}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractTestCollection} instance for testing the map's\n+     *    values collection\n+     */\n+    public BulkTest bulkTestMapValues() {\n+        return new TestMapValues();\n+    }\n+\n+    public class TestMapValues extends AbstractTestCollection<V> {\n+        public TestMapValues() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public V[] getFullElements() {\n+            return getSampleValues();\n+        }\n+\n+        @Override\n+        public V[] getOtherElements() {\n+            return getOtherValues();\n+        }\n+\n+        @Override\n+        public Collection<V> makeObject() {\n+            return AbstractTestMap.this.makeObject().values();\n+        }\n+\n+        @Override\n+        public Collection<V> makeFullCollection() {\n+            return AbstractTestMap.this.makeFullMap().values();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractTestMap.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractTestMap.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean areEqualElementsDistinguishable() {\n+            // equal values are associated with different keys, so they are\n+            // distinguishable.\n+            return true;\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedFullCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractTestMap.this.resetFull();\n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractTestMap.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractTestMap.this.resetEmpty();\n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractTestMap.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractTestMap.this.verify();\n+        }\n+\n+        // TODO: should test that a remove on the values collection view\n+        // removes the proper mapping and not just any mapping that may have\n+        // the value equal to the value returned from the values iterator.\n+    }\n+\n+\n+    /**\n+     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     * {@link #values} and {@link #confirmed} fields to empty.\n+     */\n+    public void resetEmpty() {\n+        this.map = makeObject();\n+        views();\n+        this.confirmed = makeConfirmedMap();\n+    }\n+\n+    /**\n+     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     * {@link #values} and {@link #confirmed} fields to full.\n+     */\n+    public void resetFull() {\n+        this.map = makeFullMap();\n+        views();\n+        this.confirmed = makeConfirmedMap();\n+        K[] k = getSampleKeys();\n+        V[] v = getSampleValues();\n+        for (int i = 0; i < k.length; i++) {\n+            confirmed.put(k[i], v[i]);\n+        }\n+    }\n+\n+    /**\n+     * Resets the collection view fields.\n+     */\n+    private void views() {\n+        this.keySet = getMap().keySet();\n+        this.values = getMap().values();\n+        this.entrySet = getMap().entrySet();\n+    }\n+\n+    /**\n+     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     * This method checks that the map is equal to the HashMap,\n+     * <I>and</I> that the map's collection views are still equal to\n+     * the HashMap's collection views.  An <Code>equals</Code> test\n+     * is done on the maps and their collection views; their size and\n+     * <Code>isEmpty</Code> results are compared; their hashCodes are\n+     * compared; and <Code>containsAll</Code> tests are run on the\n+     * collection views.\n+     */\n+    public void verify() {\n+        verifyMap();\n+        verifyEntrySet();\n+        verifyKeySet();\n+        verifyValues();\n+    }\n+\n+    public void verifyMap() {\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"Map should be same size as HashMap\", size, getMap().size());\n+        assertEquals(\"Map should be empty if HashMap is\", empty, getMap().isEmpty());\n+        assertEquals(\"hashCodes should be the same\", getConfirmed().hashCode(), getMap().hashCode());\n+        // this fails for LRUMap because confirmed.equals() somehow modifies\n+        // map, causing concurrent modification exceptions.\n+        //assertEquals(\"Map should still equal HashMap\", confirmed, map);\n+        // this works though and performs the same verification:\n+        assertTrue(\"Map should still equal HashMap\", getMap().equals(getConfirmed()));\n+        // TODO: this should really be reexamined to figure out why LRU map\n+        // behaves like it does (the equals shouldn't modify since all accesses\n+        // by the confirmed collection should be through an iterator, thus not\n+        // causing LRUMap to change).\n+    }\n+\n+    public void verifyEntrySet() {\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"entrySet should be same size as HashMap's\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     size, entrySet.size());\n+        assertEquals(\"entrySet should be empty if HashMap is\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     empty, entrySet.isEmpty());\n+        assertTrue(\"entrySet should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                   entrySet.containsAll(getConfirmed().entrySet()));\n+        assertEquals(\"entrySet hashCodes should be the same\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     getConfirmed().entrySet().hashCode(), entrySet.hashCode());\n+        assertEquals(\"Map's entry set should still equal HashMap's\",\n+                     getConfirmed().entrySet(), entrySet);\n+    }\n+\n+    public void verifyKeySet() {\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"keySet should be same size as HashMap's\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     size, keySet.size());\n+        assertEquals(\"keySet should be empty if HashMap is\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     empty, keySet.isEmpty());\n+        assertTrue(\"keySet should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                   keySet.containsAll(getConfirmed().keySet()));\n+        assertEquals(\"keySet hashCodes should be the same\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     getConfirmed().keySet().hashCode(), keySet.hashCode());\n+        assertEquals(\"Map's key set should still equal HashMap's\",\n+                getConfirmed().keySet(), keySet);\n+    }\n+\n+    public void verifyValues() {\n+        List<V> known = new ArrayList<V>(getConfirmed().values());\n+        List<V> test = new ArrayList<V>(values);\n+\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"values should be same size as HashMap's\" +\n+                     \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                     size, values.size());\n+        assertEquals(\"values should be empty if HashMap is\" +\n+                     \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                     empty, values.isEmpty());\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                    test.containsAll(known));\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                   known.containsAll(test));\n+        // originally coded to use a HashBag, but now separate jar so...\n+        for (Iterator<V> it = known.iterator(); it.hasNext();) {\n+            boolean removed = test.remove(it.next());\n+            assertTrue(\"Map's values should still equal HashMap's\", removed);\n+        }\n+        assertTrue(\"Map's values should still equal HashMap's\", test.isEmpty());\n+    }\n+\n+    /**\n+     * Erases any leftover instance variables by setting them to null.\n+     */\n+    @Override\n+    public void tearDown() throws Exception {\n+        map = null;\n+        keySet = null;\n+        entrySet = null;\n+        values = null;\n+        confirmed = null;\n+    }\n+\n+    /**\n+     * Get the map.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getMap() {\n+        return map;\n+    }\n+\n+    /**\n+     * Get the confirmed.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getConfirmed() {\n+        return confirmed;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractTestOrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.comparators.NullComparator;\n+import org.apache.commons.collections.iterators.AbstractTestOrderedMapIterator;\n+\n+/**\n+ * Abstract test class for {@link OrderedMap} methods and contracts.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestOrderedMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractTestOrderedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract OrderedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> makeFullMap() {\n+        return (OrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * OrderedMap uses TreeMap as its known comparison.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new NullComparator<K>());\n+    }\n+\n+    /**\n+     * The only confirmed collection we have that is ordered is the sorted one.\n+     * Thus, sort the keys.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        List<K> list = new ArrayList<K>(Arrays.asList(super.getSampleKeys()));\n+        Collections.sort(list, new NullComparator<K>());\n+        return (K[]) list.toArray();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        try {\n+            ordered.firstKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        ordered = getMap();\n+        K confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, ordered.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        try {\n+            ordered.lastKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        ordered = getMap();\n+        K confirmedLast = null;\n+        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, ordered.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNextKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        assertEquals(null, ordered.nextKey(getOtherKeys()[0]));\n+        if (!isAllowNullKey()) {\n+            try {\n+                assertEquals(null, ordered.nextKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.nextKey(null));\n+        }\n+\n+        resetFull();\n+        ordered = getMap();\n+        Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.nextKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                ordered.nextKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.nextKey(null));\n+        }\n+    }\n+\n+    public void testPreviousKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        assertEquals(null, ordered.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, ordered.previousKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.previousKey(null));\n+        }\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(confirmed.keySet());\n+        Collections.reverse(list);\n+        Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.previousKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                ordered.previousKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            if (isAllowNullKey() == false) {\n+                assertEquals(null, ordered.previousKey(null));\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestOrderedMapIterator() {\n+        return new InnerTestOrderedMapIterator();\n+    }\n+\n+    public class InnerTestOrderedMapIterator extends AbstractTestOrderedMapIterator<K, V> {\n+        public InnerTestOrderedMapIterator() {\n+            super(\"InnerTestOrderedMapIterator\");\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractTestOrderedMap.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isGetStructuralModify() {\n+            return AbstractTestOrderedMap.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractTestOrderedMap.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public OrderedMapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractTestOrderedMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public OrderedMapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractTestOrderedMap.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public OrderedMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestOrderedMap.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractTestOrderedMap.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractTestOrderedMap.this.verify();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> getMap() {\n+        return (OrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractTestSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Abstract test class for {@link java.util.SortedMap} methods and contracts.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestSortedMap<K, V> extends AbstractTestMap<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractTestSortedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Can't sort null keys.\n+     *\n+     * @return false\n+     */\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    /**\n+     * SortedMap uses TreeMap as its known comparison.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testComparator() {\n+//        SortedMap<K, V> sm = makeFullMap();\n+        // no tests I can think of\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        return (SortedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    public void testFirstKey() {\n+        SortedMap<K, V> sm = makeFullMap();\n+        assertSame(sm.keySet().iterator().next(), sm.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        SortedMap<K, V> sm = makeFullMap();\n+        K obj = null;\n+        for (Iterator<K> it = sm.keySet().iterator(); it.hasNext();) {\n+            obj = it.next();\n+        }\n+        assertSame(obj, sm.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestHeadMap() {\n+        return new TestHeadMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new TestTailMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new TestSubMap<K, V>(this);\n+    }\n+\n+    public static abstract class TestViewMap <K, V> extends AbstractTestSortedMap<K, V> {\n+        protected final AbstractTestMap<K, V> main;\n+        protected final List<K> subSortedKeys = new ArrayList<K>();\n+        protected final List<V> subSortedValues = new ArrayList<V>();\n+        protected final List<V> subSortedNewValues = new ArrayList<V>();\n+\n+        public TestViewMap(String name, AbstractTestMap<K, V> main) {\n+            super(name);\n+            this.main = main;\n+        }\n+        @Override\n+        public void resetEmpty() {\n+            // needed to init verify correctly\n+            main.resetEmpty();\n+            super.resetEmpty();\n+        }\n+        @Override\n+        public void resetFull() {\n+            // needed to init verify correctly\n+            main.resetFull();\n+            super.resetFull();\n+        }\n+        @Override\n+        public void verify() {\n+            // cross verify changes on view with changes on main map\n+            super.verify();\n+            main.verify();\n+        }\n+        @Override\n+        public BulkTest bulkTestHeadMap() {\n+            return null;  // block infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestTailMap() {\n+            return null;  // block infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSubMap() {\n+            return null;  // block infinite recursion\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public K[] getSampleKeys() {\n+            return (K[]) subSortedKeys.toArray();\n+        }\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getSampleValues() {\n+            return (V[]) subSortedValues.toArray();\n+        }\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getNewSampleValues() {\n+            return (V[]) subSortedNewValues.toArray();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+        @Override\n+        public boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+        @Override\n+        public boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+//        public void testSimpleSerialization() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testSimpleSerialization();\n+//        }\n+//        public void testSerializeDeserializeThenCompare() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testSerializeDeserializeThenCompare();\n+//        }\n+//        public void testEmptyMapCompatibility() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testEmptyMapCompatibility();\n+//        }\n+//        public void testFullMapCompatibility() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testFullMapCompatibility();\n+//        }\n+    }\n+\n+    public static class TestHeadMap<K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 6;\n+        final K toKey;\n+\n+        public TestHeadMap(AbstractTestMap<K, V> main) {\n+            super(\"SortedMap.HeadMap\", main);\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.toKey = this.subSortedKeys.get(SUBSIZE);\n+            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n+            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n+        }\n+        public void testHeadMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                getMap().put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".HeadMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.HeadMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj\");\n+//        }\n+    }\n+\n+    public static class TestTailMap <K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 6;\n+        final K fromKey;\n+        final K invalidKey;\n+\n+        public TestTailMap(AbstractTestMap<K, V> main) {\n+            super(\"SortedMap.TailMap\", main);\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n+            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n+            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n+        }\n+        public void testTailMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                getMap().put(invalidKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".TailMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.TailMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj\");\n+//        }\n+    }\n+\n+    public static class TestSubMap<K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 3;\n+        final K fromKey;\n+        final K toKey;\n+\n+        public TestSubMap(AbstractTestMap<K, V> main) {\n+            super(\"SortedMap.SubMap\", main);\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n+            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+\n+            this.subSortedKeys.subList(0, SUBSIZE).clear();\n+            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n+\n+            this.subSortedValues.subList(0, SUBSIZE).clear();\n+            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n+\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n+                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n+        }\n+        public void testSubMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                getMap().put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".SubMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.SubMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj\");\n+//        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getMap() {\n+        return (SortedMap<K, V>) super.getMap();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getConfirmed() {\n+        return (SortedMap<K, V>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/EmptyMapMutator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+import java.util.Collection;\n+\n+/**\n+ * This class is used in TestCompositeMap. When testing serialization, \n+ * the class has to be separate of TestCompositeMap, else the test \n+ * class also has to be serialized. \n+ */\n+class EmptyMapMutator<K,V> implements CompositeMap.MapMutator<K,V> {\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2729718980002476794L;\n+\n+    public void resolveCollision(CompositeMap<K,V> composite,\n+    Map<K,V> existing,\n+    Map<K,V> added,\n+    Collection<K> intersect) {\n+        // Do nothing\n+    }\n+    \n+    public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, V value) {\n+        return composited[0].put(key, value);\n+    }\n+    \n+    public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+        composited[0].putAll(t);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestCaseInsensitiveMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Tests for the {@link CaseInsensitiveMap} implementation.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Commons-Collections team\n+ */\n+public class TestCaseInsensitiveMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public TestCaseInsensitiveMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestCaseInsensitiveMap.class);\n+    }\n+\n+    @Override\n+    public CaseInsensitiveMap<K, V> makeObject() {\n+        return new CaseInsensitiveMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCaseInsensitive() {\n+        Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        assertEquals(\"One\", map.get(\"one\"));\n+        assertEquals(\"One\", map.get(\"oNe\"));\n+        map.put((K) \"two\", (V) \"Three\");\n+        assertEquals(\"Three\", map.get(\"Two\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        map.put(null, (V) \"Three\");\n+        assertEquals(\"Three\", map.get(null));\n+        map.put(null, (V) \"Four\");\n+        assertEquals(\"Four\", map.get(null));\n+        Set<K> keys = map.keySet();\n+        assertTrue(keys.contains(\"one\"));\n+        assertTrue(keys.contains(\"two\"));\n+        assertTrue(keys.contains(null));\n+        assertEquals(3, keys.size());\n+    }\n+\n+    public void testPutAll() {\n+        Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(\"One\", \"One\");\n+        map.put(\"Two\", \"Two\");\n+        map.put(\"one\", \"Three\");\n+        map.put(null, \"Four\");\n+        map.put(new Integer(20), \"Five\");\n+        Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<Object, String>(map);\n+        assertEquals(4, caseInsensitiveMap.size()); // ones collapsed\n+        Set<Object> keys = caseInsensitiveMap.keySet();\n+        assertTrue(keys.contains(\"one\"));\n+        assertTrue(keys.contains(\"two\"));\n+        assertTrue(keys.contains(null));\n+        assertTrue(keys.contains(Integer.toString(20)));\n+        assertEquals(4, keys.size());\n+        assertTrue(!caseInsensitiveMap.containsValue(\"One\")\n+            || !caseInsensitiveMap.containsValue(\"Three\")); // ones collaped\n+        assertEquals(\"Four\", caseInsensitiveMap.get(null));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        CaseInsensitiveMap<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    /*\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) map, \"/home/phil/jakarta-commons/collections/data/test/CaseInsensitiveMap.emptyCollection.version3.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) map, \"/home/phil/jakarta-commons/collections/data/test/CaseInsensitiveMap.fullCollection.version3.obj\");\n+    }\n+     */\n+\n+    // COLLECTIONS-294\n+    public void testLocaleIndependence() {\n+        Locale orig = Locale.getDefault();\n+\n+        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\", \"\", \"\"), Locale.getDefault() };\n+\n+        String[][] data = { \n+            { \"i\", \"I\" },\n+            { \"\\u03C2\", \"\\u03C3\" },\n+            { \"\\u03A3\", \"\\u03C2\" },\n+            { \"\\u03A3\", \"\\u03C3\" },\n+        };\n+\n+        try {\n+            for (int i = 0; i < locales.length; i++) {\n+                Locale.setDefault(locales[i]);\n+                for (int j = 0; j < data.length; j++) {\n+                    assertTrue(\"Test data corrupt: \" + j, data[j][0].equalsIgnoreCase(data[j][1]));\n+                    CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<String, String>();\n+                    map.put(data[j][0], \"value\");\n+                    assertEquals(Locale.getDefault() + \": \" + j, \"value\", map.get(data[j][1]));\n+                }\n+            }\n+        } finally {\n+            Locale.setDefault(orig);\n+        }\n+    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final CaseInsensitiveMap<String,String> map = new CaseInsensitiveMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestCompositeMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.Assert;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Collection;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the \n+ * {@link CompositeMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Brian McCallister\n+ */\n+public class TestCompositeMap<K, V> extends AbstractTestIterableMap<K, V> {\n+    /** used as a flag in MapMutator tests */\n+    private boolean pass = false;\n+    \n+    public TestCompositeMap(String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        this.pass = false;\n+    }\n+    \n+    @Override\n+    public CompositeMap<K, V> makeObject() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>();\n+        map.addComposited(new HashMap<K, V>());\n+        map.setMutator( new EmptyMapMutator<K, V>() );\n+        return map;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    private Map<K, V> buildOne() {\n+        HashMap<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"1\", (V) \"one\");\n+        map.put((K) \"2\", (V) \"two\");\n+        return map;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> buildTwo() {\n+        HashMap<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"3\", (V) \"three\");\n+        map.put((K) \"4\", (V) \"four\");\n+        return map;\n+    }\n+    \n+    public void testGet() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        Assert.assertEquals(\"one\", map.get(\"1\"));\n+        Assert.assertEquals(\"four\", map.get(\"4\"));\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddComposited() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        try {\n+            map.addComposited(three);\n+            fail(\"Expecting IllegalArgumentException.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(three);\n+        assertFalse(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(buildOne());\n+        assertFalse(map.containsKey(\"2\"));\n+        \n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFromUnderlying() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        three.remove(\"5\");\n+        assertFalse(map.containsKey(\"5\"));\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFromComposited() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        map.remove(\"5\");\n+        assertFalse(three.containsKey(\"5\"));\n+    }\n+    \n+    public void testResolveCollision() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+\n+            public void resolveCollision(CompositeMap<K, V> composite,\n+            Map<K, V> existing,\n+            Map<K, V> added,\n+            Collection<K> intersect) {\n+                pass = true;\n+            }\n+            \n+            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n+                V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.addComposited(buildOne());\n+        assertTrue(pass);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+            public void resolveCollision(CompositeMap<K, V> composite,\n+            Map<K, V> existing,\n+            Map<K, V> added,\n+            Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n+                V value) {\n+                pass = true;\n+                return (V) \"foo\";\n+            }\n+            \n+            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.put((K) \"willy\", (V) \"wonka\");\n+        assertTrue(pass);\n+    }\n+    \n+    public void testPutAll() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+            public void resolveCollision(CompositeMap<K, V> composite,\n+            Map<K, V> existing,\n+            Map<K, V> added,\n+            Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n+                V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+                pass = true;\n+            }\n+        });\n+        \n+        map.putAll(null);\n+        assertTrue(pass);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/CompositeMap.emptyCollection.version3.3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/CompositeMap.fullCollection.version3.3.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestDefaultedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FactoryUtils;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.functors.ConstantFactory;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the \n+ * {@link DefaultedMap} implementation.\n+ *\n+ * @since Commons Collections 3.2\n+ * @version $Revision: 155406 $ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestDefaultedMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();\n+\n+    public TestDefaultedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return DefaultedMap.defaultedMap(new HashMap<K, V>(), nullFactory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet() {\n+        Map<K, V> map = new DefaultedMap<K, V>((V) \"NULL\");\n+\n+        assertEquals(0, map.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet2() {\n+        HashMap<K, V> base = new HashMap<K, V>();\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, (V) \"NULL\");\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet3() {\n+        HashMap<K, V> base = new HashMap<K, V>();\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) \"NULL\"));\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet4() {\n+        HashMap<K, V> base = new HashMap<K, V>();\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, new Transformer<K, V>() {\n+            public V transform(K input) {\n+                if (input instanceof String) {\n+                    return (V) \"NULL\";\n+                }\n+                return (V) \"NULL_OBJECT\";\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+        assertEquals(\"NULL_OBJECT\", map.get(new Integer(0)));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+        assertEquals(\"NULL_OBJECT\", map.get(new Integer(0)));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"c:/commons/collections/data/test/DefaultedMap.emptyCollection.version3.2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"c:/commons/collections/data/test/DefaultedMap.fullCollection.version3.2.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestFixedSizeMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the {@link FixedSizeMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestFixedSizeMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public TestFixedSizeMap(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return FixedSizeMap.fixedSizeMap(new HashMap<K, V>());\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        Map<K, V> map = new HashMap<K, V>();\n+        addSampleMappings(map);\n+        return FixedSizeMap.fixedSizeMap(map);\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestFixedSizeSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedMap} for exercising the {@link FixedSizeSortedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestFixedSizeSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+\n+    public TestFixedSizeSortedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestFixedSizeSortedMap.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return FixedSizeSortedMap.fixedSizeSortedMap(new TreeMap<K, V>());\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        SortedMap<K, V> map = new TreeMap<K, V>();\n+        addSampleMappings(map);\n+        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestFlat3Map.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestFlat3Map<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final Integer THREE = new Integer(3);\n+    private static final String TEN = \"10\";\n+    private static final String TWENTY = \"20\";\n+    private static final String THIRTY = \"30\";\n+\n+    public TestFlat3Map(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestFlat3Map.class);\n+    }\n+\n+    @Override\n+    public Flat3Map<K, V> makeObject() {\n+        return new Flat3Map<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals1() {\n+        Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"b\", (V) \"testA\");\n+        assertEquals(false, map1.equals(map2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals2() {\n+        Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"c\", (V) \"testA\");\n+        assertEquals(false, map1.equals(map2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone2() {\n+        Flat3Map<K, V> map = makeObject();\n+        assertEquals(0, map.size());\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertSame(TEN, map.get(ONE));\n+        assertSame(TWENTY, map.get(TWO));\n+\n+        // clone works (size = 2)\n+        Flat3Map<K, V> cloned = map.clone();\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+\n+        // change original doesn't change clone\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+        assertEquals(4, map.size());\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone4() {\n+        Flat3Map<K, V> map = makeObject();\n+        assertEquals(0, map.size());\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n+        // clone works (size = 4)\n+        Flat3Map<K, V> cloned = map.clone();\n+        assertEquals(4, map.size());\n+        assertEquals(4, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertEquals(true, cloned.containsKey(TEN));\n+        assertEquals(true, cloned.containsKey(TWENTY));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+        assertSame(ONE, cloned.get(TEN));\n+        assertSame(TWO, cloned.get(TWENTY));\n+\n+        // change original doesn't change clone\n+        map.clear();\n+        assertEquals(0, map.size());\n+        assertEquals(4, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertEquals(true, cloned.containsKey(TEN));\n+        assertEquals(true, cloned.containsKey(TWENTY));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+        assertSame(ONE, cloned.get(TEN));\n+        assertSame(TWO, cloned.get(TWENTY));\n+    }\n+\n+    public void testSerialisation0() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        byte[] bytes = bout.toByteArray();\n+        out.close();\n+        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        ObjectInputStream in = new ObjectInputStream(bin);\n+        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(0, map.size());\n+        assertEquals(0, ser.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialisation2() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        byte[] bytes = bout.toByteArray();\n+        out.close();\n+        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        ObjectInputStream in = new ObjectInputStream(bin);\n+        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(2, map.size());\n+        assertEquals(2, ser.size());\n+        assertEquals(true, ser.containsKey(ONE));\n+        assertEquals(true, ser.containsKey(TWO));\n+        assertEquals(TEN, ser.get(ONE));\n+        assertEquals(TWENTY, ser.get(TWO));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialisation4() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        byte[] bytes = bout.toByteArray();\n+        out.close();\n+        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        ObjectInputStream in = new ObjectInputStream(bin);\n+        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(4, map.size());\n+        assertEquals(4, ser.size());\n+        assertEquals(true, ser.containsKey(ONE));\n+        assertEquals(true, ser.containsKey(TWO));\n+        assertEquals(true, ser.containsKey(TEN));\n+        assertEquals(true, ser.containsKey(TWENTY));\n+        assertEquals(TEN, ser.get(ONE));\n+        assertEquals(TWENTY, ser.get(TWO));\n+        assertEquals(ONE, ser.get(TEN));\n+        assertEquals(TWO, ser.get(TWENTY));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue1() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(\"NewValue\", map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue2() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(\"NewValue\", map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue3() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        it.next();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(\"NewValue\", map.get(THREE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue1() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(\"NewValue\", map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue2() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(\"NewValue\", map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue3() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(\"NewValue\", map.get(THREE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public BulkTest bulkTestMapIterator() {\n+        return new TestFlatMapIterator();\n+    }\n+\n+    public class TestFlatMapIterator extends AbstractTestMapIterator<K, V> {\n+        public TestFlatMapIterator() {\n+            super(\"TestFlatMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return TestFlat3Map.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return TestFlat3Map.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return TestFlat3Map.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return TestFlat3Map.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return TestFlat3Map.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public IterableMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return TestFlat3Map.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return TestFlat3Map.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            TestFlat3Map.this.verify();\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/Flat3Map.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/Flat3Map.fullCollection.version3.1.obj\");\n+//    }\n+\n+    public void testCollections261() {\n+        Flat3Map<Integer, Integer> m = new Flat3Map<Integer, Integer>();\n+        m.put( new Integer(1), new Integer(1) );\n+        m.put( new Integer(0), new Integer(0) );\n+        assertEquals( new Integer(1), m.remove( new Integer(1) ) ); \n+        assertEquals( new Integer(0), m.remove( new Integer(0) ) ); \n+\n+        m.put( new Integer(2), new Integer(2) );\n+        m.put( new Integer(1), new Integer(1) );\n+        m.put( new Integer(0), new Integer(0) );\n+        assertEquals( new Integer(2), m.remove( new Integer(2) ) ); \n+        assertEquals( new Integer(1), m.remove( new Integer(1) ) ); \n+        assertEquals( new Integer(0), m.remove( new Integer(0) ) ); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestHashedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestHashedMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public TestHashedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestHashedMap.class);\n+    }\n+\n+    @Override\n+    public HashedMap<K, V> makeObject() {\n+        return new HashedMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        HashedMap<K, V> map = new HashedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        HashedMap<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    public void testInternalState() {\n+        HashedMap<K, V> map = new HashedMap<K, V>(42, 0.75f);\n+        assertEquals(0.75f, map.loadFactor, 0.1f);\n+        assertEquals(0, map.size);\n+        assertEquals(64, map.data.length);\n+        assertEquals(48, map.threshold);\n+        assertEquals(0, map.modCount);\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final HashedMap<String,String> map = new HashedMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestIdentityMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.IterableMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestIdentityMap<K, V> extends AbstractTestObject {\n+\n+    private static final Integer I1A = new Integer(1);\n+    private static final Integer I1B = new Integer(1);\n+    private static final Integer I2A = new Integer(2);\n+    private static final Integer I2B = new Integer(2);\n+\n+    public TestIdentityMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestIdentityMap.class);\n+//        return BulkTest.makeSuite(TestIdentityMap.class);  // causes race condition!\n+    }\n+\n+    @Override\n+    public IdentityMap<K, V> makeObject() {\n+        return new IdentityMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasics() {\n+        IterableMap<K, V> map = new IdentityMap<K, V>();\n+        assertEquals(0, map.size());\n+\n+        map.put((K) I1A, (V) I2A);\n+        assertEquals(1, map.size());\n+        assertSame(I2A, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(true, map.containsValue(I2A));\n+        assertEquals(false, map.containsValue(I2B));\n+\n+        map.put((K) I1A, (V) I2B);\n+        assertEquals(1, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+\n+        map.put((K) I1B, (V) I2B);\n+        assertEquals(2, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(I2B, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(true, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHashEntry() {\n+        IterableMap<K, V> map = new IdentityMap<K, V>();\n+\n+        map.put((K) I1A, (V) I2A);\n+        map.put((K) I1B, (V) I2A);\n+\n+        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry2 = it.next();\n+        Map.Entry<K, V> entry3 = it.next();\n+\n+        assertEquals(true, entry1.equals(entry2));\n+        assertEquals(true, entry2.equals(entry1));\n+        assertEquals(false, entry1.equals(entry3));\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testEmptyMapCompatibility() throws IOException, ClassNotFoundException {\n+        // test to make sure the canonical form has been preserved\n+        Map<K, V> map = makeObject();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+            assertEquals(\"Map is empty\", 0, map2.size());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        IdentityMap<K, V> map = new IdentityMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Map map = new IdentityMap();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/IdentityMap.emptyCollection.version3.obj\");\n+//        map = new IdentityMap();\n+//        map.put(I1A, I2A);\n+//        map.put(I1B, I2A);\n+//        map.put(I2A, I2B);\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/IdentityMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final IdentityMap<String,String> map = new IdentityMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestLRUMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestLRUMap<K, V> extends AbstractTestOrderedMap<K, V> {\n+\n+    public TestLRUMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestLRUMap.class);\n+    }\n+\n+    @Override\n+    public LRUMap<K, V> makeObject() {\n+        return new LRUMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> makeFullMap() {\n+        return (LRUMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public boolean isGetStructuralModify() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLRU() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> kit;\n+        Iterator<V> vit;\n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(2);\n+        assertEquals(0, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+\n+        map.put(keys[0], values[0]);\n+        assertEquals(1, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+\n+        map.put(keys[1], values[1]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        map.put(keys[2], values[2]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        map.put(keys[2], values[0]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[0], vit.next());\n+\n+        map.put(keys[1], values[3]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[2], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(ordered.keySet());\n+        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAccessOrder() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> kit = null;\n+        Iterator<V> vit = null;\n+\n+        resetEmpty();\n+        map.put(keys[0], values[0]);\n+        map.put(keys[1], values[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[2]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        // change to order\n+        map.put(keys[0], values[3]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+\n+        // change to order\n+        map.get(keys[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[3], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        // change to order\n+        map.get(keys[0]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+\n+        // no change to order\n+        map.get(keys[0]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        LRUMap<K, V> map = new LRUMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRU() {\n+        MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<K, String>(2);\n+        assertNull(map.entry);\n+        map.put((K) \"A\", \"a\");\n+        assertNull(map.entry);\n+        map.put((K) \"B\", \"b\");\n+        assertNull(map.entry);\n+        map.put((K) \"C\", \"c\");  // removes oldest, which is A=a\n+        assertNotNull(map.entry);\n+        assertEquals(\"A\", map.key);\n+        assertEquals(\"a\", map.value);\n+        assertEquals(\"C\", map.entry.getKey());  // entry is reused\n+        assertEquals(\"c\", map.entry.getValue());  // entry is reused\n+        assertEquals(false, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {\n+        LinkEntry<K, V> entry;\n+        K key;\n+        V value;\n+\n+        MockLRUMapSubclass(int size) {\n+            super(size);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+            this.entry = entry;\n+            this.key = entry.getKey();\n+            this.value = entry.getValue();\n+            return true;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUBlocksRemove() {\n+        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, false);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        assertEquals(3, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUBlocksRemoveScan() {\n+        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, true);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        assertEquals(3, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {\n+        MockLRUMapSubclassBlocksRemove(int size, boolean scanUntilRemove) {\n+            super(size, scanUntilRemove);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUFirstBlocksRemove() {\n+        MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<K, V>(2);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b\n+        assertEquals(2, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(false, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {\n+        MockLRUMapSubclassFirstBlocksRemove(int size) {\n+            super(size, true);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+            if (\"a\".equals(entry.getValue())) {\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class SingleHashCode {\n+        private final String code;\n+        SingleHashCode(String code) {\n+            this.code = code;\n+        }\n+        @Override\n+        public int hashCode() {\n+            // always return the same hashcode\n+            // that way, it will end up in the same bucket\n+            return 12;\n+        }\n+        @Override\n+        public String toString() {\n+            return \"SingleHashCode:\" + code;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_Buckets() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        SingleHashCode one = new SingleHashCode(\"1\");\n+        SingleHashCode two = new SingleHashCode(\"2\");\n+        SingleHashCode three = new SingleHashCode(\"3\");\n+        SingleHashCode four = new SingleHashCode(\"4\");\n+        SingleHashCode five = new SingleHashCode(\"5\");\n+        SingleHashCode six = new SingleHashCode(\"6\");\n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        int hashIndex = map.hashIndex(map.hash(one), 4);\n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(one, map.header.after.key);  // LRU\n+        assertEquals(two, map.header.after.after.key);\n+        assertEquals(three, map.header.after.after.after.key);  // MRU\n+        assertEquals(three, map.data[hashIndex].key);\n+        assertEquals(two, map.data[hashIndex].next.key);\n+        assertEquals(one, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) four, (V) \"D\");  // reuses last in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(two, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(four, map.header.after.after.after.key);  // MRU\n+        assertEquals(four, map.data[hashIndex].key);\n+        assertEquals(three, map.data[hashIndex].next.key);\n+        assertEquals(two, map.data[hashIndex].next.next.key);\n+\n+        map.get(three);\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(two, map.header.after.key);  // LRU\n+        assertEquals(four, map.header.after.after.key);\n+        assertEquals(three, map.header.after.after.after.key);  // MRU\n+        assertEquals(four, map.data[hashIndex].key);\n+        assertEquals(three, map.data[hashIndex].next.key);\n+        assertEquals(two, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) five, (V) \"E\");  // reuses last in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(four, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(five, map.header.after.after.after.key);  // MRU\n+        assertEquals(five, map.data[hashIndex].key);\n+        assertEquals(four, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+\n+        map.get(three);\n+        map.get(five);\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(four, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(five, map.header.after.after.after.key);  // MRU\n+        assertEquals(five, map.data[hashIndex].key);\n+        assertEquals(four, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) six, (V) \"F\");  // reuses middle in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(three, map.header.after.key);  // LRU\n+        assertEquals(five, map.header.after.after.key);\n+        assertEquals(six, map.header.after.after.after.key);  // MRU\n+        assertEquals(six, map.data[hashIndex].key);\n+        assertEquals(five, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_getEntry_int() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        SingleHashCode one = new SingleHashCode(\"1\");\n+        SingleHashCode two = new SingleHashCode(\"2\");\n+        SingleHashCode three = new SingleHashCode(\"3\");\n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n+        assertEquals(one, map.getEntry(0).key);\n+        assertEquals(two, map.getEntry(1).key);\n+        assertEquals(three, map.getEntry(2).key);\n+        try {\n+            map.getEntry(-1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            map.getEntry(3);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+    \n+    public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {\n+\n+        final LRUMap<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {\n+                            \titer.next();\n+                            \tif (iter.getValue() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator<Map.Entry<Object, Thread>> iter = map.entrySet().iterator(); iter.hasNext();) {\n+                                Map.Entry<Object, Thread> entry = iter.next();\n+                                if (entry.getValue() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromKeySet() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {\n+\t\t\t\t\t\t\t\tString name = (String) iter.next();\n+\t\t\t\t\t\t\t\tif (name.substring(0, name.indexOf('[')).equals(getName())) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromValues() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator<Thread> iter = map.values().iterator(); iter.hasNext();) {\n+                                if (iter.next() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> getMap() {\n+        return (LRUMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestLazyMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import static org.apache.commons.collections.map.LazyMap.lazyMap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FactoryUtils;\n+import org.apache.commons.collections.Transformer;\n+import org.junit.Test;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the \n+ * {@link LazyMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestLazyMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n+\n+    public TestLazyMap(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public LazyMap<K,V> makeObject() {\n+        return lazyMap(new HashMap<K,V>(), FactoryUtils.<V>nullFactory());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testMapGet() {\n+        //TODO eliminate need for this via superclass - see svn history.\n+    }\n+\n+    @Test\n+    public void mapGetWithFactory() {\n+        Map<Integer, Number> map = lazyMap(new HashMap<Integer,Number>(), oneFactory);\n+        assertEquals(0, map.size());\n+        Number i1 = map.get(\"Five\");\n+        assertEquals(1, i1);\n+        assertEquals(1, map.size());\n+        Number i2 = map.get(new String(new char[] {'F','i','v','e'}));\n+        assertEquals(1, i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+\n+        map = lazyMap(new HashMap<Integer,Number>(), FactoryUtils.<Long>nullFactory());\n+        Object o = map.get(\"Five\");\n+        assertEquals(null,o);\n+        assertEquals(1, map.size());\n+    }\n+\n+    @Test\n+    public void mapGetWithTransformer() {\n+        Transformer<Number, Integer> intConverter = new Transformer<Number, Integer>(){\n+            public Integer transform(Number input) {\n+                return input.intValue();\n+            }\n+        };\n+        Map<Long, Number> map = lazyMap(new HashMap<Long,Number>(), intConverter );\n+        assertEquals(0, map.size());\n+        Number i1 = map.get(123L);\n+        assertEquals(123, i1);\n+        assertEquals(1, map.size());\n+    }\n+\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazyMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazyMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestLazySortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import static org.apache.commons.collections.map.LazySortedMap.lazySortedMap;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FactoryUtils;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+import org.junit.Test;\n+\n+/**\n+ * Extension of {@link TestLazyMap} for exercising the \n+ * {@link LazySortedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestLazySortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+    \n+    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n+   \n+    public TestLazySortedMap(String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    public SortedMap<K,V> makeObject() {\n+        return lazySortedMap(new TreeMap<K,V>(), FactoryUtils.<V>nullFactory());\n+    }\n+    \n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TODO TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    // from TestLazyMap\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testMapGet() {\n+        //TODO eliminate need for this via superclass - see svn history.\n+    }\n+    \n+    @Test\n+    public void mapGet() {\n+        Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer,Number>(), oneFactory);\n+        assertEquals(0, map.size());\n+        Number i1 = map.get(5);\n+        assertEquals(1, i1);\n+        assertEquals(1, map.size());\n+\n+        map = lazySortedMap(new TreeMap<Integer,Number>(), FactoryUtils.<Number>nullFactory());\n+        Number o = map.get(5);\n+        assertEquals(null,o);\n+        assertEquals(1, map.size());\n+        \n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSortOrder() {\n+        SortedMap<String, Number> map = lazySortedMap(new TreeMap<String,Number>(), oneFactory);\n+        map.put(\"A\",  5);\n+        map.get(\"B\"); // Entry with value \"One\" created\n+        map.put(\"C\", 8);\n+        assertEquals(\"First key should be A\", \"A\", map.firstKey());\n+        assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n+        assertEquals(\"First key in tail map should be B\", \n+            \"B\", map.tailMap(\"B\").firstKey());\n+        assertEquals(\"Last key in head map should be B\", \n+            \"B\", map.headMap(\"C\").lastKey());\n+        assertEquals(\"Last key in submap should be B\",\n+            \"B\", map.subMap(\"A\",\"C\").lastKey());\n+        \n+        Comparator<?> c = map.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", \n+            c == null);      \n+    } \n+    \n+    public void testTransformerDecorate() {\n+        Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n+        SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);     \n+        assertTrue(map instanceof LazySortedMap);  \n+         try {\n+            map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n+            fail(\"Expecting IllegalArgumentException for null transformer\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = lazySortedMap((SortedMap<Integer,Number>) null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        } \n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazySortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazySortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestLinkedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.list.AbstractTestList;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestLinkedMap<K, V> extends AbstractTestOrderedMap<K, V> {\n+\n+    public TestLinkedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestLinkedMap.class);\n+    }\n+\n+    @Override\n+    public LinkedMap<K, V> makeObject() {\n+        return new LinkedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> makeFullMap() {\n+        return (LinkedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(ordered.keySet());\n+        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInsertionOrder() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> keyIter;\n+        Iterator<V> valueIter;\n+\n+        resetEmpty();\n+        map.put(keys[0], values[0]);\n+        map.put(keys[1], values[1]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[1]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[2]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[0], values[3]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[3], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lm.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lm.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        assertEquals(-1, lm.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lm = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lm.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lm.get(key);\n+            assertEquals(value, lm.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lm.containsKey(key));\n+        }\n+    }\n+\n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+\n+    public class TestListView extends AbstractTestList<K> {\n+\n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return TestLinkedMap.this.makeObject().asList();\n+        }\n+\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return TestLinkedMap.this.makeFullMap().asList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return TestLinkedMap.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return TestLinkedMap.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        LinkedMap<K, V> map = new LinkedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> getMap() {\n+        return (LinkedMap<K, V>) super.getMap();\n+    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final LinkedMap<String,String> map = new LinkedMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestListOrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.list.AbstractTestList;\n+\n+/**\n+ * Extension of {@link AbstractTestOrderedMap} for exercising the {@link ListOrderedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class TestListOrderedMap<K, V> extends AbstractTestOrderedMap<K, V> {\n+\n+    public TestListOrderedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestListOrderedMap.class);\n+    }\n+\n+    @Override\n+    public ListOrderedMap<K, V> makeObject() {\n+        return (ListOrderedMap<K, V>) ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lom.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lom.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        assertEquals(-1, lom.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lom = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lom.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.setValue(0, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(lom.size(), (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        for (int i = 0; i < lom.size(); i++) {\n+            V value = lom.getValue(i);\n+            Object input = new Integer(i);\n+            assertEquals(value, lom.setValue(i, (V) input));\n+            assertEquals(input, lom.getValue(i));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lom.get(key);\n+            assertEquals(value, lom.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lom.containsKey(key));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut_intObjectObject() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+\n+        try {\n+            lom.put(1, (K) \"testInsert1\", (V) \"testInsert1v\");\n+            fail(\"should not be able to insert at pos 1 in empty Map\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.put(-1, (K) \"testInsert-1\", (V) \"testInsert-1v\");\n+            fail(\"should not be able to insert at pos -1 in empty Map\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        // put where key doesn't exist\n+        lom.put(0, (K) \"testInsert1\", (V) \"testInsert1v\");\n+        assertEquals(\"testInsert1v\", lom.getValue(0));\n+\n+        lom.put((K) \"testInsertPut\", (V) \"testInsertPutv\");\n+        assertEquals(\"testInsert1v\", lom.getValue(0));\n+        assertEquals(\"testInsertPutv\", lom.getValue(1));\n+\n+        lom.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsertPutv\", lom.getValue(2));\n+\n+        lom.put(3, (K) \"testInsert3\", (V) \"testInsert3v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsertPutv\", lom.getValue(2));\n+        assertEquals(\"testInsert3v\", lom.getValue(3));\n+\n+        // put in a full map\n+        resetFull();\n+        lom = getMap();\n+        ListOrderedMap<K, V> lom2 = new ListOrderedMap<K, V>();\n+        lom2.putAll(lom);\n+\n+        lom2.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n+        assertEquals(\"testInsert0v\", lom2.getValue(0));\n+        for (int i = 0; i < lom.size(); i++) {\n+            assertEquals(lom2.getValue(i + 1), lom.getValue(i));\n+        }\n+\n+        // put where key does exist\n+        Integer i1 = new Integer(1);\n+        Integer i1b = new Integer(1);\n+        Integer i2 = new Integer(2);\n+        Integer i3 = new Integer(3);\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertSame(i1, lom.get(0));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertEquals(\"2\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+        assertSame(i1b, lom.get(0));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(1, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertEquals(\"2\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(2, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"2\", lom.getValue(0));\n+        assertEquals(\"One\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(3, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"2\", lom.getValue(0));\n+        assertEquals(\"3\", lom.getValue(1));\n+        assertEquals(\"One\", lom.getValue(2));\n+    }\n+\n+    public void testPutAllWithIndex() {\n+        resetEmpty();\n+        ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;\n+\n+        // Create Initial Data\n+        lom.put(\"testInsert0\", \"testInsert0v\");\n+        lom.put(\"testInsert1\", \"testInsert1v\");\n+        lom.put(\"testInsert2\", \"testInsert2v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsert2v\", lom.getValue(2));\n+\n+        // Create New Test Map and Add using putAll(int, Object, Object)\n+        Map<String, String> values = new ListOrderedMap<String, String>();\n+        values.put(\"NewInsert0\", \"NewInsert0v\");\n+        values.put(\"NewInsert1\", \"NewInsert1v\");\n+        lom.putAll(1, values);\n+\n+        // Perform Asserts\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"NewInsert0v\", lom.getValue(1));\n+        assertEquals(\"NewInsert1v\", lom.getValue(2));\n+        assertEquals(\"testInsert1v\", lom.getValue(3));\n+        assertEquals(\"testInsert2v\", lom.getValue(4));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testValueList_getByIndex() {\n+        resetFull();\n+        ListOrderedMap<K, V> lom = getMap();\n+        for (int i = 0; i < lom.size(); i++) {\n+            V expected = lom.getValue(i);\n+            assertEquals(expected, lom.valueList().get(i));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueList_setByIndex() {\n+        resetFull();\n+        ListOrderedMap<K, V> lom = getMap();\n+        for (int i = 0; i < lom.size(); i++) {\n+            Object input = new Integer(i);\n+            V expected = lom.getValue(i);\n+            assertEquals(expected, lom.valueList().set(i, (V) input));\n+            assertEquals(input, lom.getValue(i));\n+            assertEquals(input, lom.valueList().get(i));\n+        }\n+    }\n+\n+    public void testValueList_removeByIndex() {\n+        resetFull();\n+        ListOrderedMap<K, V> lom = getMap();\n+        while (lom.size() > 1) {\n+            V expected = lom.getValue(1);\n+            assertEquals(expected, lom.valueList().remove(1));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestKeyListView() {\n+        return new TestKeyListView();\n+    }\n+\n+    public BulkTest bulkTestValueListView() {\n+        return new TestValueListView();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public class TestKeyListView extends AbstractTestList<K> {\n+        TestKeyListView() {\n+            super(\"TestKeyListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return TestListOrderedMap.this.makeObject().keyList();\n+        }\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return TestListOrderedMap.this.makeFullMap().keyList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return TestListOrderedMap.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return TestListOrderedMap.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public class TestValueListView extends AbstractTestList<V> {\n+        TestValueListView() {\n+            super(\"TestValueListView\");\n+        }\n+\n+        @Override\n+        public List<V> makeObject() {\n+            return TestListOrderedMap.this.makeObject().valueList();\n+        }\n+        @Override\n+        public List<V> makeFullCollection() {\n+            return TestListOrderedMap.this.makeFullMap().valueList();\n+        }\n+\n+        @Override\n+        public V[] getFullElements() {\n+            return TestListOrderedMap.this.getSampleValues();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return true;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return true;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return TestListOrderedMap.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestListOrderedMap2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.list.AbstractTestList;\n+\n+/**\n+ * Extension of {@link AbstractTestOrderedMap} for exercising the {@link ListOrderedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestListOrderedMap2<K, V> extends AbstractTestOrderedMap<K, V> {\n+\n+    public TestListOrderedMap2(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestListOrderedMap2.class);\n+    }\n+\n+    @Override\n+    public ListOrderedMap<K, V> makeObject() {\n+        return new ListOrderedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lom.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lom.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        assertEquals(-1, lom.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lom = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lom.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lom.get(key);\n+            assertEquals(value, lom.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lom.containsKey(key));\n+        }\n+    }\n+\n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+\n+    public class TestListView extends AbstractTestList<K> {\n+\n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return TestListOrderedMap2.this.makeObject().asList();\n+        }\n+\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return TestListOrderedMap2.this.makeFullMap().asList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return TestListOrderedMap2.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return TestListOrderedMap2.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestMultiKeyMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.keyvalue.MultiKey;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestMultiKeyMap<K, V> extends AbstractTestIterableMap<MultiKey<? extends K>, V> {\n+\n+    static final Integer I1 = new Integer(1);\n+    static final Integer I2 = new Integer(2);\n+    static final Integer I3 = new Integer(3);\n+    static final Integer I4 = new Integer(4);\n+    static final Integer I5 = new Integer(5);\n+    static final Integer I6 = new Integer(6);\n+    static final Integer I7 = new Integer(7);\n+    static final Integer I8 = new Integer(8);\n+\n+    public TestMultiKeyMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestMultiKeyMap.class);\n+    }\n+\n+    @Override\n+    public MultiKeyMap<K, V> makeObject() {\n+        return new MultiKeyMap<K, V>();\n+    }\n+\n+    @Override\n+    public MultiKey<K>[] getSampleKeys() {\n+        return getMultiKeyKeys();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private MultiKey<K>[] getMultiKeyKeys() {\n+        return new MultiKey[] {\n+            new MultiKey<Integer>(I1, I2),\n+            new MultiKey<Integer>(I2, I3),\n+            new MultiKey<Integer>(I3, I4),\n+            new MultiKey<Integer>(I1, I1, I2),\n+            new MultiKey<Integer>(I2, I3, I4),\n+            new MultiKey<Integer>(I3, I7, I6),\n+            new MultiKey<Integer>(I1, I1, I2, I3),\n+            new MultiKey<Integer>(I2, I4, I5, I6),\n+            new MultiKey<Integer>(I3, I6, I7, I8),\n+            new MultiKey<Integer>(I1, I1, I2, I3, I4),\n+            new MultiKey<Integer>(I2, I3, I4, I5, I6),\n+            new MultiKey<Integer>(I3, I5, I6, I7, I8),\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] {\n+            \"2A\", \"2B\", \"2C\",\n+            \"3D\", \"3E\", \"3F\",\n+            \"4G\", \"4H\", \"4I\",\n+            \"5J\", \"5K\", \"5L\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] {\n+            \"1a\", \"1b\", \"1c\",\n+            \"2d\", \"2e\", \"2f\",\n+            \"3g\", \"3h\", \"3i\",\n+            \"4j\", \"4k\", \"4l\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey<K>[] getOtherKeys() {\n+        return new MultiKey[] {\n+            new MultiKey<Integer>(I1, I7),\n+            new MultiKey<Integer>(I1, I8),\n+            new MultiKey<Integer>(I2, I4),\n+            new MultiKey<Integer>(I2, I5),\n+        };\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, map.get(null));\n+        assertEquals(false, map.containsKey(null));\n+        assertEquals(false, map.containsValue(null));\n+        assertEquals(null, map.remove(null));\n+        assertEquals(false, map.entrySet().contains(null));\n+        assertEquals(false, map.keySet().contains(null));\n+        assertEquals(false, map.values().contains(null));\n+        try {\n+            map.put(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        assertEquals(null, map.put(new MultiKey<K>(null, null), null));\n+        try {\n+            map.put(null, (V) new Object());\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMultiKeyGet() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(null, multimap.get(null, key.getKey(1)));\n+                assertEquals(null, multimap.get(key.getKey(0), null));\n+                assertEquals(null, multimap.get(null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(null, null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(null, multimap.get(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyContainsKey() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKey<K> key = keys[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null));\n+                assertEquals(false, multimap.containsKey(null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyPut() {\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKeyMap<K, V> multimap = new MultiKeyMap<K, V>();\n+\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyRemove() {\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            resetFull();\n+            MultiKeyMap<K, V> multimap = getMap();\n+            int size = multimap.size();\n+\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll1() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1);\n+        assertEquals(8, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll2() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I2, I3);\n+        assertEquals(9, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll3() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1, I1, I2);\n+        assertEquals(9, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll4() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1, I1, I2, I3);\n+        assertEquals(10, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        MultiKeyMap<K, V> map = new MultiKeyMap<K, V>();\n+        map.put(new MultiKey<K>((K) I1, (K) I2), (V) \"1-2\");\n+        Map<MultiKey<? extends K>, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(new MultiKey<K>((K) I1, (K) I2)), cloned.get(new MultiKey<K>((K) I1, (K) I2)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLRUMultiKeyMap() {\n+        MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));\n+        map.put((K) I1, (K) I2, (V) \"1-2\");\n+        map.put((K) I1, (K) I3, (V) \"1-1\");\n+        assertEquals(2, map.size());\n+        map.put((K) I1, (K) I4, (V) \"1-4\");\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.containsKey(I1, I3));\n+        assertEquals(true, map.containsKey(I1, I4));\n+        assertEquals(false, map.containsKey(I1, I2));\n+\n+        MultiKeyMap<K, V> cloned = map.clone();\n+        assertEquals(2, map.size());\n+        assertEquals(true, cloned.containsKey(I1, I3));\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(false, cloned.containsKey(I1, I2));\n+        cloned.put((K) I1, (K) I5, (V) \"1-5\");\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(true, cloned.containsKey(I1, I5));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/MultiKeyMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/MultiKeyMap.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public MultiKeyMap<K, V> getMap() {\n+        return (MultiKeyMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestMultiValueMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.MultiMap;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+\n+/**\n+ * TestMultiValueMap.\n+ *\n+ * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n+ * @author Stephen Colebourne\n+ * @since Commons Collections 3.2\n+ */\n+public class TestMultiValueMap<K, V> extends AbstractTestObject {\n+\n+    public TestMultiValueMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testNoMappingReturnsNull() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        assertNull(map.get(\"whatever\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueCollectionType() {\n+        final MultiValueMap<K, V> map = createTestMap(LinkedList.class);\n+        assertTrue(map.get(\"one\") instanceof LinkedList);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMultipleValues() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        final HashSet<V> expected = new HashSet<V>();\n+        expected.add((V) \"uno\");\n+        expected.add((V) \"un\");\n+        assertEquals(expected, map.get(\"one\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsValue() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue(\"uno\"));\n+        assertTrue(map.containsValue(\"un\"));\n+        assertTrue(map.containsValue(\"dos\"));\n+        assertTrue(map.containsValue(\"deux\"));\n+        assertTrue(map.containsValue(\"tres\"));\n+        assertTrue(map.containsValue(\"trois\"));\n+        assertFalse(map.containsValue(\"quatro\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testKeyContainsValue() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue((K) \"one\", \"uno\"));\n+        assertTrue(map.containsValue((K) \"one\", \"un\"));\n+        assertTrue(map.containsValue((K) \"two\", \"dos\"));\n+        assertTrue(map.containsValue((K) \"two\", \"deux\"));\n+        assertTrue(map.containsValue((K) \"three\", \"tres\"));\n+        assertTrue(map.containsValue((K) \"three\", \"trois\"));\n+        assertFalse(map.containsValue((K) \"four\", \"quatro\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValues() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        final HashSet<V> expected = new HashSet<V>();\n+        expected.add((V) \"uno\");\n+        expected.add((V) \"dos\");\n+        expected.add((V) \"tres\");\n+        expected.add((V) \"un\");\n+        expected.add((V) \"deux\");\n+        expected.add((V) \"trois\");\n+        final Collection<Object> c = map.values();\n+        assertEquals(6, c.size());\n+        assertEquals(expected, new HashSet<Object>(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private MultiValueMap<K, V> createTestMap() {\n+        return createTestMap(ArrayList.class);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(Class<C> collectionClass) {\n+        final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);\n+        map.put((K) \"one\", (V) \"uno\");\n+        map.put((K) \"one\", (V) \"un\");\n+        map.put((K) \"two\", (V) \"dos\");\n+        map.put((K) \"two\", (V) \"deux\");\n+        map.put((K) \"three\", (V) \"tres\");\n+        map.put((K) \"three\", (V) \"trois\");\n+        return map;\n+    }\n+\n+    public void testKeyedIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        final ArrayList<Object> actual = new ArrayList<Object>(IteratorUtils.toList(map.iterator(\"one\")));\n+        final ArrayList<Object> expected = new ArrayList<Object>(Arrays.asList(new String[]{ \"uno\", \"un\" }));\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testRemoveAllViaIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        for (Iterator<?> i = map.values().iterator(); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    public void testRemoveAllViaKeyedIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        for (Iterator<?> i = map.iterator(\"one\"); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertEquals(4, map.totalSize());\n+    }\n+\n+    public void testTotalSizeA() {\n+        assertEquals(6, createTestMap().totalSize());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapEquals() {\n+        MultiValueMap<K, V> one = new MultiValueMap<K, V>();\n+        Integer value = new Integer(1);\n+        one.put((K) \"One\", value);\n+        one.remove(\"One\", value);\n+\n+        MultiValueMap<K, V> two = new MultiValueMap<K, V>();\n+        assertEquals(two, one);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGetCollection() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        map.put((K) \"A\", \"AA\");\n+        assertSame(map.get(\"A\"), map.getCollection(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTotalSize() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.totalSize());\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.totalSize());\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(2, map.totalSize());\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(3, map.totalSize());\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(4, map.totalSize());\n+        map.remove(\"A\");\n+        assertEquals(3, map.totalSize());\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(2, map.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(2, map.size());\n+        map.remove(\"A\");\n+        assertEquals(1, map.size());\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(1, map.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize_Key() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(0, map.size(\"B\"));\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(0, map.size(\"B\"));\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(1, map.size(\"B\"));\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(2, map.size(\"B\"));\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(3, map.size(\"B\"));\n+        map.remove(\"A\");\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(3, map.size(\"B\"));\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(2, map.size(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator_Key() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(false, map.iterator(\"A\").hasNext());\n+        map.put((K) \"A\", \"AA\");\n+        Iterator<?> it = map.iterator(\"A\");\n+        assertEquals(true, it.hasNext());\n+        it.next();\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsValue_Key() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(false, map.containsValue(\"A\", \"AA\"));\n+        assertEquals(false, map.containsValue(\"B\", \"BB\"));\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(true, map.containsValue(\"A\", \"AA\"));\n+        assertEquals(false, map.containsValue(\"A\", \"AB\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithList() {\n+        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);\n+        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n+        assertEquals(1, test.size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithSet() {\n+        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);\n+        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n+        assertEquals(null, test.put((K) \"A\", \"a\"));\n+        assertEquals(1, test.size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map1() {\n+        MultiMap<K, V> original = new MultiValueMap<K, V>();\n+        original.put((K) \"key\", \"object1\");\n+        original.put((K) \"key\", \"object2\");\n+\n+        MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        test.put((K) \"keyA\", \"objectA\");\n+        test.put((K) \"key\", \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(2, test.size());\n+        assertEquals(4, test.totalSize());\n+        assertEquals(1, test.getCollection(\"keyA\").size());\n+        assertEquals(3, test.getCollection(\"key\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map2() {\n+        Map<K, V> original = new HashMap<K, V>();\n+        original.put((K) \"keyX\", (V) \"object1\");\n+        original.put((K) \"keyY\", (V) \"object2\");\n+\n+        MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        test.put((K) \"keyA\", \"objectA\");\n+        test.put((K) \"keyX\", \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(3, test.size());\n+        assertEquals(4, test.totalSize());\n+        assertEquals(1, test.getCollection(\"keyA\").size());\n+        assertEquals(2, test.getCollection(\"keyX\").size());\n+        assertEquals(1, test.getCollection(\"keyY\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_KeyCollection() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        Collection<V> coll = (Collection<V>) Arrays.asList(new Object[] { \"X\", \"Y\", \"Z\" });\n+\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", null));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", new ArrayList<V>()));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        coll = (Collection<V>) Arrays.asList(new Object[] { \"M\" });\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(4, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+        assertEquals(true, map.containsValue(\"A\", \"M\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove_KeyItem() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        map.put((K) \"A\", \"AA\");\n+        map.put((K) \"A\", \"AB\");\n+        map.put((K) \"A\", \"AC\");\n+        assertEquals(null, map.remove(\"C\", \"CA\"));\n+        assertEquals(null, map.remove(\"A\", \"AD\"));\n+        assertEquals(\"AC\", map.remove(\"A\", \"AC\"));\n+        assertEquals(\"AB\", map.remove(\"A\", \"AB\"));\n+        assertEquals(\"AA\", map.remove(\"A\", \"AA\"));\n+        assertEquals(new MultiValueMap<K, V>(), map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Manual serialization testing as this class cannot easily \n+    // extend the AbstractTestMap\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+    @Override\n+    public Object makeObject() {\n+        Map m = makeEmptyMap();\n+        m.put(\"a\", \"1\");\n+        m.put(\"a\", \"1b\");\n+        m.put(\"b\", \"2\");\n+        m.put(\"c\", \"3\");\n+        m.put(\"c\", \"3b\");\n+        m.put(\"d\", \"4\");\n+        return m;\n+    }\n+\n+    private Map makeEmptyMap() {\n+        return new MultiValueMap();\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) makeEmptyMap(),\n+//            \"/tmp/MultiValueMap.emptyCollection.version3.3.obj\");\n+//\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) makeObject(),\n+//            \"/tmp/MultiValueMap.fullCollection.version3.3.obj\");\n+//    }\n+\n+    public void testEmptyMapCompatibility() throws Exception {\n+        Map<?,?> map = makeEmptyMap();\n+        Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+        assertEquals(\"Map is empty\", 0, map2.size());\n+    }\n+    public void testFullMapCompatibility() throws Exception {\n+        Map<?,?> map = (Map<?,?>) makeObject();\n+        Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+        assertEquals(\"Map is the right size\", map.size(), map2.size());\n+        for (Iterator<?> it = map.keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            assertEquals( \"Map had inequal elements\", map.get(key), map2.get(key) );\n+            map2.remove(key);\n+        }\n+        assertEquals(\"Map had extra values\", 0, map2.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestPredicatedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the \n+ * {@link PredicatedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();\n+\n+    protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n+        public boolean evaluate(Object o) {\n+            return (o instanceof String);\n+        }\n+    };\n+\n+    public TestPredicatedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected IterableMap<K, V> decorateMap(Map<K, V> map, Predicate<? super K> keyPredicate,\n+        Predicate<? super V> valuePredicate) {\n+        return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return decorateMap(new HashMap<K, V>(), truePredicate, truePredicate);\n+    }\n+\n+    public IterableMap<K, V> makeTestMap() {\n+        return decorateMap(new HashMap<K, V>(), testPredicate, testPredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySet() {\n+        Map<K, V> map = makeTestMap();\n+        assertTrue(\"returned entryset should not be null\",\n+            map.entrySet() != null);\n+        map = decorateMap(new HashMap<K, V>(), null, null);\n+        map.put((K) \"oneKey\", (V) \"oneValue\");\n+        assertTrue(\"returned entryset should contain one entry\",\n+            map.entrySet().size() == 1);\n+        map = decorateMap(map, null, null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        Map<K, V> map = makeTestMap();\n+        try {\n+            map.put((K) \"Hi\", (V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        try {\n+            map.put((K) new Integer(3), (V) \"Hi\");\n+            fail(\"Illegal key should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        assertTrue(!map.containsKey(new Integer(3)));\n+        assertTrue(!map.containsValue(new Integer(3)));\n+\n+        Map<K, V> map2 = new HashMap<K, V>();\n+        map2.put((K) \"A\", (V) \"a\");\n+        map2.put((K) \"B\", (V) \"b\");\n+        map2.put((K) \"C\", (V) \"c\");\n+        map2.put((K) \"c\", (V) new Integer(3));\n+\n+        try {\n+            map.putAll(map2);\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"E\", (V) \"e\");\n+        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n+        try {\n+            Map.Entry<K, V> entry = iterator.next();\n+            entry.setValue((V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"F\", (V) \"f\");\n+        iterator = map.entrySet().iterator();\n+        Map.Entry<K, V> entry = iterator.next();\n+        entry.setValue((V) \"x\");\n+\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestPredicatedSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link TestPredicatedMap} for exercising the\n+ * {@link PredicatedSortedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+\n+    protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();\n+\n+    protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n+        public boolean evaluate(Object o) {\n+            return (o instanceof String);\n+        }\n+    };\n+\n+    public TestPredicatedSortedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected SortedMap<K, V> decorateMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n+        Predicate<? super V> valuePredicate) {\n+        return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return decorateMap(new TreeMap<K, V>(), truePredicate, truePredicate);\n+    }\n+\n+    public SortedMap<K, V> makeTestMap() {\n+        return decorateMap(new TreeMap<K, V>(), testPredicate, testPredicate);\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    // from TestPredicatedMap\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySet() {\n+        SortedMap<K, V> map = makeTestMap();\n+        assertTrue(\"returned entryset should not be null\",\n+            map.entrySet() != null);\n+        map = decorateMap(new TreeMap<K, V>(), null, null);\n+        map.put((K) \"oneKey\", (V) \"oneValue\");\n+        assertTrue(\"returned entryset should contain one entry\",\n+            map.entrySet().size() == 1);\n+        map = decorateMap(map, null, null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        Map<K, V> map = makeTestMap();\n+        try {\n+            map.put((K) \"Hi\", (V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        try {\n+            map.put((K) new Integer(3), (V) \"Hi\");\n+            fail(\"Illegal key should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        assertTrue(!map.containsKey(new Integer(3)));\n+        assertTrue(!map.containsValue(new Integer(3)));\n+\n+        Map<K, V> map2 = new HashMap<K, V>();\n+        map2.put((K) \"A\", (V) \"a\");\n+        map2.put((K) \"B\", (V) \"b\");\n+        map2.put((K) \"C\", (V) \"c\");\n+        map2.put((K) \"c\", (V) new Integer(3));\n+\n+        try {\n+            map.putAll(map2);\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"E\", (V) \"e\");\n+        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n+        try {\n+            Map.Entry<K, V> entry = iterator.next();\n+            entry.setValue((V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"F\", (V) \"f\");\n+        iterator = map.entrySet().iterator();\n+        Map.Entry<K, V> entry = iterator.next();\n+        entry.setValue((V) \"x\");\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSortOrder() {\n+        SortedMap<K, V> map = makeTestMap();\n+        map.put((K) \"A\",  (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n+        try {\n+            map.put(null, (V) \"c\");\n+            fail(\"Null key should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        map.put((K) \"C\", (V) \"c\");\n+        try {\n+            map.put((K) \"D\", null);\n+            fail(\"Null value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertEquals(\"First key should be A\", \"A\", map.firstKey());\n+        assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n+        assertEquals(\"First key in tail map should be B\",\n+            \"B\", map.tailMap((K) \"B\").firstKey());\n+        assertEquals(\"Last key in head map should be B\",\n+            \"B\", map.headMap((K) \"C\").lastKey());\n+        assertEquals(\"Last key in submap should be B\",\n+           \"B\", map.subMap((K) \"A\",(K) \"C\").lastKey());\n+\n+        Comparator<? super K> c = map.comparator();\n+        assertTrue(\"natural order, so comparator should be null\",\n+            c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestReferenceIdentityMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.map.AbstractReferenceMap.ReferenceStrength;\n+\n+/**\n+ * Tests for ReferenceIdentityMap.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Guilhem Lavaux\n+ */\n+public class TestReferenceIdentityMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    private static final Integer I1A = new Integer(1);\n+    private static final Integer I1B = new Integer(1);\n+    private static final Integer I2A = new Integer(2);\n+    private static final Integer I2B = new Integer(2);\n+\n+    public TestReferenceIdentityMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestReferenceIdentityMap.class);\n+    }\n+\n+    @Override\n+    public ReferenceIdentityMap<K, V> makeObject() {\n+        return new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        // Testing against another [collections] class generally isn't a good idea,\n+        // but the closest alternative is IdentityHashMap, which propagates reference-equality down to keySet and values.\n+        // arguably ReferenceIdentityMap should do the same but that's a later discussion.\n+        return new IdentityMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasics() {\n+        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+        assertEquals(0, map.size());\n+\n+        map.put((K) I1A, (V) I2A);\n+        assertEquals(1, map.size());\n+        assertSame(I2A, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(true, map.containsValue(I2A));\n+        assertEquals(false, map.containsValue(I2B));\n+\n+        map.put((K) I1A, (V) I2B);\n+        assertEquals(1, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+\n+        map.put((K) I1B, (V) I2B);\n+        assertEquals(2, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(I2B, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(true, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHashEntry() {\n+        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+\n+        map.put((K) I1A, (V) I2A);\n+        map.put((K) I1B, (V) I2A);\n+\n+        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry2 = it.next();\n+        Map.Entry<K, V> entry3 = it.next();\n+\n+        assertEquals(true, entry1.equals(entry2));\n+        assertEquals(true, entry2.equals(entry1));\n+        assertEquals(false, entry1.equals(entry3));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, getMap().get(null));\n+        assertEquals(false, getMap().containsKey(null));\n+        assertEquals(false, getMap().containsValue(null));\n+        assertEquals(null, getMap().remove(null));\n+        assertEquals(false, getMap().entrySet().contains(null));\n+        assertEquals(false, getMap().keySet().contains(null));\n+        assertEquals(false, getMap().values().contains(null));\n+        try {\n+            getMap().put(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            getMap().put((K) new Object(), null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            getMap().put(null, (V) new Object());\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+/*\n+    // Tests often fail because gc is uncontrollable\n+\n+    public void testPurge() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Map<K, V> buildRefMap() {\n+        K key = (K) new Object();\n+        V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        Map<K, V> testMap = new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        testMap.put(key, value);\n+\n+        assertEquals(\"In map\", value, testMap.get(key));\n+        assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n+        assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n+        return testMap;\n+    }\n+\n+    /** Tests whether purge values setting works */\n+    public void testPurgeValues() throws Exception {\n+        // many thanks to Juozas Baliuka for suggesting this method\n+        Map<K, V> testMap = buildRefMap();\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while (true) {\n+            System.gc();\n+            if (iterations++ > 50) {\n+                fail(\"Max iterations reached before resource released.\");\n+            }\n+            testMap.isEmpty();\n+            if (\n+                keyReference.get() == null &&\n+                valueReference.get() == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                @SuppressWarnings(\"unused\")\n+                byte[] b =  new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void gc() {\n+        try {\n+            // trigger GC\n+            byte[][] tooLarge = new byte[1000000000][1000000000];\n+            fail(\"you have too much RAM\");\n+        } catch (OutOfMemoryError ex) {\n+            System.gc(); // ignore\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestReferenceMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.map.AbstractReferenceMap.ReferenceStrength;\n+\n+/**\n+ * Tests for ReferenceMap.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ * @author Guilhem Lavaux\n+ */\n+public class TestReferenceMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public TestReferenceMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestReferenceMap.class);\n+    }\n+\n+    @Override\n+    public ReferenceMap<K, V> makeObject() {\n+        return new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, map.get(null));\n+        assertEquals(false, map.containsKey(null));\n+        assertEquals(false, map.containsValue(null));\n+        assertEquals(null, map.remove(null));\n+        assertEquals(false, map.entrySet().contains(null));\n+        assertEquals(false, map.keySet().contains(null));\n+        assertEquals(false, map.values().contains(null));\n+        try {\n+            map.put(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            map.put((K) new Object(), null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            map.put(null, (V) new Object());\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+/*\n+    // Tests often fail because gc is uncontrollable\n+\n+    public void testPurge() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> buildRefMap() {\n+        K key = (K) new Object();\n+        V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        Map<K, V> testMap = new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        testMap.put(key, value);\n+\n+        assertEquals(\"In map\", value, testMap.get(key));\n+        assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n+        assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n+        return testMap;\n+    }\n+\n+    /** Tests whether purge values setting works */\n+    public void testPurgeValues() throws Exception {\n+        // many thanks to Juozas Baliuka for suggesting this method\n+        Map<K, V> testMap = buildRefMap();\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while (true) {\n+            System.gc();\n+            if (iterations++ > 50) {\n+                fail(\"Max iterations reached before resource released.\");\n+            }\n+            testMap.isEmpty();\n+            if (keyReference.get() == null && valueReference.get() == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                @SuppressWarnings(\"unused\")\n+                byte[] b = new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void gc() {\n+        try {\n+            // trigger GC\n+            byte[][] tooLarge = new byte[1000000000][1000000000];\n+            fail(\"you have too much RAM\");\n+        } catch (OutOfMemoryError ex) {\n+            System.gc(); // ignore\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestSingletonMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.OrderedMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSingletonMap<K, V> extends AbstractTestOrderedMap<K, V> {\n+\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final String TEN = \"10\";\n+\n+    public TestSingletonMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestSingletonMap.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMap<K, V> makeObject() {\n+        // need an empty singleton map, but thats not possible\n+        // use a ridiculous fake instead to make the tests pass\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        // the ridiculous map above still doesn't pass these tests\n+        // but its not relevant, so we ignore them\n+        return new String[] {\n+            \"TestSingletonMap.bulkTestMapIterator.testEmptyMapIterator\",\n+            \"TestSingletonMap.bulkTestOrderedMapIterator.testEmptyMapIterator\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonMap<K, V> makeFullMap() {\n+        return new SingletonMap<K, V>((K) ONE, (V) TWO);\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        return (K[]) new Object[] { ONE };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] { TWO };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] { TEN };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClone() {\n+        SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        SingletonMap<K, V> cloned = map.clone();\n+        assertEquals(1, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsValue(TWO));\n+    }\n+\n+    public void testKeyValue() {\n+        SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        assertEquals(ONE, map.getKey());\n+        assertEquals(TWO, map.getValue());\n+        assertTrue(map instanceof KeyValue);\n+    }\n+\n+    public void testBoundedMap() {\n+        SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(1, map.maxSize());\n+        assertTrue(map instanceof BoundedMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    public BulkTest bulkTestMapIterator() {\n+//        return new TestFlatMapIterator();\n+//    }\n+//\n+//    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator {\n+//        public TestFlatMapIterator() {\n+//            super(\"TestFlatMapIterator\");\n+//        }\n+//\n+//        public Object[] addSetValues() {\n+//            return TestSingletonMap.this.getNewSampleValues();\n+//        }\n+//\n+//        public boolean supportsRemove() {\n+//            return TestSingletonMap.this.isRemoveSupported();\n+//        }\n+//\n+//        public boolean supportsSetValue() {\n+//            return TestSingletonMap.this.isSetValueSupported();\n+//        }\n+//\n+//        public MapIterator makeEmptyMapIterator() {\n+//            resetEmpty();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//\n+//        public MapIterator makeFullMapIterator() {\n+//            resetFull();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//\n+//        public Map getMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.map;\n+//        }\n+//\n+//        public Map getConfirmedMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.confirmed;\n+//        }\n+//\n+//        public void verify() {\n+//            super.verify();\n+//            TestSingletonMap.this.verify();\n+//        }\n+//    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/SingletonMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/SingletonMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestStaticBucketMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Unit tests.\n+ * {@link StaticBucketMap}.\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Michael A. Smith\n+ */\n+public class TestStaticBucketMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public TestStaticBucketMap(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestStaticBucketMap.class);\n+    }\n+\n+    @Override\n+    public StaticBucketMap<K, V> makeObject() {\n+        return new StaticBucketMap<K, V>(30);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isFailFastExpected() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        String pre = \"TestStaticBucketMap.bulkTestMap\";\n+        String post = \".testCollectionIteratorFailFast\";\n+        return new String[] {\n+            pre + \"EntrySet\" + post,\n+            pre + \"KeySet\" + post,\n+            pre + \"Values\" + post\n+        };\n+    }\n+\n+    // Bugzilla 37567\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_get_nullMatchesIncorrectly() {\n+        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put(null, (V) \"A\");\n+        assertEquals(\"A\", map.get(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, null, map.get(str));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_containsKey_nullMatchesIncorrectly() {\n+        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put(null, (V) \"A\");\n+        assertEquals(true, map.containsKey(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, false, map.containsKey(str));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_containsValue_nullMatchesIncorrectly() {\n+        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put((K) \"A\", null);\n+        assertEquals(true, map.containsValue(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, false, map.containsValue(str));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestTransformedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the {@link TransformedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public TestTransformedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return TransformedMap.transformingMap(new HashMap<K, V>(), TransformerUtils.<K> nopTransformer(),\n+                TransformerUtils.<V> nopTransformer());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedMap() {\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        Map<K, V> map = TransformedMap\n+                .transformingMap(\n+                        new HashMap<K, V>(),\n+                        (Transformer<? super K, ? extends K>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER,\n+                        null);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsKey(new Integer((String) els[i])));\n+            assertEquals(false, map.containsKey(els[i]));\n+            assertEquals(true, map.containsValue(els[i]));\n+            assertEquals(els[i], map.get(new Integer((String) els[i])));\n+        }\n+\n+        assertEquals(null, map.remove(els[0]));\n+        assertEquals(els[0], map.remove(new Integer((String) els[0])));\n+\n+        map = TransformedMap.transformingMap(new HashMap(), null, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsValue(new Integer((String) els[i])));\n+            assertEquals(false, map.containsValue(els[i]));\n+            assertEquals(true, map.containsKey(els[i]));\n+            assertEquals(new Integer((String) els[i]), map.get(els[i]));\n+        }\n+\n+        assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n+\n+        Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        array[0].setValue((V) \"66\");\n+        assertEquals(new Integer(66), array[0].getValue());\n+        assertEquals(new Integer(66), map.get(array[0].getKey()));\n+\n+        Map.Entry entry = entrySet.iterator().next();\n+        entry.setValue(\"88\");\n+        assertEquals(new Integer(88), entry.getValue());\n+        assertEquals(new Integer(88), map.get(entry.getKey()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_Decorate() {\n+        Map<K, V> base = new HashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        Map<K, V> trans = TransformedMap\n+                .transformingMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(\"1\", trans.get(\"A\"));\n+        assertEquals(\"2\", trans.get(\"B\"));\n+        assertEquals(\"3\", trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_decorateTransform() {\n+        Map<K, V> base = new HashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        Map<K, V> trans = TransformedMap\n+                .transformedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(new Integer(1), trans.get(\"A\"));\n+        assertEquals(new Integer(2), trans.get(\"B\"));\n+        assertEquals(new Integer(3), trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestTransformedSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedMap} for exercising the {@link TransformedSortedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+\n+    public TestTransformedSortedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestTransformedSortedMap.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedMap<K, V> makeObject() {\n+        return TransformedSortedMap.transformingSortedMap(new TreeMap<K, V>(),\n+                (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),\n+                (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedMap() {\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        SortedMap<K, V> map = TransformedSortedMap\n+                .transformingSortedMap(\n+                        new TreeMap<K, V>(),\n+                        (Transformer<? super K, ? extends K>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER,\n+                        null);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsKey(new Integer((String) els[i])));\n+            try {\n+                map.containsKey(els[i]);\n+                fail();\n+            } catch (ClassCastException ex) {}\n+            assertEquals(true, map.containsValue(els[i]));\n+            assertEquals(els[i], map.get(new Integer((String) els[i])));\n+        }\n+\n+        try {\n+            map.remove(els[0]);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        assertEquals(els[0], map.remove(new Integer((String) els[0])));\n+\n+        map = TransformedSortedMap\n+                .transformingSortedMap(\n+                        new TreeMap<K, V>(),\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsValue(new Integer((String) els[i])));\n+            assertEquals(false, map.containsValue(els[i]));\n+            assertEquals(true, map.containsKey(els[i]));\n+            assertEquals(new Integer((String) els[i]), map.get(els[i]));\n+        }\n+\n+        assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n+\n+        Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        array[0].setValue((V) \"66\");\n+        assertEquals(new Integer(66), array[0].getValue());\n+        assertEquals(new Integer(66), map.get(array[0].getKey()));\n+\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        entry.setValue((V) \"88\");\n+        assertEquals(new Integer(88), entry.getValue());\n+        assertEquals(new Integer(88), map.get(entry.getKey()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_Decorate() {\n+        SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        SortedMap<K, V> trans = TransformedSortedMap\n+                .transformingSortedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(\"1\", trans.get(\"A\"));\n+        assertEquals(\"2\", trans.get(\"B\"));\n+        assertEquals(\"3\", trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_decorateTransform() {\n+        SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        SortedMap<K, V> trans = TransformedSortedMap\n+                .transformedSortedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(new Integer(1), trans.get(\"A\"));\n+        assertEquals(new Integer(2), trans.get(\"B\"));\n+        assertEquals(new Integer(3), trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestUnmodifiableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the\n+ * {@link UnmodifiableMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestUnmodifiableMap<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public TestUnmodifiableMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(new HashMap<K, V>());\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        Map<K, V> m = new HashMap<K, V>();\n+        addSampleMappings(m);\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        Map<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableMap.unmodifiableMap(map));\n+\n+        try {\n+            UnmodifiableMap.unmodifiableMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestUnmodifiableOrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Extension of {@link AbstractTestOrderedMap} for exercising the\n+ * {@link UnmodifiableOrderedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableOrderedMap<K, V> extends AbstractTestOrderedMap<K, V> {\n+\n+    public TestUnmodifiableOrderedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public OrderedMap<K, V> makeObject() {\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public OrderedMap<K, V> makeFullMap() {\n+        OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+        addSampleMappings(m);\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        OrderedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));\n+\n+        try {\n+            UnmodifiableOrderedMap.unmodifiableOrderedMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableOrderedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableOrderedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TestUnmodifiableSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedMap} for exercising the\n+ * {@link UnmodifiableSortedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestUnmodifiableSortedMap<K, V> extends AbstractTestSortedMap<K, V> {\n+\n+    public TestUnmodifiableSortedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<K, V>());\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        SortedMap<K, V> m = new TreeMap<K, V>();\n+        addSampleMappings(m);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        SortedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));\n+\n+        try {\n+            UnmodifiableSortedMap.unmodifiableSortedMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/AbstractTestSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Abstract test class for {@link Set} methods and contracts.\n+ * <p>\n+ * Since {@link Set} doesn't stipulate much new behavior that isn't already\n+ * found in {@link Collection}, this class basically just adds tests for\n+ * {@link Set#equals} and {@link Set#hashCode()} along with an updated\n+ * {@link #verify()} that ensures elements do not appear more than once in the\n+ * set.\n+ * <p>\n+ * To use, subclass and override the {@link #makeObject()}\n+ * method.  You may have to override other protected methods if your\n+ * set is not modifiable, or if your set restricts what kinds of\n+ * elements may be added; see {@link AbstractTestCollection} for more details.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Paul Jack\n+ */\n+public abstract class AbstractTestSet<E> extends AbstractTestCollection<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param name  name for test\n+     */\n+    public AbstractTestSet(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Provides additional verifications for sets.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        \n+        assertEquals(\"Sets should be equal\", getConfirmed(), getCollection());\n+        assertEquals(\"Sets should have equal hashCodes\", \n+                     getConfirmed().hashCode(), getCollection().hashCode());\n+        Collection<E> set = makeConfirmedCollection();\n+        Iterator<E> iterator = getCollection().iterator();\n+        while (iterator.hasNext()) {\n+            assertTrue(\"Set.iterator should only return unique elements\", set.add(iterator.next()));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set equals method is defined.\n+     */\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns an empty Set for use in modification testing.\n+     *\n+     * @return a confirmed empty collection\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n+    }\n+\n+    /**\n+     * Returns a full Set for use in modification testing.\n+     *\n+     * @return a confirmed full collection\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        Collection<E> set = makeConfirmedCollection();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    /**\n+     * Makes an empty set.  The returned set should have no elements.\n+     *\n+     * @return an empty set\n+     */\n+    @Override\n+    public abstract Set<E> makeObject();\n+\n+    /**\n+     * Makes a full set by first creating an empty set and then adding\n+     * all the elements returned by {@link #getFullElements()}.\n+     *\n+     * Override if your set does not support the add operation.\n+     *\n+     * @return a full set\n+     */\n+    @Override\n+    public Set<E> makeFullCollection() {\n+        Set<E> set = makeObject();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return the {@link AbstractTestCollection#collection} fixture, but cast as a Set.  \n+     */\n+    @Override\n+    public Set<E> getCollection() {\n+        return (Set<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * Return the {@link AbstractTestCollection#confirmed} fixture, but cast as a Set.\n+     */\n+    @Override\n+    public Set<E> getConfirmed() {\n+        return (Set<E>) super.getConfirmed();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests {@link Set#equals(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetEquals() {\n+        resetEmpty();\n+        assertEquals(\"Empty sets should be equal\", getCollection(), getConfirmed());\n+        verify();\n+\n+        Collection<E> set2 = makeConfirmedCollection();\n+        set2.add((E) \"foo\");\n+        assertTrue(\"Empty set shouldn't equal nonempty set\", !getCollection().equals(set2));\n+\n+        resetFull();\n+        assertEquals(\"Full sets should be equal\", getCollection(), getConfirmed());\n+        verify();\n+\n+        set2.clear();\n+        set2.addAll(Arrays.asList(getOtherElements()));\n+        assertTrue(\"Sets with different contents shouldn't be equal\", !getCollection().equals(set2));\n+    }\n+\n+    /**\n+     * Tests {@link Set#hashCode()}.\n+     */\n+    public void testSetHashCode() {\n+        resetEmpty();\n+        assertEquals(\"Empty sets have equal hashCodes\", \n+                getCollection().hashCode(), getConfirmed().hashCode());\n+\n+        resetFull();\n+        assertEquals(\"Equal sets have equal hashCodes\", \n+                getCollection().hashCode(), getConfirmed().hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/AbstractTestSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Iterator;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Abstract test class for {@link SortedSet} methods and contracts.\n+ * <p>\n+ * To use, subclass and override the {@link #makeObject()}\n+ * method.  You may have to override other protected methods if your\n+ * set is not modifiable, or if your set restricts what kinds of\n+ * elements may be added; see {@link AbstractTestSet} for more details.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Dieter Wimberger\n+ */\n+public abstract class AbstractTestSortedSet<E> extends AbstractTestSet<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param name  name for test\n+     */\n+    public AbstractTestSortedSet(String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Verification extension, will check the order of elements,\n+     * the sets should already be verified equal.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        \n+        // Check that iterator returns elements in order and first() and last()\n+        // are consistent\n+        Iterator<E> colliter = getCollection().iterator();\n+        Iterator<E> confiter = getConfirmed().iterator();\n+        E first = null;\n+        E last = null;\n+        while (colliter.hasNext()) {\n+            if (first == null) {\n+                first = colliter.next();\n+                last = first;\n+            } else {\n+              last = colliter.next();\n+            }  \n+            assertEquals(\"Element appears to be out of order.\", last, confiter.next());\n+        }\n+        if (getCollection().size() > 0) {\n+            assertEquals(\"Incorrect element returned by first().\", first,\n+                getCollection().first());\n+            assertEquals(\"Incorrect element returned by last().\", last,\n+                getCollection().last());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because SortedSets don't allow null elements (normally).\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedSet<E> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> makeFullCollection() {\n+        return (SortedSet<E>) super.makeFullCollection();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty {@link TreeSet} for use in modification testing.\n+     *\n+     * @return a confirmed empty collection\n+     */\n+    @Override\n+    public SortedSet<E> makeConfirmedCollection() {\n+        return new TreeSet<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to return comparable objects.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        Object[] elements = new Object[30];\n+\n+        for (int i = 0; i < 30; i++) {\n+            elements[i] = new Integer(i + i + 1);\n+        }\n+        return (E[]) elements;\n+    }\n+\n+    /**\n+     * Override to return comparable objects.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n+        Object[] elements = new Object[30];\n+        for (int i = 0; i < 30; i++) {\n+            elements[i] = new Integer(i + i + 2);\n+        }\n+        return (E[]) elements;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Bulk test {@link SortedSet#subSet(Object, Object)}.  This method runs through all of\n+     * the tests in {@link AbstractTestSortedSet}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractTestSet} instance for testing a subset.\n+     */\n+    public BulkTest bulkTestSortedSetSubSet() {\n+        int length = getFullElements().length;\n+\n+        int lobound = length / 3;\n+        int hibound = lobound * 2;\n+        return new TestSortedSetSubSet(lobound, hibound);\n+\n+    }\n+\n+    /**\n+     * Bulk test {@link SortedSet#headSet(Object)}.  This method runs through all of\n+     * the tests in {@link AbstractTestSortedSet}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractTestSet} instance for testing a headset.\n+     */\n+    public BulkTest bulkTestSortedSetHeadSet() {\n+        int length = getFullElements().length;\n+\n+        int lobound = length / 3;\n+        int hibound = lobound * 2;\n+        return new TestSortedSetSubSet(hibound, true);\n+\n+    }\n+\n+    /**\n+     * Bulk test {@link SortedSet#tailSet(Object)}.  This method runs through all of\n+     * the tests in {@link AbstractTestSortedSet}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractTestSet} instance for testing a tailset.\n+     */\n+    public BulkTest bulkTestSortedSetTailSet() {\n+        int length = getFullElements().length;\n+        int lobound = length / 3;\n+        return new TestSortedSetSubSet(lobound, false);\n+    }\n+\n+    public class TestSortedSetSubSet extends AbstractTestSortedSet<E> {\n+\n+        private int m_Type;\n+        private int m_LowBound;\n+        private int m_HighBound;\n+        private E[] m_FullElements;\n+        private E[] m_OtherElements;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public TestSortedSetSubSet(int bound, boolean head) {\n+            super(\"TestSortedSetSubSet\");\n+            if (head) {\n+                //System.out.println(\"HEADSET\");\n+                m_Type = TYPE_HEADSET;\n+                m_HighBound = bound;\n+                m_FullElements = (E[]) new Object[bound];\n+                System.arraycopy(AbstractTestSortedSet.this.getFullElements(), 0, m_FullElements, 0, bound);\n+                m_OtherElements = (E[]) new Object[bound - 1];\n+                System.arraycopy(//src src_pos dst dst_pos length\n+                AbstractTestSortedSet.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);\n+                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n+                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n+            } else {\n+                //System.out.println(\"TAILSET\");\n+                m_Type = TYPE_TAILSET;\n+                m_LowBound = bound;\n+                Object[] allelements = AbstractTestSortedSet.this.getFullElements();\n+                //System.out.println(\"bound = \"+bound +\"::length=\"+allelements.length);\n+                m_FullElements = (E[]) new Object[allelements.length - bound];\n+                System.arraycopy(allelements, bound, m_FullElements, 0, allelements.length - bound);\n+                m_OtherElements = (E[]) new Object[allelements.length - bound - 1];\n+                System.arraycopy(//src src_pos dst dst_pos length\n+                AbstractTestSortedSet.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);\n+                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n+                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n+                //resetFull();\n+                //System.out.println(collection);\n+                //System.out.println(confirmed);\n+\n+            }\n+\n+        } //type\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public TestSortedSetSubSet(int lobound, int hibound) {\n+            super(\"TestSortedSetSubSet\");\n+            //System.out.println(\"SUBSET\");\n+            m_Type = TYPE_SUBSET;\n+            m_LowBound = lobound;\n+            m_HighBound = hibound;\n+            int length = hibound - lobound;\n+            //System.out.println(\"Low=\" + lobound + \"::High=\" + hibound + \"::Length=\" + length);\n+            m_FullElements = (E[]) new Object[length];\n+            System.arraycopy(AbstractTestSortedSet.this.getFullElements(), lobound, m_FullElements, 0, length);\n+            m_OtherElements = (E[]) new Object[length - 1];\n+            System.arraycopy(//src src_pos dst dst_pos length\n+            AbstractTestSortedSet.this.getOtherElements(), lobound, m_OtherElements, 0, length - 1);\n+\n+            //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n+            //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n+\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractTestSortedSet.this.isNullSupported();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return AbstractTestSortedSet.this.isAddSupported();\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractTestSortedSet.this.isRemoveSupported();\n+        }\n+        @Override\n+        public boolean isFailFastSupported() {\n+            return AbstractTestSortedSet.this.isFailFastSupported();\n+        }\n+\n+        @Override\n+        public E[] getFullElements() {\n+            return m_FullElements;\n+        }\n+        @Override\n+        public E[] getOtherElements() {\n+            return m_OtherElements;\n+        }\n+\n+        private SortedSet<E> getSubSet(SortedSet<E> set) {\n+            E[] elements = AbstractTestSortedSet.this.getFullElements();\n+            switch (m_Type) {\n+                case TYPE_SUBSET :\n+                    return set.subSet(elements[m_LowBound], elements[m_HighBound]);\n+                case TYPE_HEADSET :\n+                    return set.headSet(elements[m_HighBound]);\n+                case TYPE_TAILSET :\n+                    return set.tailSet(elements[m_LowBound]);\n+                default :\n+                    return null;\n+            }\n+        }\n+\n+        @Override\n+        public SortedSet<E> makeObject() {\n+            return getSubSet(AbstractTestSortedSet.this.makeObject());\n+        }\n+\n+        @Override\n+        public SortedSet<E> makeFullCollection() {\n+            return getSubSet(AbstractTestSortedSet.this.makeFullCollection());\n+        }\n+        \n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+        \n+        @Override\n+        public BulkTest bulkTestSortedSetSubSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSortedSetHeadSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSortedSetTailSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+\n+        static final int TYPE_SUBSET = 0;\n+        static final int TYPE_TAILSET = 1;\n+        static final int TYPE_HEADSET = 2;\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> getCollection() {\n+        return (SortedSet<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> getConfirmed() {\n+        return (SortedSet<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/EmptySetMutator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.collection.CompositeCollection;\n+\n+/**\n+ * This class is used in TestCompositeSet. When testing serialization, \n+ * the class has to be separate of TestCompositeSet, else the test \n+ * class also has to be serialized. \n+ */\n+class EmptySetMutator<E> implements CompositeSet.SetMutator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5321193666420238910L;\n+\n+    private Set<E> contained;\n+\n+    public EmptySetMutator(Set<E> set) {\n+        this.contained = set;\n+    }\n+\n+    public void resolveCollision(CompositeSet<E> comp, Set<E> existing, Set<E> added, Collection<E> intersects) {\n+        throw new IllegalArgumentException();\n+    }\n+    \n+    public boolean add(CompositeCollection<E> composite, List<Collection<E>> collections, E obj) {\n+        return contained.add(obj);\n+    }\n+    \n+    public boolean addAll(CompositeCollection<E> composite, List<Collection<E>> collections, Collection<? extends E> coll) {\n+        return contained.addAll(coll);\n+    }\n+    \n+    public boolean remove(CompositeCollection<E> composite, List<Collection<E>> collections, Object obj) {\n+        return contained.remove(obj);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestCompositeSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.collection.CompositeCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the\n+ * {@link CompositeSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Brian McCallister\n+ * @author Phil Steitz\n+ */\n+\n+public class TestCompositeSet<E> extends AbstractTestSet<E> {\n+    public TestCompositeSet(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public CompositeSet<E> makeObject() {\n+        final HashSet<E> contained = new HashSet<E>();\n+        CompositeSet<E> set = new CompositeSet<E>(contained);\n+        set.setMutator( new EmptySetMutator<E>(contained) );\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> buildOne() {\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"1\");\n+        set.add((E) \"2\");\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> buildTwo() {\n+        HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"3\");\n+        set.add((E) \"4\");\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContains() {\n+        CompositeSet<E> set = new CompositeSet<E>(new Set[]{ buildOne(), buildTwo() });\n+        assertTrue(set.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveUnderlying() {\n+        Set<E> one = buildOne();\n+        Set<E> two = buildTwo();\n+        CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        one.remove(\"1\");\n+        assertFalse(set.contains(\"1\"));\n+\n+        two.remove(\"3\");\n+        assertFalse(set.contains(\"3\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        Set<E> one = buildOne();\n+        Set<E> two = buildTwo();\n+        CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        set.remove(\"1\");\n+        assertFalse(one.contains(\"1\"));\n+\n+        set.remove(\"3\");\n+        assertFalse(one.contains(\"3\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFailedCollisionResolution() {\n+        Set<E> one = buildOne();\n+        Set<E> two = buildTwo();\n+        CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        set.setMutator(new CompositeSet.SetMutator<E>() {\n+            private static final long serialVersionUID = 1L;\n+\n+            public void resolveCollision(CompositeSet<E> comp, Set<E> existing,\n+                Set<E> added, Collection<E> intersects) {\n+                //noop\n+            }\n+\n+            public boolean add(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, E obj) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public boolean addAll(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public boolean remove(CompositeCollection<E> composite,\n+                    List<Collection<E>> collections, Object obj) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+\n+        HashSet<E> three = new HashSet<E>();\n+        three.add((E) \"1\");\n+        try {\n+            set.addComposited(three);\n+            fail(\"IllegalArgumentException should have been thrown\");\n+        }\n+        catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddComposited() {\n+        Set<E> one = buildOne();\n+        Set<E> two = buildTwo();\n+        CompositeSet<E> set = new CompositeSet<E>();\n+        set.addComposited(one, two);\n+        CompositeSet<E> set2 = new CompositeSet<E>(buildOne());\n+        set2.addComposited(buildTwo());\n+        assertTrue(set.equals(set2));\n+        HashSet<E> set3 = new HashSet<E>();\n+        set3.add((E) \"1\");\n+        set3.add((E) \"2\");\n+        set3.add((E) \"3\");\n+        HashSet<E> set4 = new HashSet<E>();\n+        set4.add((E) \"4\");\n+        CompositeSet<E> set5 = new CompositeSet<E>(set3);\n+        set5.addComposited(set4);\n+        assertTrue(set.equals(set5));\n+        try {\n+            set.addComposited(set3);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"/tmp/CompositeSet.emptyCollection.version3.3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"/tmp/CompositeSet.fullCollection.version3.3.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestListOrderedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the {@link ListOrderedSet}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Henning P. Schmiedehausen\n+ * @author Stephen Colebourne\n+ */\n+public class TestListOrderedSet<E> extends AbstractTestSet<E> {\n+\n+    private static final Integer ZERO = new Integer(0);\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final Integer THREE = new Integer(3);\n+\n+    public TestListOrderedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ListOrderedSet<E> makeObject() {\n+        return ListOrderedSet.listOrderedSet(new HashSet<E>());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected ListOrderedSet<E> setupSet() {\n+        ListOrderedSet<E> set = makeObject();\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testOrdering() {\n+        ListOrderedSet<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n+\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i += 2) {\n+            assertTrue(\"Must be able to remove int\", set.remove(Integer.toString(i)));\n+        }\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong after remove \", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+\n+        assertEquals(\"Size of set is wrong!\", 10, set.size());\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+        for (int i = 0; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddRemove() {\n+        ListOrderedSet<E> set = makeObject();\n+        List<E> view = set.asList();\n+        set.add((E) ZERO);\n+        set.add((E) ONE);\n+        set.add((E) TWO);\n+\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertEquals(3, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(ONE, view.get(1));\n+        assertSame(TWO, view.get(2));\n+\n+        assertEquals(0, set.indexOf(ZERO));\n+        assertEquals(1, set.indexOf(ONE));\n+        assertEquals(2, set.indexOf(TWO));\n+\n+        set.remove(1);\n+        assertEquals(2, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(TWO, set.get(1));\n+        assertEquals(2, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(TWO, view.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddIndexed() {\n+        ListOrderedSet<E> set = makeObject();\n+        set.add((E) ZERO);\n+        set.add((E) TWO);\n+\n+        set.add(1, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        set.add(0, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        List<E> list = new ArrayList<E>();\n+        list.add((E) ZERO);\n+        list.add((E) TWO);\n+\n+        set.addAll(0, list);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        list.add(0, (E) THREE); // list = [3,0,2]\n+        set.remove(TWO);    //  set = [0,1]\n+        set.addAll(1, list);\n+        assertEquals(4, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(THREE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertSame(ONE, set.get(3));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddReplacing() {\n+        ListOrderedSet<E> set = makeObject();\n+        A a = new A();\n+        B b = new B();\n+        set.add((E) a);\n+        assertEquals(1, set.size());\n+        set.add((E) b);  // will match but not replace A as equal\n+        assertEquals(1, set.size());\n+        assertSame(a, set.decorated().iterator().next());\n+        assertSame(a, set.iterator().next());\n+        assertSame(a, set.get(0));\n+        assertSame(a, set.asList().get(0));\n+    }\n+\n+    static class A {\n+        @Override\n+        public boolean equals(Object obj) {\n+            return (obj instanceof A || obj instanceof B);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return 1;\n+        }\n+    }\n+\n+    static class B {\n+        @Override\n+        public boolean equals(Object obj) {\n+            return (obj instanceof A || obj instanceof B);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return 1;\n+        }\n+    }\n+\n+    public void testDecorator() {\n+        try {\n+            ListOrderedSet.listOrderedSet((List<E>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet((Set<E>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet(new HashSet<E>(), null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ListOrderedSet.listOrderedSet(null, new ArrayList<E>());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestListOrderedSet2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the {@link ListOrderedSet}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Henning P. Schmiedehausen\n+ * @author Stephen Colebourne\n+ */\n+public class TestListOrderedSet2<E> extends AbstractTestSet<E> {\n+\n+    private static final Integer ZERO = new Integer(0);\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final Integer THREE = new Integer(3);\n+\n+    public TestListOrderedSet2(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ListOrderedSet<E> makeObject() {\n+        return new ListOrderedSet<E>();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected ListOrderedSet<E> setupSet() {\n+        ListOrderedSet<E> set = makeObject();\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testOrdering() {\n+        ListOrderedSet<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n+\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i += 2) {\n+            assertTrue(\"Must be able to remove int\", set.remove(Integer.toString(i)));\n+        }\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong after remove \", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+\n+        assertEquals(\"Size of set is wrong!\", 10, set.size());\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+        for (int i = 0; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddRemove() {\n+        ListOrderedSet<E> set = makeObject();\n+        List<E> view = set.asList();\n+        set.add((E) ZERO);\n+        set.add((E) ONE);\n+        set.add((E) TWO);\n+\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertEquals(3, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(ONE, view.get(1));\n+        assertSame(TWO, view.get(2));\n+\n+        assertEquals(0, set.indexOf(ZERO));\n+        assertEquals(1, set.indexOf(ONE));\n+        assertEquals(2, set.indexOf(TWO));\n+\n+        set.remove(1);\n+        assertEquals(2, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(TWO, set.get(1));\n+        assertEquals(2, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(TWO, view.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddIndexed() {\n+        ListOrderedSet<E> set = makeObject();\n+        set.add((E) ZERO);\n+        set.add((E) TWO);\n+\n+        set.add(1, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        set.add(0, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        List<E> list = new ArrayList<E>();\n+        list.add((E) ZERO);\n+        list.add((E) TWO);\n+\n+        set.addAll(0, list);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        list.add(0, (E) THREE); // list = [3,0,2]\n+        set.remove(TWO);    //  set = [0,1]\n+        set.addAll(1, list);\n+        assertEquals(4, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(THREE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertSame(ONE, set.get(3));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestMapBackedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections.map.HashedMap;\n+\n+/**\n+ * JUnit test.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestMapBackedSet<E> extends AbstractTestSet<E> {\n+\n+    public TestMapBackedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Set<E> makeObject() {\n+        return MapBackedSet.mapBackedSet(new HashedMap<E, Object>());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/MapBackedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/MapBackedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestMapBackedSet2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.map.LinkedMap;\n+\n+/**\n+ * JUnit test.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestMapBackedSet2<E> extends AbstractTestSet<E> {\n+\n+    public TestMapBackedSet2(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Set<E> makeObject() {\n+        return MapBackedSet.mapBackedSet(new LinkedMap<E, Object>());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected Set<E> setupSet() {\n+        Set<E> set = makeObject();\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testOrdering() {\n+        Set<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n+\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i += 2) {\n+            assertTrue(\"Must be able to remove int\", set.remove(Integer.toString(i)));\n+        }\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong after remove \", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+\n+        assertEquals(\"Size of set is wrong!\", 10, set.size());\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+        for (int i = 0; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+    }\n+\n+    @Override\n+    public void testCanonicalEmptyCollectionExists() {\n+    }\n+\n+    @Override\n+    public void testCanonicalFullCollectionExists() {\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestPredicatedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the \n+ * {@link PredicatedSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedSet<E> extends AbstractTestSet<E> {\n+\n+    public TestPredicatedSet(String testName) {\n+        super(testName);\n+    }\n+\n+ //-------------------------------------------------------------------\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected PredicatedSet<E> decorateSet(Set<E> set, Predicate<? super E> predicate) {\n+        return (PredicatedSet<E>) PredicatedSet.predicatedSet(set, predicate);\n+    }\n+\n+    @Override\n+    public PredicatedSet<E> makeObject() {\n+        return decorateSet(new HashSet<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+    }\n+\n+//--------------------------------------------------------------------\n+\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(E o) {\n+                return o instanceof String;\n+            }\n+        };\n+\n+    protected PredicatedSet<E> makeTestSet() {\n+        return decorateSet(new HashSet<E>(), testPredicate);\n+    }\n+\n+    public void testGetSet() {\n+        PredicatedSet<E> set = makeTestSet();\n+        assertTrue(\"returned set should not be null\", set.decorated() != null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        Set<E> set = makeTestSet();\n+        Integer i = new Integer(3);\n+        try {\n+            set.add((E) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !set.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        Set<E> set = makeTestSet();\n+        Set<E> elements = new HashSet<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n+        try {\n+            set.addAll(elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(\"one\"));\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(\"two\"));\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(new Integer(3)));\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(\"four\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestPredicatedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedSet} for exercising the\n+ * {@link PredicatedSortedSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestPredicatedSortedSet<E> extends AbstractTestSortedSet<E> {\n+\n+    public TestPredicatedSortedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestPredicatedSortedSet.class);\n+    }\n+\n+ //-------------------------------------------------------------------\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    @Override\n+    public SortedSet<E> makeObject() {\n+        return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public SortedSet<E> makeFullCollection() {\n+        TreeSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return PredicatedSortedSet.predicatedSortedSet(set, truePredicate);\n+    }\n+\n+//--------------------------------------------------------------------\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(E o) {\n+                return (o instanceof String) && (((String) o).startsWith(\"A\"));\n+            }\n+        };\n+\n+    protected PredicatedSortedSet<E> makeTestSet() {\n+        return (PredicatedSortedSet<E>) PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), testPredicate);\n+    }\n+\n+    public void testGetSet() {\n+        PredicatedSortedSet<E> set = makeTestSet();\n+        assertTrue(\"returned set should not be null\", set.decorated() != null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        SortedSet<E> set = makeTestSet();\n+        String testString = \"B\";\n+        try {\n+            set.add((E) testString);\n+            fail(\"Should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !set.contains(testString));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        SortedSet<E> set = makeTestSet();\n+        Set<E> elements = new TreeSet<E>();\n+        elements.add((E) \"Aone\");\n+        elements.add((E) \"Atwo\");\n+        elements.add((E) \"Bthree\");\n+        elements.add((E) \"Afour\");\n+        try {\n+            set.addAll(elements);\n+            fail(\"Should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Aone\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Atwo\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Bthree\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Afour\"));\n+    }\n+\n+    public void testComparator() {\n+        SortedSet<E> set = makeTestSet();\n+        Comparator<? super E> c = set.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedSortedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/PredicatedSortedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestSynchronizedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the\n+ * {@link SynchronizedSet} implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSynchronizedSet<E> extends AbstractTestSet<E> {\n+\n+    public TestSynchronizedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestSynchronizedSet.class);\n+    }\n+\n+   //-------------------------------------------------------------------\n+    @Override\n+    public Set<E> makeObject() {\n+        return SynchronizedSet.synchronizedSet(new HashSet<E>());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestSynchronizedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the\n+ * {@link SynchronizedSortedSet} implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestSynchronizedSortedSet<E> extends AbstractTestSortedSet<E> {\n+\n+    public TestSynchronizedSortedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestSynchronizedSortedSet.class);\n+    }\n+\n+   //-------------------------------------------------------------------\n+    @Override\n+    public SortedSet<E> makeObject() {\n+        return SynchronizedSortedSet.synchronizedSortedSet(new TreeSet<E>());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedSortedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/SynchronizedSortedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestTransformedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the {@link TransformedSet}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedSet<E> extends AbstractTestSet<E> {\n+\n+    public TestTransformedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Set<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n+    }\n+\n+    @Override\n+    public Set<E> makeConfirmedFullCollection() {\n+        Set<E> set = new HashSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> makeObject() {\n+        return TransformedSet.transformingSet(new HashSet<E>(),\n+                (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> makeFullCollection() {\n+        Set<E> list = new HashSet<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedSet.transformingSet(list,\n+                (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedSet() {\n+        Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),\n+                (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, set.size());\n+        E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            set.add(els[i]);\n+            assertEquals(i + 1, set.size());\n+            assertEquals(true, set.contains(new Integer((String) els[i])));\n+            assertEquals(false, set.contains(els[i]));\n+        }\n+\n+        assertEquals(false, set.remove(els[0]));\n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+\n+    }\n+\n+    public void testTransformedSet_decorateTransform() {\n+        Set<Object> originalSet = new HashSet<Object>();\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            originalSet.add(els[i]);\n+        }\n+        Set<?> set = TransformedSet.transformedSet(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, set.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, set.contains(new Integer((String) els[i])));\n+            assertEquals(false, set.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, set.remove(els[0]));\n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestTransformedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Arrays;\n+import java.util.TreeSet;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.TestTransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedSet} for exercising the {@link TransformedSortedSet}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TestTransformedSortedSet<E> extends AbstractTestSortedSet<E> {\n+\n+    public TestTransformedSortedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestTransformedSortedSet.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedSet<E> makeObject() {\n+        return TransformedSortedSet.transformingSortedSet(new TreeSet<E>(), (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedSet<E> makeFullCollection() {\n+        SortedSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TestTransformedCollection.NOOP_TRANSFORMER);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedSet() {\n+        SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),\n+                (Transformer<E, E>) TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, set.size());\n+        E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            set.add(els[i]);\n+            assertEquals(i + 1, set.size());\n+            assertEquals(true, set.contains(new Integer((String) els[i])));\n+        }\n+\n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+    }\n+\n+    public void testTransformedSet_decorateTransform() {\n+        Set<Object> originalSet = new TreeSet<Object>();\n+        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            originalSet.add(els[i]);\n+        }\n+        Set<?> set = TransformedSortedSet.transformedSet(originalSet, TestTransformedCollection.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, set.size());\n+        for (int i = 0; i < els.length; i++) {\n+            assertEquals(true, set.contains(new Integer((String) els[i])));\n+        }\n+        \n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedSortedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/TransformedSortedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestUnmodifiableSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the\n+ * {@link UnmodifiableSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestUnmodifiableSet<E> extends AbstractTestSet<E> {\n+\n+    public TestUnmodifiableSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnmodifiableSet.class);\n+    }\n+\n+    //-------------------------------------------------------------------\n+    @Override\n+    public Set<E> makeObject() {\n+        return UnmodifiableSet.unmodifiableSet(new HashSet<E>());\n+    }\n+\n+    @Override\n+    public Set<E> makeFullCollection() {\n+        HashSet<E> set = new HashSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/set/TestUnmodifiableSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractTestSortedSet} for exercising the\n+ * {@link UnmodifiableSortedSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class TestUnmodifiableSortedSet<E> extends AbstractTestSortedSet<E> {\n+    protected UnmodifiableSortedSet<E> set = null;\n+    protected ArrayList<E> array = null;\n+\n+    public TestUnmodifiableSortedSet(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnmodifiableSortedSet.class);\n+    }\n+\n+    //-------------------------------------------------------------------\n+    @Override\n+    public SortedSet<E> makeObject() {\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<E>());\n+    }\n+\n+    @Override\n+    public UnmodifiableSortedSet<E> makeFullCollection() {\n+        TreeSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.unmodifiableSortedSet(set);\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //--------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    protected void setupSet() {\n+        set = makeFullCollection();\n+        array = new ArrayList<E>();\n+        array.add((E) new Integer(1));\n+    }\n+\n+    /**\n+     * Verify that base set and subsets are not modifiable\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiable() {\n+        setupSet();\n+        verifyUnmodifiable(set);\n+        verifyUnmodifiable(set.headSet((E) new Integer(1)));\n+        verifyUnmodifiable(set.tailSet((E) new Integer(1)));\n+        verifyUnmodifiable(set.subSet((E) new Integer(1), (E) new Integer(3)));\n+    }\n+\n+    /**\n+     * Verifies that a set is not modifiable\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void verifyUnmodifiable(Set<E> set) {\n+        try {\n+            set.add((E) \"value\");\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.addAll(new TreeSet<E>());\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.clear();\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.remove(\"x\");\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.removeAll(array);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.retainAll(array);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testComparator() {\n+        setupSet();\n+        Comparator<? super E> c = set.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableSortedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/UnmodifiableSortedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/splitmap/TestSplitMapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Put;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+import org.apache.commons.collections.map.HashedMap;\n+\n+/**\n+ * Tests for {@link TransformedMap}\n+ *\n+ * @since Commons Collections 5\n+ * @TODO fix version\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestSplitMapUtils extends BulkTest {\n+    private Map<String, Integer> backingMap;\n+    private TransformedMap<String, String, String, Integer> transformedMap;\n+\n+    private Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public TestSplitMapUtils(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        backingMap = new HashMap<String, Integer>();\n+        transformedMap = TransformedMap.transformingMap(backingMap, NOPTransformer.<String> nopTransformer(),\n+                stringToInt);\n+        for (int i = 0; i < 10; i++) {\n+            transformedMap.put(String.valueOf(i), String.valueOf(i));\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testReadableMap() {\n+        final IterableMap<String, Integer> map = SplitMapUtils.readableMap(transformedMap);\n+\n+        // basic\n+        for (int i = 0; i < 10; i++) {\n+            assertFalse(map.containsValue(String.valueOf(i)));\n+            assertEquals(i, map.get(String.valueOf(i)).intValue());\n+        }\n+\n+        // mapIterator\n+        MapIterator<String, Integer> it = map.mapIterator();\n+        while (it.hasNext()) {\n+            String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(Integer.valueOf(k), it.getValue());\n+        }\n+\n+        // unmodifiable\n+        assertTrue(map instanceof Unmodifiable);\n+\n+        // check individual operations\n+        int sz = map.size();\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.clear();\n+            }\n+        });\n+\n+        assertEquals(sz, map.size());\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.put(\"foo\", 100);\n+            }\n+        });\n+\n+        final HashMap<String, Integer> m = new HashMap<String, Integer>();\n+        m.put(\"foo\", 100);\n+        m.put(\"bar\", 200);\n+        m.put(\"baz\", 300);\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.putAll(m);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // remove\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(i, map.remove(String.valueOf(i)).intValue());\n+            assertEquals(--sz, map.size());\n+        }\n+        assertTrue(map.isEmpty());\n+        assertSame(map, SplitMapUtils.readableMap(map));\n+    }\n+\n+    public void testAlreadyReadableMap() {\n+        HashedMap<String, Integer> hashedMap = new HashedMap<String, Integer>();\n+        assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testWritableMap() {\n+        final Map<String, String> map = SplitMapUtils.writableMap(transformedMap);\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.get(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.entrySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.keySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.values();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.size();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.isEmpty();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsKey(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsValue(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.remove(null);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        Map<String, String> other = SplitMapUtils.writableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // put\n+        int sz = backingMap.size();\n+        assertFalse(backingMap.containsKey(\"foo\"));\n+        map.put(\"new\", \"66\");\n+        assertEquals(++sz, backingMap.size());\n+\n+        // putall\n+        Map<String, String> more = new HashMap<String, String>();\n+        more.put(\"foo\", \"77\");\n+        more.put(\"bar\", \"88\");\n+        more.put(\"baz\", \"99\");\n+        map.putAll(more);\n+        assertEquals(sz + more.size(), backingMap.size());\n+\n+        // clear\n+        map.clear();\n+        assertTrue(backingMap.isEmpty());\n+        assertSame(map, SplitMapUtils.writableMap((Put<String, String>) map));\n+    }\n+\n+    public void testAlreadyWritableMap() {\n+        HashedMap<String, String> hashedMap = new HashedMap<String, String>();\n+        assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));\n+    }\n+\n+    private void attemptGetOperation(Runnable r) {\n+        attemptMapOperation(\"Put exposed as writable Map must not allow Get operations\", r);\n+    }\n+\n+    private void attemptPutOperation(Runnable r) {\n+        attemptMapOperation(\"Get exposed as writable Map must not allow Put operations\", r);\n+    }\n+\n+    private void attemptMapOperation(String s, Runnable r) {\n+        try {\n+            r.run();\n+            fail(s);\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/splitmap/TestTransformedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+\n+/**\n+ * Tests for {@link TransformedMap}\n+ *\n+ * @since Commons Collections 5\n+ * @TODO fix version, add Serialization tests\n+ * @version $Revision$ $Date$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestTransformedMap extends BulkTest {\n+\n+    private Transformer<Integer, String> intToString = new Transformer<Integer, String>() {\n+        public String transform(Integer input) {\n+            return String.valueOf(input);\n+        }\n+    };\n+\n+    private Transformer<Object, Class<?>> objectToClass = new Transformer<Object, Class<?>>() {\n+        public java.lang.Class<?> transform(Object input) {\n+            return input == null ? null : input.getClass();\n+        }\n+    };\n+\n+    private Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public TestTransformedMap(String testName) {\n+        super(testName);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testTransformedMap() {\n+        TransformedMap<Integer, String, Object, Class<?>> map = TransformedMap.transformingMap(\n+                new HashMap<String, Class<?>>(), intToString, objectToClass);\n+\n+        Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };\n+        Object[] v = new Object[] { \"\", new Object(), new HashMap<Object, Object>(), 0, BigInteger.TEN, null,\n+                new Object[0] };\n+\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < k.length; i++) {\n+            map.put(k[i], v[i]);\n+            assertEquals(i + 1, map.size());\n+            assertTrue(map.containsKey(intToString.transform(k[i])));\n+            assertFalse(map.containsKey(k[i]));\n+            assertTrue(map.containsValue(objectToClass.transform(v[i])));\n+            assertTrue(objectToClass.transform(v[i]) != v[i] ^ map.containsValue(v[i]));\n+            assertEquals(objectToClass.transform(v[i]), map.get(intToString.transform(k[i])));\n+        }\n+\n+        int sz = map.size();\n+        assertEquals(null, map.remove(k[0]));\n+        assertEquals(sz, map.size());\n+        assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));\n+        assertEquals(--sz, map.size());\n+\n+        TransformedMap<String, String, String, Integer> map2 = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map2.size());\n+        for (int i = 0; i < 6; i++) {\n+            map2.put(String.valueOf(i), String.valueOf(i));\n+            assertEquals(i + 1, map2.size());\n+            assertTrue(map2.containsValue(i));\n+            assertFalse(map2.containsValue(String.valueOf(i)));\n+            assertTrue(map2.containsKey(String.valueOf(i)));\n+            assertEquals(i, map2.get(String.valueOf(i)).intValue());\n+        }\n+\n+        int sz2 = map2.size();\n+        assertEquals(Integer.valueOf(0), map2.remove(\"0\"));\n+        assertEquals(--sz2, map2.size());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testMapIterator() {\n+        TransformedMap<String, String, String, Integer> map = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < 6; i++) {\n+            map.put(String.valueOf(i), String.valueOf(i));\n+        }\n+\n+        for (MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {\n+            String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(map.get(k), it.getValue());\n+        }\n+    }\n+\n+    public void testEmptyMap() throws IOException, ClassNotFoundException {\n+        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+                new HashMap<String, String>(),\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n+\n+        ObjectInputStream in = new ObjectInputStream( new FileInputStream( \"data/test/TransformedMap.emptyCollection.version3.2.obj\" ) );\n+        Object readObject = in.readObject();\n+        in.close();\n+\n+        TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        assertTrue( \"Map should be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+\n+    public void testFullMap() throws IOException, ClassNotFoundException {\n+        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+                new HashMap<String, String>(),\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n+        map.put( \"a\", \"b\" );\n+        map.put( \"c\", \"d\" );\n+        map.put( \"e\", \"f\" );\n+        map.put( \"g\", \"h\" );\n+\n+        ObjectInputStream in = new ObjectInputStream( new FileInputStream( \"data/test/TransformedMap.fullCollection.version3.2.obj\" ) );\n+        Object readObject = in.readObject();\n+        in.close();\n+\n+        TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        assertFalse( \"Map should not be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+//\n+//    public void testCreate() throws IOException {\n+//        TransformedMap<String, String, String, String> map = TransformedMap.decorate(\n+//                new HashMap<String, String>(),\n+//                NOPTransformer.<String>getInstance(),\n+//                NOPTransformer.<String>getInstance() );\n+//\n+//        ObjectOutputStream out = new ObjectOutputStream(\n+//                new FileOutputStream( \"data/test/TransformedMap.emptyCollection.version3.2.obj\" ) );\n+//        out.writeObject( map );\n+//\n+//        map.put( \"a\", \"b\" );\n+//        map.put( \"c\", \"d\" );\n+//        map.put( \"e\", \"f\" );\n+//        map.put( \"g\", \"h\" );\n+//\n+//        out = new ObjectOutputStream(\n+//                new FileOutputStream( \"data/test/TransformedMap.fullCollection.version3.2.obj\" ) );\n+//        out.writeObject( map );\n+//    }\n+}", "timestamp": 1331234965, "metainfo": ""}