{"sha": "fd7506f4d78a5710f4a34145e6a9d55b7b01eaa4", "log": "Add missing @Override tags.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public int getCount(final Object object) {\n         return decorated().getCount(object);\n     }\n \n+    @Override\n     public boolean add(final E object, final int count) {\n         return decorated().add(object, count);\n     }\n \n+    @Override\n     public boolean remove(final Object object, final int count) {\n         return decorated().remove(object, count);\n     }\n \n+    @Override\n     public Set<E> uniqueSet() {\n         return decorated().uniqueSet();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java\n import java.util.Map.Entry;\n import java.util.Set;\n \n+import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.set.UnmodifiableSet;\n-import org.apache.commons.collections4.Bag;\n \n /**\n  * Abstract implementation of the {@link Bag} interface to simplify the creation\n      *\n      * @return current size of the bag\n      */\n+    @Override\n     public int size() {\n         return size;\n     }\n      *\n      * @return true if bag is empty\n      */\n+    @Override\n     public boolean isEmpty() {\n         return map.isEmpty();\n     }\n      * @param object the object to search for\n      * @return the number of occurrences of the object, zero if not found\n      */\n+    @Override\n     public int getCount(final Object object) {\n         final MutableInteger count = map.get(object);\n         if (count != null) {\n      * @param object the object to search for\n      * @return true if the bag contains the given element\n      */\n+    @Override\n     public boolean contains(final Object object) {\n         return map.containsKey(object);\n     }\n      * @param coll the collection to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n+    @Override\n     public boolean containsAll(final Collection<?> coll) {\n         if (coll instanceof Bag) {\n             return containsAll((Bag<?>) coll);\n      *\n      * @return the iterator\n      */\n+    @Override\n     public Iterator<E> iterator() {\n         return new BagIterator<E>(this);\n     }\n         }\n \n         /** {@inheritDoc} */\n+        @Override\n         public boolean hasNext() {\n             return itemCount > 0 || entryIterator.hasNext();\n         }\n \n         /** {@inheritDoc} */\n+        @Override\n         public E next() {\n             if (parent.modCount != mods) {\n                 throw new ConcurrentModificationException();\n         }\n \n         /** {@inheritDoc} */\n+        @Override\n         public void remove() {\n             if (parent.modCount != mods) {\n                 throw new ConcurrentModificationException();\n      * @param object the object to add\n      * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n      */\n+    @Override\n     public boolean add(final E object) {\n         return add(object, 1);\n     }\n      * @param nCopies the number of copies to add\n      * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n      */\n+    @Override\n     public boolean add(final E object, final int nCopies) {\n         modCount++;\n         if (nCopies > 0) {\n      * @param coll the collection to add\n      * @return <code>true</code> if this call changed the bag\n      */\n+    @Override\n     public boolean addAll(final Collection<? extends E> coll) {\n         boolean changed = false;\n         final Iterator<? extends E> i = coll.iterator();\n     /**\n      * Clears the bag by clearing the underlying map.\n      */\n+    @Override\n     public void clear() {\n         modCount++;\n         map.clear();\n      * @param object the object to remove\n      * @return true if the bag changed\n      */\n+    @Override\n     public boolean remove(final Object object) {\n         final MutableInteger mut = map.get(object);\n         if (mut == null) {\n      * @param nCopies the number of copies to remove\n      * @return true if the bag changed\n      */\n+    @Override\n     public boolean remove(final Object object, final int nCopies) {\n         final MutableInteger mut = map.get(object);\n         if (mut == null) {\n      * @param coll the collection to use\n      * @return true if the bag changed\n      */\n+    @Override\n     public boolean removeAll(final Collection<?> coll) {\n         boolean result = false;\n         if (coll != null) {\n      * @param coll the collection to retain\n      * @return true if this call changed the collection\n      */\n+    @Override\n     public boolean retainAll(final Collection<?> coll) {\n         if (coll instanceof Bag) {\n             return retainAll((Bag<?>) coll);\n      *\n      * @return an array of all of this bag's elements\n      */\n+    @Override\n     public Object[] toArray() {\n         final Object[] result = new Object[size()];\n         int i = 0;\n      *   a supertype of the runtime type of the elements in this list\n      * @throws NullPointerException if the specified array is null\n      */\n+    @Override\n     public <T> T[] toArray(T[] array) {\n         final int size = size();\n         if (array.length < size) {\n      *\n      * @return the set of unique elements in this bag\n      */\n+    @Override\n     public Set<E> uniqueSet() {\n         if (uniqueSet == null) {\n             uniqueSet = UnmodifiableSet.<E> unmodifiableSet(map.keySet());\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public E first() {\n         return decorated().first();\n     }\n \n+    @Override\n     public E last() {\n         return decorated().last();\n     }\n \n+    @Override\n     public Comparator<? super E> comparator() {\n         return decorated().comparator();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/HashBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/HashBag.java\n import java.io.Serializable;\n import java.util.Collection;\n import java.util.HashMap;\n+\n+import org.apache.commons.collections4.Bag;\n \n /**\n  * Implements {@link Bag}, using a {@link HashMap} to provide the\n--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n  * If an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n  * <p>\n  * One usage would be to ensure that no null entries are added to the bag.\n- * <pre>Bag bag = PredicatedBag.decorate(new HashBag(), NotNullPredicate.INSTANCE);</pre>\n+ * <pre>\n+ * Bag bag = PredicatedBag.predicatedBag(new HashBag(), NotNullPredicate.INSTANCE);\n+ * </pre>\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  *\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public boolean add(final E object, final int count) {\n         validate(object);\n         return decorated().add(object, count);\n     }\n \n+    @Override\n     public boolean remove(final Object object, final int count) {\n         return decorated().remove(object, count);\n     }\n \n+    @Override\n     public Set<E> uniqueSet() {\n         return decorated().uniqueSet();\n     }\n \n+    @Override\n     public int getCount(final Object object) {\n         return decorated().getCount(object);\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java\n  * If an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n  * <p>\n  * One usage would be to ensure that no null entries are added to the bag.\n- * <pre>SortedBag bag = PredicatedSortedBag.decorate(new TreeBag(), NotNullPredicate.INSTANCE);</pre>\n+ * <pre>\n+ * SortedBag bag = PredicatedSortedBag.predicatedSortedBag(new TreeBag(), NotNullPredicate.INSTANCE);\n+ * </pre>\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  *\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public E first() {\n         return decorated().first();\n     }\n \n+    @Override\n     public E last() {\n         return decorated().last();\n     }\n \n+    @Override\n     public Comparator<? super E> comparator() {\n         return decorated().comparator();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public boolean add(final E object, final int count) {\n         synchronized (lock) {\n             return getBag().add(object, count);\n         }\n     }\n \n+    @Override\n     public boolean remove(final Object object, final int count) {\n         synchronized (lock) {\n             return getBag().remove(object, count);\n         }\n     }\n \n+    @Override\n     public Set<E> uniqueSet() {\n         synchronized (lock) {\n             final Set<E> set = getBag().uniqueSet();\n         }\n     }\n \n+    @Override\n     public int getCount(final Object object) {\n         synchronized (lock) {\n             return getBag().getCount(object);\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public synchronized E first() {\n         synchronized (lock) {\n             return getSortedBag().first();\n         }\n     }\n \n+    @Override\n     public synchronized E last() {\n         synchronized (lock) {\n             return getSortedBag().last();\n         }\n     }\n \n+    @Override\n     public synchronized Comparator<? super E> comparator() {\n         synchronized (lock) {\n             return getSortedBag().comparator();\n--- a/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public int getCount(final Object object) {\n         return getBag().getCount(object);\n     }\n \n+    @Override\n     public boolean remove(final Object object, final int nCopies) {\n         return getBag().remove(object, nCopies);\n     }\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public boolean add(final E object, final int nCopies) {\n         return getBag().add(transform(object), nCopies);\n     }\n \n+    @Override\n     public Set<E> uniqueSet() {\n         final Set<E> set = getBag().uniqueSet();\n         return TransformedSet.<E>transformingSet(set, transformer);\n--- a/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public E first() {\n         return getSortedBag().first();\n     }\n \n+    @Override\n     public E last() {\n         return getSortedBag().last();\n     }\n \n+    @Override\n     public Comparator<? super E> comparator() {\n         return getSortedBag().comparator();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/TreeBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TreeBag.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public E first() {\n         return getMap().firstKey();\n     }\n \n+    @Override\n     public E last() {\n         return getMap().lastKey();\n     }\n \n+    @Override\n     public Comparator<? super E> comparator() {\n         return getMap().comparator();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java\n         return decorated().mapIterator();\n     }\n \n+    @Override\n     public K getKey(final Object value) {\n         return decorated().getKey(value);\n     }\n \n+    @Override\n     public K removeValue(final Object value) {\n         return decorated().removeValue(value);\n     }\n \n+    @Override\n     public BidiMap<V, K> inverseBidiMap() {\n         return decorated().inverseBidiMap();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\n     // Map delegation\n     //-----------------------------------------------------------------------\n \n+    @Override\n     public V get(final Object key) {\n         return normalMap.get(key);\n     }\n \n+    @Override\n     public int size() {\n         return normalMap.size();\n     }\n \n+    @Override\n     public boolean isEmpty() {\n         return normalMap.isEmpty();\n     }\n \n+    @Override\n     public boolean containsKey(final Object key) {\n         return normalMap.containsKey(key);\n     }\n     // BidiMap changes\n     //-----------------------------------------------------------------------\n \n+    @Override\n     public V put(final K key, final V value) {\n         if (normalMap.containsKey(key)) {\n             reverseMap.remove(normalMap.get(key));\n         return obj;\n     }\n \n+    @Override\n     public void putAll(final Map<? extends K, ? extends V> map) {\n         for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n \n+    @Override\n     public V remove(final Object key) {\n         V value = null;\n         if (normalMap.containsKey(key)) {\n         return value;\n     }\n \n+    @Override\n     public void clear() {\n         normalMap.clear();\n         reverseMap.clear();\n     }\n \n+    @Override\n     public boolean containsValue(final Object value) {\n         return reverseMap.containsKey(value);\n     }\n      *\n      * @return a map iterator\n      */\n+    @Override\n     public MapIterator<K, V> mapIterator() {\n         return new BidiMapIterator<K, V>(this);\n     }\n \n+    @Override\n     public K getKey(final Object value) {\n         return reverseMap.get(value);\n     }\n \n+    @Override\n     public K removeValue(final Object value) {\n         K key = null;\n         if (reverseMap.containsKey(value)) {\n         return key;\n     }\n \n+    @Override\n     public BidiMap<V, K> inverseBidiMap() {\n         if (inverseBidiMap == null) {\n             inverseBidiMap = createBidiMap(reverseMap, normalMap, this);\n      *\n      * @return the keySet view\n      */\n+    @Override\n     public Set<K> keySet() {\n         if (keySet == null) {\n             keySet = new KeySet<K>(this);\n      *\n      * @return the values view\n      */\n+    @Override\n     public Set<V> values() {\n         if (values == null) {\n             values = new Values<V>(this);\n      *\n      * @return the entrySet view\n      */\n+    @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n         if (entrySet == null) {\n             entrySet = new EntrySet<K, V>(this);\n             this.iterator = parent.normalMap.entrySet().iterator();\n         }\n \n+        @Override\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        @Override\n         public K next() {\n             last = iterator.next();\n             canRemove = true;\n             return last.getKey();\n         }\n \n+        @Override\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             canRemove = false;\n         }\n \n+        @Override\n         public K getKey() {\n             if (last == null) {\n                 throw new IllegalStateException(\n             return last.getKey();\n         }\n \n+        @Override\n         public V getValue() {\n             if (last == null) {\n                 throw new IllegalStateException(\n             return last.getValue();\n         }\n \n+        @Override\n         public V setValue(final V value) {\n             if (last == null) {\n                 throw new IllegalStateException(\n             return parent.put(last.getKey(), value);\n         }\n \n+        @Override\n         public void reset() {\n             iterator = parent.normalMap.entrySet().iterator();\n             last = null;\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java\n         return decorated().mapIterator();\n     }\n \n+    @Override\n     public K firstKey() {\n         return decorated().firstKey();\n     }\n \n+    @Override\n     public K lastKey() {\n         return decorated().lastKey();\n     }\n \n+    @Override\n     public K nextKey(final K key) {\n         return decorated().nextKey(key);\n     }\n \n+    @Override\n     public K previousKey(final K key) {\n         return decorated().previousKey(key);\n     }\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java\n         return decorated().inverseBidiMap();\n     }\n \n+    @Override\n     public Comparator<? super K> comparator() {\n         return decorated().comparator();\n     }\n \n+    @Override\n     public Comparator<? super V> valueComparator() {\n         return decorated().valueComparator();\n     }\n \n+    @Override\n     public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return decorated().subMap(fromKey, toKey);\n     }\n \n+    @Override\n     public SortedMap<K, V> headMap(final K toKey) {\n         return decorated().headMap(toKey);\n     }\n \n+    @Override\n     public SortedMap<K, V> tailMap(final K fromKey) {\n         return decorated().tailMap(fromKey);\n     }\n--- a/src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public Comparator<? super K> comparator() {\n         return ((SortedMap<K, V>) normalMap).comparator();\n     }\n \n+    @Override\n     public Comparator<? super V> valueComparator() {\n         return ((SortedMap<V, K>) reverseMap).comparator();\n     }\n \n+    @Override\n     public K firstKey() {\n         return ((SortedMap<K, V>) normalMap).firstKey();\n     }\n \n+    @Override\n     public K lastKey() {\n         return ((SortedMap<K, V>) normalMap).lastKey();\n     }\n \n+    @Override\n     public K nextKey(final K key) {\n         if (isEmpty()) {\n             return null;\n         return null;\n     }\n \n+    @Override\n     public K previousKey(final K key) {\n         if (isEmpty()) {\n             return null;\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public SortedMap<K, V> headMap(final K toKey) {\n         final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n         return new ViewMap<K, V>(this, sub);\n     }\n \n+    @Override\n     public SortedMap<K, V> tailMap(final K fromKey) {\n         final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n         return new ViewMap<K, V>(this, sub);\n     }\n \n+    @Override\n     public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n         return new ViewMap<K, V>(this, sub);\n             iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n         }\n \n+        @Override\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        @Override\n         public K next() {\n             last = iterator.next();\n             return last.getKey();\n         }\n \n+        @Override\n         public boolean hasPrevious() {\n             return iterator.hasPrevious();\n         }\n \n+        @Override\n         public K previous() {\n             last = iterator.previous();\n             return last.getKey();\n         }\n \n+        @Override\n         public void remove() {\n             iterator.remove();\n             parent.remove(last.getKey());\n             last = null;\n         }\n \n+        @Override\n         public K getKey() {\n             if (last == null) {\n                 throw new IllegalStateException(\n             return last.getKey();\n         }\n \n+        @Override\n         public V getValue() {\n             if (last == null) {\n                 throw new IllegalStateException(\n             return last.getValue();\n         }\n \n+        @Override\n         public V setValue(final V value) {\n             if (last == null) {\n                 throw new IllegalStateException(\n             return oldValue;\n         }\n \n+        @Override\n         public void reset() {\n             iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n             last = null;\n--- a/src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java\n  */\n package org.apache.commons.collections4.bidimap;\n \n+import static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.KEY;\n+import static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.VALUE;\n+\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import org.apache.commons.collections4.OrderedMapIterator;\n import org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\n import org.apache.commons.collections4.keyvalue.UnmodifiableMapEntry;\n-\n-import static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.KEY;\n-import static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.VALUE;\n \n /**\n  * Red-Black tree-based implementation of BidiMap where all objects added\n      *\n      * @return the number of key-value mappings in this map\n      */\n+    @Override\n     public int size() {\n         return nodeCount;\n     }\n      *\n      * @return true if the map is empty\n      */\n+    @Override\n     public boolean isEmpty() {\n         return nodeCount == 0;\n     }\n      * @throws ClassCastException if the key is of an inappropriate type\n      * @throws NullPointerException if the key is null\n      */\n+    @Override\n     public boolean containsKey(final Object key) {\n         checkKey(key);\n         return lookupKey(key) != null;\n      * @throws ClassCastException if the value is of an inappropriate type\n      * @throws NullPointerException if the value is null\n      */\n+    @Override\n     public boolean containsValue(final Object value) {\n         checkValue(value);\n         return lookupValue(value) != null;\n      * @throws ClassCastException if the key is of an inappropriate type\n      * @throws NullPointerException if the key is null\n      */\n+    @Override\n     public V get(final Object key) {\n         checkKey(key);\n         final Node<K, V> node = lookupKey(key);\n      * @throws ClassCastException if the key is of an inappropriate type\n      * @throws NullPointerException if the key is null\n      */\n+    @Override\n     public V put(final K key, final V value) {\n         final V result = get(key);\n         doPut(key, value);\n      *\n      * @param map  the map to copy from\n      */\n+    @Override\n     public void putAll(final Map<? extends K, ? extends V> map) {\n         for (final Map.Entry<? extends K, ? extends V> e : map.entrySet()) {\n             put(e.getKey(), e.getValue());\n      * @throws ClassCastException if the key is of an inappropriate type\n      * @throws NullPointerException if the key is null\n      */\n+    @Override\n     public V remove(final Object key) {\n         return doRemoveKey(key);\n     }\n     /**\n      * Removes all mappings from this map.\n      */\n+    @Override\n     public void clear() {\n         modify();\n \n      * @throws ClassCastException if the value is of an inappropriate type\n      * @throws NullPointerException if the value is null\n      */\n+    @Override\n     public K getKey(final Object value) {\n         checkValue(value);\n         final Node<K, V> node = lookupValue(value);\n      * @throws ClassCastException if the value is of an inappropriate type\n      * @throws NullPointerException if the value is null\n      */\n+    @Override\n     public K removeValue(final Object value) {\n         return doRemoveValue(value);\n     }\n      * @return the first (lowest) key currently in this sorted map\n      * @throws NoSuchElementException if this map is empty\n      */\n+    @Override\n     public K firstKey() {\n         if (nodeCount == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n      * @return the last (highest) key currently in this sorted map\n      * @throws NoSuchElementException if this map is empty\n      */\n+    @Override\n     public K lastKey() {\n         if (nodeCount == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n      * @param key the key to search for next from\n      * @return the next key, null if no match or at end\n      */\n+    @Override\n     public K nextKey(final K key) {\n         checkKey(key);\n         final Node<K, V> node = nextGreater(lookupKey(key), KEY);\n      * @param key the key to search for previous from\n      * @return the previous key, null if no match or at start\n      */\n+    @Override\n     public K previousKey(final K key) {\n         checkKey(key);\n         final Node<K, V> node = nextSmaller(lookupKey(key), KEY);\n      *\n      * @return a set view of the keys contained in this map.\n      */\n+    @Override\n     public Set<K> keySet() {\n         if (keySet == null) {\n             keySet = new KeyView(KEY);\n      *\n      * @return a set view of the values contained in this map.\n      */\n+    @Override\n     public Set<V> values() {\n         if (valuesSet == null) {\n             valuesSet = new ValueView(KEY);\n      *\n      * @return a set view of the values contained in this map.\n      */\n+    @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n         if (entrySet == null) {\n             entrySet = new EntryView();\n     }\n \n     //-----------------------------------------------------------------------\n+    @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n         if (isEmpty()) {\n             return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n      *\n      * @return the inverse map\n      */\n+    @Override\n     public OrderedBidiMap<V, K> inverseBidiMap() {\n         if (inverse == null) {\n             inverse = new Inverse();\n             super(orderType);\n         }\n \n+        @Override\n         public K getKey() {\n             if (lastReturnedNode == null) {\n                 throw new IllegalStateException(\n             return lastReturnedNode.getKey();\n         }\n \n+        @Override\n         public V getValue() {\n             if (lastReturnedNode == null) {\n                 throw new IllegalStateException(\n             return lastReturnedNode.getValue();\n         }\n \n+        @Override\n         public V setValue(final V obj) {\n             throw new UnsupportedOperationException();\n         }\n \n+        @Override\n         public K next() {\n             return navigateNext().getKey();\n         }\n \n+        @Override\n         public K previous() {\n             return navigatePrevious().getKey();\n         }\n             super(orderType);\n         }\n \n+        @Override\n         public V getKey() {\n             if (lastReturnedNode == null) {\n                 throw new IllegalStateException(\n             return lastReturnedNode.getValue();\n         }\n \n+        @Override\n         public K getValue() {\n             if (lastReturnedNode == null) {\n                 throw new IllegalStateException(\n             return lastReturnedNode.getKey();\n         }\n \n+        @Override\n         public K setValue(final K obj) {\n             throw new UnsupportedOperationException();\n         }\n \n+        @Override\n         public V next() {\n             return navigateNext().getValue();\n         }\n \n+        @Override\n         public V previous() {\n             return navigatePrevious().getValue();\n         }\n             super(KEY);\n         }\n \n+        @Override\n         public Map.Entry<K, V> next() {\n             return navigateNext();\n         }\n \n+        @Override\n         public Map.Entry<K, V> previous() {\n             return navigatePrevious();\n         }\n             super(VALUE);\n         }\n \n+        @Override\n         public Map.Entry<V, K> next() {\n             return createEntry(navigateNext());\n         }\n \n+        @Override\n         public Map.Entry<V, K> previous() {\n             return createEntry(navigatePrevious());\n         }\n          *\n          * @return the key corresponding to this entry.\n          */\n+        @Override\n         public K getKey() {\n             return key;\n         }\n          *\n          * @return the value corresponding to this entry.\n          */\n+        @Override\n         public V getValue() {\n             return value;\n         }\n          * @return does not return\n          * @throws UnsupportedOperationException always\n          */\n+        @Override\n         public V setValue(final V ignored) throws UnsupportedOperationException {\n             throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n         }\n         /** Store the entrySet once created. */\n         private Set<Map.Entry<V, K>> inverseEntrySet;\n \n+        @Override\n         public int size() {\n             return TreeBidiMap.this.size();\n         }\n \n+        @Override\n         public boolean isEmpty() {\n             return TreeBidiMap.this.isEmpty();\n         }\n \n+        @Override\n         public K get(final Object key) {\n             return TreeBidiMap.this.getKey(key);\n         }\n \n+        @Override\n         public V getKey(final Object value) {\n             return TreeBidiMap.this.get(value);\n         }\n \n+        @Override\n         public boolean containsKey(final Object key) {\n             return TreeBidiMap.this.containsValue(key);\n         }\n \n+        @Override\n         public boolean containsValue(final Object value) {\n             return TreeBidiMap.this.containsKey(value);\n         }\n \n+        @Override\n         public V firstKey() {\n             if (TreeBidiMap.this.nodeCount == 0) {\n                 throw new NoSuchElementException(\"Map is empty\");\n             return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n         }\n \n+        @Override\n         public V lastKey() {\n             if (TreeBidiMap.this.nodeCount == 0) {\n                 throw new NoSuchElementException(\"Map is empty\");\n             return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n         }\n \n+        @Override\n         public V nextKey(final V key) {\n             checkKey(key);\n             final Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n             return node == null ? null : node.getValue();\n         }\n \n+        @Override\n         public V previousKey(final V key) {\n             checkKey(key);\n             final Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n             return node == null ? null : node.getValue();\n         }\n \n+        @Override\n         public K put(final V key, final K value) {\n             final K result = get(key);\n             TreeBidiMap.this.doPut(value, key);\n             return result;\n         }\n \n+        @Override\n         public void putAll(final Map<? extends V, ? extends K> map) {\n             for (final Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n                 put(e.getKey(), e.getValue());\n             }\n         }\n \n+        @Override\n         public K remove(final Object key) {\n             return TreeBidiMap.this.removeValue(key);\n         }\n \n+        @Override\n         public V removeValue(final Object value) {\n             return TreeBidiMap.this.remove(value);\n         }\n \n+        @Override\n         public void clear() {\n             TreeBidiMap.this.clear();\n         }\n \n+        @Override\n         public Set<V> keySet() {\n             if (inverseKeySet == null) {\n                 inverseKeySet = new ValueView(VALUE);\n             return inverseKeySet;\n         }\n \n+        @Override\n         public Set<K> values() {\n             if (inverseValuesSet == null) {\n                 inverseValuesSet = new KeyView(VALUE);\n             return inverseValuesSet;\n         }\n \n+        @Override\n         public Set<Map.Entry<V, K>> entrySet() {\n             if (inverseEntrySet == null) {\n                 inverseEntrySet = new InverseEntryView();\n             return inverseEntrySet;\n         }\n \n+        @Override\n         public OrderedMapIterator<V, K> mapIterator() {\n             if (isEmpty()) {\n                 return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n             return new InverseViewMapIterator(VALUE);\n         }\n \n+        @Override\n         public OrderedBidiMap<K, V> inverseBidiMap() {\n             return TreeBidiMap.this;\n         }\n--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.BidiMap;\n import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another {@link BidiMap} to ensure it can't be altered.\n--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.OrderedBidiMap;\n import org.apache.commons.collections4.OrderedMapIterator;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another {@link OrderedBidiMap} to ensure it can't be altered.\n--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java\n import java.util.Set;\n import java.util.SortedMap;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.OrderedMapIterator;\n import org.apache.commons.collections4.SortedBidiMap;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n import org.apache.commons.collections4.map.UnmodifiableSortedMap;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another {@link SortedBidiMap} to ensure it can't be altered.\n--- a/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public boolean add(final E object) {\n         return decorated().add(object);\n     }\n \n+    @Override\n     public boolean addAll(final Collection<? extends E> coll) {\n         return decorated().addAll(coll);\n     }\n \n+    @Override\n     public void clear() {\n         decorated().clear();\n     }\n \n+    @Override\n     public boolean contains(final Object object) {\n         return decorated().contains(object);\n     }\n \n+    @Override\n     public boolean isEmpty() {\n         return decorated().isEmpty();\n     }\n \n+    @Override\n     public Iterator<E> iterator() {\n         return decorated().iterator();\n     }\n \n+    @Override\n     public boolean remove(final Object object) {\n         return decorated().remove(object);\n     }\n \n+    @Override\n     public int size() {\n         return decorated().size();\n     }\n \n+    @Override\n     public Object[] toArray() {\n         return decorated().toArray();\n     }\n \n+    @Override\n     public <T> T[] toArray(final T[] object) {\n         return decorated().toArray(object);\n     }\n \n+    @Override\n     public boolean containsAll(final Collection<?> coll) {\n         return decorated().containsAll(coll);\n     }\n \n+    @Override\n     public boolean removeAll(final Collection<?> coll) {\n         return decorated().removeAll(coll);\n     }\n \n+    @Override\n     public boolean retainAll(final Collection<?> coll) {\n         return decorated().retainAll(coll);\n     }\n--- a/src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java\n      *\n      * @return total number of elements in all contained containers\n      */\n+    @Override\n     public int size() {\n         int size = 0;\n         for (final Collection<E> item : all) {\n      *\n      * @return true if all of the contained collections are empty\n      */\n+    @Override\n     public boolean isEmpty() {\n         for (final Collection<E> item : all) {\n             if (item.isEmpty() == false) {\n      * @param obj  the object to search for\n      * @return true if obj is contained in any of the contained collections\n      */\n+    @Override\n     public boolean contains(final Object obj) {\n         for (final Collection<E> item : all) {\n             if (item.contains(obj)) {\n      *  the order they were added, but this behavior should not be relied upon.\n      * @see IteratorChain\n      */\n+    @Override\n     public Iterator<E> iterator() {\n         if (all.isEmpty()) {\n             return EmptyIterator.<E>emptyIterator();\n      *\n      * @return an object array of all the elements in the collection\n      */\n+    @Override\n     public Object[] toArray() {\n         final Object[] result = new Object[size()];\n         int i = 0;\n      * @param array  the array to use, populating if possible\n      * @return an array of all the elements in the collection\n      */\n+    @Override\n     @SuppressWarnings(\"unchecked\")\n     public <T> T[] toArray(final T[] array) {\n         final int size = size();\n      * @throws NullPointerException if the object cannot be added because its null\n      * @throws IllegalArgumentException if the object cannot be added\n      */\n+    @Override\n     public boolean add(final E obj) {\n         if (mutator == null) {\n            throw new UnsupportedOperationException(\n      * @throws NullPointerException if the object cannot be removed because its null\n      * @throws IllegalArgumentException if the object cannot be removed\n      */\n+    @Override\n     public boolean remove(final Object obj) {\n         if (mutator == null) {\n             throw new UnsupportedOperationException(\n      * @param coll  the collection to check for\n      * @return true if all elements contained\n      */\n+    @Override\n     public boolean containsAll(final Collection<?> coll) {\n         for (final Object item : coll) {\n             if (contains(item) == false) {\n      * @throws NullPointerException if the object cannot be added because its null\n      * @throws IllegalArgumentException if the object cannot be added\n      */\n+    @Override\n     public boolean addAll(final Collection<? extends E> coll) {\n         if (mutator == null) {\n             throw new UnsupportedOperationException(\n      * @return true if the collection was modified\n      * @throws UnsupportedOperationException if removeAll is unsupported\n      */\n+    @Override\n     public boolean removeAll(final Collection<?> coll) {\n         if (coll.size() == 0) {\n             return false;\n      * @return true if the collection was modified\n      * @throws UnsupportedOperationException if retainAll is unsupported\n      */\n+    @Override\n     public boolean retainAll(final Collection<?> coll) {\n         boolean changed = false;\n         for (final Collection<E> item : all) {\n      *\n      * @throws UnsupportedOperationException if clear is unsupported\n      */\n+    @Override\n     public void clear() {\n         for (final Collection<E> coll : all) {\n             coll.clear();\n--- a/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\n \n     //-----------------------------------------------------------------------\n \n+    @Override\n     public boolean add(final E object) {\n         synchronized (lock) {\n             return decorated().add(object);\n         }\n     }\n \n+    @Override\n     public boolean addAll(final Collection<? extends E> coll) {\n         synchronized (lock) {\n             return decorated().addAll(coll);\n         }\n     }\n \n+    @Override\n     public void clear() {\n         synchronized (lock) {\n             decorated().clear();\n         }\n     }\n \n+    @Override\n     public boolean contains(final Object object) {\n         synchronized (lock) {\n             return decorated().contains(object);\n         }\n     }\n \n+    @Override\n     public boolean containsAll(final Collection<?> coll) {\n         synchronized (lock) {\n             return decorated().containsAll(coll);\n         }\n     }\n \n+    @Override\n     public boolean isEmpty() {\n         synchronized (lock) {\n             return decorated().isEmpty();\n      *\n      * @return an iterator that must be manually synchronized on the collection\n      */\n+    @Override\n     public Iterator<E> iterator() {\n         return decorated().iterator();\n     }\n \n+    @Override\n     public Object[] toArray() {\n         synchronized (lock) {\n             return decorated().toArray();\n         }\n     }\n \n+    @Override\n     public <T> T[] toArray(final T[] object) {\n         synchronized (lock) {\n             return decorated().toArray(object);\n         }\n     }\n \n+    @Override\n     public boolean remove(final Object object) {\n         synchronized (lock) {\n             return decorated().remove(object);\n         }\n     }\n \n+    @Override\n     public boolean removeAll(final Collection<?> coll) {\n         synchronized (lock) {\n             return decorated().removeAll(coll);\n         }\n     }\n \n+    @Override\n     public boolean retainAll(final Collection<?> coll) {\n         synchronized (lock) {\n             return decorated().retainAll(coll);\n         }\n     }\n \n+    @Override\n     public int size() {\n         synchronized (lock) {\n             return decorated().size();\n--- a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java\n     }\n \n     //-----------------------------------------------------------------------\n+    @Override\n     public boolean isFull() {\n         return decorated().isFull();\n     }\n \n+    @Override\n     public int maxSize() {\n         return decorated().maxSize();\n     }\n--- a/src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java\n      * @return negative if obj1 is less, positive if greater, zero if equal\n      * @throws NullPointerException when either argument <code>null</code>\n      */\n+    @Override\n     public int compare(final Boolean b1, final Boolean b2) {\n         final boolean v1 = b1.booleanValue();\n         final boolean v2 = b2.booleanValue();\n--- a/src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java\n  * objects.\n  * <p>\n  * This Comparator is useful, for example, for enforcing the natural order in\n- * custom implementations of {@link java.util.SortedSet SortedSet} and {@link java.util.SortedMap SortedMap}.\n+ * custom implementations of {@link java.util.SortedSet SortedSet} and\n+ * {@link java.util.SortedMap SortedMap}.\n  * <p>\n  * Note: In the 2.0 and 2.1 releases of Commons Collections, this class would\n  * throw a {@link ClassCastException} if either of the arguments to\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n-        return (ComparableComparator<E>) INSTANCE;\n+        return INSTANCE;\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ClassCastException if <i>obj1</i> is not a <code>Comparable</code>,\n      *         or when <code>((Comparable)obj1).compareTo(obj2)</code> does\n      */\n+    @Override\n     public int compare(final E obj1, final E obj2) {\n         return obj1.compareTo(obj2);\n     }\n--- a/src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java\n      * @return -1, 0, or 1\n      * @throws UnsupportedOperationException if the ComparatorChain does not contain at least one Comparator\n      */\n+    @Override\n     public int compare(final E o1, final E o2) throws UnsupportedOperationException {\n         if (isLocked == false) {\n             checkChainIntegrity();\n--- a/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\n      *  to this Comparator and an alternative behavior has not been set\n      *  via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}.\n      */\n+    @Override\n     public int compare(final T obj1, final T obj2) {\n         isLocked = true;\n         final Integer position1 = map.get(obj1);\n--- a/src/main/java/org/apache/commons/collections4/comparators/NullComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/NullComparator.java\n      *  \"higher\" than (greater than, after, etc.) <code>o2</code>; or\n      *  <code>0</code> if <code>o1</code> and <code>o2</code> are equal.\n      **/\n+    @Override\n     public int compare(final E o1, final E o2) {\n         if(o1 == o2) { return 0; }\n         if(o1 == null) { return this.nullsAreHigh ? 1 : -1; }\n--- a/src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java\n      * @param obj2  the second object to compare\n      * @return negative if obj1 is less, positive if greater, zero if equal\n      */\n+    @Override\n     public int compare(final E obj1, final E obj2) {\n         return comparator.compare(obj2, obj1);\n     }\n--- a/src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java\n      * @param obj2  the second object to transform then compare\n      * @return negative if obj1 is less, positive if greater, zero if equal\n      */\n+    @Override\n     public int compare(final I obj1, final I obj2) {\n         final O value1 = this.transformer.transform(obj1);\n         final O value2 = this.transformer.transform(obj2);", "timestamp": 1433621943, "metainfo": ""}