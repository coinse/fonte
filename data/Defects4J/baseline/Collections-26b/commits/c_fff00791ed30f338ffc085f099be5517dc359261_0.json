{"sha": "fff00791ed30f338ffc085f099be5517dc359261", "log": "Change parentage of these classes so that they subclass ArrayList, HashMap, and TreeMap respectively.  This improves the ability to substitute \"fast\" versions for the use of the regular collection classes.  Implement clone(), equals(), and hashCode() methods in accordance with the contracts specified in the Collections classes APIs.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/FastArrayList.java\n+++ b/src/java/org/apache/commons/collections/FastArrayList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastArrayList.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/04/16 22:42:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastArrayList.java,v 1.2 2001/04/21 12:19:57 craigmcc Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/04/21 12:19:57 $\n  *\n  * ====================================================================\n  *\n  * <code>java.util.ArrayList</code> directly (with no synchronization), for\n  * maximum performance.</p>\n  *\n- * <p><strong>NOTE</strong>: The following methods are <strong>NOT</strong>\n- * overridden:  clone(), equals(Object), hashCode().</p>\n- *\n  * @author Craig R. McClanahan\n- * @version $Revision: 1.1 $ $Date: 2001/04/16 22:42:04 $\n+ * @version $Revision: 1.2 $ $Date: 2001/04/21 12:19:57 $\n  */\n \n-public class FastArrayList implements List, Cloneable, Serializable {\n+public class FastArrayList extends ArrayList {\n \n \n     // ----------------------------------------------------------- Constructors\n \n \n     /**\n+     * Return a shallow copy of this <code>FastArrayList</code> instance.\n+     * The elements themselves are not copied.\n+     */\n+    public Object clone() {\n+\n+        FastArrayList results = null;\n+        if (fast) {\n+            results = new FastArrayList(list);\n+        } else {\n+            synchronized (list) {\n+                results = new FastArrayList(list);\n+            }\n+        }\n+        results.setFast(getFast());\n+        return (results);\n+\n+    }\n+\n+\n+    /**\n      * Return <code>true</code> if this list contains the specified element.\n      *\n      * @param element The element to test for\n \n \n     /**\n+     * Compare the specified object with this list for equality.  This\n+     * implementation uses exactly the code that is used to define the\n+     * list equals function in the documentation for the\n+     * <code>List.equals</code> method.\n+     *\n+     * @param o Object to be compared to this list\n+     */\n+    public boolean equals(Object o) {\n+\n+        // Simple tests that require no synchronization\n+        if (o == this)\n+            return (true);\n+        else if (!(o instanceof List))\n+            return (false);\n+        List lo = (List) o;\n+\n+        // Compare the sets of elements for equality\n+        if (fast) {\n+            ListIterator li1 = list.listIterator();\n+            ListIterator li2 = lo.listIterator();\n+            while (li1.hasNext() && li2.hasNext()) {\n+                Object o1 = li1.next();\n+                Object o2 = li2.next();\n+                if (!(o1 == null ? o2 == null : o1.equals(o2)))\n+                    return (false);\n+            }\n+            return (!(li1.hasNext() || li2.hasNext()));\n+        } else {\n+            synchronized (list) {\n+                ListIterator li1 = list.listIterator();\n+                ListIterator li2 = lo.listIterator();\n+                while (li1.hasNext() && li2.hasNext()) {\n+                    Object o1 = li1.next();\n+                    Object o2 = li2.next();\n+                    if (!(o1 == null ? o2 == null : o1.equals(o2)))\n+                        return (false);\n+                }\n+                return (!(li1.hasNext() || li2.hasNext()));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n      * Return the element at the specified position in the list.\n      *\n      * @param index The index of the element to return\n         } else {\n             synchronized (list) {\n                 return (list.get(index));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the hash code value for this list.  This implementation uses\n+     * exactly the code that is used to define the list hash function in the\n+     * documentation for the <code>List.hashCode</code> method.\n+     */\n+    public int hashCode() {\n+\n+        if (fast) {\n+            int hashCode = 1;\n+            Iterator i = list.iterator();\n+            while (i.hasNext()) {\n+                Object o = i.next();\n+                hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());\n+            }\n+            return (hashCode);\n+        } else {\n+            synchronized (list) {\n+                int hashCode = 1;\n+                Iterator i = list.iterator();\n+                while (i.hasNext()) {\n+                    Object o = i.next();\n+                    hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());\n+                }\n+                return (hashCode);\n             }\n         }\n \n--- a/src/java/org/apache/commons/collections/FastHashMap.java\n+++ b/src/java/org/apache/commons/collections/FastHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastHashMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/04/16 22:42:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastHashMap.java,v 1.2 2001/04/21 12:19:57 craigmcc Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/04/21 12:19:57 $\n  *\n  * ====================================================================\n  *\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n \n \n  * <code>java.util.HashMap</code> directly (with no synchronization), for\n  * maximum performance.</p>\n  *\n- * <p><strong>NOTE</strong>: The following methods are <strong>NOT</strong>\n- * overridden:  clone(), equals(Object), hashCode().</p>\n- *\n  * @author Craig R. McClanahan\n- * @version $Revision: 1.1 $ $Date: 2001/04/16 22:42:04 $\n+ * @version $Revision: 1.2 $ $Date: 2001/04/21 12:19:57 $\n  */\n \n-public class FastHashMap implements Map, Cloneable, Serializable {\n+public class FastHashMap extends HashMap {\n \n \n     // ----------------------------------------------------------- Constructors\n \n \n     /**\n+     * Return a shallow copy of this <code>FastHashMap</code> instance.\n+     * The keys and values themselves are not copied.\n+     */\n+    public Object clone() {\n+\n+        FastHashMap results = null;\n+        if (fast) {\n+            results = new FastHashMap(map);\n+        } else {\n+            synchronized (map) {\n+                results = new FastHashMap(map);\n+            }\n+        }\n+        results.setFast(getFast());\n+        return (results);\n+\n+    }\n+\n+\n+    /**\n      * Return <code>true</code> if this map contains a mapping for the\n      * specified key.\n      *\n         } else {\n             synchronized (map) {\n                 return (map.entrySet());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Compare the specified object with this list for equality.  This\n+     * implementation uses exactly the code that is used to define the\n+     * list equals function in the documentation for the\n+     * <code>Map.equals</code> method.\n+     *\n+     * @param o Object to be compared to this list\n+     */\n+    public boolean equals(Object o) {\n+\n+        // Simple tests that require no synchronization\n+        if (o == this)\n+            return (true);\n+        else if (!(o instanceof Map))\n+            return (false);\n+        Map mo = (Map) o;\n+\n+        // Compare the two maps for equality\n+        if (fast) {\n+            if (mo.size() != map.size())\n+                return (false);\n+            Iterator i = map.entrySet().iterator();\n+            while (i.hasNext()) {\n+                Entry e = (Entry) i.next();\n+                Object key = e.getKey();\n+                Object value = e.getValue();\n+                if (value == null) {\n+                    if (!(mo.get(key) == null && mo.containsKey(key)))\n+                        return (false);\n+                } else {\n+                    if (!value.equals(mo.get(key)))\n+                        return (false);\n+                }\n+            }\n+            return (true);\n+        } else {\n+            synchronized (map) {\n+                if (mo.size() != map.size())\n+                    return (false);\n+                Iterator i = map.entrySet().iterator();\n+                while (i.hasNext()) {\n+                    Entry e = (Entry) i.next();\n+                    Object key = e.getKey();\n+                    Object value = e.getValue();\n+                    if (value == null) {\n+                        if (!(mo.get(key) == null && mo.containsKey(key)))\n+                            return (false);\n+                    } else {\n+                        if (!value.equals(mo.get(key)))\n+                            return (false);\n+                    }\n+                }\n+                return (true);\n             }\n         }\n \n         } else {\n             synchronized (map) {\n                 return (map.get(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the hash code value for this map.  This implementation uses\n+     * exactly the code that is used to define the list hash function in the\n+     * documentation for the <code>Map.hashCode</code> method.\n+     */\n+    public int hashCode() {\n+\n+        if (fast) {\n+            int h = 0;\n+            Iterator i = map.entrySet().iterator();\n+            while (i.hasNext())\n+                h += i.next().hashCode();\n+            return (h);\n+        } else {\n+            synchronized (map) {\n+                int h = 0;\n+                Iterator i = map.entrySet().iterator();\n+                while (i.hasNext())\n+                    h += i.next().hashCode();\n+                return (h);\n             }\n         }\n \n--- a/src/java/org/apache/commons/collections/FastTreeMap.java\n+++ b/src/java/org/apache/commons/collections/FastTreeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastTreeMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n- * $Revision: 1.1 $\n- * $Date: 2001/04/16 22:42:04 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastTreeMap.java,v 1.2 2001/04/21 12:19:57 craigmcc Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2001/04/21 12:19:57 $\n  *\n  * ====================================================================\n  *\n import java.util.Comparator;\n import java.util.Iterator;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n import java.util.SortedMap;\n import java.util.TreeMap;\n  * <code>java.util.TreeMap</code> directly (with no synchronization), for\n  * maximum performance.</p>\n  *\n- * <p><strong>NOTE</strong>: The following methods are <strong>NOT</strong>\n- * overridden:  clone(), equals(Object), hashCode().</p>\n- *\n  * @author Craig R. McClanahan\n- * @version $Revision: 1.1 $ $Date: 2001/04/16 22:42:04 $\n+ * @version $Revision: 1.2 $ $Date: 2001/04/21 12:19:57 $\n  */\n \n-public class FastTreeMap implements Map, Cloneable, Serializable {\n+public class FastTreeMap extends TreeMap {\n \n \n     // ----------------------------------------------------------- Constructors\n \n \n     /**\n+     * Return a shallow copy of this <code>FastTreeMap</code> instance.\n+     * The keys and values themselves are not copied.\n+     */\n+    public Object clone() {\n+\n+        FastTreeMap results = null;\n+        if (fast) {\n+            results = new FastTreeMap(map);\n+        } else {\n+            synchronized (map) {\n+                results = new FastTreeMap(map);\n+            }\n+        }\n+        results.setFast(getFast());\n+        return (results);\n+\n+    }\n+\n+\n+    /**\n      * Return the comparator used to order this map, or <code>null</code>\n      * if this map uses its keys' natural order.\n      */\n         } else {\n             synchronized (map) {\n                 return (map.entrySet());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Compare the specified object with this list for equality.  This\n+     * implementation uses exactly the code that is used to define the\n+     * list equals function in the documentation for the\n+     * <code>Map.equals</code> method.\n+     *\n+     * @param o Object to be compared to this list\n+     */\n+    public boolean equals(Object o) {\n+\n+        // Simple tests that require no synchronization\n+        if (o == this)\n+            return (true);\n+        else if (!(o instanceof Map))\n+            return (false);\n+        Map mo = (Map) o;\n+\n+        // Compare the two maps for equality\n+        if (fast) {\n+            if (mo.size() != map.size())\n+                return (false);\n+            Iterator i = map.entrySet().iterator();\n+            while (i.hasNext()) {\n+                Entry e = (Entry) i.next();\n+                Object key = e.getKey();\n+                Object value = e.getValue();\n+                if (value == null) {\n+                    if (!(mo.get(key) == null && mo.containsKey(key)))\n+                        return (false);\n+                } else {\n+                    if (!value.equals(mo.get(key)))\n+                        return (false);\n+                }\n+            }\n+            return (true);\n+        } else {\n+            synchronized (map) {\n+                if (mo.size() != map.size())\n+                    return (false);\n+                Iterator i = map.entrySet().iterator();\n+                while (i.hasNext()) {\n+                    Entry e = (Entry) i.next();\n+                    Object key = e.getKey();\n+                    Object value = e.getValue();\n+                    if (value == null) {\n+                        if (!(mo.get(key) == null && mo.containsKey(key)))\n+                            return (false);\n+                    } else {\n+                        if (!value.equals(mo.get(key)))\n+                            return (false);\n+                    }\n+                }\n+                return (true);\n             }\n         }\n \n         } else {\n             synchronized (map) {\n                 return (map.get(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the hash code value for this map.  This implementation uses\n+     * exactly the code that is used to define the list hash function in the\n+     * documentation for the <code>Map.hashCode</code> method.\n+     */\n+    public int hashCode() {\n+\n+        if (fast) {\n+            int h = 0;\n+            Iterator i = map.entrySet().iterator();\n+            while (i.hasNext())\n+                h += i.next().hashCode();\n+            return (h);\n+        } else {\n+            synchronized (map) {\n+                int h = 0;\n+                Iterator i = map.entrySet().iterator();\n+                while (i.hasNext())\n+                    h += i.next().hashCode();\n+                return (h);\n             }\n         }\n ", "timestamp": 987855597, "metainfo": ""}