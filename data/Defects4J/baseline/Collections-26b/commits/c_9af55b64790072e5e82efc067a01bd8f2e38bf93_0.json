{"sha": "9af55b64790072e5e82efc067a01bd8f2e38bf93", "log": "Remove trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractKeyAnalyzer.java\n \n /**\n  * TODO: add javadoc\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public abstract class AbstractKeyAnalyzer<K> implements KeyAnalyzer<K> {\n-    \n+\n     private static final long serialVersionUID = -20497563720380683L;\n \n     /**\n         } else if (o2 == null) {\n             return 1;\n         }\n-        \n+\n         return ((Comparable<K>)o1).compareTo(o2);\n     }\n-    \n-    /** \n+\n+    /**\n      * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}\n      */\n     static boolean isOutOfBoundsIndex(final int bitIndex) {\n         return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n     }\n \n-    /** \n+    /**\n      * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}\n      */\n     static boolean isEqualBitKey(final int bitIndex) {\n         return bitIndex == EQUAL_BIT_KEY;\n     }\n \n-    /** \n-     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY} \n+    /**\n+     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}\n      */\n     static boolean isNullBitKey(final int bitIndex) {\n         return bitIndex == NULL_BIT_KEY;\n     }\n \n-    /** \n-     * Returns true if the given bitIndex is valid. Indices \n-     * are considered valid if they're between 0 and \n+    /**\n+     * Returns true if the given bitIndex is valid. Indices\n+     * are considered valid if they're between 0 and\n      * {@link Integer#MAX_VALUE}\n      */\n     static boolean isValidBitIndex(final int bitIndex) {\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractTrie.java\n import org.apache.commons.collections4.Trie;\n \n /**\n- * This class provides some basic {@link Trie} functionality and \n+ * This class provides some basic {@link Trie} functionality and\n  * utility methods for actual {@link Trie} implementations.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n-abstract class AbstractTrie<K, V> extends AbstractMap<K, V> \n+abstract class AbstractTrie<K, V> extends AbstractMap<K, V>\n         implements Trie<K, V>, Serializable {\n-    \n+\n     private static final long serialVersionUID = 5826987063535505652L;\n \n     // TODO Privatise fields?\n \n     /**\n-     * The {@link KeyAnalyzer} that's being used to build the \n+     * The {@link KeyAnalyzer} that's being used to build the\n      * PATRICIA {@link Trie}.\n      */\n     protected final KeyAnalyzer<? super K> keyAnalyzer;\n-    \n-    /** \n+\n+    /**\n      * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n      */\n     public AbstractTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n         if (keyAnalyzer == null) {\n             throw new NullPointerException(\"keyAnalyzer\");\n         }\n-        \n+\n         this.keyAnalyzer = keyAnalyzer;\n     }\n-    \n+\n     /**\n      * Returns the {@link KeyAnalyzer} that constructed the {@link Trie}.\n      */\n     public KeyAnalyzer<? super K> getKeyAnalyzer() {\n         return keyAnalyzer;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         }\n         return entry.getKey();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         }\n         return entry.getValue();\n     }\n-    \n+\n     @Override\n     public String toString() {\n         final StringBuilder buffer = new StringBuilder();\n         buffer.append(\"}\\n\");\n         return buffer.toString();\n     }\n-    \n+\n     /**\n      * A utility method to cast keys. It actually doesn't\n      * cast anything. It's just fooling the compiler!\n     final K castKey(final Object key) {\n         return (K)key;\n     }\n-    \n+\n     /**\n      * Returns the length of the given key in bits\n-     * \n+     *\n      * @see KeyAnalyzer#lengthInBits(Object)\n      */\n     final int lengthInBits(final K key) {\n         if (key == null) {\n             return 0;\n         }\n-        \n+\n         return keyAnalyzer.lengthInBits(key);\n     }\n-    \n+\n     /**\n      * Returns the number of bits per element in the key\n-     * \n+     *\n      * @see KeyAnalyzer#bitsPerElement()\n      */\n     final int bitsPerElement() {\n         return keyAnalyzer.bitsPerElement();\n     }\n-    \n-    /**\n-     * Returns whether or not the given bit on the \n+\n+    /**\n+     * Returns whether or not the given bit on the\n      * key is set or false if the key is null.\n-     * \n+     *\n      * @see KeyAnalyzer#isBitSet(Object, int, int)\n      */\n     final boolean isBitSet(final K key, final int bitIndex, final int lengthInBits) {\n         }\n         return keyAnalyzer.isBitSet(key, bitIndex, lengthInBits);\n     }\n-    \n+\n     /**\n      * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}\n      */\n     final int bitIndex(final K key, final K foundKey) {\n-        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key), \n+        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key),\n                 foundKey, 0, lengthInBits(foundKey));\n     }\n-    \n+\n     /**\n      * An utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n      */\n         } else if (other == null) {\n             return false;\n         }\n-        \n+\n         return keyAnalyzer.compare(key, other) == 0;\n     }\n-    \n+\n     /**\n      * Returns true if both values are either null or equal\n      */\n     static boolean compare(final Object a, final Object b) {\n         return a == null ? b == null : a.equals(b);\n     }\n-    \n+\n     /**\n      * A basic implementation of {@link Entry}\n      */\n     abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable {\n-        \n+\n         private static final long serialVersionUID = -944364551314110330L;\n \n         protected K key;\n-        \n+\n         protected V value;\n-        \n+\n         private final int hashCode;\n-        \n+\n         public BasicEntry(final K key) {\n             this.key = key;\n             this.hashCode = key != null ? key.hashCode() : 0;\n         }\n-        \n+\n         public BasicEntry(final K key, final V value) {\n             this.key = key;\n             this.value = value;\n-            \n+\n             this.hashCode = (key != null ? key.hashCode() : 0)\n                     ^ (value != null ? value.hashCode() : 0);\n         }\n-        \n+\n         /**\n          * Replaces the current key and value with the provided\n          * key &amp; value\n             this.key = key;\n             return setValue(value);\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public K getKey() {\n             return key;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             this.value = value;\n             return previous;\n         }\n-        \n+\n         @Override\n         public int hashCode() {\n             return hashCode;\n         }\n-        \n+\n         @Override\n         public boolean equals(final Object o) {\n             if (o == this) {\n             } else if (!(o instanceof Map.Entry)) {\n                 return false;\n             }\n-            \n+\n             final Map.Entry<?, ?> other = (Map.Entry<?, ?>)o;\n-            if (compare(key, other.getKey()) \n+            if (compare(key, other.getKey())\n                     && compare(value, other.getValue())) {\n                 return true;\n             }\n             return false;\n         }\n-        \n+\n         @Override\n         public String toString() {\n             return key + \"=\" + value;\n--- a/src/main/java/org/apache/commons/collections4/trie/ByteArrayKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/ByteArrayKeyAnalyzer.java\n \n /**\n  * A {@link KeyAnalyzer} for byte[]s.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class ByteArrayKeyAnalyzer extends AbstractKeyAnalyzer<byte[]> {\n-    \n+\n     private static final long serialVersionUID = 7382825097492285877L;\n \n     /**\n      * A singleton instance of {@link ByteArrayKeyAnalyzer}\n      */\n-    public static final ByteArrayKeyAnalyzer INSTANCE \n+    public static final ByteArrayKeyAnalyzer INSTANCE\n         = new ByteArrayKeyAnalyzer(Integer.MAX_VALUE);\n-    \n+\n     /**\n      * The length of an {@link Byte} in bits\n      */\n     public static final int LENGTH = Byte.SIZE;\n-    \n+\n     /**\n      * A bit mask where the first bit is 1 and the others are zero\n      */\n     private static final int MSB = 0x80;\n-    \n+\n     /**\n      * A place holder for null\n      */\n     private static final byte[] NULL = new byte[0];\n-    \n+\n     /**\n      * The maximum length of a key in bits\n      */\n     private final int maxLengthInBits;\n-    \n+\n     public ByteArrayKeyAnalyzer(final int maxLengthInBits) {\n         if (maxLengthInBits < 0) {\n             throw new IllegalArgumentException(\n                     \"maxLengthInBits=\" + maxLengthInBits);\n         }\n-        \n+\n         this.maxLengthInBits = maxLengthInBits;\n     }\n-    \n+\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n     public int getMaxLengthInBits() {\n         return maxLengthInBits;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public int bitsPerElement() {\n         return LENGTH;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public int lengthInBits(final byte[] key) {\n         return key != null ? key.length * bitsPerElement() : 0;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public boolean isBitSet(final byte[] key, final int bitIndex, final int lengthInBits) {\n-        if (key == null) {     \n+        if (key == null) {\n             return false;\n         }\n-        \n+\n         final int prefix = maxLengthInBits - lengthInBits;\n         final int keyBitIndex = bitIndex - prefix;\n-        \n+\n         if (keyBitIndex >= lengthInBits || keyBitIndex < 0) {\n             return false;\n         }\n-        \n+\n         final int index = keyBitIndex / LENGTH;\n         final int bit = keyBitIndex % LENGTH;\n         return (key[index] & mask(bit)) != 0;\n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(final byte[] key, final int offsetInBits, final int lengthInBits, \n+    public int bitIndex(final byte[] key, final int offsetInBits, final int lengthInBits,\n             byte[] other, final int otherOffsetInBits, final int otherLengthInBits) {\n-        \n+\n         if (other == null) {\n             other = NULL;\n         }\n-        \n+\n         boolean allNull = true;\n         final int length = Math.max(lengthInBits, otherLengthInBits);\n         final int prefix = maxLengthInBits - length;\n-        \n+\n         if (prefix < 0) {\n             return KeyAnalyzer.OUT_OF_BOUNDS_BIT_KEY;\n         }\n-        \n+\n         for (int i = 0; i < length; i++) {\n             final int index = prefix + offsetInBits + i;\n             final boolean value = isBitSet(key, index, lengthInBits);\n-                \n+\n             if (value) {\n                 allNull = false;\n             }\n-            \n+\n             final int otherIndex = prefix + otherOffsetInBits + i;\n             final boolean otherValue = isBitSet(other, otherIndex, otherLengthInBits);\n-            \n+\n             if (value != otherValue) {\n                 return index;\n             }\n         }\n-        \n+\n         if (allNull) {\n             return KeyAnalyzer.NULL_BIT_KEY;\n         }\n-        \n+\n         return KeyAnalyzer.EQUAL_BIT_KEY;\n     }\n-    \n-    /**\n-     * {@inheritDoc}\n-     */\n-    public boolean isPrefix(final byte[] prefix, final int offsetInBits, \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final byte[] prefix, final int offsetInBits,\n             final int lengthInBits, final byte[] key) {\n-        \n+\n         final int keyLength = lengthInBits(key);\n         if (lengthInBits > keyLength) {\n             return false;\n         }\n-        \n+\n         final int elements = lengthInBits - offsetInBits;\n         for (int i = 0; i < elements; i++) {\n-            if (isBitSet(prefix, i+offsetInBits, lengthInBits) \n+            if (isBitSet(prefix, i+offsetInBits, lengthInBits)\n                     != isBitSet(key, i, keyLength)) {\n                 return false;\n             }\n         }\n-        \n+\n         return true;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         } else if (o2 == null) {\n             return 1;\n         }\n-        \n+\n         if (o1.length != o2.length) {\n             return o1.length - o2.length;\n         }\n-        \n+\n         for (int i = 0; i < o1.length; i++) {\n             final int diff = (o1[i] & 0xFF) - (o2[i] & 0xFF);\n             if (diff != 0) {\n--- a/src/main/java/org/apache/commons/collections4/trie/ByteKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/ByteKeyAnalyzer.java\n \n /**\n  * A {@link KeyAnalyzer} for {@link Byte}s.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class ByteKeyAnalyzer extends AbstractKeyAnalyzer<Byte> {\n-    \n+\n     private static final long serialVersionUID = 3395803342983289829L;\n \n     /**\n      * A singleton instance of {@link ByteKeyAnalyzer}\n      */\n     public static final ByteKeyAnalyzer INSTANCE = new ByteKeyAnalyzer();\n-    \n+\n     /**\n      * The length of an {@link Byte} in bits\n      */\n     public static final int LENGTH = Byte.SIZE;\n-    \n+\n     /**\n      * A bit mask where the first bit is 1 and the others are zero\n      */\n     private static final int MSB = 0x80;\n-    \n+\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n     public int bitsPerElement() {\n         return 1;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(final Byte key, final int offsetInBits, final int lengthInBits, \n+    public int bitIndex(final Byte key, final int offsetInBits, final int lengthInBits,\n             final Byte other, final int otherOffsetInBits, final int otherLengthInBits) {\n-        \n+\n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n-            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n-        \n+\n         final byte keyValue = key.byteValue();\n         if (keyValue == 0) {\n             return NULL_BIT_KEY;\n         }\n \n         final byte otherValue = other != null ? other.byteValue() : 0;\n-        \n+\n         if (keyValue != otherValue) {\n             final int xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 }\n             }\n         }\n-        \n+\n         return KeyAnalyzer.EQUAL_BIT_KEY;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(final Byte prefix, final int offsetInBits, \n+    public boolean isPrefix(final Byte prefix, final int offsetInBits,\n             final int lengthInBits, final Byte key) {\n-        \n+\n         final int value1 = prefix.byteValue() << offsetInBits;\n         final int value2 = key.byteValue();\n-        \n+\n         int mask = 0;\n         for (int i = 0; i < lengthInBits; i++) {\n             mask |= 0x1 << i;\n         }\n-        \n+\n         return (value1 & mask) == (value2 & mask);\n     }\n }\n--- a/src/main/java/org/apache/commons/collections4/trie/CharArrayKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/CharArrayKeyAnalyzer.java\n \n /**\n  * An {@link KeyAnalyzer} for {@code char[]}s.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class CharArrayKeyAnalyzer extends AbstractKeyAnalyzer<char[]> {\n-    \n+\n     private static final long serialVersionUID = -8167897361549463457L;\n \n     /**\n--- a/src/main/java/org/apache/commons/collections4/trie/IntegerKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/IntegerKeyAnalyzer.java\n \n /**\n  * A {@link KeyAnalyzer} for {@link Integer}s.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class IntegerKeyAnalyzer extends AbstractKeyAnalyzer<Integer> {\n-    \n+\n     private static final long serialVersionUID = 4928508653722068982L;\n-    \n+\n     /**\n      * A singleton instance of {@link IntegerKeyAnalyzer}\n      */\n     public static final IntegerKeyAnalyzer INSTANCE = new IntegerKeyAnalyzer();\n-    \n+\n     /**\n      * The length of an {@link Integer} in bits\n      */\n     public static final int LENGTH = Integer.SIZE;\n-    \n+\n     /**\n      * A bit mask where the first bit is 1 and the others are zero\n      */\n     private static final int MSB = 0x80000000;\n-    \n+\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n     public int bitsPerElement() {\n         return 1;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(final Integer key, final int offsetInBits, final int lengthInBits, \n+    public int bitIndex(final Integer key, final int offsetInBits, final int lengthInBits,\n             final Integer other, final int otherOffsetInBits, final int otherLengthInBits) {\n-        \n+\n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n-            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n-        \n+\n         final int keyValue = key.intValue();\n         if (keyValue == 0) {\n             return NULL_BIT_KEY;\n         }\n \n         final int otherValue = other != null ? other.intValue() : 0;\n-        \n+\n         if (keyValue != otherValue) {\n             final int xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 }\n             }\n         }\n-        \n+\n         return KeyAnalyzer.EQUAL_BIT_KEY;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(final Integer prefix, final int offsetInBits, \n+    public boolean isPrefix(final Integer prefix, final int offsetInBits,\n             final int lengthInBits, final Integer key) {\n-        \n+\n         final int value1 = prefix.intValue() << offsetInBits;\n         final int value2 = key.intValue();\n-        \n+\n         int mask = 0;\n         for (int i = 0; i < lengthInBits; i++) {\n             mask |= 0x1 << i;\n         }\n-        \n+\n         return (value1 & mask) == (value2 & mask);\n     }\n }\n--- a/src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java\n import java.io.Serializable;\n import java.util.Comparator;\n \n-/** \n- * Defines the interface to analyze {@link org.apache.commons.collections4.Trie Trie} keys on a bit level. \n- * {@link KeyAnalyzer}'s methods return the length of the key in bits, \n- * whether or not a bit is set, and bits per element in the key. \n+/**\n+ * Defines the interface to analyze {@link org.apache.commons.collections4.Trie Trie} keys on a bit level.\n+ * {@link KeyAnalyzer}'s methods return the length of the key in bits,\n+ * whether or not a bit is set, and bits per element in the key.\n  * <p>\n- * Additionally, a method determines if a key is a prefix of another \n- * key and returns the bit index where one key is different from another \n- * key (if the key and found key are equal than the return value is \n+ * Additionally, a method determines if a key is a prefix of another\n+ * key and returns the bit index where one key is different from another\n+ * key (if the key and found key are equal than the return value is\n  * {@link #EQUAL_BIT_KEY}).\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public interface KeyAnalyzer<K> extends Comparator<K>, Serializable {\n-    \n-    /** \n-     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} \n-     * if key's bits are all 0 \n+\n+    /**\n+     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n+     * if key's bits are all 0\n      */\n     public static final int NULL_BIT_KEY = -1;\n-    \n-    /** \n-     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} \n-     * if key and found key are equal. This is a very very specific case \n+\n+    /**\n+     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n+     * if key and found key are equal. This is a very very specific case\n      * and shouldn't happen on a regular basis\n      */\n     public static final int EQUAL_BIT_KEY = -2;\n-    \n+\n     public static final int OUT_OF_BOUNDS_BIT_KEY = -3;\n-    \n+\n     /**\n      * Returns the number of bits per element in the key.\n      * This is only useful for variable-length keys, such as Strings.\n-     * \n+     *\n      * @return the number of bits per element\n      */\n     public int bitsPerElement();\n-    \n-    /** \n+\n+    /**\n      * Returns the length of the Key in bits.\n-     * \n+     *\n      * @param key  the key\n      * @return the bit length of the key\n      */\n     public int lengthInBits(K key);\n-    \n-    /** \n+\n+    /**\n      * Returns whether or not a bit is set.\n      */\n     public boolean isBitSet(K key, int bitIndex, int lengthInBits);\n-    \n+\n     /**\n      * Returns the n-th different bit between key and found. This starts the comparison in\n      * key at 'keyStart' and goes for 'keyLength' bits, and compares to the found key starting\n      */\n     public int bitIndex(K key, int offsetInBits, int lengthInBits,\n                         K other, int otherOffsetInBits, int otherLengthInBits);\n-    \n+\n     /**\n      * Determines whether or not the given prefix (from offset to length) is a prefix of the given key.\n      */\n--- a/src/main/java/org/apache/commons/collections4/trie/LongKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/LongKeyAnalyzer.java\n \n /**\n  * A {@link KeyAnalyzer} for {@link Long}s.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class LongKeyAnalyzer extends AbstractKeyAnalyzer<Long> {\n-    \n+\n     private static final long serialVersionUID = -4119639247588227409L;\n \n     /**\n      * A singleton instance of {@link LongKeyAnalyzer}\n      */\n     public static final LongKeyAnalyzer INSTANCE = new LongKeyAnalyzer();\n-    \n+\n     /**\n      * The length of an {@link Long} in bits\n      */\n     public static final int LENGTH = Long.SIZE;\n-    \n+\n     /**\n      * A bit mask where the first bit is 1 and the others are zero\n      */\n     private static final long MSB = 0x8000000000000000L;\n-    \n+\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n     public int bitsPerElement() {\n         return 1;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(final Long key, final int offsetInBits, final int lengthInBits, \n+    public int bitIndex(final Long key, final int offsetInBits, final int lengthInBits,\n             final Long other, final int otherOffsetInBits, final int otherLengthInBits) {\n-        \n+\n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n-            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n-        \n+\n         final long keyValue = key.longValue();\n         if (keyValue == 0L) {\n             return NULL_BIT_KEY;\n         }\n \n         final long otherValue = other != null ? other.longValue() : 0L;\n-        \n+\n         if (keyValue != otherValue) {\n             final long xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 }\n             }\n         }\n-        \n+\n         return KeyAnalyzer.EQUAL_BIT_KEY;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(final Long prefix, final int offsetInBits, \n+    public boolean isPrefix(final Long prefix, final int offsetInBits,\n             final int lengthInBits, final Long key) {\n-        \n+\n         final long value1 = prefix.longValue() << offsetInBits;\n         final long value2 = key.longValue();\n-        \n+\n         long mask = 0L;\n         for (int i = 0; i < lengthInBits; i++) {\n             mask |= 0x1L << i;\n         }\n-        \n+\n         return (value1 & mask) == (value2 & mask);\n     }\n }\n--- a/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n \n /**\n  * <h3>PATRICIA {@link Trie}</h3>\n- *  \n+ *\n  * <i>Practical Algorithm to Retrieve Information Coded in Alphanumeric</i>\n- * \n- * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing \n- * all data at the edges of the {@link Trie} (and having empty internal nodes), \n- * PATRICIA stores data in every node. This allows for very efficient traversal, \n- * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)} \n- * operations. All operations are performed at worst in O(K) time, where K \n- * is the number of bits in the largest item in the tree. In practice, \n- * operations actually take O(A(K)) time, where A(K) is the average number of \n+ *\n+ * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing\n+ * all data at the edges of the {@link Trie} (and having empty internal nodes),\n+ * PATRICIA stores data in every node. This allows for very efficient traversal,\n+ * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)}\n+ * operations. All operations are performed at worst in O(K) time, where K\n+ * is the number of bits in the largest item in the tree. In practice,\n+ * operations actually take O(A(K)) time, where A(K) is the average number of\n  * bits of all items in the tree.\n- * \n+ *\n  * <p>Most importantly, PATRICIA requires very few comparisons to keys while\n- * doing any operation. While performing a lookup, each comparison (at most \n- * K of them, described above) will perform a single bit comparison against \n+ * doing any operation. While performing a lookup, each comparison (at most\n+ * K of them, described above) will perform a single bit comparison against\n  * the given key, instead of comparing the entire key to another key.\n- * \n- * <p>The {@link Trie} can return operations in lexicographical order using the \n- * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The \n- * {@link Trie} can also scan for items that are 'bitwise' (using an XOR \n- * metric) by the 'select' method. Bitwise closeness is determined by the \n- * {@link KeyAnalyzer} returning true or false for a bit being set or not in \n+ *\n+ * <p>The {@link Trie} can return operations in lexicographical order using the\n+ * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The\n+ * {@link Trie} can also scan for items that are 'bitwise' (using an XOR\n+ * metric) by the 'select' method. Bitwise closeness is determined by the\n+ * {@link KeyAnalyzer} returning true or false for a bit being set or not in\n  * a given key.\n- * \n- * <p>This PATRICIA {@link Trie} supports both variable length & fixed length \n- * keys. Some methods, such as {@link #getPrefixedBy(Object)} are suited only \n- * to variable length keys, whereas {@link #getPrefixedByBits(Object, int)} is \n+ *\n+ * <p>This PATRICIA {@link Trie} supports both variable length & fixed length\n+ * keys. Some methods, such as {@link #getPrefixedBy(Object)} are suited only\n+ * to variable length keys, whereas {@link #getPrefixedByBits(Object, int)} is\n  * suited to fixed-size keys.\n- * \n- * <p>Any methods here that take an {@link Object} argument may throw a \n- * {@link ClassCastException} if the method is expecting an instance of K \n+ *\n+ * <p>Any methods here that take an {@link Object} argument may throw a\n+ * {@link ClassCastException} if the method is expecting an instance of K\n  * and it isn't K.\n- * \n+ *\n  * @see <a href=\"http://en.wikipedia.org/wiki/Radix_tree\">Radix Tree</a>\n  * @see <a href=\"http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA\">PATRICIA</a>\n  * @see <a href=\"http://www.imperialviolet.org/binary/critbit.pdf\">Crit-Bit Tree</a>\n  * @version $Id$\n  */\n public class PatriciaTrie<K, V> extends PatriciaTrieBase<K, V> implements Trie<K, V> {\n-    \n+\n     private static final long serialVersionUID = 4446367780901817838L;\n \n     public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n             final Map<? extends K, ? extends V> m) {\n         super(keyAnalyzer, m);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public Comparator<? super K> comparator() {\n         return keyAnalyzer;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n         return getPrefixedByBits(key, 0, lengthInBits);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         }\n         return null;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * The view that this returns is optimized to have a very efficient\n-     * {@link Iterator}. The {@link SortedMap#firstKey()}, \n-     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must \n-     * iterate over all possible values in order to determine the results. \n-     * This information is cached until the PATRICIA {@link Trie} changes. \n-     * All other methods (except {@link Iterator}) must compare the given \n-     * key to the prefix to ensure that it is within the range of the view.  \n-     * The {@link Iterator}'s remove method must also relocate the subtree \n-     * that contains the prefixes if the entry holding the subtree is \n+     * {@link Iterator}. The {@link SortedMap#firstKey()},\n+     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must\n+     * iterate over all possible values in order to determine the results.\n+     * This information is cached until the PATRICIA {@link Trie} changes.\n+     * All other methods (except {@link Iterator}) must compare the given\n+     * key to the prefix to ensure that it is within the range of the view.\n+     * The {@link Iterator}'s remove method must also relocate the subtree\n+     * that contains the prefixes if the entry holding the subtree is\n      * removed or changes. Changing the subtree takes O(K) time.\n      */\n     public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n-        \n+\n         final int offsetLength = offsetInBits + lengthInBits;\n         if (offsetLength > lengthInBits(key)) {\n-            throw new IllegalArgumentException(offsetInBits + \" + \" \n+            throw new IllegalArgumentException(offsetInBits + \" + \"\n                     + lengthInBits + \" > \" + lengthInBits(key));\n         }\n-        \n+\n         if (offsetLength == 0) {\n             return this;\n         }\n-        \n+\n         return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      */\n     public SortedMap<K, V> tailMap(final K fromKey) {\n         return new RangeEntryMap(fromKey, null);\n-    } \n-    \n+    }\n+\n     /**\n      * Returns an entry strictly higher than the given key,\n      * or null if no such entry exists.\n      */\n     TrieEntry<K,V> higherEntry(final K key) {\n         // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined \n+        //       tree.  (We do it here because there are other well-defined\n         //       functions to perform the search.)\n         final int lengthInBits = lengthInBits(key);\n-        \n+\n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n                 // If data in root, and more after -- return it.\n                 return firstEntry();\n             }\n         }\n-        \n+\n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return nextEntry(found);\n         }\n-        \n+\n         final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n         // we should have exited above.\n         throw new IllegalStateException(\"invalid lookup: \" + key);\n     }\n-    \n+\n     /**\n      * Returns a key-value mapping associated with the least key greater\n      * than or equal to the given key, or null if there is no such key.\n         // These steps ensure that the returned value is either the\n         // entry for the key itself, or the first entry directly after\n         // the key.\n-        \n+\n         // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined \n+        //       tree.  (We do it here because there are other well-defined\n         //       functions to perform the search.)\n         final int lengthInBits = lengthInBits(key);\n-        \n+\n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n                 return root;\n                 return firstEntry();\n             }\n         }\n-        \n+\n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return found;\n         }\n-        \n+\n         final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n         // we should have exited above.\n         throw new IllegalStateException(\"invalid lookup: \" + key);\n     }\n-    \n+\n     /**\n      * Returns a key-value mapping associated with the greatest key\n      * strictly less than the given key, or null if there is no such key.\n         //\n         // These steps ensure that the returned value is always just before\n         // the key or null (if there was nothing before it).\n-        \n+\n         // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined \n+        //       tree.  (We do it here because there are other well-defined\n         //       functions to perform the search.)\n         final int lengthInBits = lengthInBits(key);\n-        \n+\n         if (lengthInBits == 0) {\n             return null; // there can never be anything before root.\n         }\n-        \n+\n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return previousEntry(found);\n         }\n-        \n+\n         final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n         // we should have exited above.\n         throw new IllegalStateException(\"invalid lookup: \" + key);\n     }\n-    \n+\n     /**\n      * Returns a key-value mapping associated with the greatest key\n      * less than or equal to the given key, or null if there is no such key.\n      */\n-    TrieEntry<K,V> floorEntry(final K key) {        \n+    TrieEntry<K,V> floorEntry(final K key) {\n         // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined \n+        //       tree.  (We do it here because there are other well-defined\n         //       functions to perform the search.)\n         final int lengthInBits = lengthInBits(key);\n-        \n+\n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n                 return root;\n                 return null;\n             }\n         }\n-        \n+\n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return found;\n         }\n-        \n+\n         final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n         // we should have exited above.\n         throw new IllegalStateException(\"invalid lookup: \" + key);\n     }\n-    \n+\n     /**\n      * Finds the subtree that contains the prefix.\n-     * \n+     *\n      * This is very similar to getR but with the difference that\n      * we stop the lookup if h.bitIndex > lengthInBits.\n      */\n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while(true) {\n-            if (current.bitIndex <= path.bitIndex \n+            if (current.bitIndex <= path.bitIndex\n                     || lengthInBits < current.bitIndex) {\n                 break;\n             }\n-            \n+\n             path = current;\n-            if (!isBitSet(prefix, offsetInBits + current.bitIndex, \n+            if (!isBitSet(prefix, offsetInBits + current.bitIndex,\n                     offsetInBits + lengthInBits)) {\n                 current = current.left;\n             } else {\n                 current = current.right;\n             }\n-        }        \n+        }\n \n         // Make sure the entry is valid for a subtree.\n         final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n-        \n+\n         // If entry is root, it can't be empty.\n         if (entry.isEmpty()) {\n             return null;\n         }\n-        \n+\n         final int endIndexInBits = offsetInBits + lengthInBits;\n-        \n+\n         // if root && length of root is less than length of lookup,\n         // there's nothing.\n         // (this prevents returning the whole subtree if root has an empty\n         if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n             return null;\n         }\n-        \n+\n         // Found key's length-th bit differs from our key\n         // which means it cannot be the prefix...\n-        if (isBitSet(prefix, endIndexInBits, endIndexInBits) \n+        if (isBitSet(prefix, endIndexInBits, endIndexInBits)\n                 != isBitSet(entry.key, lengthInBits, lengthInBits(entry.key))) {\n             return null;\n         }\n-        \n+\n         // ... or there are less than 'length' equal bits\n-        final int bitIndex = keyAnalyzer.bitIndex(prefix, offsetInBits, \n+        final int bitIndex = keyAnalyzer.bitIndex(prefix, offsetInBits,\n                 lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));\n-        \n+\n         if (bitIndex >= 0 && bitIndex < lengthInBits) {\n             return null;\n         }\n-        \n+\n         return entry;\n     }\n-    \n+\n     /**\n      * Returns the last entry the {@link Trie} is storing.\n-     * \n+     *\n      * <p>This is implemented by going always to the right until\n      * we encounter a valid uplink. That uplink is the last key.\n      */\n     TrieEntry<K, V> lastEntry() {\n         return followRight(root.left);\n     }\n-    \n+\n     /**\n      * Traverses down the right path until it finds an uplink.\n      */\n         if (node.right == null) {\n             return null;\n         }\n-        \n+\n         // Go as far right as possible, until we encounter an uplink.\n         while (node.right.bitIndex > node.bitIndex) {\n             node = node.right;\n         }\n-        \n+\n         return node.right;\n     }\n-    \n+\n     /**\n      * Returns the node lexicographically before the given node (or null if none).\n-     * \n+     *\n      * This follows four simple branches:\n      *  - If the uplink that returned us was a right uplink:\n      *      - If predecessor's left is a valid uplink from predecessor, return it.\n      *      - Else, follow the right path from the predecessor's left.\n      *  - If the uplink that returned us was a left uplink:\n-     *      - Loop back through parents until we encounter a node where \n+     *      - Loop back through parents until we encounter a node where\n      *        node != node.parent.left.\n      *          - If node.parent.left is uplink from node.parent:\n      *              - If node.parent.left is not root, return it.\n      *              - If it is root & root isEmpty, return null.\n      *              - If it is root & root !isEmpty, return root.\n      *          - If node.parent.left is not uplink from node.parent:\n-     *              - Follow right path for first right child from node.parent.left   \n-     * \n+     *              - Follow right path for first right child from node.parent.left\n+     *\n      * @param start\n      */\n     TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n         if (start.predecessor == null) {\n             throw new IllegalArgumentException(\"must have come from somewhere!\");\n         }\n-        \n+\n         if (start.predecessor.right == start) {\n             if (isValidUplink(start.predecessor.left, start.predecessor)) {\n                 return start.predecessor.left;\n             while (node.parent != null && node == node.parent.left) {\n                 node = node.parent;\n             }\n-            \n+\n             if (node.parent == null) { // can be null if we're looking up root.\n                 return null;\n             }\n-            \n+\n             if (isValidUplink(node.parent.left, node.parent)) {\n                 if (node.parent.left == root) {\n                     if (root.isEmpty()) {\n                     } else {\n                         return root;\n                     }\n-                    \n+\n                 } else {\n                     return node.parent.left;\n                 }\n             }\n         }\n     }\n-    \n+\n     /**\n      * Returns the entry lexicographically after the given entry.\n      * If the given entry is null, returns the first node.\n-     * \n+     *\n      * This will traverse only within the subtree.  If the given node\n      * is not within the subtree, this will have undefined results.\n      */\n-    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, \n+    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n             final TrieEntry<K, V> parentOfSubtree) {\n         if (node == null) {\n             return firstEntry();\n             return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n         }\n     }\n-    \n+\n     /**\n      * A range view of the {@link Trie}\n      */\n-    private abstract class RangeMap extends AbstractMap<K, V> \n+    private abstract class RangeMap extends AbstractMap<K, V>\n             implements SortedMap<K, V> {\n \n         /**\n         private transient volatile Set<Map.Entry<K, V>> entrySet;\n \n         /**\n-         * Creates and returns an {@link #entrySet()} \n+         * Creates and returns an {@link #entrySet()}\n          * view of the {@link RangeMap}\n          */\n         protected abstract Set<Map.Entry<K, V>> createEntrySet();\n          * Returns the FROM Key\n          */\n         protected abstract K getFromKey();\n-        \n+\n         /**\n          * Whether or not the {@link #getFromKey()} is in the range\n          */\n         protected abstract boolean isFromInclusive();\n-        \n+\n         /**\n          * Returns the TO Key\n          */\n         protected abstract K getToKey();\n-        \n+\n         /**\n          * Whether or not the {@link #getToKey()} is in the range\n          */\n         protected abstract boolean isToInclusive();\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n                         \"ToKey is out of range: \" + toKey);\n             }\n \n-            return createRangeMap(fromKey, isFromInclusive(), \n+            return createRangeMap(fromKey, isFromInclusive(),\n                     toKey, isToInclusive());\n         }\n \n                         \"ToKey is out of range: \" + toKey);\n             }\n \n-            return createRangeMap(getFromKey(), isFromInclusive(), \n+            return createRangeMap(getFromKey(), isFromInclusive(),\n                     toKey, isToInclusive());\n         }\n \n                         \"FromKey is out of range: \" + fromKey);\n             }\n \n-            return createRangeMap(fromKey, isFromInclusive(), \n+            return createRangeMap(fromKey, isFromInclusive(),\n                     getToKey(), isToInclusive());\n         }\n \n         }\n \n         /**\n-         * Returns true if the provided key is in the FROM range \n+         * Returns true if the provided key is in the FROM range\n          * of the {@link RangeMap}\n          */\n         protected boolean inFromRange(final K key, final boolean forceInclusive) {\n         }\n \n         /**\n-         * Returns true if the provided key is in the TO range \n+         * Returns true if the provided key is in the TO range\n          * of the {@link RangeMap}\n          */\n         protected boolean inToRange(final K key, final boolean forceInclusive) {\n         protected abstract SortedMap<K, V> createRangeMap(K fromKey,\n                 boolean fromInclusive, K toKey, boolean toInclusive);\n     }\n-   \n+\n    /**\n     * A {@link RangeMap} that deals with {@link Entry}s\n     */\n    private class RangeEntryMap extends RangeMap {\n-       \n-       /** \n-        * The key to start from, null if the beginning. \n+\n+       /**\n+        * The key to start from, null if the beginning.\n         */\n        private final K fromKey;\n-       \n-       /** \n-        * The key to end at, null if till the end. \n+\n+       /**\n+        * The key to end at, null if till the end.\n         */\n        private final K toKey;\n-       \n-       /** \n-        * Whether or not the 'from' is inclusive. \n+\n+       /**\n+        * Whether or not the 'from' is inclusive.\n         */\n        private final boolean fromInclusive;\n-       \n-       /** \n-        * Whether or not the 'to' is inclusive. \n+\n+       /**\n+        * Whether or not the 'to' is inclusive.\n         */\n        private final boolean toInclusive;\n-       \n+\n        /**\n         * Creates a {@link RangeEntryMap} with the fromKey included and\n         * the toKey excluded from the range\n        protected RangeEntryMap(final K fromKey, final K toKey) {\n            this(fromKey, true, toKey, false);\n        }\n-       \n+\n        /**\n         * Creates a {@link RangeEntryMap}\n         */\n-       protected RangeEntryMap(final K fromKey, final boolean fromInclusive, \n+       protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n                final K toKey, final boolean toInclusive) {\n-           \n+\n            if (fromKey == null && toKey == null) {\n                throw new IllegalArgumentException(\"must have a from or to!\");\n            }\n-           \n-           if (fromKey != null && toKey != null \n+\n+           if (fromKey != null && toKey != null\n                    && keyAnalyzer.compare(fromKey, toKey) > 0) {\n                throw new IllegalArgumentException(\"fromKey > toKey\");\n            }\n-           \n+\n            this.fromKey = fromKey;\n            this.fromInclusive = fromInclusive;\n            this.toKey = toKey;\n            this.toInclusive = toInclusive;\n        }\n-       \n+\n        /**\n         * {@inheritDoc}\n         */\n                    e = higherEntry(fromKey);\n                }\n            }\n-           \n+\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || toKey != null && !inToRange(first, false)) {\n                throw new NoSuchElementException();\n                    e = lowerEntry(toKey);\n                }\n            }\n-           \n+\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || fromKey != null && !inFromRange(last, false)) {\n                throw new NoSuchElementException();\n            }\n            return last;\n        }\n-       \n+\n        /**\n         * {@inheritDoc}\n         */\n        protected Set<Entry<K, V>> createEntrySet() {\n            return new RangeEntrySet(this);\n        }\n-       \n+\n        /**\n         * {@inheritDoc}\n         */\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n    }\n-   \n+\n     /**\n      * A {@link Set} view of a {@link RangeMap}\n      */\n             }\n             return false;\n         }\n-        \n-        /** \n-         * An {@link Iterator} for {@link RangeEntrySet}s. \n+\n+        /**\n+         * An {@link Iterator} for {@link RangeEntrySet}s.\n          */\n         private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n-            \n+\n             private final K excludedKey;\n \n             /**\n              * Creates a {@link EntryIterator}\n              */\n             private EntryIterator(\n-                    final TrieEntry<K,V> first, \n+                    final TrieEntry<K,V> first,\n                     final TrieEntry<K,V> last) {\n                 super(first);\n-                \n+\n                 this.excludedKey = last != null ? last.getKey() : null;\n             }\n \n                 if (next == null || compare(next.key, excludedKey)) {\n                     throw new NoSuchElementException();\n                 }\n-                \n+\n                 return nextEntry();\n             }\n         }\n-    }   \n-   \n-    /** \n-     * A submap used for prefix views over the {@link Trie}. \n+    }\n+\n+    /**\n+     * A submap used for prefix views over the {@link Trie}.\n      */\n     private class PrefixRangeMap extends RangeMap {\n-        \n+\n         private final K prefix;\n-        \n+\n         private final int offsetInBits;\n-        \n+\n         private final int lengthInBits;\n-        \n+\n         private K fromKey = null;\n-        \n+\n         private K toKey = null;\n-        \n+\n         private transient int expectedModCount = 0;\n-        \n+\n         private int size = -1;\n-        \n+\n         /**\n          * Creates a {@link PrefixRangeMap}\n          */\n             this.offsetInBits = offsetInBits;\n             this.lengthInBits = lengthInBits;\n         }\n-        \n+\n         /**\n          * This method does two things. It determinates the FROM\n          * and TO range of the {@link PrefixRangeMap} and the number\n-         * of elements in the range. This method must be called every \n+         * of elements in the range. This method must be called every\n          * time the {@link Trie} has changed.\n          */\n         private int fixup() {\n             if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount) {\n                 final Iterator<Map.Entry<K, V>> it = entrySet().iterator();\n                 size = 0;\n-                \n+\n                 Map.Entry<K, V> entry = null;\n                 if (it.hasNext()) {\n                     entry = it.next();\n                     size = 1;\n                 }\n-                \n+\n                 fromKey = entry == null ? null : entry.getKey();\n                 if (fromKey != null) {\n                     final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                     fromKey = prior == null ? null : prior.getKey();\n                 }\n-                \n+\n                 toKey = fromKey;\n-                \n+\n                 while (it.hasNext()) {\n                     ++size;\n                     entry = it.next();\n                 }\n-                \n+\n                 toKey = entry == null ? null : entry.getKey();\n-                \n+\n                 if (toKey != null) {\n                     entry = nextEntry((TrieEntry<K, V>)entry);\n                     toKey = entry == null ? null : entry.getKey();\n                 }\n-                \n+\n                 expectedModCount = PatriciaTrie.this.modCount;\n             }\n-            \n+\n             return size;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public K firstKey() {\n             fixup();\n-            \n+\n             Map.Entry<K,V> e = null;\n             if (fromKey == null) {\n                 e = firstEntry();\n             } else {\n                 e = higherEntry(fromKey);\n             }\n-            \n+\n             final K first = e != null ? e.getKey() : null;\n-            if (e == null || !keyAnalyzer.isPrefix(prefix, \n+            if (e == null || !keyAnalyzer.isPrefix(prefix,\n                     offsetInBits, lengthInBits, first)) {\n                 throw new NoSuchElementException();\n             }\n-            \n+\n             return first;\n         }\n \n          */\n         public K lastKey() {\n             fixup();\n-            \n+\n             Map.Entry<K,V> e = null;\n             if (toKey == null) {\n                 e = lastEntry();\n             } else {\n                 e = lowerEntry(toKey);\n             }\n-            \n+\n             final K last = e != null ? e.getKey() : null;\n-            if (e == null || !keyAnalyzer.isPrefix(prefix, \n+            if (e == null || !keyAnalyzer.isPrefix(prefix,\n                     offsetInBits, lengthInBits, last)) {\n                 throw new NoSuchElementException();\n             }\n-            \n+\n             return last;\n         }\n-        \n+\n         /**\n          * Returns true if this {@link PrefixRangeMap}'s key is a prefix\n          * of the provided key.\n         protected boolean inRange2(final K key) {\n             return inRange(key);\n         }\n-        \n+\n         /**\n          * Returns true if the provided Key is in the FROM range\n          * of the {@link PrefixRangeMap}\n         protected boolean inFromRange(final K key, final boolean forceInclusive) {\n             return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n         }\n-        \n+\n         /**\n          * Returns true if the provided Key is in the TO range\n          * of the {@link PrefixRangeMap}\n         protected boolean inToRange(final K key, final boolean forceInclusive) {\n             return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n         }\n     }\n-    \n+\n     /**\n      * A prefix {@link RangeEntrySet} view of the {@link Trie}\n      */\n     private final class PrefixRangeEntrySet extends RangeEntrySet {\n-        \n+\n         private final PrefixRangeMap delegate;\n-        \n+\n         private TrieEntry<K, V> prefixStart;\n-        \n+\n         private int expectedModCount = 0;\n-        \n+\n         /**\n          * Creates a {@link PrefixRangeEntrySet}\n          */\n             super(delegate);\n             this.delegate = delegate;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n                 prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                 expectedModCount = PatriciaTrie.this.modCount;\n             }\n-            \n+\n             if (prefixStart == null) {\n                 final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n                 return empty.iterator();\n                 return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n             }\n         }\n-        \n-        /** \n-         * An {@link Iterator} that holds a single {@link TrieEntry}. \n+\n+        /**\n+         * An {@link Iterator} that holds a single {@link TrieEntry}.\n          */\n         private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n-            \n+\n             private final TrieEntry<K, V> entry;\n-            \n+\n             private int hit = 0;\n-            \n+\n             public SingletonIterator(final TrieEntry<K, V> entry) {\n                 this.entry = entry;\n             }\n-            \n+\n             /**\n              * {@inheritDoc}\n              */\n                 if (hit != 0) {\n                     throw new NoSuchElementException();\n                 }\n-                \n+\n                 ++hit;\n                 return entry;\n             }\n                 if (hit != 1) {\n                     throw new IllegalStateException();\n                 }\n-                \n+\n                 ++hit;\n                 PatriciaTrie.this.removeEntry(entry);\n             }\n         }\n-        \n-        /** \n-         * An {@link Iterator} for iterating over a prefix search. \n+\n+        /**\n+         * An {@link Iterator} for iterating over a prefix search.\n          */\n         private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> {\n-            \n+\n             // values to reset the subtree if we remove it.\n-            private final K prefix; \n+            private final K prefix;\n             private final int offset;\n             private final int lengthInBits;\n             private boolean lastOne;\n-            \n+\n             private TrieEntry<K, V> subtree; // the subtree to search within\n-            \n+\n             /**\n-             * Starts iteration at the given entry & search only \n+             * Starts iteration at the given entry & search only\n              * within the given subtree.\n              */\n-            EntryIterator(final TrieEntry<K, V> startScan, final K prefix, \n+            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                     final int offset, final int lengthInBits) {\n                 subtree = startScan;\n                 next = PatriciaTrie.this.followLeft(startScan);\n                 }\n                 return entry;\n             }\n-            \n+\n             /**\n              * {@inheritDoc}\n              */\n             protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                 return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n             }\n-            \n+\n             /**\n              * {@inheritDoc}\n              */\n                 if (current == subtree) {\n                     needsFixing = true;\n                 }\n-                \n+\n                 super.remove();\n-                \n+\n                 // If the subtree changed its bitIndex or we\n                 // removed the old subtree, get a new one.\n                 if (bitIdx != subtree.bitIndex || needsFixing) {\n                     subtree = subtree(prefix, offset, lengthInBits);\n                 }\n-                \n+\n                 // If the subtree's bitIndex is less than the\n                 // length of our prefix, it's the last item\n                 // in the prefix tree.\n--- a/src/main/java/org/apache/commons/collections4/trie/PatriciaTrieBase.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrieBase.java\n /**\n  * This class implements the base PATRICIA algorithm and everything that\n  * is related to the {@link Map} interface.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n abstract class PatriciaTrieBase<K, V> extends AbstractTrie<K, V> {\n-    \n+\n     private static final long serialVersionUID = 5155253417231339498L;\n \n     /**\n-     * The root node of the {@link Trie}. \n+     * The root node of the {@link Trie}.\n      */\n     final TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n-    \n+\n     /**\n      * Each of these fields are initialized to contain an instance of the\n      * appropriate view the first time this view is requested. The views are\n     private transient volatile Set<K> keySet;\n     private transient volatile Collection<V> values;\n     private transient volatile Set<Map.Entry<K,V>> entrySet;\n-    \n+\n     /**\n      * The current size of the {@link Trie}\n      */\n     private int size = 0;\n-    \n+\n     /**\n      * The number of times this {@link Trie} has been modified.\n      * It's used to detect concurrent modifications and fail-fast\n      * the {@link Iterator}s.\n      */\n     transient int modCount = 0;\n-    \n+\n     public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer) {\n         super(keyAnalyzer);\n     }\n-    \n-    /**\n-     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given {@link KeyAnalyzer} \n-     * and initializes the {@link org.apache.commons.collections4.Trie Trie} with the values from the \n+\n+    /**\n+     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given {@link KeyAnalyzer}\n+     * and initializes the {@link org.apache.commons.collections4.Trie Trie} with the values from the\n      * provided {@link Map}.\n      */\n-    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer, \n+    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer,\n             final Map<? extends K, ? extends V> m) {\n         super(keyAnalyzer);\n-        \n+\n         if (m == null) {\n             throw new NullPointerException(\"m\");\n         }\n-        \n+\n         putAll(m);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         root.key = null;\n         root.bitIndex = -1;\n         root.value = null;\n-        \n+\n         root.parent = null;\n         root.left = root;\n         root.right = null;\n         root.predecessor = root;\n-        \n+\n         size = 0;\n         incrementModCount();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public int size() {\n         return size;\n     }\n-   \n+\n     /**\n      * A helper method to increment the {@link Trie} size\n      * and the modification counter.\n         size++;\n         incrementModCount();\n     }\n-    \n+\n     /**\n      * A helper method to decrement the {@link Trie} size\n      * and increment the modification counter.\n         size--;\n         incrementModCount();\n     }\n-    \n+\n     /**\n      * A helper method to increment the modification counter.\n      */\n     private void incrementModCount() {\n         ++modCount;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         if (key == null) {\n             throw new NullPointerException(\"Key cannot be null\");\n         }\n-        \n+\n         final int lengthInBits = lengthInBits(key);\n-        \n+\n         // The only place to store a key with a length\n         // of zero bits is the root node\n         if (lengthInBits == 0) {\n             }\n             return root.setKeyValue(key, value);\n         }\n-        \n+\n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             if (found.isEmpty()) { // <- must be the root\n             }\n             return found.setKeyValue(key, value);\n         }\n-        \n+\n         final int bitIndex = bitIndex(key, found.key);\n         if (!AbstractKeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n             if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n             } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n                 // A bits of the Key are zero. The only place to\n                 // store such a Key is the root Node!\n-                \n+\n                 /* NULL BIT KEY */\n                 if (root.isEmpty()) {\n                     incrementSize();\n                     incrementModCount();\n                 }\n                 return root.setKeyValue(key, value);\n-                \n+\n             } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n                 // This is a very special and rare case.\n-                \n+\n                 /* REPLACE OLD KEY+VALUE */\n                 if (found != root) {\n                     incrementModCount();\n                 }\n             }\n         }\n-        \n+\n         throw new IndexOutOfBoundsException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n     }\n-    \n+\n     /**\n      * Adds the given {@link TrieEntry} to the {@link Trie}\n      */\n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while(true) {\n-            if (current.bitIndex >= entry.bitIndex \n+            if (current.bitIndex >= entry.bitIndex\n                     || current.bitIndex <= path.bitIndex) {\n                 entry.predecessor = entry;\n-                \n+\n                 if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n                     entry.left = entry;\n                     entry.right = current;\n                     entry.left = current;\n                     entry.right = entry;\n                 }\n-               \n+\n                 entry.parent = path;\n                 if (current.bitIndex >= entry.bitIndex) {\n                     current.parent = entry;\n                 }\n-                \n+\n                 // if we inserted an uplink, set the predecessor on it\n                 if (current.bitIndex <= path.bitIndex) {\n                     current.predecessor = entry;\n                 }\n-         \n+\n                 if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n                     path.left = entry;\n                 } else {\n                     path.right = entry;\n                 }\n-                \n+\n                 return entry;\n             }\n-                \n+\n             path = current;\n-            \n+\n             if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n                 current = current.left;\n             } else {\n             }\n         }\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * Returns the entry associated with the specified key in the\n      * PatriciaTrieBase.  Returns null if the map contains no mapping\n      * for this key.\n-     * \n+     *\n      * This may throw ClassCastException if the object is not of type K.\n      */\n     TrieEntry<K,V> getEntry(final Object k) {\n         if (key == null) {\n             return null;\n         }\n-        \n+\n         final int lengthInBits = lengthInBits(key);\n         final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n         return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public Map.Entry<K, V> select(final K key) {\n         final int lengthInBits = lengthInBits(key);\n-        final Reference<Map.Entry<K, V>> reference \n+        final Reference<Map.Entry<K, V>> reference\n             = new Reference<Map.Entry<K,V>>();\n         if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n             return reference.get();\n         }\n         return null;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public Map.Entry<K,V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n         final int lengthInBits = lengthInBits(key);\n-        final Reference<Map.Entry<K, V>> reference \n+        final Reference<Map.Entry<K, V>> reference\n             = new Reference<Map.Entry<K,V>>();\n         selectR(root.left, -1, key, lengthInBits, cursor, reference);\n         return reference.get();\n     }\n \n     /**\n-     * This is equivalent to the other {@link #selectR(TrieEntry, int, \n-     * Object, int, Cursor, Reference)} method but without its overhead \n-     * because we're selecting only one best matching Entry from the \n+     * This is equivalent to the other {@link #selectR(TrieEntry, int,\n+     * Object, int, Cursor, Reference)} method but without its overhead\n+     * because we're selecting only one best matching Entry from the\n      * {@link Trie}.\n      */\n-    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, \n-            final K key, final int lengthInBits, \n+    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex,\n+            final K key, final int lengthInBits,\n             final Reference<Map.Entry<K, V>> reference) {\n-        \n+\n         if (h.bitIndex <= bitIndex) {\n             // If we hit the root Node and it is empty\n             // we have to look for an alternative best\n         }\n         return false;\n     }\n-    \n-    /**\n-     * \n-     */\n-    private boolean selectR(final TrieEntry<K,V> h, final int bitIndex, \n-            final K key, \n+\n+    /**\n+     *\n+     */\n+    private boolean selectR(final TrieEntry<K,V> h, final int bitIndex,\n+            final K key,\n             final int lengthInBits,\n             final Cursor<? super K, ? super V> cursor,\n             final Reference<Map.Entry<K, V>> reference) {\n                 return selectR(h.left, h.bitIndex, key, lengthInBits, cursor, reference);\n             }\n         }\n-        \n+\n         return false;\n     }\n \n         TrieEntry<K, V> entry = nextEntry(null);\n         while (entry != null) {\n             final TrieEntry<K, V> current = entry;\n-            \n+\n             final Decision decision = cursor.select(current);\n             entry = nextEntry(current);\n-            \n+\n             switch(decision) {\n                 case EXIT:\n                     return current;\n                     break;\n             }\n         }\n-        \n+\n         return null;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         if (k == null) {\n             return false;\n         }\n-        \n+\n         final K key = castKey(k);\n         final int lengthInBits = lengthInBits(key);\n         final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n         return !entry.isEmpty() && compareKeys(key, entry.key);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         }\n         return entrySet;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         }\n         return keySet;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         }\n         return values;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n-     * \n-     * @throws ClassCastException if provided key is of an incompatible type \n+     *\n+     * @throws ClassCastException if provided key is of an incompatible type\n      */\n     @Override\n     public V remove(final Object k) {\n         if (k == null) {\n             return null;\n         }\n-        \n+\n         final K key = castKey(k);\n-        final int lengthInBits = lengthInBits(key);        \n+        final int lengthInBits = lengthInBits(key);\n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while (true) {\n                     return null;\n                 }\n             }\n-            \n+\n             path = current;\n-            \n+\n             if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                 current = current.left;\n             } else {\n             }\n         }\n     }\n-    \n+\n     /**\n      * Returns the nearest entry for a given key.  This is useful\n      * for finding knowing if a given key exists (and finding the value\n      * for it), or for inserting the key.\n-     * \n+     *\n      * The actual get implementation. This is very similar to\n      * selectR but with the exception that it might return the\n      * root Entry even if it's empty.\n             if (current.bitIndex <= path.bitIndex) {\n                 return current;\n             }\n-            \n+\n             path = current;\n             if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                 current = current.left;\n             }\n         }\n     }\n-    \n+\n     /**\n      * Removes a single entry from the {@link Trie}.\n-     * \n+     *\n      * If we found a Key (Entry h) then figure out if it's\n-     * an internal (hard to remove) or external Entry (easy \n+     * an internal (hard to remove) or external Entry (easy\n      * to remove)\n      */\n     V removeEntry(final TrieEntry<K, V> h) {\n                 removeExternalEntry(h);\n             }\n         }\n-        \n+\n         decrementSize();\n         return h.setKeyValue(null, null);\n     }\n-    \n+\n     /**\n      * Removes an external entry from the {@link Trie}.\n-     * \n+     *\n      * If it's an external Entry then just remove it.\n      * This is very easy and straight forward.\n      */\n             throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n         } else if (!h.isExternalNode()) {\n             throw new IllegalArgumentException(h + \" is not an external Entry!\");\n-        } \n-        \n+        }\n+\n         final TrieEntry<K, V> parent = h.parent;\n         final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n-        \n+\n         if (parent.left == h) {\n             parent.left = child;\n         } else {\n             parent.right = child;\n         }\n-        \n+\n         // either the parent is changing, or the predecessor is changing.\n         if (child.bitIndex > parent.bitIndex) {\n             child.parent = parent;\n         } else {\n             child.predecessor = parent;\n         }\n-        \n-    }\n-    \n+\n+    }\n+\n     /**\n      * Removes an internal entry from the {@link Trie}.\n-     * \n+     *\n      * If it's an internal Entry then \"good luck\" with understanding\n      * this code. The Idea is essentially that Entry p takes Entry h's\n      * place in the trie which requires some re-wiring.\n             throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n         } else if (!h.isInternalNode()) {\n             throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n-        } \n-        \n+        }\n+\n         final TrieEntry<K, V> p = h.predecessor;\n-        \n+\n         // Set P's bitIndex\n         p.bitIndex = h.bitIndex;\n-        \n+\n         // Fix P's parent, predecessor and child Nodes\n         {\n             final TrieEntry<K, V> parent = p.parent;\n             final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n-            \n+\n             // if it was looping to itself previously,\n             // it will now be pointed from it's parent\n             // (if we aren't removing it's parent --\n             if (p.predecessor == p && p.parent != h) {\n                 p.predecessor = p.parent;\n             }\n-            \n+\n             if (parent.left == p) {\n                 parent.left = child;\n             } else {\n                 parent.right = child;\n             }\n-            \n+\n             if (child.bitIndex > parent.bitIndex) {\n                 child.parent = parent;\n             }\n         }\n-        \n+\n         // Fix H's parent and child Nodes\n-        {         \n-            // If H is a parent of its left and right child \n+        {\n+            // If H is a parent of its left and right child\n             // then change them to P\n             if (h.left.parent == h) {\n                 h.left.parent = p;\n             }\n-            \n+\n             if (h.right.parent == h) {\n                 h.right.parent = p;\n             }\n-            \n+\n             // Change H's parent\n             if (h.parent.left == h) {\n                 h.parent.left = p;\n                 h.parent.right = p;\n             }\n         }\n-        \n+\n         // Copy the remaining fields from H to P\n         //p.bitIndex = h.bitIndex;\n         p.parent = h.parent;\n         p.left = h.left;\n         p.right = h.right;\n-        \n+\n         // Make sure that if h was pointing to any uplinks,\n         // p now points to them.\n         if (isValidUplink(p.left, p)) {\n             p.left.predecessor = p;\n         }\n-        \n+\n         if (isValidUplink(p.right, p)) {\n             p.right.predecessor = p;\n-        }   \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Returns the entry lexicographically after the given entry.\n      * If the given entry is null, returns the first node.\n             return nextEntryImpl(node.predecessor, node, null);\n         }\n     }\n-    \n+\n     /**\n      * Scans for the next node, starting at the specified point, and using 'previous'\n      * as a hint that the last node we returned was 'previous' (so we know not to return\n      * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n-     * \n+     *\n      * The basic premise is that each iteration can follow the following steps:\n-     * \n+     *\n      * 1) Scan all the way to the left.\n      *   a) If we already started from this node last time, proceed to Step 2.\n      *   b) If a valid uplink is found, use it.\n      *   c) If the result is an empty node (root not set), break the scan.\n      *   d) If we already returned the left node, break the scan.\n-     *   \n+     *\n      * 2) Check the right.\n      *   a) If we already returned the right node, proceed to Step 3.\n      *   b) If it is a valid uplink, use it.\n      *   c) Do Step 1 from the right node.\n-     *   \n+     *\n      * 3) Back up through the parents until we encounter find a parent\n      *    that we're not the right child of.\n-     *    \n+     *\n      * 4) If there's no right child of that parent, the iteration is finished.\n      *    Otherwise continue to Step 5.\n-     * \n+     *\n      * 5) Check to see if the right child is a valid uplink.\n      *    a) If we already returned that child, proceed to Step 6.\n      *       Otherwise, use it.\n-     *    \n+     *\n      * 6) If the right child of the parent is the parent itself, we've\n      *    already found & returned the end of the Trie, so exit.\n-     *    \n+     *\n      * 7) Do Step 1 on the parent's right child.\n      */\n-    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, \n+    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start,\n             final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n-        \n+\n         TrieEntry<K, V> current = start;\n \n         // Only look at the left if this was a recursive or\n                 if (previous == current.left) {\n                     break;\n                 }\n-                \n+\n                 if (isValidUplink(current.left, current)) {\n                     return current.left;\n                 }\n-                \n+\n                 current = current.left;\n             }\n         }\n-        \n+\n         // If there's no data at all, exit.\n         if (current.isEmpty()) {\n             return null;\n         }\n-        \n+\n         // If we've already returned the left,\n         // and the immediate right is null,\n         // there's only one entry in the Trie\n         if (current.right == null) {\n             return null;\n         }\n-        \n+\n         // If nothing valid on the left, try the right.\n         if (previous != current.right) {\n             // See if it immediately is valid.\n             if (isValidUplink(current.right, current)) {\n                 return current.right;\n             }\n-            \n+\n             // Must search on the right's side if it wasn't initially valid.\n             return nextEntryImpl(current.right, previous, tree);\n         }\n-        \n+\n         // Neither left nor right are valid, find the first parent\n         // whose child did not come from the right & traverse it.\n         while (current == current.parent.right) {\n             if (current == tree) {\n                 return null;\n             }\n-            \n+\n             current = current.parent;\n         }\n \n         if (current == tree) {\n             return null;\n         }\n-        \n+\n         // If there's no right, the parent must be root, so we're done.\n         if (current.parent.right == null) {\n             return null;\n         }\n-        \n+\n         // If the parent's right points to itself, we've found one.\n-        if (previous != current.parent.right \n+        if (previous != current.parent.right\n                 && isValidUplink(current.parent.right, current.parent)) {\n             return current.parent.right;\n         }\n-        \n+\n         // If the parent's right is itself, there can't be any more nodes.\n         if (current.parent.right == current.parent) {\n             return null;\n         }\n-        \n+\n         // We need to traverse down the parent's right's path.\n         return nextEntryImpl(current.parent.right, previous, tree);\n     }\n-    \n+\n     /**\n      * Returns the first entry the {@link Trie} is storing.\n-     * \n+     *\n      * This is implemented by going always to the left until\n      * we encounter a valid uplink. That uplink is the first key.\n      */\n         if (isEmpty()) {\n             return null;\n         }\n-        \n+\n         return followLeft(root);\n     }\n-    \n-    /** \n-     * Goes left through the tree until it finds a valid node. \n+\n+    /**\n+     * Goes left through the tree until it finds a valid node.\n      */\n     TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n         while(true) {\n             if (child.isEmpty()) {\n                 child = node.right;\n             }\n-            \n+\n             if (child.bitIndex <= node.bitIndex) {\n                 return child;\n             }\n-            \n+\n             node = child;\n         }\n     }\n-    \n-    /** \n-     * Returns true if 'next' is a valid uplink coming from 'from'. \n-     */\n-    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) { \n+\n+    /**\n+     * Returns true if 'next' is a valid uplink coming from 'from'.\n+     */\n+    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n         return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n     }\n-    \n-    /**\n-     * A {@link Reference} allows us to return something through a Method's \n-     * argument list. An alternative would be to an Array with a length of \n+\n+    /**\n+     * A {@link Reference} allows us to return something through a Method's\n+     * argument list. An alternative would be to an Array with a length of\n      * one (1) but that leads to compiler warnings. Computationally and memory\n-     * wise there's no difference (except for the need to load the \n+     * wise there's no difference (except for the need to load the\n      * {@link Reference} Class but that happens only once).\n      */\n     private static class Reference<E> {\n-        \n+\n         private E item;\n-        \n+\n         public void set(final E item) {\n             this.item = item;\n         }\n-        \n+\n         public E get() {\n             return item;\n         }\n     }\n-    \n+\n     /**\n      *  A {@link Trie} is a set of {@link TrieEntry} nodes\n      */\n     static class TrieEntry<K,V> extends BasicEntry<K, V> {\n-        \n+\n         private static final long serialVersionUID = 4596023148184140013L;\n-        \n+\n         /** The index this entry is comparing. */\n         protected int bitIndex;\n-        \n+\n         /** The parent of this entry. */\n         protected TrieEntry<K,V> parent;\n-        \n+\n         /** The left child of this entry. */\n         protected TrieEntry<K,V> left;\n-        \n+\n         /** The right child of this entry. */\n         protected TrieEntry<K,V> right;\n-        \n-        /** The entry who uplinks to this entry. */ \n+\n+        /** The entry who uplinks to this entry. */\n         protected TrieEntry<K,V> predecessor;\n-        \n+\n         public TrieEntry(final K key, final V value, final int bitIndex) {\n             super(key, value);\n-            \n+\n             this.bitIndex = bitIndex;\n-            \n+\n             this.parent = null;\n             this.left = this;\n             this.right = null;\n             this.predecessor = this;\n         }\n-        \n+\n         /**\n          * Whether or not the entry is storing a key.\n          * Only the root can potentially be empty, all other\n         public boolean isEmpty() {\n             return key == null;\n         }\n-        \n-        /** \n-         * Neither the left nor right child is a loopback \n+\n+        /**\n+         * Neither the left nor right child is a loopback\n          */\n         public boolean isInternalNode() {\n             return left != this && right != this;\n         }\n-        \n-        /** \n-         * Either the left or right child is a loopback \n+\n+        /**\n+         * Either the left or right child is a loopback\n          */\n         public boolean isExternalNode() {\n             return !isInternalNode();\n         @Override\n         public String toString() {\n             final StringBuilder buffer = new StringBuilder();\n-            \n+\n             if (bitIndex == -1) {\n                 buffer.append(\"RootEntry(\");\n             } else {\n                 buffer.append(\"Entry(\");\n             }\n-            \n+\n             buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n             buffer.append(\"value=\").append(getValue()).append(\", \");\n             //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n-            \n+\n             if (parent != null) {\n                 if (parent.bitIndex == -1) {\n                     buffer.append(\"parent=\").append(\"ROOT\");\n                 buffer.append(\"parent=\").append(\"null\");\n             }\n             buffer.append(\", \");\n-            \n+\n             if (left != null) {\n                 if (left.bitIndex == -1) {\n                     buffer.append(\"left=\").append(\"ROOT\");\n                 buffer.append(\"left=\").append(\"null\");\n             }\n             buffer.append(\", \");\n-            \n+\n             if (right != null) {\n                 if (right.bitIndex == -1) {\n                     buffer.append(\"right=\").append(\"ROOT\");\n                 buffer.append(\"right=\").append(\"null\");\n             }\n             buffer.append(\", \");\n-            \n+\n             if (predecessor != null) {\n                 if(predecessor.bitIndex == -1) {\n                     buffer.append(\"predecessor=\").append(\"ROOT\");\n                            append(predecessor.bitIndex).append(\"]\");\n                 }\n             }\n-            \n+\n             buffer.append(\")\");\n             return buffer.toString();\n         }\n     }\n-    \n-\n-    /**\n-     * This is a entry set view of the {@link Trie} as returned \n+\n+\n+    /**\n+     * This is a entry set view of the {@link Trie} as returned\n      * by {@link Map#entrySet()}\n      */\n     private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public Iterator<Map.Entry<K,V>> iterator() {\n             return new EntryIterator();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             if (!(o instanceof Map.Entry)) {\n                 return false;\n             }\n-            \n+\n             final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n             return candidate != null && candidate.equals(o);\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             PatriciaTrieBase.this.remove(o);\n             return size != size();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public int size() {\n             return PatriciaTrieBase.this.size();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public void clear() {\n             PatriciaTrieBase.this.clear();\n         }\n-        \n+\n         /**\n          * An {@link Iterator} that returns {@link Entry} Objects\n          */\n             }\n         }\n     }\n-    \n-    /**\n-     * This is a key set view of the {@link Trie} as returned \n+\n+    /**\n+     * This is a key set view of the {@link Trie} as returned\n      * by {@link Map#keySet()}\n      */\n     private class KeySet extends AbstractSet<K> {\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public Iterator<K> iterator() {\n             return new KeyIterator();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public int size() {\n             return PatriciaTrieBase.this.size();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public boolean contains(final Object o) {\n             return containsKey(o);\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             PatriciaTrieBase.this.remove(o);\n             return size != size();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public void clear() {\n             PatriciaTrieBase.this.clear();\n         }\n-        \n+\n         /**\n          * An {@link Iterator} that returns Key Objects\n          */\n             }\n         }\n     }\n-    \n-    /**\n-     * This is a value view of the {@link Trie} as returned \n+\n+    /**\n+     * This is a value view of the {@link Trie} as returned\n      * by {@link Map#values()}\n      */\n     private class Values extends AbstractCollection<V> {\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public Iterator<V> iterator() {\n             return new ValueIterator();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public int size() {\n             return PatriciaTrieBase.this.size();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public boolean contains(final Object o) {\n             return containsValue(o);\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public void clear() {\n             PatriciaTrieBase.this.clear();\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             }\n             return false;\n         }\n-        \n+\n         /**\n          * An {@link Iterator} that returns Value Objects\n          */\n             }\n         }\n     }\n-    \n-    /** \n-     * An iterator for the entries. \n+\n+    /**\n+     * An iterator for the entries.\n      */\n     abstract class TrieIterator<E> implements Iterator<E> {\n-        \n+\n         /**\n          * For fast-fail\n          */\n         protected int expectedModCount = PatriciaTrieBase.this.modCount;\n-        \n+\n         protected TrieEntry<K, V> next; // the next node to return\n         protected TrieEntry<K, V> current; // the current entry we're on\n-        \n+\n         /**\n          * Starts iteration from the root\n          */\n         protected TrieIterator() {\n             next = PatriciaTrieBase.this.nextEntry(null);\n         }\n-        \n+\n         /**\n          * Starts iteration at the given entry\n          */\n         protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n             next = firstEntry;\n         }\n-        \n+\n         /**\n          * Returns the next {@link TrieEntry}\n          */\n-        protected TrieEntry<K,V> nextEntry() { \n+        protected TrieEntry<K,V> nextEntry() {\n             if (expectedModCount != PatriciaTrieBase.this.modCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            \n+\n             final TrieEntry<K,V> e = next;\n             if (e == null) {\n                 throw new NoSuchElementException();\n             }\n-            \n+\n             next = findNext(e);\n             current = e;\n             return e;\n         }\n-        \n+\n         /**\n          * @see PatriciaTrie#nextEntry(TrieEntry)\n          */\n         protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n             return PatriciaTrieBase.this.nextEntry(prior);\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n         public boolean hasNext() {\n             return next != null;\n         }\n-        \n+\n         /**\n          * {@inheritDoc}\n          */\n             if (current == null) {\n                 throw new IllegalStateException();\n             }\n-            \n+\n             if (expectedModCount != PatriciaTrieBase.this.modCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            \n+\n             final TrieEntry<K, V> node = current;\n             current = null;\n             PatriciaTrieBase.this.removeEntry(node);\n-            \n+\n             expectedModCount = PatriciaTrieBase.this.modCount;\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections4/trie/ShortKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/ShortKeyAnalyzer.java\n \n /**\n  * A {@link KeyAnalyzer} for {@link Short}s.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class ShortKeyAnalyzer implements KeyAnalyzer<Short> {\n-    \n+\n     private static final long serialVersionUID = -8631376733513512017L;\n \n     /**\n      * A singleton instance of {@link ShortKeyAnalyzer}\n      */\n     public static final ShortKeyAnalyzer INSTANCE = new ShortKeyAnalyzer();\n-    \n+\n     /**\n      * The length of an {@link Short} in bits\n      */\n     public static final int LENGTH = Short.SIZE;\n-    \n+\n     /**\n      * A bit mask where the first bit is 1 and the others are zero\n      */\n     private static final int MSB = 0x8000;\n-    \n+\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n     public int bitsPerElement() {\n         return 1;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(final Short key, final int offsetInBits, final int lengthInBits, \n+    public int bitIndex(final Short key, final int offsetInBits, final int lengthInBits,\n             final Short other, final int otherOffsetInBits, final int otherLengthInBits) {\n-        \n+\n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n-            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n-        \n+\n         final int keyValue = key.shortValue();\n         if (keyValue == 0) {\n             return NULL_BIT_KEY;\n         }\n \n         final int otherValue = other != null ? other.shortValue() : 0;\n-        \n+\n         if (keyValue != otherValue) {\n             final int xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 }\n             }\n         }\n-        \n+\n         return KeyAnalyzer.EQUAL_BIT_KEY;\n     }\n \n     public int compare(final Short o1, final Short o2) {\n         return o1.compareTo(o2);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(final Short prefix, final int offsetInBits, \n+    public boolean isPrefix(final Short prefix, final int offsetInBits,\n             final int lengthInBits, final Short key) {\n-        \n+\n         final int value1 = prefix.shortValue() << offsetInBits;\n         final int value2 = key.shortValue();\n-        \n+\n         int mask = 0;\n         for (int i = 0; i < lengthInBits; i++) {\n             mask |= 0x1 << i;\n         }\n-        \n+\n         return (value1 & mask) == (value2 & mask);\n     }\n }\n--- a/src/main/java/org/apache/commons/collections4/trie/StringKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/StringKeyAnalyzer.java\n \n /**\n  * An {@link KeyAnalyzer} for {@link String}s.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class StringKeyAnalyzer extends AbstractKeyAnalyzer<String> {\n-    \n+\n     private static final long serialVersionUID = -7032449491269434877L;\n-    \n+\n     /**\n      * A singleton instance of {@link StringKeyAnalyzer}\n      */\n     public static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();\n-    \n+\n     /**\n      * The number of bits per {@link Character}\n      */\n     public static final int LENGTH = Character.SIZE;\n-    \n+\n     /**\n      * A bit mask where the first bit is 1 and the others are zero\n      */\n     private static final int MSB = 0x8000;\n-    \n+\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n     private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public int bitsPerElement() {\n         return LENGTH;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public int lengthInBits(final String key) {\n         return key != null ? key.length() * LENGTH : 0;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public int bitIndex(final String key, final int offsetInBits, final int lengthInBits,\n             final String other, final int otherOffsetInBits, final int otherLengthInBits) {\n         boolean allNull = true;\n-        \n-        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 \n+\n+        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0\n                 || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n             throw new IllegalArgumentException(\n                     \"The offsets and lengths must be at Character boundaries\");\n         }\n-        \n-        \n+\n+\n         final int beginIndex1 = offsetInBits / LENGTH;\n         final int beginIndex2 = otherOffsetInBits / LENGTH;\n-        \n+\n         final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n         final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n-        \n+\n         final int length = Math.max(endIndex1, endIndex2);\n-        \n+\n         // Look at each character, and if they're different\n         // then figure out which bit makes the difference\n         // and return it.\n         for(int i = 0; i < length; i++) {\n             final int index1 = beginIndex1 + i;\n             final int index2 = beginIndex2 + i;\n-            \n+\n             if (index1 >= endIndex1) {\n                 k = 0;\n             } else {\n                 k = key.charAt(index1);\n             }\n-            \n+\n             if (other == null || index2 >= endIndex2) {\n                 f = 0;\n             } else {\n                 f = other.charAt(index2);\n             }\n-            \n+\n             if (k != f) {\n                final int x = k ^ f;\n                return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n             }\n-            \n+\n             if (k != 0) {\n                 allNull = false;\n             }\n         }\n-        \n+\n         // All bits are 0\n         if (allNull) {\n             return KeyAnalyzer.NULL_BIT_KEY;\n         }\n-        \n+\n         // Both keys are equal\n         return KeyAnalyzer.EQUAL_BIT_KEY;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         if (key == null || bitIndex >= lengthInBits) {\n             return false;\n         }\n-        \n+\n         final int index = bitIndex / LENGTH;\n         final int bit = bitIndex % LENGTH;\n-        \n+\n         return (key.charAt(index) & mask(bit)) != 0;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(final String prefix, final int offsetInBits, \n+    public boolean isPrefix(final String prefix, final int offsetInBits,\n             final int lengthInBits, final String key) {\n         if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n             throw new IllegalArgumentException(\n                     \"Cannot determine prefix outside of Character boundaries\");\n         }\n-    \n+\n         final String s1 = prefix.substring(offsetInBits / LENGTH, lengthInBits / LENGTH);\n         return key.startsWith(s1);\n     }\n--- a/src/main/java/org/apache/commons/collections4/trie/SynchronizedTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/SynchronizedTrie.java\n \n /**\n  * A synchronized {@link Trie}.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class SynchronizedTrie<K, V> implements Trie<K, V>, Serializable {\n-    \n+\n     private static final long serialVersionUID = 3121878833178676939L;\n-    \n+\n     private final Trie<K, V> delegate;\n-    \n+\n     /**\n      * Factory method to create a synchronized trie.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param trie  the trie to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param trie  the trie to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n     public synchronized Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n         return delegate.traverse(cursor);\n     }\n-    \n+\n     public synchronized Set<Entry<K, V>> entrySet() {\n         return Collections.synchronizedSet(delegate.entrySet());\n     }\n     public synchronized V remove(final Object key) {\n         return delegate.remove(key);\n     }\n-    \n+\n     public synchronized K lastKey() {\n         return delegate.lastKey();\n     }\n     public synchronized SortedMap<K, V> tailMap(final K fromKey) {\n         return Collections.synchronizedSortedMap(delegate.tailMap(fromKey));\n     }\n-    \n+\n     public synchronized Comparator<? super K> comparator() {\n         return delegate.comparator();\n     }\n     public synchronized SortedMap<K, V> headMap(final K toKey) {\n         return Collections.synchronizedSortedMap(delegate.headMap(toKey));\n     }\n-    \n+\n     public synchronized SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, offset, length));\n     }\n         return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedByBits(final K key, \n+    public synchronized SortedMap<K, V> getPrefixedByBits(final K key,\n             final int offsetInBits, final int lengthInBits) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n     }\n     public synchronized int hashCode() {\n         return delegate.hashCode();\n     }\n-    \n+\n     @Override\n     public synchronized boolean equals(final Object obj) {\n         return delegate.equals(obj);\n     }\n-    \n+\n     @Override\n     public synchronized String toString() {\n         return delegate.toString();\n--- a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n \n /**\n  * An unmodifiable {@link Trie}.\n- * \n+ *\n  * @since 4.0\n  * @version $Id$\n  */\n public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodifiable {\n-    \n+\n     private static final long serialVersionUID = -7156426030315945159L;\n-    \n+\n     private final Trie<K, V> delegate;\n-    \n+\n     /**\n      * Factory method to create a unmodifiable trie.\n-     * \n+     *\n      * @param <K>  the key type\n      * @param <V>  the value type\n      * @param trie  the trie to decorate, must not be null\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param trie  the trie to decorate, must not be null\n      * @throws IllegalArgumentException if trie is null\n      */\n         }\n         this.delegate = trie;\n     }\n-    \n+\n     public Entry<K, V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n         final Cursor<K, V> c = new Cursor<K, V>() {\n             public Decision select(final Map.Entry<? extends K, ? extends V> entry) {\n                         // other decisions are fine\n                         break;\n                 }\n-                \n+\n                 return decision;\n             }\n         };\n-        \n+\n         return delegate.select(key, c);\n     }\n \n                         // other decisions are fine\n                         break;\n                 }\n-                \n+\n                 return decision;\n             }\n         };\n-        \n+\n         return delegate.traverse(c);\n     }\n \n     public Set<Entry<K, V>> entrySet() {\n         return Collections.unmodifiableSet(delegate.entrySet());\n     }\n-    \n+\n     public Set<K> keySet() {\n         return Collections.unmodifiableSet(delegate.keySet());\n     }\n     public SortedMap<K, V> tailMap(final K fromKey) {\n         return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n     }\n-    \n+\n     public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedBy(key, offset, length));\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedByBits(key, lengthInBits));\n     }\n-    \n+\n     public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n         return Collections.unmodifiableSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n     }\n     public Comparator<? super K> comparator() {\n         return delegate.comparator();\n     }\n-    \n+\n     public int size() {\n         return delegate.size();\n     }\n-    \n+\n     @Override\n     public int hashCode() {\n         return delegate.hashCode();\n     }\n-    \n+\n     @Override\n     public boolean equals(final Object obj) {\n         return delegate.equals(obj);\n     }\n-    \n+\n     @Override\n     public String toString() {\n         return delegate.toString();", "timestamp": 1367350923, "metainfo": ""}