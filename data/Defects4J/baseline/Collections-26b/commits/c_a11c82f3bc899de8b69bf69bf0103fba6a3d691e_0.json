{"sha": "a11c82f3bc899de8b69bf69bf0103fba6a3d691e", "log": "Add Apache licence   ", "commit": "\n--- a/src/java/org/apache/commons/collections/CommonsLinkedList.java\n+++ b/src/java/org/apache/commons/collections/CommonsLinkedList.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n package org.apache.commons.collections;\n \n import java.io.IOException;\n  * of {@link java.util.LinkedList}, but which provides a more open interface for\n  * subclasses to extend.\n  * \n+ * @since 2.2\n  * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n+ * @version $Revision: 1.2 $ $Date: 2003/01/07 23:40:55 $\n  */\n class CommonsLinkedList extends LinkedList\n-    implements List, Serializable {\n+        implements List, Serializable {\n \n     /*\n      * Implementation notes:\n     private static final long serialVersionUID = 1L;\n \n     /**\n-     * A {@link Node} which ndicates the start and end of the list and does not\n+     * A {@link Node} which indicates the start and end of the list and does not\n      * hold a value. The value of <code>next</code> is the first item in the\n      * list. The value of of <code>previous</code> is the last item in the list.\n      */\n--- a/src/java/org/apache/commons/collections/NodeCachingLinkedList.java\n+++ b/src/java/org/apache/commons/collections/NodeCachingLinkedList.java\n-package org.apache.commons.collections;\n-\n-import java.util.Collection;\n-\n-/**\n- * A linked list implementation that caches the nodes used internally to prevent\n- * unnecessary object creates and deletion. This should result in a performance\n- * improvement.\n- * \n- * @author Jeff Varszegi\n- * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n- */\n-public class NodeCachingLinkedList extends CommonsLinkedList {\n-\n-    private static final long serialVersionUID = 1;\n-\n-    /**\n-     * The default value for {@link #maximumCacheSize}.\n-     */\n-    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;\n-\n-    /**\n-     * The first cached node, or <code>null</code> if no nodes are cached.\n-     * Cached nodes are stored in a singly-linked list with {@link Node#next}\n-     * pointing to the next element.\n-     */\n-    private transient Node firstCachedNode;\n-    \n-    /**\n-     * The size of the cache.\n-     */\n-    private transient int cacheSize = 0;\n-\n-    /**\n-     * The maximum size of the cache.\n-     */\n-    private int maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n-\n-    public NodeCachingLinkedList() {\n-        super();\n-    }\n-\n-    public NodeCachingLinkedList(Collection c) {\n-        super(c);\n-    }\n-    \n-    public NodeCachingLinkedList(int maximumCacheSize) {\n-        super();\n-        this.maximumCacheSize = maximumCacheSize;\n-    }\n-\n-    // Cache operations\n-\n-    /**\n-     * Gets the maximum size of the cache.\n-     */\n-    public int getMaximumCacheSize() {\n-        return maximumCacheSize;\n-    }\n-\n-    /**\n-     * Sets the maximum size of the cache.\n-     */\n-    public void setMaximumCacheSize(int maximumCacheSize) {\n-        this.maximumCacheSize = maximumCacheSize;\n-        shrinkCacheToMaximumSize();\n-    }\n-\n-    /**\n-     * Reduce the size of the cache to the maximum, if necessary.\n-     */\n-    private void shrinkCacheToMaximumSize() {\n-        // Rich Dougherty: This could be more efficient.\n-        while (cacheSize > maximumCacheSize) {\n-            getNodeFromCache();\n-        }\n-    }\n-    \n-    /**\n-     * Gets a node from the cache. If a node is returned, then the value of\n-     * {@link #cacheSize} is decreased accordingly. The node that is returned\n-     * will have <code>null</code> values for next, previous and element.\n-     * \n-     * @return A node, or <code>null</code> if there are no nodes in the cache.\n-     */\n-    private Node getNodeFromCache() {\n-        if (cacheSize == 0) {\n-            return null;\n-        }\n-        Node cachedNode = firstCachedNode;\n-        firstCachedNode = cachedNode.next;\n-        cachedNode.next = null; // This should be changed anyway, but defensively\n-                                             // set it to null.\n-        cacheSize--;\n-        return cachedNode;\n-    }\n-    \n-    private boolean cacheFull() {\n-        return cacheSize >= maximumCacheSize;\n-    }\n-    \n-    /**\n-     * Adds a node to the cache, if the cache isn't full. The node's contents\n-     * are cleared to so they can be garbage collected.\n-     */\n-    private void addNodeToCache(Node node) {\n-        if (cacheFull()) {\n-            // Don't cache the node.\n-            return;\n-        }\n-        // Clear the node's contents and add it to the cache.\n-        Node nextCachedNode = firstCachedNode;\n-        node.previous = null;\n-        node.next = nextCachedNode;\n-        node.element = null;\n-        firstCachedNode = node;\n-        cacheSize++;\n-    }\n-    \n-    // Node operations\n-\n-    /**\n-     * Create a node, getting it from the cache if possible.\n-     */\n-    protected Node createNode() {\n-        Node cachedNode = getNodeFromCache();\n-        if (cachedNode == null) {\n-            return super.createNode();\n-        } else {\n-            return cachedNode;\n-        }\n-    }\n-    \n-    /**\n-     * Create a node, getting it from the cache if possible.\n-     */\n-    protected Node createNode(Node next, Node previous, Object element) {\n-        Node cachedNode = getNodeFromCache();\n-        if (cachedNode == null) {\n-            return super.createNode(next, previous, element);\n-        } else {\n-            cachedNode.next = next;\n-            cachedNode.previous = previous;\n-            cachedNode.element = element;\n-            return cachedNode;\n-        }\n-    }\n-\n-    /**\n-     * Calls the superclass' implementation then calls\n-     * {@link #addNodeToCache(Node)} on the node which has been removed.\n-     * \n-     * @see org.apache.commons.collections.CommonsLinkedList#removeNode(Node)\n-     */\n-    protected void removeNode(Node node) {\n-        super.removeNode(node);\n-        addNodeToCache(node);\n-    }\n-    \n-    protected void removeAllNodes() {\n-        // Add the removed nodes to the cache, then remove the rest.\n-        // We can add them to the cache before removing them, since\n-        // {@link CommonsLinkedList.removeAllNodes()} removes the\n-        // nodes by removing references directly from {@link #marker}.\n-        int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n-        Node node = marker.next;\n-        for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n-            Node oldNode = node;\n-            node = node.next;\n-            addNodeToCache(oldNode);\n-        }\n-        super.removeAllNodes();        \n-    }\n-\n-}\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A linked list implementation that caches the nodes used internally to prevent\n+ * unnecessary object creates and deletion. This should result in a performance\n+ * improvement.\n+ * \n+ * @since 2.2\n+ * @author Jeff Varszegi\n+ * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n+ * @version $Revision: 1.3 $ $Date: 2003/01/07 23:40:57 $\n+ */\n+public class NodeCachingLinkedList extends CommonsLinkedList {\n+\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * The default value for {@link #maximumCacheSize}.\n+     */\n+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;\n+\n+    /**\n+     * The first cached node, or <code>null</code> if no nodes are cached.\n+     * Cached nodes are stored in a singly-linked list with {@link Node#next}\n+     * pointing to the next element.\n+     */\n+    private transient Node firstCachedNode;\n+    \n+    /**\n+     * The size of the cache.\n+     */\n+    private transient int cacheSize = 0;\n+\n+    /**\n+     * The maximum size of the cache.\n+     */\n+    private int maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NodeCachingLinkedList() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that copies the specified collection\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    public NodeCachingLinkedList(Collection coll) {\n+        super(coll);\n+    }\n+    \n+    /**\n+     * Constructor that species the maximum cache size.\n+     * \n+     * @param maximumCacheSize  the maximum cache size\n+     */\n+    public NodeCachingLinkedList(int maximumCacheSize) {\n+        super();\n+        this.maximumCacheSize = maximumCacheSize;\n+    }\n+\n+    // Cache operations\n+\n+    /**\n+     * Gets the maximum size of the cache.\n+     */\n+    public int getMaximumCacheSize() {\n+        return maximumCacheSize;\n+    }\n+\n+    /**\n+     * Sets the maximum size of the cache.\n+     */\n+    public void setMaximumCacheSize(int maximumCacheSize) {\n+        this.maximumCacheSize = maximumCacheSize;\n+        shrinkCacheToMaximumSize();\n+    }\n+\n+    /**\n+     * Reduce the size of the cache to the maximum, if necessary.\n+     */\n+    private void shrinkCacheToMaximumSize() {\n+        // Rich Dougherty: This could be more efficient.\n+        while (cacheSize > maximumCacheSize) {\n+            getNodeFromCache();\n+        }\n+    }\n+    \n+    /**\n+     * Gets a node from the cache. If a node is returned, then the value of\n+     * {@link #cacheSize} is decreased accordingly. The node that is returned\n+     * will have <code>null</code> values for next, previous and element.\n+     * \n+     * @return A node, or <code>null</code> if there are no nodes in the cache.\n+     */\n+    private Node getNodeFromCache() {\n+        if (cacheSize == 0) {\n+            return null;\n+        }\n+        Node cachedNode = firstCachedNode;\n+        firstCachedNode = cachedNode.next;\n+        cachedNode.next = null; // This should be changed anyway, but defensively\n+                                             // set it to null.\n+        cacheSize--;\n+        return cachedNode;\n+    }\n+    \n+    private boolean cacheFull() {\n+        return cacheSize >= maximumCacheSize;\n+    }\n+    \n+    /**\n+     * Adds a node to the cache, if the cache isn't full. The node's contents\n+     * are cleared to so they can be garbage collected.\n+     */\n+    private void addNodeToCache(Node node) {\n+        if (cacheFull()) {\n+            // Don't cache the node.\n+            return;\n+        }\n+        // Clear the node's contents and add it to the cache.\n+        Node nextCachedNode = firstCachedNode;\n+        node.previous = null;\n+        node.next = nextCachedNode;\n+        node.element = null;\n+        firstCachedNode = node;\n+        cacheSize++;\n+    }\n+    \n+    // Node operations\n+\n+    /**\n+     * Create a node, getting it from the cache if possible.\n+     */\n+    protected Node createNode() {\n+        Node cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createNode();\n+        } else {\n+            return cachedNode;\n+        }\n+    }\n+    \n+    /**\n+     * Create a node, getting it from the cache if possible.\n+     */\n+    protected Node createNode(Node next, Node previous, Object element) {\n+        Node cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createNode(next, previous, element);\n+        } else {\n+            cachedNode.next = next;\n+            cachedNode.previous = previous;\n+            cachedNode.element = element;\n+            return cachedNode;\n+        }\n+    }\n+\n+    /**\n+     * Calls the superclass' implementation then calls\n+     * {@link #addNodeToCache(Node)} on the node which has been removed.\n+     * \n+     * @see org.apache.commons.collections.CommonsLinkedList#removeNode(Node)\n+     */\n+    protected void removeNode(Node node) {\n+        super.removeNode(node);\n+        addNodeToCache(node);\n+    }\n+    \n+    protected void removeAllNodes() {\n+        // Add the removed nodes to the cache, then remove the rest.\n+        // We can add them to the cache before removing them, since\n+        // {@link CommonsLinkedList.removeAllNodes()} removes the\n+        // nodes by removing references directly from {@link #marker}.\n+        int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n+        Node node = marker.next;\n+        for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n+            Node oldNode = node;\n+            node = node.next;\n+            addNodeToCache(oldNode);\n+        }\n+        super.removeAllNodes();        \n+    }\n+\n+}", "timestamp": 1041982857, "metainfo": ""}