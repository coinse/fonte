{"sha": "484bfbe25535134e011d72dcdc3ea7cf1154ec6e", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r471189 | scolebourne | 2006-11-04 05:57:57 -0800 (Sat, 04 Nov 2006) | 1 line          Remove getMap(), getOrderedMap() and getSortedMap() - use decorated()     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n import java.util.NoSuchElementException;\n import java.util.Set;\n \n-import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.OrderedMap;\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.ResettableIterator;\n-import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.iterators.AbstractUntypedIteratorDecorator;\n import org.apache.commons.collections.keyvalue.AbstractMapEntry;\n import org.apache.commons.collections.list.UnmodifiableList;\n \n  * @author Matt Benson\n  * @author Dave Meikle\n  */\n-public class ListOrderedMap\n-        extends AbstractMapDecorator\n-        implements OrderedMap, Serializable {\n+public class ListOrderedMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements OrderedMap<K, V>, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 2728177751851003750L;\n \n     /** Internal list to hold the sequence of objects */\n-    protected final List insertOrder = new ArrayList();\n+    protected final List<K> insertOrder = new ArrayList<K>();\n \n     /**\n      * Factory method to create an ordered map.\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static OrderedMap decorate(Map map) {\n-        return new ListOrderedMap(map);\n+    public static <K, V> OrderedMap<K, V> decorate(Map<K, V> map) {\n+        return new ListOrderedMap<K, V>(map);\n     }\n \n     //-----------------------------------------------------------------------\n      * @since Commons Collections 3.1\n      */\n     public ListOrderedMap() {\n-        this(new HashMap());\n+        this(new HashMap<K, V>());\n     }\n \n     /**\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected ListOrderedMap(Map map) {\n+    protected ListOrderedMap(Map<K, V> map) {\n         super(map);\n-        insertOrder.addAll(getMap().keySet());\n+        insertOrder.addAll(decorated().keySet());\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ClassNotFoundException\n      * @since Commons Collections 3.1\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map) in.readObject();\n \n     // Implement OrderedMap\n     //-----------------------------------------------------------------------\n-    public MapIterator mapIterator() {\n-        return orderedMapIterator();\n-    }\n-\n-    public OrderedMapIterator orderedMapIterator() {\n-        return new ListOrderedMapIterator(this);\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new ListOrderedMapIterator<K, V>(this);\n     }\n \n     /**\n      * @return the first key currently in this map\n      * @throws NoSuchElementException if this map is empty\n      */\n-    public Object firstKey() {\n+    public K firstKey() {\n         if (size() == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n         }\n      * @return the last key currently in this map\n      * @throws NoSuchElementException if this map is empty\n      */\n-    public Object lastKey() {\n+    public K lastKey() {\n         if (size() == 0) {\n             throw new NoSuchElementException(\"Map is empty\");\n         }\n      * @param key  the key to find previous for\n      * @return the next key, null if no match or at start\n      */\n-    public Object nextKey(Object key) {\n+    public K nextKey(Object key) {\n         int index = insertOrder.indexOf(key);\n         if (index >= 0 && index < size() - 1) {\n             return insertOrder.get(index + 1);\n      * @param key  the key to find previous for\n      * @return the previous key, null if no match or at start\n      */\n-    public Object previousKey(Object key) {\n+    public K previousKey(Object key) {\n         int index = insertOrder.indexOf(key);\n         if (index > 0) {\n             return insertOrder.get(index - 1);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object put(Object key, Object value) {\n-        if (getMap().containsKey(key)) {\n+    public V put(K key, V value) {\n+        if (decorated().containsKey(key)) {\n             // re-adding doesn't change order\n-            return getMap().put(key, value);\n+            return decorated().put(key, value);\n         } else {\n             // first add, so add to both map and list\n-            Object result = getMap().put(key, value);\n+            V result = decorated().put(key, value);\n             insertOrder.add(key);\n             return result;\n         }\n     }\n \n-    public void putAll(Map map) {\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n+    public void putAll(Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n      * @param index the index in the Map to start at.\n      * @param map the Map containing the values to be added.\n      */\n-    public void putAll(int index, Map map) {\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n+    public void putAll(int index, Map<? extends K, ? extends V> map) {\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(index, entry.getKey(), entry.getValue());\n             index++;\n         }\n     }\n \n-    public Object remove(Object key) {\n-        Object result = getMap().remove(key);\n+    public V remove(Object key) {\n+        V result = decorated().remove(key);\n         insertOrder.remove(key);\n         return result;\n     }\n \n     public void clear() {\n-        getMap().clear();\n+        decorated().clear();\n         insertOrder.clear();\n     }\n \n      * @see #keyList()\n      * @return the fully modifiable collection view over the keys\n      */\n-    public Set keySet() {\n-        return new KeySetView(this);\n+    public Set<K> keySet() {\n+        return new KeySetView<K>(this);\n     }\n \n     /**\n      * @return the unmodifiable list view over the keys\n      * @since Commons Collections 3.2\n      */\n-    public List keyList() {\n+    public List<K> keyList() {\n         return UnmodifiableList.decorate(insertOrder);\n     }\n \n      * @see #valueList()\n      * @return the fully modifiable collection view over the values\n      */\n-    public Collection values() {\n-        return new ValuesView(this);\n+    public Collection<V> values() {\n+        return new ValuesView<V>(this);\n     }\n \n     /**\n      * @return the partially modifiable list view over the values\n      * @since Commons Collections 3.2\n      */\n-    public List valueList() {\n-        return new ValuesView(this);\n+    public List<V> valueList() {\n+        return new ValuesView<V>(this);\n     }\n \n     /**\n      *\n      * @return the fully modifiable set view over the entries\n      */\n-    public Set entrySet() {\n-        return new EntrySetView(this, this.insertOrder);\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return new EntrySetView<K, V>(this, this.insertOrder);\n     }\n \n     //-----------------------------------------------------------------------\n         StringBuffer buf = new StringBuffer();\n         buf.append('{');\n         boolean first = true;\n-        Iterator it = entrySet().iterator();\n-        while (it.hasNext()) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            Object key = entry.getKey();\n-            Object value = entry.getValue();\n+        for (Map.Entry<K, V> entry : entrySet()) {\n+            K key = entry.getKey();\n+            V value = entry.getValue();\n             if (first) {\n                 first = false;\n             } else {\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public Object get(int index) {\n+    public K get(int index) {\n         return insertOrder.get(index);\n     }\n     \n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public Object getValue(int index) {\n+    public V getValue(int index) {\n         return get(insertOrder.get(index));\n     }\n     \n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @since Commons Collections 3.2\n      */\n-    public Object setValue(int index, Object value) {\n-        Object key = insertOrder.get(index);\n+    public V setValue(int index, V value) {\n+        K key = insertOrder.get(index);\n         return put(key, value);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * @since Commons Collections 3.2\n      */\n-    public Object put(int index, Object key, Object value) {\n-        Map m = getMap();\n+    public V put(int index, K key, V value) {\n+        Map<K, V> m = decorated();\n         if (m.containsKey(key)) {\n-            Object result = m.remove(key);\n+            V result = m.remove(key);\n             int pos = insertOrder.indexOf(key);\n             insertOrder.remove(pos);\n             if (pos < index) {\n      * @return the removed value, or <code>null</code> if none existed\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public Object remove(int index) {\n+    public V remove(int index) {\n         return remove(get(index));\n     }\n \n      * @see #keySet()\n      * @return The ordered list of keys.  \n      */\n-    public List asList() {\n+    public List<K> asList() {\n         return keyList();\n     }\n \n     //-----------------------------------------------------------------------\n-    static class ValuesView extends AbstractList {\n-        private final ListOrderedMap parent;\n-\n-        ValuesView(ListOrderedMap parent) {\n+    static class ValuesView<V> extends AbstractList<V> {\n+        private final ListOrderedMap<Object, V> parent;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ValuesView(ListOrderedMap<?, V> parent) {\n             super();\n-            this.parent = parent;\n+            this.parent = (ListOrderedMap<Object, V>) parent;\n         }\n \n         public int size() {\n             this.parent.clear();\n         }\n \n-        public Iterator iterator() {\n-            return new AbstractIteratorDecorator(parent.entrySet().iterator()) {\n-                public Object next() {\n-                    return ((Map.Entry) iterator.next()).getValue();\n+        public Iterator<V> iterator() {\n+            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n+                public V next() {\n+                    return getIterator().next().getValue();\n                 }\n             };\n         }\n \n-        public Object get(int index) {\n+        public V get(int index) {\n             return this.parent.getValue(index);\n         }\n \n-        public Object set(int index, Object value) {\n+        public V set(int index, V value) {\n             return this.parent.setValue(index, value);\n         }\n \n-        public Object remove(int index) {\n+        public V remove(int index) {\n             return this.parent.remove(index);\n         }\n     }\n \n     //-----------------------------------------------------------------------\n-    static class KeySetView extends AbstractSet {\n-        private final ListOrderedMap parent;\n-\n-        KeySetView(ListOrderedMap parent) {\n+    static class KeySetView<K> extends AbstractSet<K> {\n+        private final ListOrderedMap<K, Object> parent;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        KeySetView(ListOrderedMap<K, ?> parent) {\n             super();\n-            this.parent = parent;\n+            this.parent = (ListOrderedMap<K, Object>) parent;\n         }\n \n         public int size() {\n             this.parent.clear();\n         }\n \n-        public Iterator iterator() {\n-            return new AbstractIteratorDecorator(parent.entrySet().iterator()) {\n-                public Object next() {\n-                    return ((Map.Entry) super.next()).getKey();\n+        public Iterator<K> iterator() {\n+            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n+                public K next() {\n+                    return getIterator().next().getKey();\n                 }\n             };\n         }\n     }\n \n     //-----------------------------------------------------------------------    \n-    static class EntrySetView extends AbstractSet {\n-        private final ListOrderedMap parent;\n-        private final List insertOrder;\n-        private Set entrySet;\n-\n-        public EntrySetView(ListOrderedMap parent, List insertOrder) {\n+    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        private final ListOrderedMap<K, V> parent;\n+        private final List<K> insertOrder;\n+        private Set<Map.Entry<K, V>> entrySet;\n+\n+        public EntrySetView(ListOrderedMap<K, V> parent, List<K> insertOrder) {\n             super();\n             this.parent = parent;\n             this.insertOrder = insertOrder;\n         }\n \n-        private Set getEntrySet() {\n+        private Set<Map.Entry<K, V>> getEntrySet() {\n             if (entrySet == null) {\n-                entrySet = parent.getMap().entrySet();\n+                entrySet = parent.decorated().entrySet();\n             }\n             return entrySet;\n         }\n             return getEntrySet().contains(obj);\n         }\n \n-        public boolean containsAll(Collection coll) {\n+        public boolean containsAll(Collection<?> coll) {\n             return getEntrySet().containsAll(coll);\n         }\n \n+        @SuppressWarnings(\"unchecked\")\n         public boolean remove(Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n             if (getEntrySet().contains(obj)) {\n-                Object key = ((Map.Entry) obj).getKey();\n+                Object key = ((Map.Entry<K, V>) obj).getKey();\n                 parent.remove(key);\n                 return true;\n             }\n         public void clear() {\n             this.parent.clear();\n         }\n-        \n+\n         public boolean equals(Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n             return getEntrySet().equals(obj);\n         }\n-        \n+\n         public int hashCode() {\n             return getEntrySet().hashCode();\n         }\n         public String toString() {\n             return getEntrySet().toString();\n         }\n+\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return new ListOrderedIterator<K, V>(parent, insertOrder);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n+        private final ListOrderedMap<K, V> parent;\n+        private K last = null;\n         \n-        public Iterator iterator() {\n-            return new ListOrderedIterator(parent, insertOrder);\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    static class ListOrderedIterator extends AbstractIteratorDecorator {\n-        private final ListOrderedMap parent;\n-        private Object last = null;\n-        \n-        ListOrderedIterator(ListOrderedMap parent, List insertOrder) {\n+        ListOrderedIterator(ListOrderedMap<K, V> parent, List<K> insertOrder) {\n             super(insertOrder.iterator());\n             this.parent = parent;\n         }\n-        \n-        public Object next() {\n-            last = super.next();\n-            return new ListOrderedMapEntry(parent, last);\n+\n+        public Map.Entry<K, V> next() {\n+            last = getIterator().next();\n+            return new ListOrderedMapEntry<K, V>(parent, last);\n         }\n \n         public void remove() {\n             super.remove();\n-            parent.getMap().remove(last);\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    static class ListOrderedMapEntry extends AbstractMapEntry {\n-        private final ListOrderedMap parent;\n-        \n-        ListOrderedMapEntry(ListOrderedMap parent, Object key) {\n+            parent.decorated().remove(last);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n+        private final ListOrderedMap<K, V> parent;\n+\n+        ListOrderedMapEntry(ListOrderedMap<K, V> parent, K key) {\n             super(key, null);\n             this.parent = parent;\n         }\n-        \n-        public Object getValue() {\n+\n+        public V getValue() {\n             return parent.get(key);\n         }\n \n-        public Object setValue(Object value) {\n-            return parent.getMap().put(key, value);\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    static class ListOrderedMapIterator implements OrderedMapIterator, ResettableIterator {\n-        private final ListOrderedMap parent;\n-        private ListIterator iterator;\n-        private Object last = null;\n+        public V setValue(V value) {\n+            return parent.decorated().put(key, value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+        private final ListOrderedMap<K, V> parent;\n+        private ListIterator<K> iterator;\n+        private K last = null;\n         private boolean readable = false;\n-        \n-        ListOrderedMapIterator(ListOrderedMap parent) {\n+\n+        ListOrderedMapIterator(ListOrderedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             this.iterator = parent.insertOrder.listIterator();\n         }\n-        \n+\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n-        \n-        public Object next() {\n+\n+        public K next() {\n             last = iterator.next();\n             readable = true;\n             return last;\n         public boolean hasPrevious() {\n             return iterator.hasPrevious();\n         }\n-        \n-        public Object previous() {\n+\n+        public K previous() {\n             last = iterator.previous();\n             readable = true;\n             return last;\n         }\n-        \n+\n         public void remove() {\n             if (readable == false) {\n                 throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             parent.map.remove(last);\n             readable = false;\n         }\n-        \n-        public Object getKey() {\n+\n+        public K getKey() {\n             if (readable == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             return last;\n         }\n \n-        public Object getValue() {\n+        public V getValue() {\n             if (readable == false) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return parent.get(last);\n         }\n-        \n-        public Object setValue(Object value) {\n+\n+        public V setValue(V value) {\n             if (readable == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             return parent.map.put(last, value);\n         }\n-        \n+\n         public void reset() {\n             iterator = parent.insertOrder.listIterator();\n             last = null;\n             readable = false;\n         }\n-        \n+\n         public String toString() {\n             if (readable == true) {\n                 return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n-            } else {\n-                return \"Iterator[]\";\n-            }\n-        }\n-    }\n-    \n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n }", "timestamp": 1252994170, "metainfo": ""}