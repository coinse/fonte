{"sha": "f6692b29e618b32597d282fc2f2aca2d664de241", "log": "Tidy javadoc and code layout   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BinaryHeap.java\n+++ b/src/java/org/apache/commons/collections/BinaryHeap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.10 2002/08/15 20:04:31 pjack Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/08/15 20:04:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.11 2002/10/13 12:59:04 scolebourne Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/10/13 12:59:04 $\n  *\n  * ====================================================================\n  *\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n import java.util.Comparator;\n-\n /**\n  * Binary heap implementation of {@link PriorityQueue} and {@link Buffer}.\n- *\n+ * <p>\n  * The removal order of a binary heap is based on either the natural sort\n  * order of its elements or a specified {@link Comparator}.  The \n  * {@link #remove()} method always returns the first element as determined\n- * by the sort order.  (The <Code>isMinHeap</Code> flag in the constructors\n+ * by the sort order.  (The <code>isMinHeap</code> flag in the constructors\n  * can be used to reverse the sort order, in which case {@link #remove()}\n  * will always remove the last element.)  The removal order is \n- * <I>not</I> the same as the order of iteration; elements are\n- * returned by the iterator in no particular order.<P>\n- *\n+ * <i>not</i> the same as the order of iteration; elements are\n+ * returned by the iterator in no particular order.\n+ * <p>\n  * The {@link #add(Object)} and {@link #remove()} operations perform\n  * in logarithmic time.  The {@link #get()} operation performs in constant\n- * time.  All other operations perform in linear time or worse.<P>\n- *\n+ * time.  All other operations perform in linear time or worse.\n+ * <p>\n  * Note that this implementation is not synchronized.  Use \n  * {@link BufferUtils#synchronizedBuffer(Buffer)} to provide\n- * synchronized access to a <Code>BinaryHeap</Code>:\n- *\n- * <Pre>\n+ * synchronized access to a <code>BinaryHeap</code>:\n+ *\n+ * <pre>\n  * Buffer heap = BufferUtils.synchronizedBuffer(new BinaryHeap());\n- * </Pre>\n- *\n+ * </pre>\n+ *\n+ * @author <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n+ * @author <a href=\"mailto:ram.chidambaram@telus.com\">Ram Chidambaram</a>\n+ * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n  * @since 1.0\n- * @author  <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n- * @author  <a href=\"mailto:ram.chidambaram@telus.com\">Ram Chidambaram</a>\n- * @author  <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n- * @author  Paul Jack\n+ * @version $Id: BinaryHeap.java,v 1.11 2002/10/13 12:59:04 scolebourne Exp $\n  */\n public final class BinaryHeap extends AbstractCollection\n-    implements PriorityQueue, Buffer\n-{\n-\n-    /**\n-     *  The default capacity for a binary heap.\n-     */\n-    protected final static int      DEFAULT_CAPACITY   = 13;\n-\n-    /**\n-     *  The number of elements currently in this heap.\n-     */\n-    protected int                   m_size;\n-\n-    /**\n-     *  The elements in this heap.\n-     */\n-    protected Object[]              m_elements;\n-\n-    /**\n-     *  If true, the first element as determined by the sort order will \n-     *  be returned.  If false, the last element as determiend by the\n-     *  sort order will be returned.\n-     */\n-    protected boolean               m_isMinHeap;\n-    private Comparator              m_comparator;\n-\n-    /**\n-     *  Create a new minimum binary heap.\n-     */\n-    public BinaryHeap()\n-    {\n-        this( DEFAULT_CAPACITY, true );\n-    }\n-\n-    /**\n-     *  Constructs a new <Code>BinaryHeap</Code> that will use the given\n-     *  comparator to order its elements.\n-     */\n-    public BinaryHeap( Comparator comparator )\n-    {\n+        implements PriorityQueue, Buffer {\n+\n+    /**\n+     * The default capacity for a binary heap.\n+     */\n+    private final static int DEFAULT_CAPACITY = 13;\n+    /**\n+     * The number of elements currently in this heap.\n+     */\n+    int m_size;  // package scoped for testing\n+    /**\n+     * The elements in this heap.\n+     */\n+    Object[] m_elements;  // package scoped for testing\n+    /**\n+     * If true, the first element as determined by the sort order will \n+     * be returned.  If false, the last element as determined by the\n+     * sort order will be returned.\n+     */\n+    boolean m_isMinHeap;  // package scoped for testing\n+    /**\n+     * The comparator used to order the elements\n+     */\n+    Comparator m_comparator;  // package scoped for testing\n+\n+    /**\n+     * Constructs a new minimum binary heap.\n+     */\n+    public BinaryHeap() {\n+        this(DEFAULT_CAPACITY, true);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code> that will use the given\n+     * comparator to order its elements.\n+     * \n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     */\n+    public BinaryHeap(Comparator comparator) {\n         this();\n         m_comparator = comparator;\n     }\n-\n-    /**\n-     *  Create a new minimum binary heap with the specified initial capacity.\n+    \n+    /**\n+     * Constructs a new minimum binary heap with the specified initial capacity.\n      *  \n-     *  @param capacity the initial capacity for the heap.  This value must\n+     * @param capacity  The initial capacity for the heap.  This value must\n      *  be greater than zero.\n-     *\n-     *  @exception IllegalArgumentException \n-     *   if <code>capacity</code> is &lt;= <code>0</code>\n-     **/\n-    public BinaryHeap( final int capacity )\n-    {\n-        this( capacity, true );\n-    }\n-\n-    /**\n-     *  Constructs a new <Code>BinaryHeap</Code>.\n-     *\n-     *  @param capacity  the initial capacity for the heap\n-     *  @param comparator  the comparator to use to order elements\n-     *  @exception IllegalArgumentException \n-     *   if <code>capacity</code> is <code>&lt;= 0</code>\n-     */\n-    public BinaryHeap( final int capacity, Comparator comparator )\n-    {\n-        this( capacity );\n+     * @throws IllegalArgumentException  \n+     *  if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public BinaryHeap(int capacity) {\n+        this(capacity, true);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code>.\n+     *\n+     * @param capacity  the initial capacity for the heap\n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     * @throws IllegalArgumentException  \n+     *  if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public BinaryHeap(int capacity, Comparator comparator) {\n+        this(capacity);\n         m_comparator = comparator;\n     }\n \n     /**\n-     *  Create a new minimum or maximum binary heap\n-     *\n-     *  @param isMinHeap if <code>true</code> the heap is created as a \n+     * Constructs a new minimum or maximum binary heap\n+     *\n+     * @param isMinHeap  if <code>true</code> the heap is created as a \n+     * minimum heap; otherwise, the heap is created as a maximum heap\n+     */\n+    public BinaryHeap(boolean isMinHeap) {\n+        this(DEFAULT_CAPACITY, isMinHeap);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code>.\n+     *\n+     * @param isMinHeap  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     */\n+    public BinaryHeap(boolean isMinHeap, Comparator comparator) {\n+        this(isMinHeap);\n+        m_comparator = comparator;\n+    }\n+\n+    /**\n+     * Constructs a new minimum or maximum binary heap with the specified \n+     * initial capacity.\n+     *\n+     * @param capacity the initial capacity for the heap.  This value must \n+     * be greater than zero.\n+     * @param isMinHeap if <code>true</code> the heap is created as a \n      *  minimum heap; otherwise, the heap is created as a maximum heap.\n-     **/\n-    public BinaryHeap( final boolean isMinHeap )\n-    {\n-        this( DEFAULT_CAPACITY, isMinHeap );\n-    }\n-\n-    /**\n-     *  Constructs a new <Code>BinaryHeap</Code>.\n-     *\n-     *  @param isMinHeap  true to use the order imposed by the given \n-     *    comparator; false to reverse that order\n-     *  @param comparator  the comparator to use to order elements\n-     */\n-    public BinaryHeap( final boolean isMinHeap, Comparator comparator )\n-    {\n-        this( isMinHeap );\n+     * @throws IllegalArgumentException \n+     *  if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    public BinaryHeap(int capacity, boolean isMinHeap) {\n+        if (capacity <= 0) {\n+            throw new IllegalArgumentException(\"invalid capacity\");\n+        }\n+        m_isMinHeap = isMinHeap;\n+\n+        //+1 as 0 is noop\n+        m_elements = new Object[capacity + 1];\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code>.\n+     *\n+     * @param capacity  the initial capacity for the heap\n+     * @param isMinHeap  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     * @throws IllegalArgumentException \n+     *  if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    public BinaryHeap(int capacity, boolean isMinHeap, Comparator comparator) {\n+        this(capacity, isMinHeap);\n         m_comparator = comparator;\n     }\n \n-    /**\n-     *  Create a new minimum or maximum binary heap with the specified \n-     *  initial capacity.\n-     *\n-     *  @param capacity the initial capacity for the heap.  This value must \n-     *  be greater than zero.\n-     *\n-     *  @param isMinHeap if <code>true</code> the heap is created as a \n-     *  minimum heap; otherwise, the heap is created as a maximum heap.\n-     *\n-     *  @exception IllegalArgumentException \n-     *   if <code>capacity</code> is <code>&lt;= 0</code>\n-     **/\n-    public BinaryHeap( final int capacity, final boolean isMinHeap )\n-    {\n-        if( capacity <= 0 ) {\n-            throw new IllegalArgumentException( \"invalid capacity\" );\n-        }\n-        m_isMinHeap = isMinHeap;\n-\n-        //+1 as 0 is noop\n-        m_elements = new Object[ capacity + 1 ];\n-    }\n-\n-    /**\n-     *  Constructs a new <Code>BinaryHeap</Code>.\n-     *\n-     *  @param capacity  the initial capacity for the heap\n-     *  @param isMinHeap  true to use the order imposed by the given \n-     *    comparator; false to reverse that order\n-     *  @param comparator  the comparator to use to order elements\n-     *  @exception IllegalArgumentException \n-     *   if <code>capacity</code> is <code>&lt;= 0</code>\n-     */\n-    public BinaryHeap( final int capacity, final boolean isMinHeap,\n-                       Comparator comparator ) \n-    {\n-        this( capacity, isMinHeap );\n-        m_comparator = comparator;\n-    }\n-\n-    /**\n-     * Clear all elements from queue.\n-     */\n-    public void clear()\n-    {\n+    \n+    /**\n+     * Clears all elements from queue.\n+     */\n+    public void clear() {\n+        m_elements = new Object[m_elements.length];  // for gc\n         m_size = 0;\n     }\n \n     /**\n-     * Test if queue is empty.\n+     * Tests if queue is empty.\n      *\n      * @return <code>true</code> if queue is empty; <code>false</code> \n-     * otherwise.\n-     */\n-    public boolean isEmpty()\n-    {\n-        return ( 0 == m_size );\n-    }\n-\n-    /**\n-     * Test if queue is full.\n+     *  otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return m_size == 0;\n+    }\n+\n+    /**\n+     * Tests if queue is full.\n      *\n      * @return <code>true</code> if queue is full; <code>false</code>\n-     * otherwise.\n-     */\n-    public boolean isFull()\n-    {\n+     *  otherwise.\n+     */\n+    public boolean isFull() {\n         //+1 as element 0 is noop\n-        return ( m_elements.length == m_size+1 );\n-    }\n-\n-    /**\n-     * Insert an element into queue.\n-     *\n-     * @param element the element to be inserted\n-     */\n-    public void insert( final Object element )\n-    {\n-        if( isFull() ) grow();\n-\n+        return m_elements.length == m_size + 1;\n+    }\n+\n+    /**\n+     * Inserts an element into queue.\n+     *\n+     * @param element  the element to be inserted\n+     */\n+    public void insert(Object element) {\n+        if (isFull()) {\n+            grow();\n+        }\n         //percolate element to it's place in tree\n-        if( m_isMinHeap ) percolateUpMinHeap( element );\n-        else percolateUpMaxHeap( element );\n-    }\n-\n-    /**\n-     * Return element on top of heap but don't remove it.\n+        if (m_isMinHeap) {\n+            percolateUpMinHeap(element);\n+        } else {\n+            percolateUpMaxHeap(element);\n+        }\n+    }\n+\n+    /**\n+     * Returns the element on top of heap but don't remove it.\n      *\n      * @return the element at top of heap\n-     * @exception NoSuchElementException if <code>isEmpty() == true</code>\n-     */\n-    public Object peek() throws NoSuchElementException\n-    {\n-        if( isEmpty() ) throw new NoSuchElementException();\n-        else return m_elements[ 1 ];\n-    }\n-\n-    /**\n-     * Return element on top of heap and remove it.\n+     * @throws NoSuchElementException  if <code>isEmpty() == true</code>\n+     */\n+    public Object peek() throws NoSuchElementException {\n+        if (isEmpty()) {\n+            throw new NoSuchElementException();\n+        } else {\n+            return m_elements[1];\n+        }\n+    }\n+\n+    /**\n+     * Returns the element on top of heap and remove it.\n      *\n      * @return the element at top of heap\n-     * @exception NoSuchElementException if <code>isEmpty() == true</code>\n-     */\n-    public Object pop() throws NoSuchElementException\n-    {\n+     * @throws NoSuchElementException  if <code>isEmpty() == true</code>\n+     */\n+    public Object pop() throws NoSuchElementException {\n         final Object result = peek();\n-        m_elements[ 1 ] = m_elements[ m_size-- ];\n-\n-        //set the unused element to 'null' so that the garbage collector\n-        //can free the object if not used anywhere else.(remove reference)\n-        m_elements[ m_size + 1 ] = null;\n-\n-        if( m_size != 0 )\n-        {\n-            //percolate top element to it's place in tree\n-            if( m_isMinHeap ) percolateDownMinHeap( 1 );\n-            else percolateDownMaxHeap( 1 );\n+        m_elements[1] = m_elements[m_size--];\n+\n+        // set the unused element to 'null' so that the garbage collector\n+        // can free the object if not used anywhere else.(remove reference)\n+        m_elements[m_size + 1] = null;\n+\n+        if (m_size != 0) {\n+            // percolate top element to it's place in tree\n+            if (m_isMinHeap) {\n+                percolateDownMinHeap(1);\n+            } else {\n+                percolateDownMaxHeap(1);\n+            }\n         }\n \n         return result;\n     }\n \n     /**\n-     * Percolate element down heap from top.\n+     * Percolates element down heap from top.\n      * Assume it is a maximum heap.\n      *\n      * @param index the index for the element\n      */\n-    protected void percolateDownMinHeap( final int index )\n-    {\n-        final Object element = m_elements[ index ];\n-\n+    protected void percolateDownMinHeap(final int index) {\n+        final Object element = m_elements[index];\n         int hole = index;\n \n-        while( (hole * 2) <= m_size )\n-        {\n+        while ((hole * 2) <= m_size) {\n             int child = hole * 2;\n \n-            //if we have a right child and that child can not be percolated\n-            //up then move onto other child\n-            if( child != m_size && \n-                compare( m_elements[ child + 1 ], m_elements[ child ] ) < 0 )\n-            {\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != m_size && compare(m_elements[child + 1], m_elements[child]) < 0) {\n                 child++;\n             }\n \n-            //if we found resting place of bubble then terminate search\n-            if( compare( m_elements[ child ], element ) >= 0 )\n-            {\n+            // if we found resting place of bubble then terminate search\n+            if (compare(m_elements[child], element) >= 0) {\n                 break;\n             }\n \n-            m_elements[ hole ] = m_elements[ child ];\n+            m_elements[hole] = m_elements[child];\n             hole = child;\n         }\n \n-        m_elements[ hole ] = element;\n-    }\n-\n-    /**\n-     * Percolate element down heap from top.\n+        m_elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element down heap from top.\n      * Assume it is a maximum heap.\n      *\n      * @param index the index of the element\n      */\n-    protected void percolateDownMaxHeap( final int index )\n-    {\n-        final Object element = m_elements[ index ];\n-\n+    protected void percolateDownMaxHeap(final int index) {\n+        final Object element = m_elements[index];\n         int hole = index;\n \n-        while( (hole * 2) <= m_size )\n-        {\n+        while ((hole * 2) <= m_size) {\n             int child = hole * 2;\n \n-            //if we have a right child and that child can not be percolated\n-            //up then move onto other child\n-            if( child != m_size &&\n-                compare( m_elements[ child + 1 ], m_elements[ child ] ) > 0 )\n-            {\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != m_size && compare(m_elements[child + 1], m_elements[child]) > 0) {\n                 child++;\n             }\n \n-            //if we found resting place of bubble then terminate search\n-            if( compare( m_elements[ child ], element ) <= 0 )\n-            {\n+            // if we found resting place of bubble then terminate search\n+            if (compare(m_elements[child], element) <= 0) {\n                 break;\n             }\n \n-            m_elements[ hole ] = m_elements[ child ];\n+            m_elements[hole] = m_elements[child];\n             hole = child;\n         }\n \n-        m_elements[ hole ] = element;\n-    }\n-\n-    /**\n-     * Percolate element up heap from bottom.\n+        m_elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element up heap from bottom.\n      * Assume it is a maximum heap.\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMinHeap( final Object element )\n-    {\n+    protected void percolateUpMinHeap(final Object element) {\n         int hole = ++m_size;\n \n-        m_elements[ hole ] = element;\n-\n-        while( hole > 1 &&\n-               compare( element,  m_elements[ hole / 2 ] ) < 0 )\n-        {\n-            //save element that is being pushed down\n-            //as the element \"bubble\" is percolated up\n+        m_elements[hole] = element;\n+\n+        while (hole > 1 && compare(element, m_elements[hole / 2]) < 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n             final int next = hole / 2;\n-            m_elements[ hole ] = m_elements[ next ];\n+            m_elements[hole] = m_elements[next];\n             hole = next;\n         }\n \n-        m_elements[ hole ] = element;\n-    }\n-\n-    /**\n-     * Percolate element up heap from bottom.\n+        m_elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element up heap from bottom.\n      * Assume it is a maximum heap.\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMaxHeap( final Object element )\n-    {\n+    protected void percolateUpMaxHeap(final Object element) {\n         int hole = ++m_size;\n \n-        while( hole > 1 &&\n-               compare( element, m_elements[ hole / 2 ] ) > 0 )\n-        {\n-            //save element that is being pushed down\n-            //as the element \"bubble\" is percolated up\n+        while (hole > 1 && compare(element, m_elements[hole / 2]) > 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n             final int next = hole / 2;\n-            m_elements[ hole ] = m_elements[ next ];\n+            m_elements[hole] = m_elements[next];\n             hole = next;\n         }\n \n-        m_elements[ hole ] = element;\n-    }\n-\n+        m_elements[hole] = element;\n+    }\n+    \n+    /**\n+     * Compares two objects using the comparator if specified, or the\n+     * natural order otherwise.\n+     * \n+     * @param a  the first object\n+     * @param b  the second object\n+     * @return -ve if a less than b, 0 if they are equal, +ve if a greater than b\n+     */\n     private int compare(Object a, Object b) {\n-        if(m_comparator != null) {\n+        if (m_comparator != null) {\n             return m_comparator.compare(a, b);\n         } else {\n-            return ((Comparable)a).compareTo(b);\n-        }\n-    }\n-\n-    /**\n-     *  Increase the size of the heap to support additional elements\n-     **/\n-    protected void grow()\n-    {\n-        final Object[] elements = new Object[ m_elements.length * 2 ];\n-        System.arraycopy( m_elements, 0, elements, 0, m_elements.length );\n+            return ((Comparable) a).compareTo(b);\n+        }\n+    }\n+\n+    /**\n+     * Increases the size of the heap to support additional elements\n+     */\n+    protected void grow() {\n+        final Object[] elements = new Object[m_elements.length * 2];\n+        System.arraycopy(m_elements, 0, elements, 0, m_elements.length);\n         m_elements = elements;\n     }\n \n     /**\n-     *  Returns a string representation of this heap.  The returned string\n-     *  is similar to those produced by standard JDK collections.\n-     *\n-     *  @return  a string representation of this heap\n-     */\n-    public String toString()\n-    {\n+     * Returns a string representation of this heap.  The returned string\n+     * is similar to those produced by standard JDK collections.\n+     *\n+     * @return a string representation of this heap\n+     */\n+    public String toString() {\n         final StringBuffer sb = new StringBuffer();\n \n-        sb.append( \"[ \" );\n-\n-        for( int i = 1; i < m_size + 1; i++ )\n-        {\n-            if( i != 1 ) sb.append( \", \" );\n-            sb.append( m_elements[ i ] );\n-        }\n-\n-        sb.append( \" ]\" );\n+        sb.append(\"[ \");\n+\n+        for (int i = 1; i < m_size + 1; i++) {\n+            if (i != 1) {\n+                sb.append(\", \");\n+            }\n+            sb.append(m_elements[i]);\n+        }\n+\n+        sb.append(\" ]\");\n \n         return sb.toString();\n     }\n \n \n     /**\n-     *  Returns an iterator over this heap's elements.\n-     *\n-     *  @return an iterator over this heap's elements\n+     * Returns an iterator over this heap's elements.\n+     *\n+     * @return an iterator over this heap's elements\n      */\n     public Iterator iterator() {\n         return new Iterator() {\n \n \n     /**\n-     *  Adds an object to this heap.  Same as {@link #insert(Object)}.\n-     *\n-     *  @param o  the object to add\n-     *  @return true, always\n-     */\n-    public boolean add(Object o) {\n-        insert(o);\n+     * Adds an object to this heap. Same as {@link #insert(Object)}.\n+     *\n+     * @param object  the object to add\n+     * @return true, always\n+     */\n+    public boolean add(Object object) {\n+        insert(object);\n         return true;\n     }\n \n-\n-    /**\n-     *  Returns the priority element.  Same as {@link #peek()}.\n-     *\n-     *  @return the priority element\n-     *  @throws BufferUnderflowException if this heap is empty\n+    /**\n+     * Returns the priority element. Same as {@link #peek()}.\n+     *\n+     * @return the priority element\n+     * @throws BufferUnderflowException if this heap is empty\n      */\n     public Object get() {\n         try {\n         }\n     }\n \n-\n-    /**\n-     *  Removes the priority element.  Same as {@link #pop()}.\n-     *\n-     *  @return the removed priority element\n-     *  @throws BufferUnderflowException if this heap is empty\n+    /**\n+     * Removes the priority element. Same as {@link #pop()}.\n+     *\n+     * @return the removed priority element\n+     * @throws BufferUnderflowException if this heap is empty\n      */\n     public Object remove() {\n         try {\n         }\n     }\n \n-\n-    /**\n-     *  Returns the number of elements in this heap.\n-     *\n-     *  @return the number of elements in this heap\n+    /**\n+     * Returns the number of elements in this heap.\n+     *\n+     * @return the number of elements in this heap\n      */\n     public int size() {\n         return m_size;\n     }\n \n-    /**\n-     *  Used by testing code.\n-     *\n-     *  @return  the otherwise private comparator\n-     */\n-    Comparator comparator() {\n-        return m_comparator;\n-    }\n }\n-\n--- a/src/java/org/apache/commons/collections/BoundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/BoundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BoundedFifoBuffer.java,v 1.4 2002/08/13 00:46:25 pjack Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/08/13 00:46:25 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BoundedFifoBuffer.java,v 1.5 2002/10/13 12:59:04 scolebourne Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/10/13 12:59:04 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.collections;\n \n-\n import java.util.AbstractCollection;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n-\n-\n /**\n  * The BoundedFifoBuffer is a <strong>very</strong> efficient implementation of\n- * Buffer that does not alter the size of the buffer at runtime.<P>\n- *\n- * The removal order of a <Code>BoundedFifoBuffer</Code> is based on the \n+ * Buffer that does not alter the size of the buffer at runtime.\n+ * <p>\n+ * The removal order of a <code>BoundedFifoBuffer</code> is based on the \n  * insertion order; elements are removed in the same order in which they\n- * were added.  The iteration order is the same as the removal order.<P>\n- *\n+ * were added.  The iteration order is the same as the removal order.\n+ * <p>\n  * The {@link #add(Object)}, {@link #remove()} and {@link #get()} operations\n  * all perform in constant time.  All other operations perform in linear\n  * time or worse.\n- *\n+ * <p>\n  * Note that this implementation is not synchronized.  The following can be\n- * used to provide synchronized access to your <COde>BoundedFifoBuffer</Code>:\n- *\n- * <Pre>\n+ * used to provide synchronized access to your <code>BoundedFifoBuffer</code>:\n+ * <pre>\n  *   Buffer fifo = BufferUtils.synchronizedBuffer(new BoundedFifoBuffer());\n- * </Pre>\n- *\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ *\n+ * @author Avalon\n  * @author <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n  * @author Paul Jack\n- * @version $Id: BoundedFifoBuffer.java,v 1.4 2002/08/13 00:46:25 pjack Exp $\n- * @since Avalon 4.0\n+ * @author Stephen Colebourne\n+ * @since 2.1\n+ * @version $Id: BoundedFifoBuffer.java,v 1.5 2002/10/13 12:59:04 scolebourne Exp $\n  */\n-public class BoundedFifoBuffer extends AbstractCollection implements Buffer\n-{\n+public class BoundedFifoBuffer extends AbstractCollection implements Buffer {\n     private final Object[] m_elements;\n     private int m_start = 0;\n     private int m_end = 0;\n     private boolean m_full = false;\n \n-\n-    /**\n-     *  Constructs a new <Code>BoundedFifoBuffer</Code> big enough to hold\n-     *  the specified number of elements.\n-     *\n-     *  @param size  the maximum number of elements for this fifo\n-     */\n-    public BoundedFifoBuffer( int size )\n-    {\n-        m_elements = new Object[ size ];\n-    }\n-\n-\n-    /**\n-     *  Constructs a new <Code>BoundedFifoBuffer</Code> big enough to hold\n-     *  32 elements.\n-     */\n-    public BoundedFifoBuffer()\n-    {\n-        this( 32 );\n-    }\n-\n-\n-    /**\n-     *  Constructs a new <Code>BoundedFifoBuffer</Code> big enough to hold all\n-     *  of the elements in the specified collection.  That collection's\n-     *  elements will also be added to the fifo.\n-     *\n-     *  @param c  the collection whose elements to add\n-     */\n-    public BoundedFifoBuffer(Collection c) {\n-        this(c.size());\n-        addAll(c);\n-    }\n-\n-\n-    /**\n-     *  Returns this fifo's size.\n-     *\n-     *  @return this fifo's size\n-     */\n-    public int size()\n-    {\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold\n+     * 32 elements.\n+     */\n+    public BoundedFifoBuffer() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold\n+     * the specified number of elements.\n+     *\n+     * @param size  the maximum number of elements for this fifo\n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    public BoundedFifoBuffer(int size) {\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        m_elements = new Object[size];\n+    }\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold all\n+     * of the elements in the specified collection. That collection's\n+     * elements will also be added to the buffer.\n+     *\n+     * @param coll  the collection whose elements to add\n+     */\n+    public BoundedFifoBuffer(Collection coll) {\n+        this(coll.size());\n+        addAll(coll);\n+    }\n+\n+    /**\n+     * Returns the number of elements stored in the buffer.\n+     *\n+     * @return this buffer's size\n+     */\n+    public int size() {\n         int size = 0;\n \n-        if( m_end < m_start )\n-        {\n+        if (m_end < m_start) {\n             size = m_elements.length - m_start + m_end;\n-        }\n-        else if( m_end == m_start )\n-        {\n-            size = ( m_full ? m_elements.length : 0 );\n-        }\n-        else\n-        {\n+        } else if (m_end == m_start) {\n+            size = (m_full ? m_elements.length : 0);\n+        } else {\n             size = m_end - m_start;\n         }\n \n         return size;\n     }\n \n-\n-    /**\n-     *  Returns true if this fifo is empty; false otherwise.\n-     *\n-     *  @return true if this fifo is empty\n-     */\n-    public boolean isEmpty()\n-    {\n+    /**\n+     * Returns true if this buffer is empty; false otherwise.\n+     *\n+     * @return true if this buffer is empty\n+     */\n+    public boolean isEmpty() {\n         return size() == 0;\n     }\n \n-\n-    /**\n-     *  Adds the given element to this fifo.\n-     *\n-     *  @param element  the element to add\n-     *  @return true, always\n-     *  @throws NullPointerException if the given element is null\n-     *  @throws BufferOverflowException if this fifo is full\n-     */\n-    public boolean add( Object element )\n-    {\n-        if( null == element )\n-        {\n-            throw new NullPointerException( \"Attempted to add null object to buffer\" );\n-        }\n-\n-        if( m_full )\n-        {\n-            throw new BufferOverflowException( \"The buffer cannot hold more than \"\n-                                               + m_elements.length + \" objects.\" );\n-        }\n-\n-        m_elements[ m_end++ ] = element;\n-\n-        if( m_end >= m_elements.length )\n-        {\n+    /**\n+     * Clears this buffer.\n+     */\n+    public void clear() {\n+        m_full = false;\n+        m_start = 0;\n+        m_end = 0;\n+        Arrays.fill(m_elements, null);\n+    }\n+\n+    /**\n+     * Adds the given element to this buffer.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     * @throws BufferOverflowException  if this buffer is full\n+     */\n+    public boolean add(Object element) {\n+        if (null == element) {\n+            throw new NullPointerException(\"Attempted to add null object to buffer\");\n+        }\n+\n+        if (m_full) {\n+            throw new BufferOverflowException(\"The buffer cannot hold more than \" + m_elements.length + \" objects.\");\n+        }\n+\n+        m_elements[m_end++] = element;\n+\n+        if (m_end >= m_elements.length) {\n             m_end = 0;\n         }\n \n-        if( m_end == m_start )\n-        {\n+        if (m_end == m_start) {\n             m_full = true;\n         }\n \n         return true;\n     }\n \n-\n-    /**\n-     *  Returns the least recently inserted element in this fifo.\n-     *\n-     *  @return the least recently inserted element\n-     *  @throws BufferUnderflowException if the fifo is empty\n+    /**\n+     * Returns the least recently inserted element in this buffer.\n+     *\n+     * @return the least recently inserted element\n+     * @throws BufferUnderflowException  if the buffer is empty\n      */\n     public Object get() {\n-        if( isEmpty() )\n-        {\n-            throw new BufferUnderflowException( \"The buffer is already empty\" );\n-        }\n-\n-        return m_elements[ m_start ];\n-    }\n-\n-\n-    /**\n-     *  Removes the least recently inserted element from this fifo.\n-     *\n-     *  @return the least recently inserted element\n-     *  @throws BufferUnderflowException if the fifo is empty\n-     */\n-    public Object remove()\n-    {\n-        if( isEmpty() )\n-        {\n-            throw new BufferUnderflowException( \"The buffer is already empty\" );\n-        }\n-\n-        Object element = m_elements[ m_start ];\n-\n-        if( null != element )\n-        {\n-            m_elements[ m_start++ ] = null;\n-\n-            if( m_start >= m_elements.length )\n-            {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        return m_elements[m_start];\n+    }\n+\n+    /**\n+     * Removes the least recently inserted element from this buffer.\n+     *\n+     * @return the least recently inserted element\n+     * @throws BufferUnderflowException  if the buffer is empty\n+     */\n+    public Object remove() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        Object element = m_elements[m_start];\n+\n+        if (null != element) {\n+            m_elements[m_start++] = null;\n+\n+            if (m_start >= m_elements.length) {\n                 m_start = 0;\n             }\n \n         return element;\n     }\n \n-\n+    /**\n+     * Increments the internal index.\n+     * \n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n     private int increment(int index) {\n         index++; \n-        if (index >= m_elements.length) index = 0;\n+        if (index >= m_elements.length) {\n+            index = 0;\n+        }\n         return index;\n     }\n \n-\n+    /**\n+     * Decrements the internal index.\n+     * \n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n     private int decrement(int index) {\n         index--;\n-        if (index < 0) index = m_elements.length - 1;\n+        if (index < 0) {\n+            index = m_elements.length - 1;\n+        }\n         return index;\n     }\n \n-\n-    /**\n-     *  Returns an iterator over this fifo's elements.\n-     *\n-     *  @return an iterator over this fifo's elements\n+    /**\n+     * Returns an iterator over this buffer's elements.\n+     *\n+     * @return an iterator over this buffer's elements\n      */\n     public Iterator iterator() {\n         return new Iterator() {\n         };\n     }\n \n-\n-    /**\n-     *  Clears this fifo.\n-     */\n-    public void clear() {\n-        m_full = false;\n-        m_start = 0;\n-        m_end = 0;\n-        Arrays.fill(m_elements, null);\n-    }\n-\n }\n--- a/src/java/org/apache/commons/collections/Buffer.java\n+++ b/src/java/org/apache/commons/collections/Buffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Buffer.java,v 1.2 2002/07/03 01:45:47 mas Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/07/03 01:45:47 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Buffer.java,v 1.3 2002/10/13 12:58:04 scolebourne Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/10/13 12:58:04 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.collections;\n \n-\n import java.util.Collection;\n-\n-\n /**\n  * A Buffer is a collection that allows objects to be removed in some\n  * well-defined order.  The removal order can be based on insertion order\n  * also implement {@link java.util.List}, {@link java.util.Set} or \n  * {@link Bag}.\n  *\n- * @author  <a href=\"bloritsch@apache.org\">Berin Loritsch</a>\n- * @version CVS $Revision: 1.2 $ $Date: 2002/07/03 01:45:47 $\n- * @since Avalon 4.0\n+ * @author Avalon\n+ * @author <a href=\"bloritsch@apache.org\">Berin Loritsch</a>\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @version $Id: Buffer.java,v 1.3 2002/10/13 12:58:04 scolebourne Exp $\n+ * @since 2.1\n  */\n-public interface Buffer extends Collection\n-{\n+public interface Buffer extends Collection {\n \n     /**\n      * Removes the next object from the buffer.\n      */\n     Object remove();\n \n-\n-\n     /**\n-     *  Returns the next object in the buffer without removing it.\n+     * Returns the next object in the buffer without removing it.\n      *\n-     *  @return  the next object in the buffer\n-     *  @throws BufferUnderflowException if the buffer is empty\n+     * @return  the next object in the buffer\n+     * @throws BufferUnderflowException if the buffer is empty\n      */\n     Object get();\n }\n--- a/src/java/org/apache/commons/collections/BufferUnderflowException.java\n+++ b/src/java/org/apache/commons/collections/BufferUnderflowException.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUnderflowException.java,v 1.4 2002/08/15 20:04:31 pjack Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/08/15 20:04:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUnderflowException.java,v 1.5 2002/10/13 12:57:38 scolebourne Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/10/13 12:57:38 $\n  *\n  * ====================================================================\n  *\n /**\n  * The BufferUnderflowException is used when the buffer is already empty\n  *\n+ * @author Avalon\n  * @author <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n  * @author <a href=\"mailto:jefft@apache.org\">Jeff Turner</a>\n- * @since Avalon 4.0\n- * @version $Id: BufferUnderflowException.java,v 1.4 2002/08/15 20:04:31 pjack Exp $\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @since 2.1\n+ * @version $Id: BufferUnderflowException.java,v 1.5 2002/10/13 12:57:38 scolebourne Exp $\n  */\n-public class BufferUnderflowException extends RuntimeException\n-{\n+public class BufferUnderflowException extends RuntimeException {\n     private final Throwable m_throwable;\n \n-    /** Construct a new BufferUnderflowException.\n-     * @param message The detail message for this exception.\n-     */\n-    public BufferUnderflowException( String message )\n-    {\n-        this( message, null );\n-    }\n-\n-    /** Construct a new BufferUnderflowException.\n-     * @param message The detail message for this exception.\n-     * @param throwable the root cause of the exception\n-     */\n-    public BufferUnderflowException( String message, Throwable exception )\n-    {\n-        super( message );\n-        m_throwable = exception;\n-    }\n-\n     /**\n-     *  Constructs a new <Code>BufferUnderflowException</Code>.\n+     * Constructs a new <code>BufferUnderflowException</code>.\n      */\n     public BufferUnderflowException() {\n         super();\n         m_throwable = null;\n     }\n \n+    /** \n+     * Construct a new <code>BufferUnderflowException</code>.\n+     * \n+     * @param message  the detail message for this exception\n+     */\n+    public BufferUnderflowException(String message) {\n+        this(message, null);\n+    }\n+\n+    /** \n+     * Construct a new <code>BufferUnderflowException</code>.\n+     * \n+     * @param message  the detail message for this exception\n+     * @param throwable  the root cause of the exception\n+     */\n+    public BufferUnderflowException(String message, Throwable exception) {\n+        super(message);\n+        m_throwable = exception;\n+    }\n+\n     /**\n-     * Retrieve root cause of the exception.\n+     * Gets the root cause of the exception.\n      *\n      * @return the root cause\n      */\n-    public final Throwable getCause()\n-    {\n+    public final Throwable getCause() {\n         return m_throwable;\n     }\n }\n--- a/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java,v 1.4 2002/10/12 22:15:18 scolebourne Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/10/12 22:15:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java,v 1.5 2002/10/13 12:59:04 scolebourne Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/10/13 12:59:04 $\n  *\n  * ====================================================================\n  *\n import java.util.AbstractCollection;\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n-\n-\n /**\n  * UnboundedFifoBuffer is a <strong>very</strong> efficient buffer implementation.\n  * According to performance testing, it exhibits a constant access time, but it\n  * also outperforms ArrayList when used for the same purpose.\n- * <P>\n- * The removal order of an <Code>UnboundedFifoBuffer</Code> is based on the insertion\n+ * <p>\n+ * The removal order of an <code>UnboundedFifoBuffer</code> is based on the insertion\n  * order; elements are removed in the same order in which they were added.\n- * The iteration order is the same as the removal order.<P>\n- *\n+ * The iteration order is the same as the removal order.\n+ * <p>\n  * The {@link #remove()} and {@link #get()} operations perform in constant time.\n  * The {@link #add(Object)} operation performs in amortized constant time.  All\n- * other operations perform in linear time or worse.<P>\n- *\n+ * other operations perform in linear time or worse.\n+ * <p>\n  * Note that this implementation is not synchronized.  The following can be\n- * used to provide synchronized access to your <COde>BoundedFifo</Code>:\n- *\n- * <Pre>\n- *   Buffer fifo = BufferUtils.synchronizedBuffer(new BoundedFifo());\n- * </Pre>\n- *\n+ * used to provide synchronized access to your <code>UnboundedFifo</code>:\n+ * <pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new UnboundedFifo());\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ *\n+ * @author Avalon\n  * @author  <a href=\"fede@apache.org\">Federico Barbieri</a>\n  * @author  <a href=\"bloritsch@apache.org\">Berin Loritsch</a>\n  * @author Paul Jack\n- * @version CVS $Revision: 1.4 $ $Date: 2002/10/12 22:15:18 $\n- * @since Avalon 4.0\n+ * @author Stephen Colebourne\n+ * @since 2.1\n+ * @version $Id: UnboundedFifoBuffer.java,v 1.5 2002/10/13 12:59:04 scolebourne Exp $\n  */\n-public final class UnboundedFifoBuffer extends AbstractCollection implements Buffer\n-{\n+public final class UnboundedFifoBuffer extends AbstractCollection implements Buffer {\n     protected Object[] m_buffer;\n     protected int m_head;\n     protected int m_tail;\n \n     /**\n-     * Initialize the UnboundedFifoBuffer with the specified number of elements.  The\n-     * integer must be a positive integer.\n-     */\n-    public UnboundedFifoBuffer( int size )\n-    {\n-        m_buffer = new Object[ size + 1 ];\n+     * Constructs an UnboundedFifoBuffer with the default number of elements.\n+     * It is exactly the same as performing the following:\n+     *\n+     * <pre>\n+     *   new UnboundedFifoBuffer(32);\n+     * </pre>\n+     */\n+    public UnboundedFifoBuffer() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructs an UnboundedFifoBuffer with the specified number of elements.\n+     * The integer must be a positive integer.\n+     * \n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    public UnboundedFifoBuffer(int size) {\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        m_buffer = new Object[size + 1];\n         m_head = 0;\n         m_tail = 0;\n     }\n \n     /**\n-     * Initialize the UnboundedFifoBuffer with the default number of elements.  It is\n-     * exactly the same as performing the following:\n-     *\n-     * <pre>\n-     *   new UnboundedFifoBuffer( 32 );\n-     * </pre>\n-     */\n-    public UnboundedFifoBuffer()\n-    {\n-        this( 32 );\n-    }\n-\n-    /**\n-     * Tests to see if the CircularBuffer is empty.\n-     */\n-    public final boolean isEmpty()\n-    {\n-        return ( size() == 0 );\n-    }\n-\n-    /**\n      * Returns the number of elements stored in the buffer.\n-     */\n-    public int size()\n-    {\n+     *\n+     * @return this buffer's size\n+     */\n+    public int size() {\n         int size = 0;\n \n-        if( m_tail < m_head )\n-        {\n+        if (m_tail < m_head) {\n             size = m_buffer.length - m_head + m_tail;\n-        }\n-        else\n-        {\n+        } else {\n             size = m_tail - m_head;\n         }\n \n     }\n \n     /**\n-     * Add an object into the buffer\n-     */\n-    public boolean add( final Object o )\n-    {\n-        if( null == o )\n-        {\n-            throw new NullPointerException( \"Attempted to add null object to buffer\" );\n-        }\n-\n-        if( size() + 1 >= m_buffer.length )\n-        {\n-            Object[] tmp = new Object[ ( ( m_buffer.length - 1 ) * 2 ) + 1 ];\n+     * Returns true if this buffer is empty; false otherwise.\n+     *\n+     * @return true if this buffer is empty\n+     */\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    /**\n+     * Adds the given element to this buffer.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     * @throws BufferOverflowException  if this buffer is full\n+     */\n+    public boolean add(final Object o) {\n+        if (null == o) {\n+            throw new NullPointerException(\"Attempted to add null object to buffer\");\n+        }\n+\n+        if (size() + 1 >= m_buffer.length) {\n+            Object[] tmp = new Object[((m_buffer.length - 1) * 2) + 1];\n \n             int j = 0;\n-            for( int i = m_head; i != m_tail; )\n-            {\n-                tmp[ j ] = m_buffer[ i ];\n-                m_buffer[ i ] = null;\n+            for (int i = m_head; i != m_tail;) {\n+                tmp[j] = m_buffer[i];\n+                m_buffer[i] = null;\n \n                 j++;\n                 i++;\n-                if( i == m_buffer.length )\n-                {\n+                if (i == m_buffer.length) {\n                     i = 0;\n                 }\n             }\n             m_tail = j;\n         }\n \n-        m_buffer[ m_tail ] = o;\n+        m_buffer[m_tail] = o;\n         m_tail++;\n-        if( m_tail >= m_buffer.length )\n-        {\n+        if (m_tail >= m_buffer.length) {\n             m_tail = 0;\n         }\n         return true;\n      * Returns the next object in the buffer.\n      *\n      * @return the next object in the buffer\n-     * @throws BufferUnderflowException if this buffer is empty\n-     */\n-    public Object get()\n-    {\n-        if( isEmpty() )\n-        {\n-            throw new BufferUnderflowException( \"The buffer is already empty\" );\n-        }\n-\n-        return m_buffer[ m_head ];\n-    }\n-\n+     * @throws BufferUnderflowException  if this buffer is empty\n+     */\n+    public Object get() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        return m_buffer[m_head];\n+    }\n \n     /**\n      * Removes the next object from the buffer\n      *\n      * @return the removed object\n-     * @throws BufferUnderflowException if this buffer is empty\n-     */\n-    public Object remove()\n-    {\n-        if( isEmpty() )\n-        {\n-            throw new BufferUnderflowException( \"The buffer is already empty\" );\n-        }\n-\n-        Object element = m_buffer[ m_head ];\n-\n-        if( null != element )\n-        {\n-            m_buffer[ m_head ] = null;\n+     * @throws BufferUnderflowException  if this buffer is empty\n+     */\n+    public Object remove() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        Object element = m_buffer[m_head];\n+\n+        if (null != element) {\n+            m_buffer[m_head] = null;\n \n             m_head++;\n-            if( m_head >= m_buffer.length )\n-            {\n+            if (m_head >= m_buffer.length) {\n                 m_head = 0;\n             }\n         }\n         return element;\n     }\n \n-\n+    /**\n+     * Increments the internal index.\n+     * \n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n     private int increment(int index) {\n-        index++; \n-        if (index >= m_buffer.length) index = 0;\n+        index++;\n+        if (index >= m_buffer.length)\n+            index = 0;\n         return index;\n     }\n \n-\n+    /**\n+     * Decrements the internal index.\n+     * \n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n     private int decrement(int index) {\n         index--;\n-        if (index < 0) index = m_buffer.length - 1;\n+        if (index < 0)\n+            index = m_buffer.length - 1;\n         return index;\n     }\n \n-\n-    /**\n-     *  Returns an iterator over this fifo's elements.\n-     *\n-     *  @return an iterator over this fifo's elements\n+    /**\n+     * Returns an iterator over this buffer's elements.\n+     *\n+     * @return an iterator over this buffer's elements\n      */\n     public Iterator iterator() {\n         return new Iterator() {\n \n             public boolean hasNext() {\n                 return index != m_tail;\n-                \n+\n             }\n \n             public Object next() {\n-                if (!hasNext()) throw new NoSuchElementException();\n+                if (!hasNext())\n+                    throw new NoSuchElementException();\n                 lastReturnedIndex = index;\n                 index = increment(index);\n                 return m_buffer[lastReturnedIndex];\n             }\n \n             public void remove() {\n-                if (lastReturnedIndex == -1) throw new IllegalStateException();\n+                if (lastReturnedIndex == -1)\n+                    throw new IllegalStateException();\n \n                 // First element can be removed quickly\n                 if (lastReturnedIndex == m_head) {\n \n         };\n     }\n-\n+    \n }\n ", "timestamp": 1034513944, "metainfo": ""}