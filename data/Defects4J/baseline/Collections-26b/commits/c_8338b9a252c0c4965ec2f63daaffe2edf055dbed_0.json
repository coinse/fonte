{"sha": "8338b9a252c0c4965ec2f63daaffe2edf055dbed", "log": "COLLECTIONS-427 patch applied.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/list/SetUniqueList.java\n+++ b/src/main/java/org/apache/commons/collections/list/SetUniqueList.java\n import org.apache.commons.collections.set.UnmodifiableSet;\n \n /**\n- * Decorates a <code>List</code> to ensure that no duplicates are present\n- * much like a <code>Set</code>.\n+ * Decorates a <code>List</code> to ensure that no duplicates are present much\n+ * like a <code>Set</code>.\n  * <p>\n- * The <code>List</code> interface makes certain assumptions/requirements.\n- * This implementation breaks these in certain ways, but this is merely the\n- * result of rejecting duplicates.\n- * Each violation is explained in the method, but it should not affect you.\n- * Bear in mind that Sets require immutable objects to function correctly.\n+ * The <code>List</code> interface makes certain assumptions/requirements. This\n+ * implementation breaks these in certain ways, but this is merely the result of\n+ * rejecting duplicates. Each violation is explained in the method, but it\n+ * should not affect you. Bear in mind that Sets require immutable objects to\n+ * function correctly.\n  * <p>\n  * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n  * class provides an alternative approach, by wrapping an existing Set and\n  * retaining insertion order in the iterator.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n- *\n+ * \n  * @since 3.0\n  * @version $Id$\n  */\n public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n \n-    /** Serialization version */\n-    private static final long serialVersionUID = 7196982186153478694L;\n-\n-    /**\n-     * Internal Set to maintain uniqueness.\n-     */\n-    protected final Set<E> set;\n-\n-    /**\n-     * Factory method to create a SetList using the supplied list to retain order.\n-     * <p>\n-     * If the list contains duplicates, these are removed (first indexed one kept).\n-     * A <code>HashSet</code> is used for the set behaviour.\n-     *\n-     * @param <E> the element type\n-     * @param list the list to decorate, must not be null\n-     * @return a new {@link SetUniqueList}\n-     * @throws IllegalArgumentException if list is null\n-     */\n-    public static <E> SetUniqueList<E> setUniqueList(List<E> list) {\n-        if (list == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");\n-        }\n-        if (list.isEmpty()) {\n-            return new SetUniqueList<E>(list, new HashSet<E>());\n-        }\n-        List<E> temp = new ArrayList<E>(list);\n-        list.clear();\n-        SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n-        sl.addAll(temp);\n-        return sl;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Constructor that wraps (not copies) the List and specifies the set to use.\n-     * <p>\n-     * The set and list must both be correctly initialised to the same elements.\n-     *\n-     * @param set  the set to decorate, must not be null\n-     * @param list  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if set or list is null\n-     */\n-    protected SetUniqueList(List<E> list, Set<E> set) {\n-        super(list);\n-        if (set == null) {\n-            throw new IllegalArgumentException(\"Set must not be null\");\n-        }\n-        this.set = set;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an unmodifiable view as a Set.\n-     *\n-     * @return an unmodifiable set view\n-     */\n-    public Set<E> asSet() {\n-        return UnmodifiableSet.unmodifiableSet(set);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Adds an element to the list if it is not already present.\n-     * <p>\n-     * <i>(Violation)</i>\n-     * The <code>List</code> interface requires that this method returns\n-     * <code>true</code> always. However this class may return <code>false</code>\n-     * because of the <code>Set</code> behaviour.\n-     *\n-     * @param object the object to add\n-     * @return true if object was added\n-     */\n-    @Override\n-    public boolean add(E object) {\n-        // gets initial size\n-        final int sizeBefore = size();\n-\n-        // adds element if unique\n-        add(size(), object);\n-\n-        // compares sizes to detect if collection changed\n-        return (sizeBefore != size());\n-    }\n-\n-    /**\n-     * Adds an element to a specific index in the list if it is not already present.\n-     * <p>\n-     * <i>(Violation)</i>\n-     * The <code>List</code> interface makes the assumption that the element is\n-     * always inserted. This may not happen with this implementation.\n-     *\n-     * @param index  the index to insert at\n-     * @param object  the object to add\n-     */\n-    @Override\n-    public void add(int index, E object) {\n-        // adds element if it is not contained already\n-        if (set.contains(object) == false) {\n-            super.add(index, object);\n-            set.add(object);\n-        }\n-    }\n-\n-    /**\n-     * Adds a collection of objects to the end of the list avoiding duplicates.\n-     * <p>\n-     * Only elements that are not already in this list will be added, and\n-     * duplicates from the specified collection will be ignored.\n-     * <p>\n-     * <i>(Violation)</i>\n-     * The <code>List</code> interface makes the assumption that the elements\n-     * are always inserted. This may not happen with this implementation.\n-     *\n-     * @param coll  the collection to add in iterator order\n-     * @return true if this collection changed\n-     */\n-    @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n-        return addAll(size(), coll);\n-    }\n-\n-    /**\n-     * Adds a collection of objects a specific index in the list avoiding \n-     * duplicates.\n-     * <p>\n-     * Only elements that are not already in this list will be added, and\n-     * duplicates from the specified collection will be ignored.\n-     * <p>\n-     * <i>(Violation)</i>\n-     * The <code>List</code> interface makes the assumption that the elements\n-     * are always inserted. This may not happen with this implementation.\n-     *\n-     * @param index  the index to insert at\n-     * @param coll  the collection to add in iterator order\n-     * @return true if this collection changed\n-     */\n-    @Override\n-    public boolean addAll(int index, Collection<? extends E> coll) {\n-        final List<E> temp = new ArrayList<E>();\n-        for (E e : coll) {\n-            if (set.add(e)) {\n-                temp.add(e);\n-            }\n-        }\n-        return super.addAll(index, temp);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Sets the value at the specified index avoiding duplicates.\n-     * <p>\n-     * The object is set into the specified index.\n-     * Afterwards, any previous duplicate is removed\n-     * If the object is not already in the list then a normal set occurs.\n-     * If it is present, then the old version is removed.\n-     *\n-     * @param index  the index to insert at\n-     * @param object  the object to set\n-     * @return the previous object\n-     */\n-    @Override\n-    public E set(int index, E object) {\n-        int pos = indexOf(object);\n-        E removed = super.set(index, object);\n-\n-        if (pos != -1 && pos != index) {\n-            // the object is already in the uniq list\n-            // (and it hasn't been swapped with itself)\n-            super.remove(pos);  // remove the duplicate by index\n-        }\n-\n-        set.add(object);      // add the new item to the unique set\n-        set.remove(removed);  // remove the item deleted by the set\n-\n-        return removed;  // return the item deleted by the set\n-    }\n-\n-    @Override\n-    public boolean remove(Object object) {\n-        boolean result = set.remove(object);\n-        if (result) {\n-            super.remove(object);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public E remove(int index) {\n-        E result = super.remove(index);\n-        set.remove(result);\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean removeAll(Collection<?> coll) {\n-        boolean result = false;\n-        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n-            result |= remove(it.next());\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public boolean retainAll(Collection<?> coll) {\n-        boolean result = super.retainAll(coll);\n-        set.retainAll(coll);\n-        return result;\n-    }\n-\n-    @Override\n-    public void clear() {\n-        super.clear();\n-        set.clear();\n-    }\n-\n-    @Override\n-    public boolean contains(Object object) {\n-        return set.contains(object);\n-    }\n-\n-    @Override\n-    public boolean containsAll(Collection<?> coll) {\n-        return set.containsAll(coll);\n-    }\n-\n-    @Override\n-    public Iterator<E> iterator() {\n-        return new SetListIterator<E>(super.iterator(), set);\n-    }\n-\n-    @Override\n-    public ListIterator<E> listIterator() {\n-        return new SetListListIterator<E>(super.listIterator(), set);\n-    }\n-\n-    @Override\n-    public ListIterator<E> listIterator(int index) {\n-        return new SetListListIterator<E>(super.listIterator(index), set);\n-    }\n-\n-    @Override\n-    public List<E> subList(int fromIndex, int toIndex) {\n-        List<E> superSubList = super.subList(fromIndex, toIndex);\n-        Set<E> subSet = createSetBasedOnList(set, superSubList);\n-        return new SetUniqueList<E>(superSubList, subSet);\n-    }\n-\n-    /**\n-     * Create a new {@link Set} with the same type as the provided {@code set}\n-     * and populate it with all elements of {@code list}.\n-     *\n-     * @param set the {@link Set} to be used as return type, must not be null\n-     * @param list the {@link List} to populate the {@link Set}\n-     * @return a new {@link Set} populated with all elements of the provided {@link List}\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    protected Set<E> createSetBasedOnList(Set<E> set, List<E> list) {\n-        Set<E> subSet;\n-        if (set.getClass().equals(HashSet.class)) {\n-            subSet = new HashSet<E>(list.size());\n-        } else {\n-            try {\n-                subSet = set.getClass().newInstance();\n-            } catch (InstantiationException ie) {\n-                subSet = new HashSet<E>();\n-            } catch (IllegalAccessException iae) {\n-                subSet = new HashSet<E>();\n-            }\n-        }\n-        subSet.addAll(list);\n-        return subSet;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Inner class iterator.\n-     */\n-    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n-\n-        protected final Set<E> set;\n-        protected E last = null;\n-\n-        protected SetListIterator(Iterator<E> it, Set<E> set) {\n-            super(it);\n-            this.set = set;\n-        }\n-\n-        @Override\n-        public E next() {\n-            last = super.next();\n-            return last;\n-        }\n-\n-        @Override\n-        public void remove() {\n-            super.remove();\n-            set.remove(last);\n-            last = null;\n-        }\n-    }\n-\n-    /**\n-     * Inner class iterator.\n-     */\n-    static class SetListListIterator<E> extends AbstractListIteratorDecorator<E> {\n-\n-        protected final Set<E> set;\n-        protected E last = null;\n-\n-        protected SetListListIterator(ListIterator<E> it, Set<E> set) {\n-            super(it);\n-            this.set = set;\n-        }\n-\n-        @Override\n-        public E next() {\n-            last = super.next();\n-            return last;\n-        }\n-\n-        @Override\n-        public E previous() {\n-            last = super.previous();\n-            return last;\n-        }\n-\n-        @Override\n-        public void remove() {\n-            super.remove();\n-            set.remove(last);\n-            last = null;\n-        }\n-\n-        @Override\n-        public void add(E object) {\n-            if (set.contains(object) == false) {\n-                super.add(object);\n-                set.add(object);\n-            }\n-        }\n-\n-        @Override\n-        public void set(E object) {\n-            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n-        }\n-    }\n+\t/** Serialization version */\n+\tprivate static final long serialVersionUID = 7196982186153478694L;\n+\n+\t/**\n+\t * Internal Set to maintain uniqueness.\n+\t */\n+\tprotected final Set<E> set;\n+\n+\t/**\n+\t * Factory method to create a SetList using the supplied list to retain\n+\t * order.\n+\t * <p>\n+\t * If the list contains duplicates, these are removed (first indexed one\n+\t * kept). A <code>HashSet</code> is used for the set behaviour.\n+\t * \n+\t * @param <E>\n+\t *            the element type\n+\t * @param list\n+\t *            the list to decorate, must not be null\n+\t * @return a new {@link SetUniqueList}\n+\t * @throws IllegalArgumentException\n+\t *             if list is null\n+\t */\n+\tpublic static <E> SetUniqueList<E> setUniqueList(List<E> list) {\n+\t\tif (list == null) {\n+\t\t\tthrow new IllegalArgumentException(\"List must not be null\");\n+\t\t}\n+\t\tif (list.isEmpty()) {\n+\t\t\treturn new SetUniqueList<E>(list, new HashSet<E>());\n+\t\t}\n+\t\tList<E> temp = new ArrayList<E>(list);\n+\t\tlist.clear();\n+\t\tSetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n+\t\tsl.addAll(temp);\n+\t\treturn sl;\n+\t}\n+\n+\t// -----------------------------------------------------------------------\n+\t/**\n+\t * Constructor that wraps (not copies) the List and specifies the set to\n+\t * use.\n+\t * <p>\n+\t * The set and list must both be correctly initialised to the same elements.\n+\t * \n+\t * @param set\n+\t *            the set to decorate, must not be null\n+\t * @param list\n+\t *            the list to decorate, must not be null\n+\t * @throws IllegalArgumentException\n+\t *             if set or list is null\n+\t */\n+\tprotected SetUniqueList(List<E> list, Set<E> set) {\n+\t\tsuper(list);\n+\t\tif (set == null) {\n+\t\t\tthrow new IllegalArgumentException(\"Set must not be null\");\n+\t\t}\n+\t\tthis.set = set;\n+\t}\n+\n+\t// -----------------------------------------------------------------------\n+\t/**\n+\t * Gets an unmodifiable view as a Set.\n+\t * \n+\t * @return an unmodifiable set view\n+\t */\n+\tpublic Set<E> asSet() {\n+\t\treturn UnmodifiableSet.unmodifiableSet(set);\n+\t}\n+\n+\t// -----------------------------------------------------------------------\n+\t/**\n+\t * Adds an element to the list if it is not already present.\n+\t * <p>\n+\t * <i>(Violation)</i> The <code>List</code> interface requires that this\n+\t * method returns <code>true</code> always. However this class may return\n+\t * <code>false</code> because of the <code>Set</code> behaviour.\n+\t * \n+\t * @param object\n+\t *            the object to add\n+\t * @return true if object was added\n+\t */\n+\t@Override\n+\tpublic boolean add(E object) {\n+\t\t// gets initial size\n+\t\tfinal int sizeBefore = size();\n+\n+\t\t// adds element if unique\n+\t\tadd(size(), object);\n+\n+\t\t// compares sizes to detect if collection changed\n+\t\treturn (sizeBefore != size());\n+\t}\n+\n+\t/**\n+\t * Adds an element to a specific index in the list if it is not already\n+\t * present.\n+\t * <p>\n+\t * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+\t * that the element is always inserted. This may not happen with this\n+\t * implementation.\n+\t * \n+\t * @param index\n+\t *            the index to insert at\n+\t * @param object\n+\t *            the object to add\n+\t */\n+\t@Override\n+\tpublic void add(int index, E object) {\n+\t\t// adds element if it is not contained already\n+\t\tif (set.contains(object) == false) {\n+\t\t\tsuper.add(index, object);\n+\t\t\tset.add(object);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Adds a collection of objects to the end of the list avoiding duplicates.\n+\t * <p>\n+\t * Only elements that are not already in this list will be added, and\n+\t * duplicates from the specified collection will be ignored.\n+\t * <p>\n+\t * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+\t * that the elements are always inserted. This may not happen with this\n+\t * implementation.\n+\t * \n+\t * @param coll\n+\t *            the collection to add in iterator order\n+\t * @return true if this collection changed\n+\t */\n+\t@Override\n+\tpublic boolean addAll(Collection<? extends E> coll) {\n+\t\treturn addAll(size(), coll);\n+\t}\n+\n+\t/**\n+\t * Adds a collection of objects a specific index in the list avoiding\n+\t * duplicates.\n+\t * <p>\n+\t * Only elements that are not already in this list will be added, and\n+\t * duplicates from the specified collection will be ignored.\n+\t * <p>\n+\t * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+\t * that the elements are always inserted. This may not happen with this\n+\t * implementation.\n+\t * \n+\t * @param index\n+\t *            the index to insert at\n+\t * @param coll\n+\t *            the collection to add in iterator order\n+\t * @return true if this collection changed\n+\t */\n+\t@Override\n+\tpublic boolean addAll(int index, Collection<? extends E> coll) {\n+\t\tfinal List<E> temp = new ArrayList<E>();\n+\t\tfor (E e : coll) {\n+\t\t\tif (set.add(e)) {\n+\t\t\t\ttemp.add(e);\n+\t\t\t}\n+\t\t}\n+\t\treturn super.addAll(index, temp);\n+\t}\n+\n+\t// -----------------------------------------------------------------------\n+\t/**\n+\t * Sets the value at the specified index avoiding duplicates.\n+\t * <p>\n+\t * The object is set into the specified index. Afterwards, any previous\n+\t * duplicate is removed If the object is not already in the list then a\n+\t * normal set occurs. If it is present, then the old version is removed.\n+\t * \n+\t * @param index\n+\t *            the index to insert at\n+\t * @param object\n+\t *            the object to set\n+\t * @return the previous object\n+\t */\n+\t@Override\n+\tpublic E set(int index, E object) {\n+\t\tint pos = indexOf(object);\n+\t\tE removed = super.set(index, object);\n+\n+\t\tif (pos != -1 && pos != index) {\n+\t\t\t// the object is already in the uniq list\n+\t\t\t// (and it hasn't been swapped with itself)\n+\t\t\tsuper.remove(pos); // remove the duplicate by index\n+\t\t}\n+\n+\t\tset.add(object); // add the new item to the unique set\n+\t\tset.remove(removed); // remove the item deleted by the set\n+\n+\t\treturn removed; // return the item deleted by the set\n+\t}\n+\n+\t@Override\n+\tpublic boolean remove(Object object) {\n+\t\tboolean result = set.remove(object);\n+\t\tif (result) {\n+\t\t\tsuper.remove(object);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic E remove(int index) {\n+\t\tE result = super.remove(index);\n+\t\tset.remove(result);\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean removeAll(Collection<?> coll) {\n+\t\tboolean result = false;\n+\t\tfor (Iterator<?> it = coll.iterator(); it.hasNext();) {\n+\t\t\tresult |= remove(it.next());\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean retainAll(Collection<?> coll) {\n+\t\tSet<Object> setRetainAll = new HashSet<Object>();\n+\t\tfor (Iterator<?> it = coll.iterator(); it.hasNext();) {\n+\t\t\tObject next = it.next();\n+\t\t\tif (set.contains(next)) {\n+\t\t\t\tsetRetainAll.add(next);\n+\t\t\t}\n+\t\t}\n+\t\tif (setRetainAll.size() == set.size()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (setRetainAll.size() == 0) {\n+\t\t\tclear();\n+\t\t} else {\n+\t\t\tfor (Iterator<E> it = iterator(); it.hasNext();) {\n+\t\t\t\tif (!setRetainAll.contains(it.next())) {\n+\t\t\t\t\tit.remove();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tsuper.clear();\n+\t\tset.clear();\n+\t}\n+\n+\t@Override\n+\tpublic boolean contains(Object object) {\n+\t\treturn set.contains(object);\n+\t}\n+\n+\t@Override\n+\tpublic boolean containsAll(Collection<?> coll) {\n+\t\treturn set.containsAll(coll);\n+\t}\n+\n+\t@Override\n+\tpublic Iterator<E> iterator() {\n+\t\treturn new SetListIterator<E>(super.iterator(), set);\n+\t}\n+\n+\t@Override\n+\tpublic ListIterator<E> listIterator() {\n+\t\treturn new SetListListIterator<E>(super.listIterator(), set);\n+\t}\n+\n+\t@Override\n+\tpublic ListIterator<E> listIterator(int index) {\n+\t\treturn new SetListListIterator<E>(super.listIterator(index), set);\n+\t}\n+\n+\t@Override\n+\tpublic List<E> subList(int fromIndex, int toIndex) {\n+\t\tList<E> superSubList = super.subList(fromIndex, toIndex);\n+\t\tSet<E> subSet = createSetBasedOnList(set, superSubList);\n+\t\treturn new SetUniqueList<E>(superSubList, subSet);\n+\t}\n+\n+\t/**\n+\t * Create a new {@link Set} with the same type as the provided {@code set}\n+\t * and populate it with all elements of {@code list}.\n+\t * \n+\t * @param set\n+\t *            the {@link Set} to be used as return type, must not be null\n+\t * @param list\n+\t *            the {@link List} to populate the {@link Set}\n+\t * @return a new {@link Set} populated with all elements of the provided\n+\t *         {@link List}\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected Set<E> createSetBasedOnList(Set<E> set, List<E> list) {\n+\t\tSet<E> subSet;\n+\t\tif (set.getClass().equals(HashSet.class)) {\n+\t\t\tsubSet = new HashSet<E>(list.size());\n+\t\t} else {\n+\t\t\ttry {\n+\t\t\t\tsubSet = set.getClass().newInstance();\n+\t\t\t} catch (InstantiationException ie) {\n+\t\t\t\tsubSet = new HashSet<E>();\n+\t\t\t} catch (IllegalAccessException iae) {\n+\t\t\t\tsubSet = new HashSet<E>();\n+\t\t\t}\n+\t\t}\n+\t\tsubSet.addAll(list);\n+\t\treturn subSet;\n+\t}\n+\n+\t// -----------------------------------------------------------------------\n+\t/**\n+\t * Inner class iterator.\n+\t */\n+\tstatic class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n+\n+\t\tprotected final Set<E> set;\n+\t\tprotected E last = null;\n+\n+\t\tprotected SetListIterator(Iterator<E> it, Set<E> set) {\n+\t\t\tsuper(it);\n+\t\t\tthis.set = set;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic E next() {\n+\t\t\tlast = super.next();\n+\t\t\treturn last;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void remove() {\n+\t\t\tsuper.remove();\n+\t\t\tset.remove(last);\n+\t\t\tlast = null;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Inner class iterator.\n+\t */\n+\tstatic class SetListListIterator<E> extends\n+\t\t\tAbstractListIteratorDecorator<E> {\n+\n+\t\tprotected final Set<E> set;\n+\t\tprotected E last = null;\n+\n+\t\tprotected SetListListIterator(ListIterator<E> it, Set<E> set) {\n+\t\t\tsuper(it);\n+\t\t\tthis.set = set;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic E next() {\n+\t\t\tlast = super.next();\n+\t\t\treturn last;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic E previous() {\n+\t\t\tlast = super.previous();\n+\t\t\treturn last;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void remove() {\n+\t\t\tsuper.remove();\n+\t\t\tset.remove(last);\n+\t\t\tlast = null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void add(E object) {\n+\t\t\tif (set.contains(object) == false) {\n+\t\t\t\tsuper.add(object);\n+\t\t\t\tset.add(object);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void set(E object) {\n+\t\t\tthrow new UnsupportedOperationException(\n+\t\t\t\t\t\"ListIterator does not support set\");\n+\t\t}\n+\t}\n \n }\n--- a/src/test/java/org/apache/commons/collections/list/SetUniqueListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/SetUniqueListTest.java\n         assertFalse(subUniqueList.contains(\"World\")); // fails\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testRetainAll() {\n+    \tList<E> list = new ArrayList<E>(10);\n+    \tSetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n+    \tfor (int i = 0; i < 10; ++i) {\n+    \t\tuniqueList.add((E)Integer.valueOf(i));\n+    \t}\n+    \t\n+    \tCollection<E> retained = new ArrayList<E>(5);\n+    \tfor (int i = 0; i < 5; ++i) {\n+    \t\tretained.add((E)Integer.valueOf(i * 2));\n+    \t}\n+    \t\n+    \tassertTrue(uniqueList.retainAll(retained));\n+    \tassertEquals(5, uniqueList.size());\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(0)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(2)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(4)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(6)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(8)));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testRetainAllWithInitialList() {\n+    \t// initialized with empty list\n+    \tList<E> list = new ArrayList<E>(10);\n+    \tfor (int i = 0; i < 5; ++i) {\n+    \t\tlist.add((E)Integer.valueOf(i));\n+    \t}\n+    \tSetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n+    \tfor (int i = 5; i < 10; ++i) {\n+    \t\tuniqueList.add((E)Integer.valueOf(i));\n+    \t}\n+    \t\n+    \tCollection<E> retained = new ArrayList<E>(5);\n+    \tfor (int i = 0; i < 5; ++i) {\n+    \t\tretained.add((E)Integer.valueOf(i * 2));\n+    \t}\n+    \t\n+    \tassertTrue(uniqueList.retainAll(retained));\n+    \tassertEquals(5, uniqueList.size());\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(0)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(2)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(4)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(6)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(8)));\n+    }\n+    \n+    /*\n+     * test case for https://issues.apache.org/jira/browse/COLLECTIONS-427\n+     */\n+    public void testRetainAllCollections427() {\n+        int size = 50000;\n+        ArrayList<Integer> list = new ArrayList<Integer>();\n+        for (int i = 0; i < size; i++) {\n+            list.add(i);\n+        }\n+        SetUniqueList<Integer> uniqueList = SetUniqueList.setUniqueList(list);\n+        ArrayList<Integer> toRetain = new ArrayList<Integer>();\n+        for (int i = size; i < 2*size; i++) {\n+            toRetain.add(i);\n+        }\n+\n+        long start = System.currentTimeMillis();\n+        uniqueList.retainAll(toRetain);\n+        long stop = System.currentTimeMillis();\n+        \n+        // make sure retainAll completes under 5 seconds\n+        // TODO if test is migrated to JUnit 4, add a Timeout rule.\n+        // http://kentbeck.github.com/junit/javadoc/latest/org/junit/rules/Timeout.html\n+        assertTrue((stop - start) < 5000);\n+    }\n+    \n     @SuppressWarnings(\"serial\")\n     class SetUniqueList307 extends SetUniqueList<E> {\n         public SetUniqueList307(List<E> list, Set<E> set) {", "timestamp": 1346007711, "metainfo": ""}