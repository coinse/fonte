{"sha": "4a025d3f8e31bc3e944399990b3a4baedb90e630", "log": "Refactor trie package: reduce interface by extending IterableSortedMap and only adding prefixMap method, remove all key analyzers but the StringKeyAnalyzer, refactor PatriciaTrie class by moving all remaining methods to AbstractPatriciaTrie and fixing the key type to String, integrating the test classes into the framework.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/Trie.java\n+++ b/src/main/java/org/apache/commons/collections4/Trie.java\n  */\n package org.apache.commons.collections4;\n \n-import java.util.Map;\n import java.util.SortedMap;\n-import java.util.Map.Entry;\n \n /**\n  * Defines the interface for a prefix tree, an ordered tree data structure. For\n  * @since 4.0\n  * @version $Id$\n  */\n-// TODO: should extend IterableSortedMap\n-// TODO: move bitwise getPrefixedBy methods to AbstractBitwiseTrie\n-// TODO: consider a BitwiseTrie interface which extends Trie and supports the bitwise selection methods\n-// TODO: consider a better name for getPrefixedBy: maybe prefixMap(...)\n-public interface Trie<K, V> extends SortedMap<K, V> {\n-\n-    /**\n-     * Traverses the {@link Trie} in lexicographical order.\n-     * {@link Cursor#select(java.util.Map.Entry)} will be called on each entry.\n-     * <p>\n-     * The traversal will stop when the cursor returns {@link Cursor.Decision#EXIT},\n-     * {@link Cursor.Decision#CONTINUE} is used to continue traversing and\n-     * {@link Cursor.Decision#REMOVE} is used to remove the element that was selected\n-     * and continue traversing.\n-     * <p>\n-     * {@link Cursor.Decision#REMOVE_AND_EXIT} is used to remove the current element\n-     * and stop traversing.\n-     *\n-     * @param cursor  the cursor used while traversing the {@link Trie}\n-     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null\n-     * if it continued till the end\n-     */\n-    public Map.Entry<K,V> traverse(Cursor<? super K, ? super V> cursor);\n+public interface Trie<K, V> extends IterableSortedMap<K, V> {\n \n     /**\n      * Returns a view of this {@link Trie} of all elements that are prefixed\n      * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n      *   key is prefixed by the search key\n      */\n-    public SortedMap<K, V> getPrefixedBy(K key);\n+    public SortedMap<K, V> prefixMap(K key);\n \n-    /**\n-     * Returns a view of this {@link Trie} of all elements that are prefixed\n-     * by the length of the key.\n-     * <p>\n-     * {@link Trie}s with fixed size keys will not support this operation\n-     * (because all keys are the same length).\n-     * <p>\n-     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu',\n-     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for 'Andrey'\n-     * and a length of 4 would return 'Andreas', 'Andrea', and 'Andres'.\n-     *\n-     * @param key  the key used in the search\n-     * @param length  the length of the prefix\n-     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n-     *   key is prefixed by the search key\n-     */\n-    public SortedMap<K, V> getPrefixedBy(K key, int length);\n-\n-    /**\n-     * Returns a view of this {@link Trie} of all elements that are prefixed\n-     * by the key, starting at the given offset and for the given length.\n-     * <p>\n-     * {@link Trie}s with fixed size keys will not support this operation\n-     * (because all keys are the same length).\n-     * <p>\n-     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu',\n-     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for\n-     * 'Hello Andrey Smith', an offset of 6 and a length of 4 would return\n-     * 'Andreas', 'Andrea', and 'Andres'.\n-     *\n-     * @param key  the key used in the search\n-     * @param offset  the prefix start\n-     * @param length  the length of the prefix\n-     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n-     *   key is prefixed by the search key\n-     */\n-    public SortedMap<K, V> getPrefixedBy(K key, int offset, int length);\n-\n-    /**\n-     * Returns a view of this {@link Trie} of all elements that are prefixed\n-     * by the number of bits in the given Key.\n-     * <p>\n-     * In {@link Trie}s with fixed size keys like IP addresses this method\n-     * can be used to lookup partial keys. That is you can lookup all addresses\n-     * that begin with '192.168' by providing the key '192.168.X.X' and a\n-     * length of 16.\n-     *\n-     * @param key  the key to use in the search\n-     * @param lengthInBits  the number of significant key bits\n-     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n-     *   key is prefixed by the search key\n-     */\n-    public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits);\n-\n-    /**\n-     * Returns a view of this {@link Trie} of all elements that are prefixed\n-     * by the number of bits in the given Key.\n-     *\n-     * @param key  the key to use in the search\n-     * @param offsetInBits  the prefix offset\n-     * @param lengthInBits  the number of significant prefix bits\n-     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n-     *   key is prefixed by the search key\n-     */\n-    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits);\n-\n-    /**\n-     * A {@link Trie.Cursor} can be used to traverse a {@link Trie}, visit each node\n-     * step by step and make {@link Decision}s on each step how to continue with\n-     * traversing the {@link Trie}.\n-     */\n-    public interface Cursor<K, V> {\n-\n-        /**\n-         * The {@link Decision} tells the {@link Trie.Cursor} what to do on each step\n-         * while traversing the {@link Trie}.\n-         *\n-         * NOTE: Not all operations that work with a {@link Trie.Cursor} support all\n-         * {@link Decision} types\n-         */\n-        public static enum Decision {\n-\n-            /**\n-             * Exit the traverse operation\n-             */\n-            EXIT,\n-\n-            /**\n-             * Continue with the traverse operation\n-             */\n-            CONTINUE,\n-\n-            /**\n-             * Remove the previously returned element\n-             * from the {@link Trie} and continue\n-             */\n-            REMOVE,\n-\n-            /**\n-             * Remove the previously returned element\n-             * from the {@link Trie} and exit from the\n-             * traverse operation\n-             */\n-            REMOVE_AND_EXIT;\n-        }\n-\n-        /**\n-         * Called for each {@link Entry} in the {@link Trie}. Return\n-         * {@link Decision#EXIT} to finish the {@link Trie} operation,\n-         * {@link Decision#CONTINUE} to go to the next {@link Entry},\n-         * {@link Decision#REMOVE} to remove the {@link Entry} and\n-         * continue iterating or {@link Decision#REMOVE_AND_EXIT} to\n-         * remove the {@link Entry} and stop iterating.\n-         * <p>\n-         * Note: Not all operations support {@link Decision#REMOVE}.\n-         *\n-         * @param entry  the current entry\n-         * @return the {@link Decision} based on the current entry\n-         */\n-        public Decision select(Map.Entry<? extends K, ? extends V> entry);\n-    }\n }", "timestamp": 1371157283, "metainfo": ""}