{"sha": "30681261f39988bb5fa28ded714bf52c21a60731", "log": "- adding some utilities from struts into the collections packages   along with some (admittedly weak for now) tests. PR: Obtained from: Submitted by: Reviewed by:   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/FastArrayList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastArrayList.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/16 22:42:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+\n+package org.apache.commons.collections;\n+\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+\n+/**\n+ * <p>A customized implementation of <code>java.util.ArrayList</code> designed\n+ * to operate in a multithreaded environment where the large majority of\n+ * method calls are read-only, instead of structural changes.  When operating\n+ * in \"fast\" mode, read calls are non-synchronized and write calls perform the\n+ * following steps:</p>\n+ * <ul>\n+ * <li>Clone the existing collection\n+ * <li>Perform the modification on the clone\n+ * <li>Replace the existing collection with the (modified) clone\n+ * </ul>\n+ * <p>When first created, objects of this class default to \"slow\" mode, where\n+ * all accesses of any type are synchronized but no cloning takes place.  This\n+ * is appropriate for initially populating the collection, followed by a switch\n+ * to \"fast\" mode (by calling <code>setFast(true)</code>) after initialization\n+ * is complete.</p>\n+ *\n+ * <p><strong>NOTE</strong>: If you are creating and accessing an\n+ * <code>ArrayList</code> only within a single thread, you should use\n+ * <code>java.util.ArrayList</code> directly (with no synchronization), for\n+ * maximum performance.</p>\n+ *\n+ * <p><strong>NOTE</strong>: The following methods are <strong>NOT</strong>\n+ * overridden:  clone(), equals(Object), hashCode().</p>\n+ *\n+ * @author Craig R. McClanahan\n+ * @version $Revision: 1.1 $ $Date: 2001/04/16 22:42:04 $\n+ */\n+\n+public class FastArrayList implements List, Cloneable, Serializable {\n+\n+\n+    // ----------------------------------------------------------- Constructors\n+\n+\n+    /**\n+     * Construct a an empty list.\n+     */\n+    public FastArrayList() {\n+\n+        super();\n+        this.list = new ArrayList();\n+\n+    }\n+\n+\n+    /**\n+     * Construct an empty list with the specified capacity.\n+     *\n+     * @param capacity The initial capacity of the empty list\n+     */\n+    public FastArrayList(int capacity) {\n+\n+        super();\n+        this.list = new ArrayList(capacity);\n+\n+    }\n+\n+\n+    /**\n+     * Construct a list containing the elements of the specified collection,\n+     * in the order they are returned by the collection's iterator.\n+     *\n+     * @param collection The collection whose elements initialize the contents\n+     *  of this list\n+     */\n+    public FastArrayList(Collection collection) {\n+\n+        super();\n+        this.list = new ArrayList(collection);\n+\n+    }\n+\n+\n+    // ----------------------------------------------------- Instance Variables\n+\n+\n+    /**\n+     * The underlying list we are managing.\n+     */\n+    protected ArrayList list = null;\n+\n+\n+    // ------------------------------------------------------------- Properties\n+\n+\n+    /**\n+     * Are we operating in \"fast\" mode?\n+     */\n+    protected boolean fast = false;\n+\n+    public boolean getFast() {\n+        return (this.fast);\n+    }\n+\n+    public void setFast(boolean fast) {\n+        this.fast = fast;\n+    }\n+\n+\n+    // --------------------------------------------------------- Public Methods\n+\n+\n+    /**\n+     * Appends the specified element to the end of this list.\n+     *\n+     * @param element The element to be appended\n+     */\n+    public boolean add(Object element) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                boolean result = temp.add(element);\n+                list = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (list) {\n+                return (list.add(element));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Insert the specified element at the specified position in this list,\n+     * and shift all remaining elements up one position.\n+     *\n+     * @param index Index at which to insert this element\n+     * @param element The element to be inserted\n+     *\n+     * @exception IndexOutOfBoundsException if the index is out of range\n+     */\n+    public void add(int index, Object element) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                temp.add(index, element);\n+                list = temp;\n+            }\n+        } else {\n+            synchronized (list) {\n+                list.add(index, element);\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Append all of the elements in the specified Collection to the end\n+     * of this list, in the order that they are returned by the specified\n+     * Collection's Iterator.\n+     *\n+     * @param collection The collection to be appended\n+     */\n+    public boolean addAll(Collection collection) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                boolean result = temp.addAll(collection);\n+                list = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (list) {\n+                return (list.addAll(collection));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Insert all of the elements in the specified Collection at the specified\n+     * position in this list, and shift any previous elements upwards as\n+     * needed.\n+     *\n+     * @param index Index at which insertion takes place\n+     * @param collection The collection to be added\n+     *\n+     * @exception IndexOutOfBoundsException if the index is out of range\n+     */\n+    public boolean addAll(int index, Collection collection) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                boolean result = temp.addAll(index, collection);\n+                list = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (list) {\n+                return (list.addAll(index, collection));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Remove all of the elements from this list.  The list will be empty\n+     * after this call returns.\n+     *\n+     * @exception UnsupportedOperationException if <code>clear()</code>\n+     *  is not supported by this list\n+     */\n+    public void clear() {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                temp.clear();\n+                list = temp;\n+            }\n+        } else {\n+            synchronized (list) {\n+                list.clear();\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return <code>true</code> if this list contains the specified element.\n+     *\n+     * @param element The element to test for\n+     */\n+    public boolean contains(Object element) {\n+\n+        if (fast) {\n+            return (list.contains(element));\n+        } else {\n+            synchronized (list) {\n+                return (list.contains(element));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return <code>true</code> if this list contains all of the elements\n+     * in the specified Collection.\n+     *\n+     * @param collection Collection whose elements are to be checked\n+     */\n+    public boolean containsAll(Collection collection) {\n+\n+        if (fast) {\n+            return (list.containsAll(collection));\n+        } else {\n+            synchronized (list) {\n+                return (list.containsAll(collection));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Increase the capacity of this <code>ArrayList</code> instance, if\n+     * necessary, to ensure that it can hold at least the number of elements\n+     * specified by the minimum capacity argument.\n+     *\n+     * @param capacity The new minimum capacity\n+     */\n+    public void ensureCapacity(int capacity) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                temp.ensureCapacity(capacity);\n+                list = temp;\n+            }\n+        } else {\n+            synchronized (list) {\n+                list.ensureCapacity(capacity);\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the element at the specified position in the list.\n+     *\n+     * @param index The index of the element to return\n+     *\n+     * @exception IndexOutOfBoundsException if the index is out of range\n+     */\n+    public Object get(int index) {\n+\n+        if (fast) {\n+            return (list.get(index));\n+        } else {\n+            synchronized (list) {\n+                return (list.get(index));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Search for the first occurrence of the given argument, testing\n+     * for equality using the <code>equals()</code> method, and return\n+     * the corresponding index, or -1 if the object is not found.\n+     *\n+     * @param element The element to search for\n+     */\n+    public int indexOf(Object element) {\n+\n+        if (fast) {\n+            return (list.indexOf(element));\n+        } else {\n+            synchronized (list) {\n+                return (list.indexOf(element));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Test if this list has no elements.\n+     */\n+    public boolean isEmpty() {\n+\n+        if (fast) {\n+            return (list.isEmpty());\n+        } else {\n+            synchronized (list) {\n+                return (list.isEmpty());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return an iterator over the elements in this list in proper sequence.\n+     * <br><br>\n+     * <strong>IMPLEMENTATION NOTE</strong> - If the list is operating in fast\n+     * mode, an Iterator is returned, and a structural modification to the\n+     * list is made, then the Iterator will continue over the previous contents\n+     * of the list (at the time that the Iterator was created), rather than\n+     * failing due to concurrent modifications.\n+     */\n+    public Iterator iterator() {\n+\n+        if (fast) {\n+            return (list.iterator());\n+        } else {\n+            synchronized (list) {\n+                return (list.iterator());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Search for the last occurrence of the given argument, testing\n+     * for equality using the <code>equals()</code> method, and return\n+     * the corresponding index, or -1 if the object is not found.\n+     *\n+     * @param element The element to search for\n+     */\n+    public int lastIndexOf(Object element) {\n+\n+        if (fast) {\n+            return (list.lastIndexOf(element));\n+        } else {\n+            synchronized (list) {\n+                return (list.lastIndexOf(element));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return an iterator of the elements of this list, in proper sequence.\n+     * See the implementation note on <code>iterator()</code>.\n+     */\n+    public ListIterator listIterator() {\n+\n+        if (fast) {\n+            return (list.listIterator());\n+        } else {\n+            synchronized (list) {\n+                return (list.listIterator());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return an iterator of the elements of this list, in proper sequence,\n+     * starting at the specified position.\n+     * See the implementation note on <code>iterator()</code>.\n+     *\n+     * @param index The starting position of the iterator to return\n+     *\n+     * @exception IndexOutOfBoundsException if the index is out of range\n+     */\n+    public ListIterator listIterator(int index) {\n+\n+        if (fast) {\n+            return (list.listIterator(index));\n+        } else {\n+            synchronized (list) {\n+                return (list.listIterator(index));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Remove the element at the specified position in the list, and shift\n+     * any subsequent elements down one position.\n+     *\n+     * @param index Index of the element to be removed\n+     *\n+     * @exception IndexOutOfBoundsException if the index is out of range\n+     */\n+    public Object remove(int index) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                Object result = temp.remove(index);\n+                list = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (list) {\n+                return (list.remove(index));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Remove the first occurrence of the specified element from the list,\n+     * and shift any subsequent elements down one position.\n+     *\n+     * @param element Element to be removed\n+     */\n+    public boolean remove(Object element) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                boolean result = temp.remove(element);\n+                list = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (list) {\n+                return (list.remove(element));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Remove from this collection all of its elements that are contained\n+     * in the specified collection.\n+     *\n+     * @param collection Collection containing elements to be removed\n+     *\n+     * @exception UnsupportedOperationException if this optional operation\n+     *  is not supported by this list\n+     */\n+    public boolean removeAll(Collection collection) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                boolean result = temp.removeAll(collection);\n+                list = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (list) {\n+                return (list.removeAll(collection));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Remove from this collection all of its elements except those that are\n+     * contained in the specified collection.\n+     *\n+     * @param collection Collection containing elements to be retained\n+     *\n+     * @exception UnsupportedOperationException if this optional operation\n+     *  is not supported by this list\n+     */\n+    public boolean retainAll(Collection collection) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                boolean result = temp.retainAll(collection);\n+                list = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (list) {\n+                return (list.retainAll(collection));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Replace the element at the specified position in this list with\n+     * the specified element.  Returns the previous object at that position.\n+     * <br><br>\n+     * <strong>IMPLEMENTATION NOTE</strong> - This operation is specifically\n+     * documented to not be a structural change, so it is safe to be performed\n+     * without cloning.\n+     *\n+     * @param index Index of the element to replace\n+     * @param element The new element to be stored\n+     *\n+     * @exception IndexOutOfBoundsException if the index is out of range\n+     */\n+    public Object set(int index, Object element) {\n+\n+        if (fast) {\n+            return (list.set(index, element));\n+        } else {\n+            synchronized (list) {\n+                return (list.set(index, element));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the number of elements in this list.\n+     */\n+    public int size() {\n+\n+        if (fast) {\n+            return (list.size());\n+        } else {\n+            synchronized (list) {\n+                return (list.size());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a view of the portion of this list between fromIndex\n+     * (inclusive) and toIndex (exclusive).  The returned list is backed\n+     * by this list, so non-structural changes in the returned list are\n+     * reflected in this list.  The returned list supports\n+     * all of the optional list operations supported by this list.\n+     *\n+     * @param fromIndex The starting index of the sublist view\n+     * @param toIndex The index after the end of the sublist view\n+     *\n+     * @exception IndexOutOfBoundsException if an index is out of range\n+     */\n+    public List subList(int fromIndex, int toIndex) {\n+\n+        if (fast) {\n+            return (list.subList(fromIndex, toIndex));\n+        } else {\n+            synchronized (list) {\n+                return (list.subList(fromIndex, toIndex));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return an array containing all of the elements in this list in the\n+     * correct order.\n+     */\n+    public Object[] toArray() {\n+\n+        if (fast) {\n+            return (list.toArray());\n+        } else {\n+            synchronized (list) {\n+                return (list.toArray());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return an array containing all of the elements in this list in the\n+     * correct order.  The runtime type of the returned array is that of\n+     * the specified array.  If the list fits in the specified array, it is\n+     * returned therein.  Otherwise, a new array is allocated with the\n+     * runtime type of the specified array, and the size of this list.\n+     *\n+     * @param array Array defining the element type of the returned list\n+     *\n+     * @exception ArrayStoreException if the runtime type of <code>array</code>\n+     *  is not a supertype of the runtime type of every element in this list\n+     */\n+    public Object[] toArray(Object array[]) {\n+\n+        if (fast) {\n+            return (list.toArray(array));\n+        } else {\n+            synchronized (list) {\n+                return (list.toArray(array));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a String representation of this object.\n+     */\n+    public String toString() {\n+\n+        StringBuffer sb = new StringBuffer(\"FastArrayList[\");\n+        sb.append(list.toString());\n+        sb.append(\"]\");\n+        return (sb.toString());\n+\n+    }\n+\n+\n+    /**\n+     * Trim the capacity of this <code>ArrayList</code> instance to be the\n+     * list's current size.  An application can use this operation to minimize\n+     * the storage of an <code>ArrayList</code> instance.\n+     */\n+    public void trimToSize() {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                ArrayList temp = (ArrayList) list.clone();\n+                temp.trimToSize();\n+                list = temp;\n+            }\n+        } else {\n+            synchronized (list) {\n+                list.trimToSize();\n+            }\n+        }\n+\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/FastHashMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastHashMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/16 22:42:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+\n+package org.apache.commons.collections;\n+\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * <p>A customized implementation of <code>java.util.HashMap</code> designed\n+ * to operate in a multithreaded environment where the large majority of\n+ * method calls are read-only, instead of structural changes.  When operating\n+ * in \"fast\" mode, read calls are non-synchronized and write calls perform the\n+ * following steps:</p>\n+ * <ul>\n+ * <li>Clone the existing collection\n+ * <li>Perform the modification on the clone\n+ * <li>Replace the existing collection with the (modified) clone\n+ * </ul>\n+ * <p>When first created, objects of this class default to \"slow\" mode, where\n+ * all accesses of any type are synchronized but no cloning takes place.  This\n+ * is appropriate for initially populating the collection, followed by a switch\n+ * to \"fast\" mode (by calling <code>setFast(true)</code>) after initialization\n+ * is complete.</p>\n+ *\n+ * <p><strong>NOTE</strong>: If you are creating and accessing a\n+ * <code>HashMap</code> only within a single thread, you should use\n+ * <code>java.util.HashMap</code> directly (with no synchronization), for\n+ * maximum performance.</p>\n+ *\n+ * <p><strong>NOTE</strong>: The following methods are <strong>NOT</strong>\n+ * overridden:  clone(), equals(Object), hashCode().</p>\n+ *\n+ * @author Craig R. McClanahan\n+ * @version $Revision: 1.1 $ $Date: 2001/04/16 22:42:04 $\n+ */\n+\n+public class FastHashMap implements Map, Cloneable, Serializable {\n+\n+\n+    // ----------------------------------------------------------- Constructors\n+\n+\n+    /**\n+     * Construct a an empty map.\n+     */\n+    public FastHashMap() {\n+\n+        super();\n+        this.map = new HashMap();\n+\n+    }\n+\n+\n+    /**\n+     * Construct an empty map with the specified capacity.\n+     *\n+     * @param capacity The initial capacity of the empty map\n+     */\n+    public FastHashMap(int capacity) {\n+\n+        super();\n+        this.map = new HashMap(capacity);\n+\n+    }\n+\n+\n+    /**\n+     * Construct an empty map with the specified capacity and load factor.\n+     *\n+     * @param capacity The initial capacity of the empty map\n+     * @param factor The load factor of the new map\n+     */\n+    public FastHashMap(int capacity, float factor) {\n+\n+        super();\n+        this.map = new HashMap(capacity, factor);\n+\n+    }\n+\n+\n+    /**\n+     * Construct a new map with the same mappings as the specified map.\n+     *\n+     * @param map The map whose mappings are to be copied\n+     */\n+    public FastHashMap(Map map) {\n+\n+        super();\n+        this.map = new HashMap(map);\n+\n+    }\n+\n+\n+    // ----------------------------------------------------- Instance Variables\n+\n+\n+    /**\n+     * The underlying map we are managing.\n+     */\n+    protected HashMap map = null;\n+\n+\n+    // ------------------------------------------------------------- Properties\n+\n+\n+    /**\n+     * Are we operating in \"fast\" mode?\n+     */\n+    protected boolean fast = false;\n+\n+    public boolean getFast() {\n+        return (this.fast);\n+    }\n+\n+    public void setFast(boolean fast) {\n+        this.fast = fast;\n+    }\n+\n+\n+    // --------------------------------------------------------- Public Methods\n+\n+\n+    /**\n+     * Remove all mappings from this map.\n+     */\n+    public void clear() {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                HashMap temp = (HashMap) map.clone();\n+                temp.clear();\n+                map = temp;\n+            }\n+        } else {\n+            synchronized (map) {\n+                map.clear();\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return <code>true</code> if this map contains a mapping for the\n+     * specified key.\n+     *\n+     * @param key Key to be searched for\n+     */\n+    public boolean containsKey(Object key) {\n+\n+        if (fast) {\n+            return (map.containsKey(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsKey(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return <code>true</code> if this map contains one or more keys mapping\n+     * to the specified value.\n+     *\n+     * @param value Value to be searched for\n+     */\n+    public boolean containsValue(Object value) {\n+\n+        if (fast) {\n+            return (map.containsValue(value));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsValue(value));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a collection view of the mappings contained in this map.  Each\n+     * element in the returned collection is a <code>Map.Entry</code>.\n+     */\n+    public Set entrySet() {\n+\n+        if (fast) {\n+            return (map.entrySet());\n+        } else {\n+            synchronized (map) {\n+                return (map.entrySet());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the value to which this map maps the specified key.  Returns\n+     * <code>null</code> if the map contains no mapping for this key, or if\n+     * there is a mapping with a value of <code>null</code>.  Use the\n+     * <code>containsKey()</code> method to disambiguate these cases.\n+     *\n+     * @param key Key whose value is to be returned\n+     */\n+    public Object get(Object key) {\n+\n+        if (fast) {\n+            return (map.get(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.get(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return <code>true</code> if this map contains no mappings.\n+     */\n+    public boolean isEmpty() {\n+\n+        if (fast) {\n+            return (map.isEmpty());\n+        } else {\n+            synchronized (map) {\n+                return (map.isEmpty());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a set view of the keys contained in this map.\n+     */\n+    public Set keySet() {\n+\n+        if (fast) {\n+            return (map.keySet());\n+        } else {\n+            synchronized (map) {\n+                return (map.keySet());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Associate the specified value with the specified key in this map.\n+     * If the map previously contained a mapping for this key, the old\n+     * value is replaced and returned.\n+     *\n+     * @param key The key with which the value is to be associated\n+     * @param value The value to be associated with this key\n+     */\n+    public Object put(Object key, Object value) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                HashMap temp = (HashMap) map.clone();\n+                Object result = temp.put(key, value);\n+                map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.put(key, value));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Copy all of the mappings from the specified map to this one, replacing\n+     * any mappings with the same keys.\n+     *\n+     * @param in Map whose mappings are to be copied\n+     */\n+    public void putAll(Map in) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                HashMap temp = (HashMap) map.clone();\n+                temp.putAll(in);\n+                map = temp;\n+            }\n+        } else {\n+            synchronized (map) {\n+                map.putAll(in);\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Remove any mapping for this key, and return any previously\n+     * mapped value.\n+     *\n+     * @param key Key whose mapping is to be removed\n+     */\n+    public Object remove(Object key) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                HashMap temp = (HashMap) map.clone();\n+                Object result = temp.remove(key);\n+                map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.remove(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the number of key-value mappings in this map.\n+     */\n+    public int size() {\n+\n+        if (fast) {\n+            return (map.size());\n+        } else {\n+            synchronized (map) {\n+                return (map.size());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a collection view of the values contained in this map.\n+     */\n+    public Collection values() {\n+\n+        if (fast) {\n+            return (map.values());\n+        } else {\n+            synchronized (map) {\n+                return (map.values());\n+            }\n+        }\n+\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/FastTreeMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastTreeMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/16 22:42:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+\n+package org.apache.commons.collections;\n+\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+\n+/**\n+ * <p>A customized implementation of <code>java.util.TreeMap</code> designed\n+ * to operate in a multithreaded environment where the large majority of\n+ * method calls are read-only, instead of structural changes.  When operating\n+ * in \"fast\" mode, read calls are non-synchronized and write calls perform the\n+ * following steps:</p>\n+ * <ul>\n+ * <li>Clone the existing collection\n+ * <li>Perform the modification on the clone\n+ * <li>Replace the existing collection with the (modified) clone\n+ * </ul>\n+ * <p>When first created, objects of this class default to \"slow\" mode, where\n+ * all accesses of any type are synchronized but no cloning takes place.  This\n+ * is appropriate for initially populating the collection, followed by a switch\n+ * to \"fast\" mode (by calling <code>setFast(true)</code>) after initialization\n+ * is complete.</p>\n+ *\n+ * <p><strong>NOTE</strong>: If you are creating and accessing a\n+ * <code>TreeMap</code> only within a single thread, you should use\n+ * <code>java.util.TreeMap</code> directly (with no synchronization), for\n+ * maximum performance.</p>\n+ *\n+ * <p><strong>NOTE</strong>: The following methods are <strong>NOT</strong>\n+ * overridden:  clone(), equals(Object), hashCode().</p>\n+ *\n+ * @author Craig R. McClanahan\n+ * @version $Revision: 1.1 $ $Date: 2001/04/16 22:42:04 $\n+ */\n+\n+public class FastTreeMap implements Map, Cloneable, Serializable {\n+\n+\n+    // ----------------------------------------------------------- Constructors\n+\n+\n+    /**\n+     * Construct a an empty map.\n+     */\n+    public FastTreeMap() {\n+\n+        super();\n+        this.map = new TreeMap();\n+\n+    }\n+\n+\n+    /**\n+     * Construct an empty map with the specified comparator.\n+     *\n+     * @param comparator The comparator to use for ordering tree elements\n+     */\n+    public FastTreeMap(Comparator comparator) {\n+\n+        super();\n+        this.map = new TreeMap(comparator);\n+\n+    }\n+\n+\n+    /**\n+     * Construct a new map with the same mappings as the specified map,\n+     * sorted according to the keys's natural order\n+     *\n+     * @param map The map whose mappings are to be copied\n+     */\n+    public FastTreeMap(Map map) {\n+\n+        super();\n+        this.map = new TreeMap(map);\n+\n+    }\n+\n+\n+    /**\n+     * Construct a new map with the same mappings as the specified map,\n+     * sorted according to the same ordering\n+     *\n+     * @param map The map whose mappings are to be copied\n+     */\n+    public FastTreeMap(SortedMap map) {\n+\n+        super();\n+        this.map = new TreeMap(map);\n+\n+    }\n+\n+\n+    // ----------------------------------------------------- Instance Variables\n+\n+\n+    /**\n+     * The underlying map we are managing.\n+     */\n+    protected TreeMap map = null;\n+\n+\n+    // ------------------------------------------------------------- Properties\n+\n+\n+    /**\n+     * Are we operating in \"fast\" mode?\n+     */\n+    protected boolean fast = false;\n+\n+    public boolean getFast() {\n+        return (this.fast);\n+    }\n+\n+    public void setFast(boolean fast) {\n+        this.fast = fast;\n+    }\n+\n+\n+    // --------------------------------------------------------- Public Methods\n+\n+\n+    /**\n+     * Remove all mappings from this map.\n+     */\n+    public void clear() {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                TreeMap temp = (TreeMap) map.clone();\n+                temp.clear();\n+                map = temp;\n+            }\n+        } else {\n+            synchronized (map) {\n+                map.clear();\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the comparator used to order this map, or <code>null</code>\n+     * if this map uses its keys' natural order.\n+     */\n+    public Comparator comparator() {\n+\n+        if (fast) {\n+            return (map.comparator());\n+        } else {\n+            synchronized (map) {\n+                return (map.comparator());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return <code>true</code> if this map contains a mapping for the\n+     * specified key.\n+     *\n+     * @param key Key to be searched for\n+     */\n+    public boolean containsKey(Object key) {\n+\n+        if (fast) {\n+            return (map.containsKey(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsKey(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return <code>true</code> if this map contains one or more keys mapping\n+     * to the specified value.\n+     *\n+     * @param value Value to be searched for\n+     */\n+    public boolean containsValue(Object value) {\n+\n+        if (fast) {\n+            return (map.containsValue(value));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsValue(value));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a collection view of the mappings contained in this map.  Each\n+     * element in the returned collection is a <code>Map.Entry</code>.\n+     */\n+    public Set entrySet() {\n+\n+        if (fast) {\n+            return (map.entrySet());\n+        } else {\n+            synchronized (map) {\n+                return (map.entrySet());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the first (lowest) key currently in this sorted map.\n+     */\n+    public Object firstKey() {\n+\n+        if (fast) {\n+            return (map.firstKey());\n+        } else {\n+            synchronized (map) {\n+                return (map.firstKey());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the value to which this map maps the specified key.  Returns\n+     * <code>null</code> if the map contains no mapping for this key, or if\n+     * there is a mapping with a value of <code>null</code>.  Use the\n+     * <code>containsKey()</code> method to disambiguate these cases.\n+     *\n+     * @param key Key whose value is to be returned\n+     */\n+    public Object get(Object key) {\n+\n+        if (fast) {\n+            return (map.get(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.get(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a view of the portion of this map whose keys are strictly\n+     * less than the specified key.\n+     *\n+     * @param key Key higher than any in the returned map\n+     */\n+    public SortedMap headMap(Object key) {\n+\n+        if (fast) {\n+            return (map.headMap(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.headMap(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Test if this list has no elements.\n+     */\n+    public boolean isEmpty() {\n+\n+        if (fast) {\n+            return (map.isEmpty());\n+        } else {\n+            synchronized (map) {\n+                return (map.isEmpty());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a set view of the keys contained in this map.\n+     */\n+    public Set keySet() {\n+\n+        if (fast) {\n+            return (map.keySet());\n+        } else {\n+            synchronized (map) {\n+                return (map.keySet());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the last (highest) key currently in this sorted map.\n+     */\n+    public Object lastKey() {\n+\n+        if (fast) {\n+            return (map.lastKey());\n+        } else {\n+            synchronized (map) {\n+                return (map.lastKey());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Associate the specified value with the specified key in this map.\n+     * If the map previously contained a mapping for this key, the old\n+     * value is replaced and returned.\n+     *\n+     * @param key The key with which the value is to be associated\n+     * @param value The value to be associated with this key\n+     */\n+    public Object put(Object key, Object value) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                TreeMap temp = (TreeMap) map.clone();\n+                Object result = temp.put(key, value);\n+                map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.put(key, value));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Copy all of the mappings from the specified map to this one, replacing\n+     * any mappings with the same keys.\n+     *\n+     * @param in Map whose mappings are to be copied\n+     */\n+    public void putAll(Map in) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                TreeMap temp = (TreeMap) map.clone();\n+                temp.putAll(in);\n+                map = temp;\n+            }\n+        } else {\n+            synchronized (map) {\n+                map.putAll(in);\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Remove any mapping for this key, and return any previously\n+     * mapped value.\n+     *\n+     * @param key Key whose mapping is to be removed\n+     */\n+    public Object remove(Object key) {\n+\n+        if (fast) {\n+            synchronized (this) {\n+                TreeMap temp = (TreeMap) map.clone();\n+                Object result = temp.remove(key);\n+                map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.remove(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return the number of key-value mappings in this map.\n+     */\n+    public int size() {\n+\n+        if (fast) {\n+            return (map.size());\n+        } else {\n+            synchronized (map) {\n+                return (map.size());\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a view of the portion of this map whose keys are in the\n+     * range fromKey (inclusive) to toKey (exclusive).\n+     *\n+     * @param fromKey Lower limit of keys for the returned map\n+     * @param toKey Upper limit of keys for the returned map\n+     */\n+    public SortedMap subMap(Object fromKey, Object toKey) {\n+\n+        if (fast) {\n+            return (map.subMap(fromKey, toKey));\n+        } else {\n+            synchronized (map) {\n+                return (map.subMap(fromKey, toKey));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a view of the portion of this map whose keys are greater than\n+     * or equal to the specified key.\n+     *\n+     * @param key Key less than or equal to any in the returned map\n+     */\n+    public SortedMap tailMap(Object key) {\n+\n+        if (fast) {\n+            return (map.tailMap(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.tailMap(key));\n+            }\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Return a collection view of the values contained in this map.\n+     */\n+    public Collection values() {\n+\n+        if (fast) {\n+            return (map.values());\n+        } else {\n+            synchronized (map) {\n+                return (map.values());\n+            }\n+        }\n+\n+    }\n+\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.2 2001/04/14 19:32:38 craigmcc Exp $\n- * $Revision: 1.2 $\n- * $Date: 2001/04/14 19:32:38 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.3 2001/04/16 22:42:04 jvanzyl Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2001/04/16 22:42:04 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.2 2001/04/14 19:32:38 craigmcc Exp $\n+ * @version $Id: TestAll.java,v 1.3 2001/04/16 22:42:04 jvanzyl Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         TestSuite suite = new TestSuite();\n         suite.addTest(TestArrayStack.suite());\n         suite.addTest(TestCursorableLinkedList.suite());\n+        suite.addTest(TestFastArrayList.suite());\n+        suite.addTest(TestFastHashMap.suite());\n+        suite.addTest(TestFastTreeMap.suite());\n         return suite;\n     }\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestFastArrayList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastArrayList.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/16 22:42:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n+ * @version $Id: TestFastArrayList.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ */\n+public class TestFastArrayList extends TestCase\n+{\n+    public TestFastArrayList(String testName) \n+    {\n+        super(testName);\n+    }\n+\n+    public static Test suite() \n+    {\n+        return new TestSuite(TestFastArrayList.class);\n+    }\n+\n+    public static void main(String args[]) \n+    {\n+        String[] testCaseName = { TestFastArrayList.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    private FastArrayList list = null;\n+\n+    public void setUp() \n+    {\n+        list = new FastArrayList();\n+    }\n+\n+    public void testNewFastArrayList() \n+    {\n+        assert(\"New list is empty\", list.isEmpty());\n+        assertEquals(\"New list has size zero\", list.size(), 0);\n+\n+        try \n+        {\n+            list.get(1);\n+            fail(\"get(int i) should have thrown IndexOutOfBoundsException\");\n+        } \n+        catch (IndexOutOfBoundsException e)\n+        {\n+            ; // Expected result\n+        }\n+    }\n+\n+    public void testSearch() \n+    {\n+        list.add(\"First Item\");\n+        list.add(\"Last Item\");\n+        assertEquals(\"First item is 'First Item'\", list.get(0), \"First Item\");\n+        assertEquals(\"Last Item is 'Last Item'\", list.get(1), \"Last Item\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestFastHashMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastHashMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/16 22:42:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n+ * @version $Id: TestFastHashMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ */\n+public class TestFastHashMap extends TestCase\n+{\n+    public TestFastHashMap(String testName) \n+    {\n+        super(testName);\n+    }\n+\n+    public static Test suite() \n+    {\n+        return new TestSuite(TestFastHashMap.class);\n+    }\n+\n+    public static void main(String args[]) \n+    {\n+        String[] testCaseName = { TestFastHashMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    private FastHashMap map = null;\n+\n+    public void setUp() \n+    {\n+        map = new FastHashMap();\n+    }\n+\n+    public void testNewMap() \n+    {\n+        assert(\"New map is empty\", map.isEmpty());\n+        assertEquals(\"New map has size zero\", map.size(), 0);\n+    }\n+\n+    public void testSearch() \n+    {\n+        map.put(\"first\", \"First Item\");\n+        map.put(\"second\", \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\", map.get(\"first\"), \"First Item\");\n+        assertEquals(\"Next Item is 'First Item'\", map.get(\"second\"), \"Second Item\");\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestFastTreeMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/16 22:42:04 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n+ * @version $Id: TestFastTreeMap.java,v 1.1 2001/04/16 22:42:04 jvanzyl Exp $\n+ */\n+public class TestFastTreeMap extends TestCase\n+{\n+    public TestFastTreeMap(String testName) \n+    {\n+        super(testName);\n+    }\n+\n+    public static Test suite() \n+    {\n+        return new TestSuite(TestFastTreeMap.class);\n+    }\n+\n+    public static void main(String args[]) \n+    {\n+        String[] testCaseName = { TestFastTreeMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    private FastTreeMap map = null;\n+\n+    public void setUp() \n+    {\n+        map = new FastTreeMap();\n+    }\n+\n+    public void testNewMap() \n+    {\n+        assert(\"New map is empty\", map.isEmpty());\n+        assertEquals(\"New map has size zero\", map.size(), 0);\n+    }\n+\n+    public void testSearch() \n+    {\n+        map.put(\"first\", \"First Item\");\n+        map.put(\"second\", \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\", map.get(\"first\"), \"First Item\");\n+        assertEquals(\"Next Item is 'First Item'\", map.get(\"second\"), \"Second Item\");\n+    }\n+}", "timestamp": 987460924, "metainfo": ""}