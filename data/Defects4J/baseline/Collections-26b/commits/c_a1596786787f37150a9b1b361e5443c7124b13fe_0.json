{"sha": "a1596786787f37150a9b1b361e5443c7124b13fe", "log": "Use the more modern, compact, and flexible Javadoc \"{@code ...}\" instead of the HTML \"<tt>...</tt>\".  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/BidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/BidiMap.java\n      * The set is backed by the map, so changes to the map are reflected\n      * in the set, and vice-versa.  If the map is modified while an iteration\n      * over the set is in progress (except through the iterator's own\n-     * <tt>remove</tt> operation), the results of the iteration are undefined.\n+     * {@code remove} operation), the results of the iteration are undefined.\n      * The set supports element removal, which removes the corresponding\n-     * mapping from the map, via the <tt>Iterator.remove</tt>,\n-     * <tt>Collection.remove</tt>, <tt>removeAll</tt>,\n-     * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not\n-     * support the <tt>add</tt> or <tt>addAll</tt> operations.\n+     * mapping from the map, via the {@code Iterator.remove},\n+     * {@code Collection.remove}, {@code removeAll},\n+     * {@code retainAll} and {@code clear} operations.  It does not\n+     * support the {@code add} or {@code addAll} operations.\n      *\n      * @return a set view of the values contained in this map\n      */\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n      * cardinality(<i>e</i>,<i>b</i>))</tt>.\n      * <p>\n      * This is equivalent to\n-     * <tt>{@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})</tt>\n+     * {@code {@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})}\n      * or\n-     * <tt>{@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})</tt>.\n+     * {@code {@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})}.\n \n      * @param a the first collection, must not be null\n      * @param b the second collection, must not be null\n     }\n \n     /**\n-     * Returns a new {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n+     * Returns a new {@link Collection} containing {@code <i>a</i> - <i>b</i>}.\n      * The cardinality of each element <i>e</i> in the returned {@link Collection}\n      * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n      * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n     }\n \n     /**\n-     * Returns <tt>true</tt> iff <i>a</i> is a sub-collection of <i>b</i>,\n+     * Returns {@code true} iff <i>a</i> is a sub-collection of <i>b</i>,\n      * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n      * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n      * in <i>a</i>.\n     }\n \n     /**\n-     * Returns <tt>true</tt> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n+     * Returns {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n      * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n      * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n      * for each element <i>e</i> in <i>a</i>, and there is at least one\n     }\n \n     /**\n-     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n+     * Returns {@code true} iff the given {@link Collection}s contain\n      * exactly the same elements with exactly the same cardinalities.\n      * <p>\n      * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n     }\n \n     /**\n-     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n+     * Returns {@code true} iff the given {@link Collection}s contain\n      * exactly the same elements with exactly the same cardinalities.\n      * <p>\n      * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n--- a/src/main/java/org/apache/commons/collections4/ListUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ListUtils.java\n      * The relevant text (slightly paraphrased as this is a static method) is:\n      * <blockquote>\n      * Compares the two list objects for equality.  Returns\n-     * <tt>true</tt> if and only if both\n+     * {@code true} if and only if both\n      * lists have the same size, and all corresponding pairs of elements in\n-     * the two lists are <i>equal</i>.  (Two elements <tt>e1</tt> and\n-     * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :\n+     * the two lists are <i>equal</i>.  (Two elements {@code e1} and\n+     * {@code e2} are <i>equal</i> if <tt>(e1==null ? e2==null :\n      * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n      * equal if they contain the same elements in the same order.  This\n      * definition ensures that the equals method works properly across\n-     * different implementations of the <tt>List</tt> interface.\n+     * different implementations of the {@code List} interface.\n      * </blockquote>\n      *\n      * <b>Note:</b> The behaviour of this method is undefined if the lists are\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n     int size();\n \n     /**\n-     * Returns <tt>true</tt> if this map contains no key-value mappings.\n-     *\n-     * @return <tt>true</tt> if this map contains no key-value mappings\n+     * Returns {@code true} if this map contains no key-value mappings.\n+     *\n+     * @return {@code true} if this map contains no key-value mappings\n      */\n     boolean isEmpty();\n \n     /**\n-     * Returns <tt>true</tt> if this map contains a mapping for the specified\n-     * key. More formally, returns <tt>true</tt> if and only if this map\n-     * contains a mapping for a key <tt>k</tt> such that\n-     * <tt>(key==null ? k==null : key.equals(k))</tt>. (There can be at most one\n+     * Returns {@code true} if this map contains a mapping for the specified\n+     * key. More formally, returns {@code true} if and only if this map\n+     * contains a mapping for a key {@code k} such that\n+     * {@code (key==null ? k==null : key.equals(k))}. (There can be at most one\n      * such mapping.)\n      *\n      * @param key key whose presence in this map is to be tested\n-     * @return <tt>true</tt> if this map contains a mapping for the specified key\n+     * @return {@code true} if this map contains a mapping for the specified key\n      * @throws ClassCastException if the key is of an inappropriate type for this map (optional)\n      * @throws NullPointerException if the specified key is null and this map\n      *        does not permit null keys (optional)\n      * <p>\n      * The effect of this call is equivalent to that of calling\n      * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n-     * from key <tt>k</tt> to value <tt>v</tt> in the specified map.\n+     * from key {@code k} to value {@code v} in the specified map.\n      * <p>\n      * The behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n      * @param m mappings to be stored in this map\n-     * @throws UnsupportedOperationException if the <tt>putAll</tt> operation is\n+     * @throws UnsupportedOperationException if the {@code putAll} operation is\n      *        not supported by this map\n      * @throws ClassCastException if the class of a key or value in the\n      *        specified map prevents it from being stored in this map (optional)\n      * <p>\n      * The effect of this call is equivalent to that of\n      * calling {@link #put(Object,Object) put(k, v)} on this map once for each\n-     * mapping from key <tt>k</tt> to value <tt>v</tt> in the specified map.\n+     * mapping from key {@code k} to value {@code v} in the specified map.\n      * <p>\n      * The behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n      * @param m mappings to be stored in this map\n-     * @throws UnsupportedOperationException if the <tt>putAll</tt> operation is\n+     * @throws UnsupportedOperationException if the {@code putAll} operation is\n      *        not supported by this map\n      * @throws ClassCastException if the class of a key or value in the\n      *        specified map prevents it from being stored in this map (optional)\n      * in the set, and vice-versa.\n      * <p>\n      * If the map is modified while an iteration over the set is in\n-     * progress (except through the iterator's own <tt>remove</tt> operation),\n+     * progress (except through the iterator's own {@code remove} operation),\n      * the result of the iteration is undefined. The set supports element\n      * removal, which removes the corresponding mapping from the map, via the\n-     * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n-     * <tt>retainAll</tt>, and <tt>clear</tt> operations. It does not support\n-     * the <tt>add</tt> or <tt>addAll</tt> operations.\n+     * {@code Iterator.remove}, {@code Set.remove}, {@code removeAll},\n+     * {@code retainAll}, and {@code clear} operations. It does not support\n+     * the {@code add} or {@code addAll} operations.\n      *\n      * @return a set view of the keys contained in this map\n      */\n--- a/src/main/java/org/apache/commons/collections4/SetUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java\n      * <blockquote>\n      * <p>Two sets are considered equal if they have\n      * the same size, and every member of the first set is contained in\n-     * the second. This ensures that the <tt>equals</tt> method works\n-     * properly across different implementations of the <tt>Set</tt>\n+     * the second. This ensures that the {@code equals} method works\n+     * properly across different implementations of the {@code Set}\n      * interface.</p>\n      *\n      * <p>\n      * This implementation first checks if the two sets are the same object:\n-     * if so it returns <tt>true</tt>.  Then, it checks if the two sets are\n+     * if so it returns {@code true}.  Then, it checks if the two sets are\n      * identical in size; if not, it returns false. If so, it returns\n-     * <tt>a.containsAll((Collection) b)</tt>.</p>\n+     * {@code a.containsAll((Collection) b)}.</p>\n      * </blockquote>\n      *\n      * @see java.util.Set\n--- a/src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java\n      * <i>i</i>, or clear them if the <i>i</i><sup>th</sup> iterator has no next\n      * value.\n      *\n-     * @return <tt>false</tt> iff there was no value to set\n+     * @return {@code false} iff there was no value to set\n      */\n     private boolean set(final int i) {\n         final Iterator<? extends E> it = iterators.get(i);\n--- a/src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java\n     /**\n      * Remove the object from this iterator.\n      *\n-     * @throws IllegalStateException if the <tt>next</tt> method has not\n-     *        yet been called, or the <tt>remove</tt> method has already\n-     *        been called after the last call to the <tt>next</tt>\n+     * @throws IllegalStateException if the {@code next} method has not\n+     *        yet been called, or the {@code remove} method has already\n+     *        been called after the last call to the {@code next}\n      *        method.\n      * @throws UnsupportedOperationException if remove is not supported\n      */\n--- a/src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java\n \n     /**\n      * Returns the index of the element that would be returned by a subsequent\n-     * call to <tt>next</tt>.\n+     * call to {@code next}.\n      *\n      * @return 0 or 1 depending on current state.\n      */\n \n     /**\n      * Returns the index of the element that would be returned by a subsequent\n-     * call to <tt>previous</tt>. A return value of -1 indicates that the iterator is currently at\n+     * call to {@code previous}. A return value of -1 indicates that the iterator is currently at\n      * the start.\n      *\n      * @return 0 or -1 depending on current state.\n \n     /**\n      * Remove the object from this iterator.\n-     * @throws IllegalStateException if the <tt>next</tt> or <tt>previous</tt>\n-     *        method has not yet been called, or the <tt>remove</tt> method\n-     *        has already been called after the last call to <tt>next</tt>\n-     *        or <tt>previous</tt>.\n+     * @throws IllegalStateException if the {@code next} or {@code previous}\n+     *        method has not yet been called, or the {@code remove} method\n+     *        has already been called after the last call to {@code next}\n+     *        or {@code previous}.\n      */\n     public void remove() {\n         if(!nextCalled || removed) {\n      * Set sets the value of the singleton.\n      *\n      * @param obj  the object to set\n-     * @throws IllegalStateException if <tt>next</tt> has not been called\n+     * @throws IllegalStateException if {@code next} has not been called\n      *          or the object has been removed\n      */\n     public void set(final E obj) {\n--- a/src/main/java/org/apache/commons/collections4/map/CompositeMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/CompositeMap.java\n     }\n \n     /**\n-     * Returns <tt>true</tt> if this map contains a mapping for the specified\n-     * key.  More formally, returns <tt>true</tt> if and only if\n-     * this map contains at a mapping for a key <tt>k</tt> such that\n-     * <tt>(key==null ? k==null : key.equals(k))</tt>.  (There can be\n+     * Returns {@code true} if this map contains a mapping for the specified\n+     * key.  More formally, returns {@code true} if and only if\n+     * this map contains at a mapping for a key {@code k} such that\n+     * {@code (key==null ? k==null : key.equals(k))}.  (There can be\n      * at most one such mapping.)\n      *\n      * @param key  key whose presence in this map is to be tested.\n-     * @return <tt>true</tt> if this map contains a mapping for the specified\n+     * @return {@code true} if this map contains a mapping for the specified\n      *         key.\n      *\n      * @throws ClassCastException if the key is of an inappropriate type for\n      *         this map (optional).\n-     * @throws NullPointerException if the key is <tt>null</tt> and this map\n-     *            does not not permit <tt>null</tt> keys (optional).\n+     * @throws NullPointerException if the key is {@code null} and this map\n+     *            does not not permit {@code null} keys (optional).\n      */\n     public boolean containsKey(final Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n     }\n \n     /**\n-     * Returns <tt>true</tt> if this map maps one or more keys to the\n-     * specified value.  More formally, returns <tt>true</tt> if and only if\n-     * this map contains at least one mapping to a value <tt>v</tt> such that\n-     * <tt>(value==null ? v==null : value.equals(v))</tt>.  This operation\n+     * Returns {@code true} if this map maps one or more keys to the\n+     * specified value.  More formally, returns {@code true} if and only if\n+     * this map contains at least one mapping to a value {@code v} such that\n+     * {@code (value==null ? v==null : value.equals(v))}.  This operation\n      * will probably require time linear in the map size for most\n-     * implementations of the <tt>Map</tt> interface.\n+     * implementations of the {@code Map} interface.\n      *\n      * @param value value whose presence in this map is to be tested.\n-     * @return <tt>true</tt> if this map maps one or more keys to the\n+     * @return {@code true} if this map maps one or more keys to the\n      *         specified value.\n      * @throws ClassCastException if the value is of an inappropriate type for\n      *         this map (optional).\n-     * @throws NullPointerException if the value is <tt>null</tt> and this map\n-     *            does not not permit <tt>null</tt> values (optional).\n+     * @throws NullPointerException if the value is {@code null} and this map\n+     *            does not not permit {@code null} values (optional).\n      */\n     public boolean containsValue(final Object value) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n      * If the map is modified while an iteration over the set is in progress,\n      * the results of the iteration are undefined.  The set supports element\n      * removal, which removes the corresponding mapping from the map, via the\n-     * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n-     * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not support\n-     * the <tt>add</tt> or <tt>addAll</tt> operations.\n+     * {@code Iterator.remove}, {@code Set.remove}, {@code removeAll},\n+     * {@code retainAll} and {@code clear} operations.  It does not support\n+     * the {@code add} or {@code addAll} operations.\n      * <p>\n      * This implementation returns a <code>CompositeSet</code> which\n      * composites the entry sets from all of the composited maps.\n \n     /**\n      * Returns the value to which this map maps the specified key.  Returns\n-     * <tt>null</tt> if the map contains no mapping for this key.  A return\n-     * value of <tt>null</tt> does not <i>necessarily</i> indicate that the\n+     * {@code null} if the map contains no mapping for this key.  A return\n+     * value of {@code null} does not <i>necessarily</i> indicate that the\n      * map contains no mapping for the key; it's also possible that the map\n-     * explicitly maps the key to <tt>null</tt>.  The <tt>containsKey</tt>\n+     * explicitly maps the key to {@code null}.  The {@code containsKey}\n      * operation may be used to distinguish these two cases.\n      *\n      * <p>More formally, if this map contains a mapping from a key\n-     * <tt>k</tt> to a value <tt>v</tt> such that <tt>(key==null ? k==null :\n-     * key.equals(k))</tt>, then this method returns <tt>v</tt>; otherwise\n-     * it returns <tt>null</tt>.  (There can be at most one such mapping.)\n+     * {@code k} to a value {@code v} such that <tt>(key==null ? k==null :\n+     * key.equals(k))</tt>, then this method returns {@code v}; otherwise\n+     * it returns {@code null}.  (There can be at most one such mapping.)\n      *\n      * @param key key whose associated value is to be returned.\n      * @return the value to which this map maps the specified key, or\n-     *         <tt>null</tt> if the map contains no mapping for this key.\n+     *         {@code null} if the map contains no mapping for this key.\n      *\n      * @throws ClassCastException if the key is of an inappropriate type for\n      *         this map (optional).\n-     * @throws NullPointerException key is <tt>null</tt> and this map does not\n-     *         not permit <tt>null</tt> keys (optional).\n+     * @throws NullPointerException key is {@code null} and this map does not\n+     *         not permit {@code null} keys (optional).\n      *\n      * @see #containsKey(Object)\n      */\n     }\n \n     /**\n-     * Returns <tt>true</tt> if this map contains no key-value mappings.\n-     *\n-     * @return <tt>true</tt> if this map contains no key-value mappings.\n+     * Returns {@code true} if this map contains no key-value mappings.\n+     *\n+     * @return {@code true} if this map contains no key-value mappings.\n      */\n     public boolean isEmpty() {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n      * vice-versa.  If the map is modified while an iteration over the set is\n      * in progress, the results of the iteration are undefined.  The set\n      * supports element removal, which removes the corresponding mapping from\n-     * the map, via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,\n-     * <tt>removeAll</tt> <tt>retainAll</tt>, and <tt>clear</tt> operations.\n-     * It does not support the add or <tt>addAll</tt> operations.\n+     * the map, via the {@code Iterator.remove}, {@code Set.remove},\n+     * {@code removeAll} {@code retainAll}, and {@code clear} operations.\n+     * It does not support the add or {@code addAll} operations.\n      * <p>\n      * This implementation returns a <code>CompositeSet</code> which\n      * composites the key sets from all of the composited maps.\n      * Associates the specified value with the specified key in this map\n      * (optional operation).  If the map previously contained a mapping for\n      * this key, the old value is replaced by the specified value.  (A map\n-     * <tt>m</tt> is said to contain a mapping for a key <tt>k</tt> if and only\n+     * {@code m} is said to contain a mapping for a key {@code k} if and only\n      * if {@link #containsKey(Object) m.containsKey(k)} would return\n-     * <tt>true</tt>.))\n+     * {@code true}.))\n      *\n      * @param key key with which the specified value is to be associated.\n      * @param value value to be associated with the specified key.\n-     * @return previous value associated with specified key, or <tt>null</tt>\n-     *         if there was no mapping for key.  A <tt>null</tt> return can\n-     *         also indicate that the map previously associated <tt>null</tt>\n+     * @return previous value associated with specified key, or {@code null}\n+     *         if there was no mapping for key.  A {@code null} return can\n+     *         also indicate that the map previously associated {@code null}\n      *         with the specified key, if the implementation supports\n-     *         <tt>null</tt> values.\n+     *         {@code null} values.\n      *\n      * @throws UnsupportedOperationException if no MapMutator has been specified\n      * @throws ClassCastException if the class of the specified key or value\n      *            prevents it from being stored in this map.\n      * @throws IllegalArgumentException if some aspect of this key or value\n      *            prevents it from being stored in this map.\n-     * @throws NullPointerException this map does not permit <tt>null</tt>\n+     * @throws NullPointerException this map does not permit {@code null}\n      *            keys or values, and the specified key or value is\n-     *            <tt>null</tt>.\n+     *            {@code null}.\n      */\n     public V put(final K key, final V value) {\n         if (this.mutator == null) {\n      * Copies all of the mappings from the specified map to this map\n      * (optional operation).  The effect of this call is equivalent to that\n      * of calling {@link #put(Object,Object) put(k, v)} on this map once\n-     * for each mapping from key <tt>k</tt> to value <tt>v</tt> in the\n+     * for each mapping from key {@code k} to value {@code v} in the\n      * specified map.  The behavior of this operation is unspecified if the\n      * specified map is modified while the operation is in progress.\n      *\n      * @param map Mappings to be stored in this map.\n      *\n-     * @throws UnsupportedOperationException if the <tt>putAll</tt> method is\n+     * @throws UnsupportedOperationException if the {@code putAll} method is\n      *         not supported by this map.\n      *\n      * @throws ClassCastException if the class of a key or value in the\n      *\n      * @throws IllegalArgumentException some aspect of a key or value in the\n      *         specified map prevents it from being stored in this map.\n-     * @throws NullPointerException the specified map is <tt>null</tt>, or if\n-     *         this map does not permit <tt>null</tt> keys or values, and the\n-     *         specified map contains <tt>null</tt> keys or values.\n+     * @throws NullPointerException the specified map is {@code null}, or if\n+     *         this map does not permit {@code null} keys or values, and the\n+     *         specified map contains {@code null} keys or values.\n      */\n     public void putAll(final Map<? extends K, ? extends V> map) {\n         if (this.mutator == null) {\n     /**\n      * Removes the mapping for this key from this map if it is present\n      * (optional operation).   More formally, if this map contains a mapping\n-     * from key <tt>k</tt> to value <tt>v</tt> such that\n+     * from key {@code k} to value {@code v} such that\n      * <code>(key==null ?  k==null : key.equals(k))</code>, that mapping\n      * is removed.  (The map can contain at most one such mapping.)\n      *\n      * <p>Returns the value to which the map previously associated the key, or\n-     * <tt>null</tt> if the map contained no mapping for this key.  (A\n-     * <tt>null</tt> return can also indicate that the map previously\n-     * associated <tt>null</tt> with the specified key if the implementation\n-     * supports <tt>null</tt> values.)  The map will not contain a mapping for\n+     * {@code null} if the map contained no mapping for this key.  (A\n+     * {@code null} return can also indicate that the map previously\n+     * associated {@code null} with the specified key if the implementation\n+     * supports {@code null} values.)  The map will not contain a mapping for\n      * the specified  key once the call returns.\n      *\n      * @param key key whose mapping is to be removed from the map.\n-     * @return previous value associated with specified key, or <tt>null</tt>\n+     * @return previous value associated with specified key, or {@code null}\n      *         if there was no mapping for key.\n      *\n      * @throws ClassCastException if the key is of an inappropriate type for\n      *         the composited map (optional).\n-     * @throws NullPointerException if the key is <tt>null</tt> and the composited map\n-     *            does not not permit <tt>null</tt> keys (optional).\n-     * @throws UnsupportedOperationException if the <tt>remove</tt> method is\n+     * @throws NullPointerException if the key is {@code null} and the composited map\n+     *            does not not permit {@code null} keys (optional).\n+     * @throws UnsupportedOperationException if the {@code remove} method is\n      *         not supported by the composited map containing the key\n      */\n     public V remove(final Object key) {\n \n     /**\n      * Returns the number of key-value mappings in this map.  If the\n-     * map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns\n-     * <tt>Integer.MAX_VALUE</tt>.\n+     * map contains more than {@code Integer.MAX_VALUE} elements, returns\n+     * {@code Integer.MAX_VALUE}.\n      *\n      * @return the number of key-value mappings in this map.\n      */\n      * iteration over the collection is in progress, the results of the\n      * iteration are undefined.  The collection supports element removal,\n      * which removes the corresponding mapping from the map, via the\n-     * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\n-     * <tt>removeAll</tt>, <tt>retainAll</tt> and <tt>clear</tt> operations.\n-     * It does not support the add or <tt>addAll</tt> operations.\n+     * {@code Iterator.remove}, {@code Collection.remove},\n+     * {@code removeAll}, {@code retainAll} and {@code clear} operations.\n+     * It does not support the add or {@code addAll} operations.\n      *\n      * @return a collection view of the values contained in this map.\n      */\n          * @param composited  array of Maps in the CompositeMap being modified\n          * @param key  key with which the specified value is to be associated.\n          * @param value  value to be associated with the specified key.\n-         * @return previous value associated with specified key, or <tt>null</tt>\n-         *         if there was no mapping for key.  A <tt>null</tt> return can\n-         *         also indicate that the map previously associated <tt>null</tt>\n+         * @return previous value associated with specified key, or {@code null}\n+         *         if there was no mapping for key.  A {@code null} return can\n+         *         also indicate that the map previously associated {@code null}\n          *         with the specified key, if the implementation supports\n-         *         <tt>null</tt> values.\n+         *         {@code null} values.\n          *\n          * @throws UnsupportedOperationException if not defined\n          * @throws ClassCastException if the class of the specified key or value\n          *            prevents it from being stored in this map.\n          * @throws IllegalArgumentException if some aspect of this key or value\n          *            prevents it from being stored in this map.\n-         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         * @throws NullPointerException this map does not permit {@code null}\n          *            keys or values, and the specified key or value is\n-         *            <tt>null</tt>.\n+         *            {@code null}.\n          */\n         V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, V value);\n \n          *            prevents it from being stored in this map.\n          * @throws IllegalArgumentException if some aspect of this key or value\n          *            prevents it from being stored in this map.\n-         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         * @throws NullPointerException this map does not permit {@code null}\n          *            keys or values, and the specified key or value is\n-         *            <tt>null</tt>.\n+         *            {@code null}.\n          */\n         void putAll(CompositeMap<K, V> map, Map<K, V>[] composited,\n                 Map<? extends K, ? extends V> mapToAdd);\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n     /**\n      * Copies all of the mappings from the specified map to this map. The effect\n      * of this call is equivalent to that of calling {@link #put(Object,Object)\n-     * put(k, v)} on this map once for each mapping from key <tt>k</tt> to value\n-     * <tt>v</tt> in the specified map. The behavior of this operation is\n+     * put(k, v)} on this map once for each mapping from key {@code k} to value\n+     * {@code v} in the specified map. The behavior of this operation is\n      * undefined if the specified map is modified while the operation is in\n      * progress.\n      *\n      * Copies all of the mappings from the specified MultiValuedMap to this map.\n      * The effect of this call is equivalent to that of calling\n      * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n-     * from key <tt>k</tt> to value <tt>v</tt> in the specified map. The\n+     * from key {@code k} to value {@code v} in the specified map. The\n      * behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n      * <p>\n      * Returns a Bag of keys with its values count as the count of the Bag. This\n      * bag is backed by the map, so any changes in the map is reflected here.\n-     * Any method which modifies this bag like <tt>add</tt>, <tt>remove</tt>,\n-     * <tt>Iterator.remove</tt> etc throws\n+     * Any method which modifies this bag like {@code add}, {@code remove},\n+     * {@code Iterator.remove} etc throws\n      * <code>UnsupportedOperationException</code>\n      *\n      * @return a bag view of the key mapping contained in this map", "timestamp": 1405831865, "metainfo": ""}