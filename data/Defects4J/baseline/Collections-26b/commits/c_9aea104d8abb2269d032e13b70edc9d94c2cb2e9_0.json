{"sha": "9aea104d8abb2269d032e13b70edc9d94c2cb2e9", "log": "Where possible: - Add final modifier to private fields - Add final modifier to method parameters - Add final modifier to local variables  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/ArrayStack.java\n+++ b/src/main/java/org/apache/commons/collections/ArrayStack.java\n      * @throws IllegalArgumentException  if the specified initial size\n      *  is negative\n      */\n-    public ArrayStack(int initialSize) {\n+    public ArrayStack(final int initialSize) {\n         super(initialSize);\n     }\n \n      * @throws EmptyStackException  if the stack is empty\n      */\n     public E peek() throws EmptyStackException {\n-        int n = size();\n+        final int n = size();\n         if (n <= 0) {\n             throw new EmptyStackException();\n         } else {\n      * @throws EmptyStackException  if there are not enough items on the\n      *  stack to satisfy this request\n      */\n-    public E peek(int n) throws EmptyStackException {\n-        int m = (size() - n) - 1;\n+    public E peek(final int n) throws EmptyStackException {\n+        final int m = (size() - n) - 1;\n         if (m < 0) {\n             throw new EmptyStackException();\n         } else {\n      * @throws EmptyStackException  if the stack is empty\n      */\n     public E pop() throws EmptyStackException {\n-        int n = size();\n+        final int n = size();\n         if (n <= 0) {\n             throw new EmptyStackException();\n         } else {\n      * @param item  the item to be added\n      * @return the item just pushed\n      */\n-    public E push(E item) {\n+    public E push(final E item) {\n         add(item);\n         return item;\n     }\n      * @param object  the object to be searched for\n      * @return the 1-based depth into the stack of the object, or -1 if not found\n      */\n-    public int search(Object object) {\n+    public int search(final Object object) {\n         int i = size() - 1;        // Current index\n         int n = 1;                 // Current distance\n         while (i >= 0) {\n-            Object current = get(i);\n+            final Object current = get(i);\n             if ((object == null && current == null) ||\n                 (object != null && object.equals(current))) {\n                 return n;\n      * @throws BufferUnderflowException  if the stack is empty\n      */\n     public E get() {\n-        int size = size();\n+        final int size = size();\n         if (size == 0) {\n             throw new BufferUnderflowException();\n         }\n      * @throws BufferUnderflowException  if the stack is empty\n      */\n     public E remove() {\n-        int size = size();\n+        final int size = size();\n         if (size == 0) {\n             throw new BufferUnderflowException();\n         }\n--- a/src/main/java/org/apache/commons/collections/BagUtils.java\n+++ b/src/main/java/org/apache/commons/collections/BagUtils.java\n      * @return a synchronized bag backed by that bag\n      * @throws IllegalArgumentException if the Bag is null\n      */\n-    public static <E> Bag<E> synchronizedBag(Bag<E> bag) {\n+    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n         return SynchronizedBag.synchronizedBag(bag);\n     }\n \n      * @return an unmodifiable view of that bag\n      * @throws IllegalArgumentException if the Bag is null\n      */\n-    public static <E> Bag<E> unmodifiableBag(Bag<E> bag) {\n+    public static <E> Bag<E> unmodifiableBag(final Bag<E> bag) {\n         return UnmodifiableBag.unmodifiableBag(bag);\n     }\n \n      * @return a predicated bag backed by the given bag\n      * @throws IllegalArgumentException if the Bag or Predicate is null\n      */\n-    public static <E> Bag<E> predicatedBag(Bag<E> bag, Predicate<? super E> predicate) {\n+    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n         return PredicatedBag.predicatedBag(bag, predicate);\n     }\n \n      * @return a transformed bag backed by the given bag\n      * @throws IllegalArgumentException if the Bag or Transformer is null\n      */\n-    public static <E> Bag<E> transformingBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         return TransformedBag.transformingBag(bag, transformer);\n     }\n \n      * @return a synchronized bag backed by that bag\n      * @throws IllegalArgumentException if the SortedBag is null\n      */\n-    public static <E> SortedBag<E> synchronizedSortedBag(SortedBag<E> bag) {\n+    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n         return SynchronizedSortedBag.synchronizedSortedBag(bag);\n     }\n \n      * @return an unmodifiable view of that bag\n      * @throws IllegalArgumentException if the SortedBag is null\n      */\n-    public static <E> SortedBag<E> unmodifiableSortedBag(SortedBag<E> bag) {\n+    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n         return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n     }\n \n      * @return a predicated bag backed by the given bag\n      * @throws IllegalArgumentException if the SortedBag or Predicate is null\n      */\n-    public static <E> SortedBag<E> predicatedSortedBag(SortedBag<E> bag,\n-            Predicate<? super E> predicate) {\n+    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n+            final Predicate<? super E> predicate) {\n         return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n     }\n \n      * @return a transformed bag backed by the given bag\n      * @throws IllegalArgumentException if the Bag or Transformer is null\n      */\n-    public static <E> SortedBag<E> transformingSortedBag(SortedBag<E> bag,\n-                                                         Transformer<? super E, ? extends E> transformer) {\n+    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n+                                                         final Transformer<? super E, ? extends E> transformer) {\n         return TransformedSortedBag.transformingSortedBag(bag, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/BufferOverflowException.java\n+++ b/src/main/java/org/apache/commons/collections/BufferOverflowException.java\n      * \n      * @param message  the detail message for this exception\n      */\n-    public BufferOverflowException(String message) {\n+    public BufferOverflowException(final String message) {\n         this(message, null);\n     }\n \n      * @param message  the detail message for this exception\n      * @param exception  the root cause of the exception\n      */\n-    public BufferOverflowException(String message, Throwable exception) {\n+    public BufferOverflowException(final String message, final Throwable exception) {\n         super(message, exception);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/BufferUnderflowException.java\n+++ b/src/main/java/org/apache/commons/collections/BufferUnderflowException.java\n      * \n      * @param message  the detail message for this exception\n      */\n-    public BufferUnderflowException(String message) {\n+    public BufferUnderflowException(final String message) {\n         super(message);\n     }\n \n      * @param message  the detail message for this exception\n      * @param exception  the root cause of the exception\n      */\n-    public BufferUnderflowException(String message, Throwable exception) {\n+    public BufferUnderflowException(final String message, final Throwable exception) {\n         super(message);\n         initCause(exception);\n     }\n--- a/src/main/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/main/java/org/apache/commons/collections/BufferUtils.java\n      * @return a synchronized buffer backed by that buffer\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n-    public static <E> Buffer<E> synchronizedBuffer(Buffer<E> buffer) {\n+    public static <E> Buffer<E> synchronizedBuffer(final Buffer<E> buffer) {\n         return SynchronizedBuffer.synchronizedBuffer(buffer);\n     }\n \n      * @return a blocking buffer backed by that buffer\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n-    public static <E> Buffer<E> blockingBuffer(Buffer<E> buffer) {\n+    public static <E> Buffer<E> blockingBuffer(final Buffer<E> buffer) {\n         return BlockingBuffer.blockingBuffer(buffer);\n     }\n \n      * @throws IllegalArgumentException  if the Buffer is null\n      * @since 3.2\n      */\n-    public static <E> Buffer<E> blockingBuffer(Buffer<E> buffer, long timeoutMillis) {\n+    public static <E> Buffer<E> blockingBuffer(final Buffer<E> buffer, final long timeoutMillis) {\n         return BlockingBuffer.blockingBuffer(buffer, timeoutMillis);\n     }\n \n      * @throws IllegalArgumentException if the given buffer is null\n      * @since 3.2\n      */\n-    public static <E> Buffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize) {\n+    public static <E> Buffer<E> boundedBuffer(final Buffer<E> buffer, final int maximumSize) {\n         return BoundedBuffer.boundedBuffer(buffer, maximumSize);\n     }\n \n      * @throws IllegalArgumentException if the given buffer is null\n      * @since 3.2\n      */\n-    public static <E> Buffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize, long timeoutMillis) {\n+    public static <E> Buffer<E> boundedBuffer(final Buffer<E> buffer, final int maximumSize, final long timeoutMillis) {\n         return BoundedBuffer.boundedBuffer(buffer, maximumSize, timeoutMillis);\n     }\n \n      * @return an unmodifiable buffer backed by that buffer\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n-    public static <E> Buffer<E> unmodifiableBuffer(Buffer<E> buffer) {\n+    public static <E> Buffer<E> unmodifiableBuffer(final Buffer<E> buffer) {\n         return UnmodifiableBuffer.unmodifiableBuffer(buffer);\n     }\n \n      * @return a predicated buffer\n      * @throws IllegalArgumentException  if the Buffer or Predicate is null\n      */\n-    public static <E> Buffer<E> predicatedBuffer(Buffer<E> buffer, Predicate<? super E> predicate) {\n+    public static <E> Buffer<E> predicatedBuffer(final Buffer<E> buffer, final Predicate<? super E> predicate) {\n         return PredicatedBuffer.predicatedBuffer(buffer, predicate);\n     }\n \n      * @return a transformed buffer backed by the given buffer\n      * @throws IllegalArgumentException  if the Buffer or Transformer is null\n      */\n-    public static <E> Buffer<E> transformingBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Buffer<E> transformingBuffer(final Buffer<E> buffer, final Transformer<? super E, ? extends E> transformer) {\n         return TransformedBuffer.transformingBuffer(buffer, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/ClosureUtils.java\n+++ b/src/main/java/org/apache/commons/collections/ClosureUtils.java\n      * @param transformer  the transformer to run each time in the closure, null means nop\n      * @return the closure\n      */\n-    public static <E> Closure<E> asClosure(Transformer<? super E, ?> transformer) {\n+    public static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n         return TransformerClosure.transformerClosure(transformer);\n     }\n \n      * @param closure  the closure to call repeatedly\n      * @return the <code>for</code> closure\n      */\n-    public static <E> Closure<E> forClosure(int count, Closure<? super E> closure) {\n+    public static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n         return ForClosure.forClosure(count, closure);\n     }\n \n      * @return the <code>while</code> closure\n      * @throws IllegalArgumentException if either argument is null\n      */\n-    public static <E> Closure<E> whileClosure(Predicate<? super E> predicate, Closure<? super E> closure) {\n+    public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n         return WhileClosure.<E>whileClosure(predicate, closure, false);\n     }\n \n      * @return the <code>do-while</code> closure\n      * @throws IllegalArgumentException if either argument is null\n      */\n-    public static <E> Closure<E> doWhileClosure(Closure<? super E> closure, Predicate<? super E> predicate) {\n+    public static <E> Closure<E> doWhileClosure(final Closure<? super E> closure, final Predicate<? super E> predicate) {\n         return WhileClosure.<E>whileClosure(predicate, closure, true);\n     }\n \n      * @return the <code>invoker</code> closure\n      * @throws IllegalArgumentException if the method name is null\n      */\n-    public static <E> Closure<E> invokerClosure(String methodName) {\n+    public static <E> Closure<E> invokerClosure(final String methodName) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n     }\n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n-    public static <E> Closure<E> invokerClosure(String methodName, Class<?>[] paramTypes, Object[] args) {\n+    public static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n     }\n      * @return the <code>chained</code> closure\n      * @throws IllegalArgumentException if either closure is null\n      */\n-    public static <E> Closure<E> chainedClosure(Closure<? super E> closure1, Closure<? super E> closure2) {\n+    public static <E> Closure<E> chainedClosure(final Closure<? super E> closure1, final Closure<? super E> closure2) {\n         return ChainedClosure.<E>chainedClosure(closure1, closure2);\n     }\n \n      * @throws IllegalArgumentException if the closures array is null\n      * @throws IllegalArgumentException if any closure in the array is null\n      */\n-    public static <E> Closure<E> chainedClosure(Closure<? super E>... closures) {\n+    public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n         return ChainedClosure.chainedClosure(closures);\n     }\n \n      * @throws IllegalArgumentException if the closures collection is empty\n      * @throws IllegalArgumentException if any closure in the collection is null\n      */\n-    public static <E> Closure<E> chainedClosure(Collection<Closure<E>> closures) {\n+    public static <E> Closure<E> chainedClosure(final Collection<Closure<E>> closures) {\n         return ChainedClosure.chainedClosure(closures);\n     }\n \n      * @throws IllegalArgumentException if the closure is null\n      * @since 3.2\n      */\n-    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n         return IfClosure.<E>ifClosure(predicate, trueClosure);\n     }\n \n      * @throws IllegalArgumentException if the predicate is null\n      * @throws IllegalArgumentException if either closure is null\n      */\n-    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate,\n-                                           Closure<? super E> trueClosure,\n-                                           Closure<? super E> falseClosure) {\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n+                                           final Closure<? super E> trueClosure,\n+                                           final Closure<? super E> falseClosure) {\n         return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n     }\n \n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures) {\n+    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures) {\n         return SwitchClosure.<E>switchClosure(predicates, closures, null);\n     }\n \n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates,\n-                                               Closure<? super E>[] closures,\n-                                               Closure<? super E> defaultClosure) {\n+    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n+                                               final Closure<? super E>[] closures,\n+                                               final Closure<? super E> defaultClosure) {\n         return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n     }\n     \n      * @throws IllegalArgumentException if any closure in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n-    public static <E> Closure<E> switchClosure(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n+    public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n         return SwitchClosure.switchClosure(predicatesAndClosures);\n     }\n \n      * @throws IllegalArgumentException if any closure in the map is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> switchMapClosure(Map<? extends E, Closure<E>> objectsAndClosures) {\n+    public static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n         Closure<? super E>[] trs = null;\n         Predicate<E>[] preds = null;\n         if (objectsAndClosures == null) {\n             throw new IllegalArgumentException(\"The object and closure map must not be null\");\n         }\n-        Closure<? super E> def = objectsAndClosures.remove(null);\n-        int size = objectsAndClosures.size();\n+        final Closure<? super E> def = objectsAndClosures.remove(null);\n+        final int size = objectsAndClosures.size();\n         trs = new Closure[size];\n         preds = new Predicate[size];\n         int i = 0;\n-        for (Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n+        for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n             preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n             trs[i] = entry.getValue();\n             i++;\n--- a/src/main/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections/CollectionUtils.java\n     private static class CardinalityHelper<O> {\n         final Map<O, Integer> cardinalityA, cardinalityB;\n \n-        public CardinalityHelper(Iterable<? extends O> a, Iterable<? extends O> b) {\n+        public CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n             cardinalityA = CollectionUtils.<O>getCardinalityMap(a);\n             cardinalityB = CollectionUtils.<O>getCardinalityMap(b);\n         }\n \n-        public final int max(Object obj) {\n+        public final int max(final Object obj) {\n             return Math.max(freqA(obj), freqB(obj));\n         }\n \n-        public final int min(Object obj) {\n+        public final int min(final Object obj) {\n             return Math.min(freqA(obj), freqB(obj));\n         }\n \n-        public int freqA(Object obj) {\n+        public int freqA(final Object obj) {\n             return getFreq(obj, cardinalityA);\n         }\n \n-        public int freqB(Object obj) {\n+        public int freqB(final Object obj) {\n             return getFreq(obj, cardinalityB);\n         }\n \n         private final int getFreq(final Object obj, final Map<?, Integer> freqMap) {\n-            Integer count = freqMap.get(obj);\n+            final Integer count = freqMap.get(obj);\n             if (count != null) {\n                 return count.intValue();\n             }\n         private final Set<O> elements;\n         private final List<O> newList;\n \n-        public SetOperationCardinalityHelper(Iterable<? extends O> a, Iterable<? extends O> b) {\n+        public SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n             super(a, b);\n             elements = new HashSet<O>();\n             addAll(elements, a);\n             return elements.iterator();\n         }\n \n-        public void setCardinality(O obj, int count) {\n+        public void setCardinality(final O obj, final int count) {\n             for (int i = 0; i < count; i++) {\n                 newList.add(obj);\n             }\n      * @return an empty collection if the argument is <code>null</code>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Collection<T> emptyIfNull(Collection<T> collection) {\n+    public static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n         return collection == null ? EMPTY_COLLECTION : collection;\n     }\n \n      * @see Collection#addAll\n      */\n     public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n-        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n-        for (O obj : helper) {\n+        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (final O obj : helper) {\n             helper.setCardinality(obj, helper.max(obj));\n         }\n         return helper.list();\n      * @see #containsAny\n      */\n     public static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n-        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n-        for (O obj : helper) {\n+        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (final O obj : helper) {\n             helper.setCardinality(obj, helper.min(obj));\n         }\n         return helper.list();\n      * @return the symmetric difference of the two collections\n      */\n     public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n-        SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n-        for (O obj : helper) {\n+        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (final O obj : helper) {\n             helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n         }\n         return helper.list();\n      * @see Collection#removeAll\n      */\n     public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n-        Predicate<O> p = TruePredicate.truePredicate();\n+        final Predicate<O> p = TruePredicate.truePredicate();\n         return subtract(a, b, p);\n     }\n \n                                              final Predicate<O> p) {\n         final ArrayList<O> list = new ArrayList<O>();\n         final HashBag<O> bag = new HashBag<O>();\n-        for (O element : b) {\n+        for (final O element : b) {\n             if (p.evaluate(element)) {\n                 bag.add(element);\n             }\n         }\n-        for (O element : a) {\n+        for (final O element : a) {\n             if (!bag.remove(element, 1)) {\n                 list.add(element);\n             }\n      */\n     public static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n         if (coll1.size() < coll2.size()) {\n-            for (Object aColl1 : coll1) {\n+            for (final Object aColl1 : coll1) {\n                 if (coll2.contains(aColl1)) {\n                     return true;\n                 }\n             }\n         } else {\n-            for (Object aColl2 : coll2) {\n+            for (final Object aColl2 : coll2) {\n                 if (coll1.contains(aColl2)) {\n                     return true;\n                 }\n      * @return the populated cardinality map\n      */\n     public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n-        Map<O, Integer> count = new HashMap<O, Integer>();\n-        for (O obj : coll) {\n-            Integer c = count.get(obj);\n+        final Map<O, Integer> count = new HashMap<O, Integer>();\n+        for (final O obj : coll) {\n+            final Integer c = count.get(obj);\n             if (c == null) {\n                 count.put(obj, Integer.valueOf(1));\n             } else {\n      * @see Collection#containsAll\n      */\n     public static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n-        CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n-        for (Object obj : a) {\n+        final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n+        for (final Object obj : a) {\n             if (helper.freqA(obj) > helper.freqB(obj)) {\n                 return false;\n             }\n         if(helper.cardinalityA.size() != helper.cardinalityB.size()) {\n             return false;\n         }\n-        for( Object obj : helper.cardinalityA.keySet()) {\n+        for( final Object obj : helper.cardinalityA.keySet()) {\n             if(helper.freqA(obj) != helper.freqB(obj)) {\n                 return false;\n             }\n      * @param <O> the type of object that the {@link Iterable} may contain.\n      * @return the the number of occurrences of obj in coll\n      */\n-    public static <O> int cardinality(O obj, final Iterable<? super O> coll) {\n+    public static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n         if (coll instanceof Set<?>) {\n             return ((Set<? super O>) coll).contains(obj) ? 1 : 0;\n         }\n         }\n         int count = 0;\n         if (obj == null) {\n-            for (Object element : coll) {\n+            for (final Object element : coll) {\n                 if (element == null) {\n                     count++;\n                 }\n             }\n         } else {\n-            for (Object element : coll) {\n+            for (final Object element : coll) {\n                 if (obj.equals(element)) {\n                     count++;\n                 }\n      * @param predicate  the predicate to use, may be null\n      * @return the first element of the collection which matches the predicate or null if none could be found\n      */\n-    public static <T> T find(Collection<T> collection, Predicate<? super T> predicate) {\n+    public static <T> T find(final Collection<T> collection, final Predicate<? super T> predicate) {\n         if (collection != null && predicate != null) {\n-            for (T item : collection) {\n+            for (final T item : collection) {\n                 if (predicate.evaluate(item)) {\n                     return item;\n                 }\n      *            the closure to perform, may be null\n      * @return closure\n      */\n-    public static <T, C extends Closure<? super T>> C forAllDo(Collection<T> collection, C closure) {\n+    public static <T, C extends Closure<? super T>> C forAllDo(final Collection<T> collection, final C closure) {\n         if (collection != null && closure != null) {\n-            for (T element : collection) {\n+            for (final T element : collection) {\n                 closure.execute(element);\n             }\n         }\n      * @return closure\n      * @since 4.0\n      */\n-    public static <T, C extends Closure<? super T>> C forAllDo(Iterator<T> iterator, C closure) {\n+    public static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n         if (iterator != null && closure != null) {\n             while (iterator.hasNext()) {\n                 closure.execute(iterator.next());\n      *            the predicate to use as a filter, may be null\n      * @return true if the collection is modified by this call, false otherwise.\n      */\n-    public static <T> boolean filter(Iterable<T> collection, Predicate<? super T> predicate) {\n+    public static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n         boolean result = false;\n         if (collection != null && predicate != null) {\n-            for (Iterator<T> it = collection.iterator(); it.hasNext();) {\n+            for (final Iterator<T> it = collection.iterator(); it.hasNext();) {\n                 if (!predicate.evaluate(it.next())) {\n                     it.remove();\n                     result = true;\n      * @param transformer\n      *            the transformer to perform, may be null\n      */\n-    public static <C> void transform(Collection<C> collection,\n-            Transformer<? super C, ? extends C> transformer) {\n+    public static <C> void transform(final Collection<C> collection,\n+            final Transformer<? super C, ? extends C> transformer) {\n         if (collection != null && transformer != null) {\n             if (collection instanceof List<?>) {\n-                List<C> list = (List<C>) collection;\n-                for (ListIterator<C> it = list.listIterator(); it.hasNext();) {\n+                final List<C> list = (List<C>) collection;\n+                for (final ListIterator<C> it = list.listIterator(); it.hasNext();) {\n                     it.set(transformer.transform(it.next()));\n                 }\n             } else {\n-                Collection<C> resultCollection = collect(collection, transformer);\n+                final Collection<C> resultCollection = collect(collection, transformer);\n                 collection.clear();\n                 collection.addAll(resultCollection);\n             }\n      *            the predicate to use, may be null\n      * @return the number of matches for the predicate in the collection\n      */\n-    public static <C> int countMatches(Iterable<C> input, Predicate<? super C> predicate) {\n+    public static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n         int count = 0;\n         if (input != null && predicate != null) {\n-            for (C o : input) {\n+            for (final C o : input) {\n                 if (predicate.evaluate(o)) {\n                     count++;\n                 }\n      * @return true if at least one element of the collection matches the\n      *         predicate\n      */\n-    public static <C> boolean exists(Iterable<C> input, Predicate<? super C> predicate) {\n+    public static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n         if (input != null && predicate != null) {\n-            for (C o : input) {\n+            for (final C o : input) {\n                 if (predicate.evaluate(o)) {\n                     return true;\n                 }\n      * @throws NullPointerException\n      *             if the input collection is null\n      */\n-    public static <O> Collection<O> select(Collection<? extends O> inputCollection,\n-            Predicate<? super O> predicate) {\n+    public static <O> Collection<O> select(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate) {\n         return select(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n     }\n \n      *            and predicate or not null\n      * @return the outputCollection\n      */\n-    public static <O, R extends Collection<? super O>> R select(Collection<? extends O> inputCollection,\n-            Predicate<? super O> predicate, R outputCollection) {\n+    public static <O, R extends Collection<? super O>> R select(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate, final R outputCollection) {\n         if (inputCollection != null && predicate != null) {\n-            for (O item : inputCollection) {\n+            for (final O item : inputCollection) {\n                 if (predicate.evaluate(item)) {\n                     outputCollection.add(item);\n                 }\n      * @throws NullPointerException\n      *             if the input collection is null\n      */\n-    public static <O> Collection<O> selectRejected(Collection<? extends O> inputCollection,\n-            Predicate<? super O> predicate) {\n+    public static <O> Collection<O> selectRejected(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate) {\n         return selectRejected(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n     }\n \n      * @return outputCollection\n      */\n     public static <O, R extends Collection<? super O>> R selectRejected(\n-            Collection<? extends O> inputCollection, Predicate<? super O> predicate, R outputCollection) {\n+            final Collection<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n         if (inputCollection != null && predicate != null) {\n-            for (O item : inputCollection) {\n+            for (final O item : inputCollection) {\n                 if (!predicate.evaluate(item)) {\n                     outputCollection.add(item);\n                 }\n      * @throws NullPointerException\n      *             if the input collection is null\n      */\n-    public static <I, O> Collection<O> collect(Iterable<I> inputCollection,\n-            Transformer<? super I, ? extends O> transformer) {\n-        ArrayList<O> answer = new ArrayList<O>();\n+    public static <I, O> Collection<O> collect(final Iterable<I> inputCollection,\n+            final Transformer<? super I, ? extends O> transformer) {\n+        final ArrayList<O> answer = new ArrayList<O>();\n         collect(inputCollection, transformer, answer);\n         return answer;\n     }\n      * @param <O> the type of object in the output collection\n      * @return the transformed result (new list)\n      */\n-    public static <I, O> Collection<O> collect(Iterator<I> inputIterator,\n-            Transformer<? super I, ? extends O> transformer) {\n-        ArrayList<O> answer = new ArrayList<O>();\n+    public static <I, O> Collection<O> collect(final Iterator<I> inputIterator,\n+            final Transformer<? super I, ? extends O> transformer) {\n+        final ArrayList<O> answer = new ArrayList<O>();\n         collect(inputIterator, transformer, answer);\n         return answer;\n     }\n      * @throws NullPointerException if the output collection is null and both, inputCollection and\n      *   transformer are not null\n      */\n-    public static <I, O, R extends Collection<? super O>> R collect(Iterable<? extends I> inputCollection,\n+    public static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection,\n             final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n         if (inputCollection != null) {\n             return collect(inputCollection.iterator(), transformer, outputCollection);\n      *   transformer are not null\n      */\n     //TODO - deprecate and replace with IteratorIterable\n-    public static <I, O, R extends Collection<? super O>> R collect(Iterator<? extends I> inputIterator,\n+    public static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator,\n             final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n         if (inputIterator != null && transformer != null) {\n             while (inputIterator.hasNext()) {\n-                I item = inputIterator.next();\n-                O value = transformer.transform(item);\n+                final I item = inputIterator.next();\n+                final O value = transformer.transform(item);\n                 outputCollection.add(value);\n             }\n         }\n      * @throws NullPointerException if the collection is null\n      * @since 3.2\n      */\n-    public static <T> boolean addIgnoreNull(Collection<T> collection, T object) {\n+    public static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n         if (collection == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n      * @throws NullPointerException\n      *             if the collection or iterator is null\n      */\n-    public static <C> boolean addAll(Collection<C> collection, Iterable<? extends C> iterable) {\n+    public static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n         if (iterable instanceof Collection<?>) {\n             return collection.addAll((Collection<? extends C>) iterable);\n         }\n      * @throws NullPointerException\n      *             if the collection or iterator is null\n      */\n-    public static <C> boolean addAll(Collection<C> collection, Iterator<? extends C> iterator) {\n+    public static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n         boolean changed = false;\n         while (iterator.hasNext()) {\n             changed |= collection.add(iterator.next());\n      * @param enumeration  the enumeration of elements to add, must not be null\n      * @throws NullPointerException if the collection or enumeration is null\n      */\n-    public static <C> boolean addAll(Collection<C> collection, Enumeration<? extends C> enumeration) {\n+    public static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n         boolean changed = false;\n         while (enumeration.hasMoreElements()) {\n             changed |= collection.add(enumeration.nextElement());\n      * @throws NullPointerException\n      *             if the collection or array is null\n      */\n-    public static <C> boolean addAll(Collection<C> collection, C[] elements) {\n+    public static <C> boolean addAll(final Collection<C> collection, final C[] elements) {\n         boolean changed = false;\n-        for (C element : elements) {\n+        for (final C element : elements) {\n             changed |= collection.add(element);\n         }\n         return changed;\n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @throws IllegalArgumentException if the object type is invalid\n      */\n-    public static <T> T get(Iterator<T> iterator, int index) {\n+    public static <T> T get(final Iterator<T> iterator, final int index) {\n         int i = index;\n         checkIndexBounds(i);\n             while (iterator.hasNext()) {\n      * @param index the index to check.\n      * @throws IndexOutOfBoundsException if the index is negative.\n      */\n-    private static void checkIndexBounds(int index) {\n+    private static void checkIndexBounds(final int index) {\n         if (index < 0) {\n             throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n         }\n      * @return the object at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public static <T> T get(Iterable<T> iterable, int index) {\n+    public static <T> T get(final Iterable<T> iterable, final int index) {\n         checkIndexBounds(index);\n         if (iterable instanceof List<?>) {\n             return ((List<T>) iterable).get(index);\n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @throws IllegalArgumentException if the object type is invalid\n      */\n-    public static Object get(Object object, int index) {\n+    public static Object get(final Object object, final int index) {\n         int i = index;\n         if (i < 0) {\n             throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n         }\n         if (object instanceof Map<?,?>) {\n-            Map<?, ?> map = (Map<?, ?>) object;\n-            Iterator<?> iterator = map.entrySet().iterator();\n+            final Map<?, ?> map = (Map<?, ?>) object;\n+            final Iterator<?> iterator = map.entrySet().iterator();\n             return get(iterator, i);\n         } else if (object instanceof Object[]) {\n             return ((Object[]) object)[i];\n         } else if (object instanceof Iterator<?>) {\n-            Iterator<?> it = (Iterator<?>) object;\n+            final Iterator<?> it = (Iterator<?>) object;\n             while (it.hasNext()) {\n                 i--;\n                 if (i == -1) {\n             }\n             throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n         } else if (object instanceof Collection<?>) {\n-            Iterator<?> iterator = ((Collection<?>) object).iterator();\n+            final Iterator<?> iterator = ((Collection<?>) object).iterator();\n             return get(iterator, i);\n         } else if (object instanceof Enumeration<?>) {\n-            Enumeration<?> it = (Enumeration<?>) object;\n+            final Enumeration<?> it = (Enumeration<?>) object;\n             while (it.hasMoreElements()) {\n                 i--;\n                 if (i == -1) {\n         } else {\n             try {\n                 return Array.get(object, i);\n-            } catch (IllegalArgumentException ex) {\n+            } catch (final IllegalArgumentException ex) {\n                 throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n             }\n         }\n      * @return the object at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public static <K,V> Map.Entry<K, V> get(Map<K,V> map, int index) {\n+    public static <K,V> Map.Entry<K, V> get(final Map<K,V> map, final int index) {\n         checkIndexBounds(index);\n         return get(map.entrySet(), index);\n     }\n      * @throws IllegalArgumentException thrown if object is not recognised\n      * @since 3.1\n      */\n-    public static int size(Object object) {\n+    public static int size(final Object object) {\n         if (object == null) {\n             return 0;\n         }\n         } else if (object instanceof Object[]) {\n             total = ((Object[]) object).length;\n         } else if (object instanceof Iterator<?>) {\n-            Iterator<?> it = (Iterator<?>) object;\n+            final Iterator<?> it = (Iterator<?>) object;\n             while (it.hasNext()) {\n                 total++;\n                 it.next();\n             }\n         } else if (object instanceof Enumeration<?>) {\n-            Enumeration<?> it = (Enumeration<?>) object;\n+            final Enumeration<?> it = (Enumeration<?>) object;\n             while (it.hasMoreElements()) {\n                 total++;\n                 it.nextElement();\n         } else {\n             try {\n                 total = Array.getLength(object);\n-            } catch (IllegalArgumentException ex) {\n+            } catch (final IllegalArgumentException ex) {\n                 throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n             }\n         }\n      * @throws IllegalArgumentException thrown if object is not recognised\n      * @since 3.2\n      */\n-    public static boolean sizeIsEmpty(Object object) {\n+    public static boolean sizeIsEmpty(final Object object) {\n         if (object == null) {\n             return true;\n         } else if (object instanceof Collection<?>) {\n         } else {\n             try {\n                 return Array.getLength(object) == 0;\n-            } catch (IllegalArgumentException ex) {\n+            } catch (final IllegalArgumentException ex) {\n                 throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n             }\n         }\n      * @return true if empty or null\n      * @since 3.2\n      */\n-    public static boolean isEmpty(Collection<?> coll) {\n+    public static boolean isEmpty(final Collection<?> coll) {\n         return coll == null || coll.isEmpty();\n     }\n \n      * @return true if non-null and non-empty\n      * @since 3.2\n      */\n-    public static boolean isNotEmpty(Collection<?> coll) {\n+    public static boolean isNotEmpty(final Collection<?> coll) {\n         return !isEmpty(coll);\n     }\n \n      *\n      * @param array  the array to reverse\n      */\n-    public static void reverseArray(Object[] array) {\n+    public static void reverseArray(final Object[] array) {\n         int i = 0;\n         int j = array.length - 1;\n         Object tmp;\n      * @throws NullPointerException if the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static boolean isFull(Collection<?> coll) {\n+    public static boolean isFull(final Collection<?> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n             return ((BoundedCollection<?>) coll).isFull();\n         }\n         try {\n-            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n+            final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n             return bcoll.isFull();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return false;\n         }\n     }\n      * @throws NullPointerException if the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static int maxSize(Collection<?> coll) {\n+    public static int maxSize(final Collection<?> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n             return ((BoundedCollection<?>) coll).maxSize();\n         }\n         try {\n-            BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n+            final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n             return bcoll.maxSize();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return -1;\n         }\n     }\n      * @throws NullPointerException if either parameter is null\n      * @since 3.2\n      */\n-    public static <C> Collection<C> retainAll(Collection<C> collection, Collection<?> retain) {\n+    public static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n         return ListUtils.retainAll(collection, retain);\n     }\n \n      * @throws NullPointerException if either parameter is null\n      * @since 3.3 (method existed in 3.2 but was completely broken)\n      */\n-    public static <E> Collection<E> removeAll(Collection<E> collection, Collection<?> remove) {\n+    public static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n         return ListUtils.removeAll(collection, remove);\n     }\n \n      * @return a synchronized collection backed by the given collection\n      * @throws IllegalArgumentException  if the collection is null\n      */\n-    public static <C> Collection<C> synchronizedCollection(Collection<C> collection) {\n+    public static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n         return SynchronizedCollection.synchronizedCollection(collection);\n     }\n \n      * @return an unmodifiable collection backed by the given collection\n      * @throws IllegalArgumentException  if the collection is null\n      */\n-    public static <C> Collection<C> unmodifiableCollection(Collection<C> collection) {\n+    public static <C> Collection<C> unmodifiableCollection(final Collection<C> collection) {\n         return UnmodifiableCollection.unmodifiableCollection(collection);\n     }\n \n      * @return a predicated collection backed by the given collection\n      * @throws IllegalArgumentException  if the Collection is null\n      */\n-    public static <C> Collection<C> predicatedCollection(Collection<C> collection, Predicate<? super C> predicate) {\n+    public static <C> Collection<C> predicatedCollection(final Collection<C> collection, final Predicate<? super C> predicate) {\n         return PredicatedCollection.predicatedCollection(collection, predicate);\n     }\n \n      * @return a transformed collection backed by the given collection\n      * @throws IllegalArgumentException  if the Collection or Transformer is null\n      */\n-    public static <E> Collection<E> transformingCollection(Collection<E> collection, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Collection<E> transformingCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n         return TransformedCollection.transformingCollection(collection, transformer);\n     }\n \n      * @return sole member of collection\n      * @throws IllegalArgumentException if collection is null/empty or contains more than one element\n      */\n-    public static <E> E extractSingleton(Collection<E> collection) {\n+    public static <E> E extractSingleton(final Collection<E> collection) {\n         if (collection == null || collection.size() != 1) {\n             throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n         }\n--- a/src/main/java/org/apache/commons/collections/ComparatorUtils.java\n+++ b/src/main/java/org/apache/commons/collections/ComparatorUtils.java\n      * @see ComparatorChain\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Comparator<E> comparator1,\n-                                                                                    Comparator<E> comparator2) {\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(final Comparator<E> comparator1,\n+                                                                                    final Comparator<E> comparator2) {\n         return chainedComparator(new Comparator[] {comparator1, comparator2});\n     }\n \n      * @throws NullPointerException if comparators array is null or contains a null\n      * @see ComparatorChain\n      */\n-    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Comparator<E>[] comparators) {\n-        ComparatorChain<E> chain = new ComparatorChain<E>();\n-        for (Comparator<E> comparator : comparators) {\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(final Comparator<E>[] comparators) {\n+        final ComparatorChain<E> chain = new ComparatorChain<E>();\n+        for (final Comparator<E> comparator : comparators) {\n             if (comparator == null) {\n                 throw new NullPointerException(\"Comparator cannot be null\");\n             }\n      * @see ComparatorChain\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(Collection<Comparator<E>> comparators) {\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n         return chainedComparator(\n             (Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()])\n         );\n      * @return  a comparator that reverses the order of the input comparator\n      * @see ReverseComparator\n      */\n-    public static <E> Comparator<E> reversedComparator(Comparator<E> comparator) {\n+    public static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n         return new ReverseComparator<E>(comparator);\n     }\n \n      *        <code>false</code> {@link Boolean}s.\n      * @return  a comparator that sorts booleans\n      */\n-    public static Comparator<Boolean> booleanComparator(boolean trueFirst) {\n+    public static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n         return BooleanComparator.booleanComparator(trueFirst);\n     }\n     \n      * @see  TransformingComparator\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Comparator<E> transformedComparator(Comparator<E> comparator, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Comparator<E> transformedComparator(Comparator<E> comparator, final Transformer<? super E, ? extends E> transformer) {\n         if (comparator == null) {\n             comparator = NATURAL_COMPARATOR;\n         }\n      *  @return  the smaller of the two objects\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> E min(E o1, E o2, Comparator<E> comparator) {\n-        if (comparator == null) {\n-            comparator = NATURAL_COMPARATOR;\n-        }\n-        int c = comparator.compare(o1, o2);\n+    public static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        final int c = comparator.compare(o1, o2);\n         return c < 0 ? o1 : o2;\n     }\n \n      *  @return  the larger of the two objects\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> E max(E o1, E o2, Comparator<E> comparator) {\n-        if (comparator == null) {\n-            comparator = NATURAL_COMPARATOR;\n-        }\n-        int c = comparator.compare(o1, o2);\n+    public static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        final int c = comparator.compare(o1, o2);\n         return c > 0 ? o1 : o2;\n     }\n     \n--- a/src/main/java/org/apache/commons/collections/EnumerationUtils.java\n+++ b/src/main/java/org/apache/commons/collections/EnumerationUtils.java\n      * @return a list containing all elements of the given enumeration\n      * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n      */\n-    public static <E> List<E> toList(Enumeration<E> enumeration) {\n+    public static <E> List<E> toList(final Enumeration<E> enumeration) {\n         return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n     }\n \n      * @param stringTokenizer  the tokenizer to convert to a {@link List(String)}\n      * @return List<String>\n      */\n-    public static List<String> toList(StringTokenizer stringTokenizer) {\n-        List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n+    public static List<String> toList(final StringTokenizer stringTokenizer) {\n+        final List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n         while (stringTokenizer.hasMoreTokens()) {\n             result.add(stringTokenizer.nextToken());\n         }\n--- a/src/main/java/org/apache/commons/collections/ExtendedProperties.java\n+++ b/src/main/java/org/apache/commons/collections/ExtendedProperties.java\n      * @param base string to interpolate\n      * @return returns the key name with the ${key} substituted\n      */\n-    protected String interpolate(String base) {\n+    protected String interpolate(final String base) {\n         // COPIED from [configuration] 2003-12-29\n         return interpolateHelper(base, null);\n     }\n      *\n      * @return the string with the interpolation taken care of\n      */\n-    protected String interpolateHelper(String base, List<String> priorVariables) {\n+    protected String interpolateHelper(final String base, List<String> priorVariables) {\n         // COPIED from [configuration] 2003-12-29\n         if (base == null) {\n             return null;\n         int end = -1;\n         int prec = 0 - END_TOKEN.length();\n         String variable = null;\n-        StringBuilder result = new StringBuilder();\n+        final StringBuilder result = new StringBuilder();\n \n         // FIXME: we should probably allow the escaping of the start token\n         while ((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1\n \n             // if we've got a loop, create a useful exception message and throw\n             if (priorVariables.contains(variable)) {\n-                String initialBase = priorVariables.remove(0).toString();\n+                final String initialBase = priorVariables.remove(0).toString();\n                 priorVariables.add(variable);\n-                StringBuilder priorVariableSb = new StringBuilder();\n+                final StringBuilder priorVariableSb = new StringBuilder();\n \n                 // create a nice trace of interpolated variables like so:\n                 // var1->var2->var3\n-                for (Iterator<?> it = priorVariables.iterator(); it.hasNext();) {\n+                for (final Iterator<?> it = priorVariables.iterator(); it.hasNext();) {\n                     priorVariableSb.append(it.next());\n                     if (it.hasNext()) {\n                         priorVariableSb.append(\"->\");\n             }\n \n             //QUESTION: getProperty or getPropertyDirect\n-            Object value = getProperty(variable);\n+            final Object value = getProperty(variable);\n             if (value != null) {\n                 result.append(interpolateHelper(value.toString(), priorVariables));\n \n     /**\n      * Inserts a backslash before every comma and backslash. \n      */\n-    private static String escape(String s) {\n-        StringBuilder buf = new StringBuilder(s);\n+    private static String escape(final String s) {\n+        final StringBuilder buf = new StringBuilder(s);\n         for (int i = 0; i < buf.length(); i++) {\n-            char c = buf.charAt(i);\n+            final char c = buf.charAt(i);\n             if (c == ',' || c == '\\\\') {\n                 buf.insert(i, '\\\\');\n                 i++;\n     /**\n      * Removes a backslash from every pair of backslashes. \n      */\n-    private static String unescape(String s) {\n-        StringBuilder buf = new StringBuilder(s);\n+    private static String unescape(final String s) {\n+        final StringBuilder buf = new StringBuilder(s);\n         for (int i = 0; i < buf.length() - 1; i++) {\n-            char c1 = buf.charAt(i);\n-            char c2 = buf.charAt(i + 1);\n+            final char c1 = buf.charAt(i);\n+            final char c2 = buf.charAt(i + 1);\n             if (c1 == '\\\\' && c2 == '\\\\') {\n                 buf.deleteCharAt(i);\n             }\n      * Counts the number of successive times 'ch' appears in the\n      * 'line' before the position indicated by the 'index'.\n      */\n-    private static int countPreceding(String line, int index, char ch) {\n+    private static int countPreceding(final String line, final int index, final char ch) {\n         int i;\n         for (i = index - 1; i >= 0; i--) {\n             if (line.charAt(i) != ch) {\n     /**\n      * Checks if the line ends with odd number of backslashes \n      */\n-    private static boolean endsWithSlash(String line) {\n+    private static boolean endsWithSlash(final String line) {\n         if (!line.endsWith(\"\\\\\")) {\n             return false;\n         }\n          *\n          * @param reader A Reader.\n          */\n-        public PropertiesReader(Reader reader) {\n+        public PropertiesReader(final Reader reader) {\n             super(reader);\n         }\n \n          * @throws IOException if there is difficulty reading the source.\n          */\n         public String readProperty() throws IOException {\n-            StringBuilder buffer = new StringBuilder();\n+            final StringBuilder buffer = new StringBuilder();\n             String line = readLine();\n             while (line != null) {\n                 line = line.trim();\n          *\n          * @param string A String.\n          */\n-        public PropertiesTokenizer(String string) {\n+        public PropertiesTokenizer(final String string) {\n             super(string, DELIMITER);\n         }\n \n          */\n         @Override\n         public String nextToken() {\n-            StringBuilder buffer = new StringBuilder();\n+            final StringBuilder buffer = new StringBuilder();\n \n             while (hasMoreTokens()) {\n-                String token = super.nextToken();\n+                final String token = super.nextToken();\n                 if (endsWithSlash(token)) {\n                     buffer.append(token.substring(0, token.length() - 1));\n                     buffer.append(DELIMITER);\n      * @param file  the filename to load\n      * @throws IOException if a file error occurs\n      */\n-    public ExtendedProperties(String file) throws IOException {\n+    public ExtendedProperties(final String file) throws IOException {\n         this(file, null);\n     }\n \n      * @param defaultFile  a second filename to load default values from\n      * @throws IOException if a file error occurs\n      */\n-    public ExtendedProperties(String file, String defaultFile) throws IOException {\n+    public ExtendedProperties(final String file, final String defaultFile) throws IOException {\n         this.file = file;\n \n         basePath = new File(file).getAbsolutePath();\n                 if (in != null) {\n                     in.close();\n                 }\n-            } catch (IOException ex) {}\n+            } catch (final IOException ex) {}\n         }\n \n         if (defaultFile != null) {\n      *\n      * @param inc  the property name which includes another property, empty converted to null\n      */\n-    public void setInclude(String inc) {\n+    public void setInclude(final String inc) {\n         includePropertyName = inc;\n     }\n \n      * @param input  the InputStream to load from\n      * @throws IOException if an IO error occurs\n      */\n-    public void load(InputStream input) throws IOException {\n+    public void load(final InputStream input) throws IOException {\n         load(input, null);\n     }\n \n      * @param enc  the encoding to use\n      * @throws IOException if an IO error occurs\n      */\n-    public synchronized void load(InputStream input, String enc) throws IOException {\n+    public synchronized void load(final InputStream input, final String enc) throws IOException {\n         PropertiesReader reader = null;\n         if (enc != null) {\n             try {\n                 reader = new PropertiesReader(new InputStreamReader(input, enc));\n                 \n-            } catch (UnsupportedEncodingException ex) {\n+            } catch (final UnsupportedEncodingException ex) {\n                 // Another try coming up....\n             }\n         }\n             try {\n                 reader = new PropertiesReader(new InputStreamReader(input, \"8859_1\"));\n                 \n-            } catch (UnsupportedEncodingException ex) {\n+            } catch (final UnsupportedEncodingException ex) {\n                 // ISO8859-1 support is required on java platforms but....\n                 // If it's not supported, use the system default encoding\n                 reader = new PropertiesReader(new InputStreamReader(input));\n         }\n \n         try {\n-            String includeProperty = getInclude();\n+            final String includeProperty = getInclude();\n             while (true) {\n-                String line = reader.readProperty();\n+                final String line = reader.readProperty();\n                 if (line == null) {\n                     return;  // EOF\n                 }\n-                int equalSign = line.indexOf('=');\n+                final int equalSign = line.indexOf('=');\n \n                 if (equalSign > 0) {\n-                    String key = line.substring(0, equalSign).trim();\n+                    final String key = line.substring(0, equalSign).trim();\n                     String value = line.substring(equalSign + 1).trim();\n \n                     /* COLLECTIONS-238 allows empty properties to exist by commenting this out\n      * @return value as object. Will return user value if exists,\n      *        if not then default value if exists, otherwise null\n      */\n-    public Object getProperty(String key) {\n+    public Object getProperty(final String key) {\n         // first, try to get from the 'user value' store\n         Object obj = super.get(key);\n \n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    public void addProperty(String key, Object value) {\n+    public void addProperty(final String key, final Object value) {\n         if (value instanceof String) {\n-            String str = (String) value;\n+            final String str = (String) value;\n             if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n                 // token contains commas, so must be split apart then added\n-                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n+                final PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                 while (tokenizer.hasMoreTokens()) {\n-                    String token = tokenizer.nextToken();\n+                    final String token = tokenizer.nextToken();\n                     addPropertyInternal(key, unescape(token));\n                 }\n             } else {\n      * @param key  the key to store at\n      * @param value  the decoded object to store\n      */\n-    private void addPropertyDirect(String key, Object value) {\n+    private void addPropertyDirect(final String key, final Object value) {\n         // safety check\n         if (!containsKey(key)) {\n             keysAsListed.add(key);\n      * @param key  the key to store at\n      * @param value  the decoded object to store\n      */\n-    private void addPropertyInternal(String key, Object value) {\n-        Object current = this.get(key);\n+    private void addPropertyInternal(final String key, final Object value) {\n+        final Object current = this.get(key);\n \n         if (current instanceof String) {\n             // one object already in map - convert it to a vector\n-            List<Object> values = new Vector<Object>(2);\n+            final List<Object> values = new Vector<Object>(2);\n             values.add(current);\n             values.add(value);\n             super.put(key, values);\n         } else if (current instanceof List) {\n             // already a list - just add the new token\n             @SuppressWarnings(\"unchecked\") // OK to cast to Object\n+            final\n             List<Object> list = (List<Object>) current;\n             list.add(value);\n             \n      * @param key  the key to set\n      * @param value  the value to set\n      */\n-    public void setProperty(String key, Object value) {\n+    public void setProperty(final String key, final Object value) {\n         clearProperty(key);\n         addProperty(key, value);\n     }\n      * @param header  a textual comment to act as a file header\n      * @throws IOException if an IO error occurs\n      */\n-    public synchronized void save(OutputStream output, String header) throws IOException {\n+    public synchronized void save(final OutputStream output, final String header) throws IOException {\n         if (output == null) {\n             return;\n         }\n-        PrintWriter theWrtr = new PrintWriter(output);\n+        final PrintWriter theWrtr = new PrintWriter(output);\n         if (header != null) {\n             theWrtr.println(header);\n         }\n         \n-        Enumeration<String> theKeys = keys();\n+        final Enumeration<String> theKeys = keys();\n         while (theKeys.hasMoreElements()) {\n-            String key = theKeys.nextElement();\n-            Object value = get(key);\n+            final String key = theKeys.nextElement();\n+            final Object value = get(key);\n             if (value != null) {\n                 if (value instanceof String) {\n-                    StringBuilder currentOutput = new StringBuilder();\n+                    final StringBuilder currentOutput = new StringBuilder();\n                     currentOutput.append(key);\n                     currentOutput.append(\"=\");\n                     currentOutput.append(escape((String) value));\n                     \n                 } else if (value instanceof List) {\n                     @SuppressWarnings(\"unchecked\") // we only add Strings to the Lists\n+                    final\n                     List<String> values = (List<String>) value;\n-                    for (String currentElement : values) {\n-                        StringBuilder currentOutput = new StringBuilder();\n+                    for (final String currentElement : values) {\n+                        final StringBuilder currentOutput = new StringBuilder();\n                         currentOutput.append(key);\n                         currentOutput.append(\"=\");\n                         currentOutput.append(escape(currentElement));\n      *\n      * @param props  the properties to combine\n      */\n-    public void combine(ExtendedProperties props) {\n-        for (Iterator<String> it = props.getKeys(); it.hasNext();) {\n-            String key = it.next();\n+    public void combine(final ExtendedProperties props) {\n+        for (final Iterator<String> it = props.getKeys(); it.hasNext();) {\n+            final String key = it.next();\n             clearProperty(key);\n             addPropertyDirect(key, props.get(key));\n         }\n      *\n      * @param key  the property key to remove along with corresponding value\n      */\n-    public void clearProperty(String key) {\n+    public void clearProperty(final String key) {\n         if (containsKey(key)) {\n             // we also need to rebuild the keysAsListed or else\n             // things get *very* confusing\n      * @param prefix  the prefix to match\n      * @return an Iterator of keys that match the prefix\n      */\n-    public Iterator<String> getKeys(String prefix) {\n-        Iterator<String> keys = getKeys();\n-        ArrayList<String> matchingKeys = new ArrayList<String>();\n+    public Iterator<String> getKeys(final String prefix) {\n+        final Iterator<String> keys = getKeys();\n+        final ArrayList<String> matchingKeys = new ArrayList<String>();\n \n         while (keys.hasNext()) {\n-            String key = keys.next();\n+            final String key = keys.next();\n             if (key.startsWith(prefix)) {\n                 matchingKeys.add(key);\n             }\n      * @return a new independent ExtendedProperties\n      * or {@code null} if no keys matched\n      */\n-    public ExtendedProperties subset(String prefix) {\n-        ExtendedProperties c = new ExtendedProperties();\n-        Iterator<String> keys = getKeys();\n+    public ExtendedProperties subset(final String prefix) {\n+        final ExtendedProperties c = new ExtendedProperties();\n+        final Iterator<String> keys = getKeys();\n         boolean validSubset = false;\n \n         while (keys.hasNext()) {\n-            String key = keys.next();\n+            final String key = keys.next();\n \n             if (key.startsWith(prefix)) {\n                 if (!validSubset) {\n      * Display the configuration for debugging purposes to System.out.\n      */\n     public void display() {\n-        Iterator<String> i = getKeys();\n+        final Iterator<String> i = getKeys();\n \n         while (i.hasNext()) {\n-            String key = i.next();\n-            Object value = get(key);\n+            final String key = i.next();\n+            final Object value = get(key);\n             System.out.println(key + \" => \" + value);\n         }\n     }\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String.\n      */\n-    public String getString(String key) {\n+    public String getString(final String key) {\n         return getString(key, null);\n     }\n \n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String.\n      */\n-    public String getString(String key, String defaultValue) {\n-        Object value = get(key);\n+    public String getString(final String key, final String defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof String) {\n             return interpolate((String) value);\n             }\n         } else if (value instanceof List) {\n             @SuppressWarnings(\"unchecked\") // Only expecting Strings here\n+            final\n             List<String> entry = (List<String>) value;\n             return interpolate(entry.get(0)); // requires a String\n         } else {\n      * @throws IllegalArgumentException if one of the tokens is\n      * malformed (does not contain an equals sign).\n      */\n-    public Properties getProperties(String key) {\n+    public Properties getProperties(final String key) {\n         return getProperties(key, new Properties());\n     }\n \n      * @throws IllegalArgumentException if one of the tokens is\n      * malformed (does not contain an equals sign).\n      */\n-    public Properties getProperties(String key, Properties defaults) {\n+    public Properties getProperties(final String key, final Properties defaults) {\n         /*\n          * Grab an array of the tokens for this key.\n          */\n-        String[] tokens = getStringArray(key);\n+        final String[] tokens = getStringArray(key);\n \n         // Each token is of the form 'key=value'.\n-        Properties props = new Properties(defaults);\n-        for (String token : tokens) {\n-            int equalSign = token.indexOf('=');\n+        final Properties props = new Properties(defaults);\n+        for (final String token : tokens) {\n+            final int equalSign = token.indexOf('=');\n             if (equalSign > 0) {\n-                String pkey = token.substring(0, equalSign).trim();\n-                String pvalue = token.substring(equalSign + 1).trim();\n+                final String pkey = token.substring(0, equalSign).trim();\n+                final String pvalue = token.substring(equalSign + 1).trim();\n                 props.setProperty(pkey, pvalue);\n             } else {\n                 throw new IllegalArgumentException('\\'' + token + \"' does not contain \" + \"an equals sign\");\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a String/List.\n      */\n-    public String[] getStringArray(String key) {\n-        Object value = get(key);\n+    public String[] getStringArray(final String key) {\n+        final Object value = get(key);\n \n         List<String> values;\n         if (value instanceof String) {\n             \n         } else if (value instanceof List) {\n             @SuppressWarnings(\"unchecked\") // We only add Strings to the Lists\n+            final\n             List<String> list = (List<String>) value;\n             values = list;\n             \n             throw new ClassCastException('\\'' + key + \"' doesn't map to a String/List object\");\n         }\n \n-        String[] tokens = new String[values.size()];\n+        final String[] tokens = new String[values.size()];\n         for (int i = 0; i < tokens.length; i++) {\n             tokens[i] = values.get(i);\n         }\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Vector.\n      */\n-    public Vector<String> getVector(String key) {\n+    public Vector<String> getVector(final String key) {\n         return getVector(key, null);\n     }\n \n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Vector.\n      */\n-    public Vector<String> getVector(String key, Vector<String> defaultValue) {\n-        Object value = get(key);\n+    public Vector<String> getVector(final String key, final Vector<String> defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof List) {\n             @SuppressWarnings(\"unchecked\") // our lists only contain Strings\n+            final\n             List<String> list = (List<String>) value;\n             return new Vector<String>(list);\n             \n         } else if (value instanceof String) {\n-            Vector<String> values = new Vector<String>(1);\n+            final Vector<String> values = new Vector<String>(1);\n             values.add((String) value);\n             super.put(key, values);\n             return values;\n      * object that is not a List.\n      * @since 3.2\n      */\n-    public List<String> getList(String key) {\n+    public List<String> getList(final String key) {\n         return getList(key, null);\n     }\n \n      * object that is not a List.\n      * @since 3.2\n      */\n-    public List<String> getList(String key, List<String> defaultValue) {\n-        Object value = get(key);\n+    public List<String> getList(final String key, final List<String> defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof List) {\n             @SuppressWarnings(\"unchecked\") // our lists only contain strings\n+            final\n             List<String> list = (List<String>) value;\n             return new ArrayList<String>(list);\n             \n         } else if (value instanceof String) {\n-            List<String> values = new ArrayList<String>(1);\n+            final List<String> values = new ArrayList<String>(1);\n             values.add((String) value);\n             super.put(key, values);\n             return values;\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Boolean.\n      */\n-    public boolean getBoolean(String key) {\n-        Boolean b = getBoolean(key, null);\n+    public boolean getBoolean(final String key) {\n+        final Boolean b = getBoolean(key, null);\n         if (b != null) {\n             return b.booleanValue();\n         } else {\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Boolean.\n      */\n-    public boolean getBoolean(String key, boolean defaultValue) {\n+    public boolean getBoolean(final String key, final boolean defaultValue) {\n         return getBoolean(key, Boolean.valueOf(defaultValue)).booleanValue();\n     }\n \n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Boolean.\n      */\n-    public Boolean getBoolean(String key, Boolean defaultValue) {\n-\n-        Object value = get(key);\n+    public Boolean getBoolean(final String key, final Boolean defaultValue) {\n+\n+        final Object value = get(key);\n \n         if (value instanceof Boolean) {\n             return (Boolean) value;\n             \n         } else if (value instanceof String) {\n-            String s = testBoolean((String) value);\n-            Boolean b = Boolean.valueOf(s);\n+            final String s = testBoolean((String) value);\n+            final Boolean b = Boolean.valueOf(s);\n             super.put(key, b);\n             return b;\n             \n      * @return <code>true</code> or <code>false</code> if the supplied\n      * text maps to a boolean value, or <code>null</code> otherwise.\n      */\n-    public String testBoolean(String value) {\n-        String s = value.toLowerCase(Locale.ENGLISH);\n+    public String testBoolean(final String value) {\n+        final String s = value.toLowerCase(Locale.ENGLISH);\n \n         if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\")) {\n             return \"true\";\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public byte getByte(String key) {\n-        Byte b = getByte(key, null);\n+    public byte getByte(final String key) {\n+        final Byte b = getByte(key, null);\n         if (b != null) {\n             return b.byteValue();\n         } else {\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public byte getByte(String key, byte defaultValue) {\n+    public byte getByte(final String key, final byte defaultValue) {\n         return getByte(key, Byte.valueOf(defaultValue)).byteValue();\n     }\n \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public Byte getByte(String key, Byte defaultValue) {\n-        Object value = get(key);\n+    public Byte getByte(final String key, final Byte defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof Byte) {\n             return (Byte) value;\n             \n         } else if (value instanceof String) {\n-            Byte b = new Byte((String) value);\n+            final Byte b = new Byte((String) value);\n             super.put(key, b);\n             return b;\n             \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public short getShort(String key) {\n-        Short s = getShort(key, null);\n+    public short getShort(final String key) {\n+        final Short s = getShort(key, null);\n         if (s != null) {\n             return s.shortValue();\n         } else {\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public short getShort(String key, short defaultValue) {\n+    public short getShort(final String key, final short defaultValue) {\n         return getShort(key, Short.valueOf(defaultValue)).shortValue();\n     }\n \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public Short getShort(String key, Short defaultValue) {\n-        Object value = get(key);\n+    public Short getShort(final String key, final Short defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof Short) {\n             return (Short) value;\n             \n         } else if (value instanceof String) {\n-            Short s = new Short((String) value);\n+            final Short s = new Short((String) value);\n             super.put(key, s);\n             return s;\n             \n      * @param name The resource name.\n      * @return The value of the resource as an integer.\n      */\n-    public int getInt(String name) {\n+    public int getInt(final String name) {\n         return getInteger(name);\n     }\n \n      * @param def The default value of the resource.\n      * @return The value of the resource as an integer.\n      */\n-    public int getInt(String name, int def) {\n+    public int getInt(final String name, final int def) {\n         return getInteger(name, def);\n     }\n \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public int getInteger(String key) {\n-        Integer i = getInteger(key, null);\n+    public int getInteger(final String key) {\n+        final Integer i = getInteger(key, null);\n         if (i != null) {\n             return i.intValue();\n         } else {\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public int getInteger(String key, int defaultValue) {\n-        Integer i = getInteger(key, null);\n+    public int getInteger(final String key, final int defaultValue) {\n+        final Integer i = getInteger(key, null);\n \n         if (i == null) {\n             return defaultValue;\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public Integer getInteger(String key, Integer defaultValue) {\n-        Object value = get(key);\n+    public Integer getInteger(final String key, final Integer defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof Integer) {\n             return (Integer) value;\n             \n         } else if (value instanceof String) {\n-            Integer i = new Integer((String) value);\n+            final Integer i = new Integer((String) value);\n             super.put(key, i);\n             return i;\n             \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public long getLong(String key) {\n-        Long l = getLong(key, null);\n+    public long getLong(final String key) {\n+        final Long l = getLong(key, null);\n         if (l != null) {\n             return l.longValue();\n         } else {\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public long getLong(String key, long defaultValue) {\n+    public long getLong(final String key, final long defaultValue) {\n         return getLong(key, new Long(defaultValue)).longValue();\n     }\n \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public Long getLong(String key, Long defaultValue) {\n-        Object value = get(key);\n+    public Long getLong(final String key, final Long defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof Long) {\n             return (Long) value;\n             \n         } else if (value instanceof String) {\n-            Long l = new Long((String) value);\n+            final Long l = new Long((String) value);\n             super.put(key, l);\n             return l;\n             \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public float getFloat(String key) {\n-        Float f = getFloat(key, null);\n+    public float getFloat(final String key) {\n+        final Float f = getFloat(key, null);\n         if (f != null) {\n             return f.floatValue();\n         } else {\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public float getFloat(String key, float defaultValue) {\n+    public float getFloat(final String key, final float defaultValue) {\n         return getFloat(key, new Float(defaultValue)).floatValue();\n     }\n \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public Float getFloat(String key, Float defaultValue) {\n-        Object value = get(key);\n+    public Float getFloat(final String key, final Float defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof Float) {\n             return (Float) value;\n             \n         } else if (value instanceof String) {\n-            Float f = new Float((String) value);\n+            final Float f = new Float((String) value);\n             super.put(key, f);\n             return f;\n             \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public double getDouble(String key) {\n-        Double d = getDouble(key, null);\n+    public double getDouble(final String key) {\n+        final Double d = getDouble(key, null);\n         if (d != null) {\n             return d.doubleValue();\n         } else {\n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public double getDouble(String key, double defaultValue) {\n+    public double getDouble(final String key, final double defaultValue) {\n         return getDouble(key, new Double(defaultValue)).doubleValue();\n     }\n \n      * @throws NumberFormatException is thrown if the value mapped\n      * by the key has not a valid number format.\n      */\n-    public Double getDouble(String key, Double defaultValue) {\n-        Object value = get(key);\n+    public Double getDouble(final String key, final Double defaultValue) {\n+        final Object value = get(key);\n \n         if (value instanceof Double) {\n             return (Double) value;\n             \n         } else if (value instanceof String) {\n-            Double d = new Double((String) value);\n+            final Double d = new Double((String) value);\n             super.put(key, d);\n             return d;\n             \n      * @param props  the properties object to convert\n      * @return new ExtendedProperties created from props\n      */\n-    public static ExtendedProperties convertProperties(Properties props) {\n-        ExtendedProperties c = new ExtendedProperties();\n+    public static ExtendedProperties convertProperties(final Properties props) {\n+        final ExtendedProperties c = new ExtendedProperties();\n \n         @SuppressWarnings(\"unchecked\") // Properties are supposed to have string keys ...\n+        final\n         Enumeration<String> e = (Enumeration<String>) props.propertyNames();\n         // Unfortunately PMD 4.3 cannot handle the original code where the @Suppress\n         // was in the for loop:\n         //    Enumeration<String> e = (Enumeration<String>) props.propertyNames(); e.hasMoreElements();) {\n         //        String s = e.nextElement(); // ... if props does not, this line would fail anyway ...\n         while (e.hasMoreElements()) {\n-            String s = e.nextElement(); // ... if props does not, this line would fail anyway ...\n-            String value = props.getProperty(s);\n+            final String s = e.nextElement(); // ... if props does not, this line would fail anyway ...\n+            final String value = props.getProperty(s);\n             if(value != null) {\n                 c.setProperty(s, value);\n             }\n      * @return old value of the property\n      */\n     @Override\n-    public Object put(String key, Object value) {\n-        Object ret = getProperty(key);\n+    public Object put(final String key, final Object value) {\n+        final Object ret = getProperty(key);\n         addProperty(key, value);\n         return ret;\n     }\n      * @param map full of key/value pair data\n      */\n     @Override\n-    public void putAll(Map<? extends String, ? extends Object> map) {\n+    public void putAll(final Map<? extends String, ? extends Object> map) {\n         if (map instanceof ExtendedProperties) {\n-            for (Iterator<String> it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n-                String key = it.next();\n+            for (final Iterator<String> it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n+                final String key = it.next();\n                 put(key, map.get(key));\n             }\n         } else {\n             @SuppressWarnings(\"unchecked\") // OK to downcast here\n+            final\n             Map<String, Object> mapso = (Map<String,Object>) map;\n-            for (java.util.Map.Entry<String, Object> entry : mapso.entrySet()) {\n+            for (final java.util.Map.Entry<String, Object> entry : mapso.entrySet()) {\n                 put(entry.getKey(), entry.getValue());\n             }\n         }\n      * @return old value of the property\n      */\n     @Override\n-    public Object remove(Object key) {\n-        String strKey = String.valueOf(key);\n-        Object ret = getProperty(strKey);\n+    public Object remove(final Object key) {\n+        final String strKey = String.valueOf(key);\n+        final Object ret = getProperty(strKey);\n         clearProperty(strKey);\n         return ret;\n     }\n--- a/src/main/java/org/apache/commons/collections/FactoryUtils.java\n+++ b/src/main/java/org/apache/commons/collections/FactoryUtils.java\n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      */\n-    public static <T> Factory<T> constantFactory(T constantToReturn) {\n+    public static <T> Factory<T> constantFactory(final T constantToReturn) {\n         return ConstantFactory.constantFactory(constantToReturn);\n     }\n \n      * the {@code prototype} is {@code null}\n      * @throws IllegalArgumentException if the prototype cannot be cloned\n      */\n-    public static <T> Factory<T> prototypeFactory(T prototype) {\n+    public static <T> Factory<T> prototypeFactory(final T prototype) {\n         return PrototypeFactory.<T>prototypeFactory(prototype);\n     }\n \n      * @return the <code>reflection</code> factory\n      * @throws IllegalArgumentException if the classToInstantiate is null\n      */\n-    public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate) {\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n         return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n     }\n \n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      * @throws IllegalArgumentException if the constructor doesn't exist\n      */\n-    public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n         return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/FunctorException.java\n+++ b/src/main/java/org/apache/commons/collections/FunctorException.java\n      *\n      * @param msg  the error message.\n      */\n-    public FunctorException(String msg) {\n+    public FunctorException(final String msg) {\n         super(msg);\n     }\n \n      * @param rootCause  the exception or error that caused this exception\n      *                   to be thrown.\n      */\n-    public FunctorException(Throwable rootCause) {\n+    public FunctorException(final Throwable rootCause) {\n         super(rootCause);\n     }\n \n      * @param rootCause  the exception or error that caused this exception\n      *                   to be thrown.\n      */\n-    public FunctorException(String msg, Throwable rootCause) {\n+    public FunctorException(final String msg, final Throwable rootCause) {\n         super(msg, rootCause);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections/IteratorUtils.java\n      * @param object  the single object over which to iterate\n      * @return  a singleton iterator over the object\n      */\n-    public static <E> ResettableIterator<E> singletonIterator(E object) {\n+    public static <E> ResettableIterator<E> singletonIterator(final E object) {\n         return new SingletonIterator<E>(object);\n     }\n \n      * @param object  the single object over which to iterate\n      * @return  a singleton list iterator over the object\n      */\n-    public static <E> ListIterator<E> singletonListIterator(E object) {\n+    public static <E> ListIterator<E> singletonListIterator(final E object) {\n         return new SingletonListIterator<E>(object);\n     }\n \n      * @return  an iterator over the array\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableIterator<E> arrayIterator(E[] array) {\n+    public static <E> ResettableIterator<E> arrayIterator(final E[] array) {\n         return new ObjectArrayIterator<E>(array);\n     }\n \n      * @throws IllegalArgumentException if the array is not an array\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableIterator<E> arrayIterator(Object array) {\n+    public static <E> ResettableIterator<E> arrayIterator(final Object array) {\n         return new ArrayIterator<E>(array);\n     }\n \n      *  than the length of the array\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableIterator<E> arrayIterator(E[] array, int start) {\n+    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n         return new ObjectArrayIterator<E>(array, start);\n     }\n \n      *  than the length of the array\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableIterator<E> arrayIterator(Object array, int start) {\n+    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n         return new ArrayIterator<E>(array, start);\n     }\n \n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableIterator<E> arrayIterator(E[] array, int start, int end) {\n+    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n         return new ObjectArrayIterator<E>(array, start, end);\n     }\n \n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableIterator<E> arrayIterator(Object array, int start, int end) {\n+    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n         return new ArrayIterator<E>(array, start, end);\n     }\n \n      * @return  a list iterator over the array\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableListIterator<E> arrayListIterator(E[] array) {\n+    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array) {\n         return new ObjectArrayListIterator<E>(array);\n     }\n \n      * @throws IllegalArgumentException if the array is not an array\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableListIterator<E> arrayListIterator(Object array) {\n+    public static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n         return new ArrayListIterator<E>(array);\n     }\n \n      * @throws IndexOutOfBoundsException if start is less than zero\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableListIterator<E> arrayListIterator(E[] array, int start) {\n+    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n         return new ObjectArrayListIterator<E>(array, start);\n     }\n \n      * @throws IndexOutOfBoundsException if start is less than zero\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableListIterator<E> arrayListIterator(Object array, int start) {\n+    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n         return new ArrayListIterator<E>(array, start);\n     }\n \n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableListIterator<E> arrayListIterator(E[] array, int start, int end) {\n+    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n         return new ObjectArrayListIterator<E>(array, start, end);\n     }\n \n      * @throws IllegalArgumentException if end is before start\n      * @throws NullPointerException if array is null\n      */\n-    public static <E> ResettableListIterator<E> arrayListIterator(Object array, int start, int end) {\n+    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n         return new ArrayListIterator<E>(array, start, end);\n     }\n \n      * @param iterator  the iterator to make immutable\n      * @return an immutable version of the iterator\n      */\n-    public static <E> Iterator<E> unmodifiableIterator(Iterator<E> iterator) {\n+    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n         return UnmodifiableIterator.unmodifiableIterator(iterator);\n     }\n \n      * @param listIterator  the iterator to make immutable\n      * @return an immutable version of the iterator\n      */\n-    public static <E> ListIterator<E> unmodifiableListIterator(ListIterator<E> listIterator) {\n+    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n         return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n     }\n \n      * @param mapIterator  the iterator to make immutable\n      * @return an immutable version of the iterator\n      */\n-    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(MapIterator<K, V> mapIterator) {\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n         return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n     }\n \n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if either iterator is null\n      */\n-    public static <E> Iterator<E> chainedIterator(Iterator<? extends E> iterator1, Iterator<? extends E> iterator2) {\n+    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n         return new IteratorChain<E>(iterator1, iterator2);\n     }\n \n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if iterators array is null or contains a null\n      */\n-    public static <E> Iterator<E> chainedIterator(Iterator<? extends E>[] iterators) {\n+    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E>[] iterators) {\n         return new IteratorChain<E>(iterators);\n     }\n \n      * @throws NullPointerException if iterators collection is null or contains a null\n      * @throws ClassCastException if the iterators collection contains the wrong object type\n      */\n-    public static <E> Iterator<E> chainedIterator(Collection<Iterator<? extends E>> iterators) {\n+    public static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n         return new IteratorChain<E>(iterators);\n     }\n \n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if either iterator is null\n      */\n-    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator, Iterator<? extends E> iterator1, Iterator<? extends E> iterator2) {\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n         return new CollatingIterator<E>(comparator, iterator1, iterator2);\n     }\n \n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if iterators array is null or contains a null\n      */\n-    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator, Iterator<? extends E>[] iterators) {\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>[] iterators) {\n         return new CollatingIterator<E>(comparator, iterators);\n     }\n \n      * @throws NullPointerException if iterators collection is null or contains a null\n      * @throws ClassCastException if the iterators collection contains the wrong object type\n      */\n-    public static <E> Iterator<E> collatedIterator(Comparator<? super E> comparator,\n-            Collection<Iterator<? extends E>> iterators) {\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n+            final Collection<Iterator<? extends E>> iterators) {\n         return new CollatingIterator<E>(comparator, iterators);\n     }\n \n      * @return a new object graph iterator\n      * @since 3.1\n      */\n-    public static <E> Iterator<E> objectGraphIterator(E root, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n         return new ObjectGraphIterator<E>(root, transformer);\n     }\n \n      * @return a new transforming iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static <I, O> Iterator<O> transformedIterator(Iterator<? extends I> iterator, Transformer<? super I, ? extends O> transform) {\n+    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transform) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return a new filtered iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static <E> Iterator<E> filteredIterator(Iterator<? extends E> iterator, Predicate<? super E> predicate) {\n+    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return a new filtered iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static <E> ListIterator<E> filteredListIterator(ListIterator<? extends E> listIterator, Predicate<? super E> predicate) {\n+    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate) {\n         if (listIterator == null) {\n             throw new NullPointerException(\"ListIterator must not be null\");\n         }\n      * @return a new looping iterator\n      * @throws NullPointerException if the collection is null\n      */\n-    public static <E> ResettableIterator<E> loopingIterator(Collection<? extends E> coll) {\n+    public static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"Collection must not be null\");\n         }\n      * @throws NullPointerException if the list is null\n      * @since 3.2\n      */\n-    public static <E> ResettableListIterator<E> loopingListIterator(List<E> list) {\n+    public static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n         if (list == null) {\n             throw new NullPointerException(\"List must not be null\");\n         }\n      * @param enumeration  the enumeration to use\n      * @return a new iterator\n      */\n-    public static <E> Iterator<E> asIterator(Enumeration<? extends E> enumeration) {\n+    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n         if (enumeration == null) {\n             throw new NullPointerException(\"Enumeration must not be null\");\n         }\n      * @param removeCollection  the collection to remove elements from\n      * @return a new iterator\n      */\n-    public static <E> Iterator<E> asIterator(Enumeration<? extends E> enumeration, Collection<? super E> removeCollection) {\n+    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection) {\n         if (enumeration == null) {\n             throw new NullPointerException(\"Enumeration must not be null\");\n         }\n      * @return a new enumeration\n      * @throws NullPointerException if iterator is null\n      */\n-    public static <E> Enumeration<E> asEnumeration(Iterator<? extends E> iterator) {\n+    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return a new, single use iterable\n      * @throws NullPointerException if iterator is null\n      */\n-    public static <E> Iterable<E> asIterable(Iterator<? extends E> iterator) {\n+    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return a new, multiple use iterable\n      * @throws NullPointerException if iterator is null\n      */\n-    public static <E> Iterable<E> asMultipleUseIterable(Iterator<? extends E> iterator) {\n+    public static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return a new iterator\n      * @throws NullPointerException if iterator parameter is null\n      */\n-    public static <E> ListIterator<E> toListIterator(Iterator<? extends E> iterator) {\n+    public static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return an array of the iterator contents\n      * @throws NullPointerException if iterator parameter is null\n      */\n-    public static Object[] toArray(Iterator<?> iterator) {\n+    public static Object[] toArray(final Iterator<?> iterator) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n-        List<?> list = toList(iterator, 100);\n+        final List<?> list = toList(iterator, 100);\n         return list.toArray();\n     }\n \n      * @throws ClassCastException if the arrayClass is invalid\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> E[] toArray(Iterator<? extends E> iterator, Class<E> arrayClass) {\n+    public static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (arrayClass == null) {\n             throw new NullPointerException(\"Array class must not be null\");\n         }\n-        List<E> list = toList(iterator, 100);\n+        final List<E> list = toList(iterator, 100);\n         return list.toArray((E[]) Array.newInstance(arrayClass, list.size()));\n     }\n \n      * @return a list of the iterator contents\n      * @throws NullPointerException if iterator parameter is null\n      */\n-    public static <E> List<E> toList(Iterator<? extends E> iterator) {\n+    public static <E> List<E> toList(final Iterator<? extends E> iterator) {\n         return toList(iterator, 10);\n     }\n \n      * @throws NullPointerException if iterator parameter is null\n      * @throws IllegalArgumentException if the size is less than 1\n      */\n-    public static <E> List<E> toList(Iterator<? extends E> iterator, int estimatedSize) {\n+    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (estimatedSize < 1) {\n             throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n         }\n-        List<E> list = new ArrayList<E>(estimatedSize);\n+        final List<E> list = new ArrayList<E>(estimatedSize);\n         while (iterator.hasNext()) {\n             list.add(iterator.next());\n         }\n      * @param obj  the object to convert to an iterator\n      * @return a suitable iterator, never null\n      */\n-    public static Iterator<?> getIterator(Object obj) {\n+    public static Iterator<?> getIterator(final Object obj) {\n         if (obj == null) {\n             return emptyIterator();\n         }\n             return new ArrayIterator<Object>(obj);\n         }\n         try {\n-            Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n+            final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n             if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n-                Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n+                final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n                 if (it != null) {\n                     return it;\n                 }\n             }\n-        } catch (RuntimeException e) {\n+        } catch (final RuntimeException e) {\n             // ignore\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n             // ignore\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             // ignore\n-        } catch (InvocationTargetException e) {\n+        } catch (final InvocationTargetException e) {\n             // ignore\n         }\n         return singletonIterator(obj);\n--- a/src/main/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/main/java/org/apache/commons/collections/ListUtils.java\n      * @param list the list, possibly <code>null</code>\n      * @return an empty list if the argument is <code>null</code>\n      */\n-    public static <T> List<T> emptyIfNull(List<T> list) {\n+    public static <T> List<T> emptyIfNull(final List<T> list) {\n         return list == null ? Collections.<T>emptyList() : list;\n     }\n     \n             larger = list1;\n         }\n         \n-        HashSet<E> hashSet = new HashSet<E>(smaller);\n-\n-        for (E e : larger) {\n+        final HashSet<E> hashSet = new HashSet<E>(smaller);\n+\n+        for (final E e : larger) {\n             if (hashSet.contains(e)) {\n                 result.add(e);\n                 hashSet.remove(e);\n      * @since 4.0\n      * @see CollectionUtils#select(Collection, Predicate)\n      */\n-    public static <E> List<E> select(Collection<? extends E> inputCollection,\n-            Predicate<? super E> predicate) {\n+    public static <E> List<E> select(final Collection<? extends E> inputCollection,\n+            final Predicate<? super E> predicate) {\n         return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n     }\n \n      * @since 4.0\n      * @see CollectionUtils#selectRejected(Collection, Predicate)\n      */\n-    public static <E> List<E> selectRejected(Collection<? extends E> inputCollection,\n-            Predicate<? super E> predicate) {\n+    public static <E> List<E> selectRejected(final Collection<? extends E> inputCollection,\n+            final Predicate<? super E> predicate) {\n         return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n     }\n \n             return false;\n         }\n \n-        Iterator<?> it1 = list1.iterator();\n-        Iterator<?> it2 = list2.iterator();\n+        final Iterator<?> it1 = list1.iterator();\n+        final Iterator<?> it2 = list2.iterator();\n         Object obj1 = null;\n         Object obj2 = null;\n \n             return 0;\n         }\n         int hashCode = 1;\n-        Iterator<?> it = list.iterator();\n+        final Iterator<?> it = list.iterator();\n         \n         while (it.hasNext()) {\n-            Object obj = it.next();\n+            final Object obj = it.next();\n             hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n         }\n         return hashCode;\n      * @throws NullPointerException if either parameter is null\n      * @since 3.2\n      */\n-    public static <E> List<E> retainAll(Collection<E> collection, Collection<?> retain) {\n-        List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n-\n-        for (E obj : collection) {\n+    public static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n+        final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n+\n+        for (final E obj : collection) {\n             if (retain.contains(obj)) {\n                 list.add(obj);\n             }\n      * @throws NullPointerException if either parameter is null\n      * @since 3.2\n      */\n-    public static <E> List<E> removeAll(Collection<E> collection, Collection<?> remove) {\n-        List<E> list = new ArrayList<E>();\n-        for (E obj : collection) {\n+    public static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n+        final List<E> list = new ArrayList<E>();\n+        for (final E obj : collection) {\n             if (!remove.contains(obj)) {\n                 list.add(obj);\n             }\n      * @return a synchronized list backed by the given list\n      * @throws IllegalArgumentException  if the list is null\n      */\n-    public static <E> List<E> synchronizedList(List<E> list) {\n+    public static <E> List<E> synchronizedList(final List<E> list) {\n         return SynchronizedList.synchronizedList(list);\n     }\n \n      * @return an unmodifiable list backed by the given list\n      * @throws IllegalArgumentException  if the list is null\n      */\n-    public static <E> List<E> unmodifiableList(List<E> list) {\n+    public static <E> List<E> unmodifiableList(final List<E> list) {\n         return UnmodifiableList.unmodifiableList(list);\n     }\n \n      * @return a predicated list backed by the given list\n      * @throws IllegalArgumentException  if the List or Predicate is null\n      */\n-    public static <E> List<E> predicatedList(List<E> list, Predicate<E> predicate) {\n+    public static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n         return PredicatedList.predicatedList(list, predicate);\n     }\n \n      * @return a transformed list backed by the given list\n      * @throws IllegalArgumentException  if the List or Transformer is null\n      */\n-    public static <E> List<E> transformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> List<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n         return TransformedList.transformingList(list, transformer);\n     }\n     \n      * @return a lazy list backed by the given list\n      * @throws IllegalArgumentException  if the List or Factory is null\n      */\n-    public static <E> List<E> lazyList(List<E> list, Factory<? extends E> factory) {\n+    public static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n         return LazyList.lazyList(list, factory);\n     }\n \n      * @return a fixed-size list backed by that list\n      * @throws IllegalArgumentException  if the List is null\n      */\n-    public static <E> List<E> fixedSizeList(List<E> list) {\n+    public static <E> List<E> fixedSizeList(final List<E> list) {\n         return FixedSizeList.fixedSizeList(list);\n     }\n \n      * @param predicate  the predicate to use, may be null\n      * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n      */\n-    public static <E> int indexOf(List<E> list, Predicate<E> predicate) {\n+    public static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n         if (list != null && predicate != null) {\n             for (int i = 0; i < list.size(); i++) {\n-                E item = list.get(i);\n+                final E item = list.get(i);\n                 if (predicate.evaluate(item)) {\n                     return i;\n                 }\n      * @return a list of consecutive sublists\n      * @throws IllegalArgumentException if list is {@code null} or size is not strictly positive\n      */\n-    public static <T> List<List<T>> partition(List<T> list, int size) {\n+    public static <T> List<List<T>> partition(final List<T> list, final int size) {\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");          \n         }\n         private final List<T> list;\n         private final int size;\n \n-        private Partition(List<T> list, int size) {\n+        private Partition(final List<T> list, final int size) {\n             this.list = list;\n             this.size = size;\n         }\n \n         @Override\n-        public List<T> get(int index) {\n-            int listSize = size();\n+        public List<T> get(final int index) {\n+            final int listSize = size();\n             if (listSize < 0) {\n                 throw new IllegalArgumentException(\"negative size: \" + listSize);           \n             }\n                 throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n                                                     listSize);           \n             }           \n-            int start = index * size;\n-            int end = Math.min(start + size, list.size());\n+            final int start = index * size;\n+            final int end = Math.min(start + size, list.size());\n             return list.subList(start, end);\n         }\n \n--- a/src/main/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/main/java/org/apache/commons/collections/MapUtils.java\n      */\n     public static <K> String getString(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n-            Object answer = map.get(key);\n+            final Object answer = map.get(key);\n             if (answer != null) {\n                 return answer.toString();\n             }\n      */\n     public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n-            Object answer = map.get(key);\n+            final Object answer = map.get(key);\n             if (answer != null) {\n                 if (answer instanceof Boolean) {\n                     return (Boolean) answer;\n                     return Boolean.valueOf((String) answer);\n                 }\n                 if (answer instanceof Number) {\n-                    Number n = (Number) answer;\n+                    final Number n = (Number) answer;\n                     return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n                 }\n             }\n      */\n     public static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n-            Object answer = map.get(key);\n+            final Object answer = map.get(key);\n             if (answer != null) {\n                 if (answer instanceof Number) {\n                     return (Number) answer;\n                 }\n                 if (answer instanceof String) {\n                     try {\n-                        String text = (String) answer;\n+                        final String text = (String) answer;\n                         return NumberFormat.getInstance().parse(text);\n-                    } catch (ParseException e) {\n+                    } catch (final ParseException e) {\n                         // failure means null is returned\n                     }\n                 }\n      * @return the value in the Map as a Byte, <code>null</code> if null map input\n      */\n     public static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n-        Number answer = getNumber(map, key);\n+        final Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n         }\n      * @return the value in the Map as a Short, <code>null</code> if null map input\n      */\n     public static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n-        Number answer = getNumber(map, key);\n+        final Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n         }\n      * @return the value in the Map as a Integer, <code>null</code> if null map input\n      */\n     public static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n-        Number answer = getNumber(map, key);\n+        final Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n         }\n      * @return the value in the Map as a Long, <code>null</code> if null map input\n      */\n     public static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n-        Number answer = getNumber(map, key);\n+        final Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n         }\n      * @return the value in the Map as a Float, <code>null</code> if null map input\n      */\n     public static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n-        Number answer = getNumber(map, key);\n+        final Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n         }\n      * @return the value in the Map as a Double, <code>null</code> if null map input\n      */\n     public static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n-        Number answer = getNumber(map, key);\n+        final Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n         }\n      */\n     public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n-            Object answer = map.get(key);\n+            final Object answer = map.get(key);\n             if (answer != null && answer instanceof Map) {\n                 return (Map<?, ?>) answer;\n             }\n      *  @return  the value in the map, or defaultValue if the original value\n      *    is null or the map is null\n      */\n-    public static <K, V> V getObject(Map<K, V> map, K key, V defaultValue) {\n+    public static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n         if (map != null) {\n-            V answer = map.get(key);\n+            final V answer = map.get(key);\n             if (answer != null) {\n                 return answer;\n             }\n      *    original value is null, the map is null or the string conversion\n      *    fails\n      */\n-    public static <K> String getString(Map<? super K, ?> map, K key, String defaultValue) {\n+    public static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n         String answer = getString(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the boolean conversion\n      *    fails\n      */\n-    public static <K> Boolean getBoolean(Map<? super K, ?> map, K key, Boolean defaultValue) {\n+    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n         Boolean answer = getBoolean(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static <K> Number getNumber(Map<? super K, ?> map, K key, Number defaultValue) {\n+    public static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n         Number answer = getNumber(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static <K> Byte getByte(Map<? super K, ?> map, K key, Byte defaultValue) {\n+    public static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n         Byte answer = getByte(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static <K> Short getShort(Map<? super K, ?> map, K key, Short defaultValue) {\n+    public static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n         Short answer = getShort(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static <K> Integer getInteger(Map<? super K, ?> map, K key, Integer defaultValue) {\n+    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n         Integer answer = getInteger(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static <K> Long getLong(Map<? super K, ?> map, K key, Long defaultValue) {\n+    public static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n         Long answer = getLong(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static <K> Float getFloat(Map<? super K, ?> map, K key, Float defaultValue) {\n+    public static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n         Float answer = getFloat(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static <K> Double getDouble(Map<? super K, ?> map, K key, Double defaultValue) {\n+    public static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n         Double answer = getDouble(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      *    original value is null, the map is null or the map conversion\n      *    fails\n      */\n-    public static <K> Map<?, ?> getMap(Map<? super K, ?> map, K key, Map<?, ?> defaultValue) {\n+    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n         Map<?, ?> answer = getMap(map, key);\n         if (answer == null) {\n             answer = defaultValue;\n      * @return the value in the Map as a byte, <code>0</code> if null map input\n      */\n     public static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n-        Byte byteObject = getByte(map, key);\n+        final Byte byteObject = getByte(map, key);\n         if (byteObject == null) {\n             return 0;\n         }\n      * @return the value in the Map as a short, <code>0</code> if null map input\n      */\n     public static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n-        Short shortObject = getShort(map, key);\n+        final Short shortObject = getShort(map, key);\n         if (shortObject == null) {\n             return 0;\n         }\n      * @return the value in the Map as an int, <code>0</code> if null map input\n      */\n     public static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n-        Integer integerObject = getInteger(map, key);\n+        final Integer integerObject = getInteger(map, key);\n         if (integerObject == null) {\n             return 0;\n         }\n      * @return the value in the Map as a long, <code>0L</code> if null map input\n      */\n     public static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n-        Long longObject = getLong(map, key);\n+        final Long longObject = getLong(map, key);\n         if (longObject == null) {\n             return 0L;\n         }\n      * @return the value in the Map as a float, <code>0.0F</code> if null map input\n      */\n     public static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n-        Float floatObject = getFloat(map, key);\n+        final Float floatObject = getFloat(map, key);\n         if (floatObject == null) {\n             return 0f;\n         }\n      * @return the value in the Map as a double, <code>0.0</code> if null map input\n      */\n     public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n-        Double doubleObject = getDouble(map, key);\n+        final Double doubleObject = getDouble(map, key);\n         if (doubleObject == null) {\n             return 0d;\n         }\n      *     conversion fails\n      * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n      */\n-    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, boolean defaultValue) {\n-        Boolean booleanObject = getBoolean(map, key);\n+    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n+        final Boolean booleanObject = getBoolean(map, key);\n         if (booleanObject == null) {\n             return defaultValue;\n         }\n      *     conversion fails\n      * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n      */\n-    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key, byte defaultValue) {\n-        Byte byteObject = getByte(map, key);\n+    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n+        final Byte byteObject = getByte(map, key);\n         if (byteObject == null) {\n             return defaultValue;\n         }\n      *     conversion fails\n      * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n      */\n-    public static <K> short getShortValue(final Map<? super K, ?> map, final K key, short defaultValue) {\n-        Short shortObject = getShort(map, key);\n+    public static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n+        final Short shortObject = getShort(map, key);\n         if (shortObject == null) {\n             return defaultValue;\n         }\n      *     conversion fails\n      * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n      */\n-    public static <K> int getIntValue(final Map<? super K, ?> map, final K key, int defaultValue) {\n-        Integer integerObject = getInteger(map, key);\n+    public static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n+        final Integer integerObject = getInteger(map, key);\n         if (integerObject == null) {\n             return defaultValue;\n         }\n      *     conversion fails\n      * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n      */\n-    public static <K> long getLongValue(final Map<? super K, ?> map, final K key, long defaultValue) {\n-        Long longObject = getLong(map, key);\n+    public static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n+        final Long longObject = getLong(map, key);\n         if (longObject == null) {\n             return defaultValue;\n         }\n      *     conversion fails\n      * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n      */\n-    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key, float defaultValue) {\n-        Float floatObject = getFloat(map, key);\n+    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n+        final Float floatObject = getFloat(map, key);\n         if (floatObject == null) {\n             return defaultValue;\n         }\n      *     conversion fails\n      * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n      */\n-    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, double defaultValue) {\n-        Double doubleObject = getDouble(map, key);\n+    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n+        final Double doubleObject = getDouble(map, key);\n         if (doubleObject == null) {\n             return defaultValue;\n         }\n      * @return the properties object\n      */\n     public static <K, V> Properties toProperties(final Map<K, V> map) {\n-        Properties answer = new Properties();\n+        final Properties answer = new Properties();\n         if (map != null) {\n-            for (Entry<K, V> entry2 : map.entrySet()) {\n-                Map.Entry<?, ?> entry = entry2;\n-                Object key = entry.getKey();\n-                Object value = entry.getValue();\n+            for (final Entry<K, V> entry2 : map.entrySet()) {\n+                final Map.Entry<?, ?> entry = entry2;\n+                final Object key = entry.getKey();\n+                final Object value = entry.getValue();\n                 answer.put(key, value);\n             }\n         }\n      * @throws NullPointerException if the bundle is null\n      */\n     public static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n-        Enumeration<String> enumeration = resourceBundle.getKeys();\n-        Map<String, Object> map = new HashMap<String, Object>();\n+        final Enumeration<String> enumeration = resourceBundle.getKeys();\n+        final Map<String, Object> map = new HashMap<String, Object>();\n \n         while (enumeration.hasMoreElements()) {\n-            String key = enumeration.nextElement();\n-            Object value = resourceBundle.getObject(key);\n+            final String key = enumeration.nextElement();\n+            final Object value = resourceBundle.getObject(key);\n             map.put(key, value);\n         }\n \n \n         lineage.push(map);\n \n-        for (Map.Entry<?, ?> entry : map.entrySet()) {\n-            Object childKey = entry.getKey();\n-            Object childValue = entry.getValue();\n+        for (final Map.Entry<?, ?> entry : map.entrySet()) {\n+            final Object childKey = entry.getKey();\n+            final Object childValue = entry.getValue();\n             if (childValue instanceof Map && !lineage.contains(childValue)) {\n                 verbosePrintInternal(\n                     out,\n      * @return a new HashMap containing the inverted data\n      * @throws NullPointerException if the map is null\n      */\n-    public static <K, V> Map<V, K> invertMap(Map<K, V> map) {\n-        Map<V, K> out = new HashMap<V, K>(map.size());\n-        for (Entry<K, V> entry : map.entrySet()) {\n+    public static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n+        final Map<V, K> out = new HashMap<V, K>(map.size());\n+        for (final Entry<K, V> entry : map.entrySet()) {\n             out.put(entry.getValue(), entry.getKey());\n         }\n         return out;\n      * @param value  the value, null converted to \"\"\n      * @throws NullPointerException if the map is null\n      */\n-    public static <K> void safeAddToMap(Map<? super K, Object> map, K key, Object value) throws NullPointerException {\n+    public static <K> void safeAddToMap(final Map<? super K, Object> map, final K key, final Object value) throws NullPointerException {\n         map.put(key, value == null ? \"\" : value);\n     }\n \n      * @since 3.2\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <K, V> Map<K, V> putAll(Map<K, V> map, Object[] array) {\n+    public static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n         map.size();  // force NPE\n         if (array == null || array.length == 0) {\n             return map;\n         }\n-        Object obj = array[0];\n+        final Object obj = array[0];\n         if (obj instanceof Map.Entry) {\n-            for (Object element : array) {\n-                Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n+            for (final Object element : array) {\n+                final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n                 map.put(entry.getKey(), entry.getValue());\n             }\n         } else if (obj instanceof KeyValue) {\n-            for (Object element : array) {\n-                KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n+            for (final Object element : array) {\n+                final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n                 map.put(keyval.getKey(), keyval.getValue());\n             }\n         } else if (obj instanceof Object[]) {\n             for (int i = 0; i < array.length; i++) {\n-                Object[] sub = (Object[]) array[i];\n+                final Object[] sub = (Object[]) array[i];\n                 if (sub == null || sub.length < 2) {\n                     throw new IllegalArgumentException(\"Invalid array element: \" + i);\n                 }\n      * @param map the map, possibly <code>null</code>\n      * @return an empty map if the argument is <code>null</code>\n      */\n-    public static <K,V> Map<K,V> emptyIfNull(Map<K,V> map) {\n+    public static <K,V> Map<K,V> emptyIfNull(final Map<K,V> map) {\n         return map == null ? Collections.<K,V>emptyMap() : map;\n     }\n     \n      * @return true if empty or null\n      * @since 3.2\n      */\n-    public static boolean isEmpty(Map<?,?> map) {\n+    public static boolean isEmpty(final Map<?,?> map) {\n         return map == null || map.isEmpty();\n     }\n \n      * @return true if non-null and non-empty\n      * @since 3.2\n      */\n-    public static boolean isNotEmpty(Map<?,?> map) {\n+    public static boolean isNotEmpty(final Map<?,?> map) {\n         return !MapUtils.isEmpty(map);\n     }\n \n      * @param map  the map to synchronize, must not be null\n      * @return a synchronized map backed by the given map\n      */\n-    public static <K, V> Map<K, V> synchronizedMap(Map<K, V> map) {\n+    public static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n         return Collections.synchronizedMap(map);\n     }\n \n      * @return an unmodifiable map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      */\n-    public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n+    public static <K, V> Map<K, V> unmodifiableMap(final Map<K, V> map) {\n         return UnmodifiableMap.unmodifiableMap(map);\n     }\n \n      * @return a predicated map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static <K, V> IterableMap<K, V> predicatedMap(Map<K, V> map, Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n+    public static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n         return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n     }\n \n      * @return a transformed map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static <K, V> IterableMap<K, V> transformedMap(Map<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n+    public static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n         return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n     }\n \n      * @return a fixed-size map backed by that map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static <K, V> IterableMap<K, V> fixedSizeMap(Map<K, V> map) {\n+    public static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n         return FixedSizeMap.fixedSizeMap(map);\n     }\n \n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the Map or Factory is null\n      */\n-    public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Factory<? extends V> factory) {\n+    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n         return LazyMap.lazyMap(map, factory);\n     }\n \n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n-    public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Transformer<? super K, ? extends V> transformerFactory) {\n+    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n         return LazyMap.lazyMap(map, transformerFactory);\n     }\n \n      * @return an ordered map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static <K, V> OrderedMap<K, V> orderedMap(Map<K, V> map) {\n+    public static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n         return ListOrderedMap.listOrderedMap(map);\n     }\n \n      * @see MultiValueMap\n      * @since 3.2\n      */\n-    public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n         return MultiValueMap.<K, V>multiValueMap(map);\n     }\n \n      * @see MultiValueMap\n      * @since 3.2\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Class<C> collectionClass) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Class<C> collectionClass) {\n         return MultiValueMap.multiValueMap(map, collectionClass);\n     }\n \n      * @see MultiValueMap\n      * @since 3.2\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Factory<C> collectionFactory) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Factory<C> collectionFactory) {\n         return MultiValueMap.multiValueMap(map, collectionFactory);\n     }\n \n      * @return a synchronized map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      */\n-    public static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> map) {\n+    public static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n         return Collections.synchronizedSortedMap(map);\n     }\n \n      * @return an unmodifiable map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      */\n-    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, V> map) {\n         return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n     }\n \n      * @return a predicated map backed by the given map\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n-    public static <K, V> SortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n-            Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n+    public static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n+            final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n         return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n     }\n \n      * @return a transformed map backed by the given map\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n-    public static <K, V> SortedMap<K, V> transformedSortedMap(SortedMap<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n+    public static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n         return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n     }\n \n      * @return a fixed-size map backed by that map\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n-    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(SortedMap<K, V> map) {\n+    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n         return FixedSizeSortedMap.fixedSizeSortedMap(map);\n     }\n \n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the SortedMap or Factory is null\n      */\n-    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n-            Factory<? extends V> factory) {\n+    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n+            final Factory<? extends V> factory) {\n         return LazySortedMap.lazySortedMap(map, factory);\n     }\n \n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n-    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n-            Transformer<? super K, ? extends V> transformerFactory) {\n+    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends V> transformerFactory) {\n         return LazySortedMap.lazySortedMap(map, transformerFactory);\n     }\n \n      * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n      * @throws NullPointerException if the map, collection or transformer are null\n      */\n-    public static <K, V> void populateMap(Map<K, V> map, Collection<? extends V> collection, Transformer<V, K> keyTransformer) {\n+    public static <K, V> void populateMap(final Map<K, V> map, final Collection<? extends V> collection, final Transformer<V, K> keyTransformer) {\n         populateMap(map, collection, keyTransformer, TransformerUtils.<V>nopTransformer());\n     }\n \n      * @param valueTransformer the <code>Transformer</code> used to transform the collection value into a value\n      * @throws NullPointerException if the map, collection or transformers are null\n      */\n-    public static <K, V, E> void populateMap(Map<K, V> map, Collection<? extends E> collection, \n-            Transformer<E, K> keyTransformer, \n-            Transformer<E, V> valueTransformer) {\n-        Iterator<? extends E> iter = collection.iterator();\n+    public static <K, V, E> void populateMap(final Map<K, V> map, final Collection<? extends E> collection, \n+            final Transformer<E, K> keyTransformer, \n+            final Transformer<E, V> valueTransformer) {\n+        final Iterator<? extends E> iter = collection.iterator();\n         while (iter.hasNext()) {\n-            E temp = iter.next();\n+            final E temp = iter.next();\n             map.put(keyTransformer.transform(temp), valueTransformer.transform(temp));\n         }\n     }\n      * @return IterableMap<K, V>\n      * @since 4.0\n      */\n-    public static <K, V> IterableMap<K, V> iterableMap(Map<K, V> map) {\n+    public static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n      * @return {@link IterableSortedMap}<K, V>\n      * @since 4.0\n      */\n-    public static <K, V> IterableSortedMap<K, V> iterableSortedMap(SortedMap<K, V> sortedMap) {\n+    public static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n         if (sortedMap == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/PredicateUtils.java\n+++ b/src/main/java/org/apache/commons/collections/PredicateUtils.java\n      * @deprecated use {@link EqualPredicate#equalPredicate(Object)} instead.\n      */\n     @Deprecated\n-    public static <T> Predicate<T> equalPredicate(T value) {\n+    public static <T> Predicate<T> equalPredicate(final T value) {\n         return EqualPredicate.equalPredicate(value);\n     }\n \n      * @param value  the value to compare against\n      * @return the predicate\n      */\n-    public static <T> Predicate<T> identityPredicate(T value) {\n+    public static <T> Predicate<T> identityPredicate(final T value) {\n         return IdentityPredicate.<T>identityPredicate(value);\n     }\n \n      * @return the predicate\n      * @throws IllegalArgumentException if the class is null\n      */\n-    public static Predicate<Object> instanceofPredicate(Class<?> type) {\n+    public static Predicate<Object> instanceofPredicate(final Class<?> type) {\n         return InstanceofPredicate.instanceOfPredicate(type);\n     }\n \n      * @return the predicate\n      * @throws IllegalArgumentException if the methodName is null.\n      */\n-    public static <T> Predicate<T> invokerPredicate(String methodName){\n+    public static <T> Predicate<T> invokerPredicate(final String methodName){\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n     }\n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n-    public static <T> Predicate<T> invokerPredicate(String methodName, Class<?>[] paramTypes, Object[] args){\n+    public static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes, final Object[] args){\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n     }\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> andPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         return AndPredicate.<T>andPredicate(predicate1, predicate2);\n     }\n \n      * @deprecated use {@link AllPredicate#allPredicate(Predicate...)} instead.\n      */\n     @Deprecated\n-    public static <T> Predicate<T> allPredicate(Predicate<? super T>... predicates) {\n+    public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n         return AllPredicate.allPredicate(predicates);\n     }\n \n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      */\n-    public static <T> Predicate<T> allPredicate(Collection<? extends Predicate<T>> predicates) {\n+    public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<T>> predicates) {\n         return AllPredicate.allPredicate(predicates);\n     }\n \n      * @return the <code>or</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> orPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         return OrPredicate.<T>orPredicate(predicate1, predicate2);\n     }\n \n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> anyPredicate(Predicate<? super T>... predicates) {\n+    public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n         return AnyPredicate.anyPredicate(predicates);\n     }\n \n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      */\n-    public static <T> Predicate<T> anyPredicate(Collection<? extends Predicate<T>> predicates) {\n+    public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<T>> predicates) {\n         return AnyPredicate.anyPredicate(predicates);\n     }\n \n      * @return the <code>either</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> eitherPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         Predicate<T> onePredicate = PredicateUtils.<T>onePredicate(predicate1, predicate2);\n         return onePredicate;\n     }\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> onePredicate(Predicate<? super T>... predicates) {\n+    public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n         return OnePredicate.onePredicate(predicates);\n     }\n \n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      */\n-    public static <T> Predicate<T> onePredicate(Collection<Predicate<T>> predicates) {\n+    public static <T> Predicate<T> onePredicate(final Collection<Predicate<T>> predicates) {\n         return OnePredicate.onePredicate(predicates);\n     }\n \n      * @return the <code>neither</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> neitherPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         @SuppressWarnings(\"unchecked\")\n+        final\n         Predicate<T> nonePredicate = PredicateUtils.<T>nonePredicate(predicate1, predicate2);\n         return nonePredicate;\n     }\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> nonePredicate(Predicate<? super T>... predicates) {\n+    public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n         return NonePredicate.nonePredicate(predicates);\n     }\n \n      * @throws IllegalArgumentException if the predicates collection is null\n      * @throws IllegalArgumentException if any predicate in the collection is null\n      */\n-    public static <T> Predicate<T> nonePredicate(Collection<? extends Predicate<T>> predicates) {\n+    public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<T>> predicates) {\n         return NonePredicate.nonePredicate(predicates);\n     }\n \n      * @return the <code>not</code> predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> notPredicate(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n         return NotPredicate.notPredicate(predicate);\n     }\n \n      * @return the transformer wrapping predicate\n      * @throws IllegalArgumentException if the transformer is null\n      */\n-    public static <T> Predicate<T> asPredicate(Transformer<? super T, Boolean> transformer) {\n+    public static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n         return TransformerPredicate.transformerPredicate(transformer);\n     }\n \n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null.\n      */\n-    public static <T> Predicate<T> nullIsExceptionPredicate(Predicate<? super T> predicate){\n+    public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate){\n         return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n     }\n \n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null.\n      */\n-    public static <T> Predicate<T> nullIsFalsePredicate(Predicate<? super T> predicate){\n+    public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate){\n         return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n     }\n \n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null.\n      */\n-    public static <T> Predicate<T> nullIsTruePredicate(Predicate<? super T> predicate){\n+    public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate){\n         return NullIsTruePredicate.nullIsTruePredicate(predicate);\n     }\n \n      * @since 3.1\n      */\n     public static <T> Predicate<T> transformedPredicate(\n-            Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n+            final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n         return TransformedPredicate.<T>transformedPredicate(transformer, predicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/SetUtils.java\n+++ b/src/main/java/org/apache/commons/collections/SetUtils.java\n      * @param set the set, possibly <code>null</code>\n      * @return an empty set if the argument is <code>null</code>\n      */\n-    public static <T> Set<T> emptyIfNull(Set<T> set) {\n+    public static <T> Set<T> emptyIfNull(final Set<T> set) {\n         return set == null ? Collections.<T>emptySet() : set;\n     }\n     \n         }\n \n         int hashCode = 0;\n-        for (T obj : set) {\n+        for (final T obj : set) {\n             if (obj != null) {\n                 hashCode += obj.hashCode();\n             }\n      * @return a synchronized set backed by the given set\n      * @throws IllegalArgumentException  if the set is null\n      */\n-    public static <E> Set<E> synchronizedSet(Set<E> set) {\n+    public static <E> Set<E> synchronizedSet(final Set<E> set) {\n         return SynchronizedSet.synchronizedSet(set);\n     }\n \n      * @return an unmodifiable set backed by the given set\n      * @throws IllegalArgumentException  if the set is null\n      */\n-    public static <E> Set<E> unmodifiableSet(Set<E> set) {\n+    public static <E> Set<E> unmodifiableSet(final Set<E> set) {\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n      * @return a predicated set backed by the given set\n      * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n-    public static <E> Set<E> predicatedSet(Set<E> set, Predicate<? super E> predicate) {\n+    public static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n         return PredicatedSet.predicatedSet(set, predicate);\n     }\n \n      * @return a transformed set backed by the given set\n      * @throws IllegalArgumentException  if the Set or Transformer is null\n      */\n-    public static <E> Set<E> transformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n         return TransformedSet.transformingSet(set, transformer);\n     }\n     \n      * @return an ordered set backed by the given set\n      * @throws IllegalArgumentException  if the Set is null\n      */\n-    public static <E> Set<E> orderedSet(Set<E> set) {\n+    public static <E> Set<E> orderedSet(final Set<E> set) {\n         return ListOrderedSet.listOrderedSet(set);\n     }\n     \n      * @return a synchronized set backed by the given set\n      * @throws IllegalArgumentException  if the set is null\n      */\n-    public static <E> SortedSet<E> synchronizedSortedSet(SortedSet<E> set) {\n+    public static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n         return SynchronizedSortedSet.synchronizedSortedSet(set);\n     }\n \n      * @return an unmodifiable set backed by the given set\n      * @throws IllegalArgumentException  if the set is null\n      */\n-    public static <E> SortedSet<E> unmodifiableSortedSet(SortedSet<E> set) {\n+    public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n         return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n     }\n \n      * @return a predicated sorted set backed by the given sorted set\n      * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n-    public static <E> SortedSet<E> predicatedSortedSet(SortedSet<E> set, Predicate<? super E> predicate) {\n+    public static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n         return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n     }\n \n      * @return a transformed set backed by the given set\n      * @throws IllegalArgumentException  if the Set or Transformer is null\n      */\n-    public static <E> SortedSet<E> transformedSortedSet(SortedSet<E> set,\n-                                                        Transformer<? super E, ? extends E> transformer) {\n+    public static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set,\n+                                                        final Transformer<? super E, ? extends E> transformer) {\n         return TransformedSortedSet.transformingSortedSet(set, transformer);\n     }\n     \n--- a/src/main/java/org/apache/commons/collections/SplitMapUtils.java\n+++ b/src/main/java/org/apache/commons/collections/SplitMapUtils.java\n     private static class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n         private final Get<K, V> get;\n \n-        private WrappedGet(Get<K, V> get) {\n+        private WrappedGet(final Get<K, V> get) {\n             this.get = get;\n         }\n \n             throw new UnsupportedOperationException();\n         }\n \n-        public boolean containsKey(Object key) {\n+        public boolean containsKey(final Object key) {\n             return get.containsKey(key);\n         }\n \n-        public boolean containsValue(Object value) {\n+        public boolean containsValue(final Object value) {\n             return get.containsValue(value);\n         }\n \n         }\n \n         @Override\n-        public boolean equals(Object arg0) {\n+        public boolean equals(final Object arg0) {\n             if (arg0 == this) {\n                 return true;\n             }\n             return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(this.get);\n         }\n \n-        public V get(Object key) {\n+        public V get(final Object key) {\n             return get.get(key);\n         }\n \n             return UnmodifiableSet.unmodifiableSet(get.keySet());\n         }\n \n-        public V put(K key, V value) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public void putAll(Map<? extends K, ? extends V> t) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public V remove(Object key) {\n+        public V put(final K key, final V value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void putAll(final Map<? extends K, ? extends V> t) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V remove(final Object key) {\n             return get.remove(key);\n         }\n \n     private static class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n         private final Put<K, V> put;\n \n-        private WrappedPut(Put<K, V> put) {\n+        private WrappedPut(final Put<K, V> put) {\n             this.put = put;\n         }\n \n             put.clear();\n         }\n \n-        public boolean containsKey(Object key) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public boolean containsValue(Object value) {\n+        public boolean containsKey(final Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsValue(final Object value) {\n             throw new UnsupportedOperationException();\n         }\n \n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n             return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(this.put);\n         }\n \n-        public V get(Object key) {\n+        public V get(final Object key) {\n             throw new UnsupportedOperationException();\n         }\n \n         }\n \n         @SuppressWarnings(\"unchecked\")\n-        public V put(K key, V value) {\n+        public V put(final K key, final V value) {\n             return (V) put.put(key, value);\n         }\n \n-        public void putAll(Map<? extends K, ? extends V> t) {\n+        public void putAll(final Map<? extends K, ? extends V> t) {\n             put.putAll(t);\n         }\n \n-        public V remove(Object key) {\n+        public V remove(final Object key) {\n             throw new UnsupportedOperationException();\n         }\n \n      * @return {@link IterableMap}\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <K, V> IterableMap<K, V> readableMap(Get<K, V> get) {\n+    public static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n         if (get == null) {\n             throw new IllegalArgumentException(\"Get must not be null\");\n         }\n      * @return {@link Map}\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <K, V> Map<K, V> writableMap(Put<K, V> put) {\n+    public static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n         if (put == null) {\n             throw new IllegalArgumentException(\"Put must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/TransformerUtils.java\n+++ b/src/main/java/org/apache/commons/collections/TransformerUtils.java\n      * @param constantToReturn  the constant object to return each time in the transformer\n      * @return the transformer.\n      */\n-    public static <I, O> Transformer<I, O> constantTransformer(O constantToReturn) {\n+    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n         return ConstantTransformer.constantTransformer(constantToReturn);\n     }\n \n      * @return the transformer\n      * @throws IllegalArgumentException if the closure is null\n      */\n-    public static <T> Transformer<T, T> asTransformer(Closure<? super T> closure) {\n+    public static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n         return ClosureTransformer.closureTransformer(closure);\n     }\n \n      * @return the transformer\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Transformer<T, Boolean> asTransformer(Predicate<? super T> predicate) {\n+    public static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n         return PredicateTransformer.predicateTransformer(predicate);\n     }\n \n      * @return the transformer\n      * @throws IllegalArgumentException if the factory is null\n      */\n-    public static <I, O> Transformer<I, O> asTransformer(Factory<? extends O> factory) {\n+    public static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n         return FactoryTransformer.factoryTransformer(factory);\n     }\n \n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <T> Transformer<T, T> chainedTransformer(\n-            Transformer<? super T, ? extends T> transformer1,\n-            Transformer<? super T, ? extends T> transformer2) {\n+            final Transformer<? super T, ? extends T> transformer1,\n+            final Transformer<? super T, ? extends T> transformer2) {\n         return ChainedTransformer.<T> chainedTransformer(transformer1, transformer2);\n     }\n \n      * @throws IllegalArgumentException if the transformers array is null\n      * @throws IllegalArgumentException if any transformer in the array is null\n      */\n-    public static <T> Transformer<T, T> chainedTransformer(Transformer<? super T, ? extends T>[] transformers) {\n+    public static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>[] transformers) {\n         return ChainedTransformer.chainedTransformer(transformers);\n     }\n \n      * @throws IllegalArgumentException if any transformer in the collection is null\n      */\n     public static <T> Transformer<T, T> chainedTransformer(\n-            Collection<? extends Transformer<T, T>> transformers) {\n+            final Collection<? extends Transformer<T, T>> transformers) {\n         return ChainedTransformer.chainedTransformer(transformers);\n     }\n \n      * @throws IllegalArgumentException if either transformer is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I> predicate,\n-            Transformer<? super I, ? extends O> trueTransformer,\n-            Transformer<? super I, ? extends O> falseTransformer) {\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate,\n+            final Transformer<? super I, ? extends O> trueTransformer,\n+            final Transformer<? super I, ? extends O> falseTransformer) {\n         return SwitchTransformer.switchTransformer(new Predicate[] { predicate },\n                 new Transformer[] { trueTransformer }, falseTransformer);\n     }\n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n-            Transformer<? super I, ? extends O>[] transformers) {\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers) {\n         return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, null);\n     }\n \n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n-            Transformer<? super I, ? extends O>[] transformers,\n-            Transformer<? super I, ? extends O> defaultTransformer) {\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers,\n+            final Transformer<? super I, ? extends O> defaultTransformer) {\n         return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, defaultTransformer);\n     }\n \n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     public static <I, O> Transformer<I, O> switchTransformer(\n-            Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n+            final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n         return SwitchTransformer.<I, O>switchTransformer(predicatesAndTransformers);\n     }\n \n      * @throws IllegalArgumentException if any transformer in the map is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> switchMapTransformer(Map<I, Transformer<I, O>> objectsAndTransformers) {\n+    public static <I, O> Transformer<I, O> switchMapTransformer(final Map<I, Transformer<I, O>> objectsAndTransformers) {\n         Transformer<? super I, ? extends O>[] trs = null;\n         Predicate<I>[] preds = null;\n         if (objectsAndTransformers == null) {\n             throw new IllegalArgumentException(\"The object and transformer map must not be null\");\n         }\n-        Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n-        int size = objectsAndTransformers.size();\n+        final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n+        final int size = objectsAndTransformers.size();\n         trs = new Transformer[size];\n         preds = new Predicate[size];\n         int i = 0;\n-        for (Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n+        for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n             preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n             trs[i++] = entry.getValue();\n         }\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n     public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(\n-            Class<?>[] paramTypes, Object[] args) {\n+            final Class<?>[] paramTypes, final Object[] args) {\n         return InstantiateTransformer.<T>instantiateTransformer(paramTypes, args);\n     }\n \n      * @param map  the map to use to transform the objects\n      * @return the transformer, or a {@link ConstantTransformer#NULL_INSTANCE} if the {@code map} is {@code null}\n      */\n-    public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {\n+    public static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n         return MapTransformer.mapTransformer(map);\n     }\n \n      * @return the transformer\n      * @throws IllegalArgumentException if the methodName is null.\n      */\n-    public static <I, O> Transformer<I, O> invokerTransformer(String methodName){\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName){\n         return InvokerTransformer.<I, O>invokerTransformer(methodName, null, null);\n     }\n \n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n-    public static <I, O> Transformer<I, O> invokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args){\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args){\n         return InvokerTransformer.<I, O>invokerTransformer(methodName, paramTypes, args);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/TrieUtils.java\n+++ b/src/main/java/org/apache/commons/collections/TrieUtils.java\n      * \n      * @see Collections#synchronizedMap(Map)\n      */\n-    public static <K, V> Trie<K, V> synchronizedTrie(Trie<K, V> trie) {\n+    public static <K, V> Trie<K, V> synchronizedTrie(final Trie<K, V> trie) {\n         return SynchronizedTrie.synchronizedTrie(trie);\n     }\n     \n      * \n      * @see Collections#unmodifiableMap(Map)\n      */\n-    public static <K, V> Trie<K, V> unmodifiableTrie(Trie<K, V> trie) {\n+    public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, V> trie) {\n         return UnmodifiableTrie.unmodifiableTrie(trie);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/AbstractBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bag/AbstractBagDecorator.java\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected AbstractBagDecorator(Bag<E> bag) {\n+    protected AbstractBagDecorator(final Bag<E> bag) {\n         super(bag);\n     }\n \n \n     //-----------------------------------------------------------------------\n     \n-    public int getCount(Object object) {\n+    public int getCount(final Object object) {\n         return decorated().getCount(object);\n     }\n \n-    public boolean add(E object, int count) {\n+    public boolean add(final E object, final int count) {\n         return decorated().add(object, count);\n     }\n \n-    public boolean remove(Object object, int count) {\n+    public boolean remove(final Object object, final int count) {\n         return decorated().remove(object, count);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/AbstractMapBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/AbstractMapBag.java\n      * \n      * @param map the map to assign\n      */\n-    protected AbstractMapBag(Map<E, MutableInteger> map) {\n+    protected AbstractMapBag(final Map<E, MutableInteger> map) {\n         super();\n         this.map = map;\n     }\n      * @param object the object to search for\n      * @return the number of occurrences of the object, zero if not found\n      */\n-    public int getCount(Object object) {\n-        MutableInteger count = map.get(object);\n+    public int getCount(final Object object) {\n+        final MutableInteger count = map.get(object);\n         if (count != null) {\n             return count.value;\n         }\n      * @param object the object to search for\n      * @return true if the bag contains the given element\n      */\n-    public boolean contains(Object object) {\n+    public boolean contains(final Object object) {\n         return map.containsKey(object);\n     }\n \n      * @param coll the collection to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n-    public boolean containsAll(Collection<?> coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n         if (coll instanceof Bag) {\n             return containsAll((Bag<?>) coll);\n         }\n      * @param other the bag to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n-    boolean containsAll(Bag<?> other) {\n+    boolean containsAll(final Bag<?> other) {\n         boolean result = true;\n-        Iterator<?> it = other.uniqueSet().iterator();\n+        final Iterator<?> it = other.uniqueSet().iterator();\n         while (it.hasNext()) {\n-            Object current = it.next();\n-            boolean contains = getCount(current) >= other.getCount(current);\n+            final Object current = it.next();\n+            final boolean contains = getCount(current) >= other.getCount(current);\n             result = result && contains;\n         }\n         return result;\n          * \n          * @param parent the parent bag\n          */\n-        public BagIterator(AbstractMapBag<E> parent) {\n+        public BagIterator(final AbstractMapBag<E> parent) {\n             this.parent = parent;\n             this.entryIterator = parent.map.entrySet().iterator();\n             this.current = null;\n             if (canRemove == false) {\n                 throw new IllegalStateException();\n             }\n-            MutableInteger mut = current.getValue();\n+            final MutableInteger mut = current.getValue();\n             if (mut.value > 1) {\n                 mut.value--;\n             } else {\n      * @return <code>true</code> if the object was not already in the\n      * <code>uniqueSet</code>\n      */\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         return add(object, 1);\n     }\n \n      * @return <code>true</code> if the object was not already in the\n      * <code>uniqueSet</code>\n      */\n-    public boolean add(E object, int nCopies) {\n+    public boolean add(final E object, final int nCopies) {\n         modCount++;\n         if (nCopies > 0) {\n-            MutableInteger mut = map.get(object);\n+            final MutableInteger mut = map.get(object);\n             size += nCopies;\n             if (mut == null) {\n                 map.put(object, new MutableInteger(nCopies));\n      * @param coll the collection to add\n      * @return <code>true</code> if this call changed the bag\n      */\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         boolean changed = false;\n-        Iterator<? extends E> i = coll.iterator();\n+        final Iterator<? extends E> i = coll.iterator();\n         while (i.hasNext()) {\n-            boolean added = add(i.next());\n+            final boolean added = add(i.next());\n             changed = changed || added;\n         }\n         return changed;\n      * @param object the object to remove\n      * @return true if the bag changed\n      */\n-    public boolean remove(Object object) {\n-        MutableInteger mut = map.get(object);\n+    public boolean remove(final Object object) {\n+        final MutableInteger mut = map.get(object);\n         if (mut == null) {\n             return false;\n         }\n      * @param nCopies the number of copies to remove\n      * @return true if the bag changed\n      */\n-    public boolean remove(Object object, int nCopies) {\n-        MutableInteger mut = map.get(object);\n+    public boolean remove(final Object object, final int nCopies) {\n+        final MutableInteger mut = map.get(object);\n         if (mut == null) {\n             return false;\n         }\n      * @param coll the collection to use\n      * @return true if the bag changed\n      */\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         boolean result = false;\n         if (coll != null) {\n-            Iterator<?> i = coll.iterator();\n+            final Iterator<?> i = coll.iterator();\n             while (i.hasNext()) {\n-                boolean changed = remove(i.next(), 1);\n+                final boolean changed = remove(i.next(), 1);\n                 result = result || changed;\n             }\n         }\n      * @param coll the collection to retain\n      * @return true if this call changed the collection\n      */\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         if (coll instanceof Bag) {\n             return retainAll((Bag<?>) coll);\n         }\n      * @param other the bag to retain\n      * @return <code>true</code> if this call changed the collection\n      */\n-    boolean retainAll(Bag<?> other) {\n+    boolean retainAll(final Bag<?> other) {\n         boolean result = false;\n-        Bag<E> excess = new HashBag<E>();\n-        Iterator<E> i = uniqueSet().iterator();\n+        final Bag<E> excess = new HashBag<E>();\n+        final Iterator<E> i = uniqueSet().iterator();\n         while (i.hasNext()) {\n-            E current = i.next();\n-            int myCount = getCount(current);\n-            int otherCount = other.getCount(current);\n+            final E current = i.next();\n+            final int myCount = getCount(current);\n+            final int otherCount = other.getCount(current);\n             if (1 <= otherCount && otherCount <= myCount) {\n                 excess.add(current, myCount - otherCount);\n             } else {\n          * Constructor.\n          * @param value the initial value\n          */\n-        MutableInteger(int value) {\n+        MutableInteger(final int value) {\n             this.value = value;\n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj instanceof MutableInteger == false) {\n                 return false;\n             }\n      * @return an array of all of this bag's elements\n      */\n     public Object[] toArray() {\n-        Object[] result = new Object[size()];\n+        final Object[] result = new Object[size()];\n         int i = 0;\n-        Iterator<E> it = map.keySet().iterator();\n+        final Iterator<E> it = map.keySet().iterator();\n         while (it.hasNext()) {\n-            E current = it.next();\n+            final E current = it.next();\n             for (int index = getCount(current); index > 0; index--) {\n                 result[i++] = current;\n             }\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T[] toArray(T[] array) {\n-        int size = size();\n+        final int size = size();\n         if (array.length < size) {\n             array = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n         }\n \n         int i = 0;\n-        Iterator<E> it = map.keySet().iterator();\n+        final Iterator<E> it = map.keySet().iterator();\n         while (it.hasNext()) {\n-            E current = it.next();\n+            final E current = it.next();\n             for (int index = getCount(current); index > 0; index--) {\n                 array[i++] = (T) current;\n             }\n      * @param out the output stream\n      * @throws IOException any of the usual I/O related exceptions\n      */\n-    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n         out.writeInt(map.size());\n-        for (Entry<E, MutableInteger> entry : map.entrySet()) {\n+        for (final Entry<E, MutableInteger> entry : map.entrySet()) {\n             out.writeObject(entry.getKey());\n             out.writeInt(entry.getValue().value);\n         }\n      * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n      * @throws ClassCastException if the stream does not contain the correct objects\n      */\n-    protected void doReadObject(Map<E, MutableInteger> map, ObjectInputStream in)\n+    protected void doReadObject(final Map<E, MutableInteger> map, final ObjectInputStream in)\n             throws IOException, ClassNotFoundException {\n         this.map = map;\n-        int entrySize = in.readInt();\n+        final int entrySize = in.readInt();\n         for (int i = 0; i < entrySize; i++) {\n             @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n+            final\n             E obj = (E) in.readObject();\n-            int count = in.readInt();\n+            final int count = in.readInt();\n             map.put(obj, new MutableInteger(count));\n             size += count;\n         }\n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (object == this) {\n             return true;\n         }\n         if (object instanceof Bag == false) {\n             return false;\n         }\n-        Bag<?> other = (Bag<?>) object;\n+        final Bag<?> other = (Bag<?>) object;\n         if (other.size() != size()) {\n             return false;\n         }\n-        for (E element : map.keySet()) {\n+        for (final E element : map.keySet()) {\n             if (other.getCount(element) != getCount(element)) {\n                 return false;\n             }\n     @Override\n     public int hashCode() {\n         int total = 0;\n-        for (Entry<E, MutableInteger> entry : map.entrySet()) {\n-            E element = entry.getKey();\n-            MutableInteger count = entry.getValue();\n+        for (final Entry<E, MutableInteger> entry : map.entrySet()) {\n+            final E element = entry.getKey();\n+            final MutableInteger count = entry.getValue();\n             total += (element == null ? 0 : element.hashCode()) ^ count.value;\n         }\n         return total;\n         if (size() == 0) {\n             return \"[]\";\n         }\n-        StringBuilder buf = new StringBuilder();\n+        final StringBuilder buf = new StringBuilder();\n         buf.append('[');\n-        Iterator<E> it = uniqueSet().iterator();\n+        final Iterator<E> it = uniqueSet().iterator();\n         while (it.hasNext()) {\n-            Object current = it.next();\n-            int count = getCount(current);\n+            final Object current = it.next();\n+            final int count = getCount(current);\n             buf.append(count);\n             buf.append(':');\n             buf.append(current);\n--- a/src/main/java/org/apache/commons/collections/bag/AbstractSortedBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bag/AbstractSortedBagDecorator.java\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected AbstractSortedBagDecorator(SortedBag<E> bag) {\n+    protected AbstractSortedBagDecorator(final SortedBag<E> bag) {\n         super(bag);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/HashBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/HashBag.java\n      * \n      * @param coll  a collection to copy into this bag\n      */\n-    public HashBag(Collection<? extends E> coll) {\n+    public HashBag(final Collection<? extends E> coll) {\n         this();\n         addAll(coll);\n     }\n     /**\n      * Write the bag out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         super.doWriteObject(out);\n     }\n     /**\n      * Read the bag in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         super.doReadObject(new HashMap<E, MutableInteger>(), in);\n     }\n--- a/src/main/java/org/apache/commons/collections/bag/PredicatedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/PredicatedBag.java\n      * @throws IllegalArgumentException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n-    public static <E> PredicatedBag<E> predicatedBag(Bag<E> bag, Predicate<? super E> predicate) {\n+    public static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n         return new PredicatedBag<E>(bag, predicate);\n     }\n \n      * @throws IllegalArgumentException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n-    protected PredicatedBag(Bag<E> bag, Predicate<? super E> predicate) {\n+    protected PredicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n         super(bag, predicate);\n     }\n \n     \n     //-----------------------------------------------------------------------\n     \n-    public boolean add(E object, int count) {\n+    public boolean add(final E object, final int count) {\n         validate(object);\n         return decorated().add(object, count);\n     }\n \n-    public boolean remove(Object object, int count) {\n+    public boolean remove(final Object object, final int count) {\n         return decorated().remove(object, count);\n     }\n \n         return decorated().uniqueSet();\n     }\n \n-    public int getCount(Object object) {\n+    public int getCount(final Object object) {\n         return decorated().getCount(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/PredicatedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/PredicatedSortedBag.java\n      * @throws IllegalArgumentException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n-    public static <E> PredicatedSortedBag<E> predicatedSortedBag(SortedBag<E> bag, Predicate<? super E> predicate) {\n+    public static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n         return new PredicatedSortedBag<E>(bag, predicate);\n     }\n \n      * @throws IllegalArgumentException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n-    protected PredicatedSortedBag(SortedBag<E> bag, Predicate<? super E> predicate) {\n+    protected PredicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n         super(bag, predicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/SynchronizedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/SynchronizedBag.java\n      * @return a new synchronized Bag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> SynchronizedBag<E> synchronizedBag(Bag<E> bag) {\n+    public static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n         return new SynchronizedBag<E>(bag);\n     }\n     \n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n-    protected SynchronizedBag(Bag<E> bag) {\n+    protected SynchronizedBag(final Bag<E> bag) {\n         super(bag);\n     }\n \n      * @param lock  the lock to use, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n-    protected SynchronizedBag(Bag<E> bag, Object lock) {\n+    protected SynchronizedBag(final Bag<E> bag, final Object lock) {\n         super(bag, lock);\n     }\n \n     \n     //-----------------------------------------------------------------------\n     \n-    public boolean add(E object, int count) {\n+    public boolean add(final E object, final int count) {\n         synchronized (lock) {\n             return getBag().add(object, count);\n         }\n     }\n \n-    public boolean remove(Object object, int count) {\n+    public boolean remove(final Object object, final int count) {\n         synchronized (lock) {\n             return getBag().remove(object, count);\n         }\n \n     public Set<E> uniqueSet() {\n         synchronized (lock) {\n-            Set<E> set = getBag().uniqueSet();\n+            final Set<E> set = getBag().uniqueSet();\n             return new SynchronizedBagSet(set, lock);\n         }\n     }\n \n-    public int getCount(Object object) {\n+    public int getCount(final Object object) {\n         synchronized (lock) {\n             return getBag().getCount(object);\n         }\n          * @param set  the set to decorate\n          * @param lock  the lock to use, shared with the bag\n          */\n-        SynchronizedBagSet(Set<E> set, Object lock) {\n+        SynchronizedBagSet(final Set<E> set, final Object lock) {\n             super(set, lock);\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/bag/SynchronizedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/SynchronizedSortedBag.java\n      * @return a new synchronized SortedBag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> SynchronizedSortedBag<E> synchronizedSortedBag(SortedBag<E> bag) {\n+    public static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n         return new SynchronizedSortedBag<E>(bag);\n     }\n     \n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n-    protected SynchronizedSortedBag(SortedBag<E> bag) {\n+    protected SynchronizedSortedBag(final SortedBag<E> bag) {\n         super(bag);\n     }\n \n      * @param lock  the lock to use, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n-    protected SynchronizedSortedBag(Bag<E> bag, Object lock) {\n+    protected SynchronizedSortedBag(final Bag<E> bag, final Object lock) {\n         super(bag, lock);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/TransformedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/TransformedBag.java\n      * @return a new transformed Bag\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    public static <E> Bag<E> transformingBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedBag<E>(bag, transformer);\n     }\n     \n      * @throws IllegalArgumentException if bag or transformer is null\n      * @since 3.3\n      */\n-    public static <E> Bag<E> transformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n-        TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n+    public static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n         if (transformer != null && bag != null && bag.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // Bag is of type E\n+            final\n             E[] values = (E[]) bag.toArray();\n             bag.clear();\n-            for (E value : values) {\n+            for (final E value : values) {\n                 decorated.decorated().add(transformer.transform(value));\n             }\n         }\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    protected TransformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    protected TransformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         super(bag, transformer);\n     }\n \n \n     //-----------------------------------------------------------------------\n     \n-    public int getCount(Object object) {\n+    public int getCount(final Object object) {\n         return getBag().getCount(object);\n     }\n \n-    public boolean remove(Object object, int nCopies) {\n+    public boolean remove(final Object object, final int nCopies) {\n         return getBag().remove(object, nCopies);\n     }\n \n     //-----------------------------------------------------------------------\n     \n-    public boolean add(E object, int nCopies) {\n+    public boolean add(final E object, final int nCopies) {\n         return getBag().add(transform(object), nCopies);\n     }\n \n     public Set<E> uniqueSet() {\n-        Set<E> set = getBag().uniqueSet();\n+        final Set<E> set = getBag().uniqueSet();\n         return TransformedSet.<E>transformingSet(set, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n      * @return a new transformed SortedBag\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    public static <E> TransformedSortedBag<E> transformingSortedBag(SortedBag<E> bag,\n-                                                                    Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n+                                                                    final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSortedBag<E>(bag, transformer);\n     }\n     \n      * @throws IllegalArgumentException if bag or transformer is null\n      * @since 3.3\n      */\n-    public static <E> TransformedSortedBag<E> transformedSortedBag(SortedBag<E> bag,\n-                                                                   Transformer<? super E, ? extends E> transformer) {\n-        TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);\n+    public static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag,\n+                                                                   final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);\n         if (transformer != null && bag != null && bag.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // bag is type E\n+            final\n             E[] values = (E[]) bag.toArray();\n             bag.clear();\n-            for (E value : values) {\n+            for (final E value : values) {\n                 decorated.decorated().add(transformer.transform(value));\n             }\n         }\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n-    protected TransformedSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n+    protected TransformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         super(bag, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/TreeBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/TreeBag.java\n      * \n      * @param comparator the comparator to use\n      */\n-    public TreeBag(Comparator<? super E> comparator) {\n+    public TreeBag(final Comparator<? super E> comparator) {\n         super(new TreeMap<E, MutableInteger>(comparator));\n     }\n \n      * \n      * @param coll the collection to copy into the bag\n      */\n-    public TreeBag(Collection<? extends E> coll) {\n+    public TreeBag(final Collection<? extends E> coll) {\n         this();\n         addAll(coll);\n     }\n      * {@link Comparable} and the {@link TreeBag} is using natural ordering\n      */\n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         if(comparator() == null && !(object instanceof Comparable)) {\n             throw new IllegalArgumentException(\"Objects of type \" + object.getClass() + \" cannot be added to \" + \n                                                \"a naturally ordered TreeBag as it does not implement Comparable\");\n     /**\n      * Write the bag out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(comparator());\n         super.doWriteObject(out);\n     /**\n      * Read the bag in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         @SuppressWarnings(\"unchecked\")  // This will fail at runtime if the stream is incorrect\n+        final\n         Comparator<? super E> comp = (Comparator<? super E>) in.readObject();\n         super.doReadObject(new TreeMap<E, MutableInteger>(comp), in);\n     }\n--- a/src/main/java/org/apache/commons/collections/bag/UnmodifiableBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/UnmodifiableBag.java\n      * @return an unmodifiable Bag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> Bag<E> unmodifiableBag(Bag<E> bag) {\n+    public static <E> Bag<E> unmodifiableBag(final Bag<E> bag) {\n         if (bag instanceof Unmodifiable) {\n             return bag;\n         }\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n-    private UnmodifiableBag(Bag<E> bag) {\n+    private UnmodifiableBag(final Bag<E> bag) {\n         super(bag);\n     }\n \n      * @param out  the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(collection);\n     }\n      * @throws ClassNotFoundException\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         collection = (Collection<E>) in.readObject();\n     }\n     }\n \n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public boolean add(E object, int count) {\n+    public boolean add(final E object, final int count) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean remove(Object object, int count) {\n+    public boolean remove(final Object object, final int count) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public Set<E> uniqueSet() {\n-        Set<E> set = decorated().uniqueSet();\n+        final Set<E> set = decorated().uniqueSet();\n         return UnmodifiableSet.<E> unmodifiableSet(set);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/UnmodifiableSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/UnmodifiableSortedBag.java\n      * @return an unmodifiable SortedBag\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static <E> SortedBag<E> unmodifiableSortedBag(SortedBag<E> bag) {\n+    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n         if (bag instanceof Unmodifiable) {\n             return bag;\n         }\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n-    private UnmodifiableSortedBag(SortedBag<E> bag) {\n+    private UnmodifiableSortedBag(final SortedBag<E> bag) {\n         super(bag);\n     }\n \n      * @param out  the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(collection);\n     }\n      * @throws ClassNotFoundException\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         collection = (Collection<E>) in.readObject();\n     }\n     }\n \n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public boolean add(E object, int count) {\n+    public boolean add(final E object, final int count) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean remove(Object object, int count) {\n+    public boolean remove(final Object object, final int count) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public Set<E> uniqueSet() {\n-        Set<E> set = decorated().uniqueSet();\n+        final Set<E> set = decorated().uniqueSet();\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractBidiMapDecorator.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected AbstractBidiMapDecorator(BidiMap<K, V> map) {\n+    protected AbstractBidiMapDecorator(final BidiMap<K, V> map) {\n         super(map);\n     }\n \n         return decorated().mapIterator();\n     }\n \n-    public K getKey(Object value) {\n+    public K getKey(final Object value) {\n         return decorated().getKey(value);\n     }\n \n-    public K removeValue(Object value) {\n+    public K removeValue(final Object value) {\n         return decorated().removeValue(value);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n      * @param reverseMap  the reverse direction map\n      * @since 3.1\n      */\n-    protected AbstractDualBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap) {\n+    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap) {\n         super();\n         this.normalMap = normalMap;\n         this.reverseMap = reverseMap;\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected AbstractDualBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n+    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap, final BidiMap<V, K> inverseBidiMap) {\n         super();\n         this.normalMap = normalMap;\n         this.reverseMap = reverseMap;\n     // Map delegation\n     //-----------------------------------------------------------------------\n     \n-    public V get(Object key) {\n+    public V get(final Object key) {\n         return normalMap.get(key);\n     }\n \n         return normalMap.isEmpty();\n     }\n \n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         return normalMap.containsKey(key);\n     }\n \n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         return normalMap.equals(obj);\n     }\n \n     // BidiMap changes\n     //-----------------------------------------------------------------------\n     \n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (normalMap.containsKey(key)) {\n             reverseMap.remove(normalMap.get(key));\n         }\n         return obj;\n     }\n \n-    public void putAll(Map<? extends K, ? extends V> map) {\n-        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n \n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         V value = null;\n         if (normalMap.containsKey(key)) {\n             value = normalMap.remove(key);\n         reverseMap.clear();\n     }\n \n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         return reverseMap.containsKey(value);\n     }\n \n         return new BidiMapIterator<K, V>(this);\n     }\n \n-    public K getKey(Object value) {\n+    public K getKey(final Object value) {\n         return reverseMap.get(value);\n     }\n \n-    public K removeValue(Object value) {\n+    public K removeValue(final Object value) {\n         K key = null;\n         if (reverseMap.containsKey(value)) {\n             key = reverseMap.remove(value);\n      * @param iterator  the iterator to decorate\n      * @return the keySet iterator\n      */\n-    protected Iterator<K> createKeySetIterator(Iterator<K> iterator) {\n+    protected Iterator<K> createKeySetIterator(final Iterator<K> iterator) {\n         return new KeySetIterator<K>(iterator, this);\n     }\n \n      * @param iterator  the iterator to decorate\n      * @return the values iterator\n      */\n-    protected Iterator<V> createValuesIterator(Iterator<V> iterator) {\n+    protected Iterator<V> createValuesIterator(final Iterator<V> iterator) {\n         return new ValuesIterator<V>(iterator, this);\n     }\n \n      * @param iterator  the iterator to decorate\n      * @return the entrySet iterator\n      */\n-    protected Iterator<Map.Entry<K, V>> createEntrySetIterator(Iterator<Map.Entry<K, V>> iterator) {\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n         return new EntrySetIterator<K, V>(iterator, this);\n     }\n \n          * @param coll  the collection view being decorated\n          * @param parent  the parent BidiMap\n          */\n-        protected View(Collection<E> coll, AbstractDualBidiMap<K, V> parent) {\n+        protected View(final Collection<E> coll, final AbstractDualBidiMap<K, V> parent) {\n             super(coll);\n             this.parent = parent;\n         }\n \n         @Override\n-        public boolean removeAll(Collection<?> coll) {\n+        public boolean removeAll(final Collection<?> coll) {\n             if (parent.isEmpty() || coll.isEmpty()) {\n                 return false;\n             }\n         }\n \n         @Override\n-        public boolean retainAll(Collection<?> coll) {\n+        public boolean retainAll(final Collection<?> coll) {\n             if (parent.isEmpty()) {\n                 return false;\n             }\n                 return true;\n             }\n             boolean modified = false;\n-            Iterator<E> it = iterator();\n+            final Iterator<E> it = iterator();\n             while (it.hasNext()) {\n                 if (coll.contains(it.next()) == false) {\n                     it.remove();\n          * @param parent  the parent BidiMap\n          */\n         @SuppressWarnings(\"unchecked\")\n-        protected KeySet(AbstractDualBidiMap<K, ?> parent) {\n+        protected KeySet(final AbstractDualBidiMap<K, ?> parent) {\n             super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n         }\n \n         }\n \n         @Override\n-        public boolean contains(Object key) {\n+        public boolean contains(final Object key) {\n             return parent.normalMap.containsKey(key);\n         }\n \n         @Override\n-        public boolean remove(Object key) {\n+        public boolean remove(final Object key) {\n             if (parent.normalMap.containsKey(key)) {\n-                Object value = parent.normalMap.remove(key);\n+                final Object value = parent.normalMap.remove(key);\n                 parent.reverseMap.remove(value);\n                 return true;\n             }\n          * @param iterator  the iterator to decorate\n          * @param parent  the parent map\n          */\n-        protected KeySetIterator(Iterator<K> iterator, AbstractDualBidiMap<K, ?> parent) {\n+        protected KeySetIterator(final Iterator<K> iterator, final AbstractDualBidiMap<K, ?> parent) {\n             super(iterator);\n             this.parent = parent;\n         }\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n-            Object value = parent.normalMap.get(lastKey);\n+            final Object value = parent.normalMap.get(lastKey);\n             super.remove();\n             parent.reverseMap.remove(value);\n             lastKey = null;\n          * @param parent  the parent BidiMap\n          */\n         @SuppressWarnings(\"unchecked\")\n-        protected Values(AbstractDualBidiMap<?, V> parent) {\n+        protected Values(final AbstractDualBidiMap<?, V> parent) {\n             super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n         }\n \n         }\n \n         @Override\n-        public boolean contains(Object value) {\n+        public boolean contains(final Object value) {\n             return parent.reverseMap.containsKey(value);\n         }\n \n         @Override\n-        public boolean remove(Object value) {\n+        public boolean remove(final Object value) {\n             if (parent.reverseMap.containsKey(value)) {\n-                Object key = parent.reverseMap.remove(value);\n+                final Object key = parent.reverseMap.remove(value);\n                 parent.normalMap.remove(key);\n                 return true;\n             }\n          * @param parent  the parent map\n          */\n         @SuppressWarnings(\"unchecked\")\n-        protected ValuesIterator(Iterator<V> iterator, AbstractDualBidiMap<?, V> parent) {\n+        protected ValuesIterator(final Iterator<V> iterator, final AbstractDualBidiMap<?, V> parent) {\n             super(iterator);\n             this.parent = (AbstractDualBidiMap<Object, V>) parent;\n         }\n          *\n          * @param parent  the parent BidiMap\n          */\n-        protected EntrySet(AbstractDualBidiMap<K, V> parent) {\n+        protected EntrySet(final AbstractDualBidiMap<K, V> parent) {\n             super(parent.normalMap.entrySet(), parent);\n         }\n \n         }\n \n         @Override\n-        public boolean remove(Object obj) {\n+        public boolean remove(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            Object key = entry.getKey();\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object key = entry.getKey();\n             if (parent.containsKey(key)) {\n-                V value = parent.normalMap.get(key);\n+                final V value = parent.normalMap.get(key);\n                 if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n                     parent.normalMap.remove(key);\n                     parent.reverseMap.remove(value);\n          * @param iterator  the iterator to decorate\n          * @param parent  the parent map\n          */\n-        protected EntrySetIterator(Iterator<Map.Entry<K, V>> iterator, AbstractDualBidiMap<K, V> parent) {\n+        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractDualBidiMap<K, V> parent) {\n             super(iterator);\n             this.parent = parent;\n         }\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n             // store value as remove may change the entry in the decorator (eg.TreeMap)\n-            Object value = last.getValue();\n+            final Object value = last.getValue();\n             super.remove();\n             parent.reverseMap.remove(value);\n             last = null;\n          * @param entry  the entry to decorate\n          * @param parent  the parent map\n          */\n-        protected MapEntry(Map.Entry<K, V> entry, AbstractDualBidiMap<K, V> parent) {\n+        protected MapEntry(final Map.Entry<K, V> entry, final AbstractDualBidiMap<K, V> parent) {\n             super(entry);\n             this.parent = parent;\n         }\n \n         @Override\n-        public V setValue(V value) {\n-            K key = MapEntry.this.getKey();\n+        public V setValue(final V value) {\n+            final K key = MapEntry.this.getKey();\n             if (parent.reverseMap.containsKey(value) &&\n                 parent.reverseMap.get(value) != key) {\n                 throw new IllegalArgumentException(\n          * Constructor.\n          * @param parent  the parent map\n          */\n-        protected BidiMapIterator(AbstractDualBidiMap<K, V> parent) {\n+        protected BidiMapIterator(final AbstractDualBidiMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             this.iterator = parent.normalMap.entrySet().iterator();\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n             // store value as remove may change the entry in the decorator (eg.TreeMap)\n-            V value = last.getValue();\n+            final V value = last.getValue();\n             iterator.remove();\n             parent.reverseMap.remove(value);\n             last = null;\n             return last.getValue();\n         }\n \n-        public V setValue(V value) {\n+        public V setValue(final V value) {\n             if (last == null) {\n                 throw new IllegalStateException(\n                         \"Iterator setValue() can only be called after next() and before remove()\");\n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecorator.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected AbstractOrderedBidiMapDecorator(OrderedBidiMap<K, V> map) {\n+    protected AbstractOrderedBidiMapDecorator(final OrderedBidiMap<K, V> map) {\n         super(map);\n     }\n \n         return decorated().lastKey();\n     }\n \n-    public K nextKey(K key) {\n+    public K nextKey(final K key) {\n         return decorated().nextKey(key);\n     }\n \n-    public K previousKey(K key) {\n+    public K previousKey(final K key) {\n         return decorated().previousKey(key);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapDecorator.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractSortedBidiMapDecorator(SortedBidiMap<K, V> map) {\n+    public AbstractSortedBidiMapDecorator(final SortedBidiMap<K, V> map) {\n         super(map);\n     }\n \n         return decorated().valueComparator();\n     }\n \n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return decorated().subMap(fromKey, toKey);\n     }\n \n-    public SortedMap<K, V> headMap(K toKey) {\n+    public SortedMap<K, V> headMap(final K toKey) {\n         return decorated().headMap(toKey);\n     }\n \n-    public SortedMap<K, V> tailMap(K fromKey) {\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n         return decorated().tailMap(fromKey);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n      *\n      * @param map  the map whose mappings are to be placed in this map\n      */\n-    public DualHashBidiMap(Map<K, V> map) {\n+    public DualHashBidiMap(final Map<K, V> map) {\n         super(new HashMap<K, V>(), new HashMap<V, K>());\n         putAll(map);\n     }\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected DualHashBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n+    protected DualHashBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap, final BidiMap<V, K> inverseBidiMap) {\n         super(normalMap, reverseMap, inverseBidiMap);\n     }\n \n      * @return new bidi map\n      */\n     @Override\n-    protected BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseBidiMap) {\n+    protected BidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap, final BidiMap<K, V> inverseBidiMap) {\n         return new DualHashBidiMap<V, K>(normalMap, reverseMap, inverseBidiMap);\n     }\n \n     // Serialization\n     //-----------------------------------------------------------------------\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(normalMap);\n     }\n \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         normalMap = new HashMap<K, V>();\n         reverseMap = new HashMap<V, K>();\n         @SuppressWarnings(\"unchecked\") // will fail at runtime if stream is incorrect\n+        final\n         Map<K, V> map = (Map<K, V>) in.readObject();\n         putAll(map);\n     }\n--- a/src/main/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n      *\n      * @param map  the map whose mappings are to be placed in this map\n      */\n-    public DualTreeBidiMap(Map<K, V> map) {\n+    public DualTreeBidiMap(final Map<K, V> map) {\n         super(new TreeMap<K, V>(), new TreeMap<V, K>());\n         putAll(map);\n         this.comparator = null;\n      * @param keyComparator  the comparator\n      * @param valueComparator  the values comparator to use\n      */\n-    public DualTreeBidiMap(Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {\n+    public DualTreeBidiMap(final Comparator<? super K> keyComparator, final Comparator<? super V> valueComparator) {\n         super(new TreeMap<K, V>(keyComparator), new TreeMap<V, K>(valueComparator));\n         this.comparator = keyComparator;\n         this.valueComparator = valueComparator;\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected DualTreeBidiMap(Map<K, V> normalMap, Map<V, K> reverseMap, BidiMap<V, K> inverseBidiMap) {\n+    protected DualTreeBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap, final BidiMap<V, K> inverseBidiMap) {\n         super(normalMap, reverseMap, inverseBidiMap);\n         this.comparator = ((SortedMap<K, V>) normalMap).comparator();\n         this.valueComparator = ((SortedMap<V, K>) reverseMap).comparator();\n      * @return new bidi map\n      */\n     @Override\n-    protected DualTreeBidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseMap) {\n+    protected DualTreeBidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap, final BidiMap<K, V> inverseMap) {\n         return new DualTreeBidiMap<V, K>(normalMap, reverseMap, inverseMap);\n     }\n \n         return ((SortedMap<K, V>) normalMap).lastKey();\n     }\n \n-    public K nextKey(K key) {\n+    public K nextKey(final K key) {\n         if (isEmpty()) {\n             return null;\n         }\n         if (normalMap instanceof OrderedMap) {\n             return ((OrderedMap<K, ?>) normalMap).nextKey(key);\n         }\n-        SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n-        Iterator<K> it = sm.tailMap(key).keySet().iterator();\n+        final SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        final Iterator<K> it = sm.tailMap(key).keySet().iterator();\n         it.next();\n         if (it.hasNext()) {\n             return it.next();\n         return null;\n     }\n \n-    public K previousKey(K key) {\n+    public K previousKey(final K key) {\n         if (isEmpty()) {\n             return null;\n         }\n         if (normalMap instanceof OrderedMap) {\n             return ((OrderedMap<K, V>) normalMap).previousKey(key);\n         }\n-        SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n-        SortedMap<K, V> hm = sm.headMap(key);\n+        final SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        final SortedMap<K, V> hm = sm.headMap(key);\n         if (hm.isEmpty()) {\n             return null;\n         }\n \n     //-----------------------------------------------------------------------\n     \n-    public SortedMap<K, V> headMap(K toKey) {\n-        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n         return new ViewMap<K, V>(this, sub);\n     }\n \n-    public SortedMap<K, V> tailMap(K fromKey) {\n-        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n         return new ViewMap<K, V>(this, sub);\n     }\n \n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n-        SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n         return new ViewMap<K, V>(this, sub);\n     }\n \n          * @param bidi  the parent bidi map\n          * @param sm  the subMap sorted map\n          */\n-        protected ViewMap(DualTreeBidiMap<K, V> bidi, SortedMap<K, V> sm) {\n+        protected ViewMap(final DualTreeBidiMap<K, V> bidi, final SortedMap<K, V> sm) {\n             // the implementation is not great here...\n             // use the normalMap as the filtered map, but reverseMap as the full map\n             // this forces containsValue and clear to be overridden\n         }\n \n         @Override\n-        public boolean containsValue(Object value) {\n+        public boolean containsValue(final Object value) {\n             // override as default implementation uses reverseMap\n             return decorated().normalMap.containsValue(value);\n         }\n         @Override\n         public void clear() {\n             // override as default implementation uses reverseMap\n-            for (Iterator<K> it = keySet().iterator(); it.hasNext();) {\n+            for (final Iterator<K> it = keySet().iterator(); it.hasNext();) {\n                 it.next();\n                 it.remove();\n             }\n         }\n \n         @Override\n-        public SortedMap<K, V> headMap(K toKey) {\n+        public SortedMap<K, V> headMap(final K toKey) {\n             return new ViewMap<K, V>(decorated(), super.headMap(toKey));\n         }\n \n         @Override\n-        public SortedMap<K, V> tailMap(K fromKey) {\n+        public SortedMap<K, V> tailMap(final K fromKey) {\n             return new ViewMap<K, V>(decorated(), super.tailMap(fromKey));\n         }\n \n         @Override\n-        public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n             return new ViewMap<K, V>(decorated(), super.subMap(fromKey, toKey));\n         }\n \n         }\n \n         @Override\n-        public K previousKey(K key) {\n+        public K previousKey(final K key) {\n             return decorated().previousKey(key);\n         }\n \n         @Override\n-        public K nextKey(K key) {\n+        public K nextKey(final K key) {\n             return decorated().nextKey(key);\n         }\n     }\n          * Constructor.\n          * @param parent  the parent map\n          */\n-        protected BidiOrderedMapIterator(AbstractDualBidiMap<K, V> parent) {\n+        protected BidiOrderedMapIterator(final AbstractDualBidiMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n             return last.getValue();\n         }\n \n-        public V setValue(V value) {\n+        public V setValue(final V value) {\n             if (last == null) {\n                 throw new IllegalStateException(\n                         \"Iterator setValue() can only be called after next() and before remove()\");\n \n     // Serialization\n     //-----------------------------------------------------------------------\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(normalMap);\n     }\n \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         normalMap = new TreeMap<K, V>(comparator);\n         reverseMap = new TreeMap<V, K>(valueComparator);\n         @SuppressWarnings(\"unchecked\") // will fail at runtime if the stream is incorrect\n+        final\n         Map<K, V> map = (Map<K, V>) in.readObject();\n         putAll(map);\n     }\n--- a/src/main/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n          * \n          * @param description  the description for the element\n          */\n-        private DataElement(String description) {\n+        private DataElement(final String description) {\n             this.description = description;\n         }\n \n      */\n     public V get(final Object key) {\n         checkKey(key);\n-        Node<K, V> node = lookupKey(key);\n+        final Node<K, V> node = lookupKey(key);\n         return node == null ? null : node.getValue();\n     }\n \n      * @throws NullPointerException if the key is null\n      */\n     public V put(final K key, final V value) {\n-        V result = get(key);\n+        final V result = get(key);\n         doPut(key, value);\n         return result;\n     }\n      *\n      * @param map  the map to copy from\n      */\n-    public void putAll(Map<? extends K, ? extends V> map) {\n-        for (Map.Entry<? extends K, ? extends V> e : map.entrySet()) {\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> e : map.entrySet()) {\n             put(e.getKey(), e.getValue());\n         }\n     }\n      */\n     public K getKey(final Object value) {\n         checkValue(value);\n-        Node<K, V> node = lookupValue(value);\n+        final Node<K, V> node = lookupValue(value);\n         return node == null ? null : node.getKey();\n     }\n \n      * @param key the key to search for next from\n      * @return the next key, null if no match or at end\n      */\n-    public K nextKey(K key) {\n+    public K nextKey(final K key) {\n         checkKey(key);\n-        Node<K, V> node = nextGreater(lookupKey(key), KEY);\n+        final Node<K, V> node = nextGreater(lookupKey(key), KEY);\n         return node == null ? null : node.getKey();\n     }\n \n      * @param key the key to search for previous from\n      * @return the previous key, null if no match or at start\n      */\n-    public K previousKey(K key) {\n+    public K previousKey(final K key) {\n         checkKey(key);\n-        Node<K, V> node = nextSmaller(lookupKey(key), KEY);\n+        final Node<K, V> node = nextSmaller(lookupKey(key), KEY);\n         return node == null ? null : node.getKey();\n     }\n \n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         return this.doEquals(obj, KEY);\n     }\n \n         Node<K, V> node = rootNode[KEY.ordinal()];\n         if (node == null) {\n             // map is empty\n-            Node<K, V> root = new Node<K, V>(key, value);\n+            final Node<K, V> root = new Node<K, V>(key, value);\n             rootNode[KEY.ordinal()] = root;\n             rootNode[VALUE.ordinal()] = root;\n             grow();\n         } else {\n             // add new mapping\n             while (true) {\n-                int cmp = compare(key, node.getKey());\n+                final int cmp = compare(key, node.getKey());\n \n                 if (cmp == 0) {\n                     // shouldn't happen\n                     if (node.getLeft(KEY) != null) {\n                         node = node.getLeft(KEY);\n                     } else {\n-                        Node<K, V> newNode = new Node<K, V>(key, value);\n+                        final Node<K, V> newNode = new Node<K, V>(key, value);\n \n                         insertValue(newNode);\n                         node.setLeft(newNode, KEY);\n                     if (node.getRight(KEY) != null) {\n                         node = node.getRight(KEY);\n                     } else {\n-                        Node<K, V> newNode = new Node<K, V>(key, value);\n+                        final Node<K, V> newNode = new Node<K, V>(key, value);\n \n                         insertValue(newNode);\n                         node.setRight(newNode, KEY);\n         }\n     }\n \n-    private V doRemoveKey(Object key) {\n-        Node<K, V> node = lookupKey(key);\n+    private V doRemoveKey(final Object key) {\n+        final Node<K, V> node = lookupKey(key);\n         if (node == null) {\n             return null;\n         }\n         return node.getValue();\n     }\n \n-    private K doRemoveValue(Object value) {\n-        Node<K, V> node = lookupValue(value);\n+    private K doRemoveValue(final Object value) {\n+        final Node<K, V> node = lookupValue(value);\n         if (node == null) {\n             return null;\n         }\n         Node<K, V> node = rootNode[dataElement.ordinal()];\n \n         while (node != null) {\n-            int cmp = compare((T) data, (T) node.getData(dataElement));\n+            final int cmp = compare((T) data, (T) node.getData(dataElement));\n             if (cmp == 0) {\n                 rval = node;\n                 break;\n         return rval;\n     }\n \n-    private Node<K, V> lookupKey(Object key) {\n+    private Node<K, V> lookupKey(final Object key) {\n         return this.<K>lookup(key, KEY);\n     }\n \n-    private Node<K, V> lookupValue(Object value) {\n+    private Node<K, V> lookupValue(final Object value) {\n         return this.<V>lookup(value, VALUE);\n     }\n \n      * @param index  the KEY or VALUE int\n      */\n     private void rotateLeft(final Node<K, V> node, final DataElement dataElement) {\n-        Node<K, V> rightChild = node.getRight(dataElement);\n+        final Node<K, V> rightChild = node.getRight(dataElement);\n         node.setRight(rightChild.getLeft(dataElement), dataElement);\n \n         if (rightChild.getLeft(dataElement) != null) {\n      * @param index  the KEY or VALUE int\n      */\n     private void rotateRight(final Node<K, V> node, final DataElement dataElement) {\n-        Node<K, V> leftChild = node.getLeft(dataElement);\n+        final Node<K, V> leftChild = node.getLeft(dataElement);\n         node.setLeft(leftChild.getRight(dataElement), dataElement);\n         if (leftChild.getRight(dataElement) != null) {\n             leftChild.getRight(dataElement).setParent(node, dataElement);\n             && currentNode != rootNode[dataElement.ordinal()]\n             && isRed(currentNode.getParent(dataElement), dataElement)) {\n             if (currentNode.isLeftChild(dataElement)) {\n-                Node<K, V> y = getRightChild(getGrandParent(currentNode, dataElement), dataElement);\n+                final Node<K, V> y = getRightChild(getGrandParent(currentNode, dataElement), dataElement);\n \n                 if (isRed(y, dataElement)) {\n                     makeBlack(getParent(currentNode, dataElement), dataElement);\n             } else {\n \n                 // just like clause above, except swap left for right\n-                Node<K, V> y = getLeftChild(getGrandParent(currentNode, dataElement), dataElement);\n+                final Node<K, V> y = getLeftChild(getGrandParent(currentNode, dataElement), dataElement);\n \n                 if (isRed(y, dataElement)) {\n                     makeBlack(getParent(currentNode, dataElement), dataElement);\n      * @param deletedNode the node to be deleted\n      */\n     private void doRedBlackDelete(final Node<K, V> deletedNode) {\n-        for (DataElement dataElement : DataElement.values()) {\n+        for (final DataElement dataElement : DataElement.values()) {\n             // if deleted node has both left and children, swap with\n             // the next greater node\n             if (deletedNode.getLeft(dataElement) != null && deletedNode.getRight(dataElement) != null) {\n                 swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);\n             }\n \n-            Node<K, V> replacement = deletedNode.getLeft(dataElement) != null ?\n+            final Node<K, V> replacement = deletedNode.getLeft(dataElement) != null ?\n                     deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);\n \n             if (replacement != null) {\n      */\n     private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement) {\n         // Save initial values.\n-        Node<K, V> xFormerParent = x.getParent(dataElement);\n-        Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\n-        Node<K, V> xFormerRightChild = x.getRight(dataElement);\n-        Node<K, V> yFormerParent = y.getParent(dataElement);\n-        Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\n-        Node<K, V> yFormerRightChild = y.getRight(dataElement);\n-        boolean xWasLeftChild =\n+        final Node<K, V> xFormerParent = x.getParent(dataElement);\n+        final Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\n+        final Node<K, V> xFormerRightChild = x.getRight(dataElement);\n+        final Node<K, V> yFormerParent = y.getParent(dataElement);\n+        final Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\n+        final Node<K, V> yFormerRightChild = y.getRight(dataElement);\n+        final boolean xWasLeftChild =\n                 x.getParent(dataElement) != null && x == x.getParent(dataElement).getLeft(dataElement);\n-        boolean yWasLeftChild =\n+        final boolean yWasLeftChild =\n                 y.getParent(dataElement) != null && y == y.getParent(dataElement).getLeft(dataElement);\n \n         // Swap, handling special cases of one being the other's parent.\n         Node<K, V> node = rootNode[VALUE.ordinal()];\n \n         while (true) {\n-            int cmp = compare(newNode.getValue(), node.getValue());\n+            final int cmp = compare(newNode.getValue(), node.getValue());\n \n             if (cmp == 0) {\n                 throw new IllegalArgumentException(\n      * @param type  the KEY or VALUE int\n      * @return true if equal\n      */\n-    private boolean doEquals(Object obj, DataElement dataElement) {\n+    private boolean doEquals(final Object obj, final DataElement dataElement) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map == false) {\n             return false;\n         }\n-        Map<?, ?> other = (Map<?, ?>) obj;\n+        final Map<?, ?> other = (Map<?, ?>) obj;\n         if (other.size() != size()) {\n             return false;\n         }\n \n         if (nodeCount > 0) {\n             try {\n-                for (MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n-                    Object key = it.next();\n-                    Object value = it.getValue();\n+                for (final MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n+                    final Object key = it.next();\n+                    final Object value = it.getValue();\n                     if (value.equals(other.get(key)) == false) {\n                         return false;\n                     }\n                 }\n-            } catch (ClassCastException ex) {\n+            } catch (final ClassCastException ex) {\n                 return false;\n-            } catch (NullPointerException ex) {\n+            } catch (final NullPointerException ex) {\n                 return false;\n             }\n         }\n      * @param type  the KEY or VALUE int\n      * @return the hash code value for this map\n      */\n-    private int doHashCode(DataElement dataElement) {\n+    private int doHashCode(final DataElement dataElement) {\n         int total = 0;\n         if (nodeCount > 0) {\n-            for (MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n-                Object key = it.next();\n-                Object value = it.getValue();\n+            for (final MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n+                final Object key = it.next();\n+                final Object value = it.getValue();\n                 total += key.hashCode() ^ value.hashCode();\n             }\n         }\n      * @param type  the KEY or VALUE int\n      * @return the string form of this map\n      */\n-    private String doToString(DataElement dataElement) {\n+    private String doToString(final DataElement dataElement) {\n         if (nodeCount == 0) {\n             return \"{}\";\n         }\n-        StringBuilder buf = new StringBuilder(nodeCount * 32);\n+        final StringBuilder buf = new StringBuilder(nodeCount * 32);\n         buf.append('{');\n-        MapIterator<?, ?> it = getMapIterator(dataElement);\n+        final MapIterator<?, ?> it = getMapIterator(dataElement);\n         boolean hasNext = it.hasNext();\n         while (hasNext) {\n-            Object key = it.next();\n-            Object value = it.getValue();\n+            final Object key = it.next();\n+            final Object value = it.getValue();\n             buf.append(key == this ? \"(this Map)\" : key)\n                .append('=')\n                .append(value == this ? \"(this Map)\" : value);\n         return buf.toString();\n     }\n \n-    private MapIterator<?, ?> getMapIterator(DataElement dataElement) {\n+    private MapIterator<?, ?> getMapIterator(final DataElement dataElement) {\n         switch (dataElement) {\n         case KEY:\n             return new ViewMapIterator(KEY);\n         /**\n          * Create a new TreeBidiMap.KeyView.\n          */\n-        public KeyView(DataElement orderType) {\n+        public KeyView(final DataElement orderType) {\n             super(orderType);\n         }\n \n         }\n \n         @Override\n-        public boolean remove(Object o) {\n+        public boolean remove(final Object o) {\n             return doRemoveKey(o) != null;\n         }\n \n         /**\n          * Create a new TreeBidiMap.ValueView.\n          */\n-        public ValueView(DataElement orderType) {\n+        public ValueView(final DataElement orderType) {\n             super(orderType);\n         }\n \n         }\n \n         @Override\n-        public boolean remove(Object o) {\n+        public boolean remove(final Object o) {\n             return doRemoveValue(o) != null;\n         }\n \n         }\n \n         @Override\n-        public boolean contains(Object obj) {\n+        public boolean contains(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            Object value = entry.getValue();\n-            Node<K, V> node = lookupKey(entry.getKey());\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupKey(entry.getKey());\n             return node != null && node.getValue().equals(value);\n         }\n \n         @Override\n-        public boolean remove(Object obj) {\n+        public boolean remove(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            Object value = entry.getValue();\n-            Node<K, V> node = lookupKey(entry.getKey());\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupKey(entry.getKey());\n             if (node != null && node.getValue().equals(value)) {\n                 doRedBlackDelete(node);\n                 return true;\n         }\n \n         @Override\n-        public boolean contains(Object obj) {\n+        public boolean contains(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            Object value = entry.getValue();\n-            Node<K, V> node = lookupValue(entry.getKey());\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupValue(entry.getKey());\n             return node != null && node.getKey().equals(value);\n         }\n \n         @Override\n-        public boolean remove(Object obj) {\n+        public boolean remove(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            Object value = entry.getValue();\n-            Node<K, V> node = lookupValue(entry.getKey());\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupValue(entry.getKey());\n             if (node != null && node.getKey().equals(value)) {\n                 doRedBlackDelete(node);\n                 return true;\n         /**\n          * Constructor.\n          */\n-        ViewMapIterator(DataElement orderType) {\n+        ViewMapIterator(final DataElement orderType) {\n             super(orderType);\n         }\n \n         /**\n          * Create a new TreeBidiMap.InverseViewMapIterator.\n          */\n-        public InverseViewMapIterator(DataElement orderType) {\n+        public InverseViewMapIterator(final DataElement orderType) {\n             super(orderType);\n         }\n \n             return createEntry(navigatePrevious());\n         }\n \n-        private Map.Entry<V, K> createEntry(Node<K, V> node) {\n+        private Map.Entry<V, K> createEntry(final Node<K, V> node) {\n             return new UnmodifiableMapEntry<V, K>(node.getValue(), node.getKey());\n         }\n     }\n             if (!(obj instanceof Map.Entry)) {\n                 return false;\n             }\n-            Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n+            final Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n             return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n         }\n \n             return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n         }\n \n-        public V nextKey(V key) {\n+        public V nextKey(final V key) {\n             checkKey(key);\n-            Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            final Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n             return node == null ? null : node.getValue();\n         }\n \n-        public V previousKey(V key) {\n+        public V previousKey(final V key) {\n             checkKey(key);\n-            Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            final Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n             return node == null ? null : node.getValue();\n         }\n \n         public K put(final V key, final K value) {\n-            K result = get(key);\n+            final K result = get(key);\n             TreeBidiMap.this.doPut(value, key);\n             return result;\n         }\n \n-        public void putAll(Map<? extends V, ? extends K> map) {\n-            for (Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n+        public void putAll(final Map<? extends V, ? extends K> map) {\n+            for (final Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n                 put(e.getKey(), e.getValue());\n             }\n         }\n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);\n         }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n      * @return an unmodifiable BidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> BidiMap<K, V> unmodifiableBidiMap(BidiMap<K, V> map) {\n+    public static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableBidiMap(BidiMap<K, V> map) {\n+    private UnmodifiableBidiMap(final BidiMap<K, V> map) {\n         super(map);\n     }\n \n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        Set<Map.Entry<K, V>> set = super.entrySet();\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        Set<K> set = super.keySet();\n+        final Set<K> set = super.keySet();\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n-        Collection<V> coll = super.values();\n+        final Collection<V> coll = super.values();\n         return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public K removeValue(Object value) {\n+    public K removeValue(final Object value) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public MapIterator<K, V> mapIterator() {\n-        MapIterator<K, V> it = decorated().mapIterator();\n+        final MapIterator<K, V> it = decorated().mapIterator();\n         return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n      * @return an unmodifiable OrderedBidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(OrderedBidiMap<K, V> map) {\n+    public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableOrderedBidiMap(OrderedBidiMap<K, V> map) {\n+    private UnmodifiableOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n         super(map);\n     }\n \n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        Set<Map.Entry<K, V>> set = super.entrySet();\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        Set<K> set = super.keySet();\n+        final Set<K> set = super.keySet();\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n-        Collection<V> coll = super.values();\n+        final Collection<V> coll = super.values();\n         return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public K removeValue(Object value) {\n+    public K removeValue(final Object value) {\n         throw new UnsupportedOperationException();\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n-        OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n         return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n      * @return an unmodifiable SortedBidiMap\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(SortedBidiMap<K, V> map) {\n+    public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableSortedBidiMap(SortedBidiMap<K, V> map) {\n+    private UnmodifiableSortedBidiMap(final SortedBidiMap<K, V> map) {\n         super(map);\n     }\n \n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        Set<Map.Entry<K, V>> set = super.entrySet();\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        Set<K> set = super.keySet();\n+        final Set<K> set = super.keySet();\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n-        Collection<V> coll = super.values();\n+        final Collection<V> coll = super.values();\n         return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public K removeValue(Object value) {\n+    public K removeValue(final Object value) {\n         throw new UnsupportedOperationException();\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n-        OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n         return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n     }\n \n     }\n \n     @Override\n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n-        SortedMap<K, V> sm = decorated().subMap(fromKey, toKey);\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> sm = decorated().subMap(fromKey, toKey);\n         return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n     }\n \n     @Override\n-    public SortedMap<K, V> headMap(K toKey) {\n-        SortedMap<K, V> sm = decorated().headMap(toKey);\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> sm = decorated().headMap(toKey);\n         return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n     }\n \n     @Override\n-    public SortedMap<K, V> tailMap(K fromKey) {\n-        SortedMap<K, V> sm = decorated().tailMap(fromKey);\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> sm = decorated().tailMap(fromKey);\n         return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/buffer/AbstractBufferDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/AbstractBufferDecorator.java\n      * @param buffer  the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected AbstractBufferDecorator(Buffer<E> buffer) {\n+    protected AbstractBufferDecorator(final Buffer<E> buffer) {\n         super(buffer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n      * @return a new blocking Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static <E> BlockingBuffer<E> blockingBuffer(Buffer<E> buffer) {\n+    public static <E> BlockingBuffer<E> blockingBuffer(final Buffer<E> buffer) {\n         return new BlockingBuffer<E>(buffer);\n     }\n \n      * @throws IllegalArgumentException if the buffer is null\n      * @since 3.2\n      */\n-    public static <E> BlockingBuffer<E> blockingBuffer(Buffer<E> buffer, long timeoutMillis) {\n+    public static <E> BlockingBuffer<E> blockingBuffer(final Buffer<E> buffer, final long timeoutMillis) {\n         return new BlockingBuffer<E>(buffer, timeoutMillis);\n     }\n \n      * @param buffer the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    protected BlockingBuffer(Buffer<E> buffer) {\n+    protected BlockingBuffer(final Buffer<E> buffer) {\n         super(buffer);\n         this.timeout = 0;\n     }\n      * @throws IllegalArgumentException if the buffer is null\n      * @since 3.2\n      */\n-    protected BlockingBuffer(Buffer<E> buffer, long timeoutMillis) {\n+    protected BlockingBuffer(final Buffer<E> buffer, final long timeoutMillis) {\n         super(buffer);\n         this.timeout = timeoutMillis < 0 ? 0 : timeoutMillis;\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public boolean add(E o) {\n-        synchronized (lock) {\n-            boolean result = collection.add(o);\n+    public boolean add(final E o) {\n+        synchronized (lock) {\n+            final boolean result = collection.add(o);\n             lock.notifyAll();\n             return result;\n         }\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> c) {\n-        synchronized (lock) {\n-            boolean result = collection.addAll(c);\n+    public boolean addAll(final Collection<? extends E> c) {\n+        synchronized (lock) {\n+            final boolean result = collection.addAll(c);\n             lock.notifyAll();\n             return result;\n         }\n                     } else {\n                         return get(timeout);\n                     }\n-                } catch (InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n+                } catch (final InterruptedException e) {\n+                    final PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n                 try {\n                     lock.wait(timeLeft);\n                     timeLeft = expiration - System.currentTimeMillis();\n-                } catch(InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n+                } catch(final InterruptedException e) {\n+                    final PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n                     } else {\n                         return remove(timeout);\n                     }\n-                } catch (InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n+                } catch (final InterruptedException e) {\n+                    final PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n                 try {\n                     lock.wait(timeLeft);\n                     timeLeft = expiration - System.currentTimeMillis();\n-                } catch(InterruptedException e) {\n-                    PrintWriter out = new PrintWriter(new StringWriter());\n+                } catch(final InterruptedException e) {\n+                    final PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n--- a/src/main/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n      * @throws IllegalArgumentException if the buffer is null\n      * @throws IllegalArgumentException if the maximum size is zero or less\n      */\n-    public static <E> BoundedBuffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize) {\n+    public static <E> BoundedBuffer<E> boundedBuffer(final Buffer<E> buffer, final int maximumSize) {\n         return new BoundedBuffer<E>(buffer, maximumSize, 0L);\n     }\n \n      * @throws IllegalArgumentException if the buffer is null\n      * @throws IllegalArgumentException if the maximum size is zero or less\n      */\n-    public static <E> BoundedBuffer<E> boundedBuffer(Buffer<E> buffer, int maximumSize, long timeout) {\n+    public static <E> BoundedBuffer<E> boundedBuffer(final Buffer<E> buffer, final int maximumSize, final long timeout) {\n         return new BoundedBuffer<E>(buffer, maximumSize, timeout);\n     }\n \n      * @throws IllegalArgumentException if the buffer is null\n      * @throws IllegalArgumentException if the maximum size is zero or less\n      */\n-    protected BoundedBuffer(Buffer<E> buffer, int maximumSize, long timeout) {\n+    protected BoundedBuffer(final Buffer<E> buffer, final int maximumSize, final long timeout) {\n         super(buffer);\n         if (maximumSize < 1) {\n             throw new IllegalArgumentException();\n     @Override\n     public E remove() {\n         synchronized (lock) {\n-            E returnValue = decorated().remove();\n+            final E returnValue = decorated().remove();\n             lock.notifyAll();\n             return returnValue;\n         }\n     }\n \n     @Override\n-    public boolean add(E o) {\n+    public boolean add(final E o) {\n         synchronized (lock) {\n             timeoutWait(1);\n             return decorated().add(o);\n             try {\n                 lock.wait(timeLeft);\n                 timeLeft = expiration - System.currentTimeMillis();\n-            } catch (InterruptedException ex) {\n-                PrintWriter out = new PrintWriter(new StringWriter());\n+            } catch (final InterruptedException ex) {\n+                final PrintWriter out = new PrintWriter(new StringWriter());\n                 ex.printStackTrace(out);\n                 throw new BufferUnderflowException(\n                     \"Caused by InterruptedException: \" + out.toString());\n          * \n          * @param it the decorated {@link Iterator}\n          */\n-        public NotifyingIterator(Iterator<E> it) {\n+        public NotifyingIterator(final Iterator<E> it) {\n             super(it);\n         }\n \n--- a/src/main/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n      * @throws IllegalArgumentException  if the size is less than 1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public BoundedFifoBuffer(int size) {\n+    public BoundedFifoBuffer(final int size) {\n         if (size <= 0) {\n             throw new IllegalArgumentException(\"The size must be greater than 0\");\n         }\n      * @param coll  the collection whose elements to add, may not be null\n      * @throws NullPointerException if the collection is null\n      */\n-    public BoundedFifoBuffer(Collection<? extends E> coll) {\n+    public BoundedFifoBuffer(final Collection<? extends E> coll) {\n         this(coll.size());\n         addAll(coll);\n     }\n      * @param out  the output stream\n      * @throws IOException if an I/O error occurs while writing to the output stream\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeInt(size());\n-        for (E e : this) {\n+        for (final E e : this) {\n             out.writeObject(e);\n         }\n     }\n      * @throws ClassNotFoundException if the class of a serialized object can not be found\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         elements = (E[]) new Object[maxElements];\n-        int size = in.readInt();\n+        final int size = in.readInt();\n         for (int i = 0; i < size; i++) {\n             elements[i] = (E) in.readObject();\n         }\n      * @throws BufferOverflowException  if this buffer is full\n      */\n     @Override\n-    public boolean add(E element) {\n+    public boolean add(final E element) {\n         if (null == element) {\n             throw new NullPointerException(\"Attempted to add null object to buffer\");\n         }\n      * @return the element at position {@code index}\n      * @throws NoSuchElementException if the requested position is outside the range [0, size)\n      */\n-    public E get(int index) {\n+    public E get(final int index) {\n         final int sz = size();\n         if (index < 0 || index >= sz) {\n             throw new NoSuchElementException(\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        E element = elements[start];\n+        final E element = elements[start];\n \n         if (null != element) {\n             elements[start++] = null;\n--- a/src/main/java/org/apache/commons/collections/buffer/CircularFifoBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/CircularFifoBuffer.java\n      * @param size  the size of the buffer (cannot be changed)\n      * @throws IllegalArgumentException  if the size is less than 1\n      */\n-    public CircularFifoBuffer(int size) {\n+    public CircularFifoBuffer(final int size) {\n         super(size);\n     }\n \n      * @param coll  the collection to copy into the buffer, may not be null\n      * @throws NullPointerException if the collection is null\n      */\n-    public CircularFifoBuffer(Collection<E> coll) {\n+    public CircularFifoBuffer(final Collection<E> coll) {\n         super(coll);\n     }\n \n      * @return true, always\n      */\n     @Override\n-    public boolean add(E element) {\n+    public boolean add(final E element) {\n         if (isFull()) {\n             remove();\n         }\n--- a/src/main/java/org/apache/commons/collections/buffer/PredicatedBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/PredicatedBuffer.java\n      * @throws IllegalArgumentException if buffer or predicate is null\n      * @throws IllegalArgumentException if the buffer contains invalid elements\n      */\n-    public static <E> PredicatedBuffer<E> predicatedBuffer(Buffer<E> buffer, Predicate<? super E> predicate) {\n+    public static <E> PredicatedBuffer<E> predicatedBuffer(final Buffer<E> buffer, final Predicate<? super E> predicate) {\n         return new PredicatedBuffer<E>(buffer, predicate);\n     }\n     \n      * @throws IllegalArgumentException if buffer or predicate is null\n      * @throws IllegalArgumentException if the buffer contains invalid elements\n      */\n-    protected PredicatedBuffer(Buffer<E> buffer, Predicate<? super E> predicate) {\n+    protected PredicatedBuffer(final Buffer<E> buffer, final Predicate<? super E> predicate) {\n         super(buffer, predicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n      * @param comparator  the comparator used to order the elements,\n      *  null means use natural order\n      */\n-    public PriorityBuffer(Comparator<? super E> comparator) {\n+    public PriorityBuffer(final Comparator<? super E> comparator) {\n         this(DEFAULT_CAPACITY, true, comparator);\n     }\n \n      * @param ascendingOrder  if <code>true</code> the heap is created as a \n      * minimum heap; otherwise, the heap is created as a maximum heap\n      */\n-    public PriorityBuffer(boolean ascendingOrder) {\n+    public PriorityBuffer(final boolean ascendingOrder) {\n         this(DEFAULT_CAPACITY, ascendingOrder, null);\n     }\n \n      * @param comparator  the comparator used to order the elements,\n      *  null means use natural order\n      */\n-    public PriorityBuffer(boolean ascendingOrder, Comparator<? super E> comparator) {\n+    public PriorityBuffer(final boolean ascendingOrder, final Comparator<? super E> comparator) {\n         this(DEFAULT_CAPACITY, ascendingOrder, comparator);\n     }\n \n      * @param capacity  the initial capacity for the buffer, greater than zero\n      * @throws IllegalArgumentException if <code>capacity</code> is &lt;= <code>0</code>\n      */\n-    public PriorityBuffer(int capacity) {\n+    public PriorityBuffer(final int capacity) {\n         this(capacity, true, null);\n     }\n \n      *  null means use natural order\n      * @throws IllegalArgumentException if <code>capacity</code> is &lt;= <code>0</code>\n      */\n-    public PriorityBuffer(int capacity, Comparator<? super E> comparator) {\n+    public PriorityBuffer(final int capacity, final Comparator<? super E> comparator) {\n         this(capacity, true, comparator);\n     }\n \n      *  minimum heap; otherwise, the heap is created as a maximum heap.\n      * @throws IllegalArgumentException if <code>capacity</code> is <code>&lt;= 0</code>\n      */\n-    public PriorityBuffer(int capacity, boolean ascendingOrder) {\n+    public PriorityBuffer(final int capacity, final boolean ascendingOrder) {\n         this(capacity, ascendingOrder, null);\n     }\n \n      * @throws IllegalArgumentException if <code>capacity</code> is <code>&lt;= 0</code>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public PriorityBuffer(int capacity, boolean ascendingOrder, Comparator<? super E> comparator) {\n+    public PriorityBuffer(final int capacity, final boolean ascendingOrder, final Comparator<? super E> comparator) {\n         super();\n         if (capacity <= 0) {\n             throw new IllegalArgumentException(\"invalid capacity\");\n      * @return true always\n      */\n     @Override\n-    public boolean add(E element) {\n+    public boolean add(final E element) {\n         if (isAtCapacity()) {\n             grow();\n         }\n      */\n     protected void percolateUpMinHeap(final int index) {\n         int hole = index;\n-        E element = elements[hole];\n+        final E element = elements[hole];\n         while (hole > 1 && compare(element, elements[hole / 2]) < 0) {\n             // save element that is being pushed down\n             // as the element \"bubble\" is percolated up\n      */\n     protected void percolateUpMaxHeap(final int index) {\n         int hole = index;\n-        E element = elements[hole];\n+        final E element = elements[hole];\n \n         while (hole > 1 && compare(element, elements[hole / 2]) > 0) {\n             // save element that is being pushed down\n      * @param b  the second object\n      * @return -ve if a less than b, 0 if they are equal, +ve if a greater than b\n      */\n-    protected int compare(E a, E b) {\n+    protected int compare(final E a, final E b) {\n         return comparator.compare(a, b);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/buffer/SynchronizedBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/SynchronizedBuffer.java\n      * @return a new synchronized Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static <E> SynchronizedBuffer<E> synchronizedBuffer(Buffer<E> buffer) {\n+    public static <E> SynchronizedBuffer<E> synchronizedBuffer(final Buffer<E> buffer) {\n         return new SynchronizedBuffer<E>(buffer);\n     }\n \n      * @param buffer  the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    protected SynchronizedBuffer(Buffer<E> buffer) {\n+    protected SynchronizedBuffer(final Buffer<E> buffer) {\n         super(buffer);\n     }\n \n      * @param lock  the lock object to use, must not be null\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    protected SynchronizedBuffer(Buffer<E> buffer, Object lock) {\n+    protected SynchronizedBuffer(final Buffer<E> buffer, final Object lock) {\n         super(buffer, lock);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/buffer/TransformedBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/TransformedBuffer.java\n      * @return a new transformed Buffer\n      * @throws IllegalArgumentException if buffer or transformer is null\n      */\n-    public static <E> TransformedBuffer<E> transformingBuffer(Buffer<E> buffer,\n-                                                              Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedBuffer<E> transformingBuffer(final Buffer<E> buffer,\n+                                                              final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedBuffer<E>(buffer, transformer);\n     }\n     \n      * @throws IllegalArgumentException if buffer or transformer is null\n      * @since 3.3\n      */\n-    public static <E> TransformedBuffer<E> transformedBuffer(Buffer<E> buffer,\n-                                                             Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedBuffer<E> transformedBuffer(final Buffer<E> buffer,\n+                                                             final Transformer<? super E, ? extends E> transformer) {\n         // throws IAE if buffer or transformer is null\n         final TransformedBuffer<E> decorated = new TransformedBuffer<E>(buffer, transformer); \n         if (buffer.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // buffer is type <E>\n+            final\n             E[] values = (E[]) buffer.toArray();\n             buffer.clear();\n-            for (E value : values) {\n+            for (final E value : values) {\n                 decorated.decorated().add(transformer.transform(value));\n             }\n         }\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if buffer or transformer is null\n      */\n-    protected TransformedBuffer(Buffer<E> buffer, Transformer<? super E, ? extends E> transformer) {\n+    protected TransformedBuffer(final Buffer<E> buffer, final Transformer<? super E, ? extends E> transformer) {\n         super(buffer, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n      * @throws IllegalArgumentException  if the size is less than 1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public UnboundedFifoBuffer(int initialSize) {\n+    public UnboundedFifoBuffer(final int initialSize) {\n         if (initialSize <= 0) {\n             throw new IllegalArgumentException(\"The size must be greater than 0\");\n         }\n      * @param out  the output stream\n      * @throws IOException if an I/O error occurs while writing to the output stream\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeInt(size());\n         out.writeInt(buffer.length);\n-        for (E e : this) {\n+        for (final E e : this) {\n             out.writeObject(e);\n         }\n     }\n      * @throws ClassNotFoundException if the class of a serialized object can not be found\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        int size = in.readInt();\n-        int length = in.readInt();\n+        final int size = in.readInt();\n+        final int length = in.readInt();\n         buffer = (E[]) new Object[length];\n         for (int i = 0; i < size; i++) {\n             buffer[i] = (E) in.readObject();\n \n         if (size() + 1 >= buffer.length) {\n             // copy contents to a new buffer array\n-            E[] tmp = (E[]) new Object[(buffer.length - 1) * 2 + 1];\n+            final E[] tmp = (E[]) new Object[(buffer.length - 1) * 2 + 1];\n             int j = 0;\n             // move head to element zero in the new array\n             for (int i = head; i != tail;) {\n             throw new BufferUnderflowException(\"The buffer is already empty\");\n         }\n \n-        E element = buffer[head];\n+        final E element = buffer[head];\n         if (element != null) {\n             buffer[head] = null;\n             head = increment(head);\n--- a/src/main/java/org/apache/commons/collections/buffer/UnmodifiableBuffer.java\n+++ b/src/main/java/org/apache/commons/collections/buffer/UnmodifiableBuffer.java\n      * @return an unmodifiable Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static <E> Buffer<E> unmodifiableBuffer(Buffer<E> buffer) {\n+    public static <E> Buffer<E> unmodifiableBuffer(final Buffer<E> buffer) {\n         if (buffer instanceof Unmodifiable) {\n             return buffer;\n         }\n      * @param buffer  the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    private UnmodifiableBuffer(Buffer<E> buffer) {\n+    private UnmodifiableBuffer(final Buffer<E> buffer) {\n         super(buffer);\n     }\n \n      * @param out  the output stream\n      * @throws IOException if an I/O error occurs while writing to the output stream\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(collection);\n     }\n      * @throws ClassNotFoundException if the class of a serialized object can not be found\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         collection = (Collection<E>) in.readObject();\n     }\n     }\n \n     @Override\n-    public boolean add(Object object) {\n+    public boolean add(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/AbstractCollectionDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/collection/AbstractCollectionDecorator.java\n      * @param coll  the collection to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected AbstractCollectionDecorator(Collection<E> coll) {\n+    protected AbstractCollectionDecorator(final Collection<E> coll) {\n         if (coll == null) {\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n \n     //-----------------------------------------------------------------------\n     \n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         return decorated().add(object);\n     }\n \n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         return decorated().addAll(coll);\n     }\n \n         decorated().clear();\n     }\n \n-    public boolean contains(Object object) {\n+    public boolean contains(final Object object) {\n         return decorated().contains(object);\n     }\n \n         return decorated().iterator();\n     }\n \n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         return decorated().remove(object);\n     }\n \n         return decorated().toArray();\n     }\n \n-    public <T> T[] toArray(T[] object) {\n+    public <T> T[] toArray(final T[] object) {\n         return decorated().toArray(object);\n     }\n \n-    public boolean containsAll(Collection<?> coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n         return decorated().containsAll(coll);\n     }\n \n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         return decorated().removeAll(coll);\n     }\n \n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         return decorated().retainAll(coll);\n     }\n \n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         return object == this || decorated().equals(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/AbstractUntypedCollectionDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/collection/AbstractUntypedCollectionDecorator.java\n         decorated().clear();\n     }\n \n-    public boolean contains(Object object) {\n+    public boolean contains(final Object object) {\n         return decorated().contains(object);\n     }\n \n         return decorated().isEmpty();\n     }\n \n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         return decorated().remove(object);\n     }\n \n         return decorated().toArray();\n     }\n \n-    public <T> T[] toArray(T[] object) {\n+    public <T> T[] toArray(final T[] object) {\n         return decorated().toArray(object);\n     }\n \n-    public boolean containsAll(Collection<?> coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n         return decorated().containsAll(coll);\n     }\n \n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         return decorated().removeAll(coll);\n     }\n \n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         return decorated().retainAll(coll);\n     }\n \n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         return object == this || decorated().equals(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/CompositeCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/CompositeCollection.java\n      *\n      * @param compositeCollection  the Collection to be appended to the composite\n      */\n-    public CompositeCollection(Collection<E> compositeCollection) {\n+    public CompositeCollection(final Collection<E> compositeCollection) {\n         super();\n         addComposited(compositeCollection);\n     }\n      * @param compositeCollection1  the Collection to be appended to the composite\n      * @param compositeCollection2  the Collection to be appended to the composite\n      */\n-    public CompositeCollection(Collection<E> compositeCollection1, Collection<E> compositeCollection2) {\n+    public CompositeCollection(final Collection<E> compositeCollection1, final Collection<E> compositeCollection2) {\n         super();\n         addComposited(compositeCollection1, compositeCollection2);\n     }\n      *\n      * @param compositeCollections  the collections to composite\n      */\n-    public CompositeCollection(Collection<E>[] compositeCollections) {\n+    public CompositeCollection(final Collection<E>[] compositeCollections) {\n         super();\n         addComposited(compositeCollections);\n     }\n      */\n     public int size() {\n         int size = 0;\n-        for (Collection<E> item : all) {\n+        for (final Collection<E> item : all) {\n             size += item.size();\n         }\n         return size;\n      * @return true if all of the contained collections are empty\n      */\n     public boolean isEmpty() {\n-        for (Collection<? extends E> item : all) {\n+        for (final Collection<? extends E> item : all) {\n             if (item.isEmpty() == false) {\n                 return false;\n             }\n      * @param obj  the object to search for\n      * @return true if obj is contained in any of the contained collections\n      */\n-    public boolean contains(Object obj) {\n-        for (Collection<? extends E> item : all) {\n+    public boolean contains(final Object obj) {\n+        for (final Collection<? extends E> item : all) {\n             if (item.contains(obj)) {\n                 return true;\n             }\n         if (all.isEmpty()) {\n             return EmptyIterator.<E>emptyIterator();\n         }\n-        IteratorChain<E> chain = new IteratorChain<E>();\n-        for (Collection<? extends E> item : all) {\n+        final IteratorChain<E> chain = new IteratorChain<E>();\n+        for (final Collection<? extends E> item : all) {\n             chain.addIterator(item.iterator());\n         }\n         return chain;\n     public Object[] toArray() {\n         final Object[] result = new Object[size()];\n         int i = 0;\n-        for (Iterator<E> it = iterator(); it.hasNext(); i++) {\n+        for (final Iterator<E> it = iterator(); it.hasNext(); i++) {\n             result[i] = it.next();\n         }\n         return result;\n      * @return an array of all the elements in the collection\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public <T> T[] toArray(T[] array) {\n-        int size = size();\n+    public <T> T[] toArray(final T[] array) {\n+        final int size = size();\n         Object[] result = null;\n         if (array.length >= size) {\n             result = array;\n         }\n \n         int offset = 0;\n-        for (Collection<? extends E> item : all) {\n-            for (E e : item) {\n+        for (final Collection<? extends E> item : all) {\n+            for (final E e : item) {\n                 result[offset++] = e;\n             }\n         }\n      * @throws NullPointerException if the object cannot be added because its null\n      * @throws IllegalArgumentException if the object cannot be added\n      */\n-    public boolean add(E obj) {\n+    public boolean add(final E obj) {\n         if (mutator == null) {\n            throw new UnsupportedOperationException(\n                \"add() is not supported on CompositeCollection without a CollectionMutator strategy\");\n      * @throws NullPointerException if the object cannot be removed because its null\n      * @throws IllegalArgumentException if the object cannot be removed\n      */\n-    public boolean remove(Object obj) {\n+    public boolean remove(final Object obj) {\n         if (mutator == null) {\n             throw new UnsupportedOperationException(\n                 \"remove() is not supported on CompositeCollection without a CollectionMutator strategy\");\n      * @param coll  the collection to check for\n      * @return true if all elements contained\n      */\n-    public boolean containsAll(Collection<?> coll) {\n-        for (Object item : coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object item : coll) {\n             if (contains(item) == false) {\n                 return false;\n             }\n      * @throws NullPointerException if the object cannot be added because its null\n      * @throws IllegalArgumentException if the object cannot be added\n      */\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         if (mutator == null) {\n             throw new UnsupportedOperationException(\n                 \"addAll() is not supported on CompositeCollection without a CollectionMutator strategy\");\n      * @return true if the collection was modified\n      * @throws UnsupportedOperationException if removeAll is unsupported\n      */\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         if (coll.size() == 0) {\n             return false;\n         }\n         boolean changed = false;\n-        for (Collection<? extends E> item : all) {\n+        for (final Collection<? extends E> item : all) {\n             changed |= item.removeAll(coll);\n         }\n         return changed;\n      */\n     public boolean retainAll(final Collection<?> coll) {\n         boolean changed = false;\n-        for (Collection<? extends E> item : all) {\n+        for (final Collection<? extends E> item : all) {\n             changed |= item.retainAll(coll);\n         }\n         return changed;\n      * @throws UnsupportedOperationException if clear is unsupported\n      */\n     public void clear() {\n-        for (Collection<? extends E> coll : all) {\n+        for (final Collection<? extends E> coll : all) {\n             coll.clear();\n         }\n     }\n      *\n      * @param mutator  the mutator to use\n      */\n-    public void setMutator(CollectionMutator<E> mutator) {\n+    public void setMutator(final CollectionMutator<E> mutator) {\n         this.mutator = mutator;\n     }\n \n      *\n      * @param compositeCollection  the Collection to be appended to the composite\n      */\n-    public void addComposited(Collection<E> compositeCollection) {\n+    public void addComposited(final Collection<E> compositeCollection) {\n         all.add(compositeCollection);\n     }\n \n      * @param compositeCollection1  the Collection to be appended to the composite\n      * @param compositeCollection2  the Collection to be appended to the composite\n      */\n-    public void addComposited(Collection<E> compositeCollection1, Collection<E> compositeCollection2) {\n+    public void addComposited(final Collection<E> compositeCollection1, final Collection<E> compositeCollection2) {\n         all.add(compositeCollection1);\n         all.add(compositeCollection2);\n     }\n      *\n      * @param compositeCollections  the Collections to be appended to the composite\n      */\n-    public void addComposited(Collection<E>[] compositeCollections) {\n+    public void addComposited(final Collection<E>[] compositeCollections) {\n         all.addAll(Arrays.asList(compositeCollections));\n     }\n \n      *\n      * @param coll  collection to be removed\n      */\n-    public void removeComposited(Collection<E> coll) {\n+    public void removeComposited(final Collection<E> coll) {\n         all.remove(coll);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/IndexedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/IndexedCollection.java\n      * @param keyTransformer  {@link Transformer} for generating index keys\n      * @param map  map to use as index\n      */\n-    public IndexedCollection(Collection<C> coll, Transformer<C, K> keyTransformer, HashMap<K, C> map) {\n+    public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer, final HashMap<K, C> map) {\n         super(coll);\n         this.keyTransformer = keyTransformer;\n         this.index = new HashMap<K, C>();\n     }\n \n     @Override\n-    public boolean add(C object) {\n+    public boolean add(final C object) {\n         final boolean added = super.add(object);\n         if (added) {\n             addToIndex(object);\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends C> coll) {\n+    public boolean addAll(final Collection<? extends C> coll) {\n         boolean changed = false;\n-        for (C c: coll) {\n+        for (final C c: coll) {\n             changed |= add(c);\n         }\n         return changed;\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public boolean contains(Object object) {\n+    public boolean contains(final Object object) {\n         return index.containsKey(keyTransformer.transform((C) object));\n     }\n \n      * Note: uses the index for fast lookup\n      */\n     @Override\n-    public boolean containsAll(Collection<?> coll) {\n-        for (Object o : coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object o : coll) {\n             if (!contains(o)) {\n                 return false;\n             }\n      * @param key  key to look up\n      * @return element found\n      */\n-    public C get(K key) {\n+    public C get(final K key) {\n         return index.get(key);\n     }\n \n      */\n     public void reindex() {\n         index.clear();\n-        for (C c : decorated()) {\n+        for (final C c : decorated()) {\n             addToIndex(c);\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         final boolean removed = super.remove(object);\n         if (removed) {\n             removeFromIndex((C) object);\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         boolean changed = false;\n-        for (Object o : coll) {\n+        for (final Object o : coll) {\n             changed |= remove(o);\n         }\n         return changed;\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         final boolean changed = super.retainAll(coll);\n         if (changed) {\n             reindex();\n      *\n      * @param object the object to index\n      */\n-    private void addToIndex(C object) {\n+    private void addToIndex(final C object) {\n         final C existingObject = index.put(keyTransformer.transform(object), object);\n         if (existingObject != null) {\n             throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n      *\n      * @param object the object to remove\n      */\n-    private void removeFromIndex(C object) {\n+    private void removeFromIndex(final C object) {\n         index.remove(keyTransformer.transform(object));\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/PredicatedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/PredicatedCollection.java\n      * @throws IllegalArgumentException if collection or predicate is null\n      * @throws IllegalArgumentException if the collection contains invalid elements\n      */\n-    public static <T> PredicatedCollection<T> predicatedCollection(Collection<T> coll,\n-                                                                   Predicate<? super T> predicate) {\n+    public static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll,\n+                                                                   final Predicate<? super T> predicate) {\n         return new PredicatedCollection<T>(coll, predicate);\n     }\n \n      * @throws IllegalArgumentException if collection or predicate is null\n      * @throws IllegalArgumentException if the collection contains invalid elements\n      */\n-    protected PredicatedCollection(Collection<E> coll, Predicate<? super E> predicate) {\n+    protected PredicatedCollection(final Collection<E> coll, final Predicate<? super E> predicate) {\n         super(coll);\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n         this.predicate = predicate;\n-        for (E item : coll) {\n+        for (final E item : coll) {\n             validate(item);\n         }\n     }\n      * @param object  the object being added\n      * @throws IllegalArgumentException if the add is invalid\n      */\n-    protected void validate(E object) {\n+    protected void validate(final E object) {\n         if (predicate.evaluate(object) == false) {\n             throw new IllegalArgumentException(\"Cannot add Object '\" + object + \"' - Predicate '\" +\n                                                predicate + \"' rejected it\");\n      * @throws IllegalArgumentException if the add is invalid\n      */\n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         validate(object);\n         return decorated().add(object);\n     }\n      * @throws IllegalArgumentException if the add is invalid\n      */\n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n-        for (E item : coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        for (final E item : coll) {\n             validate(item);\n         }\n         return decorated().addAll(coll);\n--- a/src/main/java/org/apache/commons/collections/collection/SynchronizedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/SynchronizedCollection.java\n      * @return a new synchronized collection\n      * @throws IllegalArgumentException if collection is null\n      */\n-    public static <T> SynchronizedCollection<T> synchronizedCollection(Collection<T> coll) {\n+    public static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n         return new SynchronizedCollection<T>(coll);\n     }\n \n      * @param collection  the collection to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected SynchronizedCollection(Collection<E> collection) {\n+    protected SynchronizedCollection(final Collection<E> collection) {\n         if (collection == null) {\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n      * @param lock  the lock object to use, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected SynchronizedCollection(Collection<E> collection, Object lock) {\n+    protected SynchronizedCollection(final Collection<E> collection, final Object lock) {\n         if (collection == null) {\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n \n     //-----------------------------------------------------------------------\n     \n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         synchronized (lock) {\n             return decorated().add(object);\n         }\n     }\n \n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         synchronized (lock) {\n             return decorated().addAll(coll);\n         }\n         }\n     }\n \n-    public boolean contains(Object object) {\n+    public boolean contains(final Object object) {\n         synchronized (lock) {\n             return decorated().contains(object);\n         }\n     }\n \n-    public boolean containsAll(Collection<?> coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n         synchronized (lock) {\n             return decorated().containsAll(coll);\n         }\n         }\n     }\n \n-    public <T> T[] toArray(T[] object) {\n+    public <T> T[] toArray(final T[] object) {\n         synchronized (lock) {\n             return decorated().toArray(object);\n         }\n     }\n \n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         synchronized (lock) {\n             return decorated().remove(object);\n         }\n     }\n \n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         synchronized (lock) {\n             return decorated().removeAll(coll);\n         }\n     }\n \n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         synchronized (lock) {\n             return decorated().retainAll(coll);\n         }\n     }\n \n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         synchronized (lock) {\n             if (object == this) {\n                 return true;\n--- a/src/main/java/org/apache/commons/collections/collection/TransformedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/TransformedCollection.java\n      * @return a new transformed collection\n      * @throws IllegalArgumentException if collection or transformer is null\n      */\n-    public static <E> TransformedCollection<E> transformingCollection(Collection<E> coll,\n-                                                                      Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll,\n+                                                                      final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedCollection<E>(coll, transformer);\n     }\n \n      * @throws IllegalArgumentException if collection or transformer is null\n      * @since 3.3\n      */\n-    public static <E> TransformedCollection<E> transformedCollection(Collection<E> collection,\n-                                                                     Transformer<? super E, ? extends E> transformer) {\n-        TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n+    public static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection,\n+                                                                     final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n         // null collection & transformer are disallowed by the constructor call above \n         if (collection.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // collection is of type E\n+            final\n             E[] values = (E[]) collection.toArray();\n             collection.clear();\n-            for (E value : values) {\n+            for (final E value : values) {\n                 decorated.decorated().add(transformer.transform(value));\n             }\n         }\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if collection or transformer is null\n      */\n-    protected TransformedCollection(Collection<E> coll, Transformer<? super E, ? extends E> transformer) {\n+    protected TransformedCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n         super(coll);\n         if (transformer == null) {\n             throw new IllegalArgumentException(\"Transformer must not be null\");\n      * @param object  the object to transform\n      * @return a transformed object\n      */\n-    protected E transform(E object) {\n+    protected E transform(final E object) {\n         return transformer.transform(object);\n     }\n \n      * @param coll  the collection to transform\n      * @return a transformed object\n      */\n-    protected Collection<E> transform(Collection<? extends E> coll) {\n-        List<E> list = new ArrayList<E>(coll.size());\n-        for (E item : coll) {\n+    protected Collection<E> transform(final Collection<? extends E> coll) {\n+        final List<E> list = new ArrayList<E>(coll.size());\n+        for (final E item : coll) {\n             list.add(transform(item));\n         }\n         return list;\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         return decorated().add(transform(object));\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         return decorated().addAll(transform(coll));\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java\n      * @return a new unmodifiable bounded collection\n      * @throws IllegalArgumentException if {@code coll} is {@code null}\n      */\n-    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(BoundedCollection<E> coll) {\n+    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<E> coll) {\n         return new UnmodifiableBoundedCollection<E>(coll);\n     }\n \n      * @param coll  the collection to decorate, must not be null\n      * @throws IllegalArgumentException if coll is null\n      */\n-    private UnmodifiableBoundedCollection(BoundedCollection<E> coll) {\n+    private UnmodifiableBoundedCollection(final BoundedCollection<E> coll) {\n         super(coll);\n     }\n \n     }\n \n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/UnmodifiableCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/UnmodifiableCollection.java\n      * @return an unmodifiable collection\n      * @throws IllegalArgumentException if collection is null\n      */\n-    public static <T> Collection<T> unmodifiableCollection(Collection<T> coll) {\n+    public static <T> Collection<T> unmodifiableCollection(final Collection<T> coll) {\n         if (coll instanceof Unmodifiable) {\n             return coll;\n         }\n      * @param coll  the collection to decorate, must not be null\n      * @throws IllegalArgumentException if collection is null\n      */\n-    private UnmodifiableCollection(Collection<E> coll) {\n+    private UnmodifiableCollection(final Collection<E> coll) {\n         super(coll);\n     }\n \n     }\n \n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/main/java/org/apache/commons/collections/comparators/BooleanComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/BooleanComparator.java\n      * <code>true</code> <code>Boolean</code>s before <code>false</code>\n      * @return a singleton BooleanComparator instance\n      */\n-    public static BooleanComparator booleanComparator(boolean trueFirst) {\n+    public static BooleanComparator booleanComparator(final boolean trueFirst) {\n         return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n     }\n \n      * @param trueFirst when <code>true</code>, sort \n      *  <code>true</code> boolean values before <code>false</code>\n      */\n-    public BooleanComparator(boolean trueFirst) {\n+    public BooleanComparator(final boolean trueFirst) {\n         this.trueFirst = trueFirst;\n     }\n \n      * @return negative if obj1 is less, positive if greater, zero if equal\n      * @throws NullPointerException when either argument <code>null</code>\n      */\n-    public int compare(Boolean b1, Boolean b2) {\n-        boolean v1 = b1.booleanValue();\n-        boolean v2 = b2.booleanValue();\n+    public int compare(final Boolean b1, final Boolean b2) {\n+        final boolean v1 = b1.booleanValue();\n+        final boolean v2 = b2.booleanValue();\n \n         return (v1 ^ v2) ? ( (v1 ^ trueFirst) ? 1 : -1 ) : 0;\n     }\n      */\n     @Override\n     public int hashCode() {\n-        int hash = \"BooleanComparator\".hashCode();\n+        final int hash = \"BooleanComparator\".hashCode();\n         return trueFirst ? -1 * hash : hash;\n     }\n \n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         return (this == object) || \n                ((object instanceof BooleanComparator) && \n                 (this.trueFirst == ((BooleanComparator)object).trueFirst));\n--- a/src/main/java/org/apache/commons/collections/comparators/ComparableComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/ComparableComparator.java\n      * @throws ClassCastException if <i>obj1</i> is not a <code>Comparable</code>,\n      *         or when <code>((Comparable)obj1).compareTo(obj2)</code> does\n      */\n-    public int compare(E obj1, E obj2) {\n+    public int compare(final E obj1, final E obj2) {\n         return obj1.compareTo(obj2);\n     }\n \n      * @since 3.0\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         return this == object || \n                null != object && object.getClass().equals(this.getClass());\n     }\n--- a/src/main/java/org/apache/commons/collections/comparators/ComparatorChain.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/ComparatorChain.java\n      *\n      * @param comparator First comparator in the Comparator chain\n      */\n-    public ComparatorChain(Comparator<E> comparator) {\n+    public ComparatorChain(final Comparator<E> comparator) {\n         this(comparator, false);\n     }\n \n      * @param comparator First Comparator in the ComparatorChain\n      * @param reverse    false = forward sort; true = reverse sort\n      */\n-    public ComparatorChain(Comparator<E> comparator, boolean reverse) {\n+    public ComparatorChain(final Comparator<E> comparator, final boolean reverse) {\n         comparatorChain = new ArrayList<Comparator<E>>(1);\n         comparatorChain.add(comparator);\n         orderingBits = new BitSet(1);\n      * @param list   List of Comparators\n      * @see #ComparatorChain(List,BitSet)\n      */\n-    public ComparatorChain(List<Comparator<E>> list) {\n+    public ComparatorChain(final List<Comparator<E>> list) {\n         this(list, new BitSet(list.size()));\n     }\n \n      * @param bits   Sort order for each Comparator.  Extra bits are ignored,\n      *               unless extra Comparators are added by another method.\n      */\n-    public ComparatorChain(List<Comparator<E>> list, BitSet bits) {\n+    public ComparatorChain(final List<Comparator<E>> list, final BitSet bits) {\n         comparatorChain = list;\n         orderingBits = bits;\n     }\n      *\n      * @param comparator Comparator with the forward sort order\n      */\n-    public void addComparator(Comparator<E> comparator) {\n+    public void addComparator(final Comparator<E> comparator) {\n         addComparator(comparator, false);\n     }\n \n      * @param comparator Comparator to add to the end of the chain\n      * @param reverse    false = forward sort order; true = reverse sort order\n      */\n-    public void addComparator(Comparator<E> comparator, boolean reverse) {\n+    public void addComparator(final Comparator<E> comparator, final boolean reverse) {\n         checkLocked();\n \n         comparatorChain.add(comparator);\n      * @exception IndexOutOfBoundsException\n      *                   if index &lt; 0 or index &gt;= size()\n      */\n-    public void setComparator(int index, Comparator<E> comparator) throws IndexOutOfBoundsException {\n+    public void setComparator(final int index, final Comparator<E> comparator) throws IndexOutOfBoundsException {\n         setComparator(index, comparator, false);\n     }\n \n      * @param comparator Comparator to set\n      * @param reverse    false = forward sort order; true = reverse sort order\n      */\n-    public void setComparator(int index, Comparator<E> comparator, boolean reverse) {\n+    public void setComparator(final int index, final Comparator<E> comparator, final boolean reverse) {\n         checkLocked();\n \n         comparatorChain.set(index,comparator);\n      *\n      * @param index  Index of the ComparatorChain\n      */\n-    public void setForwardSort(int index) {\n+    public void setForwardSort(final int index) {\n         checkLocked();\n         orderingBits.clear(index);\n     }\n      *\n      * @param index  Index of the ComparatorChain\n      */\n-    public void setReverseSort(int index) {\n+    public void setReverseSort(final int index) {\n         checkLocked();\n         orderingBits.set(index);\n     }\n      *                   if the ComparatorChain does not contain at least one\n      *                   Comparator\n      */\n-    public int compare(E o1, E o2) throws UnsupportedOperationException {\n+    public int compare(final E o1, final E o2) throws UnsupportedOperationException {\n         if (isLocked == false) {\n             checkChainIntegrity();\n             isLocked = true;\n         }\n \n         // iterate over all comparators in the chain\n-        Iterator<Comparator<E>> comparators = comparatorChain.iterator();\n+        final Iterator<Comparator<E>> comparators = comparatorChain.iterator();\n         for (int comparatorIndex = 0; comparators.hasNext(); ++comparatorIndex) {\n \n-            Comparator<E> comparator = comparators.next();\n+            final Comparator<E> comparator = comparators.next();\n             int retval = comparator.compare(o1,o2);\n             if (retval != 0) {\n                 // invert the order if it is a reverse sort\n      * @since 3.0\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (this == object) {\n             return true;\n         }\n             return false;\n         }\n         if (object.getClass().equals(this.getClass())) {\n-            ComparatorChain<?> chain = (ComparatorChain<?>) object;\n+            final ComparatorChain<?> chain = (ComparatorChain<?>) object;\n             return (null == orderingBits ? null == chain.orderingBits : orderingBits\n                     .equals(chain.orderingBits)) && (null == comparatorChain ? null == chain.comparatorChain\n                     : comparatorChain.equals(chain.comparatorChain));\n--- a/src/main/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/FixedOrderComparator.java\n      * @param items  the items that the comparator can compare in order\n      * @throws IllegalArgumentException if the array is null\n      */\n-    public FixedOrderComparator(T[] items) {\n+    public FixedOrderComparator(final T[] items) {\n         super();\n         if (items == null) {\n             throw new IllegalArgumentException(\"The list of items must not be null\");\n         }\n-        for (T item : items) {\n+        for (final T item : items) {\n             add(item);\n         }\n     }\n      * @param items  the items that the comparator can compare in order\n      * @throws IllegalArgumentException if the list is null\n      */\n-    public FixedOrderComparator(List<T> items) {\n+    public FixedOrderComparator(final List<T> items) {\n         super();\n         if (items == null) {\n             throw new IllegalArgumentException(\"The list of items must not be null\");\n         }\n-        for (T t : items) {\n+        for (final T t : items) {\n             add(t);\n         }\n     }\n      * @throws UnsupportedOperationException if a comparison has been performed\n      * @throws IllegalArgumentException if the unknown flag is not valid\n      */\n-    public void setUnknownObjectBehavior(UnknownObjectBehavior unknownObjectBehavior) {\n+    public void setUnknownObjectBehavior(final UnknownObjectBehavior unknownObjectBehavior) {\n         checkLocked();\n         if (unknownObjectBehavior == null) {\n             throw new IllegalArgumentException(\"Unknown object behavior must not be null\");\n      *  it was already known to the Comparator.\n      * @throws UnsupportedOperationException if a comparison has already been made\n      */\n-    public boolean add(T obj) {\n+    public boolean add(final T obj) {\n         checkLocked();\n-        Integer position = map.put(obj, new Integer(counter++));\n+        final Integer position = map.put(obj, new Integer(counter++));\n         return position == null;\n     }\n \n      *  Comparator's set of known objects.\n      * @throws UnsupportedOperationException if a comparison has already been made\n      */\n-    public boolean addAsEqual(T existingObj, T newObj) {\n+    public boolean addAsEqual(final T existingObj, final T newObj) {\n         checkLocked();\n-        Integer position = map.get(existingObj);\n+        final Integer position = map.get(existingObj);\n         if (position == null) {\n             throw new IllegalArgumentException(existingObj + \" not known to \" + this);\n         }\n-        Integer result = map.put(newObj, position);\n+        final Integer result = map.put(newObj, position);\n         return result == null;\n     }\n \n      *  to this Comparator and an alternative behavior has not been set\n      *  via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}.\n      */\n-    public int compare(T obj1, T obj2) {\n+    public int compare(final T obj1, final T obj2) {\n         isLocked = true;\n-        Integer position1 = map.get(obj1);\n-        Integer position2 = map.get(obj2);\n+        final Integer position1 = map.get(obj1);\n+        final Integer position2 = map.get(obj2);\n         if (position1 == null || position2 == null) {\n             switch (unknownObjectBehavior) {\n             case BEFORE:\n             case AFTER:\n                 return position1 == null ? position2 == null ? 0 : 1 : -1;\n             case EXCEPTION:\n-                Object unknownObj = position1 == null ? obj1 : obj2;\n+                final Object unknownObj = position1 == null ? obj1 : obj2;\n                 throw new IllegalArgumentException(\"Attempting to compare unknown object \"\n                         + unknownObj);\n             default: //could be null\n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (this == object) {\n             return true;\n         }\n             return false;\n         }\n         if (object.getClass().equals(this.getClass())) {\n-            FixedOrderComparator<?> comp = (FixedOrderComparator<?>) object;\n+            final FixedOrderComparator<?> comp = (FixedOrderComparator<?>) object;\n             return null == map ? null == comp.map : map.equals(comp.map) &&\n                     null == unknownObjectBehavior ? null == comp.unknownObjectBehavior :\n                         unknownObjectBehavior == comp.unknownObjectBehavior &&\n--- a/src/main/java/org/apache/commons/collections/comparators/NullComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/NullComparator.java\n      *  @exception NullPointerException if <code>nonNullComparator</code> is\n      *  <code>null</code>\n      **/\n-    public NullComparator(Comparator<E> nonNullComparator) {\n+    public NullComparator(final Comparator<E> nonNullComparator) {\n         this(nonNullComparator, true);\n     }\n \n      *  non-<code>null</code> object.\n      **/\n     @SuppressWarnings(\"unchecked\")\n-    public NullComparator(boolean nullsAreHigh) {\n+    public NullComparator(final boolean nullsAreHigh) {\n         this(ComparatorUtils.NATURAL_COMPARATOR, nullsAreHigh);\n     }\n     \n      *  @exception NullPointerException if <code>nonNullComparator</code> is\n      *  <code>null</code>\n      **/\n-    public NullComparator(Comparator<E> nonNullComparator, boolean nullsAreHigh) {\n+    public NullComparator(final Comparator<E> nonNullComparator, final boolean nullsAreHigh) {\n         this.nonNullComparator = nonNullComparator;\n         this.nullsAreHigh = nullsAreHigh;\n         \n      *  \"higher\" than (greater than, after, etc.) <code>o2</code>; or\n      *  <code>0</code> if <code>o1</code> and <code>o2</code> are equal.\n      **/\n-    public int compare(E o1, E o2) {\n+    public int compare(final E o1, final E o2) {\n         if(o1 == o2) { return 0; }\n         if(o1 == null) { return this.nullsAreHigh ? 1 : -1; }\n         if(o2 == null) { return this.nullsAreHigh ? -1 : 1; }\n      *  non-<code>null</code> object comparators.\n      **/\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if(obj == null) { return false; }\n         if(obj == this) { return true; }\n         if(!obj.getClass().equals(this.getClass())) { return false; }\n \n-        NullComparator<?> other = (NullComparator<?>) obj;\n+        final NullComparator<?> other = (NullComparator<?>) obj;\n \n         return this.nullsAreHigh == other.nullsAreHigh &&\n                 this.nonNullComparator.equals(other.nonNullComparator);\n--- a/src/main/java/org/apache/commons/collections/comparators/ReverseComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/ReverseComparator.java\n      * @param comparator Comparator to reverse\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public ReverseComparator(Comparator<E> comparator) {\n+    public ReverseComparator(final Comparator<E> comparator) {\n         this.comparator = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n     }\n \n      * @param obj2  the second object to compare\n      * @return negative if obj1 is less, positive if greater, zero if equal\n      */\n-    public int compare(E obj1, E obj2) {\n+    public int compare(final E obj1, final E obj2) {\n         return comparator.compare(obj2, obj1);\n     }\n \n      * @since 3.0\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (this == object) {\n             return true;\n         }\n             return false;\n         }\n         if (object.getClass().equals(this.getClass())) {\n-            ReverseComparator<?> thatrc = (ReverseComparator<?>) object;\n+            final ReverseComparator<?> thatrc = (ReverseComparator<?>) object;\n             return comparator.equals(thatrc.comparator);\n         }\n         return false;\n--- a/src/main/java/org/apache/commons/collections/comparators/TransformingComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/TransformingComparator.java\n      * @param transformer what will transform the arguments to <code>compare</code>\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public TransformingComparator(Transformer<? super E, ? extends E> transformer) {\n+    public TransformingComparator(final Transformer<? super E, ? extends E> transformer) {\n         this(transformer, ComparatorUtils.NATURAL_COMPARATOR);\n     }\n \n      * @param transformer  what will transform the arguments to <code>compare</code>\n      * @param decorated  the decorated Comparator\n      */\n-    public TransformingComparator(Transformer<? super E, ? extends E> transformer, Comparator<E> decorated) {\n+    public TransformingComparator(final Transformer<? super E, ? extends E> transformer, final Comparator<E> decorated) {\n         this.decorated = decorated;\n         this.transformer = transformer;\n     }\n      * @param obj2  the second object to transform then compare\n      * @return negative if obj1 is less, positive if greater, zero if equal\n      */\n-    public int compare(E obj1, E obj2) {\n-        E value1 = this.transformer.transform(obj1);\n-        E value2 = this.transformer.transform(obj2);\n+    public int compare(final E obj1, final E obj2) {\n+        final E value1 = this.transformer.transform(obj1);\n+        final E value2 = this.transformer.transform(obj2);\n         return this.decorated.compare(value1, value2);\n     }\n \n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (this == object) {\n             return true;\n         }\n             return false;\n         }\n         if (object.getClass().equals(this.getClass())) {\n-            TransformingComparator<?> comp = (TransformingComparator<?>) object;\n+            final TransformingComparator<?> comp = (TransformingComparator<?>) object;\n             return null == decorated ? null == comp.decorated : decorated.equals(comp.decorated) &&\n                     null == transformer ? null == comp.transformer : transformer.equals(comp.transformer);\n         }\n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/DeleteCommand.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/DeleteCommand.java\n      *\n      * @param object  the object of the first sequence that should be deleted\n      */\n-    public DeleteCommand(T object) {\n+    public DeleteCommand(final T object) {\n         super(object);\n     }\n \n      * @param visitor  the visitor to be accepted\n      */    \n     @Override\n-    public void accept(CommandVisitor<T> visitor) {\n+    public void accept(final CommandVisitor<T> visitor) {\n         visitor.visitDeleteCommand(object);\n     }    \n }\n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/EditCommand.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/EditCommand.java\n      * @param object  reference to the object associated with this command, this\n      *   refers to an element of one of the sequences being compared\n      */\n-    protected EditCommand(T object) {\n+    protected EditCommand(final T object) {\n         this.object = object;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/EditScript.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/EditScript.java\n public class EditScript<T> {\n \n     /** Container for the commands. */\n-    private List<EditCommand<T>> commands;\n+    private final List<EditCommand<T>> commands;\n \n     /** Length of the longest common subsequence. */\n     private int lcsLength;\n      * \n      * @param command  command to add\n      */\n-    public void append(KeepCommand<T> command) {\n+    public void append(final KeepCommand<T> command) {\n         commands.add(command);\n         ++lcsLength;\n     }\n      * \n      * @param command  command to add\n      */\n-    public void append(InsertCommand<T> command) {\n+    public void append(final InsertCommand<T> command) {\n         commands.add(command);\n         ++modifications;\n     }\n      * \n      * @param command  command to add\n      */\n-    public void append(DeleteCommand<T> command) {\n+    public void append(final DeleteCommand<T> command) {\n         commands.add(command);\n         ++modifications;\n     }\n      * \n      * @param visitor  the visitor that will visit all commands in turn\n      */\n-    public void visit(CommandVisitor<T> visitor) {\n-        for (EditCommand<T> command : commands) {\n+    public void visit(final CommandVisitor<T> visitor) {\n+        for (final EditCommand<T> command : commands) {\n             command.accept(visitor);\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/InsertCommand.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/InsertCommand.java\n      * \n      * @param object  the object of the second sequence that should be inserted\n      */\n-    public InsertCommand(T object) {\n+    public InsertCommand(final T object) {\n         super(object);\n     }\n \n      * @param visitor  the visitor to be accepted\n      */\n     @Override\n-    public void accept(CommandVisitor<T> visitor) {\n+    public void accept(final CommandVisitor<T> visitor) {\n         visitor.visitInsertCommand(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/KeepCommand.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/KeepCommand.java\n      *   reference to the instance in the first sequence which is known\n      *   to be equal to an instance in the second sequence)\n      */\n-    public KeepCommand(T object) {\n+    public KeepCommand(final T object) {\n         super(object);\n     }\n \n      * @param visitor  the visitor to be accepted\n      */\n     @Override\n-    public void accept(CommandVisitor<T> visitor) {\n+    public void accept(final CommandVisitor<T> visitor) {\n         visitor.visitKeepCommand(object);\n     }\n }\n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/ReplacementsFinder.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/ReplacementsFinder.java\n  */\n public class ReplacementsFinder<T> implements CommandVisitor<T> {\n \n-    private List<T> pendingInsertions;\n-    private List<T> pendingDeletions;\n+    private final List<T> pendingInsertions;\n+    private final List<T> pendingDeletions;\n     private int     skipped;\n \n     /** Handler to call when synchronized sequences are found. */\n-    private ReplacementsHandler<T> handler;\n+    private final ReplacementsHandler<T> handler;\n \n     /**\n      * Simple constructor. Creates a new instance of {@link ReplacementsFinder}.\n      *\n      * @param handler  handler to call when synchronized sequences are found\n      */\n-    public ReplacementsFinder(ReplacementsHandler<T> handler) {\n+    public ReplacementsFinder(final ReplacementsHandler<T> handler) {\n         pendingInsertions = new ArrayList<T>();\n         pendingDeletions  = new ArrayList<T>();\n         skipped           = 0;\n      *\n      * @param object  object to insert\n      */\n-    public void visitInsertCommand(T object) {\n+    public void visitInsertCommand(final T object) {\n         pendingInsertions.add(object);\n     }\n \n      *\n      * @param object  synchronization object detected\n      */\n-    public void visitKeepCommand(T object) {\n+    public void visitKeepCommand(final T object) {\n         if (pendingDeletions.isEmpty() && pendingInsertions.isEmpty()) {\n             ++skipped;\n         } else {\n      *\n      * @param object  object to delete\n      */\n-    public void visitDeleteCommand(T object) {\n+    public void visitDeleteCommand(final T object) {\n         pendingDeletions.add(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/SequencesComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/SequencesComparator.java\n public class SequencesComparator<T> {\n \n     /** First sequence. */\n-    private List<T> sequence1;\n+    private final List<T> sequence1;\n \n     /** Second sequence. */\n-    private List<T> sequence2;\n+    private final List<T> sequence2;\n \n     /** Temporary variables. */\n-    private int[] vDown;\n-    private int[] vUp;\n+    private final int[] vDown;\n+    private final int[] vUp;\n \n     /**\n      * Simple constructor.\n      * @param sequence2\n      *            second sequence to be compared\n      */\n-    public SequencesComparator(List<T> sequence1, List<T> sequence2) {\n+    public SequencesComparator(final List<T> sequence1, final List<T> sequence2) {\n         this.sequence1 = sequence1;\n         this.sequence2 = sequence2;\n \n-        int size = sequence1.size() + sequence2.size() + 2;\n+        final int size = sequence1.size() + sequence2.size() + 2;\n         vDown = new int[size];\n         vUp   = new int[size];\n     }\n      * @param end2  the value of the end of the second sequence to be compared\n      * @return the snake built\n      */\n-    private Snake buildSnake(int start, int diag, int end1, int end2) {\n+    private Snake buildSnake(final int start, final int diag, final int end1, final int end2) {\n         int end = start;\n         while (end - diag < end2\n                 && end < end1\n      * @param end2  the end of the second sequence to be compared\n      * @return the middle snake\n      */\n-    private Snake getMiddleSnake(int start1, int end1, int start2, int end2) {\n+    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n         // Myers Algorithm\n         // Initialisations\n-        int m = end1 - start1;\n-        int n = end2 - start2;\n+        final int m = end1 - start1;\n+        final int n = end2 - start2;\n         if (m == 0 || n == 0) {\n             return null;\n         }\n \n-        int delta  = m - n;\n-        int sum    = n + m;\n-        int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n+        final int delta  = m - n;\n+        final int sum    = n + m;\n+        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n         vDown[1+offset] = start1;\n         vUp[1+offset]   = end1 + 1;\n \n             for (int k = -d; k <= d; k += 2) {\n                 // First step\n \n-                int i = k + offset;\n+                final int i = k + offset;\n                 if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                     vDown[i] = vDown[i+1];\n                 } else {\n             // Up\n             for (int k = delta - d; k <= delta + d; k += 2) {\n                 // First step\n-                int i = k + offset - delta;\n+                final int i = k + offset - delta;\n                 if (k == delta - d\n                         || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                     vUp[i] = vUp[i+1] - 1;\n      * @param end2  the end of the second sequence to be compared\n      * @param script the edited script\n      */\n-    private void buildScript(int start1, int end1, int start2, int end2,\n-                             EditScript<T> script) {\n-\n-        Snake middle = getMiddleSnake(start1, end1, start2, end2);\n+    private void buildScript(final int start1, final int end1, final int start2, final int end2,\n+                             final EditScript<T> script) {\n+\n+        final Snake middle = getMiddleSnake(start1, end1, start2, end2);\n \n         if (middle == null\n                 || middle.getStart() == end1 && middle.getDiag() == end1 - end2\n      *         sequences\n      */\n     public EditScript<T> getScript() {\n-        EditScript<T> script = new EditScript<T>();\n+        final EditScript<T> script = new EditScript<T>();\n         buildScript(0, sequence1.size(), 0, sequence2.size(), script);\n         return script;\n     }\n--- a/src/main/java/org/apache/commons/collections/comparators/sequence/Snake.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/sequence/Snake.java\n public class Snake {\n \n     /** Start index. */\n-    private int start;\n+    private final int start;\n \n     /** End index. */\n-    private int end;\n+    private final int end;\n \n     /** Diagonal number. */\n-    private int diag;\n+    private final int diag;\n \n     /**\n      * Simple constructor. Creates a new instance of Snake with default indices.\n      * @param end  end index of the snake\n      * @param diag  diagonal number\n      */ \n-    public Snake(int start, int end, int diag) {\n+    public Snake(final int start, final int end, final int diag) {\n         this.start = start;\n         this.end   = end;\n         this.diag  = diag;\n--- a/src/main/java/org/apache/commons/collections/functors/AllPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/AllPredicate.java\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> allPredicate(Predicate<? super T> ... predicates) {\n+    public static <T> Predicate<T> allPredicate(final Predicate<? super T> ... predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n             return truePredicate();\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> allPredicate(Collection<? extends Predicate<T>> predicates) {\n+    public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<T>> predicates) {\n         final Predicate<T>[] preds = validate(predicates);\n         if (preds.length == 0) {\n             return truePredicate();\n      *\n      * @param predicates  the predicates to check, not cloned, not null\n      */\n-    public AllPredicate(Predicate<? super T> ... predicates) {\n+    public AllPredicate(final Predicate<? super T> ... predicates) {\n         super();\n         iPredicates = predicates;\n     }\n      * @param object  the input object\n      * @return true if all decorated predicates return true\n      */\n-    public boolean evaluate(T object) {\n-        for (Predicate<? super T> iPredicate : iPredicates) {\n+    public boolean evaluate(final T object) {\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n             if (!iPredicate.evaluate(object)) {\n                 return false;\n             }\n--- a/src/main/java/org/apache/commons/collections/functors/AndPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/AndPredicate.java\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> andPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      */\n-    public AndPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public AndPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         super();\n         iPredicate1 = predicate1;\n         iPredicate2 = predicate2;\n      * @param object  the input object\n      * @return true if both decorated predicates return true\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n        return iPredicate1.evaluate(object) && iPredicate2.evaluate(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/AnyPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/AnyPredicate.java\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> anyPredicate(Predicate<? super T>... predicates) {\n+    public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n             return FalsePredicate.<T>falsePredicate();\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> anyPredicate(Collection<? extends Predicate<T>> predicates) {\n-        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+    public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         if (preds.length == 0) {\n             return FalsePredicate.<T>falsePredicate();\n         }\n      *\n      * @param predicates  the predicates to check, not cloned, not null\n      */\n-    public AnyPredicate(Predicate<? super T>[] predicates) {\n+    public AnyPredicate(final Predicate<? super T>[] predicates) {\n         super();\n         iPredicates = predicates;\n     }\n      * @param object  the input object\n      * @return true if any decorated predicate return true\n      */\n-    public boolean evaluate(T object) {\n-        for (Predicate<? super T> iPredicate : iPredicates) {\n+    public boolean evaluate(final T object) {\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n             if (iPredicate.evaluate(object)) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/collections/functors/CatchAndRethrowClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/CatchAndRethrowClosure.java\n      * @throws FunctorException (runtime) if the closure execution resulted in a\n      *             checked exception.\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         try {\n             executeAndThrow(input);\n-        } catch (RuntimeException ex) {\n+        } catch (final RuntimeException ex) {\n             throw ex;\n-        } catch (Throwable t) {\n+        } catch (final Throwable t) {\n             throw new FunctorException(t);\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/ChainedClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ChainedClosure.java\n      * @throws IllegalArgumentException if the closures array is null\n      * @throws IllegalArgumentException if any closure in the array is null\n      */\n-    public static <E> Closure<E> chainedClosure(Closure<? super E>... closures) {\n+    public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n         FunctorUtils.validate(closures);\n         if (closures.length == 0) {\n             return NOPClosure.<E>nopClosure();\n      * @throws IllegalArgumentException if any closure in the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> chainedClosure(Collection<Closure<E>> closures) {\n+    public static <E> Closure<E> chainedClosure(final Collection<Closure<E>> closures) {\n         if (closures == null) {\n             throw new IllegalArgumentException(\"Closure collection must not be null\");\n         }\n             return NOPClosure.<E>nopClosure();\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Closure<? super E>[] cmds = new Closure[closures.size()];\n+        final Closure<? super E>[] cmds = new Closure[closures.size()];\n         int i = 0;\n-        for (Closure<? super E> closure : closures) {\n+        for (final Closure<? super E> closure : closures) {\n             cmds[i++] = closure;\n         }\n         FunctorUtils.validate(cmds);\n      * \n      * @param closures  the closures to chain, not copied, no nulls\n      */\n-    public ChainedClosure(Closure<? super E>[] closures) {\n+    public ChainedClosure(final Closure<? super E>[] closures) {\n         super();\n         iClosures = closures;\n     }\n      * \n      * @param input  the input object passed to each closure\n      */\n-    public void execute(E input) {\n-        for (Closure<? super E> iClosure : iClosures) {\n+    public void execute(final E input) {\n+        for (final Closure<? super E> iClosure : iClosures) {\n             iClosure.execute(input);\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/ChainedTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ChainedTransformer.java\n      * @throws IllegalArgumentException if the transformers array is null\n      * @throws IllegalArgumentException if any transformer in the array is null\n      */\n-    public static <T> Transformer<T, T> chainedTransformer(Transformer<? super T, ? extends T>... transformers) {\n+    public static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n         FunctorUtils.validate(transformers);\n         if (transformers.length == 0) {\n             return NOPTransformer.<T>nopTransformer();\n      * @throws IllegalArgumentException if any transformer in the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Transformer<T, T> chainedTransformer(Collection<? extends Transformer<T, T>> transformers) {\n+    public static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<T, T>> transformers) {\n         if (transformers == null) {\n             throw new IllegalArgumentException(\"Transformer collection must not be null\");\n         }\n             return NOPTransformer.<T>nopTransformer();\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n+        final Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n         FunctorUtils.validate(cmds);\n         return new ChainedTransformer<T>(cmds);\n     }\n      * \n      * @param transformers  the transformers to chain, not copied, no nulls\n      */\n-    public ChainedTransformer(Transformer<? super T, ? extends T>[] transformers) {\n+    public ChainedTransformer(final Transformer<? super T, ? extends T>[] transformers) {\n         super();\n         iTransformers = transformers;\n     }\n      * @return the transformed result\n      */\n     public T transform(T object) {\n-        for (Transformer<? super T, ? extends T> iTransformer : iTransformers) {\n+        for (final Transformer<? super T, ? extends T> iTransformer : iTransformers) {\n             object = iTransformer.transform(object);\n         }\n         return object;\n--- a/src/main/java/org/apache/commons/collections/functors/CloneTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/CloneTransformer.java\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public T transform(T input) {\n+    public T transform(final T input) {\n         if (input == null) {\n             return null;\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/ClosureTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ClosureTransformer.java\n      * @return the <code>closure</code> transformer\n      * @throws IllegalArgumentException if the closure is null\n      */\n-    public static <T> Transformer<T, T> closureTransformer(Closure<? super T> closure) {\n+    public static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n         if (closure == null) {\n             throw new IllegalArgumentException(\"Closure must not be null\");\n         }\n      * \n      * @param closure  the closure to call, not null\n      */\n-    public ClosureTransformer(Closure<? super T> closure) {\n+    public ClosureTransformer(final Closure<? super T> closure) {\n         super();\n         iClosure = closure;\n     }\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public T transform(T input) {\n+    public T transform(final T input) {\n         iClosure.execute(input);\n         return input;\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if comparator is null\n      */\n-    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator) {\n+    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n         return comparatorPredicate(object, comparator, Criterion.EQUAL);\n     }\n \n      * @return the predicate\n      * @throws IllegalArgumentException if comparator is null of criterion is invalid\n      */\n-    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n+    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n         if (comparator == null) {\n             throw new IllegalArgumentException(\"Comparator must not be null.\");\n         }\n      * @param comparator  the comparator to use for comparison\n      * @param criterion  the criterion to use to evaluate comparison\n      */\n-    public ComparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n+    public ComparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n         super();\n         this.object = object;\n         this.comparator = comparator;\n      * \n      * @throws IllegalStateException if the criterion is invalid (really not possible)\n      */\n-    public boolean evaluate(T target) {\n+    public boolean evaluate(final T target) {\n \n         boolean result = false;\n-        int comparison = comparator.compare(object, target);\n+        final int comparison = comparator.compare(object, target);\n         switch (criterion) {\n         case EQUAL:\n             result = comparison == 0;\n--- a/src/main/java/org/apache/commons/collections/functors/ConstantFactory.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ConstantFactory.java\n      * @return the <code>constant</code> factory.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Factory<T> constantFactory(T constantToReturn) {\n+    public static <T> Factory<T> constantFactory(final T constantToReturn) {\n         if (constantToReturn == null) {\n             return (Factory<T>) NULL_INSTANCE;\n         }\n      * \n      * @param constantToReturn  the constant to return each time\n      */\n-    public ConstantFactory(T constantToReturn) {\n+    public ConstantFactory(final T constantToReturn) {\n         super();\n         iConstant = constantToReturn;\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/ConstantTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ConstantTransformer.java\n      * @param constantToReturn  the constant object to return each time in the factory\n      * @return the <code>constant</code> factory.\n      */\n-    public static <I, O> Transformer<I, O> constantTransformer(O constantToReturn) {\n+    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n         if (constantToReturn == null) {\n             return nullTransformer();\n         }\n      * \n      * @param constantToReturn  the constant to return each time\n      */\n-    public ConstantTransformer(O constantToReturn) {\n+    public ConstantTransformer(final O constantToReturn) {\n         super();\n         iConstant = constantToReturn;\n     }\n      * @param input  the input object which is ignored\n      * @return the stored constant\n      */\n-    public O transform(I input) {\n+    public O transform(final I input) {\n         return iConstant;\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof ConstantTransformer == false) {\n             return false;\n         }\n-        Object otherConstant = ((ConstantTransformer<?, ?>) obj).getConstant();\n+        final Object otherConstant = ((ConstantTransformer<?, ?>) obj).getConstant();\n         return otherConstant == getConstant() || otherConstant != null && otherConstant.equals(getConstant());\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/DefaultEquator.java\n+++ b/src/main/java/org/apache/commons/collections/functors/DefaultEquator.java\n     /**\n      * {@inheritDoc} Delegates to {@link Object#equals(Object)}.\n      */\n-    public boolean equate(T o1, T o2) {\n+    public boolean equate(final T o1, final T o2) {\n         return o1 == o2 || o1 != null && o1.equals(o2);\n     }\n \n      * @return <code>o.hashCode()</code> if <code>o</code> is non-\n      *         <code>null</code>, else {@link #HASHCODE_NULL}.\n      */\n-    public int hash(T o) {\n+    public int hash(final T o) {\n         return o == null ? HASHCODE_NULL : o.hashCode();\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> equalPredicate(T object) {\n+    public static <T> Predicate<T> equalPredicate(final T object) {\n         if (object == null) {\n             return nullPredicate();\n         }\n      * @throws IllegalArgumentException if the predicate is null\n      * @since 4.0\n      */\n-    public static <T> Predicate<T> equalPredicate(T object, Equator<T> equator) {\n+    public static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n         if (object == null) {\n             return nullPredicate();\n         }\n      * \n      * @param object  the object to compare to\n      */\n-    public EqualPredicate(T object) {\n+    public EqualPredicate(final T object) {\n         // do not use the DefaultEquator to keep backwards compatibility\n         // the DefaultEquator returns also true if the two object references are equal\n         this(object, null);\n      * @param equator  the equator to use for comparison\n      * @since 4.0\n      */\n-    public EqualPredicate(T object, Equator<T> equator) {\n+    public EqualPredicate(final T object, final Equator<T> equator) {\n         super();\n         iValue = object;\n         this.equator = equator;\n      * @param object  the input object\n      * @return true if input object equals stored value\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         if (equator != null) {\n             return equator.equate(iValue, object);\n         } else {\n--- a/src/main/java/org/apache/commons/collections/functors/ExceptionClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionClosure.java\n      * @param input  the input object\n      * @throws FunctorException always\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         throw new FunctorException(\"ExceptionClosure invoked\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionPredicate.java\n      * @return never\n      * @throws FunctorException always\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         throw new FunctorException(\"ExceptionPredicate invoked\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ExceptionTransformer.java\n      * @return never\n      * @throws FunctorException always\n      */\n-    public O transform(I input) {\n+    public O transform(final I input) {\n         throw new FunctorException(\"ExceptionTransformer invoked\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/FactoryTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/FactoryTransformer.java\n      * @return the <code>factory</code> transformer\n      * @throws IllegalArgumentException if the factory is null\n      */\n-    public static <I, O> Transformer<I, O> factoryTransformer(Factory<? extends O> factory) {\n+    public static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n         }\n      * \n      * @param factory  the factory to call, not null\n      */\n-    public FactoryTransformer(Factory<? extends O> factory) {\n+    public FactoryTransformer(final Factory<? extends O> factory) {\n         super();\n         iFactory = factory;\n     }\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public O transform(I input) {\n+    public O transform(final I input) {\n         return iFactory.create();\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/FalsePredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/FalsePredicate.java\n      * @param object  the input object\n      * @return false always\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         return false;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/ForClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ForClosure.java\n      * @return the <code>for</code> closure\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> forClosure(int count, Closure<? super E> closure) {\n+    public static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n         if (count <= 0 || closure == null) {\n             return NOPClosure.<E>nopClosure();\n         }\n      * @param count  the number of times to execute the closure\n      * @param closure  the closure to execute, not null\n      */\n-    public ForClosure(int count, Closure<? super E> closure) {\n+    public ForClosure(final int count, final Closure<? super E> closure) {\n         super();\n         iCount = count;\n         iClosure = closure;\n      * \n      * @param input  the input object\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         for (int i = 0; i < iCount; i++) {\n             iClosure.execute(input);\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/FunctorUtils.java\n+++ b/src/main/java/org/apache/commons/collections/functors/FunctorUtils.java\n      * @return the cloned predicates\n      */\n     @SuppressWarnings(\"unchecked\")\n-    static <T> Predicate<T>[] copy(Predicate<? super T>[] predicates) {\n+    static <T> Predicate<T>[] copy(final Predicate<? super T>[] predicates) {\n         if (predicates == null) {\n             return null;\n         }\n      * @return the coerced predicate.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    static <T> Predicate<T> coerce(Predicate<? super T> predicate){\n+    static <T> Predicate<T> coerce(final Predicate<? super T> predicate){\n         return (Predicate<T>) predicate;\n     }\n \n      *\n      * @param predicates  the predicates to validate\n      */\n-    static void validate(Predicate<?>[] predicates) {\n+    static void validate(final Predicate<?>[] predicates) {\n         if (predicates == null) {\n             throw new IllegalArgumentException(\"The predicate array must not be null\");\n         }\n      * @param predicates  the predicates to validate\n      * @return predicate array\n      */\n-    static <T> Predicate<T>[] validate(Collection<? extends Predicate<T>> predicates) {\n+    static <T> Predicate<T>[] validate(final Collection<? extends Predicate<T>> predicates) {\n         if (predicates == null) {\n             throw new IllegalArgumentException(\"The predicate collection must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n         @SuppressWarnings(\"unchecked\") // OK\n+        final\n         Predicate<T>[] preds = new Predicate[predicates.size()];\n         int i = 0;\n-        for (Predicate<T> predicate : predicates) {\n+        for (final Predicate<T> predicate : predicates) {\n             preds[i] = predicate;\n             if (preds[i] == null) {\n                 throw new IllegalArgumentException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n      * @return the cloned closures\n      */\n     @SuppressWarnings(\"unchecked\")\n-    static <E> Closure<E>[] copy(Closure<? super E>[] closures) {\n+    static <E> Closure<E>[] copy(final Closure<? super E>[] closures) {\n         if (closures == null) {\n             return null;\n         }\n      *\n      * @param closures  the closures to validate\n      */\n-    static void validate(Closure<?>[] closures) {\n+    static void validate(final Closure<?>[] closures) {\n         if (closures == null) {\n             throw new IllegalArgumentException(\"The closure array must not be null\");\n         }\n      * @return the coerced closure.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    static <T> Closure<T> coerce(Closure<? super T> closure){\n+    static <T> Closure<T> coerce(final Closure<? super T> closure){\n         return (Closure<T>) closure;\n     }\n \n      * @return a clone of the transformers\n      */\n     @SuppressWarnings(\"unchecked\")\n-    static <I, O> Transformer<I, O>[] copy(Transformer<? super I, ? extends O>[] transformers) {\n+    static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>[] transformers) {\n         if (transformers == null) {\n             return null;\n         }\n      *\n      * @param transformers  the transformers to validate\n      */\n-    static void validate(Transformer<?, ?>[] transformers) {\n+    static void validate(final Transformer<?, ?>[] transformers) {\n         if (transformers == null) {\n             throw new IllegalArgumentException(\"The transformer array must not be null\");\n         }\n      * @return the coerced transformer.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    static <I, O> Transformer<I, O> coerce(Transformer<? super I, ? extends O> transformer) {\n+    static <I, O> Transformer<I, O> coerce(final Transformer<? super I, ? extends O> transformer) {\n         return (Transformer<I, O>) transformer;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/IdentityPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/IdentityPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> identityPredicate(T object) {\n+    public static <T> Predicate<T> identityPredicate(final T object) {\n         if (object == null) {\n             return NullPredicate.<T>nullPredicate();\n         }\n      *\n      * @param object  the object to compare to\n      */\n-    public IdentityPredicate(T object) {\n+    public IdentityPredicate(final T object) {\n         super();\n         iValue = object;\n     }\n      * @param object  the input object\n      * @return true if input is the same object as the stored value\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         return iValue == object;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/IfClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/IfClosure.java\n      * @throws IllegalArgumentException if either argument is null\n      * @since 3.2\n      */\n-    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n         return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n     }\n \n      * @return the <code>if</code> closure\n      * @throws IllegalArgumentException if any argument is null\n      */\n-    public static <E> Closure<E> ifClosure(Predicate<? super E> predicate,\n-                                           Closure<? super E> trueClosure,\n-                                           Closure<? super E> falseClosure) {\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n+                                           final Closure<? super E> trueClosure,\n+                                           final Closure<? super E> falseClosure) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * @param trueClosure  closure used if true, not null\n      * @since 3.2\n      */\n-    public IfClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure) {\n+    public IfClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n         this(predicate, trueClosure, NOPClosure.INSTANCE);\n     }\n \n      * @param trueClosure  closure used if true, not null\n      * @param falseClosure  closure used if false, not null\n      */\n-    public IfClosure(Predicate<? super E> predicate, Closure<? super E> trueClosure, Closure<? super E> falseClosure) {\n+    public IfClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure, final Closure<? super E> falseClosure) {\n         super();\n         iPredicate = predicate;\n         iTrueClosure = trueClosure;\n      * \n      * @param input  the input object\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         if (iPredicate.evaluate(input)) {\n             iTrueClosure.execute(input);\n         } else {\n--- a/src/main/java/org/apache/commons/collections/functors/InstanceofPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/InstanceofPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the class is null\n      */\n-    public static Predicate<Object> instanceOfPredicate(Class<?> type) {\n+    public static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n         if (type == null) {\n             throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n         }\n      *\n      * @param type  the type to check for\n      */\n-    public InstanceofPredicate(Class<?> type) {\n+    public InstanceofPredicate(final Class<?> type) {\n         super();\n         iType = type;\n     }\n      * @param object  the input object\n      * @return true if input is of stored type\n      */\n-    public boolean evaluate(Object object) {\n+    public boolean evaluate(final Object object) {\n         return iType.isInstance(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/InstantiateFactory.java\n+++ b/src/main/java/org/apache/commons/collections/functors/InstantiateFactory.java\n      * @param args  the constructor arguments\n      * @return a new instantiate factory\n      */\n-    public static <T> Factory<T> instantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n         if (classToInstantiate == null) {\n             throw new IllegalArgumentException(\"Class to instantiate must not be null\");\n         }\n      * \n      * @param classToInstantiate  the class to instantiate\n      */\n-    public InstantiateFactory(Class<T> classToInstantiate) {\n+    public InstantiateFactory(final Class<T> classToInstantiate) {\n         super();\n         iClassToInstantiate = classToInstantiate;\n         iParamTypes = null;\n      * @param paramTypes  the constructor parameter types, not cloned\n      * @param args  the constructor arguments, not cloned\n      */\n-    public InstantiateFactory(Class<T> classToInstantiate, Class<?>[] paramTypes, Object[] args) {\n+    public InstantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n         super();\n         iClassToInstantiate = classToInstantiate;\n         iParamTypes = paramTypes;\n         try {\n             iConstructor = iClassToInstantiate.getConstructor(iParamTypes);\n \n-        } catch (NoSuchMethodException ex) {\n+        } catch (final NoSuchMethodException ex) {\n             throw new IllegalArgumentException(\"InstantiateFactory: The constructor must exist and be public \");\n         }\n     }\n \n         try {\n             return iConstructor.newInstance(iArgs);\n-        } catch (InstantiationException ex) {\n+        } catch (final InstantiationException ex) {\n             throw new FunctorException(\"InstantiateFactory: InstantiationException\", ex);\n-        } catch (IllegalAccessException ex) {\n+        } catch (final IllegalAccessException ex) {\n             throw new FunctorException(\"InstantiateFactory: Constructor must be public\", ex);\n-        } catch (InvocationTargetException ex) {\n+        } catch (final InvocationTargetException ex) {\n             throw new FunctorException(\"InstantiateFactory: Constructor threw an exception\", ex);\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/InstantiateTransformer.java\n      * @param paramTypes  the constructor parameter types, not cloned\n      * @param args  the constructor arguments, not cloned\n      */\n-    public InstantiateTransformer(Class<?>[] paramTypes, Object[] args) {\n+    public InstantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n         super();\n         iParamTypes = paramTypes;\n         iArgs = args;\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public T transform(Class<? extends T> input) {\n+    public T transform(final Class<? extends T> input) {\n         try {\n             if (input == null) {\n                 throw new FunctorException(\n                     \"InstantiateTransformer: Input object was not an instanceof Class, it was a null object\");\n             }\n-            Constructor<? extends T> con = input.getConstructor(iParamTypes);\n+            final Constructor<? extends T> con = input.getConstructor(iParamTypes);\n             return con.newInstance(iArgs);\n-        } catch (NoSuchMethodException ex) {\n+        } catch (final NoSuchMethodException ex) {\n             throw new FunctorException(\"InstantiateTransformer: The constructor must exist and be public \");\n-        } catch (InstantiationException ex) {\n+        } catch (final InstantiationException ex) {\n             throw new FunctorException(\"InstantiateTransformer: InstantiationException\", ex);\n-        } catch (IllegalAccessException ex) {\n+        } catch (final IllegalAccessException ex) {\n             throw new FunctorException(\"InstantiateTransformer: Constructor must be public\", ex);\n-        } catch (InvocationTargetException ex) {\n+        } catch (final InvocationTargetException ex) {\n             throw new FunctorException(\"InstantiateTransformer: Constructor threw an exception\", ex);\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/InvokerTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/InvokerTransformer.java\n      * @return an invoker transformer\n      * @since 3.1\n      */\n-    public static <I, O> Transformer<I, O> invokerTransformer(String methodName) {\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n         if (methodName == null) {\n             throw new IllegalArgumentException(\"The method to invoke must not be null\");\n         }\n      * @param args  the arguments to pass to the method\n      * @return an invoker transformer\n      */\n-    public static <I, O> Transformer<I, O> invokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args) {\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, Class<?>[] paramTypes, Object[] args) {\n         if (methodName == null) {\n             throw new IllegalArgumentException(\"The method to invoke must not be null\");\n         }\n      * \n      * @param methodName  the method to call\n      */\n-    private InvokerTransformer(String methodName) {\n+    private InvokerTransformer(final String methodName) {\n         super();\n         iMethodName = methodName;\n         iParamTypes = null;\n      * @param paramTypes  the constructor parameter types, not cloned\n      * @param args  the constructor arguments, not cloned\n      */\n-    public InvokerTransformer(String methodName, Class<?>[] paramTypes, Object[] args) {\n+    public InvokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n         super();\n         iMethodName = methodName;\n         iParamTypes = paramTypes;\n      * @return the transformed result, null if null input\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public O transform(Object input) {\n+    public O transform(final Object input) {\n         if (input == null) {\n             return null;\n         }\n         try {\n-            Class<?> cls = input.getClass();\n-            Method method = cls.getMethod(iMethodName, iParamTypes);\n+            final Class<?> cls = input.getClass();\n+            final Method method = cls.getMethod(iMethodName, iParamTypes);\n             return (O) method.invoke(input, iArgs);\n-        } catch (NoSuchMethodException ex) {\n+        } catch (final NoSuchMethodException ex) {\n             throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n                                        input.getClass() + \"' does not exist\");\n-        } catch (IllegalAccessException ex) {\n+        } catch (final IllegalAccessException ex) {\n             throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n                                        input.getClass() + \"' cannot be accessed\");\n-        } catch (InvocationTargetException ex) {\n+        } catch (final InvocationTargetException ex) {\n             throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n                                        input.getClass() + \"' threw an exception\", ex);\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/MapTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/MapTransformer.java\n      * @param map the map, not cloned\n      * @return the transformer\n      */\n-    public static <I, O> Transformer<I, O> mapTransformer(Map<? super I, ? extends O> map) {\n+    public static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n         if (map == null) {\n             return ConstantTransformer.<I, O>nullTransformer();\n         }\n      *\n      * @param map  the map to use for lookup, not cloned\n      */\n-    private MapTransformer(Map<? super I, ? extends O> map) {\n+    private MapTransformer(final Map<? super I, ? extends O> map) {\n         super();\n         iMap = map;\n     }\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public O transform(I input) {\n+    public O transform(final I input) {\n         return iMap.get(input);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/NOPClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NOPClosure.java\n      *\n      * @param input  the input object\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         // do nothing\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/NOPTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NOPTransformer.java\n      * @param input  the input object to transform\n      * @return the transformed result which is the input\n      */\n-    public T transform(T input) {\n+    public T transform(final T input) {\n         return input;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/NonePredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NonePredicate.java\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> nonePredicate(Predicate<? super T>... predicates) {\n+    public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n             return TruePredicate.<T>truePredicate();\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> nonePredicate(Collection<? extends Predicate<T>> predicates) {\n-        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+    public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         if (preds.length == 0) {\n             return TruePredicate.<T>truePredicate();\n         }\n      *\n      * @param predicates  the predicates to check, not cloned, not null\n      */\n-    public NonePredicate(Predicate<? super T>[] predicates) {\n+    public NonePredicate(final Predicate<? super T>[] predicates) {\n         super();\n         iPredicates = predicates;\n     }\n      * @param object  the input object\n      * @return true if none of decorated predicates return true\n      */\n-    public boolean evaluate(T object) {\n-        for (Predicate<? super T> iPredicate : iPredicates) {\n+    public boolean evaluate(final T object) {\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n             if (iPredicate.evaluate(object)) {\n                 return false;\n             }\n--- a/src/main/java/org/apache/commons/collections/functors/NotNullPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NotNullPredicate.java\n      * @param object  the object to evaluate\n      * @return true if not null\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         return object != null;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/NotPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NotPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> notPredicate(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * \n      * @param predicate  the predicate to call after the null check\n      */\n-    public NotPredicate(Predicate<? super T> predicate) {\n+    public NotPredicate(final Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @param object  the input object\n      * @return true if predicate returns false\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         return !iPredicate.evaluate(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/NullIsExceptionPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NullIsExceptionPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> nullIsExceptionPredicate(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * \n      * @param predicate  the predicate to call after the null check\n      */\n-    public NullIsExceptionPredicate(Predicate<? super T> predicate) {\n+    public NullIsExceptionPredicate(final Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @return true if decorated predicate returns true\n      * @throws FunctorException if input is null\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         if (object == null) {\n             throw new FunctorException(\"Input Object must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/NullIsFalsePredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NullIsFalsePredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> nullIsFalsePredicate(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      *\n      * @param predicate  the predicate to call after the null check\n      */\n-    public NullIsFalsePredicate(Predicate<? super T> predicate) {\n+    public NullIsFalsePredicate(final Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @param object  the input object\n      * @return true if decorated predicate returns true, false if input is null\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         if (object == null) {\n             return false;\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/NullIsTruePredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NullIsTruePredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Predicate<T> nullIsTruePredicate(Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * \n      * @param predicate  the predicate to call after the null check\n      */\n-    public NullIsTruePredicate(Predicate<? super T> predicate) {\n+    public NullIsTruePredicate(final Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @param object  the input object\n      * @return true if decorated predicate returns true or input is null\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         if (object == null) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/collections/functors/NullPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/NullPredicate.java\n      * @param object  the input object\n      * @return true if input is null\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         return object == null;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/OnePredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/OnePredicate.java\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Predicate<T> onePredicate(Predicate<? super T>... predicates) {\n+    public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n         if (predicates.length == 0) {\n             return FalsePredicate.<T>falsePredicate();\n      * @throws IllegalArgumentException if the predicates array is null\n      * @throws IllegalArgumentException if any predicate in the array is null\n      */\n-    public static <T> Predicate<T> onePredicate(Collection<? extends Predicate<T>> predicates) {\n-        Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+    public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n         return new OnePredicate<T>(preds);\n     }\n \n      * \n      * @param predicates  the predicates to check, not cloned, not null\n      */\n-    public OnePredicate(Predicate<? super T>[] predicates) {\n+    public OnePredicate(final Predicate<? super T>[] predicates) {\n         super();\n         iPredicates = predicates;\n     }\n      * @param object  the input object\n      * @return true if only one decorated predicate returns true\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         boolean match = false;\n-        for (Predicate<? super T> iPredicate : iPredicates) {\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n             if (iPredicate.evaluate(object)) {\n                 if (match) {\n                     return false;\n--- a/src/main/java/org/apache/commons/collections/functors/OrPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/OrPredicate.java\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> orPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      */\n-    public OrPredicate(Predicate<? super T> predicate1, Predicate<? super T> predicate2) {\n+    public OrPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n         super();\n         iPredicate1 = predicate1;\n         iPredicate2 = predicate2;\n      * @param object  the input object\n      * @return true if either decorated predicate returns true\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n        return iPredicate1.evaluate(object) || iPredicate2.evaluate(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/PredicateTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/PredicateTransformer.java\n      * @return the <code>predicate</code> transformer\n      * @throws IllegalArgumentException if the predicate is null\n      */\n-    public static <T> Transformer<T, Boolean> predicateTransformer(Predicate<? super T> predicate) {\n+    public static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * \n      * @param predicate  the predicate to call, not null\n      */\n-    public PredicateTransformer(Predicate<? super T> predicate) {\n+    public PredicateTransformer(final Predicate<? super T> predicate) {\n         super();\n         iPredicate = predicate;\n     }\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public Boolean transform(T input) {\n+    public Boolean transform(final T input) {\n         return Boolean.valueOf(iPredicate.evaluate(input));\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/PrototypeFactory.java\n+++ b/src/main/java/org/apache/commons/collections/functors/PrototypeFactory.java\n      * @throws IllegalArgumentException if the prototype cannot be cloned\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Factory<T> prototypeFactory(T prototype) {\n+    public static <T> Factory<T> prototypeFactory(final T prototype) {\n         if (prototype == null) {\n             return ConstantFactory.<T>constantFactory(null);\n         }\n         try {\n-            Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n+            final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n             return new PrototypeCloneFactory<T>(prototype, method);\n \n-        } catch (NoSuchMethodException ex) {\n+        } catch (final NoSuchMethodException ex) {\n             try {\n                 prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n                 return new InstantiateFactory<T>(\n                     (Class<T>) prototype.getClass(),\n                     new Class<?>[] { prototype.getClass() },\n                     new Object[] { prototype });\n-            } catch (NoSuchMethodException ex2) {\n+            } catch (final NoSuchMethodException ex2) {\n                 if (prototype instanceof Serializable) {\n                     return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n                 }\n         /**\n          * Constructor to store prototype.\n          */\n-        private PrototypeCloneFactory(T prototype, Method method) {\n+        private PrototypeCloneFactory(final T prototype, final Method method) {\n             super();\n             iPrototype = prototype;\n             iCloneMethod = method;\n         private void findCloneMethod() {\n             try {\n                 iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n-            } catch (NoSuchMethodException ex) {\n+            } catch (final NoSuchMethodException ex) {\n                 throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n             }\n         }\n \n             try {\n                 return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n-            } catch (IllegalAccessException ex) {\n+            } catch (final IllegalAccessException ex) {\n                 throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n-            } catch (InvocationTargetException ex) {\n+            } catch (final InvocationTargetException ex) {\n                 throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n             }\n         }\n         /**\n          * Constructor to store prototype\n          */\n-        private PrototypeSerializationFactory(T prototype) {\n+        private PrototypeSerializationFactory(final T prototype) {\n             super();\n             iPrototype = prototype;\n         }\n          */\n         @SuppressWarnings(\"unchecked\")\n         public T create() {\n-            ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n             ByteArrayInputStream bais = null;\n             try {\n-                ObjectOutputStream out = new ObjectOutputStream(baos);\n+                final ObjectOutputStream out = new ObjectOutputStream(baos);\n                 out.writeObject(iPrototype);\n \n                 bais = new ByteArrayInputStream(baos.toByteArray());\n-                ObjectInputStream in = new ObjectInputStream(bais);\n+                final ObjectInputStream in = new ObjectInputStream(bais);\n                 return (T) in.readObject();\n \n-            } catch (ClassNotFoundException ex) {\n+            } catch (final ClassNotFoundException ex) {\n                 throw new FunctorException(ex);\n-            } catch (IOException ex) {\n+            } catch (final IOException ex) {\n                 throw new FunctorException(ex);\n             } finally {\n                 try {\n                     if (bais != null) {\n                         bais.close();\n                     }\n-                } catch (IOException ex) {\n+                } catch (final IOException ex) {\n                     // ignore\n                 }\n                 try {\n                     baos.close();\n-                } catch (IOException ex) {\n+                } catch (final IOException ex) {\n                     // ignore\n                 }\n             }\n--- a/src/main/java/org/apache/commons/collections/functors/StringValueTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/StringValueTransformer.java\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public String transform(T input) {\n+    public String transform(final T input) {\n         return String.valueOf(input);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/SwitchClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/SwitchClosure.java\n      * @throws IllegalArgumentException if any element in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> switchClosure(Predicate<? super E>[] predicates,\n-                                               Closure<? super E>[] closures,\n-                                               Closure<? super E> defaultClosure) {\n+    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n+                                               final Closure<? super E>[] closures,\n+                                               final Closure<? super E> defaultClosure) {\n         FunctorUtils.validate(predicates);\n         FunctorUtils.validate(closures);\n         if (predicates.length != closures.length) {\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Closure<E> switchClosure(Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n+    public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n         if (predicatesAndClosures == null) {\n             throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n-        int size = predicatesAndClosures.size();\n+        final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n+        final int size = predicatesAndClosures.size();\n         if (size == 0) {\n             return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n         }\n-        Closure<E>[] closures = new Closure[size];\n-        Predicate<E>[] preds = new Predicate[size];\n+        final Closure<E>[] closures = new Closure[size];\n+        final Predicate<E>[] preds = new Predicate[size];\n         int i = 0;\n-        for (Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n+        for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n             preds[i] = entry.getKey();\n             closures[i] = entry.getValue();\n             i++;\n      * @param defaultClosure  the closure to use if no match, null means nop\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public SwitchClosure(Predicate<? super E>[] predicates, Closure<? super E>[] closures,\n-                         Closure<? super E> defaultClosure) {\n+    public SwitchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures,\n+                         final Closure<? super E> defaultClosure) {\n         super();\n         iPredicates = predicates;\n         iClosures = closures;\n      *\n      * @param input  the input object\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         for (int i = 0; i < iPredicates.length; i++) {\n             if (iPredicates[i].evaluate(input) == true) {\n                 iClosures[i].execute(input);\n--- a/src/main/java/org/apache/commons/collections/functors/SwitchTransformer.java\n+++ b/src/main/java/org/apache/commons/collections/functors/SwitchTransformer.java\n      * @throws IllegalArgumentException if any element in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> switchTransformer(Predicate<? super I>[] predicates,\n-            Transformer<? super I, ? extends O>[] transformers,\n-            Transformer<? super I, ? extends O> defaultTransformer) {\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers,\n+            final Transformer<? super I, ? extends O> defaultTransformer) {\n         FunctorUtils.validate(predicates);\n         FunctorUtils.validate(transformers);\n         if (predicates.length != transformers.length) {\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <I, O> Transformer<I, O> switchTransformer(\n-            Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> predicatesAndTransformers) {\n+            final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> predicatesAndTransformers) {\n         if (predicatesAndTransformers == null) {\n             throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n         }\n             return ConstantTransformer.<I, O>nullTransformer();\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Transformer<? super I, ? extends O> defaultTransformer = predicatesAndTransformers.remove(null);\n-        int size = predicatesAndTransformers.size();\n+        final Transformer<? super I, ? extends O> defaultTransformer = predicatesAndTransformers.remove(null);\n+        final int size = predicatesAndTransformers.size();\n         if (size == 0) {\n             return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n         }\n-        Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n-        Predicate<? super I>[] preds = new Predicate[size];\n+        final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n+        final Predicate<? super I>[] preds = new Predicate[size];\n         int i = 0;\n-        for (Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : predicatesAndTransformers.entrySet()) {\n+        for (final Map.Entry<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> entry : predicatesAndTransformers.entrySet()) {\n             preds[i] = entry.getKey();\n             transformers[i] = entry.getValue();\n             i++;\n      * @param defaultTransformer  the transformer to use if no match, null means return null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public SwitchTransformer(Predicate<? super I>[] predicates,\n-            Transformer<? super I, ? extends O>[] transformers,\n-            Transformer<? super I, ? extends O> defaultTransformer) {\n+    public SwitchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers,\n+            final Transformer<? super I, ? extends O> defaultTransformer) {\n         super();\n         iPredicates = predicates;\n         iTransformers = transformers;\n      * @param input  the input object to transform\n      * @return the transformed result\n      */\n-    public O transform(I input) {\n+    public O transform(final I input) {\n         for (int i = 0; i < iPredicates.length; i++) {\n             if (iPredicates[i].evaluate(input) == true) {\n                 return iTransformers[i].transform(input);\n--- a/src/main/java/org/apache/commons/collections/functors/TransformedPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/TransformedPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the transformer or the predicate is null\n      */\n-    public static <T> Predicate<T> transformedPredicate(Transformer<? super T, ? extends T> transformer,\n-                                                        Predicate<? super T> predicate) {\n+    public static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer,\n+                                                        final Predicate<? super T> predicate) {\n         if (transformer == null) {\n             throw new IllegalArgumentException(\"The transformer to call must not be null\");\n         }\n      * @param transformer  the transformer to use\n      * @param predicate  the predicate to decorate\n      */\n-    public TransformedPredicate(Transformer<? super T, ? extends T> transformer, Predicate<? super T> predicate) {\n+    public TransformedPredicate(final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n         iTransformer = transformer;\n         iPredicate = predicate;\n     }\n      * @param object  the input object which will be transformed\n      * @return true if decorated predicate returns true\n      */\n-    public boolean evaluate(T object) {\n-        T result = iTransformer.transform(object);\n+    public boolean evaluate(final T object) {\n+        final T result = iTransformer.transform(object);\n         return iPredicate.evaluate(result);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/TransformerClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/TransformerClosure.java\n      * @param transformer  the transformer to call, null means nop\n      * @return the <code>transformer</code> closure\n      */\n-    public static <E> Closure<E> transformerClosure(Transformer<? super E, ?> transformer) {\n+    public static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n         if (transformer == null) {\n             return NOPClosure.<E>nopClosure();\n         }\n      * \n      * @param transformer  the transformer to call, not null\n      */\n-    public TransformerClosure(Transformer<? super E, ?> transformer) {\n+    public TransformerClosure(final Transformer<? super E, ?> transformer) {\n         super();\n         iTransformer = transformer;\n     }\n      * \n      * @param input  the input object\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         iTransformer.transform(input);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/TransformerPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/TransformerPredicate.java\n      * @return the predicate\n      * @throws IllegalArgumentException if the transformer is null\n      */\n-    public static <T> Predicate<T> transformerPredicate(Transformer<? super T, Boolean> transformer) {\n+    public static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n         if (transformer == null) {\n             throw new IllegalArgumentException(\"The transformer to call must not be null\");\n         }\n      *\n      * @param transformer  the transformer to decorate\n      */\n-    public TransformerPredicate(Transformer<? super T, Boolean> transformer) {\n+    public TransformerPredicate(final Transformer<? super T, Boolean> transformer) {\n         super();\n         iTransformer = transformer;\n     }\n      * @return true if decorated transformer returns Boolean.TRUE\n      * @throws FunctorException if the transformer returns an invalid type\n      */\n-    public boolean evaluate(T object) {\n-        Boolean result = iTransformer.transform(object);\n+    public boolean evaluate(final T object) {\n+        final Boolean result = iTransformer.transform(object);\n         if (result == null) {\n             throw new FunctorException(\n                     \"Transformer must return an instanceof Boolean, it was a null object\");\n--- a/src/main/java/org/apache/commons/collections/functors/TruePredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/TruePredicate.java\n      * @param object  the input object\n      * @return true always\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         return true;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/UniquePredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/UniquePredicate.java\n      * @param object  the input object\n      * @return true if this is the first time the object is seen\n      */\n-    public boolean evaluate(T object) {\n+    public boolean evaluate(final T object) {\n         return iSet.add(object);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/functors/WhileClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/WhileClosure.java\n      * @return the <code>while</code> closure\n      * @throws IllegalArgumentException if the predicate or closure is null\n      */\n-    public static <E> Closure<E> whileClosure(Predicate<? super E> predicate,\n-                                              Closure<? super E> closure, boolean doLoop) {\n+    public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate,\n+                                              final Closure<? super E> closure, final boolean doLoop) {\n         if (predicate == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n      * @param closure  the closure the execute, not null\n      * @param doLoop  true to act as a do-while loop, always executing the closure once\n      */\n-    public WhileClosure(Predicate<? super E> predicate, Closure<? super E> closure, boolean doLoop) {\n+    public WhileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure, final boolean doLoop) {\n         super();\n         iPredicate = predicate;\n         iClosure = closure;\n      * \n      * @param input  the input object\n      */\n-    public void execute(E input) {\n+    public void execute(final E input) {\n         if (iDoLoop) {\n             iClosure.execute(input);\n         }\n--- a/src/main/java/org/apache/commons/collections/iterators/AbstractEmptyIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractEmptyIterator.java\n         return -1;\n     }\n \n-    public void add(E obj) {\n+    public void add(final E obj) {\n         throw new UnsupportedOperationException(\"add() not supported for empty Iterator\");\n     }\n \n-    public void set(E obj) {\n+    public void set(final E obj) {\n         throw new IllegalStateException(\"Iterator contains no elements\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/AbstractEmptyMapIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractEmptyMapIterator.java\n         throw new IllegalStateException(\"Iterator contains no elements\");\n     }\n \n-    public V setValue(V value) {\n+    public V setValue(final V value) {\n         throw new IllegalStateException(\"Iterator contains no elements\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/AbstractIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractIteratorDecorator.java\n      * @param iterator  the iterator to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected AbstractIteratorDecorator(Iterator<E> iterator) {\n+    protected AbstractIteratorDecorator(final Iterator<E> iterator) {\n         super(iterator);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/AbstractListIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractListIteratorDecorator.java\n      * @param iterator  the iterator to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractListIteratorDecorator(ListIterator<E> iterator) {\n+    public AbstractListIteratorDecorator(final ListIterator<E> iterator) {\n         super();\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"ListIterator must not be null\");\n     }\n \n     /** {@inheritDoc} */\n-    public void set(E obj) {\n+    public void set(final E obj) {\n         iterator.set(obj);\n     }\n \n     /** {@inheritDoc} */\n-    public void add(E obj) {\n+    public void add(final E obj) {\n         iterator.add(obj);\n     }\n     \n--- a/src/main/java/org/apache/commons/collections/iterators/AbstractMapIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractMapIteratorDecorator.java\n      * @param iterator  the iterator to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractMapIteratorDecorator(MapIterator<K, V> iterator) {\n+    public AbstractMapIteratorDecorator(final MapIterator<K, V> iterator) {\n         super();\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"MapIterator must not be null\");\n     }\n \n     /** {@inheritDoc} */\n-    public V setValue(V obj) {\n+    public V setValue(final V obj) {\n         return iterator.setValue(obj);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/AbstractOrderedMapIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractOrderedMapIteratorDecorator.java\n      * @param iterator  the iterator to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractOrderedMapIteratorDecorator(OrderedMapIterator<K, V> iterator) {\n+    public AbstractOrderedMapIteratorDecorator(final OrderedMapIterator<K, V> iterator) {\n         super();\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n     }\n \n     /** {@inheritDoc} */\n-    public V setValue(V obj) {\n+    public V setValue(final V obj) {\n         return iterator.setValue(obj);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/AbstractUntypedIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/AbstractUntypedIteratorDecorator.java\n      * \n      * @param iterator  the iterator to decorate\n      */\n-    protected AbstractUntypedIteratorDecorator(Iterator<I> iterator) {\n+    protected AbstractUntypedIteratorDecorator(final Iterator<I> iterator) {\n         super();\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"Iterator must not be null\");\n--- a/src/main/java/org/apache/commons/collections/iterators/ArrayListIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/ArrayListIterator.java\n      * @throws IllegalArgumentException if <code>array</code> is not an array.\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ArrayListIterator(Object array) {\n+    public ArrayListIterator(final Object array) {\n         super(array);\n     }\n \n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      * @throws IndexOutOfBoundsException if the start index is out of bounds\n      */\n-    public ArrayListIterator(Object array, int startIndex) {\n+    public ArrayListIterator(final Object array, final int startIndex) {\n         super(array, startIndex);\n         this.startIndex = startIndex;\n     }\n      * @throws IllegalArgumentException if end index is before the start\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ArrayListIterator(Object array, int startIndex, int endIndex) {\n+    public ArrayListIterator(final Object array, final int startIndex, final int endIndex) {\n         super(array, startIndex, endIndex);\n         this.startIndex = startIndex;\n     }\n      * @throws UnsupportedOperationException always thrown.\n      * @see java.util.ListIterator#set\n      */\n-    public void add(Object o) {\n+    public void add(final Object o) {\n         throw new UnsupportedOperationException(\"add() method is not supported\");\n     }\n \n      * before {@link #set(Object)}\n      * @see java.util.ListIterator#set\n      */\n-    public void set(Object o) {\n+    public void set(final Object o) {\n         if (this.lastItemIndex == -1) {\n             throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n         }\n--- a/src/main/java/org/apache/commons/collections/iterators/CollatingIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/CollatingIterator.java\n      */\n     public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E>[] iterators) {\n         this(comp, iterators.length);\n-        for (Iterator<? extends E> iterator : iterators) {\n+        for (final Iterator<? extends E> iterator : iterators) {\n             addIterator(iterator);\n         }\n     }\n      */\n     public CollatingIterator(final Comparator<? super E> comp, final Collection<Iterator<? extends E>> iterators) {\n         this(comp, iterators.size());\n-        for (Iterator<? extends E> iterator : iterators) {\n+        for (final Iterator<? extends E> iterator : iterators) {\n             addIterator(iterator);\n         }\n     }\n         if (hasNext() == false) {\n             throw new NoSuchElementException();\n         }\n-        int leastIndex = least();\n+        final int leastIndex = least();\n         if (leastIndex == -1) {\n             throw new NoSuchElementException();\n         }\n-        E val = values.get(leastIndex);\n+        final E val = values.get(leastIndex);\n         clear(leastIndex);\n         lastReturned = leastIndex;\n         return val;\n      * \n      * @return <tt>false</tt> iff there was no value to set\n      */\n-    private boolean set(int i) {\n-        Iterator<? extends E> it = iterators.get(i);\n+    private boolean set(final int i) {\n+        final Iterator<? extends E> it = iterators.get(i);\n         if (it.hasNext()) {\n             values.set(i, it.next());\n             valueSet.set(i);\n      * Clears the {@link #values} and {@link #valueSet} attributes at position\n      * <i>i</i>.\n      */\n-    private void clear(int i) {\n+    private void clear(final int i) {\n         values.set(i, null);\n         valueSet.clear(i);\n     }\n                     leastIndex = i;\n                     leastObject = values.get(i);\n                 } else {\n-                    E curObject = values.get(i);\n+                    final E curObject = values.get(i);\n                     if (comparator == null) {\n                         throw new NullPointerException(\"You must invoke setComparator() to set a comparator first.\");\n                     }\n      * Returns <code>true</code> iff any bit in the given set is\n      * <code>true</code>.\n      */\n-    private boolean anyValueSet(BitSet set) {\n+    private boolean anyValueSet(final BitSet set) {\n         for (int i = 0; i < set.size(); i++) {\n             if (set.get(i)) {\n                 return true;\n      * Returns <code>true</code> iff any {@link Iterator} in the given list has\n      * a next value.\n      */\n-    private boolean anyHasNext(ArrayList<Iterator<? extends E>> iters) {\n-        for (Iterator<? extends E> iterator : iters) {\n+    private boolean anyHasNext(final ArrayList<Iterator<? extends E>> iters) {\n+        for (final Iterator<? extends E> iterator : iters) {\n             if (iterator.hasNext()) {\n                 return true;\n             }\n--- a/src/main/java/org/apache/commons/collections/iterators/EntrySetMapIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/EntrySetMapIterator.java\n      * \n      * @param map  the map to iterate over\n      */\n-    public EntrySetMapIterator(Map<K, V> map) {\n+    public EntrySetMapIterator(final Map<K, V> map) {\n         super();\n         this.map = map;\n         this.iterator = map.entrySet().iterator();\n      * @throws IllegalStateException if <code>remove()</code> has been called since the\n      *  last call to <code>next()</code>\n      */\n-    public V setValue(V value) {\n+    public V setValue(final V value) {\n         if (last == null) {\n             throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n         }\n--- a/src/main/java/org/apache/commons/collections/iterators/FilterIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/FilterIterator.java\n      *\n      * @param iterator  the iterator to use\n      */\n-    public FilterIterator(Iterator<? extends E> iterator) {\n+    public FilterIterator(final Iterator<? extends E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n      * @param iterator  the iterator to use\n      * @param predicate  the predicate to use\n      */\n-    public FilterIterator(Iterator<? extends E> iterator, Predicate<? super E> predicate) {\n+    public FilterIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n         super();\n         this.iterator = iterator;\n         this.predicate = predicate;\n      *\n      * @param iterator  the iterator to use\n      */\n-    public void setIterator(Iterator<? extends E> iterator) {\n+    public void setIterator(final Iterator<? extends E> iterator) {\n         this.iterator = iterator;\n         nextObject = null;\n         nextObjectSet = false;\n      *\n      * @param predicate  the predicate to use\n      */\n-    public void setPredicate(Predicate<? super E> predicate) {\n+    public void setPredicate(final Predicate<? super E> predicate) {\n         this.predicate = predicate;\n         nextObject = null;\n         nextObjectSet = false;\n      */\n     private boolean setNextObject() {\n         while (iterator.hasNext()) {\n-            E object = iterator.next();\n+            final E object = iterator.next();\n             if (predicate.evaluate(object)) {\n                 nextObject = object;\n                 nextObjectSet = true;\n--- a/src/main/java/org/apache/commons/collections/iterators/FilterListIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/FilterListIterator.java\n      *\n      * @param iterator  the iterator to use\n      */\n-    public FilterListIterator(ListIterator<? extends E> iterator ) {\n+    public FilterListIterator(final ListIterator<? extends E> iterator ) {\n         super();\n         this.iterator = iterator;\n     }\n      * @param iterator  the iterator to use\n      * @param predicate  the predicate to use\n      */\n-    public FilterListIterator(ListIterator<? extends E> iterator, Predicate<? super E> predicate) {\n+    public FilterListIterator(final ListIterator<? extends E> iterator, final Predicate<? super E> predicate) {\n         super();\n         this.iterator = iterator;\n         this.predicate = predicate;\n      *\n      * @param predicate  the predicate to use.\n      */\n-    public FilterListIterator(Predicate<? super E> predicate) {\n+    public FilterListIterator(final Predicate<? super E> predicate) {\n         super();\n         this.predicate = predicate;\n     }\n \n     //-----------------------------------------------------------------------\n     /** Not supported. */\n-    public void add(E o) {\n+    public void add(final E o) {\n         throw new UnsupportedOperationException(\"FilterListIterator.add(Object) is not supported.\");\n     }\n \n             }\n         }\n         nextIndex++;\n-        E temp = nextObject;\n+        final E temp = nextObject;\n         clearNextObject();\n         return temp;\n     }\n             }\n         }\n         nextIndex--;\n-        E temp = previousObject;\n+        final E temp = previousObject;\n         clearPreviousObject();\n         return temp;\n     }\n     }\n \n     /** Not supported. */\n-    public void set(E o) {\n+    public void set(final E o) {\n         throw new UnsupportedOperationException(\"FilterListIterator.set(Object) is not supported.\");\n     }\n \n      * \n      * @param iterator  the iterator to use\n      */\n-    public void setListIterator(ListIterator<? extends E> iterator) {\n+    public void setListIterator(final ListIterator<? extends E> iterator) {\n         this.iterator = iterator;\n     }\n \n      * \n      * @param predicate  the transformer to use\n      */\n-    public void setPredicate(Predicate<? super E> predicate) {\n+    public void setPredicate(final Predicate<? super E> predicate) {\n         this.predicate = predicate;\n     }\n \n             return false;\n         }\n         while (iterator.hasNext()) {\n-            E object = iterator.next();\n+            final E object = iterator.next();\n             if (predicate.evaluate(object)) {\n                 nextObject = object;\n                 nextObjectSet = true;\n             return false;\n         }\n         while (iterator.hasPrevious()) {\n-            E object = iterator.previous();\n+            final E object = iterator.previous();\n             if (predicate.evaluate(object)) {\n                 previousObject = object;\n                 previousObjectSet = true;\n--- a/src/main/java/org/apache/commons/collections/iterators/IteratorChain.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/IteratorChain.java\n      * @param iterator the first child iterator in the IteratorChain, not null\n      * @throws NullPointerException if the iterator is null\n      */\n-    public IteratorChain(Iterator<? extends E> iterator) {\n+    public IteratorChain(final Iterator<? extends E> iterator) {\n         super();\n         addIterator(iterator);\n     }\n      * @param second the second child iterator in the IteratorChain, not null\n      * @throws NullPointerException if either iterator is null\n      */\n-    public IteratorChain(Iterator<? extends E> first, Iterator<? extends E> second) {\n+    public IteratorChain(final Iterator<? extends E> first, final Iterator<? extends E> second) {\n         super();\n         addIterator(first);\n         addIterator(second);\n      * @param iteratorChain the array of iterators, not null\n      * @throws NullPointerException if iterators array is or contains null\n      */\n-    public IteratorChain(Iterator<? extends E>... iteratorChain) {\n-        super();\n-        for (Iterator<? extends E> element : iteratorChain) {\n+    public IteratorChain(final Iterator<? extends E>... iteratorChain) {\n+        super();\n+        for (final Iterator<? extends E> element : iteratorChain) {\n             addIterator(element);\n         }\n     }\n      * @throws ClassCastException if iterators collection doesn't contain an\n      * iterator\n      */\n-    public IteratorChain(Collection<Iterator<? extends E>> iteratorChain) {\n-        super();\n-        for (Iterator<? extends E> iterator : iteratorChain) {\n+    public IteratorChain(final Collection<Iterator<? extends E>> iteratorChain) {\n+        super();\n+        for (final Iterator<? extends E> iterator : iteratorChain) {\n             addIterator(iterator);\n         }\n     }\n      * @throws IllegalStateException if I've already started iterating\n      * @throws NullPointerException if the iterator is null\n      */\n-    public void addIterator(Iterator<? extends E> iterator) {\n+    public void addIterator(final Iterator<? extends E> iterator) {\n         checkLocked();\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n      * @throws IllegalStateException if I've already started iterating\n      * @throws NullPointerException if the iterator is null\n      */\n-    public void setIterator(int index, Iterator<? extends E> iterator)\n+    public void setIterator(final int index, final Iterator<? extends E> iterator)\n             throws IndexOutOfBoundsException {\n         checkLocked();\n         if (iterator == null) {\n--- a/src/main/java/org/apache/commons/collections/iterators/IteratorEnumeration.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/IteratorEnumeration.java\n      * \n      * @param iterator the iterator to use\n      */\n-    public IteratorEnumeration(Iterator<? extends E> iterator) {\n+    public IteratorEnumeration(final Iterator<? extends E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n      * \n      * @param iterator the new underlying iterator\n      */\n-    public void setIterator(Iterator<? extends E> iterator) {\n+    public void setIterator(final Iterator<? extends E> iterator) {\n         this.iterator = iterator;\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/IteratorIterable.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/IteratorIterable.java\n      * \n      * @param iterator the iterator to use.\n      */\n-    public IteratorIterable(Iterator<? extends E> iterator) {\n+    public IteratorIterable(final Iterator<? extends E> iterator) {\n         this(iterator, false);\n     }\n \n      * @param iterator the iterator to use.\n      * @param multipleUse <code>true</code> if the new iterable can be used in multiple iterations\n      */\n-    public IteratorIterable(Iterator<? extends E> iterator, boolean multipleUse) {\n+    public IteratorIterable(final Iterator<? extends E> iterator, final boolean multipleUse) {\n         super();\n         if (multipleUse && !(iterator instanceof ResettableIterator)) {\n             this.iterator = new ListIteratorWrapper<E>(iterator); \n--- a/src/main/java/org/apache/commons/collections/iterators/ListIteratorWrapper.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/ListIteratorWrapper.java\n      * @param iterator  the iterator to wrap\n      * @throws NullPointerException if the iterator is null\n      */\n-    public ListIteratorWrapper(Iterator<? extends E> iterator) {\n+    public ListIteratorWrapper(final Iterator<? extends E> iterator) {\n         super();\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n      * @throws UnsupportedOperationException if the underlying iterator is not of\n      * type {@link ListIterator}\n      */\n-    public void add(E obj) throws UnsupportedOperationException {\n+    public void add(final E obj) throws UnsupportedOperationException {\n         if (iterator instanceof ListIterator) {\n             @SuppressWarnings(\"unchecked\")\n+            final\n             ListIterator<E> li = (ListIterator<E>) iterator;\n             li.add(obj);\n             return;\n      */\n     public boolean hasPrevious() {\n         if (iterator instanceof ListIterator) {\n-            ListIterator<?> li = (ListIterator<?>) iterator;\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n             return li.hasPrevious();\n         }\n         return currentIndex > 0;\n             return list.get(currentIndex - 1);\n         }\n \n-        E retval = iterator.next();\n+        final E retval = iterator.next();\n         list.add(retval);\n         ++currentIndex;\n         ++wrappedIteratorIndex;\n      */\n     public int nextIndex() {\n         if (iterator instanceof ListIterator) {\n-            ListIterator<?> li = (ListIterator<?>) iterator;\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n             return li.nextIndex();\n         }\n         return currentIndex;\n     public E previous() throws NoSuchElementException {\n         if (iterator instanceof ListIterator) {\n             @SuppressWarnings(\"unchecked\")\n+            final\n             ListIterator<E> li = (ListIterator<E>) iterator;\n             return li.previous();\n         }\n      */\n     public int previousIndex() {\n         if (iterator instanceof ListIterator) {\n-            ListIterator<?> li = (ListIterator<?>) iterator;\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n             return li.previousIndex();\n         }\n         return currentIndex - 1;\n      * @throws UnsupportedOperationException if the underlying iterator is not of\n      * type {@link ListIterator}\n      */\n-    public void set(E obj) throws UnsupportedOperationException {\n+    public void set(final E obj) throws UnsupportedOperationException {\n         if (iterator instanceof ListIterator) {\n             @SuppressWarnings(\"unchecked\")\n+            final\n             ListIterator<E> li = (ListIterator<E>) iterator;\n             li.set(obj);\n             return;\n      */\n     public void reset()  {\n         if (iterator instanceof ListIterator) {\n-            ListIterator<?> li = (ListIterator<?>) iterator;\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n             while (li.previousIndex() >= 0) {\n                 li.previous();\n             }\n--- a/src/main/java/org/apache/commons/collections/iterators/LoopingIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/LoopingIterator.java\n public class LoopingIterator<E> implements ResettableIterator<E> {\n     \n     /** The collection to base the iterator on */\n-    private Collection<? extends E> collection;\n+    private final Collection<? extends E> collection;\n     /** The current iterator */\n     private Iterator<? extends E> iterator;\n \n      * @param coll  the collection to wrap\n      * @throws NullPointerException if the collection is null\n      */\n-    public LoopingIterator(Collection<? extends E> coll) {\n+    public LoopingIterator(final Collection<? extends E> coll) {\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/iterators/LoopingListIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/LoopingListIterator.java\n public class LoopingListIterator<E> implements ResettableListIterator<E> {\n \n     /** The list to base the iterator on */\n-    private List<E> list;\n+    private final List<E> list;\n     /** The current list iterator */\n     private ListIterator<E> iterator;\n \n      * @param list the list to wrap\n      * @throws NullPointerException if the list it null\n      */\n-    public LoopingListIterator(List<E> list) {\n+    public LoopingListIterator(final List<E> list) {\n         if (list == null) {\n             throw new NullPointerException(\"The list must not be null\");\n         }\n      * @throws UnsupportedOperationException if the add method is not\n      *  supported by the iterator implementation of the underlying list\n      */\n-    public void add(E obj) {\n+    public void add(final E obj) {\n         iterator.add(obj);\n     }\n \n      * @throws UnsupportedOperationException if the set method is not\n      *  supported by the iterator implementation of the underlying list\n      */\n-    public void set(E obj) {\n+    public void set(final E obj) {\n         iterator.set(obj);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/ObjectArrayIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/ObjectArrayIterator.java\n      * @param array the array to iterate over\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayIterator(E... array) {\n+    public ObjectArrayIterator(final E... array) {\n         this(array, 0, array.length);\n     }\n \n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      * @throws IndexOutOfBoundsException if the start index is out of bounds\n      */\n-    public ObjectArrayIterator(E array[], int start) {\n+    public ObjectArrayIterator(final E array[], final int start) {\n         this(array, start, array.length);\n     }\n \n      * @throws IllegalArgumentException if end index is before the start\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayIterator(E array[], int start, int end) {\n+    public ObjectArrayIterator(final E array[], final int start, final int end) {\n         super();\n         if (start < 0) {\n             throw new ArrayIndexOutOfBoundsException(\"Start index must not be less than zero\");\n      * @throws IllegalStateException if the <code>array</code> was set in the constructor\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public void setArray(E[] array) {\n+    public void setArray(final E[] array) {\n         if (this.array != null) {\n             throw new IllegalStateException(\"The array to iterate over has already been set\");\n         }\n--- a/src/main/java/org/apache/commons/collections/iterators/ObjectArrayListIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/ObjectArrayListIterator.java\n      * @param array the array to iterate over\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayListIterator(E... array) {\n+    public ObjectArrayListIterator(final E... array) {\n         super(array);\n     }\n \n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      * @throws IndexOutOfBoundsException if the start index is out of bounds\n      */\n-    public ObjectArrayListIterator(E[] array, int start) {\n+    public ObjectArrayListIterator(final E[] array, final int start) {\n         super(array, start);\n     }\n     \n      * @throws IllegalArgumentException if end index is before the start\n      * @throws NullPointerException if <code>array</code> is <code>null</code>\n      */\n-    public ObjectArrayListIterator(E[] array, int start, int end) {\n+    public ObjectArrayListIterator(final E[] array, final int start, final int end) {\n         super(array, start, end);\n     }\n \n      * @param obj  the object to add\n      * @throws UnsupportedOperationException always thrown.\n      */\n-    public void add(E obj) {\n+    public void add(final E obj) {\n         throw new UnsupportedOperationException(\"add() method is not supported\");\n     }\n \n      * @throws IllegalStateException if next() has not yet been called.\n      * @throws ClassCastException if the object type is unsuitable for the array\n      */\n-    public void set(E obj) {\n+    public void set(final E obj) {\n         if (this.lastItemIndex == -1) {\n             throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n         }\n--- a/src/main/java/org/apache/commons/collections/iterators/ObjectGraphIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/ObjectGraphIterator.java\n      * @param transformer  the transformer to use, null will use a no effect transformer\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public ObjectGraphIterator(E root, Transformer<? super E, ? extends E> transformer) {\n+    public ObjectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n         super();\n         if (root instanceof Iterator) {\n             this.currentIterator = (Iterator<? extends E>) root;\n      * \n      * @param rootIterator  the root iterator, null will result in an empty iterator\n      */\n-    public ObjectGraphIterator(Iterator<? extends E> rootIterator) {\n+    public ObjectGraphIterator(final Iterator<? extends E> rootIterator) {\n         super();\n         this.currentIterator = rootIterator;\n         this.transformer = null;\n      * @param value  the value to start from\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected void findNext(E value) {\n+    protected void findNext(final E value) {\n         if (value instanceof Iterator) {\n             // need to examine this iterator\n             findNextByIterator((Iterator<? extends E>) value);\n      * \n      * @param iterator  the iterator to start from\n      */\n-    protected void findNextByIterator(Iterator<? extends E> iterator) {\n+    protected void findNextByIterator(final Iterator<? extends E> iterator) {\n         if (iterator != currentIterator) {\n             // recurse a level\n             if (currentIterator != null) {\n             throw new NoSuchElementException(\"No more elements in the iteration\");\n         }\n         lastUsedIterator = currentIterator;\n-        E result = currentValue;\n+        final E result = currentValue;\n         currentValue = null;\n         hasNext = false;\n         return result;\n--- a/src/main/java/org/apache/commons/collections/iterators/ReverseListIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/ReverseListIterator.java\n      * @param list  the list to create a reversed iterator for\n      * @throws NullPointerException if the list is null\n      */\n-    public ReverseListIterator(List<E> list) {\n+    public ReverseListIterator(final List<E> list) {\n         super();\n         this.list = list;\n         iterator = list.listIterator(list.size());\n      * @return the next element in the iterator\n      */\n     public E next() {\n-        E obj = iterator.previous();\n+        final E obj = iterator.previous();\n         validForUpdate = true;\n         return obj;\n     }\n      * @return the previous element in the iterator\n      */\n     public E previous() {\n-        E obj = iterator.next();\n+        final E obj = iterator.next();\n         validForUpdate = true;\n         return obj;\n     }\n      * @throws UnsupportedOperationException if the list is unmodifiable\n      * @throws IllegalStateException if the iterator is not in a valid state for set\n      */\n-    public void set(E obj) {\n+    public void set(final E obj) {\n         if (validForUpdate == false) {\n             throw new IllegalStateException(\"Cannot set to list until next() or previous() called\");\n         }\n      * @throws UnsupportedOperationException if the list is unmodifiable\n      * @throws IllegalStateException if the iterator is not in a valid state for set\n      */\n-    public void add(E obj) {\n+    public void add(final E obj) {\n         // the validForUpdate flag is needed as the necessary previous()\n         // method call re-enables remove and add\n         if (validForUpdate == false) {\n--- a/src/main/java/org/apache/commons/collections/iterators/SingletonIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/SingletonIterator.java\n      *\n      * @param object  the single object to return from the iterator\n      */\n-    public SingletonIterator(E object) {\n+    public SingletonIterator(final E object) {\n         this(object, true);\n     }\n \n      * @param removeAllowed  true if remove is allowed\n      * @since 3.1\n      */\n-    public SingletonIterator(E object, boolean removeAllowed) {\n+    public SingletonIterator(final E object, final boolean removeAllowed) {\n         super();\n         this.object = object;\n         this.removeAllowed = removeAllowed;\n--- a/src/main/java/org/apache/commons/collections/iterators/SingletonListIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/SingletonListIterator.java\n      *\n      * @param object  the single object to return from the iterator\n      */\n-    public SingletonListIterator(E object) {\n+    public SingletonListIterator(final E object) {\n         super();\n         this.object = object;\n     }\n      * @param obj  the object to add\n      * @throws UnsupportedOperationException always\n      */\n-    public void add(E obj) {\n+    public void add(final E obj) {\n         throw new UnsupportedOperationException(\"add() is not supported by this iterator\");\n     }\n     \n      * @throws IllegalStateException if <tt>next</tt> has not been called \n      *          or the object has been removed\n      */\n-    public void set(E obj) {\n+    public void set(final E obj) {\n         if (!nextCalled || removed) {\n             throw new IllegalStateException();\n         }\n--- a/src/main/java/org/apache/commons/collections/iterators/TransformIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/TransformIterator.java\n      *\n      * @param iterator  the iterator to use\n      */\n-    public TransformIterator(Iterator<? extends I> iterator) {\n+    public TransformIterator(final Iterator<? extends I> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n      * @param iterator  the iterator to use\n      * @param transformer  the transformer to use\n      */\n-    public TransformIterator(Iterator<? extends I> iterator, Transformer<? super I, ? extends O> transformer) {\n+    public TransformIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transformer) {\n         super();\n         this.iterator = iterator;\n         this.transformer = transformer;\n      * \n      * @param iterator  the iterator to use\n      */\n-    public void setIterator(Iterator<? extends I> iterator) {\n+    public void setIterator(final Iterator<? extends I> iterator) {\n         this.iterator = iterator;\n     }\n \n      * \n      * @param transformer  the transformer to use\n      */\n-    public void setTransformer(Transformer<? super I, ? extends O> transformer) {\n+    public void setTransformer(final Transformer<? super I, ? extends O> transformer) {\n         this.transformer = transformer;\n     }\n \n      * @param source  the object to transform\n      * @return the transformed object\n      */\n-    protected O transform(I source) {\n+    protected O transform(final I source) {\n         return transformer.transform(source);\n     }\n }\n--- a/src/main/java/org/apache/commons/collections/iterators/UniqueFilterIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/UniqueFilterIterator.java\n      *\n      *  @param iterator  the iterator to use\n      */\n-    public UniqueFilterIterator(Iterator<E> iterator) {\n+    public UniqueFilterIterator(final Iterator<E> iterator) {\n         super(iterator, UniquePredicate.uniquePredicate());\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/UnmodifiableIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableIterator.java\n      * @return a new unmodifiable iterator\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <E> Iterator<E> unmodifiableIterator(Iterator<E> iterator) {\n+    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"Iterator must not be null\");\n         }\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableIterator(Iterator<E> iterator) {\n+    private UnmodifiableIterator(final Iterator<E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n--- a/src/main/java/org/apache/commons/collections/iterators/UnmodifiableListIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableListIterator.java\n public final class UnmodifiableListIterator<E> implements ListIterator<E>, Unmodifiable {\n \n     /** The iterator being decorated */\n-    private ListIterator<E> iterator;\n+    private final ListIterator<E> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @return a new unmodifiable list iterator\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <E> ListIterator<E> umodifiableListIterator(ListIterator<E> iterator) {\n+    public static <E> ListIterator<E> umodifiableListIterator(final ListIterator<E> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"ListIterator must not be null\");\n         }\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableListIterator(ListIterator<E> iterator) {\n+    private UnmodifiableListIterator(final ListIterator<E> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n         throw new UnsupportedOperationException(\"remove() is not supported\");\n     }\n \n-    public void set(E obj) {\n+    public void set(final E obj) {\n         throw new UnsupportedOperationException(\"set() is not supported\");\n     }\n \n-    public void add(E obj) {\n+    public void add(final E obj) {\n         throw new UnsupportedOperationException(\"add() is not supported\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableMapIterator.java\n      * @return a new unmodifiable map iterator\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(MapIterator<K, V> iterator) {\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"MapIterator must not be null\");\n         }\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableMapIterator(MapIterator<K, V> iterator) {\n+    private UnmodifiableMapIterator(final MapIterator<K, V> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n         return iterator.getValue();\n     }\n \n-    public V setValue(V value) {\n+    public V setValue(final V value) {\n         throw new UnsupportedOperationException(\"setValue() is not supported\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIterator.java\n+++ b/src/main/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIterator.java\n         Unmodifiable {\n \n     /** The iterator being decorated */\n-    private OrderedMapIterator<K, V> iterator;\n+    private final OrderedMapIterator<K, V> iterator;\n \n     //-----------------------------------------------------------------------\n     /**\n      * @return a new unmodifiable ordered map iterator\n      * @throws IllegalArgumentException if the iterator is null\n      */\n-    public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(OrderedMapIterator<K, V> iterator) {\n+    public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(final OrderedMapIterator<K, V> iterator) {\n         if (iterator == null) {\n             throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n         }\n      *\n      * @param iterator  the iterator to decorate\n      */\n-    private UnmodifiableOrderedMapIterator(OrderedMapIterator<K, V> iterator) {\n+    private UnmodifiableOrderedMapIterator(final OrderedMapIterator<K, V> iterator) {\n         super();\n         this.iterator = iterator;\n     }\n         return iterator.getValue();\n     }\n \n-    public V setValue(V value) {\n+    public V setValue(final V value) {\n         throw new UnsupportedOperationException(\"setValue() is not supported\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/keyvalue/AbstractKeyValue.java\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/AbstractKeyValue.java\n      * @param key  the key for the entry, may be null\n      * @param value  the value for the entry, may be null\n      */\n-    protected AbstractKeyValue(K key, V value) {\n+    protected AbstractKeyValue(final K key, final V value) {\n         super();\n         this.key = key;\n         this.value = value;\n--- a/src/main/java/org/apache/commons/collections/keyvalue/AbstractMapEntry.java\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/AbstractMapEntry.java\n      * @param key  the key for the entry, may be null\n      * @param value  the value for the entry, may be null\n      */\n-    protected AbstractMapEntry(K key, V value) {\n+    protected AbstractMapEntry(final K key, final V value) {\n         super(key, value);\n     }\n \n      * @param value  the new value\n      * @return the previous value\n      */\n-    public V setValue(V value) {\n-        V answer = this.value;\n+    public V setValue(final V value) {\n+        final V answer = this.value;\n         this.value = value;\n         return answer;\n     }\n      * @return true if equal key and value\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map.Entry == false) {\n             return false;\n         }\n-        Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n         return\n             (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n             (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n--- a/src/main/java/org/apache/commons/collections/keyvalue/AbstractMapEntryDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/AbstractMapEntryDecorator.java\n      * @param entry  the <code>Map.Entry</code> to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractMapEntryDecorator(Map.Entry<K, V> entry) {\n+    public AbstractMapEntryDecorator(final Map.Entry<K, V> entry) {\n         if (entry == null) {\n             throw new IllegalArgumentException(\"Map Entry must not be null\");\n         }\n         return entry.getValue();\n     }\n \n-    public V setValue(V object) {\n+    public V setValue(final V object) {\n         return entry.setValue(object);\n     }\n    \n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (object == this) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/collections/keyvalue/DefaultKeyValue.java\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/DefaultKeyValue.java\n             return false;\n         }\n \n-        DefaultKeyValue<?, ?> other = (DefaultKeyValue<?, ?>) obj;\n+        final DefaultKeyValue<?, ?> other = (DefaultKeyValue<?, ?>) obj;\n         return \n             (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n             (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n--- a/src/main/java/org/apache/commons/collections/keyvalue/MultiKey.java\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/MultiKey.java\n      * @param key2  the second key\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public MultiKey(K key1, K key2) {\n+    public MultiKey(final K key1, final K key2) {\n         this((K[]) new Object[] { key1, key2 }, false);\n     }\n \n      * @param key3  the third key\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public MultiKey(K key1, K key2, K key3) {\n+    public MultiKey(final K key1, final K key2, final K key3) {\n         this((K[]) new Object[] {key1, key2, key3}, false);\n     }\n \n      * @param key4  the fourth key\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public MultiKey(K key1, K key2, K key3, K key4) {\n+    public MultiKey(final K key1, final K key2, final K key3, final K key4) {\n         this((K[]) new Object[] {key1, key2, key3, key4}, false);\n     }\n \n      * @param key5  the fifth key\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public MultiKey(K key1, K key2, K key3, K key4, K key5) {\n+    public MultiKey(final K key1, final K key2, final K key3, final K key4, final K key5) {\n         this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);\n     }\n \n      * @param keys  the array of keys, not null\n      * @throws IllegalArgumentException if the key array is null\n      */\n-    public MultiKey(K[] keys) {\n+    public MultiKey(final K[] keys) {\n         this(keys, true);\n     }\n \n      * @throws IllegalArgumentException if the key array is null\n      * @since 3.1\n      */\n-    public MultiKey(K[] keys, boolean makeClone) {\n+    public MultiKey(final K[] keys, final boolean makeClone) {\n         super();\n         if (keys == null) {\n             throw new IllegalArgumentException(\"The array of keys must not be null\");\n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @since 3.1\n      */\n-    public K getKey(int index) {\n+    public K getKey(final int index) {\n         return keys[index];\n     }\n \n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object other) {\n+    public boolean equals(final Object other) {\n         if (other == this) {\n             return true;\n         }\n         if (other instanceof MultiKey) {\n-            MultiKey<?> otherMulti = (MultiKey<?>) other;\n+            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n             return Arrays.equals(keys, otherMulti.keys);\n         }\n         return false;\n      * Calculate the hash code of the instance using the provided keys.\n      * @param keys the keys to calculate the hash code for\n      */\n-    private void calculateHashCode(Object[] keys)\n+    private void calculateHashCode(final Object[] keys)\n     {\n         int total = 0;\n-        for (Object key : keys) {\n+        for (final Object key : keys) {\n             if (key != null) {\n                 total ^= key.hashCode();\n             }\n--- a/src/main/java/org/apache/commons/collections/keyvalue/TiedMapEntry.java\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/TiedMapEntry.java\n      * @param map  the map\n      * @param key  the key\n      */\n-    public TiedMapEntry(Map<K, V> map, K key) {\n+    public TiedMapEntry(final Map<K, V> map, final K key) {\n         super();\n         this.map = map;\n         this.key = key;\n      * @return the old value\n      * @throws IllegalArgumentException if the value is set to this map entry\n      */\n-    public V setValue(V value) {\n+    public V setValue(final V value) {\n         if (value == this) {\n             throw new IllegalArgumentException(\"Cannot set value to this map entry\");\n         }\n      * @return true if equal key and value\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map.Entry == false) {\n             return false;\n         }\n-        Map.Entry<?,?> other = (Map.Entry<?,?>) obj;\n-        Object value = getValue();\n+        final Map.Entry<?,?> other = (Map.Entry<?,?>) obj;\n+        final Object value = getValue();\n         return\n             (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n             (value == null ? other.getValue() == null : value.equals(other.getValue()));\n      */\n     @Override\n     public int hashCode() {\n-        Object value = getValue();\n+        final Object value = getValue();\n         return (getKey() == null ? 0 : getKey().hashCode()) ^\n                (value == null ? 0 : value.hashCode()); \n     }\n--- a/src/main/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntry.java\n+++ b/src/main/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntry.java\n      * @throws UnsupportedOperationException always\n      */\n     @Override\n-    public V setValue(V value) {\n+    public V setValue(final V value) {\n         throw new UnsupportedOperationException(\"setValue() is not supported\");\n     }\n \n--- a/src/main/java/org/apache/commons/collections/list/AbstractLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections/list/AbstractLinkedList.java\n      *\n      * @param coll  the collection to copy\n      */\n-    protected AbstractLinkedList(Collection<? extends E> coll) {\n+    protected AbstractLinkedList(final Collection<? extends E> coll) {\n         super();\n         init();\n         addAll(coll);\n         return size() == 0;\n     }\n \n-    public E get(int index) {\n-        Node<E> node = getNode(index, false);\n+    public E get(final int index) {\n+        final Node<E> node = getNode(index, false);\n         return node.getValue();\n     }\n \n         return new LinkedListIterator<E>(this, 0);\n     }\n \n-    public ListIterator<E> listIterator(int fromIndex) {\n+    public ListIterator<E> listIterator(final int fromIndex) {\n         return new LinkedListIterator<E>(this, fromIndex);\n     }\n \n     //-----------------------------------------------------------------------\n     \n-    public int indexOf(Object value) {\n+    public int indexOf(final Object value) {\n         int i = 0;\n         for (Node<E> node = header.next; node != header; node = node.next) {\n             if (isEqualValue(node.getValue(), value)) {\n         return -1;\n     }\n \n-    public int lastIndexOf(Object value) {\n+    public int lastIndexOf(final Object value) {\n         int i = size - 1;\n         for (Node<E> node = header.previous; node != header; node = node.previous) {\n             if (isEqualValue(node.getValue(), value)) {\n         return -1;\n     }\n \n-    public boolean contains(Object value) {\n+    public boolean contains(final Object value) {\n         return indexOf(value) != -1;\n     }\n \n-    public boolean containsAll(Collection<?> coll) {\n-        for (Object o : coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object o : coll) {\n             if (!contains(o)) {\n                 return false;\n             }\n     public <T> T[] toArray(T[] array) {\n         // Extend the array if needed\n         if (array.length < size) {\n-            Class<?> componentType = array.getClass().getComponentType();\n+            final Class<?> componentType = array.getClass().getComponentType();\n             array = (T[]) Array.newInstance(componentType, size);\n         }\n         // Copy the values into the array\n      * @param toIndexExclusive  the index to end at\n      * @return the new sublist\n      */\n-    public List<E> subList(int fromIndexInclusive, int toIndexExclusive) {\n+    public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n         return new LinkedSubList<E>(this, fromIndexInclusive, toIndexExclusive);\n     }\n \n     //-----------------------------------------------------------------------\n     \n-    public boolean add(E value) {\n+    public boolean add(final E value) {\n         addLast(value);\n         return true;\n     }\n \n-    public void add(int index, E value) {\n-        Node<E> node = getNode(index, true);\n+    public void add(final int index, final E value) {\n+        final Node<E> node = getNode(index, true);\n         addNodeBefore(node, value);\n     }\n \n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         return addAll(size, coll);\n     }\n \n-    public boolean addAll(int index, Collection<? extends E> coll) {\n-        Node<E> node = getNode(index, true);\n-        for (E e : coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        final Node<E> node = getNode(index, true);\n+        for (final E e : coll) {\n             addNodeBefore(node, e);\n         }\n         return true;\n \n     //-----------------------------------------------------------------------\n     \n-    public E remove(int index) {\n-        Node<E> node = getNode(index, false);\n-        E oldValue = node.getValue();\n+    public E remove(final int index) {\n+        final Node<E> node = getNode(index, false);\n+        final E oldValue = node.getValue();\n         removeNode(node);\n         return oldValue;\n     }\n \n-    public boolean remove(Object value) {\n+    public boolean remove(final Object value) {\n         for (Node<E> node = header.next; node != header; node = node.next) {\n             if (isEqualValue(node.getValue(), value)) {\n                 removeNode(node);\n      * <code>coll</code> that provides a fast (e.g. O(1)) implementation of\n      * {@link Collection#contains(Object)}.\n      */\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         boolean modified = false;\n-        Iterator<E> it = iterator();\n+        final Iterator<E> it = iterator();\n         while (it.hasNext()) {\n             if (coll.contains(it.next())) {\n                 it.remove();\n      * <code>coll</code> that provides a fast (e.g. O(1)) implementation of\n      * {@link Collection#contains(Object)}.\n      */\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         boolean modified = false;\n-        Iterator<E> it = iterator();\n+        final Iterator<E> it = iterator();\n         while (it.hasNext()) {\n             if (coll.contains(it.next()) == false) {\n                 it.remove();\n         return modified;\n     }\n \n-    public E set(int index, E value) {\n-        Node<E> node = getNode(index, false);\n-        E oldValue = node.getValue();\n+    public E set(final int index, final E value) {\n+        final Node<E> node = getNode(index, false);\n+        final E oldValue = node.getValue();\n         updateNode(node, value);\n         return oldValue;\n     }\n     //-----------------------------------------------------------------------\n     \n     public E getFirst() {\n-        Node<E> node = header.next;\n+        final Node<E> node = header.next;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n     }\n \n     public E getLast() {\n-        Node<E> node = header.previous;\n+        final Node<E> node = header.previous;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n         return node.getValue();\n     }\n \n-    public boolean addFirst(E o) {\n+    public boolean addFirst(final E o) {\n         addNodeAfter(header, o);\n         return true;\n     }\n \n-    public boolean addLast(E o) {\n+    public boolean addLast(final E o) {\n         addNodeBefore(header, o);\n         return true;\n     }\n \n     public E removeFirst() {\n-        Node<E> node = header.next;\n+        final Node<E> node = header.next;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n-        E oldValue = node.getValue();\n+        final E oldValue = node.getValue();\n         removeNode(node);\n         return oldValue;\n     }\n \n     public E removeLast() {\n-        Node<E> node = header.previous;\n+        final Node<E> node = header.previous;\n         if (node == header) {\n             throw new NoSuchElementException();\n         }\n-        E oldValue = node.getValue();\n+        final E oldValue = node.getValue();\n         removeNode(node);\n         return oldValue;\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof List == false) {\n             return false;\n         }\n-        List<?> other = (List<?>) obj;\n+        final List<?> other = (List<?>) obj;\n         if (other.size() != size()) {\n             return false;\n         }\n-        ListIterator<?> it1 = listIterator();\n-        ListIterator<?> it2 = other.listIterator();\n+        final ListIterator<?> it1 = listIterator();\n+        final ListIterator<?> it2 = other.listIterator();\n         while (it1.hasNext() && it2.hasNext()) {\n-            Object o1 = it1.next();\n-            Object o2 = it2.next();\n+            final Object o1 = it1.next();\n+            final Object o2 = it2.next();\n             if (!(o1 == null ? o2 == null : o1.equals(o2))) {\n                 return false;\n             }\n     @Override\n     public int hashCode() {\n         int hashCode = 1;\n-        for (E e : this) {\n+        for (final E e : this) {\n             hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n         }\n         return hashCode;\n         if (size() == 0) {\n             return \"[]\";\n         }\n-        StringBuilder buf = new StringBuilder(16 * size());\n+        final StringBuilder buf = new StringBuilder(16 * size());\n         buf.append(\"[\");\n \n-        Iterator<E> it = iterator();\n+        final Iterator<E> it = iterator();\n         boolean hasNext = it.hasNext();\n         while (hasNext) {\n-            Object value = it.next();\n+            final Object value = it.next();\n             buf.append(value == this ? \"(this Collection)\" : value);\n             hasNext = it.hasNext();\n             if (hasNext) {\n      * @param value2  the second value to compare, may be null\n      * @return true if equal\n      */\n-    protected boolean isEqualValue(Object value1, Object value2) {\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n         return value1 == value2 || (value1 == null ? false : value1.equals(value2));\n     }\n \n      * @param node  node to update\n      * @param value  new value of the node\n      */\n-    protected void updateNode(Node<E> node, E value) {\n+    protected void updateNode(final Node<E> node, final E value) {\n         node.setValue(value);\n     }\n \n      * @param value  value of the new node\n      * @return a new node containing the value\n      */\n-    protected Node<E> createNode(E value) {\n+    protected Node<E> createNode(final E value) {\n         return new Node<E>(value);\n     }\n \n      * @param value  value of the newly added node\n      * @throws NullPointerException if <code>node</code> is null\n      */\n-    protected void addNodeBefore(Node<E> node, E value) {\n-        Node<E> newNode = createNode(value);\n+    protected void addNodeBefore(final Node<E> node, final E value) {\n+        final Node<E> newNode = createNode(value);\n         addNode(newNode, node);\n     }\n \n      * @param value  value of the newly added node\n      * @throws NullPointerException if <code>node</code> is null\n      */\n-    protected void addNodeAfter(Node<E> node, E value) {\n-        Node<E> newNode = createNode(value);\n+    protected void addNodeAfter(final Node<E> node, final E value) {\n+        final Node<E> newNode = createNode(value);\n         addNode(newNode, node.next);\n     }\n \n      * @param insertBeforeNode  node to insert before\n      * @throws NullPointerException if either node is null\n      */\n-    protected void addNode(Node<E> nodeToInsert, Node<E> insertBeforeNode) {\n+    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n         nodeToInsert.next = insertBeforeNode;\n         nodeToInsert.previous = insertBeforeNode.previous;\n         insertBeforeNode.previous.next = nodeToInsert;\n      * @param node  the node to remove\n      * @throws NullPointerException if <code>node</code> is null\n      */\n-    protected void removeNode(Node<E> node) {\n+    protected void removeNode(final Node<E> node) {\n         node.previous.next = node.next;\n         node.next.previous = node.previous;\n         size--;\n      * the size of the list and endMakerAllowed is false; or greater than the\n      * size of the list\n      */\n-    protected Node<E> getNode(int index, boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n+    protected Node<E> getNode(final int index, final boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n         // Check the index is within the bounds\n         if (index < 0) {\n             throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n      * @param subList  the sublist to get an iterator for\n      * @return a new iterator on the given sublist\n      */\n-    protected Iterator<E> createSubListIterator(LinkedSubList<E> subList) {\n+    protected Iterator<E> createSubListIterator(final LinkedSubList<E> subList) {\n         return createSubListListIterator(subList, 0);\n     }\n \n      * @param fromIndex  the index to start from, relative to the sublist\n      * @return a new list iterator on the given sublist\n      */\n-    protected ListIterator<E> createSubListListIterator(LinkedSubList<E> subList, int fromIndex) {\n+    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n         return new LinkedSubListIterator<E>(subList, fromIndex);\n     }\n \n      * The first serializable subclass must call this method from\n      * <code>writeObject</code>.\n      */\n-    protected void doWriteObject(ObjectOutputStream outputStream) throws IOException {\n+    protected void doWriteObject(final ObjectOutputStream outputStream) throws IOException {\n         // Write the size so we know how many nodes to read back\n         outputStream.writeInt(size());\n-        for (E e : this) {\n+        for (final E e : this) {\n             outputStream.writeObject(e);\n         }\n     }\n      * <code>readObject</code>.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected void doReadObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n+    protected void doReadObject(final ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n         init();\n-        int size = inputStream.readInt();\n+        final int size = inputStream.readInt();\n         for (int i = 0; i < size; i++) {\n             add((E) inputStream.readObject());\n         }\n          *\n          * @param value  the value to store\n          */\n-        protected Node(E value) {\n+        protected Node(final E value) {\n             super();\n             this.value = value;\n         }\n          * @param next  the next node in the list\n          * @param value  the value to store\n          */\n-        protected Node(Node<E> previous, Node<E> next, E value) {\n+        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n             super();\n             this.previous = previous;\n             this.next = next;\n          * @param value  the value\n          * @since 3.1\n          */\n-        protected void setValue(E value) {\n+        protected void setValue(final E value) {\n             this.value = value;\n         }\n \n          * @param previous  the previous node\n          * @since 3.1\n          */\n-        protected void setPreviousNode(Node<E> previous) {\n+        protected void setPreviousNode(final Node<E> previous) {\n             this.previous = previous;\n         }\n \n          * @param next  the next node\n          * @since 3.1\n          */\n-        protected void setNextNode(Node<E> next) {\n+        protected void setNextNode(final Node<E> next) {\n             this.next = next;\n         }\n     }\n          * @param fromIndex  the index to start at\n          * @throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list\n          */\n-        protected LinkedListIterator(AbstractLinkedList<E> parent, int fromIndex) throws IndexOutOfBoundsException {\n+        protected LinkedListIterator(final AbstractLinkedList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n             super();\n             this.parent = parent;\n             this.expectedModCount = parent.modCount;\n             if (!hasNext()) {\n                 throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n             }\n-            E value = next.getValue();\n+            final E value = next.getValue();\n             current = next;\n             next = next.next;\n             nextIndex++;\n                 throw new NoSuchElementException(\"Already at start of list.\");\n             }\n             next = next.previous;\n-            E value = next.getValue();\n+            final E value = next.getValue();\n             current = next;\n             nextIndex--;\n             return value;\n             expectedModCount++;\n         }\n \n-        public void set(E obj) {\n+        public void set(final E obj) {\n             checkModCount();\n             getLastNodeReturned().setValue(obj);\n         }\n \n-        public void add(E obj) {\n+        public void add(final E obj) {\n             checkModCount();\n             parent.addNodeBefore(next, obj);\n             current = null;\n         /** The parent list */\n         protected final LinkedSubList<E> sub;\n \n-        protected LinkedSubListIterator(LinkedSubList<E> sub, int startIndex) {\n+        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n             super(sub.parent, startIndex + sub.offset);\n             this.sub = sub;\n         }\n         }\n \n         @Override\n-        public void add(E obj) {\n+        public void add(final E obj) {\n             super.add(obj);\n             sub.expectedModCount = parent.modCount;\n             sub.size++;\n         /** Sublist modCount */\n         int expectedModCount;\n \n-        protected LinkedSubList(AbstractLinkedList<E> parent, int fromIndex, int toIndex) {\n+        protected LinkedSubList(final AbstractLinkedList<E> parent, final int fromIndex, final int toIndex) {\n             if (fromIndex < 0) {\n                 throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n             }\n         }\n \n         @Override\n-        public E get(int index) {\n+        public E get(final int index) {\n             rangeCheck(index, size);\n             checkModCount();\n             return parent.get(index + offset);\n         }\n \n         @Override\n-        public void add(int index, E obj) {\n+        public void add(final int index, final E obj) {\n             rangeCheck(index, size + 1);\n             checkModCount();\n             parent.add(index + offset, obj);\n         }\n \n         @Override\n-        public E remove(int index) {\n+        public E remove(final int index) {\n             rangeCheck(index, size);\n             checkModCount();\n-            E result = parent.remove(index + offset);\n+            final E result = parent.remove(index + offset);\n             expectedModCount = parent.modCount;\n             size--;\n             LinkedSubList.this.modCount++;\n         }\n \n         @Override\n-        public boolean addAll(Collection<? extends E> coll) {\n+        public boolean addAll(final Collection<? extends E> coll) {\n             return addAll(size, coll);\n         }\n \n         @Override\n-        public boolean addAll(int index, Collection<? extends E> coll) {\n+        public boolean addAll(final int index, final Collection<? extends E> coll) {\n             rangeCheck(index, size + 1);\n-            int cSize = coll.size();\n+            final int cSize = coll.size();\n             if (cSize == 0) {\n                 return false;\n             }\n         }\n \n         @Override\n-        public E set(int index, E obj) {\n+        public E set(final int index, final E obj) {\n             rangeCheck(index, size);\n             checkModCount();\n             return parent.set(index + offset, obj);\n         @Override\n         public void clear() {\n             checkModCount();\n-            Iterator<E> it = iterator();\n+            final Iterator<E> it = iterator();\n             while (it.hasNext()) {\n                 it.next();\n                 it.remove();\n         }\n \n         @Override\n-        public List<E> subList(int fromIndexInclusive, int toIndexExclusive) {\n+        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n             return new LinkedSubList<E>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n         }\n \n-        protected void rangeCheck(int index, int beyond) {\n+        protected void rangeCheck(final int index, final int beyond) {\n             if (index < 0 || index >= beyond) {\n                 throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n             }\n--- a/src/main/java/org/apache/commons/collections/list/AbstractListDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/list/AbstractListDecorator.java\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected AbstractListDecorator(List<E> list) {\n+    protected AbstractListDecorator(final List<E> list) {\n         super(list);\n     }\n \n \n     //-----------------------------------------------------------------------\n     \n-    public void add(int index, E object) {\n+    public void add(final int index, final E object) {\n         decorated().add(index, object);\n     }\n \n-    public boolean addAll(int index, Collection<? extends E> coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n         return decorated().addAll(index, coll);\n     }\n \n-    public E get(int index) {\n+    public E get(final int index) {\n         return decorated().get(index);\n     }\n \n-    public int indexOf(Object object) {\n+    public int indexOf(final Object object) {\n         return decorated().indexOf(object);\n     }\n \n-    public int lastIndexOf(Object object) {\n+    public int lastIndexOf(final Object object) {\n         return decorated().lastIndexOf(object);\n     }\n \n         return decorated().listIterator();\n     }\n \n-    public ListIterator<E> listIterator(int index) {\n+    public ListIterator<E> listIterator(final int index) {\n         return decorated().listIterator(index);\n     }\n \n-    public E remove(int index) {\n+    public E remove(final int index) {\n         return decorated().remove(index);\n     }\n \n-    public E set(int index, E object) {\n+    public E set(final int index, final E object) {\n         return decorated().set(index, object);\n     }\n \n-    public List<E> subList(int fromIndex, int toIndex) {\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n         return decorated().subList(fromIndex, toIndex);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/list/AbstractSerializableListDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/list/AbstractSerializableListDecorator.java\n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected AbstractSerializableListDecorator(List<E> list) {\n+    protected AbstractSerializableListDecorator(final List<E> list) {\n         super(list);\n     }\n \n      * @param out  the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(collection);\n     }\n      * @throws ClassNotFoundException\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         collection = (Collection<E>) in.readObject();\n     }\n--- a/src/main/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections/list/CursorableLinkedList.java\n      * \n      * @param coll  the collection to copy\n      */\n-    public CursorableLinkedList(Collection<E> coll) {\n+    public CursorableLinkedList(final Collection<E> coll) {\n         super(coll);\n     }\n \n      * @return a new cursor iterator\n      */\n     @Override\n-    public ListIterator<E> listIterator(int fromIndex) {\n+    public ListIterator<E> listIterator(final int fromIndex) {\n         return cursor(fromIndex);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      *      (index &lt; 0 || index &gt; size()).\n      */\n-    public CursorableLinkedList.Cursor<E> cursor(int fromIndex) {\n-        Cursor<E> cursor = new Cursor<E>(this, fromIndex);\n+    public CursorableLinkedList.Cursor<E> cursor(final int fromIndex) {\n+        final Cursor<E> cursor = new Cursor<E>(this, fromIndex);\n         registerCursor(cursor);\n         return cursor;\n     }\n      * @param value  new value of the node\n      */\n     @Override\n-    protected void updateNode(Node<E> node, E value) {\n+    protected void updateNode(final Node<E> node, final E value) {\n         super.updateNode(node, value);\n         broadcastNodeChanged(node);\n     }\n      * @throws NullPointerException if either node is null\n      */\n     @Override\n-    protected void addNode(Node<E> nodeToInsert, Node<E> insertBeforeNode) {\n+    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n         super.addNode(nodeToInsert, insertBeforeNode);\n         broadcastNodeInserted(nodeToInsert);\n     }\n      * @throws NullPointerException if <code>node</code> is null\n      */\n     @Override\n-    protected void removeNode(Node<E> node) {\n+    protected void removeNode(final Node<E> node) {\n         super.removeNode(node);\n         broadcastNodeRemoved(node);\n     }\n     protected void removeAllNodes() {\n         if (size() > 0) {\n             // superclass implementation would break all the iterators\n-            Iterator<E> it = iterator();\n+            final Iterator<E> it = iterator();\n             while (it.hasNext()) {\n                 it.next();\n                 it.remove();\n      * \n      * @param cursor  the cursor to register\n      */\n-    protected void registerCursor(Cursor<E> cursor) {\n+    protected void registerCursor(final Cursor<E> cursor) {\n         // We take this opportunity to clean the cursors list\n         // of WeakReference objects to garbage-collected cursors.\n-        for (Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n-            WeakReference<Cursor<E>> ref = it.next();\n+        for (final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            final WeakReference<Cursor<E>> ref = it.next();\n             if (ref.get() == null) {\n                 it.remove();\n             }\n      * \n      * @param cursor  the cursor to deregister\n      */\n-    protected void unregisterCursor(Cursor<E> cursor) {\n-        for (Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n-            WeakReference<Cursor<E>> ref = it.next();\n-            Cursor<E> cur = ref.get();\n+    protected void unregisterCursor(final Cursor<E> cursor) {\n+        for (final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cur = ref.get();\n             if (cur == null) {\n                 // some other unrelated cursor object has been \n                 // garbage-collected; let's take the opportunity to\n      * \n      * @param node  the node that was changed\n      */\n-    protected void broadcastNodeChanged(Node<E> node) {\n-        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+    protected void broadcastNodeChanged(final Node<E> node) {\n+        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n         while (it.hasNext()) {\n-            WeakReference<Cursor<E>> ref = it.next();\n-            Cursor<E> cursor = ref.get();\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cursor = ref.get();\n             if (cursor == null) {\n                 it.remove(); // clean up list\n             } else {\n      * \n      * @param node  the node that was changed\n      */\n-    protected void broadcastNodeRemoved(Node<E> node) {\n-        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+    protected void broadcastNodeRemoved(final Node<E> node) {\n+        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n         while (it.hasNext()) {\n-            WeakReference<Cursor<E>> ref = it.next();\n-            Cursor<E> cursor = ref.get();\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cursor = ref.get();\n             if (cursor == null) {\n                 it.remove(); // clean up list\n             } else {\n      * \n      * @param node  the node that was changed\n      */\n-    protected void broadcastNodeInserted(Node<E> node) {\n-        Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+    protected void broadcastNodeInserted(final Node<E> node) {\n+        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n         while (it.hasNext()) {\n-            WeakReference<Cursor<E>> ref = it.next();\n-            Cursor<E> cursor = ref.get();\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cursor = ref.get();\n             if (cursor == null) {\n                 it.remove(); // clean up list\n             } else {\n     /**\n      * Serializes the data held in this object to the stream specified.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Deserializes the data held in this object to the stream specified.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n      * @return the list iterator for the sublist\n      */\n     @Override\n-    protected ListIterator<E> createSubListListIterator(LinkedSubList<E> subList, int fromIndex) {\n-        SubCursor<E> cursor = new SubCursor<E>(subList, fromIndex);\n+    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n+        final SubCursor<E> cursor = new SubCursor<E>(subList, fromIndex);\n         registerCursor(cursor);\n         return cursor;\n     }\n          * @param parent  the parent list\n          * @param index  the index to start from\n          */\n-        protected Cursor(CursorableLinkedList<E> parent, int index) {\n+        protected Cursor(final CursorableLinkedList<E> parent, final int index) {\n             super(parent, index);\n             valid = true;\n         }\n          * @param obj  the object to add\n          */\n         @Override\n-        public void add(E obj) {\n+        public void add(final E obj) {\n             // overridden, as the nodeInserted() method updates the iterator state\n             super.add(obj);\n             // matches the (next.previous == node) clause in nodeInserted()\n          * \n          * @param node  the node that changed\n          */\n-        protected void nodeChanged(Node<E> node) {\n+        protected void nodeChanged(final Node<E> node) {\n             // do nothing\n         }\n \n          * \n          * @param node  the node that was removed\n          */\n-        protected void nodeRemoved(Node<E> node) {\n+        protected void nodeRemoved(final Node<E> node) {\n             if (node == next && node == current) {\n                 // state where next() followed by previous()\n                 next = node.next;\n          * \n          * @param node  the node that was added\n          */\n-        protected void nodeInserted(Node<E> node) {\n+        protected void nodeInserted(final Node<E> node) {\n             if (node.previous == current) {\n                 next = node;\n             } else if (next.previous == node) {\n          * @param sub  the sub list\n          * @param index  the index to start from\n          */\n-        protected SubCursor(LinkedSubList<E> sub, int index) {\n+        protected SubCursor(final LinkedSubList<E> sub, final int index) {\n             super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n             this.sub = sub;\n         }\n         }\n \n         @Override\n-        public void add(E obj) {\n+        public void add(final E obj) {\n             super.add(obj);\n             sub.expectedModCount = parent.modCount;\n             sub.size++;\n--- a/src/main/java/org/apache/commons/collections/list/FixedSizeList.java\n+++ b/src/main/java/org/apache/commons/collections/list/FixedSizeList.java\n      * @return a new fixed size list\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> FixedSizeList<E> fixedSizeList(List<E> list) {\n+    public static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n         return new FixedSizeList<E>(list);\n     }\n \n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected FixedSizeList(List<E> list) {\n+    protected FixedSizeList(final List<E> list) {\n         super(list);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     @Override\n-    public void add(int index, E object) {\n+    public void add(final int index, final E object) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     @Override\n-    public boolean addAll(int index, Collection<? extends E> coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     }\n \n     @Override\n-    public E get(int index) {\n+    public E get(final int index) {\n         return decorated().get(index);\n     }\n \n     @Override\n-    public int indexOf(Object object) {\n+    public int indexOf(final Object object) {\n         return decorated().indexOf(object);\n     }\n \n     }\n \n     @Override\n-    public int lastIndexOf(Object object) {\n+    public int lastIndexOf(final Object object) {\n         return decorated().lastIndexOf(object);\n     }\n \n     }\n \n     @Override\n-    public ListIterator<E> listIterator(int index) {\n+    public ListIterator<E> listIterator(final int index) {\n         return new FixedSizeListIterator(decorated().listIterator(index));\n     }\n \n     @Override\n-    public E remove(int index) {\n+    public E remove(final int index) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException(\"List is fixed size\");\n     }\n \n     @Override\n-    public E set(int index, E object) {\n+    public E set(final int index, final E object) {\n         return decorated().set(index, object);\n     }\n \n     @Override\n-    public List<E> subList(int fromIndex, int toIndex) {\n-        List<E> sub = decorated().subList(fromIndex, toIndex);\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n         return new FixedSizeList<E>(sub);\n     }\n \n      * List iterator that only permits changes via set()\n      */\n     private class FixedSizeListIterator extends AbstractListIteratorDecorator<E> {\n-        protected FixedSizeListIterator(ListIterator<E> iterator) {\n+        protected FixedSizeListIterator(final ListIterator<E> iterator) {\n             super(iterator);\n         }\n         @Override\n             throw new UnsupportedOperationException(\"List is fixed size\");\n         }\n         @Override\n-        public void add(Object object) {\n+        public void add(final Object object) {\n             throw new UnsupportedOperationException(\"List is fixed size\");\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/list/GrowthList.java\n+++ b/src/main/java/org/apache/commons/collections/list/GrowthList.java\n      * @return a new growth list\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> GrowthList<E> growthList(List<E> list) {\n+    public static <E> GrowthList<E> growthList(final List<E> list) {\n         return new GrowthList<E>(list);\n     }\n \n      * @param initialSize  the initial size of the ArrayList\n      * @throws IllegalArgumentException if initial size is invalid\n      */\n-    public GrowthList(int initialSize) {\n+    public GrowthList(final int initialSize) {\n         super(new ArrayList<E>(initialSize));\n     }\n \n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected GrowthList(List<E> list) {\n+    protected GrowthList(final List<E> list) {\n         super(list);\n     }\n \n      * @throws IllegalArgumentException if the underlying list rejects the element\n      */\n     @Override\n-    public void add(int index, E element) {\n-        int size = decorated().size();\n+    public void add(final int index, final E element) {\n+        final int size = decorated().size();\n         if (index > size) {\n             decorated().addAll(Collections.<E>nCopies(index - size, null));\n         }\n      * @throws IllegalArgumentException if the underlying list rejects the element\n      */\n     @Override\n-    public boolean addAll(int index, Collection<? extends E> coll) {\n-        int size = decorated().size();\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        final int size = decorated().size();\n         boolean result = false;\n         if (index > size) {\n             decorated().addAll(Collections.<E>nCopies(index - size, null));\n      * @throws IllegalArgumentException if the underlying list rejects the element\n      */\n     @Override\n-    public E set(int index, E element) {\n-        int size = decorated().size();\n+    public E set(final int index, final E element) {\n+        final int size = decorated().size();\n         if (index >= size) {\n             decorated().addAll(Collections.<E>nCopies(index - size + 1, null));\n         }\n--- a/src/main/java/org/apache/commons/collections/list/LazyList.java\n+++ b/src/main/java/org/apache/commons/collections/list/LazyList.java\n      * @return a new lazy list\n      * @throws IllegalArgumentException if list or factory is null\n      */\n-    public static <E> LazyList<E> lazyList(List<E> list, Factory<? extends E> factory) {\n+    public static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n         return new LazyList<E>(list, factory);\n     }\n     \n      * @param factory  the factory to use for creation, must not be null\n      * @throws IllegalArgumentException if list or factory is null\n      */\n-    protected LazyList(List<E> list, Factory<? extends E> factory) {\n+    protected LazyList(final List<E> list, final Factory<? extends E> factory) {\n         super(list);\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n      * @return the element at the given index\n      */\n     @Override\n-    public E get(int index) {\n-        int size = decorated().size();\n+    public E get(final int index) {\n+        final int size = decorated().size();\n         if (index < size) {\n             // within bounds, get the object\n             E object = decorated().get(index);\n             decorated().add(null);\n         }\n         // create our last object, set and return\n-        E object = factory.create();\n+        final E object = factory.create();\n         decorated().add(object);\n         return object;\n     }\n \n     @Override\n-    public List<E> subList(int fromIndex, int toIndex) {\n-        List<E> sub = decorated().subList(fromIndex, toIndex);\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n         return new LazyList<E>(sub, factory);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n      * \n      * @param coll  the collection to copy\n      */\n-    public NodeCachingLinkedList(Collection<E> coll) {\n+    public NodeCachingLinkedList(final Collection<E> coll) {\n         super(coll);\n         this.maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n     }\n      *\n      * @param maximumCacheSize  the maximum cache size\n      */\n-    public NodeCachingLinkedList(int maximumCacheSize) {\n+    public NodeCachingLinkedList(final int maximumCacheSize) {\n         super();\n         this.maximumCacheSize = maximumCacheSize;\n         init();  // must call init() as use super();\n      * \n      * @param maximumCacheSize  the new maximum cache size\n      */\n-    protected void setMaximumCacheSize(int maximumCacheSize) {\n+    protected void setMaximumCacheSize(final int maximumCacheSize) {\n         this.maximumCacheSize = maximumCacheSize;\n         shrinkCacheToMaximumSize();\n     }\n         if (cacheSize == 0) {\n             return null;\n         }\n-        Node<E> cachedNode = firstCachedNode;\n+        final Node<E> cachedNode = firstCachedNode;\n         firstCachedNode = cachedNode.next;\n         cachedNode.next = null; // This should be changed anyway, but defensively\n                                 // set it to null.                    \n      * \n      * @param node  the node to add to the cache\n      */\n-    protected void addNodeToCache(Node<E> node) {\n+    protected void addNodeToCache(final Node<E> node) {\n         if (isCacheFull()) {\n             // don't cache the node.\n             return;\n         }\n         // clear the node's contents and add it to the cache.\n-        Node<E> nextCachedNode = firstCachedNode;\n+        final Node<E> nextCachedNode = firstCachedNode;\n         node.previous = null;\n         node.next = nextCachedNode;\n         node.setValue(null);\n      * @return the newly created node\n      */\n     @Override\n-    protected Node<E> createNode(E value) {\n-        Node<E> cachedNode = getNodeFromCache();\n+    protected Node<E> createNode(final E value) {\n+        final Node<E> cachedNode = getNodeFromCache();\n         if (cachedNode == null) {\n             return super.createNode(value);\n         }\n      * @param node  the node to remove\n      */\n     @Override\n-    protected void removeNode(Node<E> node) {\n+    protected void removeNode(final Node<E> node) {\n         super.removeNode(node);\n         addNodeToCache(node);\n     }\n         // We can add them to the cache before removing them, since\n         // {@link AbstractLinkedList.removeAllNodes()} removes the\n         // nodes by removing references directly from {@link #header}.\n-        int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n+        final int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n         Node<E> node = header.next;\n         for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n-            Node<E> oldNode = node;\n+            final Node<E> oldNode = node;\n             node = node.next;\n             addNodeToCache(oldNode);\n         }\n     /**\n      * Serializes the data held in this object to the stream specified.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Deserializes the data held in this object to the stream specified.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n--- a/src/main/java/org/apache/commons/collections/list/PredicatedList.java\n+++ b/src/main/java/org/apache/commons/collections/list/PredicatedList.java\n      * @throws IllegalArgumentException if list or predicate is null\n      * @throws IllegalArgumentException if the list contains invalid elements\n      */\n-    public static <T> PredicatedList<T> predicatedList(List<T> list, Predicate<? super T> predicate) {\n+    public static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n         return new PredicatedList<T>(list, predicate);\n     }\n \n      * @throws IllegalArgumentException if list or predicate is null\n      * @throws IllegalArgumentException if the list contains invalid elements\n      */\n-    protected PredicatedList(List<E> list, Predicate<? super E> predicate) {\n+    protected PredicatedList(final List<E> list, final Predicate<? super E> predicate) {\n         super(list, predicate);\n     }\n \n \n     //-----------------------------------------------------------------------\n     \n-    public E get(int index) {\n+    public E get(final int index) {\n         return decorated().get(index);\n     }\n \n-    public int indexOf(Object object) {\n+    public int indexOf(final Object object) {\n         return decorated().indexOf(object);\n     }\n \n-    public int lastIndexOf(Object object) {\n+    public int lastIndexOf(final Object object) {\n         return decorated().lastIndexOf(object);\n     }\n \n-    public E remove(int index) {\n+    public E remove(final int index) {\n         return decorated().remove(index);\n     }\n \n     //-----------------------------------------------------------------------\n     \n-    public void add(int index, E object) {\n+    public void add(final int index, final E object) {\n         validate(object);\n         decorated().add(index, object);\n     }\n \n-    public boolean addAll(int index, Collection<? extends E> coll) {\n-        for (E aColl : coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        for (final E aColl : coll) {\n             validate(aColl);\n         }\n         return decorated().addAll(index, coll);\n         return listIterator(0);\n     }\n \n-    public ListIterator<E> listIterator(int i) {\n+    public ListIterator<E> listIterator(final int i) {\n         return new PredicatedListIterator(decorated().listIterator(i));\n     }\n \n-    public E set(int index, E object) {\n+    public E set(final int index, final E object) {\n         validate(object);\n         return decorated().set(index, object);\n     }\n \n-    public List<E> subList(int fromIndex, int toIndex) {\n-        List<E> sub = decorated().subList(fromIndex, toIndex);\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n         return new PredicatedList<E>(sub, predicate);\n     }\n \n          * \n          * @param iterator  the list iterator to decorate\n          */\n-        protected PredicatedListIterator(ListIterator<E> iterator) {\n+        protected PredicatedListIterator(final ListIterator<E> iterator) {\n             super(iterator);\n         }\n         \n         @Override\n-        public void add(E object) {\n+        public void add(final E object) {\n             validate(object);\n             iterator.add(object);\n         }\n         \n         @Override\n-        public void set(E object) {\n+        public void set(final E object) {\n             validate(object);\n             iterator.set(object);\n         }\n--- a/src/main/java/org/apache/commons/collections/list/SetUniqueList.java\n+++ b/src/main/java/org/apache/commons/collections/list/SetUniqueList.java\n      * @throws IllegalArgumentException\n      *             if list is null\n      */\n-    public static <E> SetUniqueList<E> setUniqueList(List<E> list) {\n+    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n         if (list.isEmpty()) {\n             return new SetUniqueList<E>(list, new HashSet<E>());\n         }\n-        List<E> temp = new ArrayList<E>(list);\n+        final List<E> temp = new ArrayList<E>(list);\n         list.clear();\n-        SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n+        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n         sl.addAll(temp);\n         return sl;\n     }\n      * @throws IllegalArgumentException\n      *             if set or list is null\n      */\n-    protected SetUniqueList(List<E> list, Set<E> set) {\n+    protected SetUniqueList(final List<E> list, final Set<E> set) {\n         super(list);\n         if (set == null) {\n             throw new IllegalArgumentException(\"Set must not be null\");\n      * @return true if object was added\n      */\n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         // gets initial size\n         final int sizeBefore = size();\n \n      *            the object to add\n      */\n     @Override\n-    public void add(int index, E object) {\n+    public void add(final int index, final E object) {\n         // adds element if it is not contained already\n         if (set.contains(object) == false) {\n             super.add(index, object);\n      * @return true if this collection changed\n      */\n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         return addAll(size(), coll);\n     }\n \n      * @return true if this collection changed\n      */\n     @Override\n-    public boolean addAll(int index, Collection<? extends E> coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n         final List<E> temp = new ArrayList<E>();\n-        for (E e : coll) {\n+        for (final E e : coll) {\n             if (set.add(e)) {\n                 temp.add(e);\n             }\n      * @return the previous object\n      */\n     @Override\n-    public E set(int index, E object) {\n-        int pos = indexOf(object);\n-        E removed = super.set(index, object);\n+    public E set(final int index, final E object) {\n+        final int pos = indexOf(object);\n+        final E removed = super.set(index, object);\n \n         if (pos != -1 && pos != index) {\n             // the object is already in the uniq list\n     }\n \n     @Override\n-    public boolean remove(Object object) {\n-        boolean result = set.remove(object);\n+    public boolean remove(final Object object) {\n+        final boolean result = set.remove(object);\n         if (result) {\n             super.remove(object);\n         }\n     }\n \n     @Override\n-    public E remove(int index) {\n-        E result = super.remove(index);\n+    public E remove(final int index) {\n+        final E result = super.remove(index);\n         set.remove(result);\n         return result;\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         boolean result = false;\n-        for (Object name : coll) {\n+        for (final Object name : coll) {\n             result |= remove(name);\n         }\n         return result;\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n-        Set<Object> setRetainAll = new HashSet<Object>();\n-        for (Object next : coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n+        final Set<Object> setRetainAll = new HashSet<Object>();\n+        for (final Object next : coll) {\n             if (set.contains(next)) {\n                 setRetainAll.add(next);\n             }\n         if (setRetainAll.size() == 0) {\n             clear();\n         } else {\n-            for (Iterator<E> it = iterator(); it.hasNext();) {\n+            for (final Iterator<E> it = iterator(); it.hasNext();) {\n                 if (!setRetainAll.contains(it.next())) {\n                     it.remove();\n                 }\n     }\n \n     @Override\n-    public boolean contains(Object object) {\n+    public boolean contains(final Object object) {\n         return set.contains(object);\n     }\n \n     @Override\n-    public boolean containsAll(Collection<?> coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n         return set.containsAll(coll);\n     }\n \n     }\n \n     @Override\n-    public ListIterator<E> listIterator(int index) {\n+    public ListIterator<E> listIterator(final int index) {\n         return new SetListListIterator<E>(super.listIterator(index), set);\n     }\n \n     @Override\n-    public List<E> subList(int fromIndex, int toIndex) {\n-        List<E> superSubList = super.subList(fromIndex, toIndex);\n-        Set<E> subSet = createSetBasedOnList(set, superSubList);\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> superSubList = super.subList(fromIndex, toIndex);\n+        final Set<E> subSet = createSetBasedOnList(set, superSubList);\n         return new SetUniqueList<E>(superSubList, subSet);\n     }\n \n      *         {@link List}\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected Set<E> createSetBasedOnList(Set<E> set, List<E> list) {\n+    protected Set<E> createSetBasedOnList(final Set<E> set, final List<E> list) {\n         Set<E> subSet;\n         if (set.getClass().equals(HashSet.class)) {\n             subSet = new HashSet<E>(list.size());\n         } else {\n             try {\n                 subSet = set.getClass().newInstance();\n-            } catch (InstantiationException ie) {\n+            } catch (final InstantiationException ie) {\n                 subSet = new HashSet<E>();\n-            } catch (IllegalAccessException iae) {\n+            } catch (final IllegalAccessException iae) {\n                 subSet = new HashSet<E>();\n             }\n         }\n         protected final Set<E> set;\n         protected E last = null;\n \n-        protected SetListIterator(Iterator<E> it, Set<E> set) {\n+        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n             super(it);\n             this.set = set;\n         }\n         protected final Set<E> set;\n         protected E last = null;\n \n-        protected SetListListIterator(ListIterator<E> it, Set<E> set) {\n+        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n             super(it);\n             this.set = set;\n         }\n         }\n \n         @Override\n-        public void add(E object) {\n+        public void add(final E object) {\n             if (set.contains(object) == false) {\n                 super.add(object);\n                 set.add(object);\n         }\n \n         @Override\n-        public void set(E object) {\n+        public void set(final E object) {\n             throw new UnsupportedOperationException(\"ListIterator does not support set\");\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/list/SynchronizedList.java\n+++ b/src/main/java/org/apache/commons/collections/list/SynchronizedList.java\n      * @return a new synchronized list\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <T> SynchronizedList<T> synchronizedList(List<T> list) {\n+    public static <T> SynchronizedList<T> synchronizedList(final List<T> list) {\n         return new SynchronizedList<T>(list);\n     }\n     \n      * @param list  the list to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected SynchronizedList(List<E> list) {\n+    protected SynchronizedList(final List<E> list) {\n         super(list);\n     }\n \n      * @param lock  the lock to use, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n-    protected SynchronizedList(List<E> list, Object lock) {\n+    protected SynchronizedList(final List<E> list, final Object lock) {\n         super(list, lock);\n     }\n \n \n     //-----------------------------------------------------------------------\n     \n-    public void add(int index, E object) {\n+    public void add(final int index, final E object) {\n         synchronized (lock) {\n             getList().add(index, object);\n         }\n     }\n \n-    public boolean addAll(int index, Collection<? extends E> coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n         synchronized (lock) {\n             return getList().addAll(index, coll);\n         }\n     }\n \n-    public E get(int index) {\n+    public E get(final int index) {\n         synchronized (lock) {\n             return getList().get(index);\n         }\n     }\n \n-    public int indexOf(Object object) {\n+    public int indexOf(final Object object) {\n         synchronized (lock) {\n             return getList().indexOf(object);\n         }\n     }\n \n-    public int lastIndexOf(Object object) {\n+    public int lastIndexOf(final Object object) {\n         synchronized (lock) {\n             return getList().lastIndexOf(object);\n         }\n      * @param index  index of first element to be returned by this list iterator\n      * @return an iterator that must be manually synchronized on the collection\n      */\n-    public ListIterator<E> listIterator(int index) {\n+    public ListIterator<E> listIterator(final int index) {\n         return getList().listIterator(index);\n     }\n \n-    public E remove(int index) {\n+    public E remove(final int index) {\n         synchronized (lock) {\n             return getList().remove(index);\n         }\n     }\n \n-    public E set(int index, E object) {\n+    public E set(final int index, final E object) {\n         synchronized (lock) {\n             return getList().set(index, object);\n         }\n     }\n \n-    public List<E> subList(int fromIndex, int toIndex) {\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n         synchronized (lock) {\n-            List<E> list = getList().subList(fromIndex, toIndex);\n+            final List<E> list = getList().subList(fromIndex, toIndex);\n             // the lock is passed into the constructor here to ensure that the sublist is\n             // synchronized on the same lock as the parent list\n             return new SynchronizedList<E>(list, lock);\n--- a/src/main/java/org/apache/commons/collections/list/TransformedList.java\n+++ b/src/main/java/org/apache/commons/collections/list/TransformedList.java\n      * @return a new transformed list\n      * @throws IllegalArgumentException if list or transformer is null\n      */\n-    public static <E> TransformedList<E> transformingList(List<E> list,\n-                                                          Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedList<E> transformingList(final List<E> list,\n+                                                          final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedList<E>(list, transformer);\n     }\n     \n      * @throws IllegalArgumentException if list or transformer is null\n      * @since 3.3\n      */\n-    public static <E> TransformedList<E> transformedList(List<E> list,\n-                                                         Transformer<? super E, ? extends E> transformer) {\n-        TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n+    public static <E> TransformedList<E> transformedList(final List<E> list,\n+                                                         final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n         if (transformer != null && list != null && list.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // list is of type E\n+            final\n             E[] values = (E[]) list.toArray();\n             list.clear();\n-            for (E value : values) {\n+            for (final E value : values) {\n                 decorated.decorated().add(transformer.transform(value));\n             }\n         }\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if list or transformer is null\n      */\n-    protected TransformedList(List<E> list, Transformer<? super E, ? extends E> transformer) {\n+    protected TransformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n         super(list, transformer);\n     }\n \n \n     //-----------------------------------------------------------------------\n     \n-    public E get(int index) {\n+    public E get(final int index) {\n         return getList().get(index);\n     }\n \n-    public int indexOf(Object object) {\n+    public int indexOf(final Object object) {\n         return getList().indexOf(object);\n     }\n \n-    public int lastIndexOf(Object object) {\n+    public int lastIndexOf(final Object object) {\n         return getList().lastIndexOf(object);\n     }\n \n-    public E remove(int index) {\n+    public E remove(final int index) {\n         return getList().remove(index);\n     }\n \n     //-----------------------------------------------------------------------\n     \n-    public void add(int index, E object) {\n+    public void add(final int index, E object) {\n         object = transform(object);\n         getList().add(index, object);\n     }\n \n-    public boolean addAll(int index, Collection<? extends E> coll) {\n+    public boolean addAll(final int index, Collection<? extends E> coll) {\n         coll = transform(coll);\n         return getList().addAll(index, coll);\n     }\n         return listIterator(0);\n     }\n \n-    public ListIterator<E> listIterator(int i) {\n+    public ListIterator<E> listIterator(final int i) {\n         return new TransformedListIterator(getList().listIterator(i));\n     }\n \n-    public E set(int index, E object) {\n+    public E set(final int index, E object) {\n         object = transform(object);\n         return getList().set(index, object);\n     }\n \n-    public List<E> subList(int fromIndex, int toIndex) {\n-        List<E> sub = getList().subList(fromIndex, toIndex);\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = getList().subList(fromIndex, toIndex);\n         return new TransformedList<E>(sub, transformer);\n     }\n \n          * \n          * @param iterator  the list iterator to decorate\n          */\n-        protected TransformedListIterator(ListIterator<E> iterator) {\n+        protected TransformedListIterator(final ListIterator<E> iterator) {\n             super(iterator);\n         }\n \n--- a/src/main/java/org/apache/commons/collections/list/TreeList.java\n+++ b/src/main/java/org/apache/commons/collections/list/TreeList.java\n      * @param coll  the collection to copy\n      * @throws NullPointerException if the collection is null\n      */\n-    public TreeList(Collection<E> coll) {\n+    public TreeList(final Collection<E> coll) {\n         super();\n         addAll(coll);\n     }\n      * @return the element at the specified index\n      */\n     @Override\n-    public E get(int index) {\n+    public E get(final int index) {\n         checkInterval(index, 0, size() - 1);\n         return root.get(index).getValue();\n     }\n      * @return the new iterator\n      */\n     @Override\n-    public ListIterator<E> listIterator(int fromIndex) {\n+    public ListIterator<E> listIterator(final int fromIndex) {\n         // override to go 75% faster\n         // cannot use EmptyIterator as iterator.add() must work\n         checkInterval(fromIndex, 0, size());\n      * @return the index of the object, -1 if not found\n      */\n     @Override\n-    public int indexOf(Object object) {\n+    public int indexOf(final Object object) {\n         // override to go 75% faster\n         if (root == null) {\n             return -1;\n      * @return true if the object is found\n      */\n     @Override\n-    public boolean contains(Object object) {\n+    public boolean contains(final Object object) {\n         return indexOf(object) >= 0;\n     }\n \n     @Override\n     public Object[] toArray() {\n         // override to go 20% faster\n-        Object[] array = new Object[size()];\n+        final Object[] array = new Object[size()];\n         if (root != null) {\n             root.toArray(array, root.relativePosition);\n         }\n      * @param obj  the element to add\n      */\n     @Override\n-    public void add(int index, E obj) {\n+    public void add(final int index, final E obj) {\n         modCount++;\n         checkInterval(index, 0, size());\n         if (root == null) {\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n     @Override\n-    public E set(int index, E obj) {\n+    public E set(final int index, final E obj) {\n         checkInterval(index, 0, size() - 1);\n-        AVLNode<E> node = root.get(index);\n-        E result = node.value;\n+        final AVLNode<E> node = root.get(index);\n+        final E result = node.value;\n         node.setValue(obj);\n         return result;\n     }\n      * @return the previous object at that index\n      */\n     @Override\n-    public E remove(int index) {\n+    public E remove(final int index) {\n         modCount++;\n         checkInterval(index, 0, size() - 1);\n-        E result = get(index);\n+        final E result = get(index);\n         root = root.remove(index);\n         size--;\n         return result;\n      * @param endIndex  the last allowed index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    private void checkInterval(int index, int startIndex, int endIndex) {\n+    private void checkInterval(final int index, final int startIndex, final int endIndex) {\n         if (index < startIndex || index > endIndex) {\n             throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n         }\n          * @param rightFollower the node with the value following this one\n          * @param leftFollower the node with the value leading this one\n          */\n-        private AVLNode(int relativePosition, E obj, AVLNode<E> rightFollower, AVLNode<E> leftFollower) {\n+        private AVLNode(final int relativePosition, final E obj, final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n             this.relativePosition = relativePosition;\n             value = obj;\n             rightIsNext = true;\n          *\n          * @param obj  the value to store\n          */\n-        void setValue(E obj) {\n+        void setValue(final E obj) {\n             this.value = obj;\n         }\n \n          * Locate the element with the given index relative to the\n          * offset of the parent of this node.\n          */\n-        AVLNode<E> get(int index) {\n-            int indexRelativeToMe = index - relativePosition;\n+        AVLNode<E> get(final int index) {\n+            final int indexRelativeToMe = index - relativePosition;\n \n             if (indexRelativeToMe == 0) {\n                 return this;\n             }\n \n-            AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n+            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n             if (nextNode == null) {\n                 return null;\n             }\n         /**\n          * Locate the index that contains the specified object.\n          */\n-        int indexOf(Object object, int index) {\n+        int indexOf(final Object object, final int index) {\n             if (getLeftSubTree() != null) {\n-                int result = left.indexOf(object, index + left.relativePosition);\n+                final int result = left.indexOf(object, index + left.relativePosition);\n                 if (result != -1) {\n                     return result;\n                 }\n          * @param array the array to be filled\n          * @param index the index of this node\n          */\n-        void toArray(Object[] array, int index) {\n+        void toArray(final Object[] array, final int index) {\n             array[index] = value;\n             if (getLeftSubTree() != null) {\n                 left.toArray(array, index + left.relativePosition);\n          * the parent node.\n          * @param obj is the object to be stored in the position.\n          */\n-        AVLNode<E> insert(int index, E obj) {\n-            int indexRelativeToMe = index - relativePosition;\n+        AVLNode<E> insert(final int index, final E obj) {\n+            final int indexRelativeToMe = index - relativePosition;\n \n             if (indexRelativeToMe <= 0) {\n                 return insertOnLeft(indexRelativeToMe, obj);\n             return insertOnRight(indexRelativeToMe, obj);\n         }\n \n-        private AVLNode<E> insertOnLeft(int indexRelativeToMe, E obj) {\n+        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n             AVLNode<E> ret = this;\n \n             if (getLeftSubTree() == null) {\n             return ret;\n         }\n \n-        private AVLNode<E> insertOnRight(int indexRelativeToMe, E obj) {\n+        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n             AVLNode<E> ret = this;\n \n             if (getRightSubTree() == null) {\n          * @param index is the index of the element to be removed relative to the position of\n          * the parent node of the current node.\n          */\n-        AVLNode<E> remove(int index) {\n-            int indexRelativeToMe = index - relativePosition;\n+        AVLNode<E> remove(final int index) {\n+            final int indexRelativeToMe = index - relativePosition;\n \n             if (indexRelativeToMe == 0) {\n                 return removeSelf();\n \n             if (heightRightMinusLeft() > 0) {\n                 // more on the right, so delete from the right\n-                AVLNode<E> rightMin = right.min();\n+                final AVLNode<E> rightMin = right.min();\n                 value = rightMin.value;\n                 if (leftIsPrevious) {\n                     left = rightMin.left;\n                 }\n             } else {\n                 // more on the left or equal, so delete from the left\n-                AVLNode<E> leftMax = left.max();\n+                final AVLNode<E> leftMax = left.max();\n                 value = leftMax.value;\n                 if (rightIsNext) {\n                     right = leftMax.right;\n                 }\n-                AVLNode<E> leftPrevious = left.left;\n+                final AVLNode<E> leftPrevious = left.left;\n                 left = left.removeMax();\n                 if (left == null) {\n                     // special case where left that was deleted was a double link\n         /**\n          * Gets the relative position.\n          */\n-        private int getOffset(AVLNode<E> node) {\n+        private int getOffset(final AVLNode<E> node) {\n             if (node == null) {\n                 return 0;\n             }\n         /**\n          * Sets the relative position.\n          */\n-        private int setOffset(AVLNode<E> node, int newOffest) {\n+        private int setOffset(final AVLNode<E> node, final int newOffest) {\n             if (node == null) {\n                 return 0;\n             }\n-            int oldOffset = getOffset(node);\n+            final int oldOffset = getOffset(node);\n             node.relativePosition = newOffest;\n             return oldOffset;\n         }\n         /**\n          * Returns the height of the node or -1 if the node is null.\n          */\n-        private int getHeight(AVLNode<E> node) {\n+        private int getHeight(final AVLNode<E> node) {\n             return node == null ? -1 : node.height;\n         }\n \n         }\n \n         private AVLNode<E> rotateLeft() {\n-            AVLNode<E> newTop = right; // can't be faedelung!\n-            AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n-\n-            int newTopPosition = relativePosition + getOffset(newTop);\n-            int myNewPosition = -newTop.relativePosition;\n-            int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+            final AVLNode<E> newTop = right; // can't be faedelung!\n+            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n+\n+            final int newTopPosition = relativePosition + getOffset(newTop);\n+            final int myNewPosition = -newTop.relativePosition;\n+            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n \n             setRight(movedNode, newTop);\n             newTop.setLeft(this, null);\n         }\n \n         private AVLNode<E> rotateRight() {\n-            AVLNode<E> newTop = left; // can't be faedelung\n-            AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n-\n-            int newTopPosition = relativePosition + getOffset(newTop);\n-            int myNewPosition = -newTop.relativePosition;\n-            int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+            final AVLNode<E> newTop = left; // can't be faedelung\n+            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n+\n+            final int newTopPosition = relativePosition + getOffset(newTop);\n+            final int myNewPosition = -newTop.relativePosition;\n+            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n \n             setLeft(movedNode, newTop);\n             newTop.setRight(this, null);\n          * @param node  the new left subtree node\n          * @param previous  the previous node in the linked list\n          */\n-        private void setLeft(AVLNode<E> node, AVLNode<E> previous) {\n+        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n             leftIsPrevious = node == null;\n             left = leftIsPrevious ? previous : node;\n             recalcHeight();\n          * @param node  the new left subtree node\n          * @param next  the next node in the linked list\n          */\n-        private void setRight(AVLNode<E> node, AVLNode<E> next) {\n+        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n             rightIsNext = node == null;\n             right = rightIsNext ? next : node;\n             recalcHeight();\n          * @param parent  the parent list\n          * @param fromIndex  the index to start at\n          */\n-        protected TreeListIterator(TreeList<E> parent, int fromIndex) throws IndexOutOfBoundsException {\n+        protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n             super();\n             this.parent = parent;\n             this.expectedModCount = parent.modCount;\n             if (next == null) {\n                 next = parent.root.get(nextIndex);\n             }\n-            E value = next.getValue();\n+            final E value = next.getValue();\n             current = next;\n             currentIndex = nextIndex++;\n             next = next.next();\n             } else {\n                 next = next.previous();\n             }\n-            E value = next.getValue();\n+            final E value = next.getValue();\n             current = next;\n             currentIndex = --nextIndex;\n             return value;\n             expectedModCount++;\n         }\n \n-        public void set(E obj) {\n+        public void set(final E obj) {\n             checkModCount();\n             if (current == null) {\n                 throw new IllegalStateException();\n             current.setValue(obj);\n         }\n \n-        public void add(E obj) {\n+        public void add(final E obj) {\n             checkModCount();\n             parent.add(nextIndex, obj);\n             current = null;\n--- a/src/main/java/org/apache/commons/collections/list/UnmodifiableList.java\n+++ b/src/main/java/org/apache/commons/collections/list/UnmodifiableList.java\n      * @return a new unmodifiable list\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> List<E> unmodifiableList(List<E> list) {\n+    public static <E> List<E> unmodifiableList(final List<E> list) {\n         if (list instanceof Unmodifiable) {\n             return list;\n         }\n      * @throws IllegalArgumentException if list is null\n      * @since Commons Collection 5\n      */\n-    public UnmodifiableList(List<E> list) {\n+    public UnmodifiableList(final List<E> list) {\n         super(list);\n     }\n \n     }\n \n     @Override\n-    public boolean add(Object object) {\n+    public boolean add(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public ListIterator<E> listIterator(int index) {\n+    public ListIterator<E> listIterator(final int index) {\n         return UnmodifiableListIterator.umodifiableListIterator(decorated().listIterator(index));\n     }\n \n     @Override\n-    public void add(int index, E object) {\n+    public void add(final int index, final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(int index, Collection<? extends E> coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public E remove(int index) {\n+    public E remove(final int index) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public E set(int index, E object) {\n+    public E set(final int index, final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public List<E> subList(int fromIndex, int toIndex) {\n-        List<E> sub = decorated().subList(fromIndex, toIndex);\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n         return new UnmodifiableList<E>(sub);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractHashedMap.java\n      * @param threshold  the threshold, must be sensible\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected AbstractHashedMap(int initialCapacity, float loadFactor, int threshold) {\n+    protected AbstractHashedMap(final int initialCapacity, final float loadFactor, final int threshold) {\n         super();\n         this.loadFactor = loadFactor;\n         this.data = new HashEntry[initialCapacity];\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n      */\n-    protected AbstractHashedMap(int initialCapacity) {\n+    protected AbstractHashedMap(final int initialCapacity) {\n         this(initialCapacity, DEFAULT_LOAD_FACTOR);\n     }\n \n      * @throws IllegalArgumentException if the load factor is less than or equal to zero \n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected AbstractHashedMap(int initialCapacity, float loadFactor) {\n+    protected AbstractHashedMap(int initialCapacity, final float loadFactor) {\n         super();\n         if (initialCapacity < 0) {\n             throw new IllegalArgumentException(\"Initial capacity must be a non negative number\");  \n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    protected AbstractHashedMap(Map<K, V> map) {\n+    protected AbstractHashedMap(final Map<K, V> map) {\n         this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n         _putAll(map);\n     }\n     @Override\n     public V get(Object key) {\n         key = convertKey(key);\n-        int hashCode = hash(key);\n+        final int hashCode = hash(key);\n         HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n     @Override\n     public boolean containsKey(Object key) {\n         key = convertKey(key);\n-        int hashCode = hash(key);\n+        final int hashCode = hash(key);\n         HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n      * @return true if the map contains the value\n      */\n     @Override\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         if (value == null) {\n-            for (HashEntry<K, V> element : data) {\n+            for (final HashEntry<K, V> element : data) {\n                 HashEntry<K, V> entry = element;\n                 while (entry != null) {\n                     if (entry.getValue() == null) {\n                 }\n             }\n         } else {\n-            for (HashEntry<K, V> element : data) {\n+            for (final HashEntry<K, V> element : data) {\n                 HashEntry<K, V> entry = element;\n                 while (entry != null) {\n                     if (isEqualValue(value, entry.getValue())) {\n      * @return the value previously mapped to this key, null if none\n      */\n     @Override\n-    public V put(K key, V value) {\n-        Object convertedKey = convertKey(key);\n-        int hashCode = hash(convertedKey);\n-        int index = hashIndex(hashCode, data.length);\n+    public V put(final K key, final V value) {\n+        final Object convertedKey = convertKey(key);\n+        final int hashCode = hash(convertedKey);\n+        final int index = hashIndex(hashCode, data.length);\n         HashEntry<K, V> entry = data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(convertedKey, entry.key)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 updateEntry(entry, value);\n                 return oldValue;\n             }\n      * @throws NullPointerException if the map is null\n      */\n     @Override\n-    public void putAll(Map<? extends K, ? extends V> map) {\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n         _putAll(map);\n     }\n \n      * @param map  the map to add\n      * @throws NullPointerException if the map is null\n      */\n-    private void _putAll(Map<? extends K, ? extends V> map) {\n-        int mapSize = map.size();\n+    private void _putAll(final Map<? extends K, ? extends V> map) {\n+        final int mapSize = map.size();\n         if (mapSize == 0) {\n             return;\n         }\n-        int newSize = (int) ((size + mapSize) / loadFactor + 1);\n+        final int newSize = (int) ((size + mapSize) / loadFactor + 1);\n         ensureCapacity(calculateNewCapacity(newSize));\n-        for (Map.Entry<? extends K, ? extends V> entry: map.entrySet()) {\n+        for (final Map.Entry<? extends K, ? extends V> entry: map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n     @Override\n     public V remove(Object key) {\n         key = convertKey(key);\n-        int hashCode = hash(key);\n-        int index = hashIndex(hashCode, data.length);\n+        final int hashCode = hash(key);\n+        final int index = hashIndex(hashCode, data.length);\n         HashEntry<K, V> entry = data[index];\n         HashEntry<K, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n     @Override\n     public void clear() {\n         modCount++;\n-        HashEntry<K, V>[] data = this.data;\n+        final HashEntry<K, V>[] data = this.data;\n         for (int i = data.length - 1; i >= 0; i--) {\n             data[i] = null;\n         }\n      * @param key  the key convert\n      * @return the converted key\n      */\n-    protected Object convertKey(Object key) {\n+    protected Object convertKey(final Object key) {\n         return key == null ? NULL : key;\n     }\n \n      * @param key  the key to get a hash code for\n      * @return the hash code\n      */\n-    protected int hash(Object key) {\n+    protected int hash(final Object key) {\n         // same as JDK 1.4\n         int h = key.hashCode();\n         h += ~(h << 9);\n      * @param key2  the second key extracted from the entry via <code>entry.key</code>\n      * @return true if equal\n      */\n-    protected boolean isEqualKey(Object key1, Object key2) {\n+    protected boolean isEqualKey(final Object key1, final Object key2) {\n         return key1 == key2 || key1.equals(key2);\n     }\n \n      * @param value2  the second value extracted from the entry via <code>getValue()</code>\n      * @return true if equal\n      */\n-    protected boolean isEqualValue(Object value1, Object value2) {\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n         return value1 == value2 || value1.equals(value2);\n     }\n \n      * @param dataSize  the size of the data to pick a bucket from\n      * @return the bucket index\n      */\n-    protected int hashIndex(int hashCode, int dataSize) {\n+    protected int hashIndex(final int hashCode, final int dataSize) {\n         return hashCode & dataSize - 1;\n     }\n \n      */\n     protected HashEntry<K, V> getEntry(Object key) {\n         key = convertKey(key);\n-        int hashCode = hash(key);\n+        final int hashCode = hash(key);\n         HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n      * @param entry  the entry to update\n      * @param newValue  the new value to store\n      */\n-    protected void updateEntry(HashEntry<K, V> entry, V newValue) {\n+    protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {\n         entry.setValue(newValue);\n     }\n \n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void reuseEntry(HashEntry<K, V> entry, int hashIndex, int hashCode, K key, V value) {\n+    protected void reuseEntry(final HashEntry<K, V> entry, final int hashIndex, final int hashCode, final K key, final V value) {\n         entry.next = data[hashIndex];\n         entry.hashCode = hashCode;\n         entry.key = key;\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void addMapping(int hashIndex, int hashCode, K key, V value) {\n+    protected void addMapping(final int hashIndex, final int hashCode, final K key, final V value) {\n         modCount++;\n-        HashEntry<K, V> entry = createEntry(data[hashIndex], hashCode, key, value);\n+        final HashEntry<K, V> entry = createEntry(data[hashIndex], hashCode, key, value);\n         addEntry(entry, hashIndex);\n         size++;\n         checkCapacity();\n      * @param value  the value to store\n      * @return the newly created entry\n      */\n-    protected HashEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+    protected HashEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n         return new HashEntry<K, V>(next, hashCode, convertKey(key), value);\n     }\n \n      * @param entry  the entry to add\n      * @param hashIndex  the index into the data array to store at\n      */\n-    protected void addEntry(HashEntry<K, V> entry, int hashIndex) {\n+    protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {\n         data[hashIndex] = entry;\n     }\n \n      * @param hashIndex  the index into the data structure\n      * @param previous  the previous entry in the chain\n      */\n-    protected void removeMapping(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n+    protected void removeMapping(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n         modCount++;\n         removeEntry(entry, hashIndex, previous);\n         size--;\n      * @param hashIndex  the index into the data structure\n      * @param previous  the previous entry in the chain\n      */\n-    protected void removeEntry(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n+    protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n         if (previous == null) {\n             data[hashIndex] = entry.next;\n         } else {\n      *\n      * @param entry  the entry to destroy\n      */\n-    protected void destroyEntry(HashEntry<K, V> entry) {\n+    protected void destroyEntry(final HashEntry<K, V> entry) {\n         entry.next = null;\n         entry.key = null;\n         entry.value = null;\n      */\n     protected void checkCapacity() {\n         if (size >= threshold) {\n-            int newCapacity = data.length * 2;\n+            final int newCapacity = data.length * 2;\n             if (newCapacity <= MAXIMUM_CAPACITY) {\n                 ensureCapacity(newCapacity);\n             }\n      * @param newCapacity  the new capacity of the array (a power of two, less or equal to max)\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected void ensureCapacity(int newCapacity) {\n-        int oldCapacity = data.length;\n+    protected void ensureCapacity(final int newCapacity) {\n+        final int oldCapacity = data.length;\n         if (newCapacity <= oldCapacity) {\n             return;\n         }\n             threshold = calculateThreshold(newCapacity, loadFactor);\n             data = new HashEntry[newCapacity];\n         } else {\n-            HashEntry<K, V> oldEntries[] = data;\n-            HashEntry<K, V> newEntries[] = new HashEntry[newCapacity];\n+            final HashEntry<K, V> oldEntries[] = data;\n+            final HashEntry<K, V> newEntries[] = new HashEntry[newCapacity];\n \n             modCount++;\n             for (int i = oldCapacity - 1; i >= 0; i--) {\n                 if (entry != null) {\n                     oldEntries[i] = null;  // gc\n                     do {\n-                        HashEntry<K, V> next = entry.next;\n-                        int index = hashIndex(entry.hashCode, newCapacity);\n+                        final HashEntry<K, V> next = entry.next;\n+                        final int index = hashIndex(entry.hashCode, newCapacity);\n                         entry.next = newEntries[index];\n                         newEntries[index] = entry;\n                         entry = next;\n      * @param proposedCapacity  the proposed capacity\n      * @return the normalized new capacity\n      */\n-    protected int calculateNewCapacity(int proposedCapacity) {\n+    protected int calculateNewCapacity(final int proposedCapacity) {\n         int newCapacity = 1;\n         if (proposedCapacity > MAXIMUM_CAPACITY) {\n             newCapacity = MAXIMUM_CAPACITY;\n      * @param factor  the load factor\n      * @return the new resize threshold\n      */\n-    protected int calculateThreshold(int newCapacity, float factor) {\n+    protected int calculateThreshold(final int newCapacity, final float factor) {\n         return (int) (newCapacity * factor);\n     }\n \n      * @throws NullPointerException if the entry is null\n      * @since 3.1\n      */\n-    protected HashEntry<K, V> entryNext(HashEntry<K, V> entry) {\n+    protected HashEntry<K, V> entryNext(final HashEntry<K, V> entry) {\n         return entry.next;\n     }\n \n      * @throws NullPointerException if the entry is null\n      * @since 3.1\n      */\n-    protected int entryHashCode(HashEntry<K, V> entry) {\n+    protected int entryHashCode(final HashEntry<K, V> entry) {\n         return entry.hashCode;\n     }\n \n      * @throws NullPointerException if the entry is null\n      * @since 3.1\n      */\n-    protected K entryKey(HashEntry<K, V> entry) {\n+    protected K entryKey(final HashEntry<K, V> entry) {\n         return entry.getKey();\n     }\n \n      * @throws NullPointerException if the entry is null\n      * @since 3.1\n      */\n-    protected V entryValue(HashEntry<K, V> entry) {\n+    protected V entryValue(final HashEntry<K, V> entry) {\n         return entry.getValue();\n     }\n \n      */\n     protected static class HashMapIterator<K, V> extends HashIterator<K, V> implements MapIterator<K, V> {\n \n-        protected HashMapIterator(AbstractHashedMap<K, V> parent) {\n+        protected HashMapIterator(final AbstractHashedMap<K, V> parent) {\n             super(parent);\n         }\n \n         }\n \n         public K getKey() {\n-            HashEntry<K, V> current = currentEntry();\n+            final HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n         }\n \n         public V getValue() {\n-            HashEntry<K, V> current = currentEntry();\n+            final HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n \n-        public V setValue(V value) {\n-            HashEntry<K, V> current = currentEntry();\n+        public V setValue(final V value) {\n+            final HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n         /** The parent map */\n         protected final AbstractHashedMap<K, V> parent;\n \n-        protected EntrySet(AbstractHashedMap<K, V> parent) {\n+        protected EntrySet(final AbstractHashedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         }\n \n         @Override\n-        public boolean contains(Object entry) {\n+        public boolean contains(final Object entry) {\n             if (entry instanceof Map.Entry) {\n-                Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n-                Entry<K, V> match = parent.getEntry(e.getKey());\n+                final Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n+                final Entry<K, V> match = parent.getEntry(e.getKey());\n                 return match != null && match.equals(e);\n             }\n             return false;\n         }\n \n         @Override\n-        public boolean remove(Object obj) {\n+        public boolean remove(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n             if (contains(obj) == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n             parent.remove(entry.getKey());\n             return true;\n         }\n      */\n     protected static class EntrySetIterator<K, V> extends HashIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n \n-        protected EntrySetIterator(AbstractHashedMap<K, V> parent) {\n+        protected EntrySetIterator(final AbstractHashedMap<K, V> parent) {\n             super(parent);\n         }\n \n         /** The parent map */\n         protected final AbstractHashedMap<K, ?> parent;\n \n-        protected KeySet(AbstractHashedMap<K, ?> parent) {\n+        protected KeySet(final AbstractHashedMap<K, ?> parent) {\n             super();\n             this.parent = parent;\n         }\n         }\n \n         @Override\n-        public boolean contains(Object key) {\n+        public boolean contains(final Object key) {\n             return parent.containsKey(key);\n         }\n \n         @Override\n-        public boolean remove(Object key) {\n-            boolean result = parent.containsKey(key);\n+        public boolean remove(final Object key) {\n+            final boolean result = parent.containsKey(key);\n             parent.remove(key);\n             return result;\n         }\n     protected static class KeySetIterator<K> extends HashIterator<K, Object> implements Iterator<K> {\n \n         @SuppressWarnings(\"unchecked\")\n-        protected KeySetIterator(AbstractHashedMap<K, ?> parent) {\n+        protected KeySetIterator(final AbstractHashedMap<K, ?> parent) {\n             super((AbstractHashedMap<K, Object>) parent);\n         }\n \n         /** The parent map */\n         protected final AbstractHashedMap<?, V> parent;\n \n-        protected Values(AbstractHashedMap<?, V> parent) {\n+        protected Values(final AbstractHashedMap<?, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         }\n \n         @Override\n-        public boolean contains(Object value) {\n+        public boolean contains(final Object value) {\n             return parent.containsValue(value);\n         }\n \n     protected static class ValuesIterator<V> extends HashIterator<Object, V> implements Iterator<V> {\n \n         @SuppressWarnings(\"unchecked\")\n-        protected ValuesIterator(AbstractHashedMap<?, V> parent) {\n+        protected ValuesIterator(final AbstractHashedMap<?, V> parent) {\n             super((AbstractHashedMap<Object, V>) parent);\n         }\n \n         /** The value */\n         protected Object value;\n \n-        protected HashEntry(HashEntry<K, V> next, int hashCode, Object key, V value) {\n+        protected HashEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n             super();\n             this.next = next;\n             this.hashCode = hashCode;\n         }\n \n         @SuppressWarnings(\"unchecked\")\n-        public V setValue(V value) {\n-            Object old = this.value;\n+        public V setValue(final V value) {\n+            final Object old = this.value;\n             this.value = value;\n             return (V) old;\n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n             return\n                 (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n                 (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n         /** The modification count expected */\n         protected int expectedModCount;\n \n-        protected HashIterator(AbstractHashedMap<K, V> parent) {\n+        protected HashIterator(final AbstractHashedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n-            HashEntry<K, V>[] data = parent.data;\n+            final HashEntry<K, V>[] data = parent.data;\n             int i = data.length;\n             HashEntry<K, V> next = null;\n             while (i > 0 && next == null) {\n             if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            HashEntry<K, V> newCurrent = next;\n+            final HashEntry<K, V> newCurrent = next;\n             if (newCurrent == null)  {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n-            HashEntry<K, V>[] data = parent.data;\n+            final HashEntry<K, V>[] data = parent.data;\n             int i = hashIndex;\n             HashEntry<K, V> n = newCurrent.next;\n             while (n == null && i > 0) {\n      *\n      * @param out  the output stream\n      */\n-    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n         out.writeFloat(loadFactor);\n         out.writeInt(data.length);\n         out.writeInt(size);\n-        for (MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n+        for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n             out.writeObject(it.next());\n             out.writeObject(it.getValue());\n         }\n      * @param in  the input stream\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         loadFactor = in.readFloat();\n-        int capacity = in.readInt();\n-        int size = in.readInt();\n+        final int capacity = in.readInt();\n+        final int size = in.readInt();\n         init();\n         threshold = calculateThreshold(capacity, loadFactor);\n         data = new HashEntry[capacity];\n         for (int i = 0; i < size; i++) {\n-            K key = (K) in.readObject();\n-            V value = (V) in.readObject();\n+            final K key = (K) in.readObject();\n+            final V value = (V) in.readObject();\n             put(key, value);\n         }\n     }\n     @SuppressWarnings(\"unchecked\")\n     protected AbstractHashedMap<K, V> clone() {\n         try {\n-            AbstractHashedMap<K, V> cloned = (AbstractHashedMap<K, V>) super.clone();\n+            final AbstractHashedMap<K, V> cloned = (AbstractHashedMap<K, V>) super.clone();\n             cloned.data = new HashEntry[data.length];\n             cloned.entrySet = null;\n             cloned.keySet = null;\n             cloned.init();\n             cloned.putAll(this);\n             return cloned;\n-        } catch (CloneNotSupportedException ex) {\n+        } catch (final CloneNotSupportedException ex) {\n             return null;  // should never happen\n         }\n     }\n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map == false) {\n             return false;\n         }\n-        Map<?,?> map = (Map<?,?>) obj;\n+        final Map<?,?> map = (Map<?,?>) obj;\n         if (map.size() != size()) {\n             return false;\n         }\n-        MapIterator<?,?> it = mapIterator();\n+        final MapIterator<?,?> it = mapIterator();\n         try {\n             while (it.hasNext()) {\n-                Object key = it.next();\n-                Object value = it.getValue();\n+                final Object key = it.next();\n+                final Object value = it.getValue();\n                 if (value == null) {\n                     if (map.get(key) != null || map.containsKey(key) == false) {\n                         return false;\n                     }\n                 }\n             }\n-        } catch (ClassCastException ignored)   {\n+        } catch (final ClassCastException ignored)   {\n             return false;\n-        } catch (NullPointerException ignored) {\n+        } catch (final NullPointerException ignored) {\n             return false;\n         }\n         return true;\n     @Override\n     public int hashCode() {\n         int total = 0;\n-        Iterator<Map.Entry<K, V>> it = createEntrySetIterator();\n+        final Iterator<Map.Entry<K, V>> it = createEntrySetIterator();\n         while (it.hasNext()) {\n             total += it.next().hashCode();\n         }\n         if (size() == 0) {\n             return \"{}\";\n         }\n-        StringBuilder buf = new StringBuilder(32 * size());\n+        final StringBuilder buf = new StringBuilder(32 * size());\n         buf.append('{');\n \n-        MapIterator<K, V> it = mapIterator();\n+        final MapIterator<K, V> it = mapIterator();\n         boolean hasNext = it.hasNext();\n         while (hasNext) {\n-            K key = it.next();\n-            V value = it.getValue();\n+            final K key = it.next();\n+            final V value = it.getValue();\n             buf.append(key == this ? \"(this Map)\" : key)\n                .append('=')\n                .append(value == this ? \"(this Map)\" : value);\n--- a/src/main/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected AbstractInputCheckedMapDecorator(Map<K, V> map) {\n+    protected AbstractInputCheckedMapDecorator(final Map<K, V> map) {\n         super(map);\n     }\n \n         /** The parent map */\n         private final AbstractInputCheckedMapDecorator<K, V> parent;\n \n-        protected EntrySet(Set<Map.Entry<K, V>> set, AbstractInputCheckedMapDecorator<K, V> parent) {\n+        protected EntrySet(final Set<Map.Entry<K, V>> set, final AbstractInputCheckedMapDecorator<K, V> parent) {\n             super(set);\n             this.parent = parent;\n         }\n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public Object[] toArray() {\n-            Object[] array = collection.toArray();\n+            final Object[] array = collection.toArray();\n             for (int i = 0; i < array.length; i++) {\n                 array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n             }\n         \n         @Override\n         @SuppressWarnings(\"unchecked\")\n-        public <T> T[] toArray(T[] array) {\n+        public <T> T[] toArray(final T[] array) {\n             Object[] result = array;\n             if (array.length > 0) {\n                 // we must create a new array to handle multi-threaded situations\n         /** The parent map */\n         private final AbstractInputCheckedMapDecorator<K, V> parent;\n \n-        protected EntrySetIterator(Iterator<Map.Entry<K, V>> iterator, AbstractInputCheckedMapDecorator<K, V> parent) {\n+        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractInputCheckedMapDecorator<K, V> parent) {\n             super(iterator);\n             this.parent = parent;\n         }\n \n         @Override\n         public Map.Entry<K, V> next() {\n-            Map.Entry<K, V> entry = iterator.next();\n+            final Map.Entry<K, V> entry = iterator.next();\n             return new MapEntry(entry, parent);\n         }\n     }\n         /** The parent map */\n         private final AbstractInputCheckedMapDecorator<K, V> parent;\n \n-        protected MapEntry(Map.Entry<K, V> entry, AbstractInputCheckedMapDecorator<K, V> parent) {\n+        protected MapEntry(final Map.Entry<K, V> entry, final AbstractInputCheckedMapDecorator<K, V> parent) {\n             super(entry);\n             this.parent = parent;\n         }\n--- a/src/main/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n      * @param loadFactor  the load factor, must be > 0.0f and generally < 1.0f\n      * @param threshold  the threshold, must be sensible\n      */\n-    protected AbstractLinkedMap(int initialCapacity, float loadFactor, int threshold) {\n+    protected AbstractLinkedMap(final int initialCapacity, final float loadFactor, final int threshold) {\n         super(initialCapacity, loadFactor, threshold);\n     }\n \n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n      */\n-    protected AbstractLinkedMap(int initialCapacity) {\n+    protected AbstractLinkedMap(final int initialCapacity) {\n         super(initialCapacity);\n     }\n \n      * @throws IllegalArgumentException if the initial capacity is negative\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n-    protected AbstractLinkedMap(int initialCapacity, float loadFactor) {\n+    protected AbstractLinkedMap(final int initialCapacity, final float loadFactor) {\n         super(initialCapacity, loadFactor);\n     }\n \n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    protected AbstractLinkedMap(Map<K, V> map) {\n+    protected AbstractLinkedMap(final Map<K, V> map) {\n         super(map);\n     }\n \n      * @return true if the map contains the value\n      */\n     @Override\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         // override uses faster iterator\n         if (value == null) {\n             for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n      * @param key  the key to get after\n      * @return the next key\n      */\n-    public K nextKey(Object key) {\n-        LinkEntry<K, V> entry = getEntry(key);\n+    public K nextKey(final Object key) {\n+        final LinkEntry<K, V> entry = getEntry(key);\n         return entry == null || entry.after == header ? null : entry.after.getKey();\n     }\n \n     @Override\n-    protected LinkEntry<K, V> getEntry(Object key) {\n+    protected LinkEntry<K, V> getEntry(final Object key) {\n         return (LinkEntry<K, V>) super.getEntry(key);\n     }\n \n      * @param key  the key to get before\n      * @return the previous key\n      */\n-    public K previousKey(Object key) {\n-        LinkEntry<K, V> entry = getEntry(key);\n+    public K previousKey(final Object key) {\n+        final LinkEntry<K, V> entry = getEntry(key);\n         return entry == null || entry.before == header ? null : entry.before.getKey();\n     }\n \n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    protected LinkEntry<K, V> getEntry(int index) {\n+    protected LinkEntry<K, V> getEntry(final int index) {\n         if (index < 0) {\n             throw new IndexOutOfBoundsException(\"Index \" + index + \" is less than zero\");\n         }\n      * @param hashIndex  the index into the data array to store at\n      */\n     @Override\n-    protected void addEntry(HashEntry<K, V> entry, int hashIndex) {\n-        LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n+    protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {\n+        final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n         link.after  = header;\n         link.before = header.before;\n         header.before.after = link;\n      * @return the newly created entry\n      */\n     @Override\n-    protected LinkEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+    protected LinkEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n         return new LinkEntry<K, V>(next, hashCode, convertKey(key), value);\n     }\n \n      * @param previous  the previous entry in the chain\n      */\n     @Override\n-    protected void removeEntry(HashEntry<K, V> entry, int hashIndex, HashEntry<K, V> previous) {\n-        LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n+    protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n+        final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n         link.before.after = link.after;\n         link.after.before = link.before;\n         link.after = null;\n      * @throws NullPointerException if the entry is null\n      * @since 3.1\n      */\n-    protected LinkEntry<K, V> entryBefore(LinkEntry<K, V> entry) {\n+    protected LinkEntry<K, V> entryBefore(final LinkEntry<K, V> entry) {\n         return entry.before;\n     }\n \n      * @throws NullPointerException if the entry is null\n      * @since 3.1\n      */\n-    protected LinkEntry<K, V> entryAfter(LinkEntry<K, V> entry) {\n+    protected LinkEntry<K, V> entryAfter(final LinkEntry<K, V> entry) {\n         return entry.after;\n     }\n \n     protected static class LinkMapIterator<K, V> extends LinkIterator<K, V> implements\n             OrderedMapIterator<K, V>, ResettableIterator<K> {\n \n-        protected LinkMapIterator(AbstractLinkedMap<K, V> parent) {\n+        protected LinkMapIterator(final AbstractLinkedMap<K, V> parent) {\n             super(parent);\n         }\n \n         }\n \n         public K getKey() {\n-            LinkEntry<K, V> current = currentEntry();\n+            final LinkEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n         }\n \n         public V getValue() {\n-            LinkEntry<K, V> current = currentEntry();\n+            final LinkEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n \n-        public V setValue(V value) {\n-            LinkEntry<K, V> current = currentEntry();\n+        public V setValue(final V value) {\n+            final LinkEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n     protected static class EntrySetIterator<K, V> extends LinkIterator<K, V> implements\n             OrderedIterator<Map.Entry<K, V>>, ResettableIterator<Map.Entry<K, V>> {\n \n-        protected EntrySetIterator(AbstractLinkedMap<K, V> parent) {\n+        protected EntrySetIterator(final AbstractLinkedMap<K, V> parent) {\n             super(parent);\n         }\n \n             OrderedIterator<K>, ResettableIterator<K> {\n         \n         @SuppressWarnings(\"unchecked\")\n-        protected KeySetIterator(AbstractLinkedMap<K, ?> parent) {\n+        protected KeySetIterator(final AbstractLinkedMap<K, ?> parent) {\n             super((AbstractLinkedMap<K, Object>) parent);\n         }\n \n             OrderedIterator<V>, ResettableIterator<V> {\n \n         @SuppressWarnings(\"unchecked\")\n-        protected ValuesIterator(AbstractLinkedMap<?, V> parent) {\n+        protected ValuesIterator(final AbstractLinkedMap<?, V> parent) {\n             super((AbstractLinkedMap<Object, V>) parent);\n         }\n \n          * @param key  the key\n          * @param value  the value\n          */\n-        protected LinkEntry(HashEntry<K, V> next, int hashCode, Object key, V value) {\n+        protected LinkEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n             super(next, hashCode, key, value);\n         }\n     }\n         /** The modification count expected */\n         protected int expectedModCount;\n \n-        protected LinkIterator(AbstractLinkedMap<K, V> parent) {\n+        protected LinkIterator(final AbstractLinkedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             this.next = parent.header.after;\n             if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            LinkEntry<K, V> previous = next.before;\n+            final LinkEntry<K, V> previous = next.before;\n             if (previous == parent.header)  {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n             }\n--- a/src/main/java/org/apache/commons/collections/map/AbstractMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractMapDecorator.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected AbstractMapDecorator(Map<K, V> map) {\n+    protected AbstractMapDecorator(final Map<K, V> map) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n         decorated().clear();\n     }\n \n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         return decorated().containsKey(key);\n     }\n \n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         return decorated().containsValue(value);\n     }\n \n         return decorated().entrySet();\n     }\n \n-    public V get(Object key) {\n+    public V get(final Object key) {\n         return decorated().get(key);\n     }\n \n         return decorated().keySet();\n     }\n \n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         return decorated().put(key, value);\n     }\n \n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         decorated().putAll(mapToCopy);\n     }\n \n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         return decorated().remove(key);\n     }\n \n     }\n    \n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (object == this) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/collections/map/AbstractOrderedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractOrderedMapDecorator.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractOrderedMapDecorator(OrderedMap<K, V> map) {\n+    public AbstractOrderedMapDecorator(final OrderedMap<K, V> map) {\n         super(map);\n     }\n \n         return decorated().lastKey();\n     }\n \n-    public K nextKey(K key) {\n+    public K nextKey(final K key) {\n         return decorated().nextKey(key);\n     }\n \n-    public K previousKey(K key) {\n+    public K previousKey(final K key) {\n         return decorated().previousKey(key);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n          * @return ReferenceType\n          * @throws IllegalArgumentException if the specified value is invalid.\n          */\n-        public static ReferenceStrength resolve(int value) {\n+        public static ReferenceStrength resolve(final int value) {\n             switch (value) {\n             case 0:\n                 return HARD;\n             }\n         }\n \n-        private ReferenceStrength(int value) {\n+        private ReferenceStrength(final int value) {\n             this.value = value;\n         }\n \n      *   key is garbage collected\n      */\n     protected AbstractReferenceMap(\n-            ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n-            float loadFactor, boolean purgeValues) {\n+            final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n+            final float loadFactor, final boolean purgeValues) {\n         super(capacity, loadFactor);\n         this.keyType = keyType;\n         this.valueType = valueType;\n      * @return true if the map contains the key\n      */\n     @Override\n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         purgeBeforeRead();\n-        Entry<K, V> entry = getEntry(key);\n+        final Entry<K, V> entry = getEntry(key);\n         if (entry == null) {\n             return false;\n         }\n      * @return true if the map contains the value\n      */\n     @Override\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         purgeBeforeRead();\n         if (value == null) {\n             return false;\n      * @return the mapped value, null if no match\n      */\n     @Override\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         purgeBeforeRead();\n-        Entry<K, V> entry = getEntry(key);\n+        final Entry<K, V> entry = getEntry(key);\n         if (entry == null) {\n             return null;\n         }\n      * @throws NullPointerException if either the key or value is null\n      */\n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (key == null) {\n             throw new NullPointerException(\"null keys not allowed\");\n         }\n      * @return the value mapped to the removed key, null if key not in map\n      */\n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         if (key == null) {\n             return null;\n         }\n      *\n      * @param ref  the reference to purge\n      */\n-    protected void purge(Reference<?> ref) {\n+    protected void purge(final Reference<?> ref) {\n         // The hashCode of the reference is the hashCode of the\n         // mapping key, even if the reference refers to the\n         // mapping value...\n-        int hash = ref.hashCode();\n-        int index = hashIndex(hash, data.length);\n+        final int hash = ref.hashCode();\n+        final int index = hashIndex(hash, data.length);\n         HashEntry<K, V> previous = null;\n         HashEntry<K, V> entry = data[index];\n         while (entry != null) {\n      * @return the entry, null if no match\n      */\n     @Override\n-    protected HashEntry<K, V> getEntry(Object key) {\n+    protected HashEntry<K, V> getEntry(final Object key) {\n         if (key == null) {\n             return null;\n         }\n      * @param value  the value to get a hash code for, may be null\n      * @return the hash code, as per the MapEntry specification\n      */\n-    protected int hashEntry(Object key, Object value) {\n+    protected int hashEntry(final Object key, final Object value) {\n         return (key == null ? 0 : key.hashCode()) ^\n                (value == null ? 0 : value.hashCode());\n     }\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    protected boolean isEqualKey(Object key1, Object key2) {\n+    protected boolean isEqualKey(final Object key1, Object key2) {\n         key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<K>) key2).get();\n         return key1 == key2 || key1.equals(key2);\n     }\n      * @return the newly created entry\n      */\n     @Override\n-    protected ReferenceEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+    protected ReferenceEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n         return new ReferenceEntry<K, V>(this, next, hashCode, key, value);\n     }\n \n      */\n     static class ReferenceEntrySet<K, V> extends EntrySet<K, V> {\n \n-        protected ReferenceEntrySet(AbstractHashedMap<K, V> parent) {\n+        protected ReferenceEntrySet(final AbstractHashedMap<K, V> parent) {\n             super(parent);\n         }\n \n         }\n \n         @Override\n-        public <T> T[] toArray(T[] arr) {\n+        public <T> T[] toArray(final T[] arr) {\n             // special implementation to handle disappearing entries\n-            ArrayList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>();\n-            for (Map.Entry<K, V> entry : this) {\n+            final ArrayList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>();\n+            for (final Map.Entry<K, V> entry : this) {\n                 list.add(new DefaultMapEntry<K, V>(entry));\n             }\n             return list.toArray(arr);\n      */\n     static class ReferenceKeySet<K> extends KeySet<K> {\n \n-        protected ReferenceKeySet(AbstractHashedMap<K, ?> parent) {\n+        protected ReferenceKeySet(final AbstractHashedMap<K, ?> parent) {\n             super(parent);\n         }\n \n         }\n \n         @Override\n-        public <T> T[] toArray(T[] arr) {\n+        public <T> T[] toArray(final T[] arr) {\n             // special implementation to handle disappearing keys\n-            List<K> list = new ArrayList<K>(parent.size());\n-            for (K key : this) {\n+            final List<K> list = new ArrayList<K>(parent.size());\n+            for (final K key : this) {\n                 list.add(key);\n             }\n             return list.toArray(arr);\n      */\n     static class ReferenceValues<V> extends Values<V> {\n \n-        protected ReferenceValues(AbstractHashedMap<?, V> parent) {\n+        protected ReferenceValues(final AbstractHashedMap<?, V> parent) {\n             super(parent);\n         }\n \n         }\n \n         @Override\n-        public <T> T[] toArray(T[] arr) {\n+        public <T> T[] toArray(final T[] arr) {\n             // special implementation to handle disappearing values\n-            List<V> list = new ArrayList<V>(parent.size());\n-            for (V value : this) {\n+            final List<V> list = new ArrayList<V>(parent.size());\n+            for (final V value : this) {\n                 list.add(value);\n             }\n             return list.toArray(arr);\n          * @param key  the key\n          * @param value  the value\n          */\n-        public ReferenceEntry(AbstractReferenceMap<K, V> parent, HashEntry<K, V> next, int hashCode, K key, V value) {\n+        public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n             super(next, hashCode, null, null);\n             this.parent = parent;\n             this.key = toReference(parent.keyType, key, hashCode);\n          */\n         @Override\n         @SuppressWarnings(\"unchecked\")\n-        public V setValue(V obj) {\n-            V old = getValue();\n+        public V setValue(final V obj) {\n+            final V old = getValue();\n             if (parent.valueType != ReferenceStrength.HARD) {\n                 ((Reference<V>) value).clear();\n             }\n          * @return true if equal, false if not\n          */\n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n                 return false;\n             }\n \n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>)obj;\n-            Object entryKey = entry.getKey();  // convert to hard reference\n-            Object entryValue = entry.getValue();  // convert to hard reference\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>)obj;\n+            final Object entryKey = entry.getKey();  // convert to hard reference\n+            final Object entryValue = entry.getValue();  // convert to hard reference\n             if (entryKey == null || entryValue == null) {\n                 return false;\n             }\n          *    the referent represents a value and not a key\n          * @return the reference to the object\n          */\n-        protected <T> Object toReference(ReferenceStrength type, T referent, int hash) {\n+        protected <T> Object toReference(final ReferenceStrength type, final T referent, final int hash) {\n             if (type == ReferenceStrength.HARD) {\n                 return referent;\n             }\n          * @param ref  the reference to purge\n          * @return true or false\n          */\n-        boolean purge(Reference<?> ref) {\n+        boolean purge(final Reference<?> ref) {\n             boolean r = parent.keyType != ReferenceStrength.HARD && key == ref;\n             r = r || parent.valueType != ReferenceStrength.HARD && value == ref;\n             if (r) {\n \n         int expectedModCount;\n \n-        public ReferenceBaseIterator(AbstractReferenceMap<K, V> parent) {\n+        public ReferenceBaseIterator(final AbstractReferenceMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             index = parent.size() != 0 ? parent.data.length : 0;\n     static class ReferenceEntrySetIterator<K, V>\n             extends ReferenceBaseIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n \n-        public ReferenceEntrySetIterator(AbstractReferenceMap<K, V> parent) {\n+        public ReferenceEntrySetIterator(final AbstractReferenceMap<K, V> parent) {\n             super(parent);\n         }\n \n     static class ReferenceKeySetIterator<K> extends ReferenceBaseIterator<K, Object> implements Iterator<K> {\n \n         @SuppressWarnings(\"unchecked\")\n-        ReferenceKeySetIterator(AbstractReferenceMap<K, ?> parent) {\n+        ReferenceKeySetIterator(final AbstractReferenceMap<K, ?> parent) {\n             super((AbstractReferenceMap<K, Object>) parent);\n         }\n \n     static class ReferenceValuesIterator<V> extends ReferenceBaseIterator<Object, V> implements Iterator<V> {\n \n         @SuppressWarnings(\"unchecked\")\n-        ReferenceValuesIterator(AbstractReferenceMap<?, V> parent) {\n+        ReferenceValuesIterator(final AbstractReferenceMap<?, V> parent) {\n             super((AbstractReferenceMap<Object, V>) parent);\n         }\n \n      */\n     static class ReferenceMapIterator<K, V> extends ReferenceBaseIterator<K, V> implements MapIterator<K, V> {\n \n-        protected ReferenceMapIterator(AbstractReferenceMap<K, V> parent) {\n+        protected ReferenceMapIterator(final AbstractReferenceMap<K, V> parent) {\n             super(parent);\n         }\n \n         }\n \n         public K getKey() {\n-            HashEntry<K, V> current = currentEntry();\n+            final HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n         }\n \n         public V getValue() {\n-            HashEntry<K, V> current = currentEntry();\n+            final HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n \n-        public V setValue(V value) {\n-            HashEntry<K, V> current = currentEntry();\n+        public V setValue(final V value) {\n+            final HashEntry<K, V> current = currentEntry();\n             if (current == null) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n         /** the hashCode of the key (even if the reference points to a value) */\n         private final int hash;\n \n-        public SoftRef(int hash, T r, ReferenceQueue<? super T> q) {\n+        public SoftRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n             super(r, q);\n             this.hash = hash;\n         }\n         /** the hashCode of the key (even if the reference points to a value) */\n         private final int hash;\n \n-        public WeakRef(int hash, T r, ReferenceQueue<? super T> q) {\n+        public WeakRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n             super(r, q);\n             this.hash = hash;\n         }\n      * @param out  the output stream\n      */\n     @Override\n-    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n         out.writeInt(keyType.value);\n         out.writeInt(valueType.value);\n         out.writeBoolean(purgeValues);\n         out.writeFloat(loadFactor);\n         out.writeInt(data.length);\n-        for (MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n+        for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n             out.writeObject(it.next());\n             out.writeObject(it.getValue());\n         }\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         this.keyType = ReferenceStrength.resolve(in.readInt());\n         this.valueType = ReferenceStrength.resolve(in.readInt());\n         this.purgeValues = in.readBoolean();\n         this.loadFactor = in.readFloat();\n-        int capacity = in.readInt();\n+        final int capacity = in.readInt();\n         init();\n         data = new HashEntry[capacity];\n         while (true) {\n-            K key = (K) in.readObject();\n+            final K key = (K) in.readObject();\n             if (key == null) {\n                 break;\n             }\n-            V value = (V) in.readObject();\n+            final V value = (V) in.readObject();\n             put(key, value);\n         }\n         threshold = calculateThreshold(data.length, loadFactor);\n--- a/src/main/java/org/apache/commons/collections/map/AbstractSortedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractSortedMapDecorator.java\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractSortedMapDecorator(SortedMap<K, V> map) {\n+    public AbstractSortedMapDecorator(final SortedMap<K, V> map) {\n         super(map);\n     }\n \n         return decorated().lastKey();\n     }\n \n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return decorated().subMap(fromKey, toKey);\n     }\n \n-    public SortedMap<K, V> headMap(K toKey) {\n+    public SortedMap<K, V> headMap(final K toKey) {\n         return decorated().headMap(toKey);\n     }\n \n-    public SortedMap<K, V> tailMap(K fromKey) {\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n         return decorated().tailMap(fromKey);\n     }\n \n-    public K previousKey(K key) {\n-        SortedMap<K, V> headMap = headMap(key);\n+    public K previousKey(final K key) {\n+        final SortedMap<K, V> headMap = headMap(key);\n         return headMap.isEmpty() ? null : headMap.lastKey();\n     }\n \n-    public K nextKey(K key) {\n-        Iterator<K> it = tailMap(key).keySet().iterator();\n+    public K nextKey(final K key) {\n+        final Iterator<K> it = tailMap(key).keySet().iterator();\n         it.next();\n         return it.hasNext() ? it.next() : null;\n     }\n         /**\n          * Create a new AbstractSortedMapDecorator.SortedMapIterator.\n          */\n-        protected SortedMapIterator(Set<Map.Entry<K, V>> entrySet) {\n+        protected SortedMapIterator(final Set<Map.Entry<K, V>> entrySet) {\n             super(entrySet);\n         }\n \n--- a/src/main/java/org/apache/commons/collections/map/CaseInsensitiveMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/CaseInsensitiveMap.java\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n      */\n-    public CaseInsensitiveMap(int initialCapacity) {\n+    public CaseInsensitiveMap(final int initialCapacity) {\n         super(initialCapacity);\n     }\n \n      * @throws IllegalArgumentException if the initial capacity is negative\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n-    public CaseInsensitiveMap(int initialCapacity, float loadFactor) {\n+    public CaseInsensitiveMap(final int initialCapacity, final float loadFactor) {\n         super(initialCapacity, loadFactor);\n     }\n \n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public CaseInsensitiveMap(Map<K, V> map) {\n+    public CaseInsensitiveMap(final Map<K, V> map) {\n         super(map);\n     }\n \n      * @return the converted key\n      */\n     @Override\n-    protected Object convertKey(Object key) {\n+    protected Object convertKey(final Object key) {\n         if (key != null) {\n-            char[] chars = key.toString().toCharArray();\n+            final char[] chars = key.toString().toCharArray();\n             for (int i = chars.length - 1; i >= 0; i--) {\n                 chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i]));\n             }\n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Read the map in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n--- a/src/main/java/org/apache/commons/collections/map/CompositeMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/CompositeMap.java\n      * @throws IllegalArgumentException if there is a key collision\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public CompositeMap(Map<K, V> one, Map<K, V> two) {\n+    public CompositeMap(final Map<K, V> one, final Map<K, V> two) {\n         this(new Map[] { one, two }, null);\n     }\n \n      * @param mutator  MapMutator to be used for mutation operations\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public CompositeMap(Map<K, V> one, Map<K, V> two, MapMutator<K, V> mutator) {\n+    public CompositeMap(final Map<K, V> one, final Map<K, V> two, final MapMutator<K, V> mutator) {\n         this(new Map[] { one, two }, mutator);\n     }\n \n      * @param composite  the Maps to be composited\n      * @throws IllegalArgumentException if there is a key collision\n      */\n-    public CompositeMap(Map<K, V>... composite) {\n+    public CompositeMap(final Map<K, V>... composite) {\n         this(composite, null);\n     }\n \n      * @param mutator  MapMutator to be used for mutation operations\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public CompositeMap(Map<K, V>[] composite, MapMutator<K, V> mutator) {\n+    public CompositeMap(final Map<K, V>[] composite, final MapMutator<K, V> mutator) {\n         this.mutator = mutator;\n         this.composite = new Map[0];\n         for (int i = composite.length - 1; i >= 0; --i) {\n      *\n      * @param mutator  the MapMutator to be used for mutation delegation\n      */\n-    public void setMutator(MapMutator<K, V> mutator) {\n+    public void setMutator(final MapMutator<K, V> mutator) {\n         this.mutator = mutator;\n     }\n \n      *         MapMutator set to handle it.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public synchronized void addComposited(Map<K, V> map) throws IllegalArgumentException {\n+    public synchronized void addComposited(final Map<K, V> map) throws IllegalArgumentException {\n         for (int i = composite.length - 1; i >= 0; --i) {\n-            Collection<K> intersect = CollectionUtils.intersection(this.composite[i].keySet(), map.keySet());\n+            final Collection<K> intersect = CollectionUtils.intersection(this.composite[i].keySet(), map.keySet());\n             if (intersect.size() != 0) {\n                 if (this.mutator == null) {\n                     throw new IllegalArgumentException(\"Key collision adding Map to CompositeMap\");\n                 this.mutator.resolveCollision(this, this.composite[i], map, intersect);\n             }\n         }\n-        Map<K, V>[] temp = new Map[this.composite.length + 1];\n+        final Map<K, V>[] temp = new Map[this.composite.length + 1];\n         System.arraycopy(this.composite, 0, temp, 0, this.composite.length);\n         temp[temp.length - 1] = map;\n         this.composite = temp;\n      * @return The removed Map or <code>null</code> if map is not in the composite\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public synchronized Map<K, V> removeComposited(Map<K, V> map) {\n-        int size = this.composite.length;\n+    public synchronized Map<K, V> removeComposited(final Map<K, V> map) {\n+        final int size = this.composite.length;\n         for (int i = 0; i < size; ++i) {\n             if (this.composite[i].equals(map)) {\n-                Map<K, V>[] temp = new Map[size - 1];\n+                final Map<K, V>[] temp = new Map[size - 1];\n                 System.arraycopy(this.composite, 0, temp, 0, i);\n                 System.arraycopy(this.composite, i + 1, temp, i, size - i - 1);\n                 this.composite = temp;\n      * @throws NullPointerException if the key is <tt>null</tt> and this map\n      *            does not not permit <tt>null</tt> keys (optional).\n      */\n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             if (this.composite[i].containsKey(key)) {\n                 return true;\n      * @throws NullPointerException if the value is <tt>null</tt> and this map\n      *            does not not permit <tt>null</tt> values (optional).\n      */\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             if (this.composite[i].containsValue(value)) {\n                 return true;\n      * @return a set view of the mappings contained in this map.\n      */\n     public Set<Map.Entry<K, V>> entrySet() {\n-        CompositeSet<Map.Entry<K, V>> entries = new CompositeSet<Map.Entry<K,V>>();\n+        final CompositeSet<Map.Entry<K, V>> entries = new CompositeSet<Map.Entry<K,V>>();\n         for (int i = composite.length - 1; i >= 0; --i) {\n             entries.addComposited(composite[i].entrySet());\n         }\n      *\n      * @see #containsKey(Object)\n      */\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             if (this.composite[i].containsKey(key)) {\n                 return this.composite[i].get(key);\n      * @return a set view of the keys contained in this map.\n      */\n     public Set<K> keySet() {\n-        CompositeSet<K> keys = new CompositeSet<K>();\n+        final CompositeSet<K> keys = new CompositeSet<K>();\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             keys.addComposited(this.composite[i].keySet());\n         }\n      *            keys or values, and the specified key or value is\n      *            <tt>null</tt>.\n      */\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (this.mutator == null) {\n             throw new UnsupportedOperationException(\"No mutator specified\");\n         }\n      *         this map does not permit <tt>null</tt> keys or values, and the\n      *         specified map contains <tt>null</tt> keys or values.\n      */\n-    public void putAll(Map<? extends K, ? extends V> map) {\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n         if (this.mutator == null) {\n             throw new UnsupportedOperationException(\"No mutator specified\");\n         }\n      * @throws UnsupportedOperationException if the <tt>remove</tt> method is\n      *         not supported by the composited map containing the key\n      */\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             if (this.composite[i].containsKey(key)) {\n                 return this.composite[i].remove(key);\n      * @return a collection view of the values contained in this map.\n      */\n     public Collection<V> values() {\n-        CompositeCollection<V> values = new CompositeCollection<V>();\n+        final CompositeCollection<V> values = new CompositeCollection<V>();\n         for (int i = composite.length - 1; i >= 0; --i) {\n             values.addComposited(composite[i].values());\n         }\n      * @return true if the maps are equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof Map) {\n-            Map<?, ?> map = (Map<?, ?>) obj;\n+            final Map<?, ?> map = (Map<?, ?>) obj;\n             return this.entrySet().equals(map.entrySet());\n         }\n         return false;\n     @Override\n     public int hashCode() {\n         int code = 0;\n-        for (Map.Entry<K, V> entry : entrySet()) {\n+        for (final Map.Entry<K, V> entry : entrySet()) {\n             code += entry.hashCode();\n         }\n         return code;\n--- a/src/main/java/org/apache/commons/collections/map/DefaultedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/DefaultedMap.java\n      * @return a new defaulting map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> DefaultedMap<K, V> defaultedMap(Map<K, V> map, V defaultValue) {\n+    public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n         return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n     }\n \n      * @return a new defaulting map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> DefaultedMap<K, V> defaultedMap(Map<K, V> map, Factory<? extends V> factory) {\n+    public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n         }\n      * @return a new defaulting map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> Map<K, V> defaultedMap(Map<K, V> map, Transformer<? super K, ? extends V> transformer) {\n+    public static <K, V> Map<K, V> defaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformer) {\n         if (transformer == null) {\n            throw new IllegalArgumentException(\"Transformer must not be null\");\n        }\n      * \n      * @param defaultValue  the default value to return when the key is not found\n      */\n-    public DefaultedMap(V defaultValue) {\n+    public DefaultedMap(final V defaultValue) {\n         this(ConstantTransformer.constantTransformer(defaultValue));\n     }\n \n      *\n      * @param defaultValueTransformer transformer to use to generate missing values.\n      */\n-    public DefaultedMap(Transformer<? super K, ? extends V> defaultValueTransformer) {\n+    public DefaultedMap(final Transformer<? super K, ? extends V> defaultValueTransformer) {\n         this(new HashMap<K, V>(), defaultValueTransformer);\n     }\n \n      * @param defaultValueTransformer  the value transformer to use\n      * @throws IllegalArgumentException if map or transformer is null\n      */\n-    protected DefaultedMap(Map<K, V> map, Transformer<? super K, ? extends V> defaultValueTransformer) {\n+    protected DefaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> defaultValueTransformer) {\n         super(map);\n         if (defaultValueTransformer == null) {\n             throw new IllegalArgumentException(\"transformer must not be null\");\n      * @param out  the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @throws ClassNotFoundException\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject();\n     }\n     //-----------------------------------------------------------------------\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         // create value for key if key is not currently in the map\n         if (map.containsKey(key) == false) {\n             return value.transform((K) key);\n--- a/src/main/java/org/apache/commons/collections/map/EntrySetToMapIteratorAdapter.java\n+++ b/src/main/java/org/apache/commons/collections/map/EntrySetToMapIteratorAdapter.java\n     /**\n      * Create a new EntrySetToMapIteratorAdapter.\n      */\n-    public EntrySetToMapIteratorAdapter(Set<Map.Entry<K, V>> entrySet) {\n+    public EntrySetToMapIteratorAdapter(final Set<Map.Entry<K, V>> entrySet) {\n         this.entrySet = entrySet;\n         reset();\n     }\n     /**\n      * {@inheritDoc}\n      */\n-    public V setValue(V value) {\n+    public V setValue(final V value) {\n         return current().setValue(value);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/FixedSizeMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/FixedSizeMap.java\n      * @return a new fixed size map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> FixedSizeMap<K, V> fixedSizeMap(Map<K, V> map) {\n+    public static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n         return new FixedSizeMap<K, V>(map);\n     }\n \n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected FixedSizeMap(Map<K, V> map) {\n+    protected FixedSizeMap(final Map<K, V> map) {\n         super(map);\n     }\n \n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (map.containsKey(key) == false) {\n             throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n         }\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n-        for (K key : mapToCopy.keySet()) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        for (final K key : mapToCopy.keySet()) {\n             if (!containsKey(key)) {\n                 throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n             }\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException(\"Map is fixed size\");\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        Set<Map.Entry<K, V>> set = map.entrySet();\n+        final Set<Map.Entry<K, V>> set = map.entrySet();\n         // unmodifiable set will still allow modification via Map.Entry objects\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        Set<K> set = map.keySet();\n+        final Set<K> set = map.keySet();\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n-        Collection<V> coll = map.values();\n+        final Collection<V> coll = map.values();\n         return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/FixedSizeSortedMap.java\n      * @return a new fixed size sorted map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(SortedMap<K, V> map) {\n+    public static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n         return new FixedSizeSortedMap<K, V>(map);\n     }\n \n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected FixedSizeSortedMap(SortedMap<K, V> map) {\n+    protected FixedSizeSortedMap(final SortedMap<K, V> map) {\n         super(map);\n     }\n \n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * Read the map in using a custom routine.\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (map.containsKey(key) == false) {\n             throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n         }\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         if (CollectionUtils.isSubCollection(mapToCopy.keySet(), keySet())) {\n             throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n         }\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException(\"Map is fixed size\");\n     }\n \n \n     //-----------------------------------------------------------------------\n     @Override\n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return new FixedSizeSortedMap<K, V>(getSortedMap().subMap(fromKey, toKey));\n     }\n \n     @Override\n-    public SortedMap<K, V> headMap(K toKey) {\n+    public SortedMap<K, V> headMap(final K toKey) {\n         return new FixedSizeSortedMap<K, V>(getSortedMap().headMap(toKey));\n     }\n \n     @Override\n-    public SortedMap<K, V> tailMap(K fromKey) {\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n         return new FixedSizeSortedMap<K, V>(getSortedMap().tailMap(fromKey));\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/Flat3Map.java\n+++ b/src/main/java/org/apache/commons/collections/map/Flat3Map.java\n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public Flat3Map(Map<? extends K, ? extends V> map) {\n+    public Flat3Map(final Map<? extends K, ? extends V> map) {\n         super();\n         putAll(map);\n     }\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         if (delegateMap != null) {\n             return delegateMap.get(key);\n         }\n             }\n         } else {\n             if (size > 0) {\n-                int hashCode = key.hashCode();\n+                final int hashCode = key.hashCode();\n                 switch (size) {\n                     // drop through\n                     case 3:\n      * @param key  the key to search for\n      * @return true if the map contains the key\n      */\n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         if (delegateMap != null) {\n             return delegateMap.containsKey(key);\n         }\n             }\n         } else {\n             if (size > 0) {\n-                int hashCode = key.hashCode();\n+                final int hashCode = key.hashCode();\n                 switch (size) {  // drop through\n                     case 3:\n                         if (hash3 == hashCode && key.equals(key3)) {\n      * @param value  the value to search for\n      * @return true if the map contains the key\n      */\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         if (delegateMap != null) {\n             return delegateMap.containsValue(value);\n         }\n      * @param value  the value to add\n      * @return the value previously mapped to this key, null if none\n      */\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (delegateMap != null) {\n             return delegateMap.put(key, value);\n         }\n             switch (size) {  // drop through\n                 case 3:\n                     if (key3 == null) {\n-                        V old = value3;\n+                        final V old = value3;\n                         value3 = value;\n                         return old;\n                     }\n                 case 2:\n                     if (key2 == null) {\n-                        V old = value2;\n+                        final V old = value2;\n                         value2 = value;\n                         return old;\n                     }\n                 case 1:\n                     if (key1 == null) {\n-                        V old = value1;\n+                        final V old = value1;\n                         value1 = value;\n                         return old;\n                     }\n             }\n         } else {\n             if (size > 0) {\n-                int hashCode = key.hashCode();\n+                final int hashCode = key.hashCode();\n                 switch (size) {  // drop through\n                     case 3:\n                         if (hash3 == hashCode && key.equals(key3)) {\n-                            V old = value3;\n+                            final V old = value3;\n                             value3 = value;\n                             return old;\n                         }\n                     case 2:\n                         if (hash2 == hashCode && key.equals(key2)) {\n-                            V old = value2;\n+                            final V old = value2;\n                             value2 = value;\n                             return old;\n                         }\n                     case 1:\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            V old = value1;\n+                            final V old = value1;\n                             value1 = value;\n                             return old;\n                         }\n      * @param map  the map to add\n      * @throws NullPointerException if the map is null\n      */\n-    public void putAll(Map<? extends K, ? extends V> map) {\n-        int size = map.size();\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        final int size = map.size();\n         if (size == 0) {\n             return;\n         }\n             return;\n         }\n         if (size < 4) {\n-            for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n                 put(entry.getKey(), entry.getValue());\n             }\n         } else {\n      * @param key  the mapping to remove\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         if (delegateMap != null) {\n             return delegateMap.remove(key);\n         }\n             switch (size) {  // drop through\n                 case 3:\n                     if (key3 == null) {\n-                        V old = value3;\n+                        final V old = value3;\n                         hash3 = 0;\n                         key3 = null;\n                         value3 = null;\n                         return old;\n                     }\n                     if (key2 == null) {\n-                        V old = value2;\n+                        final V old = value2;\n                         hash2 = hash3;\n                         key2 = key3;\n                         value2 = value3;\n                         return old;\n                     }\n                     if (key1 == null) {\n-                        V old = value1;\n+                        final V old = value1;\n                         hash1 = hash3;\n                         key1 = key3;\n                         value1 = value3;\n                     return null;\n                 case 2:\n                     if (key2 == null) {\n-                        V old = value2;\n+                        final V old = value2;\n                         hash2 = 0;\n                         key2 = null;\n                         value2 = null;\n                         return old;\n                     }\n                     if (key1 == null) {\n-                        V old = value1;\n+                        final V old = value1;\n                         hash1 = hash2;\n                         key1 = key2;\n                         value1 = value2;\n                     return null;\n                 case 1:\n                     if (key1 == null) {\n-                        V old = value1;\n+                        final V old = value1;\n                         hash1 = 0;\n                         key1 = null;\n                         value1 = null;\n             }\n         } else {\n             if (size > 0) {\n-                int hashCode = key.hashCode();\n+                final int hashCode = key.hashCode();\n                 switch (size) {  // drop through\n                     case 3:\n                         if (hash3 == hashCode && key.equals(key3)) {\n-                            V old = value3;\n+                            final V old = value3;\n                             hash3 = 0;\n                             key3 = null;\n                             value3 = null;\n                             return old;\n                         }\n                         if (hash2 == hashCode && key.equals(key2)) {\n-                            V old = value2;\n+                            final V old = value2;\n                             hash2 = hash3;\n                             key2 = key3;\n                             value2 = value3;\n                             return old;\n                         }\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            V old = value1;\n+                            final V old = value1;\n                             hash1 = hash3;\n                             key1 = key3;\n                             value1 = value3;\n                         return null;\n                     case 2:\n                         if (hash2 == hashCode && key.equals(key2)) {\n-                            V old = value2;\n+                            final V old = value2;\n                             hash2 = 0;\n                             key2 = null;\n                             value2 = null;\n                             return old;\n                         }\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            V old = value1;\n+                            final V old = value1;\n                             hash1 = hash2;\n                             key1 = key2;\n                             value1 = value2;\n                         return null;\n                     case 1:\n                         if (hash1 == hashCode && key.equals(key1)) {\n-                            V old = value1;\n+                            final V old = value1;\n                             hash1 = 0;\n                             key1 = null;\n                             value1 = null;\n         private int nextIndex = 0;\n         private boolean canRemove = false;\n \n-        FlatMapIterator(Flat3Map<K, V> parent) {\n+        FlatMapIterator(final Flat3Map<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n-        public V setValue(V value) {\n+        public V setValue(final V value) {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n-            V old = getValue();\n+            final V old = getValue();\n             switch (nextIndex) {\n                 case 3:\n                     parent.value3 = value;\n     static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n         private final Flat3Map<K, V> parent;\n \n-        EntrySet(Flat3Map<K, V> parent) {\n+        EntrySet(final Flat3Map<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         }\n \n         @Override\n-        public boolean remove(Object obj) {\n+        public boolean remove(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            Object key = entry.getKey();\n-            boolean result = parent.containsKey(key);\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object key = entry.getKey();\n+            final boolean result = parent.containsKey(key);\n             parent.remove(key);\n             return result;\n         }\n         /**\n          * Create a new Flat3Map.EntryIterator.\n          */\n-        public EntryIterator(Flat3Map<K, V> parent) {\n+        public EntryIterator(final Flat3Map<K, V> parent) {\n             this.parent = parent;\n         }\n \n             throw new IllegalStateException(\"Invalid map index\");\n         }\n \n-        public V setValue(V value) {\n+        public V setValue(final V value) {\n             if (canRemove == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n-            V old = getValue();\n+            final V old = getValue();\n             switch (nextIndex) {\n                 case 3:\n                     parent.value3 = value;\n      */\n     static class EntrySetIterator<K, V> extends EntryIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n \n-        EntrySetIterator(Flat3Map<K, V> parent) {\n+        EntrySetIterator(final Flat3Map<K, V> parent) {\n             super(parent);\n         }\n \n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (canRemove == false) {\n                 return false;\n             }\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n-            Object key = getKey();\n-            Object value = getValue();\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            final Object key = getKey();\n+            final Object value = getValue();\n             return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n                    (value == null ? other.getValue() == null : value.equals(other.getValue()));\n         }\n             if (canRemove == false) {\n                 return 0;\n             }\n-            Object key = getKey();\n-            Object value = getValue();\n+            final Object key = getKey();\n+            final Object value = getValue();\n             return (key == null ? 0 : key.hashCode()) ^\n                    (value == null ? 0 : value.hashCode());\n         }\n     static class KeySet<K> extends AbstractSet<K> {\n         private final Flat3Map<K, ?> parent;\n \n-        KeySet(Flat3Map<K, ?> parent) {\n+        KeySet(final Flat3Map<K, ?> parent) {\n             super();\n             this.parent = parent;\n         }\n         }\n \n         @Override\n-        public boolean contains(Object key) {\n+        public boolean contains(final Object key) {\n             return parent.containsKey(key);\n         }\n \n         @Override\n-        public boolean remove(Object key) {\n-            boolean result = parent.containsKey(key);\n+        public boolean remove(final Object key) {\n+            final boolean result = parent.containsKey(key);\n             parent.remove(key);\n             return result;\n         }\n     static class KeySetIterator<K> extends EntryIterator<K, Object> implements Iterator<K>{\n \n         @SuppressWarnings(\"unchecked\")\n-        KeySetIterator(Flat3Map<K, ?> parent) {\n+        KeySetIterator(final Flat3Map<K, ?> parent) {\n             super((Flat3Map<K, Object>) parent);\n         }\n \n     static class Values<V> extends AbstractCollection<V> {\n         private final Flat3Map<?, V> parent;\n \n-        Values(Flat3Map<?, V> parent) {\n+        Values(final Flat3Map<?, V> parent) {\n             super();\n             this.parent = parent;\n         }\n         }\n \n         @Override\n-        public boolean contains(Object value) {\n+        public boolean contains(final Object value) {\n             return parent.containsValue(value);\n         }\n \n     static class ValuesIterator<V> extends EntryIterator<Object, V> implements Iterator<V> {\n \n         @SuppressWarnings(\"unchecked\")\n-        ValuesIterator(Flat3Map<?, V> parent) {\n+        ValuesIterator(final Flat3Map<?, V> parent) {\n             super((Flat3Map<Object, V>) parent);\n         }\n \n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeInt(size());\n-        for (MapIterator<?, ?> it = mapIterator(); it.hasNext();) {\n+        for (final MapIterator<?, ?> it = mapIterator(); it.hasNext();) {\n             out.writeObject(it.next());  // key\n             out.writeObject(it.getValue());  // value\n         }\n      * Read the map in using a custom routine.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        int count = in.readInt();\n+        final int count = in.readInt();\n         if (count > 3) {\n             delegateMap = createDelegateMap();\n         }\n     @SuppressWarnings(\"unchecked\")\n     public Flat3Map<K, V> clone() {\n         try {\n-            Flat3Map<K, V> cloned = (Flat3Map<K, V>) super.clone();\n+            final Flat3Map<K, V> cloned = (Flat3Map<K, V>) super.clone();\n             if (cloned.delegateMap != null) {\n                 cloned.delegateMap = cloned.delegateMap.clone();\n             }\n             return cloned;\n-        } catch (CloneNotSupportedException ex) {\n+        } catch (final CloneNotSupportedException ex) {\n             throw new InternalError();\n         }\n     }\n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map == false) {\n             return false;\n         }\n-        Map<?, ?> other = (Map<?, ?>) obj;\n+        final Map<?, ?> other = (Map<?, ?>) obj;\n         if (size != other.size()) {\n             return false;\n         }\n         if (size == 0) {\n             return \"{}\";\n         }\n-        StringBuilder buf = new StringBuilder(128);\n+        final StringBuilder buf = new StringBuilder(128);\n         buf.append('{');\n         switch (size) {  // drop through\n             case 3:\n--- a/src/main/java/org/apache/commons/collections/map/HashedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/HashedMap.java\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n      */\n-    public HashedMap(int initialCapacity) {\n+    public HashedMap(final int initialCapacity) {\n         super(initialCapacity);\n     }\n \n      * @throws IllegalArgumentException if the initial capacity is negative\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n-    public HashedMap(int initialCapacity, float loadFactor) {\n+    public HashedMap(final int initialCapacity, final float loadFactor) {\n         super(initialCapacity, loadFactor);\n     }\n \n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public HashedMap(Map<K, V> map) {\n+    public HashedMap(final Map<K, V> map) {\n         super(map);\n     }\n \n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Read the map in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n--- a/src/main/java/org/apache/commons/collections/map/IdentityMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/IdentityMap.java\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n      */\n-    public IdentityMap(int initialCapacity) {\n+    public IdentityMap(final int initialCapacity) {\n         super(initialCapacity);\n     }\n \n      * @throws IllegalArgumentException if the initial capacity is negative\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n-    public IdentityMap(int initialCapacity, float loadFactor) {\n+    public IdentityMap(final int initialCapacity, final float loadFactor) {\n         super(initialCapacity, loadFactor);\n     }\n \n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public IdentityMap(Map<K, V> map) {\n+    public IdentityMap(final Map<K, V> map) {\n         super(map);\n     }\n \n      * @return the hash code\n      */\n     @Override\n-    protected int hash(Object key) {\n+    protected int hash(final Object key) {\n         return System.identityHashCode(key);\n     }\n \n      * @return true if equal by identity\n      */\n     @Override\n-    protected boolean isEqualKey(Object key1, Object key2) {\n+    protected boolean isEqualKey(final Object key1, final Object key2) {\n         return key1 == key2;\n     }\n \n      * @return true if equal by identity\n      */\n     @Override\n-    protected boolean isEqualValue(Object value1, Object value2) {\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n         return value1 == value2;\n     }\n \n      * @return the newly created entry\n      */\n     @Override\n-    protected IdentityEntry<K, V> createEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+    protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n         return new IdentityEntry<K, V>(next, hashCode, key, value);\n     }\n \n      */\n     protected static class IdentityEntry<K, V> extends HashEntry<K, V> {\n \n-        protected IdentityEntry(HashEntry<K, V> next, int hashCode, K key, V value) {\n+        protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n             super(next, hashCode, key, value);\n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n             return\n                 getKey() == other.getKey() &&\n                 getValue() == other.getValue();\n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Read the map in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n--- a/src/main/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LRUMap.java\n      * @param maxSize  the maximum size of the map\n      * @throws IllegalArgumentException if the maximum size is less than one\n      */\n-    public LRUMap(int maxSize) {\n+    public LRUMap(final int maxSize) {\n         this(maxSize, DEFAULT_LOAD_FACTOR);\n     }\n \n      * @throws IllegalArgumentException if the maximum size is less than one\n      * @since 3.1\n      */\n-    public LRUMap(int maxSize, boolean scanUntilRemovable) {\n+    public LRUMap(final int maxSize, final boolean scanUntilRemovable) {\n         this(maxSize, DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n     }\n \n      * @throws IllegalArgumentException if the maximum size is less than one\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n-    public LRUMap(int maxSize, float loadFactor) {\n+    public LRUMap(final int maxSize, final float loadFactor) {\n         this(maxSize, loadFactor, false);\n     }\n \n      * @throws IllegalArgumentException if the load factor is less than zero\n      * @since 3.1\n      */\n-    public LRUMap(int maxSize, float loadFactor, boolean scanUntilRemovable) {\n+    public LRUMap(final int maxSize, final float loadFactor, final boolean scanUntilRemovable) {\n         super(maxSize < 1 ? DEFAULT_CAPACITY : maxSize, loadFactor);\n         if (maxSize < 1) {\n             throw new IllegalArgumentException(\"LRUMap max size must be greater than 0\");\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if the map is empty\n      */\n-    public LRUMap(Map<K, V> map) {\n+    public LRUMap(final Map<K, V> map) {\n         this(map, false);\n     }\n \n      * @throws IllegalArgumentException if the map is empty\n      * @since 3.1\n      */\n-    public LRUMap(Map<K, V> map, boolean scanUntilRemovable) {\n+    public LRUMap(final Map<K, V> map, final boolean scanUntilRemovable) {\n         this(map.size(), DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n         putAll(map);\n     }\n      * @return the mapped value, null if no match\n      */\n     @Override\n-    public V get(Object key) {\n-        LinkEntry<K, V> entry = getEntry(key);\n+    public V get(final Object key) {\n+        final LinkEntry<K, V> entry = getEntry(key);\n         if (entry == null) {\n             return null;\n         }\n      *\n      * @param entry  the entry to update\n      */\n-    protected void moveToMRU(LinkEntry<K, V> entry) {\n+    protected void moveToMRU(final LinkEntry<K, V> entry) {\n         if (entry.after != header) {\n             modCount++;\n             // remove\n      * @param newValue  the new value to store\n      */\n     @Override\n-    protected void updateEntry(HashEntry<K, V> entry, V newValue) {\n+    protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {\n         moveToMRU((LinkEntry<K, V>) entry);  // handles modCount\n         entry.setValue(newValue);\n     }\n      * @param value  the value to add\n      */\n     @Override\n-    protected void addMapping(int hashIndex, int hashCode, K key, V value) {\n+    protected void addMapping(final int hashIndex, final int hashCode, final K key, final V value) {\n         if (isFull()) {\n             LinkEntry<K, V> reuse = header.after;\n             boolean removeLRUEntry = false;\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void reuseMapping(LinkEntry<K, V> entry, int hashIndex, int hashCode, K key, V value) {\n+    protected void reuseMapping(final LinkEntry<K, V> entry, final int hashIndex, final int hashCode, final K key, final V value) {\n         // find the entry before the entry specified in the hash table\n         // remember that the parameters (except the first) refer to the new entry,\n         // not the old one\n         try {\n-            int removeIndex = hashIndex(entry.hashCode, data.length);\n-            HashEntry<K, V>[] tmp = data;  // may protect against some sync issues\n+            final int removeIndex = hashIndex(entry.hashCode, data.length);\n+            final HashEntry<K, V>[] tmp = data;  // may protect against some sync issues\n             HashEntry<K, V> loop = tmp[removeIndex];\n             HashEntry<K, V> previous = null;\n             while (loop != entry && loop != null) {\n             removeEntry(entry, removeIndex, previous);\n             reuseEntry(entry, hashIndex, hashCode, key, value);\n             addEntry(entry, hashIndex);\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             throw new IllegalStateException(\n                     \"NPE, entry=\" + entry + \" entryIsHeader=\" + (entry==header) +\n                     \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n      * @param entry  the entry to be removed\n      * @return {@code true}\n      */\n-    protected boolean removeLRU(LinkEntry<K, V> entry) {\n+    protected boolean removeLRU(final LinkEntry<K, V> entry) {\n         return true;\n     }\n \n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Read the map in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n      * Writes the data necessary for <code>put()</code> to work in deserialization.\n      */\n     @Override\n-    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n         out.writeInt(maxSize);\n         super.doWriteObject(out);\n     }\n      * Reads the data necessary for <code>put()</code> to work in the superclass.\n      */\n     @Override\n-    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         maxSize = in.readInt();\n         super.doReadObject(in);\n     }\n--- a/src/main/java/org/apache/commons/collections/map/LazyMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LazyMap.java\n      * @return a new lazy map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> LazyMap<K, V> lazyMap(Map<K, V> map, Factory< ? extends V> factory) {\n+    public static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory< ? extends V> factory) {\n         return new LazyMap<K,V>(map, factory);\n     }\n \n      * @return a new lazy map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <V, K> LazyMap<K, V> lazyMap(Map<K, V> map, Transformer<? super K, ? extends V> factory) {\n+    public static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n         return new LazyMap<K,V>(map, factory);\n     }\n \n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    protected LazyMap(Map<K,V> map, Factory<? extends V> factory) {\n+    protected LazyMap(final Map<K,V> map, final Factory<? extends V> factory) {\n         super(map);\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    protected LazyMap(Map<K,V> map, Transformer<? super K, ? extends V> factory) {\n+    protected LazyMap(final Map<K,V> map, final Transformer<? super K, ? extends V> factory) {\n         super(map);\n         if (factory == null) {\n             throw new IllegalArgumentException(\"Factory must not be null\");\n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject();\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         // create value for key if key is not currently in the map\n         if (map.containsKey(key) == false) {\n             @SuppressWarnings(\"unchecked\")\n+            final\n             K castKey = (K) key;\n-            V value = factory.transform(castKey);\n+            final V value = factory.transform(castKey);\n             map.put(castKey, value);\n             return value;\n         }\n--- a/src/main/java/org/apache/commons/collections/map/LazySortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LazySortedMap.java\n      * @return a new lazy sorted map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> LazySortedMap<K, V> lazySortedMap(SortedMap<K, V> map, Factory<? extends V> factory) {\n+    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n      * @return a new lazy sorted map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> LazySortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n-                                                           Transformer<? super K, ? extends V> factory) {\n+    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n+                                                           final Transformer<? super K, ? extends V> factory) {\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    protected LazySortedMap(SortedMap<K,V> map, Factory<? extends V> factory) {\n+    protected LazySortedMap(final SortedMap<K,V> map, final Factory<? extends V> factory) {\n         super(map, factory);\n     }\n \n      * @param factory  the factory to use, must not be null\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    protected LazySortedMap(SortedMap<K,V> map, Transformer<? super K, ? extends V> factory) {\n+    protected LazySortedMap(final SortedMap<K,V> map, final Transformer<? super K, ? extends V> factory) {\n         super(map, factory);\n     }\n \n         return getSortedMap().comparator();\n     }\n \n-    public SortedMap<K,V> subMap(K fromKey, K toKey) {\n-        SortedMap<K,V> map = getSortedMap().subMap(fromKey, toKey);\n+    public SortedMap<K,V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K,V> map = getSortedMap().subMap(fromKey, toKey);\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n-    public SortedMap<K,V> headMap(K toKey) {\n-        SortedMap<K,V> map = getSortedMap().headMap(toKey);\n+    public SortedMap<K,V> headMap(final K toKey) {\n+        final SortedMap<K,V> map = getSortedMap().headMap(toKey);\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n-    public SortedMap<K,V> tailMap(K fromKey) {\n-        SortedMap<K,V> map = getSortedMap().tailMap(fromKey);\n+    public SortedMap<K,V> tailMap(final K fromKey) {\n+        final SortedMap<K,V> map = getSortedMap().tailMap(fromKey);\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/LinkedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LinkedMap.java\n      * @param initialCapacity  the initial capacity\n      * @throws IllegalArgumentException if the initial capacity is negative\n      */\n-    public LinkedMap(int initialCapacity) {\n+    public LinkedMap(final int initialCapacity) {\n         super(initialCapacity);\n     }\n \n      * @throws IllegalArgumentException if the initial capacity is negative\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n-    public LinkedMap(int initialCapacity, float loadFactor) {\n+    public LinkedMap(final int initialCapacity, final float loadFactor) {\n         super(initialCapacity, loadFactor);\n     }\n \n      * @param map  the map to copy\n      * @throws NullPointerException if the map is null\n      */\n-    public LinkedMap(Map<K, V> map) {\n+    public LinkedMap(final Map<K, V> map) {\n         super(map);\n     }\n \n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Read the map in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public K get(int index) {\n+    public K get(final int index) {\n         return getEntry(index).getKey();\n     }\n     \n      * @return the value at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public V getValue(int index) {\n+    public V getValue(final int index) {\n         return getEntry(index).getValue();\n     }\n     \n      *  or <code>null</code> if none existed\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public V remove(int index) {\n+    public V remove(final int index) {\n         return remove(get(index));\n     }\n \n \n         final LinkedMap<K, ?> parent;\n \n-        LinkedMapList(LinkedMap<K, ?> parent) {\n+        LinkedMapList(final LinkedMap<K, ?> parent) {\n             this.parent = parent;\n         }\n \n         }\n \n         @Override\n-        public K get(int index) {\n+        public K get(final int index) {\n             return parent.get(index);\n         }\n \n         @Override\n-        public boolean contains(Object obj) {\n+        public boolean contains(final Object obj) {\n             return parent.containsKey(obj);\n         }\n \n         @Override\n-        public int indexOf(Object obj) {\n+        public int indexOf(final Object obj) {\n             return parent.indexOf(obj);\n         }\n \n         @Override\n-        public int lastIndexOf(Object obj) {\n+        public int lastIndexOf(final Object obj) {\n             return parent.indexOf(obj);\n         }\n \n         @Override\n-        public boolean containsAll(Collection<?> coll) {\n+        public boolean containsAll(final Collection<?> coll) {\n             return parent.keySet().containsAll(coll);\n         }\n \n         @Override\n-        public K remove(int index) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public boolean remove(Object obj) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public boolean removeAll(Collection<?> coll) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public boolean retainAll(Collection<?> coll) {\n+        public K remove(final int index) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean removeAll(final Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean retainAll(final Collection<?> coll) {\n             throw new UnsupportedOperationException();\n         }\n \n         }\n \n         @Override\n-        public <T> T[] toArray(T[] array) {\n+        public <T> T[] toArray(final T[] array) {\n             return parent.keySet().toArray(array);\n         }\n \n         }\n \n         @Override\n-        public ListIterator<K> listIterator(int fromIndex) {\n+        public ListIterator<K> listIterator(final int fromIndex) {\n             return UnmodifiableListIterator.umodifiableListIterator(super.listIterator(fromIndex));\n         }\n \n         @Override\n-        public List<K> subList(int fromIndexInclusive, int toIndexExclusive) {\n+        public List<K> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n             return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/ListOrderedMap.java\n      * @return a new list ordered map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> ListOrderedMap<K, V> listOrderedMap(Map<K, V> map) {\n+    public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n         return new ListOrderedMap<K, V>(map);\n     }\n \n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected ListOrderedMap(Map<K, V> map) {\n+    protected ListOrderedMap(final Map<K, V> map) {\n         super(map);\n         insertOrder.addAll(decorated().keySet());\n     }\n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     }\n      * @param key  the key to find previous for\n      * @return the next key, null if no match or at start\n      */\n-    public K nextKey(Object key) {\n-        int index = insertOrder.indexOf(key);\n+    public K nextKey(final Object key) {\n+        final int index = insertOrder.indexOf(key);\n         if (index >= 0 && index < size() - 1) {\n             return insertOrder.get(index + 1);\n         }\n      * @param key  the key to find previous for\n      * @return the previous key, null if no match or at start\n      */\n-    public K previousKey(Object key) {\n-        int index = insertOrder.indexOf(key);\n+    public K previousKey(final Object key) {\n+        final int index = insertOrder.indexOf(key);\n         if (index > 0) {\n             return insertOrder.get(index - 1);\n         }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (decorated().containsKey(key)) {\n             // re-adding doesn't change order\n             return decorated().put(key, value);\n         } else {\n             // first add, so add to both map and list\n-            V result = decorated().put(key, value);\n+            final V result = decorated().put(key, value);\n             insertOrder.add(key);\n             return result;\n         }\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> map) {\n-        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n      * @param index the index in the Map to start at.\n      * @param map the Map containing the values to be added.\n      */\n-    public void putAll(int index, Map<? extends K, ? extends V> map) {\n-        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n-            V old = put(index, entry.getKey(), entry.getValue());\n+    public void putAll(int index, final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            final V old = put(index, entry.getKey(), entry.getValue());\n             if (old == null) {\n                 // if no key was replaced, increment the index\n                 index++;\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         V result = null;\n         if (decorated().containsKey(key)) {\n             result = decorated().remove(key);\n         if (isEmpty()) {\n             return \"{}\";\n         }\n-        StringBuilder buf = new StringBuilder();\n+        final StringBuilder buf = new StringBuilder();\n         buf.append('{');\n         boolean first = true;\n-        for (Map.Entry<K, V> entry : entrySet()) {\n-            K key = entry.getKey();\n-            V value = entry.getValue();\n+        for (final Map.Entry<K, V> entry : entrySet()) {\n+            final K key = entry.getKey();\n+            final V value = entry.getValue();\n             if (first) {\n                 first = false;\n             } else {\n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public K get(int index) {\n+    public K get(final int index) {\n         return insertOrder.get(index);\n     }\n     \n      * @return the key at the specified index\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public V getValue(int index) {\n+    public V getValue(final int index) {\n         return get(insertOrder.get(index));\n     }\n     \n      * @param key  the key to find the index of\n      * @return the index, or -1 if not found\n      */\n-    public int indexOf(Object key) {\n+    public int indexOf(final Object key) {\n         return insertOrder.indexOf(key);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is invalid\n      * @since 3.2\n      */\n-    public V setValue(int index, V value) {\n-        K key = insertOrder.get(index);\n+    public V setValue(final int index, final V value) {\n+        final K key = insertOrder.get(index);\n         return put(key, value);\n     }\n \n      * @throws IndexOutOfBoundsException if the index is out of range\n      * @since 3.2\n      */\n-    public V put(int index, K key, V value) {\n-        Map<K, V> m = decorated();\n+    public V put(int index, final K key, final V value) {\n+        final Map<K, V> m = decorated();\n         if (m.containsKey(key)) {\n-            V result = m.remove(key);\n-            int pos = insertOrder.indexOf(key);\n+            final V result = m.remove(key);\n+            final int pos = insertOrder.indexOf(key);\n             insertOrder.remove(pos);\n             if (pos < index) {\n                 index--;\n      * @return the removed value, or <code>null</code> if none existed\n      * @throws IndexOutOfBoundsException if the index is invalid\n      */\n-    public V remove(int index) {\n+    public V remove(final int index) {\n         return remove(get(index));\n     }\n \n         private final ListOrderedMap<Object, V> parent;\n \n         @SuppressWarnings(\"unchecked\")\n-        ValuesView(ListOrderedMap<?, V> parent) {\n+        ValuesView(final ListOrderedMap<?, V> parent) {\n             super();\n             this.parent = (ListOrderedMap<Object, V>) parent;\n         }\n         }\n \n         @Override\n-        public boolean contains(Object value) {\n+        public boolean contains(final Object value) {\n             return this.parent.containsValue(value);\n         }\n \n         }\n \n         @Override\n-        public V get(int index) {\n+        public V get(final int index) {\n             return this.parent.getValue(index);\n         }\n \n         @Override\n-        public V set(int index, V value) {\n+        public V set(final int index, final V value) {\n             return this.parent.setValue(index, value);\n         }\n \n         @Override\n-        public V remove(int index) {\n+        public V remove(final int index) {\n             return this.parent.remove(index);\n         }\n     }\n         private final ListOrderedMap<K, Object> parent;\n \n         @SuppressWarnings(\"unchecked\")\n-        KeySetView(ListOrderedMap<K, ?> parent) {\n+        KeySetView(final ListOrderedMap<K, ?> parent) {\n             super();\n             this.parent = (ListOrderedMap<K, Object>) parent;\n         }\n         }\n \n         @Override\n-        public boolean contains(Object value) {\n+        public boolean contains(final Object value) {\n             return this.parent.containsKey(value);\n         }\n \n         private final List<K> insertOrder;\n         private Set<Map.Entry<K, V>> entrySet;\n \n-        public EntrySetView(ListOrderedMap<K, V> parent, List<K> insertOrder) {\n+        public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n             super();\n             this.parent = parent;\n             this.insertOrder = insertOrder;\n         }\n \n         @Override\n-        public boolean contains(Object obj) {\n+        public boolean contains(final Object obj) {\n             return getEntrySet().contains(obj);\n         }\n \n         @Override\n-        public boolean containsAll(Collection<?> coll) {\n+        public boolean containsAll(final Collection<?> coll) {\n             return getEntrySet().containsAll(coll);\n         }\n \n         @Override\n         @SuppressWarnings(\"unchecked\")\n-        public boolean remove(Object obj) {\n+        public boolean remove(final Object obj) {\n             if (obj instanceof Map.Entry == false) {\n                 return false;\n             }\n             if (getEntrySet().contains(obj)) {\n-                Object key = ((Map.Entry<K, V>) obj).getKey();\n+                final Object key = ((Map.Entry<K, V>) obj).getKey();\n                 parent.remove(key);\n                 return true;\n             }\n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n         private final ListOrderedMap<K, V> parent;\n         private K last = null;\n         \n-        ListOrderedIterator(ListOrderedMap<K, V> parent, List<K> insertOrder) {\n+        ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n             super(insertOrder.iterator());\n             this.parent = parent;\n         }\n     static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n         private final ListOrderedMap<K, V> parent;\n \n-        ListOrderedMapEntry(ListOrderedMap<K, V> parent, K key) {\n+        ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n             super(key, null);\n             this.parent = parent;\n         }\n         }\n \n         @Override\n-        public V setValue(V value) {\n+        public V setValue(final V value) {\n             return parent.decorated().put(key, value);\n         }\n     }\n         private K last = null;\n         private boolean readable = false;\n \n-        ListOrderedMapIterator(ListOrderedMap<K, V> parent) {\n+        ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n             super();\n             this.parent = parent;\n             this.iterator = parent.insertOrder.listIterator();\n             return parent.get(last);\n         }\n \n-        public V setValue(V value) {\n+        public V setValue(final V value) {\n             if (readable == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n--- a/src/main/java/org/apache/commons/collections/map/MultiKeyMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/MultiKeyMap.java\n      * @return a new multi key map\n      * @throws IllegalArgumentException if the map is null or not empty\n      */\n-    public static <K, V> MultiKeyMap<K, V> multiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+    public static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n      *\n      * @param map  the map to decorate\n      */\n-    protected MultiKeyMap(AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+    protected MultiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n         super(map);\n         this.map = map;\n     }\n      * @param key2  the second key\n      * @return the mapped value, null if no match\n      */\n-    public V get(Object key1, Object key2) {\n-        int hashCode = hash(key1, key2);\n+    public V get(final Object key1, final Object key2) {\n+        final int hashCode = hash(key1, key2);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param key2  the second key\n      * @return true if the map contains the key\n      */\n-    public boolean containsKey(Object key1, Object key2) {\n-        int hashCode = hash(key1, key2);\n+    public boolean containsKey(final Object key1, final Object key2) {\n+        final int hashCode = hash(key1, key2);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public V put(K key1, K key2, V value) {\n-        int hashCode = hash(key1, key2);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V put(final K key1, final K key2, final V value) {\n+        final int hashCode = hash(key1, key2);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n      * @param key2  the second key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public V remove(Object key1, Object key2) {\n-        int hashCode = hash(key1, key2);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V remove(final Object key1, final Object key2) {\n+        final int hashCode = hash(key1, key2);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n      * @param key2  the second key\n      * @return the hash code\n      */\n-    protected int hash(Object key1, Object key2) {\n+    protected int hash(final Object key1, final Object key2) {\n         int h = 0;\n         if (key1 != null) {\n             h ^= key1.hashCode();\n      * @param key2  the second key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n-            Object key1, Object key2) {\n-        MultiKey<? extends K> multi = entry.getKey();\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            final Object key1, final Object key2) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 2 &&\n             (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n      * @param key3  the third key\n      * @return the mapped value, null if no match\n      */\n-    public V get(Object key1, Object key2, Object key3) {\n-        int hashCode = hash(key1, key2, key3);\n+    public V get(final Object key1, final Object key2, final Object key3) {\n+        final int hashCode = hash(key1, key2, key3);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param key3  the third key\n      * @return true if the map contains the key\n      */\n-    public boolean containsKey(Object key1, Object key2, Object key3) {\n-        int hashCode = hash(key1, key2, key3);\n+    public boolean containsKey(final Object key1, final Object key2, final Object key3) {\n+        final int hashCode = hash(key1, key2, key3);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public V put(K key1, K key2, K key3, V value) {\n-        int hashCode = hash(key1, key2, key3);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V put(final K key1, final K key2, final K key3, final V value) {\n+        final int hashCode = hash(key1, key2, key3);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n      * @param key3  the third key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public V remove(Object key1, Object key2, Object key3) {\n-        int hashCode = hash(key1, key2, key3);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V remove(final Object key1, final Object key2, final Object key3) {\n+        final int hashCode = hash(key1, key2, key3);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n      * @param key3  the third key\n      * @return the hash code\n      */\n-    protected int hash(Object key1, Object key2, Object key3) {\n+    protected int hash(final Object key1, final Object key2, final Object key3) {\n         int h = 0;\n         if (key1 != null) {\n             h ^= key1.hashCode();\n      * @param key3  the third key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n-                                 Object key1, Object key2, Object key3) {\n-        MultiKey<? extends K> multi = entry.getKey();\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+                                 final Object key1, final Object key2, final Object key3) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 3 &&\n             (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n      * @param key4  the fourth key\n      * @return the mapped value, null if no match\n      */\n-    public V get(Object key1, Object key2, Object key3, Object key4) {\n-        int hashCode = hash(key1, key2, key3, key4);\n+    public V get(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param key4  the fourth key\n      * @return true if the map contains the key\n      */\n-    public boolean containsKey(Object key1, Object key2, Object key3, Object key4) {\n-        int hashCode = hash(key1, key2, key3, key4);\n+    public boolean containsKey(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public V put(K key1, K key2, K key3, K key4, V value) {\n-        int hashCode = hash(key1, key2, key3, key4);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V put(final K key1, final K key2, final K key3, final K key4, final V value) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n      * @param key4  the fourth key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public V remove(Object key1, Object key2, Object key3, Object key4) {\n-        int hashCode = hash(key1, key2, key3, key4);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V remove(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n      * @param key4  the fourth key\n      * @return the hash code\n      */\n-    protected int hash(Object key1, Object key2, Object key3, Object key4) {\n+    protected int hash(final Object key1, final Object key2, final Object key3, final Object key4) {\n         int h = 0;\n         if (key1 != null) {\n             h ^= key1.hashCode();\n      * @param key4  the fourth key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n-                                 Object key1, Object key2, Object key3, Object key4) {\n-        MultiKey<? extends K> multi = entry.getKey();\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+                                 final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 4 &&\n             (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n      * @param key5  the fifth key\n      * @return the mapped value, null if no match\n      */\n-    public V get(Object key1, Object key2, Object key3, Object key4, Object key5) {\n-        int hashCode = hash(key1, key2, key3, key4, key5);\n+    public V get(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param key5  the fifth key\n      * @return true if the map contains the key\n      */\n-    public boolean containsKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n-        int hashCode = hash(key1, key2, key3, key4, key5);\n+    public boolean containsKey(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n         while (entry != null) {\n      * @param value  the value to store\n      * @return the value previously mapped to this combined key, null if none\n      */\n-    public V put(K key1, K key2, K key3, K key4, K key5, V value) {\n-        int hashCode = hash(key1, key2, key3, key4, key5);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V put(final K key1, final K key2, final K key3, final K key4, final K key5, final V value) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().updateEntry(entry, value);\n                 return oldValue;\n             }\n      * @param key5  the fifth key\n      * @return the value mapped to the removed key, null if key not in map\n      */\n-    public V remove(Object key1, Object key2, Object key3, Object key4, Object key5) {\n-        int hashCode = hash(key1, key2, key3, key4, key5);\n-        int index = decorated().hashIndex(hashCode, decorated().data.length);\n+    public V remove(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n-                V oldValue = entry.getValue();\n+                final V oldValue = entry.getValue();\n                 decorated().removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n      * @param key5  the fifth key\n      * @return the hash code\n      */\n-    protected int hash(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+    protected int hash(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n         int h = 0;\n         if (key1 != null) {\n             h ^= key1.hashCode();\n      * @param key5  the fifth key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n-            Object key1, Object key2, Object key3, Object key4, Object key5) {\n-        MultiKey<? extends K> multi = entry.getKey();\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n         return\n             multi.size() == 5 &&\n             (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n      * @param key1  the first key\n      * @return true if any elements were removed\n      */\n-    public boolean removeAll(Object key1) {\n+    public boolean removeAll(final Object key1) {\n         boolean modified = false;\n-        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey<? extends K> multi = it.next();\n+            final MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 1 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {\n                 it.remove();\n      * @param key2  the second key\n      * @return true if any elements were removed\n      */\n-    public boolean removeAll(Object key1, Object key2) {\n+    public boolean removeAll(final Object key1, final Object key2) {\n         boolean modified = false;\n-        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey<? extends K> multi = it.next();\n+            final MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 2 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                 (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {\n      * @param key3  the third key\n      * @return true if any elements were removed\n      */\n-    public boolean removeAll(Object key1, Object key2, Object key3) {\n+    public boolean removeAll(final Object key1, final Object key2, final Object key3) {\n         boolean modified = false;\n-        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey<? extends K> multi = it.next();\n+            final MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 3 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                 (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n      * @param key4  the fourth key\n      * @return true if any elements were removed\n      */\n-    public boolean removeAll(Object key1, Object key2, Object key3, Object key4) {\n+    public boolean removeAll(final Object key1, final Object key2, final Object key3, final Object key4) {\n         boolean modified = false;\n-        MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n         while (it.hasNext()) {\n-            MultiKey<? extends K> multi = it.next();\n+            final MultiKey<? extends K> multi = it.next();\n             if (multi.size() >= 4 &&\n                 (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n                 (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n      * \n      * @param key  the key to check\n      */\n-    protected void checkKey(MultiKey<?> key) {\n+    protected void checkKey(final MultiKey<?> key) {\n         if (key == null) {\n             throw new NullPointerException(\"Key must not be null\");\n         }\n      * @throws ClassCastException if the key is not a MultiKey\n      */\n     @Override\n-    public V put(MultiKey<? extends K> key, V value) {\n+    public V put(final MultiKey<? extends K> key, final V value) {\n         checkKey(key);\n         return super.put(key, value);\n     }\n      * @throws ClassCastException if any key in mapToCopy is not a MultiKey\n      */\n     @Override\n-    public void putAll(Map<? extends MultiKey<? extends K>, ? extends V> mapToCopy) {\n-        for (MultiKey<? extends K> key : mapToCopy.keySet()) {\n+    public void putAll(final Map<? extends MultiKey<? extends K>, ? extends V> mapToCopy) {\n+        for (final MultiKey<? extends K> key : mapToCopy.keySet()) {\n             checkKey(key);\n         }\n         super.putAll(mapToCopy);\n--- a/src/main/java/org/apache/commons/collections/map/MultiValueMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/MultiValueMap.java\n      * @return a new multi-value map\n      */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-    public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n         return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n     }\n \n      * @param collectionClass  the type of the collection class\n      * @return a new multi-value map\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map,\n-                                                                                    Class<C> collectionClass) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n+                                                                                    final Class<C> collectionClass) {\n         return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n     }\n \n      * @param collectionFactory  the collection factory (must return a Collection object).\n      * @return a new multi-value map\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, ? super C> map,\n-                                                                                    Factory<C> collectionFactory) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n+                                                                                    final Factory<C> collectionFactory) {\n         return new MultiValueMap<K, V>(map, collectionFactory);\n     }\n \n      * @param collectionFactory  the collection factory which must return a Collection instance\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected <C extends Collection<V>> MultiValueMap(Map<K, ? super C> map, Factory<C> collectionFactory) {\n+    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map, final Factory<C> collectionFactory) {\n         super((Map<K, Object>) map);\n         if (collectionFactory == null) {\n             throw new IllegalArgumentException(\"The factory must not be null\");\n      * @throws IOException\n      * @since 3.3\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.3\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, Object>) in.readObject(); // (1)\n     }\n      * @return the value removed (which was passed in), null if nothing removed\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public V remove(Object key, Object value) {\n-        Collection<V> valuesForKey = getCollection(key);\n+    public V remove(final Object key, final Object value) {\n+        final Collection<V> valuesForKey = getCollection(key);\n         if (valuesForKey == null) {\n             return null;\n         }\n-        boolean removed = valuesForKey.remove(value);\n+        final boolean removed = valuesForKey.remove(value);\n         if (removed == false) {\n             return null;\n         }\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public boolean containsValue(Object value) {\n-        Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n+    public boolean containsValue(final Object value) {\n+        final Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n         if (pairs != null) {\n-            for (Map.Entry<K, Object> entry : pairs) {\n+            for (final Map.Entry<K, Object> entry : pairs) {\n                 if (((Collection<V>) entry.getValue()).contains(value)) {\n                     return true;\n                 }\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Object put(K key, Object value) {\n+    public Object put(final K key, final Object value) {\n         boolean result = false;\n         Collection<V> coll = getCollection(key);\n         if (coll == null) {\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public void putAll(Map<? extends K, ?> map) {\n+    public void putAll(final Map<? extends K, ?> map) {\n         if (map instanceof MultiMap) {\n-            for (Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n+            for (final Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n                 putAll(entry.getKey(), (Collection<V>) entry.getValue());\n             }\n         } else {\n-            for (Map.Entry<? extends K, ?> entry : map.entrySet()) {\n+            for (final Map.Entry<? extends K, ?> entry : map.entrySet()) {\n                 put(entry.getKey(), entry.getValue());\n             }\n         }\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Collection<Object> values() {\n-        Collection<V> vs = valuesView;\n+        final Collection<V> vs = valuesView;\n         return (Collection<Object>) (vs != null ? vs : (valuesView = new Values()));\n     }\n \n      * @param value  the value to search for\n      * @return true if the map contains the value\n      */\n-    public boolean containsValue(Object key, Object value) {\n-        Collection<V> coll = getCollection(key);\n+    public boolean containsValue(final Object key, final Object value) {\n+        final Collection<V> coll = getCollection(key);\n         if (coll == null) {\n             return false;\n         }\n      * @return the collection mapped to the key, null if no mapping\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public Collection<V> getCollection(Object key) {\n+    public Collection<V> getCollection(final Object key) {\n         return (Collection<V>) decorated().get(key);\n     }\n \n      * @param key  the key to get size for\n      * @return the size of the collection at the key, zero if key not in map\n      */\n-    public int size(Object key) {\n-        Collection<V> coll = getCollection(key);\n+    public int size(final Object key) {\n+        final Collection<V> coll = getCollection(key);\n         if (coll == null) {\n             return 0;\n         }\n      * @param values  the values to add to the collection at the key, null ignored\n      * @return true if this map changed\n      */\n-    public boolean putAll(K key, Collection<V> values) {\n+    public boolean putAll(final K key, final Collection<V> values) {\n         if (values == null || values.size() == 0) {\n             return false;\n         }\n      * @param key  the key to get an iterator for\n      * @return the iterator of the collection at the key, empty iterator if key not in map\n      */\n-    public Iterator<V> iterator(Object key) {\n+    public Iterator<V> iterator(final Object key) {\n         if (!containsKey(key)) {\n             return EmptyIterator.<V>emptyIterator();\n         }\n      */\n     public int totalSize() {\n         int total = 0;\n-        for (Object v : decorated().values()) {\n+        for (final Object v : decorated().values()) {\n             total += CollectionUtils.size(v);\n         }\n         return total;\n      * @param size  the collection size that is about to be added\n      * @return the new collection\n      */\n-    protected Collection<V> createCollection(int size) {\n+    protected Collection<V> createCollection(final int size) {\n         return collectionFactory.create();\n     }\n \n         @Override\n         public Iterator<V> iterator() {\n             final IteratorChain<V> chain = new IteratorChain<V>();\n-            for (K k : keySet()) {\n+            for (final K k : keySet()) {\n                 chain.addIterator(new ValuesIterator(k));\n             }\n             return chain;\n         private final Collection<V> values;\n         private final Iterator<V> iterator;\n \n-        public ValuesIterator(Object key) {\n+        public ValuesIterator(final Object key) {\n             this.key = key;\n             this.values = getCollection(key);\n             this.iterator = values.iterator();\n \n         private final Class<T> clazz;\n \n-        public ReflectionFactory(Class<T> clazz) {\n+        public ReflectionFactory(final Class<T> clazz) {\n             this.clazz = clazz;\n         }\n \n         public T create() {\n             try {\n                 return clazz.newInstance();\n-            } catch (Exception ex) {\n+            } catch (final Exception ex) {\n                 throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n             }\n         }\n--- a/src/main/java/org/apache/commons/collections/map/PassiveExpiringMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PassiveExpiringMap.java\n          *        results in entries that NEVER expire. A zero value results in\n          *        entries that ALWAYS expire.\n          */\n-        public ConstantTimeToLiveExpirationPolicy(long timeToLiveMillis) {\n+        public ConstantTimeToLiveExpirationPolicy(final long timeToLiveMillis) {\n             super();\n             this.timeToLiveMillis = timeToLiveMillis;\n         }\n          *        parameter, must not be null.\n          * @throws IllegalArgumentException if the time unit is null.\n          */\n-        public ConstantTimeToLiveExpirationPolicy(long timeToLive,\n-                                                  TimeUnit timeUnit) {\n+        public ConstantTimeToLiveExpirationPolicy(final long timeToLive,\n+                                                  final TimeUnit timeUnit) {\n             this(validateAndConvertToMillis(timeToLive, TimeUnit.MILLISECONDS));\n         }\n \n          *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n          *         is returned indicating the entry never expires.\n          */\n-        public long expirationTime(K key, V value) {\n+        public long expirationTime(final K key, final V value) {\n             if (timeToLiveMillis >= 0L) {\n                 // avoid numerical overflow\n-                long now = System.currentTimeMillis();\n+                final long now = System.currentTimeMillis();\n                 if (now > Long.MAX_VALUE - timeToLiveMillis) {\n                     // expiration would be greater than Long.MAX_VALUE\n                     // never expire\n      *        parameter, must not be null.\n      * @throws IllegalArgumentException if the time unit is null.\n      */\n-    private static long validateAndConvertToMillis(long timeToLive,\n-                                                   TimeUnit timeUnit) {\n+    private static long validateAndConvertToMillis(final long timeToLive,\n+                                                   final TimeUnit timeUnit) {\n         if (timeUnit == null) {\n             throw new IllegalArgumentException(\"Time unit must not be null\");\n         }\n      * @param expiringPolicy the policy used to determine expiration times of\n      *        entries as they are added.\n      */\n-    public PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy) {\n+    public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy) {\n         this(expiringPolicy, new HashMap<K, V>());\n     }\n \n      * @param map the map to decorate, must not be null.\n      * @throws IllegalArgumentException if the map is null.\n      */\n-    public PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy,\n-                              Map<K, V> map) {\n+    public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy,\n+                              final Map<K, V> map) {\n         super(map);\n         if (expiringPolicy == null) {\n             throw new IllegalArgumentException(\"Policy must not be null.\");\n      *        entries that NEVER expire. A zero value results in entries that\n      *        ALWAYS expire.\n      */\n-    public PassiveExpiringMap(long timeToLiveMillis) {\n+    public PassiveExpiringMap(final long timeToLiveMillis) {\n         this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n              new HashMap<K, V>());\n     }\n      * @param map the map to decorate, must not be null.\n      * @throws IllegalArgumentException if the map is null.\n      */\n-    public PassiveExpiringMap(long timeToLiveMillis, Map<K, V> map) {\n+    public PassiveExpiringMap(final long timeToLiveMillis, final Map<K, V> map) {\n         this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n              map);\n     }\n      *        parameter, must not be null.\n      * @throws IllegalArgumentException if the time unit is null.\n      */\n-    public PassiveExpiringMap(long timeToLive, TimeUnit timeUnit) {\n+    public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit) {\n         this(validateAndConvertToMillis(timeToLive, timeUnit));\n     }\n \n      * @param map the map to decorate, must not be null.\n      * @throws IllegalArgumentException if the map is null.\n      */\n-    public PassiveExpiringMap(long timeToLive, TimeUnit timeUnit, Map<K, V> map) {\n+    public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit, final Map<K, V> map) {\n         this(validateAndConvertToMillis(timeToLive, timeUnit), map);\n     }\n \n      * @param map the map to decorate, must not be null.\n      * @throws IllegalArgumentException if the map is null.\n      */\n-    public PassiveExpiringMap(Map<K, V> map) {\n+    public PassiveExpiringMap(final Map<K, V> map) {\n         this(-1L, map);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         removeIfExpired(key, now());\n         return super.containsKey(key);\n     }\n      * {@inheritDoc}\n      */\n     @Override\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         removeAllExpired(now());\n         return super.containsValue(value);\n     }\n      * {@inheritDoc}\n      */\n     @Override\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         removeIfExpired(key, now());\n         return super.get(key);\n     }\n      *         and <code>expirationTimeObject</code> &lt; <code>now</code>.\n      *         <code>false</code> otherwise.\n      */\n-    private boolean isExpired(long now, Long expirationTimeObject) {\n+    private boolean isExpired(final long now, final Long expirationTimeObject) {\n         if (expirationTimeObject != null) {\n-            long expirationTime = expirationTimeObject.longValue();\n+            final long expirationTime = expirationTimeObject.longValue();\n             return expirationTime >= 0 && now >= expirationTime;\n         }\n         return false;\n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         return put(key, value, now());\n     }\n \n      * Add the given key-value pair to this map as well as recording the entry's expiration time based on\n      * the current time in milliseconds, <code>now</code> and this map's {@link #expiringPolicy}.\n      */\n-    private V put(K key, V value, long now) {\n+    private V put(final K key, final V value, final long now) {\n         // record expiration time of new entry\n-        long expirationTime = expiringPolicy.expirationTime(key, value);\n+        final long expirationTime = expiringPolicy.expirationTime(key, value);\n         expirationMap.put(key, Long.valueOf(expirationTime));\n \n         return super.put(key, value);\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n-        for (Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n      * {@inheritDoc}\n      */\n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         expirationMap.remove(key);\n         return super.remove(key);\n     }\n      * \n      * @see #isExpired(long, Long)\n      */\n-    private void removeAllExpired(long now) {\n-        Iterator<Map.Entry<Object, Long>> iter = expirationMap.entrySet()\n+    private void removeAllExpired(final long now) {\n+        final Iterator<Map.Entry<Object, Long>> iter = expirationMap.entrySet()\n             .iterator();\n         while (iter.hasNext()) {\n-            Map.Entry<Object, Long> expirationEntry = iter.next();\n+            final Map.Entry<Object, Long> expirationEntry = iter.next();\n             if (isExpired(now, expirationEntry.getValue())) {\n                 // remove entry from collection\n                 super.remove(expirationEntry.getKey());\n      * less than <code>now</code>. If the entry has a negative expiration time,\n      * the entry is never removed.\n      */\n-    private void removeIfExpired(Object key, long now) {\n-        Long expirationTimeObject = expirationMap.get(key);\n+    private void removeIfExpired(final Object key, final long now) {\n+        final Long expirationTimeObject = expirationMap.get(key);\n         if (isExpired(now, expirationTimeObject)) {\n             remove(key);\n         }\n      */\n     @SuppressWarnings(\"unchecked\")\n     // (1) should only fail if input stream is incorrect\n-    private void readObject(ObjectInputStream in)\n+    private void readObject(final ObjectInputStream in)\n         throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n      * @param out the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out)\n+    private void writeObject(final ObjectOutputStream out)\n         throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n--- a/src/main/java/org/apache/commons/collections/map/PredicatedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PredicatedMap.java\n      * @return a new predicated map\n      * @throws IllegalArgumentException if the map is null\n      */\n-    public static <K, V> PredicatedMap<K, V> predicatedMap(Map<K, V> map,\n-                                                           Predicate<? super K> keyPredicate,\n-                                                           Predicate<? super V> valuePredicate) {\n+    public static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map,\n+                                                           final Predicate<? super K> keyPredicate,\n+                                                           final Predicate<? super V> valuePredicate) {\n         return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @throws IllegalArgumentException if the map is null\n      */\n-    protected PredicatedMap(Map<K, V> map, Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n+    protected PredicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n         super(map);\n         this.keyPredicate = keyPredicate;\n         this.valuePredicate = valuePredicate;\n         \n-        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n         while (it.hasNext()) {\n-            Map.Entry<K, V> entry = it.next();\n+            final Map.Entry<K, V> entry = it.next();\n             validate(entry.getKey(), entry.getValue());\n         }\n     }\n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     }\n      * @param value  the value to validate\n      * @throws IllegalArgumentException if invalid\n      */\n-    protected void validate(K key, V value) {\n+    protected void validate(final K key, final V value) {\n         if (keyPredicate != null && keyPredicate.evaluate(key) == false) {\n             throw new IllegalArgumentException(\"Cannot add key - Predicate rejected it\");\n         }\n      * @since 3.1\n      */\n     @Override\n-    protected V checkSetValue(V value) {\n+    protected V checkSetValue(final V value) {\n         if (valuePredicate.evaluate(value) == false) {\n             throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n         }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         validate(key, value);\n         return map.put(key, value);\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n-        for (Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n             validate(entry.getKey(), entry.getValue());\n         }\n         super.putAll(mapToCopy);\n--- a/src/main/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PredicatedSortedMap.java\n      * @return a new predicated sorted map\n      * @throws IllegalArgumentException if the map is null\n      */\n-    public static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n-            Predicate<? super K> keyPredicate, Predicate<? super V> valuePredicate) {\n+    public static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n+            final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n         return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @throws IllegalArgumentException if the map is null\n      */\n-    protected PredicatedSortedMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n-            Predicate<? super V> valuePredicate) {\n+    protected PredicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,\n+            final Predicate<? super V> valuePredicate) {\n         super(map, keyPredicate, valuePredicate);\n     }\n \n         return getSortedMap().comparator();\n     }\n \n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n-        SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n         return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n-    public SortedMap<K, V> headMap(K toKey) {\n-        SortedMap<K, V> map = getSortedMap().headMap(toKey);\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().headMap(toKey);\n         return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n-    public SortedMap<K, V> tailMap(K fromKey) {\n-        SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n         return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n      *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      */\n-    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n     }\n \n      * @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n-            boolean purgeValues) {\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n+            final boolean purgeValues) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n     }\n \n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      */\n-    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n-            int capacity, float loadFactor) {\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n+            final int capacity, final float loadFactor) {\n         super(keyType, valueType, capacity, loadFactor, false);\n     }\n \n      * @param purgeValues  should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceIdentityMap(ReferenceStrength keyType, ReferenceStrength valueType,\n-            int capacity, float loadFactor, boolean purgeValues) {\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n+            final int capacity, final float loadFactor, final boolean purgeValues) {\n         super(keyType, valueType, capacity, loadFactor, purgeValues);\n     }\n \n      * @return the hash code\n      */\n     @Override\n-    protected int hash(Object key) {\n+    protected int hash(final Object key) {\n         return System.identityHashCode(key);\n     }\n \n      * @return the hash code, as per the MapEntry specification\n      */\n     @Override\n-    protected int hashEntry(Object key, Object value) {\n+    protected int hashEntry(final Object key, final Object value) {\n         return System.identityHashCode(key) ^\n                System.identityHashCode(value);\n     }\n      * @return true if equal by identity\n      */\n     @Override\n-    protected boolean isEqualKey(Object key1, Object key2) {\n+    protected boolean isEqualKey(final Object key1, Object key2) {\n         key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<?>) key2).get();\n         return key1 == key2;\n     }\n      * @return true if equal by identity\n      */\n     @Override\n-    protected boolean isEqualValue(Object value1, Object value2) {\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n         return value1 == value2;\n     }\n \n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Read the map in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n--- a/src/main/java/org/apache/commons/collections/map/ReferenceMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/ReferenceMap.java\n      *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n      *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n      */\n-    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType) {\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n     }\n \n      * @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, boolean purgeValues) {\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final boolean purgeValues) {\n         super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n     }\n \n      * @param capacity  the initial capacity for the map\n      * @param loadFactor  the load factor for the map\n      */\n-    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n-            float loadFactor) {\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n+            final float loadFactor) {\n         super(keyType, valueType, capacity, loadFactor, false);\n     }\n \n      * @param purgeValues  should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceMap(ReferenceStrength keyType, ReferenceStrength valueType, int capacity,\n-            float loadFactor, boolean purgeValues) {\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n+            final float loadFactor, final boolean purgeValues) {\n         super(keyType, valueType, capacity, loadFactor, purgeValues);\n     }\n \n     /**\n      * Write the map out using a custom routine.\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         doWriteObject(out);\n     }\n     /**\n      * Read the map in using a custom routine.\n      */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         doReadObject(in);\n     }\n--- a/src/main/java/org/apache/commons/collections/map/SingletonMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/SingletonMap.java\n      * @param key  the key to use\n      * @param value  the value to use\n      */\n-    public SingletonMap(K key, V value) {\n+    public SingletonMap(final K key, final V value) {\n         super();\n         this.key = key;\n         this.value = value;\n      *\n      * @param keyValue  the key value pair to use\n      */\n-    public SingletonMap(KeyValue<K, V> keyValue) {\n+    public SingletonMap(final KeyValue<K, V> keyValue) {\n         super();\n         this.key = keyValue.getKey();\n         this.value = keyValue.getValue();\n      *\n      * @param mapEntry  the mapEntry to use\n      */\n-    public SingletonMap(Map.Entry<K, V> mapEntry) {\n+    public SingletonMap(final Map.Entry<K, V> mapEntry) {\n         super();\n         this.key = mapEntry.getKey();\n         this.value = mapEntry.getValue();\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if the size is not 1\n      */\n-    public SingletonMap(Map<K, V> map) {\n+    public SingletonMap(final Map<K, V> map) {\n         super();\n         if (map.size() != 1) {\n             throw new IllegalArgumentException(\"The map size must be 1\");\n         }\n-        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n         this.key = entry.getKey();\n         this.value = entry.getValue();\n     }\n      * @param value  the new value to set\n      * @return the old value\n      */\n-    public V setValue(V value) {\n-        V old = this.value;\n+    public V setValue(final V value) {\n+        final V old = this.value;\n         this.value = value;\n         return old;\n     }\n      * @param key  the key\n      * @return the mapped value, null if no match\n      */\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         if (isEqualKey(key)) {\n             return value;\n         }\n      * @param key  the key to search for\n      * @return true if the map contains the key\n      */\n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         return isEqualKey(key);\n     }\n \n      * @param value  the value to search for\n      * @return true if the map contains the key\n      */\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         return isEqualValue(value);\n     }\n \n      * @return the value previously mapped to this key, null if none\n      * @throws IllegalArgumentException if the key does not match\n      */\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (isEqualKey(key)) {\n             return setValue(value);\n         }\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if the key does not match\n      */\n-    public void putAll(Map<? extends K, ? extends V> map) {\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n         switch (map.size()) {\n             case 0:\n                 return;\n \n             case 1:\n-                Map.Entry<? extends K, ? extends V> entry = map.entrySet().iterator().next();\n+                final Map.Entry<? extends K, ? extends V> entry = map.entrySet().iterator().next();\n                 put(entry.getKey(), entry.getValue());\n                 return;\n \n      * @return the value mapped to the removed key, null if key not in map\n      * @throws UnsupportedOperationException always\n      */\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n      * @return the entrySet view\n      */\n     public Set<Map.Entry<K, V>> entrySet() {\n-        Map.Entry<K, V> entry = new TiedMapEntry<K, V>(this, getKey());\n+        final Map.Entry<K, V> entry = new TiedMapEntry<K, V>(this, getKey());\n         return Collections.singleton(entry);\n     }\n     \n      * @param key  the next key\n      * @return null always\n      */\n-    public K nextKey(K key) {\n+    public K nextKey(final K key) {\n         return null;\n     }\n \n      * @param key  the next key\n      * @return null always\n      */\n-    public K previousKey(K key) {\n+    public K previousKey(final K key) {\n         return null;\n     }\n \n      * @param key  the key to compare\n      * @return true if equal\n      */\n-    protected boolean isEqualKey(Object key) {\n+    protected boolean isEqualKey(final Object key) {\n         return key == null ? getKey() == null : key.equals(getKey());\n     }\n \n      * @param value  the value to compare\n      * @return true if equal\n      */\n-    protected boolean isEqualValue(Object value) {\n+    protected boolean isEqualValue(final Object value) {\n         return value == null ? getValue() == null : value.equals(getValue());\n     }\n \n         private boolean hasNext = true;\n         private boolean canGetSet = false;\n         \n-        SingletonMapIterator(SingletonMap<K, V> parent) {\n+        SingletonMapIterator(final SingletonMap<K, V> parent) {\n             super();\n             this.parent = parent;\n         }\n             return parent.getValue();\n         }\n \n-        public V setValue(V value) {\n+        public V setValue(final V value) {\n             if (canGetSet == false) {\n                 throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n         private static final long serialVersionUID = -3689524741863047872L;\n         private final SingletonMap<?, V> parent;\n \n-        SingletonValues(SingletonMap<?, V> parent) {\n+        SingletonValues(final SingletonMap<?, V> parent) {\n             super();\n             this.parent = parent;\n         }\n             return false;\n         }\n         @Override\n-        public boolean contains(Object object) {\n+        public boolean contains(final Object object) {\n             return parent.containsValue(object);\n         }\n         @Override\n     public SingletonMap<K, V> clone() {\n         try {\n             return (SingletonMap<K, V>) super.clone();\n-        } catch (CloneNotSupportedException ex) {\n+        } catch (final CloneNotSupportedException ex) {\n             throw new InternalError();\n         }\n     }\n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map == false) {\n             return false;\n         }\n-        Map<?,?> other = (Map<?,?>) obj;\n+        final Map<?,?> other = (Map<?,?>) obj;\n         if (other.size() != 1) {\n             return false;\n         }\n-        Map.Entry<?,?> entry = other.entrySet().iterator().next();\n+        final Map.Entry<?,?> entry = other.entrySet().iterator().next();\n         return isEqualKey(entry.getKey()) && isEqualValue(entry.getValue());\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/StaticBucketMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/StaticBucketMap.java\n      * @param numBuckets  the number of buckets for this map\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public StaticBucketMap(int numBuckets) {\n+    public StaticBucketMap(final int numBuckets) {\n         int size = Math.max(17, numBuckets);\n \n         // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n      *   the number of buckets.\n      * </p>\n      */\n-    private final int getHash(Object key) {\n+    private final int getHash(final Object key) {\n         if (key == null) {\n             return 0;\n         }\n      * @return the associated value\n      */\n     public V get(final Object key) {\n-        int hash = getHash(key);\n+        final int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n             Node<K, V> n = buckets[hash];\n      * @return true if found\n      */\n     public boolean containsKey(final Object key) {\n-        int hash = getHash(key);\n+        final int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n             Node<K, V> n = buckets[hash];\n      * @return the previous mapping for the key\n      */\n     public V put(final K key, final V value) {\n-        int hash = getHash(key);\n+        final int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n             Node<K, V> n = buckets[hash];\n                 n = next;\n \n                 if (n.key == key || (n.key != null && n.key.equals(key))) {\n-                    V returnVal = n.value;\n+                    final V returnVal = n.value;\n                     n.value = value;\n                     return returnVal;\n                 }\n \n             // The key was not found in the current list of nodes, add it to the end\n             //  in a new node.\n-            Node<K, V> newNode = new Node<K, V>();\n+            final Node<K, V> newNode = new Node<K, V>();\n             newNode.key = key;\n             newNode.value = value;\n             n.next = newNode;\n      * @param key  the key to remove\n      * @return the previous value at this key\n      */\n-    public V remove(Object key) {\n-        int hash = getHash(key);\n+    public V remove(final Object key) {\n+        final int hash = getHash(key);\n \n         synchronized (locks[hash]) {\n             Node<K, V> n = buckets[hash];\n      * \n      * @param map  the map of entries to add\n      */\n-    public void putAll(Map<? extends K, ? extends V> map) {\n-        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n      */\n     public void clear() {\n         for (int i = 0; i < buckets.length; i++) {\n-            Lock lock = locks[i];\n+            final Lock lock = locks[i];\n             synchronized (lock) {\n                 buckets[i] = null;\n                 lock.size = 0;\n      * @return true if equal\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj == this) {\n             return true;\n         }\n         if (obj instanceof Map<?, ?> == false) {\n             return false;\n         }\n-        Map<?, ?> other = (Map<?, ?>) obj;\n+        final Map<?, ?> other = (Map<?, ?>) obj;\n         return entrySet().equals(other.entrySet());\n     }\n \n         }\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n                 return false;\n             }\n \n-            Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n+            final Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n             return (\n                 (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n                 (value == null ? e2.getValue() == null : value.equals(e2.getValue())));\n         }\n \n-        public V setValue(V obj) {\n-            V retVal = value;\n+        public V setValue(final V obj) {\n+            final V retVal = value;\n             value = obj;\n             return retVal;\n         }\n \n     //-----------------------------------------------------------------------\n     private class BaseIterator {\n-        private ArrayList<Map.Entry<K, V>> current = new ArrayList<Map.Entry<K,V>>();\n+        private final ArrayList<Map.Entry<K, V>> current = new ArrayList<Map.Entry<K,V>>();\n         private int bucket;\n         private Map.Entry<K, V> last;\n \n         }\n \n         @Override\n-        public boolean contains(Object obj) {\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            int hash = getHash(entry.getKey());\n+        public boolean contains(final Object obj) {\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final int hash = getHash(entry.getKey());\n             synchronized (locks[hash]) {\n                 for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                     if (n.equals(entry)) {\n         }\n \n         @Override\n-        public boolean remove(Object obj) {\n+        public boolean remove(final Object obj) {\n             if (obj instanceof Map.Entry<?, ?> == false) {\n                 return false;\n             }\n-            Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n-            int hash = getHash(entry.getKey());\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final int hash = getHash(entry.getKey());\n             synchronized (locks[hash]) {\n                 for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n                     if (n.equals(entry)) {\n         }\n \n         @Override\n-        public boolean contains(Object obj) {\n+        public boolean contains(final Object obj) {\n             return StaticBucketMap.this.containsKey(obj);\n         }\n \n         @Override\n-        public boolean remove(Object obj) {\n-            int hash = getHash(obj);\n+        public boolean remove(final Object obj) {\n+            final int hash = getHash(obj);\n             synchronized (locks[hash]) {\n                 for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n-                    Object k = n.getKey();\n+                    final Object k = n.getKey();\n                     if ((k == obj) || ((k != null) && k.equals(obj))) {\n                         StaticBucketMap.this.remove(k);\n                         return true;\n      *\n      *  @param r  the code to execute atomically\n      */\n-    public void atomic(Runnable r) {\n+    public void atomic(final Runnable r) {\n         if (r == null) {\n             throw new NullPointerException();\n         }\n         atomic(r, 0);\n     }\n \n-    private void atomic(Runnable r, int bucket) {\n+    private void atomic(final Runnable r, final int bucket) {\n         if (bucket >= buckets.length) {\n             r.run();\n             return;\n--- a/src/main/java/org/apache/commons/collections/map/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/TransformedMap.java\n      * @return a new transformed map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> TransformedMap<K, V> transformingMap(Map<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n+    public static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n         return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n     }\n \n      * @throws IllegalArgumentException if map is null\n      * @since 3.2\n      */\n-    public static <K, V> TransformedMap<K, V> transformedMap(Map<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n-        TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n+    public static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n         if (map.size() > 0) {\n-            Map<K, V> transformed = decorated.transformMap(map);\n+            final Map<K, V> transformed = decorated.transformMap(map);\n             decorated.clear();\n             decorated.decorated().putAll(transformed);  // avoids double transformation\n         }\n      * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected TransformedMap(Map<K, V> map, Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n+    protected TransformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n         super(map);\n         this.keyTransformer = keyTransformer;\n         this.valueTransformer = valueTransformer;\n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     }\n      * @param object  the object to transform\n      * @return the transformed object\n      */\n-    protected K transformKey(K object) {\n+    protected K transformKey(final K object) {\n         if (keyTransformer == null) {\n             return object;\n         }\n      * @param object  the object to transform\n      * @return the transformed object\n      */\n-    protected V transformValue(V object) {\n+    protected V transformValue(final V object) {\n         if (valueTransformer == null) {\n             return object;\n         }\n      * @return the transformed object\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected Map<K, V> transformMap(Map<? extends K, ? extends V> map) {\n+    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map) {\n         if (map.isEmpty()) {\n             return (Map<K, V>) map;\n         }\n-        Map<K, V> result = new LinkedMap<K, V>(map.size());\n-\n-        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n         }\n         return result;\n      * @since 3.1\n      */\n     @Override\n-    protected V checkSetValue(V value) {\n+    protected V checkSetValue(final V value) {\n         return valueTransformer.transform(value);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/TransformedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/TransformedSortedMap.java\n      * @return a new transformed sorted map\n      * @throws IllegalArgumentException if the map is null\n      */\n-    public static <K, V> TransformedSortedMap<K, V> transformingSortedMap(SortedMap<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n+    public static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n         return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n     }\n \n      * @throws IllegalArgumentException if map is null\n      * @since 3.2\n      */\n-    public static <K, V> TransformedSortedMap<K, V> transformedSortedMap(SortedMap<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n-        TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    public static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        final TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n         if (map.size() > 0) {\n-            Map<K, V> transformed = decorated.transformMap(map);\n+            final Map<K, V> transformed = decorated.transformMap(map);\n             decorated.clear();\n             decorated.decorated().putAll(transformed);  // avoids double transformation\n         }\n      * @param valueTransformer  the predicate to validate to values, null means no transformation\n      * @throws IllegalArgumentException if the map is null\n      */\n-    protected TransformedSortedMap(SortedMap<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer,\n-            Transformer<? super V, ? extends V> valueTransformer) {\n+    protected TransformedSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n         super(map, keyTransformer, valueTransformer);\n     }\n \n         return getSortedMap().comparator();\n     }\n \n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n-        SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n         return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n     }\n \n-    public SortedMap<K, V> headMap(K toKey) {\n-        SortedMap<K, V> map = getSortedMap().headMap(toKey);\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().headMap(toKey);\n         return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n     }\n \n-    public SortedMap<K, V> tailMap(K fromKey) {\n-        SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n         return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableEntrySet.java\n      * @return a new unmodifiable entry set\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(Set<Map.Entry<K, V>> set) {\n+    public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n         if (set instanceof Unmodifiable) {\n             return set;\n         }\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    private UnmodifiableEntrySet(Set<Map.Entry<K, V>> set) {\n+    private UnmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n         super(set);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public boolean add(Map.Entry<K, V> object) {\n+    public boolean add(final Map.Entry<K, V> object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends Map.Entry<K, V>> coll) {\n+    public boolean addAll(final Collection<? extends Map.Entry<K, V>> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Object[] toArray() {\n-        Object[] array = collection.toArray();\n+        final Object[] array = collection.toArray();\n         for (int i = 0; i < array.length; i++) {\n             array[i] = new UnmodifiableEntry((Map.Entry<K, V>) array[i]);\n         }\n     \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public <T> T[] toArray(T[] array) {\n+    public <T> T[] toArray(final T[] array) {\n         Object[] result = array;\n         if (array.length > 0) {\n             // we must create a new array to handle multi-threaded situations\n      */\n     private class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n \n-        protected UnmodifiableEntrySetIterator(Iterator<Map.Entry<K, V>> iterator) {\n+        protected UnmodifiableEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n             super(iterator);\n         }\n \n      */\n     private class UnmodifiableEntry extends AbstractMapEntryDecorator<K, V> {\n \n-        protected UnmodifiableEntry(Map.Entry<K, V> entry) {\n+        protected UnmodifiableEntry(final Map.Entry<K, V> entry) {\n             super(entry);\n         }\n \n         @Override\n-        public V setValue(V obj) {\n+        public V setValue(final V obj) {\n             throw new UnsupportedOperationException();\n         }\n     }\n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableMap.java\n      * @return a new unmodifiable map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n+    public static <K, V> Map<K, V> unmodifiableMap(final Map<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableMap(Map<K, V> map) {\n+    private UnmodifiableMap(final Map<K, V> map) {\n         super(map);\n     }\n \n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject();\n     }\n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public MapIterator<K, V> mapIterator() {\n         if (map instanceof IterableMap) {\n-            MapIterator<K, V> it = ((IterableMap<K, V>) map).mapIterator();\n+            final MapIterator<K, V> it = ((IterableMap<K, V>) map).mapIterator();\n             return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n         }\n-        MapIterator<K, V> it = new EntrySetMapIterator<K, V>(map);\n+        final MapIterator<K, V> it = new EntrySetMapIterator<K, V>(map);\n         return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        Set<Map.Entry<K, V>> set = super.entrySet();\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        Set<K> set = super.keySet();\n+        final Set<K> set = super.keySet();\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n-        Collection<V> coll = super.values();\n+        final Collection<V> coll = super.values();\n         return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableOrderedMap.java\n      * @return a new ordered map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(OrderedMap<K, V> map) {\n+    public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableOrderedMap(OrderedMap<K, V> map) {\n+    private UnmodifiableOrderedMap(final OrderedMap<K, V> map) {\n         super(map);\n     }\n \n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     }\n     //-----------------------------------------------------------------------\n     @Override\n     public OrderedMapIterator<K, V> mapIterator() {\n-        OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n         return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n     }\n \n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n     public Set<Map.Entry<K, V>> entrySet() {\n-        Set<Map.Entry<K, V>> set = super.entrySet();\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n         return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n     }\n \n     @Override\n     public Set<K> keySet() {\n-        Set<K> set = super.keySet();\n+        final Set<K> set = super.keySet();\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n \n     @Override\n     public Collection<V> values() {\n-        Collection<V> coll = super.values();\n+        final Collection<V> coll = super.values();\n         return UnmodifiableCollection.unmodifiableCollection(coll);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/UnmodifiableSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/UnmodifiableSortedMap.java\n      * @return a new unmodifiable sorted map\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, V> map) {\n         if (map instanceof Unmodifiable) {\n             return map;\n         }\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if map is null\n      */\n-    private UnmodifiableSortedMap(SortedMap<K, V> map) {\n+    private UnmodifiableSortedMap(final SortedMap<K, V> map) {\n         super(map);\n     }\n     \n      * @throws IOException\n      * @since 3.1\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(map);\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject();\n     }\n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return new UnmodifiableSortedMap<K, V>(decorated().subMap(fromKey, toKey));\n     }\n \n     @Override\n-    public SortedMap<K, V> headMap(K toKey) {\n+    public SortedMap<K, V> headMap(final K toKey) {\n         return new UnmodifiableSortedMap<K, V>(decorated().headMap(toKey));\n     }\n \n     @Override\n-    public SortedMap<K, V> tailMap(K fromKey) {\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n         return new UnmodifiableSortedMap<K, V>(decorated().tailMap(fromKey));\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/AbstractSerializableSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/set/AbstractSerializableSetDecorator.java\n      * @param set  the list to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected AbstractSerializableSetDecorator(Set<E> set) {\n+    protected AbstractSerializableSetDecorator(final Set<E> set) {\n         super(set);\n     }\n \n      * @param out  the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(collection);\n     }\n      * @throws ClassNotFoundException\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         collection = (Collection<E>) in.readObject();\n     }\n--- a/src/main/java/org/apache/commons/collections/set/AbstractSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/set/AbstractSetDecorator.java\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected AbstractSetDecorator(Set<E> set) {\n+    protected AbstractSetDecorator(final Set<E> set) {\n         super(set);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/AbstractSortedSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/set/AbstractSortedSetDecorator.java\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected AbstractSortedSetDecorator(Set<E> set) {\n+    protected AbstractSortedSetDecorator(final Set<E> set) {\n         super(set);\n     }\n \n     }\n \n     //-----------------------------------------------------------------------\n-    public SortedSet<E> subSet(E fromElement, E toElement) {\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n         return decorated().subSet(fromElement, toElement);\n     }\n \n-    public SortedSet<E> headSet(E toElement) {\n+    public SortedSet<E> headSet(final E toElement) {\n         return decorated().headSet(toElement);\n     }\n \n-    public SortedSet<E> tailSet(E fromElement) {\n+    public SortedSet<E> tailSet(final E fromElement) {\n         return decorated().tailSet(fromElement);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/CompositeSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/CompositeSet.java\n      *\n      * @param set  the initial set in the composite\n      */\n-    public CompositeSet(Set<E> set) {\n+    public CompositeSet(final Set<E> set) {\n         super(set);\n     }\n \n      * \n      * @param sets  the initial sets in the composite\n      */\n-    public CompositeSet(Set<E>... sets) {\n+    public CompositeSet(final Set<E>... sets) {\n         super(sets);\n     }\n \n      * @see SetMutator\n      */\n     @Override\n-    public synchronized void addComposited(Collection<E> c) {\n+    public synchronized void addComposited(final Collection<E> c) {\n         if (!(c instanceof Set)) {\n             throw new IllegalArgumentException(\"Collections added must implement java.util.Set\");\n         }\n \n-        for (Set<E> set : getCollections()) {\n-            Collection<E> intersects = CollectionUtils.intersection(set, c);\n+        for (final Set<E> set : getCollections()) {\n+            final Collection<E> intersects = CollectionUtils.intersection(set, c);\n             if (intersects.size() > 0) {\n                 if (this.mutator == null) {\n                     throw new UnsupportedOperationException(\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public synchronized void addComposited(Collection<E> c, Collection<E> d) {\n+    public synchronized void addComposited(final Collection<E> c, final Collection<E> d) {\n         if (!(c instanceof Set)) {\n             throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n         }\n      * @throws IllegalArgumentException if any of the collections in comps do not implement Set\n      */\n     @Override\n-    public synchronized void addComposited(Collection<E>[] comps) {\n+    public synchronized void addComposited(final Collection<E>[] comps) {\n         for (int i = comps.length - 1; i >= 0; --i) {\n             this.addComposited(comps[i]);\n         }\n      * @param mutator  the {@link CollectionMutator} to use for this composite\n      */\n     @Override\n-    public void setMutator(CollectionMutator<E> mutator) {\n+    public void setMutator(final CollectionMutator<E> mutator) {\n         super.setMutator(mutator);\n     }\n \n      * @return true if the object is removed, false otherwise\n      */\n     @Override\n-    public boolean remove(Object obj) {\n-        for (Set<? extends E> set : getCollections()) {\n+    public boolean remove(final Object obj) {\n+        for (final Set<? extends E> set : getCollections()) {\n             if (set.contains(obj)) {\n                 return set.remove(obj);\n             }\n      * @see Set#equals\n      */\n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         if (obj instanceof Set) {\n-            Set<?> set = (Set<?>) obj;\n+            final Set<?> set = (Set<?>) obj;\n             return set.containsAll(this) && set.size() == this.size();\n         }\n         return false;\n     @Override\n     public int hashCode() {\n         int code = 0;\n-        for (E e : this) {\n+        for (final E e : this) {\n             code += e == null ? 0 : e.hashCode();\n         }\n         return code;\n--- a/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java\n      * @throws IllegalArgumentException if either the set or list is not empty\n      * @since 3.1\n      */\n-    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set, List<E> list) {\n+    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n         if (set == null) {\n             throw new IllegalArgumentException(\"Set must not be null\");\n         }\n      * @return a new ordered set\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E> ListOrderedSet<E> listOrderedSet(Set<E> set) {\n+    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n         return new ListOrderedSet<E>(set);\n     }\n \n      * @return a new ordered set\n      * @throws IllegalArgumentException if list is null\n      */\n-    public static <E> ListOrderedSet<E> listOrderedSet(List<E> list) {\n+    public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n-        Set<E> set = new HashSet<E>(list);\n+        final Set<E> set = new HashSet<E>(list);\n         list.retainAll(set);\n \n         return new ListOrderedSet<E>(set, list);\n      * @param set the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected ListOrderedSet(Set<E> set) {\n+    protected ListOrderedSet(final Set<E> set) {\n         super(set);\n         setOrder = new ArrayList<E>(set);\n     }\n      * @param list the list to decorate, must not be null\n      * @throws IllegalArgumentException if set or list is null\n      */\n-    protected ListOrderedSet(Set<E> set, List<E> list) {\n+    protected ListOrderedSet(final Set<E> set, final List<E> list) {\n         super(set);\n         if (list == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n     }\n \n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         if (collection.add(object)) {\n             setOrder.add(object);\n             return true;\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         boolean result = false;\n-        for (E e : coll) {\n+        for (final E e : coll) {\n             result |= add(e);\n         }\n         return result;\n     }\n \n     @Override\n-    public boolean remove(Object object) {\n-        boolean result = collection.remove(object);\n+    public boolean remove(final Object object) {\n+        final boolean result = collection.remove(object);\n         if (result) {\n             setOrder.remove(object);\n         }\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         boolean result = false;\n-        for (Object name : coll) {\n+        for (final Object name : coll) {\n             result |= remove(name);\n         }\n         return result;\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n-        Set<Object> collectionRetainAll = new HashSet<Object>();\n-        for (Object next : coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n+        final Set<Object> collectionRetainAll = new HashSet<Object>();\n+        for (final Object next : coll) {\n             if (collection.contains(next)) {\n                 collectionRetainAll.add(next);\n             }\n         if (collectionRetainAll.size() == 0) {\n             clear();\n         } else {\n-            for (Iterator<E> it = iterator(); it.hasNext();) {\n+            for (final Iterator<E> it = iterator(); it.hasNext();) {\n                 if (!collectionRetainAll.contains(it.next())) {\n                     it.remove();\n                 }\n     }\n \n     @Override\n-    public <T> T[] toArray(T a[]) {\n+    public <T> T[] toArray(final T a[]) {\n         return setOrder.toArray(a);\n     }\n \n      * @return the element at position {@code index}\n      * @see List#get(int)\n      */\n-    public E get(int index) {\n+    public E get(final int index) {\n         return setOrder.get(index);\n     }\n \n      *         this ordered set does not contain this object\n      * @see List#indexOf(Object)\n      */\n-    public int indexOf(Object object) {\n+    public int indexOf(final Object object) {\n         return setOrder.indexOf(object);\n     }\n \n      * @param object the element to be inserted\n      * @see List#add(int, Object)\n      */\n-    public void add(int index, E object) {\n+    public void add(final int index, final E object) {\n         if (!contains(object)) {\n             collection.add(object);\n             setOrder.add(index, object);\n      * @return {@code true} if this ordered set changed as a result of the call\n      * @see List#addAll(int, Collection)\n      */\n-    public boolean addAll(int index, Collection<? extends E> coll) {\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n         boolean changed = false;\n         // collect all elements to be added for performance reasons\n         final List<E> toAdd = new ArrayList<E>();\n-        for (E e : coll) {\n+        for (final E e : coll) {\n             if (contains(e)) {\n                 continue;\n             }\n      * @return the element that has been remove from the ordered set\n      * @see List#remove(int)\n      */\n-    public Object remove(int index) {\n-        Object obj = setOrder.remove(index);\n+    public Object remove(final int index) {\n+        final Object obj = setOrder.remove(index);\n         remove(obj);\n         return obj;\n     }\n         /** Last object retrieved */\n         protected E last;\n \n-        private OrderedSetIterator(ListIterator<E> iterator, Collection<E> set) {\n+        private OrderedSetIterator(final ListIterator<E> iterator, final Collection<E> set) {\n             super(iterator);\n             this.set = set;\n         }\n--- a/src/main/java/org/apache/commons/collections/set/MapBackedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/MapBackedSet.java\n      * @return a new map backed set\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E, V> MapBackedSet<E, V> mapBackedSet(Map<E, ? super V> map) {\n+    public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n         return mapBackedSet(map, null);\n     }\n \n      * @return a new map backed set\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <E, V> MapBackedSet<E, V> mapBackedSet(Map<E, ? super V> map, V dummyValue) {\n+    public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"The map must not be null\");\n         }\n      * @param dummyValue  the dummy value to use\n      * @throws IllegalArgumentException if map is null\n      */\n-    private MapBackedSet(Map<E, ? super V> map, V dummyValue) {\n+    private MapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n         super();\n         this.map = map;\n         this.dummyValue = dummyValue;\n         return map.keySet().iterator();\n     }\n \n-    public boolean contains(Object obj) {\n+    public boolean contains(final Object obj) {\n         return map.containsKey(obj);\n     }\n \n-    public boolean containsAll(Collection<?> coll) {\n+    public boolean containsAll(final Collection<?> coll) {\n         return map.keySet().containsAll(coll);\n     }\n \n-    public boolean add(E obj) {\n-        int size = map.size();\n+    public boolean add(final E obj) {\n+        final int size = map.size();\n         map.put(obj, dummyValue);\n         return map.size() != size;\n     }\n \n-    public boolean addAll(Collection<? extends E> coll) {\n-        int size = map.size();\n-        for (E e : coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        final int size = map.size();\n+        for (final E e : coll) {\n             map.put(e, dummyValue);\n         }\n         return map.size() != size;\n     }\n \n-    public boolean remove(Object obj) {\n-        int size = map.size();\n+    public boolean remove(final Object obj) {\n+        final int size = map.size();\n         map.remove(obj);\n         return map.size() != size;\n     }\n \n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         return map.keySet().removeAll(coll);\n     }\n \n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         return map.keySet().retainAll(coll);\n     }\n \n         return map.keySet().toArray();\n     }\n \n-    public <T> T[] toArray(T[] array) {\n+    public <T> T[] toArray(final T[] array) {\n         return map.keySet().toArray(array);\n     }\n \n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         return map.keySet().equals(obj);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/PredicatedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/PredicatedSet.java\n      * @throws IllegalArgumentException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n-    public static <E> PredicatedSet<E> predicatedSet(Set<E> set, Predicate<? super E> predicate) {\n+    public static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n         return new PredicatedSet<E>(set, predicate);\n     }\n \n      * @throws IllegalArgumentException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n-    protected PredicatedSet(Set<E> set, Predicate<? super E> predicate) {\n+    protected PredicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n         super(set, predicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/PredicatedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/PredicatedSortedSet.java\n      * @throws IllegalArgumentException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n-    public static <E> PredicatedSortedSet<E> predicatedSortedSet(SortedSet<E> set, Predicate<? super E> predicate) {\n+    public static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n         return new PredicatedSortedSet<E>(set, predicate);\n     }\n \n      * @throws IllegalArgumentException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n-    protected PredicatedSortedSet(SortedSet<E> set, Predicate<? super E> predicate) {\n+    protected PredicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n         super(set, predicate);\n     }\n \n         return decorated().last();\n     }\n \n-    public SortedSet<E> subSet(E fromElement, E toElement) {\n-        SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n         return new PredicatedSortedSet<E>(sub, predicate);\n     }\n \n-    public SortedSet<E> headSet(E toElement) {\n-        SortedSet<E> sub = decorated().headSet(toElement);\n+    public SortedSet<E> headSet(final E toElement) {\n+        final SortedSet<E> sub = decorated().headSet(toElement);\n         return new PredicatedSortedSet<E>(sub, predicate);\n     }\n \n-    public SortedSet<E> tailSet(E fromElement) {\n-        SortedSet<E> sub = decorated().tailSet(fromElement);\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        final SortedSet<E> sub = decorated().tailSet(fromElement);\n         return new PredicatedSortedSet<E>(sub, predicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/SynchronizedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/SynchronizedSet.java\n      * @return a new synchronized set\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E> SynchronizedSet<E> synchronizedSet(Set<E> set) {\n+    public static <E> SynchronizedSet<E> synchronizedSet(final Set<E> set) {\n         return new SynchronizedSet<E>(set);\n     }\n     \n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected SynchronizedSet(Set<E> set) {\n+    protected SynchronizedSet(final Set<E> set) {\n         super(set);\n     }\n \n      * @param lock  the lock object to use, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected SynchronizedSet(Set<E> set, Object lock) {\n+    protected SynchronizedSet(final Set<E> set, final Object lock) {\n         super(set, lock);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/SynchronizedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/SynchronizedSortedSet.java\n      * @return a new synchronized sorted set\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E> SynchronizedSortedSet<E> synchronizedSortedSet(SortedSet<E> set) {\n+    public static <E> SynchronizedSortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n         return new SynchronizedSortedSet<E>(set);\n     }\n \n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected SynchronizedSortedSet(SortedSet<E> set) {\n+    protected SynchronizedSortedSet(final SortedSet<E> set) {\n         super(set);\n     }\n \n      * @param lock  the lock object to use, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    protected SynchronizedSortedSet(SortedSet<E> set, Object lock) {\n+    protected SynchronizedSortedSet(final SortedSet<E> set, final Object lock) {\n         super(set, lock);\n     }\n \n     }\n \n     //-----------------------------------------------------------------------\n-    public SortedSet<E> subSet(E fromElement, E toElement) {\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n         synchronized (lock) {\n-            SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n+            final SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n             // the lock is passed into the constructor here to ensure that the\n             // subset is synchronized on the same lock as the parent\n             return new SynchronizedSortedSet<E>(set, lock);\n         }\n     }\n \n-    public SortedSet<E> headSet(E toElement) {\n+    public SortedSet<E> headSet(final E toElement) {\n         synchronized (lock) {\n-            SortedSet<E> set = getSortedSet().headSet(toElement);\n+            final SortedSet<E> set = getSortedSet().headSet(toElement);\n             // the lock is passed into the constructor here to ensure that the\n             // headset is synchronized on the same lock as the parent\n             return new SynchronizedSortedSet<E>(set, lock);\n         }\n     }\n \n-    public SortedSet<E> tailSet(E fromElement) {\n+    public SortedSet<E> tailSet(final E fromElement) {\n         synchronized (lock) {\n-            SortedSet<E> set = getSortedSet().tailSet(fromElement);\n+            final SortedSet<E> set = getSortedSet().tailSet(fromElement);\n             // the lock is passed into the constructor here to ensure that the\n             // tailset is synchronized on the same lock as the parent\n             return new SynchronizedSortedSet<E>(set, lock);\n--- a/src/main/java/org/apache/commons/collections/set/TransformedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/TransformedSet.java\n      * @return a new transformed set\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    public static <E> TransformedSet<E> transformingSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedSet<E> transformingSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSet<E>(set, transformer);\n     }\n     \n      * @throws IllegalArgumentException if set or transformer is null\n      * @since 3.3\n      */\n-    public static <E> Set<E> transformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n-        TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n+    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n         if (transformer != null && set != null && set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n+            final\n             E[] values = (E[]) set.toArray();\n             set.clear();\n-            for (E value : values) {\n+            for (final E value : values) {\n                 decorated.decorated().add(transformer.transform(value));\n             }\n         }\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    protected TransformedSet(Set<E> set, Transformer<? super E, ? extends E> transformer) {\n+    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n         super(set, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/TransformedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/TransformedSortedSet.java\n      * @return a new transformed {@link SortedSet}\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    public static <E> TransformedSortedSet<E> transformingSortedSet(SortedSet<E> set,\n-                                                                    Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set,\n+                                                                    final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSortedSet<E>(set, transformer);\n     }\n     \n      * @throws IllegalArgumentException if set or transformer is null\n      * @since 3.3\n      */\n-    public static <E> TransformedSortedSet<E> transformedSortedSet(SortedSet<E> set,\n-                                                                   Transformer<? super E, ? extends E> transformer) {\n-        TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n+    public static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set,\n+                                                                   final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n         if (transformer != null && set != null && set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n+            final\n             E[] values = (E[]) set.toArray();\n             set.clear();\n-            for (E value : values) {\n+            for (final E value : values) {\n                 decorated.decorated().add(transformer.transform(value));\n             }\n         }\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    protected TransformedSortedSet(SortedSet<E> set, Transformer<? super E, ? extends E> transformer) {\n+    protected TransformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n         super(set, transformer);\n     }\n \n     }\n \n     //-----------------------------------------------------------------------\n-    public SortedSet<E> subSet(E fromElement, E toElement) {\n-        SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        final SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n         return new TransformedSortedSet<E>(set, transformer);\n     }\n \n-    public SortedSet<E> headSet(E toElement) {\n-        SortedSet<E> set = getSortedSet().headSet(toElement);\n+    public SortedSet<E> headSet(final E toElement) {\n+        final SortedSet<E> set = getSortedSet().headSet(toElement);\n         return new TransformedSortedSet<E>(set, transformer);\n     }\n \n-    public SortedSet<E> tailSet(E fromElement) {\n-        SortedSet<E> set = getSortedSet().tailSet(fromElement);\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        final SortedSet<E> set = getSortedSet().tailSet(fromElement);\n         return new TransformedSortedSet<E>(set, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/UnmodifiableSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/UnmodifiableSet.java\n      * @return a new unmodifiable set\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E> Set<E> unmodifiableSet(Set<E> set) {\n+    public static <E> Set<E> unmodifiableSet(final Set<E> set) {\n         if (set instanceof Unmodifiable) {\n             return set;\n         }\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    private UnmodifiableSet(Set<E> set) {\n+    private UnmodifiableSet(final Set<E> set) {\n         super(set);\n     }\n \n     }\n \n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/UnmodifiableSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/UnmodifiableSortedSet.java\n      * @return a new unmodifiable {@link SortedSet}\n      * @throws IllegalArgumentException if set is null\n      */\n-    public static <E> SortedSet<E> unmodifiableSortedSet(SortedSet<E> set) {\n+    public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n         if (set instanceof Unmodifiable) {\n             return set;\n         }\n      * @param out  the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(collection);\n     }\n      * @throws ClassNotFoundException\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         collection = (Collection<E>) in.readObject(); // (1)\n     }\n      * @param set  the set to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    private UnmodifiableSortedSet(SortedSet<E> set) {\n+    private UnmodifiableSortedSet(final SortedSet<E> set) {\n         super(set);\n     }\n \n     }\n \n     @Override\n-    public boolean add(E object) {\n+    public boolean add(final E object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean addAll(Collection<? extends E> coll) {\n+    public boolean addAll(final Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public boolean remove(Object object) {\n+    public boolean remove(final Object object) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeAll(Collection<?> coll) {\n+    public boolean removeAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean retainAll(Collection<?> coll) {\n+    public boolean retainAll(final Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n-    public SortedSet<E> subSet(E fromElement, E toElement) {\n-        SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n         return new UnmodifiableSortedSet<E>(sub);\n     }\n \n     @Override\n-    public SortedSet<E> headSet(E toElement) {\n-        SortedSet<E> sub = decorated().headSet(toElement);\n+    public SortedSet<E> headSet(final E toElement) {\n+        final SortedSet<E> sub = decorated().headSet(toElement);\n         return new UnmodifiableSortedSet<E>(sub);\n     }\n \n     @Override\n-    public SortedSet<E> tailSet(E fromElement) {\n-        SortedSet<E> sub = decorated().tailSet(fromElement);\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        final SortedSet<E> sub = decorated().tailSet(fromElement);\n         return new UnmodifiableSortedSet<E>(sub);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/splitmap/AbstractIterableGetMapDecorator.java\n      * Create a new AbstractSplitMapDecorator.\n      * @param decorated the Map to decorate\n      */\n-    public AbstractIterableGetMapDecorator(Map<K, V> decorated) {\n+    public AbstractIterableGetMapDecorator(final Map<K, V> decorated) {\n         this.map = decorated;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         return decorated().containsKey(key);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         return decorated().containsValue(value);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public V get(Object key) {\n+    public V get(final Object key) {\n         return decorated().get(key);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public V remove(Object key) {\n+    public V remove(final Object key) {\n         return decorated().remove(key);\n     }\n \n      * {@inheritDoc}\n      */\n     @Override\n-    public boolean equals(Object object) {\n+    public boolean equals(final Object object) {\n         if (object == this) {\n             return true;\n         }\n--- a/src/main/java/org/apache/commons/collections/splitmap/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections/splitmap/TransformedMap.java\n      * means no transformation\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static <J, K, U, V> TransformedMap<J, K, U, V> transformingMap(Map<K, V> map,\n-            Transformer<? super J, ? extends K> keyTransformer,\n-            Transformer<? super U, ? extends V> valueTransformer) {\n+    public static <J, K, U, V> TransformedMap<J, K, U, V> transformingMap(final Map<K, V> map,\n+            final Transformer<? super J, ? extends K> keyTransformer,\n+            final Transformer<? super U, ? extends V> valueTransformer) {\n         return new TransformedMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n     }\n \n      * means no conversion\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected TransformedMap(Map<K, V> map, Transformer<? super J, ? extends K> keyTransformer,\n-            Transformer<? super U, ? extends V> valueTransformer) {\n+    protected TransformedMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer,\n+            final Transformer<? super U, ? extends V> valueTransformer) {\n         super(map);\n         if (keyTransformer == null) {\n             throw new IllegalArgumentException(\"keyTransformer cannot be null\");\n      * @param out the output stream\n      * @throws IOException\n      */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n         out.writeObject(decorated());\n     }\n      * @since 3.1\n      */\n     @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map<K, V>) in.readObject(); // (1)\n     }\n      * @param object the object to transform\n      * @return the transformed object\n      */\n-    protected K transformKey(J object) {\n+    protected K transformKey(final J object) {\n         return keyTransformer.transform(object);\n     }\n \n      * @param object the object to transform\n      * @return the transformed object\n      */\n-    protected V transformValue(U object) {\n+    protected V transformValue(final U object) {\n         return valueTransformer.transform(object);\n     }\n \n      * @return the transformed object\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected Map<K, V> transformMap(Map<? extends J, ? extends U> map) {\n+    protected Map<K, V> transformMap(final Map<? extends J, ? extends U> map) {\n         if (map.isEmpty()) {\n             return (Map<K, V>) map;\n         }\n-        Map<K, V> result = new LinkedMap<K, V>(map.size());\n-\n-        for (Map.Entry<? extends J, ? extends U> entry : map.entrySet()) {\n+        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (final Map.Entry<? extends J, ? extends U> entry : map.entrySet()) {\n             result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n         }\n         return result;\n      * @param value the value to transform\n      * @return the transformed value\n      */\n-    protected V checkSetValue(U value) {\n+    protected V checkSetValue(final U value) {\n         return valueTransformer.transform(value);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public V put(J key, U value) {\n+    public V put(final J key, final U value) {\n         return decorated().put(transformKey(key), transformValue(value));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public void putAll(Map<? extends J, ? extends U> mapToCopy) {\n+    public void putAll(final Map<? extends J, ? extends U> mapToCopy) {\n         decorated().putAll(transformMap(mapToCopy));\n     }\n \n--- a/src/main/java/org/apache/commons/collections/trie/AbstractKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/AbstractKeyAnalyzer.java\n      * {@inheritDoc}\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public int compare(K o1, K o2) {\n+    public int compare(final K o1, final K o2) {\n         if (o1 == null) {\n             return o2 == null ? 0 : -1;\n         } else if (o2 == null) {\n     /** \n      * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}\n      */\n-    static boolean isOutOfBoundsIndex(int bitIndex) {\n+    static boolean isOutOfBoundsIndex(final int bitIndex) {\n         return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n     }\n \n     /** \n      * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}\n      */\n-    static boolean isEqualBitKey(int bitIndex) {\n+    static boolean isEqualBitKey(final int bitIndex) {\n         return bitIndex == EQUAL_BIT_KEY;\n     }\n \n     /** \n      * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY} \n      */\n-    static boolean isNullBitKey(int bitIndex) {\n+    static boolean isNullBitKey(final int bitIndex) {\n         return bitIndex == NULL_BIT_KEY;\n     }\n \n      * are considered valid if they're between 0 and \n      * {@link Integer#MAX_VALUE}\n      */\n-    static boolean isValidBitIndex(int bitIndex) {\n+    static boolean isValidBitIndex(final int bitIndex) {\n         return 0 <= bitIndex && bitIndex <= Integer.MAX_VALUE;\n     }\n }\n--- a/src/main/java/org/apache/commons/collections/trie/AbstractTrie.java\n+++ b/src/main/java/org/apache/commons/collections/trie/AbstractTrie.java\n     /** \n      * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n      */\n-    public AbstractTrie(KeyAnalyzer<? super K> keyAnalyzer) {\n+    public AbstractTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n         if (keyAnalyzer == null) {\n             throw new NullPointerException(\"keyAnalyzer\");\n         }\n     /**\n      * {@inheritDoc}\n      */\n-    public K selectKey(K key) {\n-        Map.Entry<K, V> entry = select(key);\n+    public K selectKey(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n         if (entry == null) {\n             return null;\n         }\n     /**\n      * {@inheritDoc}\n      */\n-    public V selectValue(K key) {\n-        Map.Entry<K, V> entry = select(key);\n+    public V selectValue(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n         if (entry == null) {\n             return null;\n         }\n     \n     @Override\n     public String toString() {\n-        StringBuilder buffer = new StringBuilder();\n+        final StringBuilder buffer = new StringBuilder();\n         buffer.append(\"Trie[\").append(size()).append(\"]={\\n\");\n-        for (Map.Entry<K, V> entry : entrySet()) {\n+        for (final Map.Entry<K, V> entry : entrySet()) {\n             buffer.append(\"  \").append(entry).append(\"\\n\");\n         }\n         buffer.append(\"}\\n\");\n      * cast anything. It's just fooling the compiler!\n      */\n     @SuppressWarnings(\"unchecked\")\n-    final K castKey(Object key) {\n+    final K castKey(final Object key) {\n         return (K)key;\n     }\n     \n      * \n      * @see KeyAnalyzer#lengthInBits(Object)\n      */\n-    final int lengthInBits(K key) {\n+    final int lengthInBits(final K key) {\n         if (key == null) {\n             return 0;\n         }\n      * \n      * @see KeyAnalyzer#isBitSet(Object, int, int)\n      */\n-    final boolean isBitSet(K key, int bitIndex, int lengthInBits) {\n+    final boolean isBitSet(final K key, final int bitIndex, final int lengthInBits) {\n         if (key == null) { // root's might be null!\n             return false;\n         }\n     /**\n      * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}\n      */\n-    final int bitIndex(K key, K foundKey) {\n+    final int bitIndex(final K key, final K foundKey) {\n         return keyAnalyzer.bitIndex(key, 0, lengthInBits(key), \n                 foundKey, 0, lengthInBits(foundKey));\n     }\n     /**\n      * An utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n      */\n-    final boolean compareKeys(K key, K other) {\n+    final boolean compareKeys(final K key, final K other) {\n         if (key == null) {\n             return other == null;\n         } else if (other == null) {\n     /**\n      * Returns true if both values are either null or equal\n      */\n-    static boolean compare(Object a, Object b) {\n+    static boolean compare(final Object a, final Object b) {\n         return a == null ? b == null : a.equals(b);\n     }\n     \n         \n         private final int hashCode;\n         \n-        public BasicEntry(K key) {\n+        public BasicEntry(final K key) {\n             this.key = key;\n             this.hashCode = key != null ? key.hashCode() : 0;\n         }\n         \n-        public BasicEntry(K key, V value) {\n+        public BasicEntry(final K key, final V value) {\n             this.key = key;\n             this.value = value;\n             \n          * Replaces the current key and value with the provided\n          * key &amp; value\n          */\n-        public V setKeyValue(K key, V value) {\n+        public V setKeyValue(final K key, final V value) {\n             this.key = key;\n             return setValue(value);\n         }\n         /**\n          * {@inheritDoc}\n          */\n-        public V setValue(V value) {\n-            V previous = this.value;\n+        public V setValue(final V value) {\n+            final V previous = this.value;\n             this.value = value;\n             return previous;\n         }\n         }\n         \n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (o == this) {\n                 return true;\n             } else if (!(o instanceof Map.Entry)) {\n                 return false;\n             }\n             \n-            Map.Entry<?, ?> other = (Map.Entry<?, ?>)o;\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>)o;\n             if (compare(key, other.getKey()) \n                     && compare(value, other.getValue())) {\n                 return true;\n--- a/src/main/java/org/apache/commons/collections/trie/ByteArrayKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/ByteArrayKeyAnalyzer.java\n      */\n     private final int maxLengthInBits;\n     \n-    public ByteArrayKeyAnalyzer(int maxLengthInBits) {\n+    public ByteArrayKeyAnalyzer(final int maxLengthInBits) {\n         if (maxLengthInBits < 0) {\n             throw new IllegalArgumentException(\n                     \"maxLengthInBits=\" + maxLengthInBits);\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static int mask(int bit) {\n+    private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(byte[] key) {\n+    public int lengthInBits(final byte[] key) {\n         return key != null ? key.length * bitsPerElement() : 0;\n     }\n     \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(byte[] key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final byte[] key, final int bitIndex, final int lengthInBits) {\n         if (key == null) {     \n             return false;\n         }\n         \n-        int prefix = maxLengthInBits - lengthInBits;\n-        int keyBitIndex = bitIndex - prefix;\n+        final int prefix = maxLengthInBits - lengthInBits;\n+        final int keyBitIndex = bitIndex - prefix;\n         \n         if (keyBitIndex >= lengthInBits || keyBitIndex < 0) {\n             return false;\n         }\n         \n-        int index = keyBitIndex / LENGTH;\n-        int bit = keyBitIndex % LENGTH;\n+        final int index = keyBitIndex / LENGTH;\n+        final int bit = keyBitIndex % LENGTH;\n         return (key[index] & mask(bit)) != 0;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(byte[] key, int offsetInBits, int lengthInBits, \n-            byte[] other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final byte[] key, final int offsetInBits, final int lengthInBits, \n+            byte[] other, final int otherOffsetInBits, final int otherLengthInBits) {\n         \n         if (other == null) {\n             other = NULL;\n         }\n         \n         boolean allNull = true;\n-        int length = Math.max(lengthInBits, otherLengthInBits);\n-        int prefix = maxLengthInBits - length;\n+        final int length = Math.max(lengthInBits, otherLengthInBits);\n+        final int prefix = maxLengthInBits - length;\n         \n         if (prefix < 0) {\n             return KeyAnalyzer.OUT_OF_BOUNDS_BIT_KEY;\n         }\n         \n         for (int i = 0; i < length; i++) {\n-            int index = prefix + offsetInBits + i;\n-            boolean value = isBitSet(key, index, lengthInBits);\n+            final int index = prefix + offsetInBits + i;\n+            final boolean value = isBitSet(key, index, lengthInBits);\n                 \n             if (value) {\n                 allNull = false;\n             }\n             \n-            int otherIndex = prefix + otherOffsetInBits + i;\n-            boolean otherValue = isBitSet(other, otherIndex, otherLengthInBits);\n+            final int otherIndex = prefix + otherOffsetInBits + i;\n+            final boolean otherValue = isBitSet(other, otherIndex, otherLengthInBits);\n             \n             if (value != otherValue) {\n                 return index;\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(byte[] prefix, int offsetInBits, \n-            int lengthInBits, byte[] key) {\n-        \n-        int keyLength = lengthInBits(key);\n+    public boolean isPrefix(final byte[] prefix, final int offsetInBits, \n+            final int lengthInBits, final byte[] key) {\n+        \n+        final int keyLength = lengthInBits(key);\n         if (lengthInBits > keyLength) {\n             return false;\n         }\n         \n-        int elements = lengthInBits - offsetInBits;\n+        final int elements = lengthInBits - offsetInBits;\n         for (int i = 0; i < elements; i++) {\n             if (isBitSet(prefix, i+offsetInBits, lengthInBits) \n                     != isBitSet(key, i, keyLength)) {\n      * {@inheritDoc}\n      */\n     @Override\n-    public int compare(byte[] o1, byte[] o2) {\n+    public int compare(final byte[] o1, final byte[] o2) {\n         if (o1 == null) {\n             return o2 == null ? 0 : -1;\n         } else if (o2 == null) {\n         }\n         \n         for (int i = 0; i < o1.length; i++) {\n-            int diff = (o1[i] & 0xFF) - (o2[i] & 0xFF);\n+            final int diff = (o1[i] & 0xFF) - (o2[i] & 0xFF);\n             if (diff != 0) {\n                 return diff;\n             }\n--- a/src/main/java/org/apache/commons/collections/trie/ByteKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/ByteKeyAnalyzer.java\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static int mask(int bit) {\n+    private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(Byte key) {\n+    public int lengthInBits(final Byte key) {\n         return LENGTH;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(Byte key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final Byte key, final int bitIndex, final int lengthInBits) {\n         return (key & mask(bitIndex)) != 0;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(Byte key, int offsetInBits, int lengthInBits, \n-            Byte other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final Byte key, final int offsetInBits, final int lengthInBits, \n+            final Byte other, final int otherOffsetInBits, final int otherLengthInBits) {\n         \n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n             throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n         \n-        byte keyValue = key.byteValue();\n+        final byte keyValue = key.byteValue();\n         if (keyValue == 0) {\n             return NULL_BIT_KEY;\n         }\n \n-        byte otherValue = other != null ? other.byteValue() : 0;\n+        final byte otherValue = other != null ? other.byteValue() : 0;\n         \n         if (keyValue != otherValue) {\n-            int xorValue = keyValue ^ otherValue;\n+            final int xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 if ((xorValue & mask(i)) != 0) {\n                     return i;\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(Byte prefix, int offsetInBits, \n-            int lengthInBits, Byte key) {\n+    public boolean isPrefix(final Byte prefix, final int offsetInBits, \n+            final int lengthInBits, final Byte key) {\n         \n-        int value1 = prefix.byteValue() << offsetInBits;\n-        int value2 = key.byteValue();\n+        final int value1 = prefix.byteValue() << offsetInBits;\n+        final int value2 = key.byteValue();\n         \n         int mask = 0;\n         for (int i = 0; i < lengthInBits; i++) {\n--- a/src/main/java/org/apache/commons/collections/trie/CharArrayKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/CharArrayKeyAnalyzer.java\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static int mask(int bit) {\n+    private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(char[] key) {\n+    public int lengthInBits(final char[] key) {\n         return key != null ? key.length * LENGTH : 0;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(char[] key, int offsetInBits, int lengthInBits,\n-            char[] other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final char[] key, final int offsetInBits, final int lengthInBits,\n+            final char[] other, final int otherOffsetInBits, final int otherLengthInBits) {\n         boolean allNull = true;\n \n         if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0\n         }\n \n \n-        int beginIndex1 = offsetInBits / LENGTH;\n-        int beginIndex2 = otherOffsetInBits / LENGTH;\n+        final int beginIndex1 = offsetInBits / LENGTH;\n+        final int beginIndex2 = otherOffsetInBits / LENGTH;\n \n-        int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n-        int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+        final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n \n-        int length = Math.max(endIndex1, endIndex2);\n+        final int length = Math.max(endIndex1, endIndex2);\n \n         // Look at each character, and if they're different\n         // then figure out which bit makes the difference\n         // and return it.\n         char k = 0, f = 0;\n         for(int i = 0; i < length; i++) {\n-            int index1 = beginIndex1 + i;\n-            int index2 = beginIndex2 + i;\n+            final int index1 = beginIndex1 + i;\n+            final int index2 = beginIndex2 + i;\n \n             if (index1 >= endIndex1) {\n                 k = 0;\n             }\n \n             if (k != f) {\n-               int x = k ^ f;\n+               final int x = k ^ f;\n                return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n             }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(char[] key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final char[] key, final int bitIndex, final int lengthInBits) {\n         if (key == null || bitIndex >= lengthInBits) {\n             return false;\n         }\n \n-        int index = bitIndex / LENGTH;\n-        int bit = bitIndex % LENGTH;\n+        final int index = bitIndex / LENGTH;\n+        final int bit = bitIndex % LENGTH;\n \n         return (key[index] & mask(bit)) != 0;\n     }\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(char[] prefix, int offsetInBits,\n-            int lengthInBits, char[] key) {\n+    public boolean isPrefix(final char[] prefix, final int offsetInBits,\n+            final int lengthInBits, final char[] key) {\n         if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n             throw new IllegalArgumentException(\n                     \"Cannot determine prefix outside of Character boundaries\");\n         }\n \n-        int off = offsetInBits / LENGTH;\n-        int len = lengthInBits / LENGTH;\n+        final int off = offsetInBits / LENGTH;\n+        final int len = lengthInBits / LENGTH;\n         for (int i = 0; i < len; i ++) {\n             if (prefix[i + off] != key[i]) {\n                 return false;\n--- a/src/main/java/org/apache/commons/collections/trie/CharacterKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/CharacterKeyAnalyzer.java\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static int mask(int bit) {\n+    private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n     \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(Character key) {\n+    public int lengthInBits(final Character key) {\n         return LENGTH;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(Character key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final Character key, final int bitIndex, final int lengthInBits) {\n         return (key & mask(bitIndex)) != 0;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(Character key, int offsetInBits, int lengthInBits, \n-            Character other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final Character key, final int offsetInBits, final int lengthInBits, \n+            Character other, final int otherOffsetInBits, final int otherLengthInBits) {\n         \n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n             throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n         \n-        char keyValue = key.charValue();\n+        final char keyValue = key.charValue();\n         if (keyValue == Character.MIN_VALUE) {\n             return NULL_BIT_KEY;\n         }\n             other = Character.MIN_VALUE;\n         }\n         \n-        char otherValue = other != null ? other.charValue() : Character.MIN_VALUE;\n+        final char otherValue = other != null ? other.charValue() : Character.MIN_VALUE;\n         \n         if (keyValue != otherValue) {\n-            int xorValue = keyValue ^ otherValue;\n+            final int xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 if ((xorValue & mask(i)) != 0) {\n                     return i;\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(Character prefix, int offsetInBits, \n-            int lengthInBits, Character key) {\n+    public boolean isPrefix(final Character prefix, final int offsetInBits, \n+            final int lengthInBits, final Character key) {\n         \n-        int value1 = prefix.charValue() << offsetInBits;\n-        int value2 = key.charValue();\n+        final int value1 = prefix.charValue() << offsetInBits;\n+        final int value2 = key.charValue();\n         \n         int mask = 0;\n         for(int i = 0; i < lengthInBits; i++) {\n--- a/src/main/java/org/apache/commons/collections/trie/IntegerKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/IntegerKeyAnalyzer.java\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static int mask(int bit) {\n+    private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(Integer key) {\n+    public int lengthInBits(final Integer key) {\n         return LENGTH;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(Integer key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final Integer key, final int bitIndex, final int lengthInBits) {\n         return (key & mask(bitIndex)) != 0;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(Integer key, int offsetInBits, int lengthInBits, \n-            Integer other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final Integer key, final int offsetInBits, final int lengthInBits, \n+            final Integer other, final int otherOffsetInBits, final int otherLengthInBits) {\n         \n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n             throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n         \n-        int keyValue = key.intValue();\n+        final int keyValue = key.intValue();\n         if (keyValue == 0) {\n             return NULL_BIT_KEY;\n         }\n \n-        int otherValue = other != null ? other.intValue() : 0;\n+        final int otherValue = other != null ? other.intValue() : 0;\n         \n         if (keyValue != otherValue) {\n-            int xorValue = keyValue ^ otherValue;\n+            final int xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 if ((xorValue & mask(i)) != 0) {\n                     return i;\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(Integer prefix, int offsetInBits, \n-            int lengthInBits, Integer key) {\n+    public boolean isPrefix(final Integer prefix, final int offsetInBits, \n+            final int lengthInBits, final Integer key) {\n         \n-        int value1 = prefix.intValue() << offsetInBits;\n-        int value2 = key.intValue();\n+        final int value1 = prefix.intValue() << offsetInBits;\n+        final int value2 = key.intValue();\n         \n         int mask = 0;\n         for (int i = 0; i < lengthInBits; i++) {\n--- a/src/main/java/org/apache/commons/collections/trie/LongKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/LongKeyAnalyzer.java\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static long mask(int bit) {\n+    private static long mask(final int bit) {\n         return MSB >>> bit;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(Long key) {\n+    public int lengthInBits(final Long key) {\n         return LENGTH;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(Long key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final Long key, final int bitIndex, final int lengthInBits) {\n         return (key & mask(bitIndex)) != 0;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(Long key, int offsetInBits, int lengthInBits, \n-            Long other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final Long key, final int offsetInBits, final int lengthInBits, \n+            final Long other, final int otherOffsetInBits, final int otherLengthInBits) {\n         \n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n             throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n         \n-        long keyValue = key.longValue();\n+        final long keyValue = key.longValue();\n         if (keyValue == 0L) {\n             return NULL_BIT_KEY;\n         }\n \n-        long otherValue = other != null ? other.longValue() : 0L;\n+        final long otherValue = other != null ? other.longValue() : 0L;\n         \n         if (keyValue != otherValue) {\n-            long xorValue = keyValue ^ otherValue;\n+            final long xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 if ((xorValue & mask(i)) != 0L) {\n                     return i;\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(Long prefix, int offsetInBits, \n-            int lengthInBits, Long key) {\n+    public boolean isPrefix(final Long prefix, final int offsetInBits, \n+            final int lengthInBits, final Long key) {\n         \n-        long value1 = prefix.longValue() << offsetInBits;\n-        long value2 = key.longValue();\n+        final long value1 = prefix.longValue() << offsetInBits;\n+        final long value2 = key.longValue();\n         \n         long mask = 0L;\n         for (int i = 0; i < lengthInBits; i++) {\n--- a/src/main/java/org/apache/commons/collections/trie/PatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections/trie/PatriciaTrie.java\n     \n     private static final long serialVersionUID = 4446367780901817838L;\n \n-    public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer) {\n+    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n         super(keyAnalyzer);\n     }\n \n-    public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer,\n-            Map<? extends K, ? extends V> m) {\n+    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer,\n+            final Map<? extends K, ? extends V> m) {\n         super(keyAnalyzer, m);\n     }\n     \n     /**\n      * {@inheritDoc}\n      */\n-    public SortedMap<K, V> getPrefixedBy(K key) {\n+    public SortedMap<K, V> getPrefixedBy(final K key) {\n         return getPrefixedByBits(key, 0, lengthInBits(key));\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public SortedMap<K, V> getPrefixedBy(K key, int length) {\n+    public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n         return getPrefixedByBits(key, 0, length * bitsPerElement());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n-        int bitsPerElement = bitsPerElement();\n+    public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n+        final int bitsPerElement = bitsPerElement();\n         return getPrefixedByBits(key, offset*bitsPerElement, length*bitsPerElement);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n         return getPrefixedByBits(key, 0, lengthInBits);\n     }\n     \n      * {@inheritDoc}\n      */\n     public K lastKey() {\n-        TrieEntry<K, V> entry = lastEntry();\n+        final TrieEntry<K, V> entry = lastEntry();\n         if (entry != null) {\n             return entry.getKey();\n         }\n      * that contains the prefixes if the entry holding the subtree is \n      * removed or changes. Changing the subtree takes O(K) time.\n      */\n-    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits) {\n-        \n-        int offsetLength = offsetInBits + lengthInBits;\n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n+        \n+        final int offsetLength = offsetInBits + lengthInBits;\n         if (offsetLength > lengthInBits(key)) {\n             throw new IllegalArgumentException(offsetInBits + \" + \" \n                     + lengthInBits + \" > \" + lengthInBits(key));\n     /**\n      * {@inheritDoc}\n      */\n-    public SortedMap<K, V> headMap(K toKey) {\n+    public SortedMap<K, V> headMap(final K toKey) {\n         return new RangeEntryMap(null, toKey);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return new RangeEntryMap(fromKey, toKey);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public SortedMap<K, V> tailMap(K fromKey) {\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n         return new RangeEntryMap(fromKey, null);\n     } \n     \n      * Returns an entry strictly higher than the given key,\n      * or null if no such entry exists.\n      */\n-    TrieEntry<K,V> higherEntry(K key) {\n+    TrieEntry<K,V> higherEntry(final K key) {\n         // TODO: Cleanup so that we don't actually have to add/remove from the\n         //       tree.  (We do it here because there are other well-defined \n         //       functions to perform the search.)\n-        int lengthInBits = lengthInBits(key);\n+        final int lengthInBits = lengthInBits(key);\n         \n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n             }\n         }\n         \n-        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return nextEntry(found);\n         }\n         \n-        int bitIndex = bitIndex(key, found.key);\n+        final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n-            TrieEntry<K, V> ceil = nextEntry(added);\n+            final TrieEntry<K, V> ceil = nextEntry(added);\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return ceil;\n      * Returns a key-value mapping associated with the least key greater\n      * than or equal to the given key, or null if there is no such key.\n      */\n-    TrieEntry<K,V> ceilingEntry(K key) {\n+    TrieEntry<K,V> ceilingEntry(final K key) {\n         // Basically:\n         // Follow the steps of adding an entry, but instead...\n         //\n         // TODO: Cleanup so that we don't actually have to add/remove from the\n         //       tree.  (We do it here because there are other well-defined \n         //       functions to perform the search.)\n-        int lengthInBits = lengthInBits(key);\n+        final int lengthInBits = lengthInBits(key);\n         \n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n             }\n         }\n         \n-        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return found;\n         }\n         \n-        int bitIndex = bitIndex(key, found.key);\n+        final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n-            TrieEntry<K, V> ceil = nextEntry(added);\n+            final TrieEntry<K, V> ceil = nextEntry(added);\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return ceil;\n      * Returns a key-value mapping associated with the greatest key\n      * strictly less than the given key, or null if there is no such key.\n      */\n-    TrieEntry<K,V> lowerEntry(K key) {\n+    TrieEntry<K,V> lowerEntry(final K key) {\n         // Basically:\n         // Follow the steps of adding an entry, but instead...\n         //\n         // TODO: Cleanup so that we don't actually have to add/remove from the\n         //       tree.  (We do it here because there are other well-defined \n         //       functions to perform the search.)\n-        int lengthInBits = lengthInBits(key);\n+        final int lengthInBits = lengthInBits(key);\n         \n         if (lengthInBits == 0) {\n             return null; // there can never be anything before root.\n         }\n         \n-        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return previousEntry(found);\n         }\n         \n-        int bitIndex = bitIndex(key, found.key);\n+        final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n-            TrieEntry<K, V> prior = previousEntry(added);\n+            final TrieEntry<K, V> prior = previousEntry(added);\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return prior;\n      * Returns a key-value mapping associated with the greatest key\n      * less than or equal to the given key, or null if there is no such key.\n      */\n-    TrieEntry<K,V> floorEntry(K key) {        \n+    TrieEntry<K,V> floorEntry(final K key) {        \n         // TODO: Cleanup so that we don't actually have to add/remove from the\n         //       tree.  (We do it here because there are other well-defined \n         //       functions to perform the search.)\n-        int lengthInBits = lengthInBits(key);\n+        final int lengthInBits = lengthInBits(key);\n         \n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n             }\n         }\n         \n-        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             return found;\n         }\n         \n-        int bitIndex = bitIndex(key, found.key);\n+        final int bitIndex = bitIndex(key, found.key);\n         if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n-            TrieEntry<K, V> floor = previousEntry(added);\n+            final TrieEntry<K, V> floor = previousEntry(added);\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return floor;\n      * This is very similar to getR but with the difference that\n      * we stop the lookup if h.bitIndex > lengthInBits.\n      */\n-    TrieEntry<K, V> subtree(K prefix, int offsetInBits, int lengthInBits) {\n+    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while(true) {\n         }        \n \n         // Make sure the entry is valid for a subtree.\n-        TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n+        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n         \n         // If entry is root, it can't be empty.\n         if (entry.isEmpty()) {\n             return null;\n         }\n         \n-        int endIndexInBits = offsetInBits + lengthInBits;\n+        final int endIndexInBits = offsetInBits + lengthInBits;\n         \n         // if root && length of root is less than length of lookup,\n         // there's nothing.\n         }\n         \n         // ... or there are less than 'length' equal bits\n-        int bitIndex = keyAnalyzer.bitIndex(prefix, offsetInBits, \n+        final int bitIndex = keyAnalyzer.bitIndex(prefix, offsetInBits, \n                 lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));\n         \n         if (bitIndex >= 0 && bitIndex < lengthInBits) {\n      * \n      * @param start\n      */\n-    TrieEntry<K, V> previousEntry(TrieEntry<K, V> start) {\n+    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n         if (start.predecessor == null) {\n             throw new IllegalArgumentException(\"must have come from somewhere!\");\n         }\n      * This will traverse only within the subtree.  If the given node\n      * is not within the subtree, this will have undefined results.\n      */\n-    TrieEntry<K, V> nextEntryInSubtree(TrieEntry<K, V> node, \n-            TrieEntry<K, V> parentOfSubtree) {\n+    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, \n+            final TrieEntry<K, V> parentOfSubtree) {\n         if (node == null) {\n             return firstEntry();\n         } else {\n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean containsKey(Object key) {\n+        public boolean containsKey(final Object key) {\n             if (!inRange(castKey(key))) {\n                 return false;\n             }\n          * {@inheritDoc}\n          */\n         @Override\n-        public V remove(Object key) {\n+        public V remove(final Object key) {\n             if (!inRange(castKey(key))) {\n                 return null;\n             }\n          * {@inheritDoc}\n          */\n         @Override\n-        public V get(Object key) {\n+        public V get(final Object key) {\n             if (!inRange(castKey(key))) {\n                 return null;\n             }\n          * {@inheritDoc}\n          */\n         @Override\n-        public V put(K key, V value) {\n+        public V put(final K key, final V value) {\n             if (!inRange(key)) {\n                 throw new IllegalArgumentException(\n                         \"Key is out of range: \" + key);\n         /**\n          * {@inheritDoc}\n          */\n-        public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n             if (!inRange2(fromKey)) {\n                 throw new IllegalArgumentException(\n                         \"FromKey is out of range: \" + fromKey);\n         /**\n          * {@inheritDoc}\n          */\n-        public SortedMap<K, V> headMap(K toKey) {\n+        public SortedMap<K, V> headMap(final K toKey) {\n             if (!inRange2(toKey)) {\n                 throw new IllegalArgumentException(\n                         \"ToKey is out of range: \" + toKey);\n         /**\n          * {@inheritDoc}\n          */\n-        public SortedMap<K, V> tailMap(K fromKey) {\n+        public SortedMap<K, V> tailMap(final K fromKey) {\n             if (!inRange2(fromKey)) {\n                 throw new IllegalArgumentException(\n                         \"FromKey is out of range: \" + fromKey);\n          * Returns true if the provided key is greater than TO and\n          * less than FROM\n          */\n-        protected boolean inRange(K key) {\n-\n-            K fromKey = getFromKey();\n-            K toKey = getToKey();\n+        protected boolean inRange(final K key) {\n+\n+            final K fromKey = getFromKey();\n+            final K toKey = getToKey();\n \n             return (fromKey == null || inFromRange(key, false))\n                     && (toKey == null || inToRange(key, false));\n         /**\n          * This form allows the high endpoint (as well as all legit keys)\n          */\n-        protected boolean inRange2(K key) {\n-\n-            K fromKey = getFromKey();\n-            K toKey = getToKey();\n+        protected boolean inRange2(final K key) {\n+\n+            final K fromKey = getFromKey();\n+            final K toKey = getToKey();\n \n             return (fromKey == null || inFromRange(key, false))\n                     && (toKey == null || inToRange(key, true));\n          * Returns true if the provided key is in the FROM range \n          * of the {@link RangeMap}\n          */\n-        protected boolean inFromRange(K key, boolean forceInclusive) {\n-\n-            K fromKey = getFromKey();\n-            boolean fromInclusive = isFromInclusive();\n-\n-            int ret = keyAnalyzer.compare(key, fromKey);\n+        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n+\n+            final K fromKey = getFromKey();\n+            final boolean fromInclusive = isFromInclusive();\n+\n+            final int ret = keyAnalyzer.compare(key, fromKey);\n             if (fromInclusive || forceInclusive) {\n                 return ret >= 0;\n             } else {\n          * Returns true if the provided key is in the TO range \n          * of the {@link RangeMap}\n          */\n-        protected boolean inToRange(K key, boolean forceInclusive) {\n-\n-            K toKey = getToKey();\n-            boolean toInclusive = isToInclusive();\n-\n-            int ret = keyAnalyzer.compare(key, toKey);\n+        protected boolean inToRange(final K key, final boolean forceInclusive) {\n+\n+            final K toKey = getToKey();\n+            final boolean toInclusive = isToInclusive();\n+\n+            final int ret = keyAnalyzer.compare(key, toKey);\n             if (toInclusive || forceInclusive) {\n                 return ret <= 0;\n             } else {\n         * Creates a {@link RangeEntryMap} with the fromKey included and\n         * the toKey excluded from the range\n         */\n-       protected RangeEntryMap(K fromKey, K toKey) {\n+       protected RangeEntryMap(final K fromKey, final K toKey) {\n            this(fromKey, true, toKey, false);\n        }\n        \n        /**\n         * Creates a {@link RangeEntryMap}\n         */\n-       protected RangeEntryMap(K fromKey, boolean fromInclusive, \n-               K toKey, boolean toInclusive) {\n+       protected RangeEntryMap(final K fromKey, final boolean fromInclusive, \n+               final K toKey, final boolean toInclusive) {\n            \n            if (fromKey == null && toKey == null) {\n                throw new IllegalArgumentException(\"must have a from or to!\");\n                }\n            }\n            \n-           K first = e != null ? e.getKey() : null;\n+           final K first = e != null ? e.getKey() : null;\n            if (e == null || toKey != null && !inToRange(first, false)) {\n                throw new NoSuchElementException();\n            }\n                }\n            }\n            \n-           K last = e != null ? e.getKey() : null;\n+           final K last = e != null ? e.getKey() : null;\n            if (e == null || fromKey != null && !inFromRange(last, false)) {\n                throw new NoSuchElementException();\n            }\n         * {@inheritDoc}\n         */\n        @Override\n-       protected SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n-               K toKey, boolean toInclusive) {\n+       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n+               final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n    }\n         /**\n          * Creates a {@link RangeEntrySet}\n          */\n-        public RangeEntrySet(RangeMap delegate) {\n+        public RangeEntrySet(final RangeMap delegate) {\n             if (delegate == null) {\n                 throw new NullPointerException(\"delegate\");\n             }\n          */\n         @Override\n         public Iterator<Map.Entry<K, V>> iterator() {\n-            K fromKey = delegate.getFromKey();\n-            K toKey = delegate.getToKey();\n+            final K fromKey = delegate.getFromKey();\n+            final K toKey = delegate.getToKey();\n \n             TrieEntry<K, V> first = null;\n             if (fromKey == null) {\n             if (size == -1 || expectedModCount != PatriciaTrie.this.modCount) {\n                 size = 0;\n \n-                for (Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n+                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                     ++size;\n                 }\n \n          */\n         @SuppressWarnings(\"unchecked\")\n         @Override\n-        public boolean contains(Object o) {\n+        public boolean contains(final Object o) {\n             if (!(o instanceof Map.Entry)) {\n                 return false;\n             }\n \n-            Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n-            K key = entry.getKey();\n+            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            final K key = entry.getKey();\n             if (!delegate.inRange(key)) {\n                 return false;\n             }\n \n-            TrieEntry<K, V> node = getEntry(key);\n+            final TrieEntry<K, V> node = getEntry(key);\n             return node != null && compare(node.getValue(), entry.getValue());\n         }\n \n          */\n         @SuppressWarnings(\"unchecked\")\n         @Override\n-        public boolean remove(Object o) {\n+        public boolean remove(final Object o) {\n             if (!(o instanceof Map.Entry)) {\n                 return false;\n             }\n \n-            Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n-            K key = entry.getKey();\n+            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            final K key = entry.getKey();\n             if (!delegate.inRange(key)) {\n                 return false;\n             }\n \n-            TrieEntry<K, V> node = getEntry(key);\n+            final TrieEntry<K, V> node = getEntry(key);\n             if (node != null && compare(node.getValue(), entry.getValue())) {\n                 removeEntry(node);\n                 return true;\n              * Creates a {@link EntryIterator}\n              */\n             private EntryIterator(\n-                    TrieEntry<K,V> first, \n-                    TrieEntry<K,V> last) {\n+                    final TrieEntry<K,V> first, \n+                    final TrieEntry<K,V> last) {\n                 super(first);\n                 \n                 this.excludedKey = last != null ? last.getKey() : null;\n         /**\n          * Creates a {@link PrefixRangeMap}\n          */\n-        private PrefixRangeMap(K prefix, int offsetInBits, int lengthInBits) {\n+        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n             this.prefix = prefix;\n             this.offsetInBits = offsetInBits;\n             this.lengthInBits = lengthInBits;\n             // The trie has changed since we last\n             // found our toKey / fromKey\n             if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount) {\n-                Iterator<Map.Entry<K, V>> it = entrySet().iterator();\n+                final Iterator<Map.Entry<K, V>> it = entrySet().iterator();\n                 size = 0;\n                 \n                 Map.Entry<K, V> entry = null;\n                 \n                 fromKey = entry == null ? null : entry.getKey();\n                 if (fromKey != null) {\n-                    TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n+                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n                     fromKey = prior == null ? null : prior.getKey();\n                 }\n                 \n                 e = higherEntry(fromKey);\n             }\n             \n-            K first = e != null ? e.getKey() : null;\n+            final K first = e != null ? e.getKey() : null;\n             if (e == null || !keyAnalyzer.isPrefix(prefix, \n                     offsetInBits, lengthInBits, first)) {\n                 throw new NoSuchElementException();\n                 e = lowerEntry(toKey);\n             }\n             \n-            K last = e != null ? e.getKey() : null;\n+            final K last = e != null ? e.getKey() : null;\n             if (e == null || !keyAnalyzer.isPrefix(prefix, \n                     offsetInBits, lengthInBits, last)) {\n                 throw new NoSuchElementException();\n          * of the provided key.\n          */\n         @Override\n-        protected boolean inRange(K key) {\n+        protected boolean inRange(final K key) {\n             return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n         }\n \n          * Same as {@link #inRange(Object)}\n          */\n         @Override\n-        protected boolean inRange2(K key) {\n+        protected boolean inRange2(final K key) {\n             return inRange(key);\n         }\n         \n          * of the {@link PrefixRangeMap}\n          */\n         @Override\n-        protected boolean inFromRange(K key, boolean forceInclusive) {\n+        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n             return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n         }\n         \n          * of the {@link PrefixRangeMap}\n          */\n         @Override\n-        protected boolean inToRange(K key, boolean forceInclusive) {\n+        protected boolean inToRange(final K key, final boolean forceInclusive) {\n             return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n         }\n         \n          */\n         @Override\n         protected SortedMap<K, V> createRangeMap(\n-                K fromKey, boolean fromInclusive,\n-                K toKey, boolean toInclusive) {\n+                final K fromKey, final boolean fromInclusive,\n+                final K toKey, final boolean toInclusive) {\n             return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n         }\n     }\n         /**\n          * Creates a {@link PrefixRangeEntrySet}\n          */\n-        public PrefixRangeEntrySet(PrefixRangeMap delegate) {\n+        public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n             super(delegate);\n             this.delegate = delegate;\n         }\n             }\n             \n             if (prefixStart == null) {\n-                Set<Map.Entry<K,V>> empty = Collections.emptySet();\n+                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n                 return empty.iterator();\n             } else if (delegate.lengthInBits >= prefixStart.bitIndex) {\n                 return new SingletonIterator(prefixStart);\n             \n             private int hit = 0;\n             \n-            public SingletonIterator(TrieEntry<K, V> entry) {\n+            public SingletonIterator(final TrieEntry<K, V> entry) {\n                 this.entry = entry;\n             }\n             \n              * Starts iteration at the given entry & search only \n              * within the given subtree.\n              */\n-            EntryIterator(TrieEntry<K, V> startScan, K prefix, \n-                    int offset, int lengthInBits) {\n+            EntryIterator(final TrieEntry<K, V> startScan, final K prefix, \n+                    final int offset, final int lengthInBits) {\n                 subtree = startScan;\n                 next = PatriciaTrie.this.followLeft(startScan);\n                 this.prefix = prefix;\n              * {@inheritDoc}\n              */\n             public Map.Entry<K,V> next() {\n-                Map.Entry<K, V> entry = nextEntry();\n+                final Map.Entry<K, V> entry = nextEntry();\n                 if (lastOne) {\n                     next = null;\n                 }\n              * {@inheritDoc}\n              */\n             @Override\n-            protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior) {\n+            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                 return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n             }\n             \n                 // If the current entry we're removing is the subtree\n                 // then we need to find a new subtree parent.\n                 boolean needsFixing = false;\n-                int bitIdx = subtree.bitIndex;\n+                final int bitIdx = subtree.bitIndex;\n                 if (current == subtree) {\n                     needsFixing = true;\n                 }\n--- a/src/main/java/org/apache/commons/collections/trie/PatriciaTrieBase.java\n+++ b/src/main/java/org/apache/commons/collections/trie/PatriciaTrieBase.java\n     /** \n      * {@inheritDoc}\n      */\n-    public PatriciaTrieBase(KeyAnalyzer<? super K> keyAnalyzer) {\n+    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer) {\n         super(keyAnalyzer);\n     }\n     \n      * and initializes the {@link Trie} with the values from the \n      * provided {@link Map}.\n      */\n-    public PatriciaTrieBase(KeyAnalyzer<? super K> keyAnalyzer, \n-            Map<? extends K, ? extends V> m) {\n+    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer, \n+            final Map<? extends K, ? extends V> m) {\n         super(keyAnalyzer);\n         \n         if (m == null) {\n      * {@inheritDoc}\n      */\n     @Override\n-    public V put(K key, V value) {\n+    public V put(final K key, final V value) {\n         if (key == null) {\n             throw new NullPointerException(\"Key cannot be null\");\n         }\n         \n-        int lengthInBits = lengthInBits(key);\n+        final int lengthInBits = lengthInBits(key);\n         \n         // The only place to store a key with a length\n         // of zero bits is the root node\n             return root.setKeyValue(key, value);\n         }\n         \n-        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (compareKeys(key, found.key)) {\n             if (found.isEmpty()) { // <- must be the root\n                 incrementSize();\n             return found.setKeyValue(key, value);\n         }\n         \n-        int bitIndex = bitIndex(key, found.key);\n+        final int bitIndex = bitIndex(key, found.key);\n         if (!AbstractKeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n             if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n                 /* NEW KEY+VALUE TUPLE */\n-                TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n+                final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n                 addEntry(t, lengthInBits);\n                 incrementSize();\n                 return null;\n     /**\n      * Adds the given {@link TrieEntry} to the {@link Trie}\n      */\n-    TrieEntry<K, V> addEntry(TrieEntry<K, V> entry, int lengthInBits) {\n+    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while(true) {\n      * {@inheritDoc}\n      */\n     @Override\n-    public V get(Object k) {\n-        TrieEntry<K, V> entry = getEntry(k);\n+    public V get(final Object k) {\n+        final TrieEntry<K, V> entry = getEntry(k);\n         return entry != null ? entry.getValue() : null;\n     }\n \n      * \n      * This may throw ClassCastException if the object is not of type K.\n      */\n-    TrieEntry<K,V> getEntry(Object k) {\n-        K key = castKey(k);\n+    TrieEntry<K,V> getEntry(final Object k) {\n+        final K key = castKey(k);\n         if (key == null) {\n             return null;\n         }\n         \n-        int lengthInBits = lengthInBits(key);\n-        TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n+        final int lengthInBits = lengthInBits(key);\n+        final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n         return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n     }\n     \n     /**\n      * {@inheritDoc}\n      */\n-    public Map.Entry<K, V> select(K key) {\n-        int lengthInBits = lengthInBits(key);\n-        Reference<Map.Entry<K, V>> reference \n+    public Map.Entry<K, V> select(final K key) {\n+        final int lengthInBits = lengthInBits(key);\n+        final Reference<Map.Entry<K, V>> reference \n             = new Reference<Map.Entry<K,V>>();\n         if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n             return reference.get();\n     /**\n      * {@inheritDoc}\n      */\n-    public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor) {\n-        int lengthInBits = lengthInBits(key);\n-        Reference<Map.Entry<K, V>> reference \n+    public Map.Entry<K,V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n+        final int lengthInBits = lengthInBits(key);\n+        final Reference<Map.Entry<K, V>> reference \n             = new Reference<Map.Entry<K,V>>();\n         selectR(root.left, -1, key, lengthInBits, cursor, reference);\n         return reference.get();\n      * because we're selecting only one best matching Entry from the \n      * {@link Trie}.\n      */\n-    private boolean selectR(TrieEntry<K, V> h, int bitIndex, \n+    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, \n             final K key, final int lengthInBits, \n             final Reference<Map.Entry<K, V>> reference) {\n         \n     /**\n      * \n      */\n-    private boolean selectR(TrieEntry<K,V> h, int bitIndex, \n+    private boolean selectR(final TrieEntry<K,V> h, final int bitIndex, \n             final K key, \n             final int lengthInBits,\n             final Cursor<? super K, ? super V> cursor,\n \n         if (h.bitIndex <= bitIndex) {\n             if (!h.isEmpty()) {\n-                Decision decision = cursor.select(h);\n+                final Decision decision = cursor.select(h);\n                 switch(decision) {\n                     case REMOVE:\n                         throw new UnsupportedOperationException(\"Cannot remove during select\");\n                         reference.set(h);\n                         return false; // exit\n                     case REMOVE_AND_EXIT:\n-                        TrieEntry<K, V> entry = new TrieEntry<K, V>(\n+                        final TrieEntry<K, V> entry = new TrieEntry<K, V>(\n                                 h.getKey(), h.getValue(), -1);\n                         reference.set(entry);\n                         removeEntry(h);\n     /**\n      * {@inheritDoc}\n      */\n-    public Map.Entry<K, V> traverse(Cursor<? super K, ? super V> cursor) {\n+    public Map.Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n         TrieEntry<K, V> entry = nextEntry(null);\n         while (entry != null) {\n-            TrieEntry<K, V> current = entry;\n-            \n-            Decision decision = cursor.select(current);\n+            final TrieEntry<K, V> current = entry;\n+            \n+            final Decision decision = cursor.select(current);\n             entry = nextEntry(current);\n             \n             switch(decision) {\n                     removeEntry(current);\n                     break; // out of switch, stay in while loop\n                 case REMOVE_AND_EXIT:\n-                    Map.Entry<K, V> value = new TrieEntry<K, V>(\n+                    final Map.Entry<K, V> value = new TrieEntry<K, V>(\n                             current.getKey(), current.getValue(), -1);\n                     removeEntry(current);\n                     return value;\n      * {@inheritDoc}\n      */\n     @Override\n-    public boolean containsKey(Object k) {\n+    public boolean containsKey(final Object k) {\n         if (k == null) {\n             return false;\n         }\n         \n-        K key = castKey(k);\n-        int lengthInBits = lengthInBits(key);\n-        TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n+        final K key = castKey(k);\n+        final int lengthInBits = lengthInBits(key);\n+        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n         return !entry.isEmpty() && compareKeys(key, entry.key);\n     }\n     \n      * @throws ClassCastException if provided key is of an incompatible type \n      */\n     @Override\n-    public V remove(Object k) {\n+    public V remove(final Object k) {\n         if (k == null) {\n             return null;\n         }\n         \n-        K key = castKey(k);\n-        int lengthInBits = lengthInBits(key);        \n+        final K key = castKey(k);\n+        final int lengthInBits = lengthInBits(key);        \n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while (true) {\n      * selectR but with the exception that it might return the\n      * root Entry even if it's empty.\n      */\n-    TrieEntry<K, V> getNearestEntryForKey(K key, int lengthInBits) {\n+    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while(true) {\n      * an internal (hard to remove) or external Entry (easy \n      * to remove)\n      */\n-    V removeEntry(TrieEntry<K, V> h) {\n+    V removeEntry(final TrieEntry<K, V> h) {\n         if (h != root) {\n             if (h.isInternalNode()) {\n                 removeInternalEntry(h);\n      * If it's an external Entry then just remove it.\n      * This is very easy and straight forward.\n      */\n-    private void removeExternalEntry(TrieEntry<K, V> h) {\n+    private void removeExternalEntry(final TrieEntry<K, V> h) {\n         if (h == root) {\n             throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n         } else if (!h.isExternalNode()) {\n             throw new IllegalArgumentException(h + \" is not an external Entry!\");\n         } \n         \n-        TrieEntry<K, V> parent = h.parent;\n-        TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n+        final TrieEntry<K, V> parent = h.parent;\n+        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n         \n         if (parent.left == h) {\n             parent.left = child;\n      * this code. The Idea is essentially that Entry p takes Entry h's\n      * place in the trie which requires some re-wiring.\n      */\n-    private void removeInternalEntry(TrieEntry<K, V> h) {\n+    private void removeInternalEntry(final TrieEntry<K, V> h) {\n         if (h == root) {\n             throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n         } else if (!h.isInternalNode()) {\n             throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n         } \n         \n-        TrieEntry<K, V> p = h.predecessor;\n+        final TrieEntry<K, V> p = h.predecessor;\n         \n         // Set P's bitIndex\n         p.bitIndex = h.bitIndex;\n         \n         // Fix P's parent, predecessor and child Nodes\n         {\n-            TrieEntry<K, V> parent = p.parent;\n-            TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n+            final TrieEntry<K, V> parent = p.parent;\n+            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n             \n             // if it was looping to itself previously,\n             // it will now be pointed from it's parent\n      * Returns the entry lexicographically after the given entry.\n      * If the given entry is null, returns the first node.\n      */\n-    TrieEntry<K, V> nextEntry(TrieEntry<K, V> node) {\n+    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n         if (node == null) {\n             return firstEntry();\n         } else {\n      *    \n      * 7) Do Step 1 on the parent's right child.\n      */\n-    TrieEntry<K, V> nextEntryImpl(TrieEntry<K, V> start, \n-            TrieEntry<K, V> previous, TrieEntry<K, V> tree) {\n+    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, \n+            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n         \n         TrieEntry<K, V> current = start;\n \n     /** \n      * Returns true if 'next' is a valid uplink coming from 'from'. \n      */\n-    static boolean isValidUplink(TrieEntry<?, ?> next, TrieEntry<?, ?> from) { \n+    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) { \n         return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n     }\n     \n         \n         private E item;\n         \n-        public void set(E item) {\n+        public void set(final E item) {\n             this.item = item;\n         }\n         \n         /** The entry who uplinks to this entry. */ \n         protected TrieEntry<K,V> predecessor;\n         \n-        public TrieEntry(K key, V value, int bitIndex) {\n+        public TrieEntry(final K key, final V value, final int bitIndex) {\n             super(key, value);\n             \n             this.bitIndex = bitIndex;\n          */\n         @Override\n         public String toString() {\n-            StringBuilder buffer = new StringBuilder();\n+            final StringBuilder buffer = new StringBuilder();\n             \n             if (bitIndex == -1) {\n                 buffer.append(\"RootEntry(\");\n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean contains(Object o) {\n+        public boolean contains(final Object o) {\n             if (!(o instanceof Map.Entry)) {\n                 return false;\n             }\n             \n-            TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n+            final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n             return candidate != null && candidate.equals(o);\n         }\n         \n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean remove(Object o) {\n-            int size = size();\n+        public boolean remove(final Object o) {\n+            final int size = size();\n             PatriciaTrieBase.this.remove(o);\n             return size != size();\n         }\n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean contains(Object o) {\n+        public boolean contains(final Object o) {\n             return containsKey(o);\n         }\n         \n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean remove(Object o) {\n-            int size = size();\n+        public boolean remove(final Object o) {\n+            final int size = size();\n             PatriciaTrieBase.this.remove(o);\n             return size != size();\n         }\n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean contains(Object o) {\n+        public boolean contains(final Object o) {\n             return containsValue(o);\n         }\n         \n          * {@inheritDoc}\n          */\n         @Override\n-        public boolean remove(Object o) {\n-            for (Iterator<V> it = iterator(); it.hasNext(); ) {\n-                V value = it.next();\n+        public boolean remove(final Object o) {\n+            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n+                final V value = it.next();\n                 if (compare(value, o)) {\n                     it.remove();\n                     return true;\n         /**\n          * Starts iteration at the given entry\n          */\n-        protected TrieIterator(TrieEntry<K, V> firstEntry) {\n+        protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n             next = firstEntry;\n         }\n         \n                 throw new ConcurrentModificationException();\n             }\n             \n-            TrieEntry<K,V> e = next;\n+            final TrieEntry<K,V> e = next;\n             if (e == null) {\n                 throw new NoSuchElementException();\n             }\n         /**\n          * @see PatriciaTrie#nextEntry(TrieEntry)\n          */\n-        protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior) {\n+        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n             return PatriciaTrieBase.this.nextEntry(prior);\n         }\n         \n                 throw new ConcurrentModificationException();\n             }\n             \n-            TrieEntry<K, V> node = current;\n+            final TrieEntry<K, V> node = current;\n             current = null;\n             PatriciaTrieBase.this.removeEntry(node);\n             \n--- a/src/main/java/org/apache/commons/collections/trie/ShortKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/ShortKeyAnalyzer.java\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static int mask(int bit) {\n+    private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(Short key) {\n+    public int lengthInBits(final Short key) {\n         return LENGTH;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(Short key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final Short key, final int bitIndex, final int lengthInBits) {\n         return (key & mask(bitIndex)) != 0;\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(Short key, int offsetInBits, int lengthInBits, \n-            Short other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final Short key, final int offsetInBits, final int lengthInBits, \n+            final Short other, final int otherOffsetInBits, final int otherLengthInBits) {\n         \n         if (offsetInBits != 0 || otherOffsetInBits != 0) {\n             throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n                     + \", otherOffsetInBits=\" + otherOffsetInBits);\n         }\n         \n-        int keyValue = key.shortValue();\n+        final int keyValue = key.shortValue();\n         if (keyValue == 0) {\n             return NULL_BIT_KEY;\n         }\n \n-        int otherValue = other != null ? other.shortValue() : 0;\n+        final int otherValue = other != null ? other.shortValue() : 0;\n         \n         if (keyValue != otherValue) {\n-            int xorValue = keyValue ^ otherValue;\n+            final int xorValue = keyValue ^ otherValue;\n             for (int i = 0; i < LENGTH; i++) {\n                 if ((xorValue & mask(i)) != 0) {\n                     return i;\n     /**\n      * {@inheritDoc}\n      */\n-    public int compare(Short o1, Short o2) {\n+    public int compare(final Short o1, final Short o2) {\n         return o1.compareTo(o2);\n     }\n     \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(Short prefix, int offsetInBits, \n-            int lengthInBits, Short key) {\n+    public boolean isPrefix(final Short prefix, final int offsetInBits, \n+            final int lengthInBits, final Short key) {\n         \n-        int value1 = prefix.shortValue() << offsetInBits;\n-        int value2 = key.shortValue();\n+        final int value1 = prefix.shortValue() << offsetInBits;\n+        final int value2 = key.shortValue();\n         \n         int mask = 0;\n         for (int i = 0; i < lengthInBits; i++) {\n--- a/src/main/java/org/apache/commons/collections/trie/StringKeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections/trie/StringKeyAnalyzer.java\n     /**\n      * Returns a bit mask where the given bit is set\n      */\n-    private static int mask(int bit) {\n+    private static int mask(final int bit) {\n         return MSB >>> bit;\n     }\n     \n     /**\n      * {@inheritDoc}\n      */\n-    public int lengthInBits(String key) {\n+    public int lengthInBits(final String key) {\n         return key != null ? key.length() * LENGTH : 0;\n     }\n     \n     /**\n      * {@inheritDoc}\n      */\n-    public int bitIndex(String key, int offsetInBits, int lengthInBits,\n-            String other, int otherOffsetInBits, int otherLengthInBits) {\n+    public int bitIndex(final String key, final int offsetInBits, final int lengthInBits,\n+            final String other, final int otherOffsetInBits, final int otherLengthInBits) {\n         boolean allNull = true;\n         \n         if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 \n         }\n         \n         \n-        int beginIndex1 = offsetInBits / LENGTH;\n-        int beginIndex2 = otherOffsetInBits / LENGTH;\n+        final int beginIndex1 = offsetInBits / LENGTH;\n+        final int beginIndex2 = otherOffsetInBits / LENGTH;\n         \n-        int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n-        int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+        final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n         \n-        int length = Math.max(endIndex1, endIndex2);\n+        final int length = Math.max(endIndex1, endIndex2);\n         \n         // Look at each character, and if they're different\n         // then figure out which bit makes the difference\n         // and return it.\n         char k = 0, f = 0;\n         for(int i = 0; i < length; i++) {\n-            int index1 = beginIndex1 + i;\n-            int index2 = beginIndex2 + i;\n+            final int index1 = beginIndex1 + i;\n+            final int index2 = beginIndex2 + i;\n             \n             if (index1 >= endIndex1) {\n                 k = 0;\n             }\n             \n             if (k != f) {\n-               int x = k ^ f;\n+               final int x = k ^ f;\n                return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n             }\n             \n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isBitSet(String key, int bitIndex, int lengthInBits) {\n+    public boolean isBitSet(final String key, final int bitIndex, final int lengthInBits) {\n         if (key == null || bitIndex >= lengthInBits) {\n             return false;\n         }\n         \n-        int index = bitIndex / LENGTH;\n-        int bit = bitIndex % LENGTH;\n+        final int index = bitIndex / LENGTH;\n+        final int bit = bitIndex % LENGTH;\n         \n         return (key.charAt(index) & mask(bit)) != 0;\n     }\n     /**\n      * {@inheritDoc}\n      */\n-    public boolean isPrefix(String prefix, int offsetInBits, \n-            int lengthInBits, String key) {\n+    public boolean isPrefix(final String prefix, final int offsetInBits, \n+            final int lengthInBits, final String key) {\n         if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n             throw new IllegalArgumentException(\n                     \"Cannot determine prefix outside of Character boundaries\");\n         }\n     \n-        String s1 = prefix.substring(offsetInBits / LENGTH, lengthInBits / LENGTH);\n+        final String s1 = prefix.substring(offsetInBits / LENGTH, lengthInBits / LENGTH);\n         return key.startsWith(s1);\n     }\n }\n--- a/src/main/java/org/apache/commons/collections/trie/SynchronizedTrie.java\n+++ b/src/main/java/org/apache/commons/collections/trie/SynchronizedTrie.java\n      * @return a new synchronized trie\n      * @throws IllegalArgumentException if trie is null\n      */\n-    public static <K, V> SynchronizedTrie<K, V> synchronizedTrie(Trie<K, V> trie) {\n+    public static <K, V> SynchronizedTrie<K, V> synchronizedTrie(final Trie<K, V> trie) {\n         return new SynchronizedTrie<K, V>(trie);\n     }\n \n      * @param trie  the trie to decorate, must not be null\n      * @throws IllegalArgumentException if set is null\n      */\n-    public SynchronizedTrie(Trie<K, V> trie) {\n+    public SynchronizedTrie(final Trie<K, V> trie) {\n         if (trie == null) {\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n         this.delegate = trie;\n     }\n \n-    public synchronized Entry<K, V> select(K key, Cursor<? super K, ? super V> cursor) {\n+    public synchronized Entry<K, V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n         return delegate.select(key, cursor);\n     }\n \n-    public synchronized Entry<K, V> select(K key) {\n+    public synchronized Entry<K, V> select(final K key) {\n         return delegate.select(key);\n     }\n \n-    public synchronized K selectKey(K key) {\n+    public synchronized K selectKey(final K key) {\n         return delegate.selectKey(key);\n     }\n \n-    public synchronized V selectValue(K key) {\n+    public synchronized V selectValue(final K key) {\n         return delegate.selectValue(key);\n     }\n \n-    public synchronized Entry<K, V> traverse(Cursor<? super K, ? super V> cursor) {\n+    public synchronized Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n         return delegate.traverse(cursor);\n     }\n     \n         delegate.clear();\n     }\n \n-    public synchronized boolean containsKey(Object key) {\n+    public synchronized boolean containsKey(final Object key) {\n         return delegate.containsKey(key);\n     }\n \n-    public synchronized boolean containsValue(Object value) {\n+    public synchronized boolean containsValue(final Object value) {\n         return delegate.containsValue(value);\n     }\n \n-    public synchronized V get(Object key) {\n+    public synchronized V get(final Object key) {\n         return delegate.get(key);\n     }\n \n         return delegate.isEmpty();\n     }\n \n-    public synchronized V put(K key, V value) {\n+    public synchronized V put(final K key, final V value) {\n         return delegate.put(key, value);\n     }\n \n-    public synchronized void putAll(Map<? extends K, ? extends V> m) {\n+    public synchronized void putAll(final Map<? extends K, ? extends V> m) {\n         delegate.putAll(m);\n     }\n \n-    public synchronized V remove(Object key) {\n+    public synchronized V remove(final Object key) {\n         return delegate.remove(key);\n     }\n     \n         return delegate.lastKey();\n     }\n \n-    public synchronized SortedMap<K, V> subMap(K fromKey, K toKey) {\n+    public synchronized SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return Collections.synchronizedSortedMap(delegate.subMap(fromKey, toKey));\n     }\n \n-    public synchronized SortedMap<K, V> tailMap(K fromKey) {\n+    public synchronized SortedMap<K, V> tailMap(final K fromKey) {\n         return Collections.synchronizedSortedMap(delegate.tailMap(fromKey));\n     }\n     \n         return delegate.firstKey();\n     }\n \n-    public synchronized SortedMap<K, V> headMap(K toKey) {\n+    public synchronized SortedMap<K, V> headMap(final K toKey) {\n         return Collections.synchronizedSortedMap(delegate.headMap(toKey));\n     }\n     \n-    public synchronized SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n+    public synchronized SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, offset, length));\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedBy(K key, int length) {\n+    public synchronized SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, length));\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedBy(K key) {\n+    public synchronized SortedMap<K, V> getPrefixedBy(final K key) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key));\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n+    public synchronized SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedByBits(K key, \n-            int offsetInBits, int lengthInBits) {\n+    public synchronized SortedMap<K, V> getPrefixedByBits(final K key, \n+            final int offsetInBits, final int lengthInBits) {\n         return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n     }\n \n     }\n     \n     @Override\n-    public synchronized boolean equals(Object obj) {\n+    public synchronized boolean equals(final Object obj) {\n         return delegate.equals(obj);\n     }\n     \n--- a/src/main/java/org/apache/commons/collections/trie/UnmodifiableTrie.java\n+++ b/src/main/java/org/apache/commons/collections/trie/UnmodifiableTrie.java\n      * @return a new unmodifiable trie\n      * @throws IllegalArgumentException if trie is null\n      */\n-    public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(Trie<K, V> trie) {\n+    public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, V> trie) {\n         return new UnmodifiableTrie<K, V>(trie);\n     }\n \n      * @param trie  the trie to decorate, must not be null\n      * @throws IllegalArgumentException if trie is null\n      */\n-    public UnmodifiableTrie(Trie<K, V> trie) {\n+    public UnmodifiableTrie(final Trie<K, V> trie) {\n         if (trie == null) {\n             throw new IllegalArgumentException(\"Trie must not be null\");\n         }\n         this.delegate = trie;\n     }\n     \n-    public Entry<K, V> select(K key, final Cursor<? super K, ? super V> cursor) {\n-        Cursor<K, V> c = new Cursor<K, V>() {\n-            public Decision select(Map.Entry<? extends K, ? extends V> entry) {\n-                Decision decision = cursor.select(entry);\n+    public Entry<K, V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n+        final Cursor<K, V> c = new Cursor<K, V>() {\n+            public Decision select(final Map.Entry<? extends K, ? extends V> entry) {\n+                final Decision decision = cursor.select(entry);\n                 switch (decision) {\n                     case REMOVE:\n                     case REMOVE_AND_EXIT:\n         return delegate.select(key, c);\n     }\n \n-    public Entry<K, V> select(K key) {\n+    public Entry<K, V> select(final K key) {\n         return delegate.select(key);\n     }\n \n-    public K selectKey(K key) {\n+    public K selectKey(final K key) {\n         return delegate.selectKey(key);\n     }\n \n-    public V selectValue(K key) {\n+    public V selectValue(final K key) {\n         return delegate.selectValue(key);\n     }\n \n     public Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n-        Cursor<K, V> c = new Cursor<K, V>() {\n-            public Decision select(Map.Entry<? extends K, ? extends V> entry) {\n-                Decision decision = cursor.select(entry);\n+        final Cursor<K, V> c = new Cursor<K, V>() {\n+            public Decision select(final Map.Entry<? extends K, ? extends V> entry) {\n+                final Decision decision = cursor.select(entry);\n                 switch (decision) {\n                     case REMOVE:\n                     case REMOVE_AND_EXIT:\n         throw new UnsupportedOperationException();\n     }\n \n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         return delegate.containsKey(key);\n     }\n \n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         return delegate.containsValue(value);\n     }\n \n-    public V get(Object key) {\n+    public V get(final Object key) {\n         return delegate.get(key);\n     }\n \n         return delegate.isEmpty();\n     }\n \n-    public V put(K key, V value) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public void putAll(Map<? extends K, ? extends V> m) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    public V remove(Object key) {\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void putAll(final Map<? extends K, ? extends V> m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public V remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n         return delegate.firstKey();\n     }\n \n-    public SortedMap<K, V> headMap(K toKey) {\n+    public SortedMap<K, V> headMap(final K toKey) {\n         return Collections.unmodifiableSortedMap(delegate.headMap(toKey));\n     }\n \n         return delegate.lastKey();\n     }\n \n-    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.subMap(fromKey, toKey));\n     }\n \n-    public SortedMap<K, V> tailMap(K fromKey) {\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n         return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n     }\n     \n-    public SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n+    public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedBy(key, offset, length));\n     }\n \n-    public SortedMap<K, V> getPrefixedBy(K key, int length) {\n+    public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedBy(key, length));\n     }\n \n-    public SortedMap<K, V> getPrefixedBy(K key) {\n+    public SortedMap<K, V> getPrefixedBy(final K key) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedBy(key));\n     }\n \n-    public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n         return Collections.unmodifiableSortedMap(\n                 delegate.getPrefixedByBits(key, lengthInBits));\n     }\n     \n-    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits) {\n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n         return Collections.unmodifiableSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n     }\n \n     }\n     \n     @Override\n-    public boolean equals(Object obj) {\n+    public boolean equals(final Object obj) {\n         return delegate.equals(obj);\n     }\n     \n--- a/src/test/java/org/apache/commons/collections/AbstractArrayListTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractArrayListTest.java\n  */\n public abstract class AbstractArrayListTest<E> extends AbstractListTest<E> {\n \n-    public AbstractArrayListTest(String testName) {\n+    public AbstractArrayListTest(final String testName) {\n         super(testName);\n     }\n \n \n     //-----------------------------------------------------------------------\n     public void testNewArrayList() {\n-        ArrayList<E> list = makeObject();\n+        final ArrayList<E> list = makeObject();\n         assertTrue(\"New list is empty\", list.isEmpty());\n         assertEquals(\"New list has size zero\", 0, list.size());\n \n         try {\n             list.get(1);\n             fail(\"get(int i) should have thrown IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // Expected result\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSearch() {\n-        ArrayList<E> list = makeObject();\n+        final ArrayList<E> list = makeObject();\n         list.add((E) \"First Item\");\n         list.add((E) \"Last Item\");\n         assertEquals(\"First item is 'First Item'\", \"First Item\", list.get(0));\n--- a/src/test/java/org/apache/commons/collections/AbstractLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractLinkedListTest.java\n  */\n public abstract class AbstractLinkedListTest<T> extends AbstractListTest<T> {\n \n-    public AbstractLinkedListTest(String testName) {\n+    public AbstractLinkedListTest(final String testName) {\n         super(testName);\n     }\n \n         if (!isAddSupported()) {\n             return;\n         }\n-        T o = (T) \"hello\";\n+        final T o = (T) \"hello\";\n \n         resetEmpty();\n         getCollection().addFirst(o);\n         if (!isAddSupported()) {\n             return;\n         }\n-        T o = (T) \"hello\";\n+        final T o = (T) \"hello\";\n \n         resetEmpty();\n         getCollection().addLast(o);\n             getCollection().getFirst();\n             fail(\"getFirst() should throw a NoSuchElementException for an \" +\n                     \"empty list.\");\n-        } catch (NoSuchElementException e) {\n-            // This is correct\n-        }\n-        verify();\n-\n-        resetFull();\n-        Object first = getCollection().getFirst();\n-        Object confirmedFirst = getConfirmedLinkedList().getFirst();\n+        } catch (final NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        final Object first = getCollection().getFirst();\n+        final Object confirmedFirst = getConfirmedLinkedList().getFirst();\n         assertEquals(\"Result returned by getFirst() was wrong.\",\n                 confirmedFirst, first);\n         verify();\n             getCollection().getLast();\n             fail(\"getLast() should throw a NoSuchElementException for an \" +\n                     \"empty list.\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             // This is correct\n         }\n         verify();\n         \n         resetFull();\n-        Object last = getCollection().getLast();\n-        Object confirmedLast = getConfirmedLinkedList().getLast();\n+        final Object last = getCollection().getLast();\n+        final Object confirmedLast = getConfirmedLinkedList().getLast();\n         assertEquals(\"Result returned by getLast() was wrong.\",\n                 confirmedLast, last);\n         verify();\n             getCollection().removeFirst();\n             fail(\"removeFirst() should throw a NoSuchElementException for \" +\n                     \"an empty list.\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             // This is correct\n         }\n         verify();\n         \n         resetFull();\n-        Object first = getCollection().removeFirst();\n-        Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n+        final Object first = getCollection().removeFirst();\n+        final Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n         assertEquals(\"Result returned by removeFirst() was wrong.\",\n                 confirmedFirst, first);\n         verify();\n             getCollection().removeLast();\n             fail(\"removeLast() should throw a NoSuchElementException for \" +\n                     \"an empty list.\");\n-        } catch (NoSuchElementException e) {\n-            // This is correct\n-        }\n-        verify();\n-\n-        resetFull();\n-        Object last = getCollection().removeLast();\n-        Object confirmedLast = getConfirmedLinkedList().removeLast();\n+        } catch (final NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        final Object last = getCollection().removeLast();\n+        final Object confirmedLast = getConfirmedLinkedList().removeLast();\n         assertEquals(\"Result returned by removeLast() was wrong.\",\n                 confirmedLast, last);\n         verify();\n      */\n     @Override\n     public Collection<T> makeConfirmedFullCollection() {\n-        List<T> list = new LinkedList<T>();\n+        final List<T> list = new LinkedList<T>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n--- a/src/test/java/org/apache/commons/collections/AbstractObjectTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractObjectTest.java\n      * \n      * @param testName  the test class name\n      */\n-    public AbstractObjectTest(String testName) {\n+    public AbstractObjectTest(final String testName) {\n         super(testName);\n     }\n \n \n     //-----------------------------------------------------------------------\n     public void testObjectEqualsSelf() {\n-        Object obj = makeObject();\n+        final Object obj = makeObject();\n         assertEquals(\"A Object should equal itself\", obj, obj);\n     }\n \n     public void testEqualsNull() {\n-        Object obj = makeObject();\n+        final Object obj = makeObject();\n         assertEquals(false, obj.equals(null)); // make sure this doesn't throw NPE either\n     }\n \n     public void testObjectHashCodeEqualsSelfHashCode() {\n-        Object obj = makeObject();\n+        final Object obj = makeObject();\n         assertEquals(\"hashCode should be repeatable\", obj.hashCode(), obj.hashCode());\n     }\n \n     public void testObjectHashCodeEqualsContract() {\n-        Object obj1 = makeObject();\n+        final Object obj1 = makeObject();\n         if (obj1.equals(obj1)) {\n             assertEquals(\n                 \"[1] When two objects are equal, their hashCodes should be also.\",\n                 obj1.hashCode(), obj1.hashCode());\n         }\n-        Object obj2 = makeObject();\n+        final Object obj2 = makeObject();\n         if (obj1.equals(obj2)) {\n             assertEquals(\n                 \"[2] When two objects are equal, their hashCodes should be also.\",\n         }\n     }\n \n-    protected Object serializeDeserialize(Object obj) throws Exception {\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+    protected Object serializeDeserialize(final Object obj) throws Exception {\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n         out.writeObject(obj);\n         out.close();\n \n-        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n-        Object dest = in.readObject();\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final Object dest = in.readObject();\n         in.close();\n \n         return dest;\n     }\n \n     public void testSerializeDeserializeThenCompare() throws Exception {\n-        Object obj = makeObject();\n+        final Object obj = makeObject();\n         if (obj instanceof Serializable && isTestSerialization()) {\n-            Object dest = serializeDeserialize(obj);\n+            final Object dest = serializeDeserialize(obj);\n             if (isEqualsCheckable()) {\n                 assertEquals(\"obj != deserialize(serialize(obj))\", obj, dest);\n             }\n      * @throws ClassNotFoundException\n      */\n     public void testSimpleSerialization() throws Exception {\n-        Object o = makeObject();\n+        final Object o = makeObject();\n         if (o instanceof Serializable && isTestSerialization()) {\n-            byte[] objekt = writeExternalFormToBytes((Serializable) o);\n+            final byte[] objekt = writeExternalFormToBytes((Serializable) o);\n             readExternalFormFromBytes(objekt);\n         }\n     }\n      */\n     public void testCanonicalEmptyCollectionExists() {\n         if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n-            Object object = makeObject();\n+            final Object object = makeObject();\n             if (object instanceof Serializable) {\n-                String name = getCanonicalEmptyCollectionName(object);\n+                final String name = getCanonicalEmptyCollectionName(object);\n                 assertTrue(\n                     \"Canonical empty collection (\" + name + \") is not in SVN\",\n                     new File(name).exists());\n      */\n     public void testCanonicalFullCollectionExists() {\n         if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n-            Object object = makeObject();\n+            final Object object = makeObject();\n             if (object instanceof Serializable) {\n-                String name = getCanonicalFullCollectionName(object);\n+                final String name = getCanonicalFullCollectionName(object);\n                 assertTrue(\n                     \"Canonical full collection (\" + name + \") is not in SVN\",\n                     new File(name).exists());\n         return \"1\";\n     }\n \n-    protected String getCanonicalEmptyCollectionName(Object object) {\n-        StringBuilder retval = new StringBuilder();\n+    protected String getCanonicalEmptyCollectionName(final Object object) {\n+        final StringBuilder retval = new StringBuilder();\n         retval.append(TEST_DATA_PATH);\n         String colName = object.getClass().getName();\n         colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n         return retval.toString();\n     }\n \n-    protected String getCanonicalFullCollectionName(Object object) {\n-        StringBuilder retval = new StringBuilder();\n+    protected String getCanonicalFullCollectionName(final Object object) {\n+        final StringBuilder retval = new StringBuilder();\n         retval.append(TEST_DATA_PATH);\n         String colName = object.getClass().getName();\n         colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n      * @param path path to write the serialized Object\n      * @exception IOException\n      */\n-    protected void writeExternalFormToDisk(Serializable o, String path) throws IOException {\n-        FileOutputStream fileStream = new FileOutputStream(path);\n+    protected void writeExternalFormToDisk(final Serializable o, final String path) throws IOException {\n+        final FileOutputStream fileStream = new FileOutputStream(path);\n         writeExternalFormToStream(o, fileStream);\n     }\n \n      * @return serialized form of the Object\n      * @exception IOException\n      */\n-    protected byte[] writeExternalFormToBytes(Serializable o) throws IOException {\n-        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n+    protected byte[] writeExternalFormToBytes(final Serializable o) throws IOException {\n+        final ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n         writeExternalFormToStream(o, byteStream);\n         return byteStream.toByteArray();\n     }\n      * @exception IOException\n      * @exception ClassNotFoundException\n      */\n-    protected Object readExternalFormFromDisk(String path) throws IOException, ClassNotFoundException {\n-        FileInputStream stream = new FileInputStream(path);\n+    protected Object readExternalFormFromDisk(final String path) throws IOException, ClassNotFoundException {\n+        final FileInputStream stream = new FileInputStream(path);\n         return readExternalFormFromStream(stream);\n     }\n \n      * @exception IOException\n      * @exception ClassNotFoundException\n      */\n-    protected Object readExternalFormFromBytes(byte[] b) throws IOException, ClassNotFoundException {\n-        ByteArrayInputStream stream = new ByteArrayInputStream(b);\n+    protected Object readExternalFormFromBytes(final byte[] b) throws IOException, ClassNotFoundException {\n+        final ByteArrayInputStream stream = new ByteArrayInputStream(b);\n         return readExternalFormFromStream(stream);\n     }\n \n \n     // private implementation\n     //-----------------------------------------------------------------------\n-    private Object readExternalFormFromStream(InputStream stream) throws IOException, ClassNotFoundException {\n-        ObjectInputStream oStream = new ObjectInputStream(stream);\n+    private Object readExternalFormFromStream(final InputStream stream) throws IOException, ClassNotFoundException {\n+        final ObjectInputStream oStream = new ObjectInputStream(stream);\n         return oStream.readObject();\n     }\n \n-    private void writeExternalFormToStream(Serializable o, OutputStream stream) throws IOException {\n-        ObjectOutputStream oStream = new ObjectOutputStream(stream);\n+    private void writeExternalFormToStream(final Serializable o, final OutputStream stream) throws IOException {\n+        final ObjectOutputStream oStream = new ObjectOutputStream(stream);\n         oStream.writeObject(o);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/AbstractTreeMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractTreeMapTest.java\n  */\n public abstract class AbstractTreeMapTest<K, V> extends AbstractMapTest<K, V> {\n \n-    public AbstractTreeMapTest(String testName) {\n+    public AbstractTreeMapTest(final String testName) {\n         super(testName);\n     }\n \n     public abstract TreeMap<K, V> makeObject();\n \n     public void testNewMap() {\n-        TreeMap<K, V> map = makeObject();\n+        final TreeMap<K, V> map = makeObject();\n         assertTrue(\"New map is empty\", map.isEmpty());\n         assertEquals(\"New map has size zero\", 0, map.size());\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSearch() {\n-        TreeMap<K, V> map = makeObject();\n+        final TreeMap<K, V> map = makeObject();\n         map.put((K) \"first\", (V) \"First Item\");\n         map.put((K) \"second\", (V) \"Second Item\");\n         assertEquals(\"Top item is 'Second Item'\",\n--- a/src/test/java/org/apache/commons/collections/AbstractTypedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractTypedCollectionTest.java\n  */\n public abstract class AbstractTypedCollectionTest<T> extends BulkTest {\n \n-    public AbstractTypedCollectionTest(String name) {\n+    public AbstractTypedCollectionTest(final String name) {\n         super(name);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        Collection<T> c = typedCollection();\n-        Integer i = new Integer(3);\n+        final Collection<T> c = typedCollection();\n+        final Integer i = new Integer(3);\n         try {\n             c.add((T) i);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\", \n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        Collection<T> c = typedCollection();\n-        List<Object> elements = new ArrayList<Object>();\n+        final Collection<T> c = typedCollection();\n+        final List<Object> elements = new ArrayList<Object>();\n         elements.add(\"one\");\n         elements.add(\"two\");\n         elements.add(new Integer(3));\n         try {\n             c.addAll((Collection<? extends T>) elements);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\", \n--- a/src/test/java/org/apache/commons/collections/ArrayStackTest.java\n+++ b/src/test/java/org/apache/commons/collections/ArrayStackTest.java\n  */\n public class ArrayStackTest<E> extends AbstractArrayListTest<E> {\n     \n-    public ArrayStackTest(String testName) {\n+    public ArrayStackTest(final String testName) {\n         super(testName);\n     }\n \n \n     //-----------------------------------------------------------------------\n     public void testNewStack() {\n-        ArrayStack<E> stack = makeObject();\n+        final ArrayStack<E> stack = makeObject();\n         assertTrue(\"New stack is empty\", stack.empty());\n         assertEquals(\"New stack has size zero\", 0, stack.size());\n \n         try {\n             stack.peek();\n             fail(\"peek() should have thrown EmptyStackException\");\n-        } catch (EmptyStackException e) {\n+        } catch (final EmptyStackException e) {\n             // Expected result\n         }\n \n         try {\n             stack.pop();\n             fail(\"pop() should have thrown EmptyStackException\");\n-        } catch (EmptyStackException e) {\n+        } catch (final EmptyStackException e) {\n             // Expected result\n         }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testPushPeekPop() {\n-        ArrayStack<E> stack = makeObject();\n+        final ArrayStack<E> stack = makeObject();\n \n         stack.push((E) \"First Item\");\n         assertTrue(\"Stack is not empty\", !stack.empty());\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public void testSearch() {\n-        ArrayStack<E> stack = makeObject();\n+        final ArrayStack<E> stack = makeObject();\n \n         stack.push((E) \"First Item\");\n         stack.push((E) \"Second Item\");\n--- a/src/test/java/org/apache/commons/collections/BagUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/BagUtilsTest.java\n  */\n public class BagUtilsTest extends BulkTest {\n \n-    public BagUtilsTest(String name) {\n+    public BagUtilsTest(final String name) {\n         super(name);\n     }\n \n         try {\n             bag = BagUtils.synchronizedBag(null);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             bag = BagUtils.unmodifiableBag(null);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             bag = BagUtils.predicatedBag(null,truePredicate);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             bag = BagUtils.predicatedBag(new HashBag<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             bag = BagUtils.transformingBag(null, nopTransformer);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             bag = BagUtils.transformingBag(new HashBag<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null transformer.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             bag = BagUtils.synchronizedSortedBag(null);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             bag = BagUtils.unmodifiableSortedBag(null);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             bag = BagUtils.predicatedSortedBag(null, truePredicate);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             bag = BagUtils.predicatedSortedBag(new TreeBag<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             bag = BagUtils.transformingSortedBag(null, nopTransformer);\n             fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null transformer.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/BufferUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/BufferUtilsTest.java\n  */\n public class BufferUtilsTest extends BulkTest {\n \n-    public BufferUtilsTest(String name) {\n+    public BufferUtilsTest(final String name) {\n         super(name);\n     }\n \n     }\n \n     public void testpredicatedBuffer() {\n-        Predicate<Object> predicate = new Predicate<Object>() {\n-            public boolean evaluate(Object o) {\n+        final Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(final Object o) {\n                 return o instanceof String;\n             }\n         };\n         try {\n             buffer = BufferUtils.predicatedBuffer(new ArrayStack<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             buffer = BufferUtils.predicatedBuffer(null, predicate);\n             fail(\"Expecting IllegalArgumentException for null buffer.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/BulkTest.java\n+++ b/src/test/java/org/apache/commons/collections/BulkTest.java\n      *\n      *  @param name  the name of the simple test method to run\n      */\n-    public BulkTest(String name) {\n+    public BulkTest(final String name) {\n         super(name);\n         this.verboseName = getClass().getName();\n     }\n     public Object clone() {\n         try {\n             return super.clone();\n-        } catch (CloneNotSupportedException e) {\n+        } catch (final CloneNotSupportedException e) {\n             throw new Error(); // should never happen\n         }\n     }\n      *  @return  a {@link TestSuite} containing all the simple and bulk tests\n      *    defined by that class\n      */\n-    public static TestSuite makeSuite(Class<? extends BulkTest> c) {\n+    public static TestSuite makeSuite(final Class<? extends BulkTest> c) {\n         if (Modifier.isAbstract(c.getModifiers())) {\n             throw new IllegalArgumentException(\"Class must not be abstract.\");\n         }\n class BulkTestSuiteMaker {\n \n     /** The class that defines simple and bulk tests methods. */\n-    private Class<? extends BulkTest> startingClass;\n+    private final Class<? extends BulkTest> startingClass;\n \n     /** List of ignored simple test names. */\n     private List<String> ignored;\n      *\n      *  @param startingClass  the starting class\n      */     \n-    public BulkTestSuiteMaker(Class<? extends BulkTest> startingClass) {\n+    public BulkTestSuiteMaker(final Class<? extends BulkTest> startingClass) {\n         this.startingClass = startingClass;\n     }\n \n          this.prefix = getBaseName(startingClass);\n          result.setName(prefix);\n \n-         BulkTest bulk = makeFirstTestCase(startingClass);\n+         final BulkTest bulk = makeFirstTestCase(startingClass);\n          ignored = new ArrayList<String>();\n-         String[] s = bulk.ignoredTests();\n+         final String[] s = bulk.ignoredTests();\n          if (s != null) {\n              ignored.addAll(Arrays.asList(s));\n          }\n      *  @param bulk  An instance of the class that defines simple and bulk\n      *    tests for us to append\n      */\n-    void make(BulkTest bulk) {\n-        Class<? extends BulkTest> c = bulk.getClass();\n-        Method[] all = c.getMethods();\n-        for (Method element : all) {\n+    void make(final BulkTest bulk) {\n+        final Class<? extends BulkTest> c = bulk.getClass();\n+        final Method[] all = c.getMethods();\n+        for (final Method element : all) {\n             if (isTest(element)) {\n                 addTest(bulk, element);\n             }\n      *   and not have to worry about constructors.)\n      *  @param m  The simple test method\n      */\n-    void addTest(BulkTest bulk, Method m) {\n-        BulkTest bulk2 = (BulkTest)bulk.clone();\n+    void addTest(final BulkTest bulk, final Method m) {\n+        final BulkTest bulk2 = (BulkTest)bulk.clone();\n         bulk2.setName(m.getName());\n         bulk2.verboseName = prefix + \".\" + m.getName();\n         if (ignored.contains(bulk2.verboseName)) {\n      *  @param bulk  The instance of the class that defined the method\n      *  @param m  The bulk test method\n      */\n-    void addBulk(BulkTest bulk, Method m) {\n-        String verboseName = prefix + \".\" + m.getName();\n+    void addBulk(final BulkTest bulk, final Method m) {\n+        final String verboseName = prefix + \".\" + m.getName();\n         if (ignored.contains(verboseName)) {\n             return;\n         }\n             if (bulk2 == null) {\n                 return;\n             }\n-        } catch (InvocationTargetException ex) {\n+        } catch (final InvocationTargetException ex) {\n             ex.getTargetException().printStackTrace();\n             throw new Error(); // FIXME;\n-        } catch (IllegalAccessException ex) {\n+        } catch (final IllegalAccessException ex) {\n             ex.printStackTrace();\n             throw new Error(); // FIXME;\n         }\n \n         // Save current state on the stack.\n-        String oldPrefix = prefix;\n-        TestSuite oldResult = result;\n+        final String oldPrefix = prefix;\n+        final TestSuite oldResult = result;\n \n         prefix = prefix + \".\" + m.getName();\n         result = new TestSuite();\n      *  @param c  the class\n      *  @return the name of that class, minus any package names\n      */\n-    private static String getBaseName(Class<?> c) {\n+    private static String getBaseName(final Class<?> c) {\n         String name = c.getName();\n-        int p = name.lastIndexOf('.');\n+        final int p = name.lastIndexOf('.');\n         if (p > 0) {\n             name = name.substring(p + 1);\n         }\n     // These three methods are used to create a valid BulkTest instance\n     // from a class.\n \n-    private static <T> Constructor<T> getTestCaseConstructor(Class<T> c) {\n+    private static <T> Constructor<T> getTestCaseConstructor(final Class<T> c) {\n         try {\n             return c.getConstructor(new Class[] { String.class });\n-        } catch (NoSuchMethodException e) {\n+        } catch (final NoSuchMethodException e) {\n             throw new IllegalArgumentException(c + \" must provide \" +\n              \"a (String) constructor\");\n         }\n     }\n \n-    private static <T extends BulkTest> BulkTest makeTestCase(Class<T> c, Method m) {\n-        Constructor<T> con = getTestCaseConstructor(c);\n+    private static <T extends BulkTest> BulkTest makeTestCase(final Class<T> c, final Method m) {\n+        final Constructor<T> con = getTestCaseConstructor(c);\n         try {\n             return con.newInstance(new Object[] { m.getName() });\n-        } catch (InvocationTargetException e) {\n+        } catch (final InvocationTargetException e) {\n             e.printStackTrace();\n             throw new RuntimeException(); // FIXME;\n-        } catch (IllegalAccessException e) {\n+        } catch (final IllegalAccessException e) {\n             throw new Error(); // should never occur\n-        } catch (InstantiationException e) {\n+        } catch (final InstantiationException e) {\n             throw new RuntimeException(); // FIXME;\n         }\n     }\n \n-    private static <T extends BulkTest> BulkTest makeFirstTestCase(Class<T> c) {\n-        Method[] all = c.getMethods();\n-        for (Method element : all) {\n+    private static <T extends BulkTest> BulkTest makeFirstTestCase(final Class<T> c) {\n+        final Method[] all = c.getMethods();\n+        for (final Method element : all) {\n             if (isTest(element)) {\n                 return makeTestCase(c, element);\n             }\n     /**\n      *  Returns true if the given method is a simple test method.\n      */\n-    private static boolean isTest(Method m) {\n+    private static boolean isTest(final Method m) {\n         if (!m.getName().startsWith(\"test\")) {\n             return false;\n         }\n         if (m.getParameterTypes().length != 0) {\n             return false;\n         }\n-        int mods = m.getModifiers();\n+        final int mods = m.getModifiers();\n         if (Modifier.isStatic(mods)) {\n             return false;\n         }\n     /**\n      *  Returns true if the given method is a bulk test method.\n      */\n-    private static boolean isBulk(Method m) {\n+    private static boolean isBulk(final Method m) {\n         if (!m.getName().startsWith(\"bulkTest\")) {\n             return false;\n         }\n         if (m.getParameterTypes().length != 0) {\n             return false;\n         }\n-        int mods = m.getModifiers();\n+        final int mods = m.getModifiers();\n         if (Modifier.isStatic(mods)) {\n             return false;\n         }\n--- a/src/test/java/org/apache/commons/collections/ClosureUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/ClosureUtilsTest.java\n     /**\n      * Construct\n      */\n-    public ClosureUtilsTest(String name) {\n+    public ClosureUtilsTest(final String name) {\n         super(name);\n     }\n \n     static class MockClosure<T> implements Closure<T> {\n         int count = 0;\n \n-        public void execute(T object) {\n+        public void execute(final T object) {\n             count++;\n         }\n \n     static class MockTransformer<T> implements Transformer<T, T> {\n         int count = 0;\n \n-        public T transform(T object) {\n+        public T transform(final T object) {\n             count++;\n             return object;\n         }\n         assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());\n         try {\n             ClosureUtils.exceptionClosure().execute(null);\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             try {\n                 ClosureUtils.exceptionClosure().execute(cString);\n-            } catch (FunctorException ex2) {\n+            } catch (final FunctorException ex2) {\n                 return;\n             }\n         }\n     //------------------------------------------------------------------\n \n     public void testNopClosure() {\n-        StringBuilder buf = new StringBuilder(\"Hello\");\n+        final StringBuilder buf = new StringBuilder(\"Hello\");\n         ClosureUtils.nopClosure().execute(null);\n         assertEquals(\"Hello\", buf.toString());\n         ClosureUtils.nopClosure().execute(\"Hello\");\n     //------------------------------------------------------------------\n \n     public void testForClosure() {\n-        MockClosure<Object> cmd = new MockClosure<Object>();\n+        final MockClosure<Object> cmd = new MockClosure<Object>();\n         ClosureUtils.forClosure(5, cmd).execute(null);\n         assertEquals(5, cmd.count);\n         assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure<Object>()));\n         try {\n             ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.whileClosure(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // doWhileClosure\n         try {\n             ClosureUtils.doWhileClosure(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // chainedClosure\n         try {\n             ClosureUtils.chainedClosure(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.<Object>chainedClosure((Closure[]) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.<Object>chainedClosure(new Closure[] {null, null});\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             coll = new ArrayList<Closure<Object>>();\n             coll.add(null);\n             coll.add(null);\n             ClosureUtils.chainedClosure(coll);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // ifClosure\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSwitchClosure() {\n-        MockClosure<String> a = new MockClosure<String>();\n-        MockClosure<String> b = new MockClosure<String>();\n+        final MockClosure<String> a = new MockClosure<String>();\n+        final MockClosure<String> b = new MockClosure<String>();\n         ClosureUtils.<String>switchClosure(\n             new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n             new Closure[] { a, b }).execute(\"WELL\");\n \n         a.reset();\n         b.reset();\n-        MockClosure<String> c = new MockClosure<String>();\n+        final MockClosure<String> c = new MockClosure<String>();\n         ClosureUtils.<String>switchClosure(\n             new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n             new Closure[] { a, b }, c).execute(\"WELL\");\n \n         a.reset();\n         b.reset();\n-        Map<Predicate<String>, Closure<String>> map = new HashMap<Predicate<String>, Closure<String>>();\n+        final Map<Predicate<String>, Closure<String>> map = new HashMap<Predicate<String>, Closure<String>>();\n         map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n         map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n         ClosureUtils.<String>switchClosure(map).execute(null);\n         try {\n             ClosureUtils.switchClosure(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2]);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure(\n                     new Predicate[] { TruePredicate.<String>truePredicate() },\n                     new Closure[] { a, b });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // switchMapClosure\n     //------------------------------------------------------------------\n \n     public void testSwitchMapClosure() {\n-        MockClosure<String> a = new MockClosure<String>();\n-        MockClosure<String> b = new MockClosure<String>();\n-        Map<String, Closure<String>> map = new HashMap<String, Closure<String>>();\n+        final MockClosure<String> a = new MockClosure<String>();\n+        final MockClosure<String> b = new MockClosure<String>();\n+        final Map<String, Closure<String>> map = new HashMap<String, Closure<String>>();\n         map.put(\"HELLO\", a);\n         map.put(\"THERE\", b);\n         ClosureUtils.switchMapClosure(map).execute(null);\n         a.reset();\n         b.reset();\n         map.clear();\n-        MockClosure<String> c = new MockClosure<String>();\n+        final MockClosure<String> c = new MockClosure<String>();\n         map.put(\"HELLO\", a);\n         map.put(\"THERE\", b);\n         map.put(null, c);\n         try {\n             ClosureUtils.switchMapClosure(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // asClosure\n     //------------------------------------------------------------------\n \n     public void testTransformerClosure() {\n-        MockTransformer<Object> mock = new MockTransformer<Object>();\n-        Closure<Object> closure = ClosureUtils.asClosure(mock);\n+        final MockTransformer<Object> mock = new MockTransformer<Object>();\n+        final Closure<Object> closure = ClosureUtils.asClosure(mock);\n         closure.execute(null);\n         assertEquals(1, mock.count);\n         closure.execute(null);\n--- a/src/test/java/org/apache/commons/collections/CollectionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/CollectionUtilsTest.java\n         collectionB.add(2L);\n \n         collectionC = new ArrayList<Integer>();\n-        for (Long l : collectionB) {\n+        for (final Long l : collectionB) {\n             collectionC.add(l.intValue());\n         }\n \n \n     @Test\n     public void getCardinalityMap() {\n-        Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);\n+        final Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);\n         assertEquals(1, (int) freqA.get(1));\n         assertEquals(2, (int) freqA.get(2));\n         assertEquals(3, (int) freqA.get(3));\n         assertEquals(4, (int) freqA.get(4));\n         assertNull(freqA.get(5));\n \n-        Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);\n+        final Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);\n         assertNull(freqB.get(1L));\n         assertEquals(4, (int) freqB.get(2L));\n         assertEquals(3, (int) freqB.get(3L));\n         assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));\n         assertEquals(0, CollectionUtils.cardinality(2, iterableB2));\n \n-        Set<String> set = new HashSet<String>();\n+        final Set<String> set = new HashSet<String>();\n         set.add(\"A\");\n         set.add(\"C\");\n         set.add(\"E\");\n         assertEquals(0, CollectionUtils.cardinality(\"D\", set));\n         assertEquals(1, CollectionUtils.cardinality(\"E\", set));\n \n-        Bag<String> bag = new HashBag<String>();\n+        final Bag<String> bag = new HashBag<String>();\n         bag.add(\"A\", 3);\n         bag.add(\"C\");\n         bag.add(\"E\");\n \n     @Test\n     public void cardinalityOfNull() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         assertEquals(0, CollectionUtils.cardinality(null, list));\n         {\n-            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertNull(freq.get(null));\n         }\n         list.add(\"A\");\n         assertEquals(0, CollectionUtils.cardinality(null, list));\n         {\n-            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertNull(freq.get(null));\n         }\n         list.add(null);\n         assertEquals(1, CollectionUtils.cardinality(null, list));\n         {\n-            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertEquals(Integer.valueOf(1), freq.get(null));\n         }\n         list.add(\"B\");\n         assertEquals(1, CollectionUtils.cardinality(null, list));\n         {\n-            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertEquals(Integer.valueOf(1), freq.get(null));\n         }\n         list.add(null);\n         assertEquals(2, CollectionUtils.cardinality(null, list));\n         {\n-            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertEquals(Integer.valueOf(2), freq.get(null));\n         }\n         list.add(\"B\");\n         assertEquals(2, CollectionUtils.cardinality(null, list));\n         {\n-            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertEquals(Integer.valueOf(2), freq.get(null));\n         }\n         list.add(null);\n         assertEquals(3, CollectionUtils.cardinality(null, list));\n         {\n-            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n             assertEquals(Integer.valueOf(3), freq.get(null));\n         }\n     }\n \n     @Test\n     public void containsAny() {\n-        Collection<String> empty = new ArrayList<String>(0);\n-        Collection<String> one = new ArrayList<String>(1);\n+        final Collection<String> empty = new ArrayList<String>(0);\n+        final Collection<String> one = new ArrayList<String>(1);\n         one.add(\"1\");\n-        Collection<String> two = new ArrayList<String>(1);\n+        final Collection<String> two = new ArrayList<String>(1);\n         two.add(\"2\");\n-        Collection<String> three = new ArrayList<String>(1);\n+        final Collection<String> three = new ArrayList<String>(1);\n         three.add(\"3\");\n-        Collection<String> odds = new ArrayList<String>(2);\n+        final Collection<String> odds = new ArrayList<String>(2);\n         odds.add(\"1\");\n         odds.add(\"3\");\n \n \n     @Test\n     public void union() {\n-        Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);\n-        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        final Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n         assertEquals(Integer.valueOf(1), freq.get(1));\n         assertEquals(Integer.valueOf(4), freq.get(2));\n         assertEquals(Integer.valueOf(3), freq.get(3));\n         assertEquals(Integer.valueOf(4), freq.get(4));\n         assertEquals(Integer.valueOf(1), freq.get(5));\n \n-        Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);\n-        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        final Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n         assertEquals(Integer.valueOf(1), freq2.get(1));\n         assertEquals(Integer.valueOf(4), freq2.get(2));\n         assertEquals(Integer.valueOf(3), freq2.get(3));\n \n     @Test\n     public void intersection() {\n-        Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);\n-        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        final Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n         assertNull(freq.get(1));\n         assertEquals(Integer.valueOf(2), freq.get(2));\n         assertEquals(Integer.valueOf(3), freq.get(3));\n         assertEquals(Integer.valueOf(2), freq.get(4));\n         assertNull(freq.get(5));\n \n-        Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);\n-        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        final Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n         assertNull(freq2.get(1));\n         assertEquals(Integer.valueOf(2), freq2.get(2));\n         assertEquals(Integer.valueOf(3), freq2.get(3));\n \n     @Test\n     public void disjunction() {\n-        Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);\n-        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        final Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n         assertEquals(Integer.valueOf(1), freq.get(1));\n         assertEquals(Integer.valueOf(2), freq.get(2));\n         assertNull(freq.get(3));\n         assertEquals(Integer.valueOf(2), freq.get(4));\n         assertEquals(Integer.valueOf(1), freq.get(5));\n \n-        Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);\n-        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        final Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n         assertEquals(Integer.valueOf(1), freq2.get(1));\n         assertEquals(Integer.valueOf(2), freq2.get(2));\n         assertNull(freq2.get(3));\n \n     @Test\n     public void testDisjunctionAsUnionMinusIntersection() {\n-        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n-        Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);\n-        Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);\n+        final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        final Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);\n+        final Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);\n         assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));\n     }\n \n     @Test\n     public void testDisjunctionAsSymmetricDifference() {\n-        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n-        Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);\n-        Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);\n+        final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        final Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);\n+        final Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);\n         assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));\n     }\n \n     @Test\n     public void testSubtract() {\n-        Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);\n-        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        final Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n         assertEquals(Integer.valueOf(1), freq.get(1));\n         assertNull(freq.get(2));\n         assertNull(freq.get(3));\n         assertEquals(Integer.valueOf(2), freq.get(4));\n         assertNull(freq.get(5));\n \n-        Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);\n-        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        final Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n         assertEquals(Integer.valueOf(1), freq2.get(5));\n         assertNull(freq2.get(4));\n         assertNull(freq2.get(3));\n     @Test\n     public void testSubtractWithPredicate() {\n         // greater than 3\n-        Predicate<Number> predicate = new Predicate<Number>() {\n-            public boolean evaluate(Number n) {\n+        final Predicate<Number> predicate = new Predicate<Number>() {\n+            public boolean evaluate(final Number n) {\n                 return n.longValue() > 3L;\n             }\n         };\n         \n-        Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);\n-        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);\n+        final Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);\n         assertEquals(Integer.valueOf(1), freq2.get(1));\n         assertEquals(Integer.valueOf(2), freq2.get(2));\n         assertEquals(Integer.valueOf(3), freq2.get(3));\n \n     @Test\n     public void testIsSubCollection2() {\n-        Collection<Integer> c = new ArrayList<Integer>();\n+        final Collection<Integer> c = new ArrayList<Integer>();\n         assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n         assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n         c.add(1);\n \n     @Test\n     public void testIsEqualCollectionReturnsFalse() {\n-        List<Integer> b = new ArrayList<Integer>(collectionA);\n+        final List<Integer> b = new ArrayList<Integer>(collectionA);\n         // remove an extra '2', and add a 5.  This will increase the size of the cardinality\n         b.remove(1);\n         b.add(5);\n \n     @Test\n     public void testIsEqualCollection2() {\n-        Collection<String> a = new ArrayList<String>();\n-        Collection<String> b = new ArrayList<String>();\n+        final Collection<String> a = new ArrayList<String>();\n+        final Collection<String> b = new ArrayList<String>();\n         assertTrue(CollectionUtils.isEqualCollection(a, b));\n         assertTrue(CollectionUtils.isEqualCollection(b, a));\n         a.add(\"1\");\n \n     @Test\n     public void testIsProperSubCollection() {\n-        Collection<String> a = new ArrayList<String>();\n-        Collection<String> b = new ArrayList<String>();\n+        final Collection<String> a = new ArrayList<String>();\n+        final Collection<String> b = new ArrayList<String>();\n         assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n         b.add(\"1\");\n         assertTrue(CollectionUtils.isProperSubCollection(a, b));\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     @Test\n     public void forAllDoCollection() {\n-        Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n-        Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n         col.add(collectionA);\n         col.add(collectionB);\n         Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col, testClosure);\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     @Test\n     public void forAllDoIterator() {\n-        Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n-        Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n         col.add(collectionA);\n         col.add(collectionB);\n         Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col.iterator(), testClosure);\n     \n     @Test(expected = FunctorException.class)\n     public void forAllDoFailure() {\n-        Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n-        Collection<String> col = new ArrayList<String>();\n+        final Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<String> col = new ArrayList<String>();\n         col.add(\"x\");\n         CollectionUtils.forAllDo(col, testClosure);\n     }\n     @Test\n     public void getFromMap() {\n         // Unordered map, entries exist\n-        Map<String, String> expected = new HashMap<String, String>();\n+        final Map<String, String> expected = new HashMap<String, String>();\n         expected.put(\"zeroKey\", \"zero\");\n         expected.put(\"oneKey\", \"one\");\n \n-        Map<String, String> found = new HashMap<String, String>();\n+        final Map<String, String> found = new HashMap<String, String>();\n         Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);\n         found.put(entry.getKey(), entry.getValue());\n         entry = CollectionUtils.get(expected, 1);\n         try {\n             CollectionUtils.get(expected, 2);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         try {\n             CollectionUtils.get(expected, -2);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         // Sorted map, entries exist, should respect order\n-        SortedMap<String, String> map = new TreeMap<String, String>();\n+        final SortedMap<String, String> map = new TreeMap<String, String>();\n         map.put(\"zeroKey\", \"zero\");\n         map.put(\"oneKey\", \"one\");\n         Map.Entry<String, String> test = CollectionUtils.get(map, 1);\n     @Test(expected=IndexOutOfBoundsException.class)\n     public void getFromList() throws Exception {\n         // List, entry exists\n-        List<String> list = createMock(List.class);\n+        final List<String> list = createMock(List.class);\n         expect(list.get(0)).andReturn(\"zero\");\n         expect(list.get(1)).andReturn(\"one\");\n         replay();\n-        String string = CollectionUtils.get(list, 0);\n+        final String string = CollectionUtils.get(list, 0);\n         assertEquals(\"zero\", string);\n         assertEquals(\"one\", CollectionUtils.get(list, 1));\n         // list, non-existent entry -- IndexOutOfBoundsException\n         try {\n             CollectionUtils.get(iterator, 10);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         assertTrue(!iterator.hasNext());\n     @Test\n     public void getFromEnumeration() throws Exception {\n         // Enumeration, entry exists\n-        Vector<String> vector = new Vector<String>();\n+        final Vector<String> vector = new Vector<String>();\n         vector.addElement(\"zero\");\n         vector.addElement(\"one\");\n         Enumeration<String> en = vector.elements();\n         try {\n             CollectionUtils.get(en, 3);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n         assertTrue(!en.hasMoreElements());\n     @Test(expected = IndexOutOfBoundsException.class)\n     public void getFromIterable() throws Exception {\n         // Collection, entry exists\n-        Bag<String> bag = new HashBag<String>();\n+        final Bag<String> bag = new HashBag<String>();\n         bag.add(\"element\", 1);\n         assertEquals(\"element\", CollectionUtils.get(bag, 0));\n \n     @Test(expected = IndexOutOfBoundsException.class)\n     public void getFromObjectArray() throws Exception {\n         // Object array, entry exists\n-        Object[] objArray = new Object[2];\n+        final Object[] objArray = new Object[2];\n         objArray[0] = \"zero\";\n         objArray[1] = \"one\";\n         assertEquals(\"zero\", CollectionUtils.get(objArray, 0));\n     @Test(expected = IndexOutOfBoundsException.class)\n     public void getFromPrimativeArray() throws Exception {\n         // Primitive array, entry exists\n-        int[] array = new int[2];\n+        final int[] array = new int[2];\n         array[0] = 10;\n         array[1] = 20;\n         assertEquals(10, CollectionUtils.get(array, 0));\n     @Test(expected=IllegalArgumentException.class)\n     public void getFromObject() throws Exception {\n         // Invalid object\n-        Object obj = new Object();\n+        final Object obj = new Object();\n         CollectionUtils.get(obj, 0);\n     }\n \n \n     @Test\n     public void testSize_Map() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         assertEquals(0, CollectionUtils.size(map));\n         map.put(\"1\", \"a\");\n         assertEquals(1, CollectionUtils.size(map));\n \n     @Test\n     public void testSize_Array() {\n-        Object[] objectArray = new Object[0];\n+        final Object[] objectArray = new Object[0];\n         assertEquals(0, CollectionUtils.size(objectArray));\n \n-        String[] stringArray = new String[3];\n+        final String[] stringArray = new String[3];\n         assertEquals(3, CollectionUtils.size(stringArray));\n         stringArray[0] = \"a\";\n         stringArray[1] = \"b\";\n \n     @Test\n     public void testSize_PrimitiveArray() {\n-        int[] intArray = new int[0];\n+        final int[] intArray = new int[0];\n         assertEquals(0, CollectionUtils.size(intArray));\n \n-        double[] doubleArray = new double[3];\n+        final double[] doubleArray = new double[3];\n         assertEquals(3, CollectionUtils.size(doubleArray));\n         doubleArray[0] = 0.0d;\n         doubleArray[1] = 1.0d;\n \n     @Test\n     public void testSize_Enumeration() {\n-        Vector<String> list = new Vector<String>();\n+        final Vector<String> list = new Vector<String>();\n         assertEquals(0, CollectionUtils.size(list.elements()));\n         list.add(\"a\");\n         assertEquals(1, CollectionUtils.size(list.elements()));\n \n     @Test\n     public void testSize_Iterator() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         assertEquals(0, CollectionUtils.size(list.iterator()));\n         list.add(\"a\");\n         assertEquals(1, CollectionUtils.size(list.iterator()));\n \n     @Test\n     public void testSizeIsEmpty_List() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(list));\n         list.add(\"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(list));\n \n     @Test\n     public void testSizeIsEmpty_Map() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(map));\n         map.put(\"1\", \"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(map));\n \n     @Test\n     public void testSizeIsEmpty_Array() {\n-        Object[] objectArray = new Object[0];\n+        final Object[] objectArray = new Object[0];\n         assertEquals(true, CollectionUtils.sizeIsEmpty(objectArray));\n \n-        String[] stringArray = new String[3];\n+        final String[] stringArray = new String[3];\n         assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n         stringArray[0] = \"a\";\n         stringArray[1] = \"b\";\n \n     @Test\n     public void testSizeIsEmpty_PrimitiveArray() {\n-        int[] intArray = new int[0];\n+        final int[] intArray = new int[0];\n         assertEquals(true, CollectionUtils.sizeIsEmpty(intArray));\n \n-        double[] doubleArray = new double[3];\n+        final double[] doubleArray = new double[3];\n         assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n         doubleArray[0] = 0.0d;\n         doubleArray[1] = 1.0d;\n \n     @Test\n     public void testSizeIsEmpty_Enumeration() {\n-        Vector<String> list = new Vector<String>();\n+        final Vector<String> list = new Vector<String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(list.elements()));\n         list.add(\"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(list.elements()));\n-        Enumeration<String> en = list.elements();\n+        final Enumeration<String> en = list.elements();\n         en.nextElement();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(en));\n     }\n \n     @Test\n     public void testSizeIsEmpty_Iterator() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(list.iterator()));\n         list.add(\"a\");\n         assertEquals(false, CollectionUtils.sizeIsEmpty(list.iterator()));\n-        Iterator<String> it = list.iterator();\n+        final Iterator<String> it = list.iterator();\n         it.next();\n         assertEquals(true, CollectionUtils.sizeIsEmpty(it));\n     }\n         try {\n             CollectionUtils.sizeIsEmpty(\"not a list\");\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n     }\n \n     // -----------------------------------------------------------------------\n     @Test\n     public void testIsEmptyWithEmptyCollection() {\n-        Collection<Object> coll = new ArrayList<Object>();\n+        final Collection<Object> coll = new ArrayList<Object>();\n         assertEquals(true, CollectionUtils.isEmpty(coll));\n     }\n \n     @Test\n     public void testIsEmptyWithNonEmptyCollection() {\n-        Collection<String> coll = new ArrayList<String>();\n+        final Collection<String> coll = new ArrayList<String>();\n         coll.add(\"item\");\n         assertEquals(false, CollectionUtils.isEmpty(coll));\n     }\n \n     @Test\n     public void testIsEmptyWithNull() {\n-        Collection<?> coll = null;\n+        final Collection<?> coll = null;\n         assertEquals(true, CollectionUtils.isEmpty(coll));\n     }\n \n     @Test\n     public void testIsNotEmptyWithEmptyCollection() {\n-        Collection<Object> coll = new ArrayList<Object>();\n+        final Collection<Object> coll = new ArrayList<Object>();\n         assertEquals(false, CollectionUtils.isNotEmpty(coll));\n     }\n \n     @Test\n     public void testIsNotEmptyWithNonEmptyCollection() {\n-        Collection<String> coll = new ArrayList<String>();\n+        final Collection<String> coll = new ArrayList<String>();\n         coll.add(\"item\");\n         assertEquals(true, CollectionUtils.isNotEmpty(coll));\n     }\n \n     @Test\n     public void testIsNotEmptyWithNull() {\n-        Collection<?> coll = null;\n+        final Collection<?> coll = null;\n         assertEquals(false, CollectionUtils.isNotEmpty(coll));\n     }\n \n     // -----------------------------------------------------------------------\n     private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n-        public boolean evaluate(Number input) {\n+        public boolean evaluate(final Number input) {\n             return input.intValue() == 2;\n         }\n     };\n     @SuppressWarnings(\"cast\")\n     @Test\n     public void filter() {\n-        List<Integer> ints = new ArrayList<Integer>();\n+        final List<Integer> ints = new ArrayList<Integer>();\n         ints.add(1);\n         ints.add(2);\n         ints.add(3);\n         ints.add(3);\n-        Iterable<Integer> iterable = ints;\n+        final Iterable<Integer> iterable = ints;\n         assertTrue(CollectionUtils.filter(iterable, EQUALS_TWO));\n         assertEquals(1, ints.size());\n         assertEquals(2, (int) ints.get(0));\n \n     @Test\n     public void filterNullParameters() throws Exception {\n-        List<Long> longs = Collections.nCopies(4, 10L);\n+        final List<Long> longs = Collections.nCopies(4, 10L);\n         assertFalse(CollectionUtils.filter(longs, null));\n         assertEquals(4, longs.size());\n         assertFalse(CollectionUtils.filter(null, EQUALS_TWO));\n \n     @Test\n     public void exists() {\n-        List<Integer> list = new ArrayList<Integer>();\n+        final List<Integer> list = new ArrayList<Integer>();\n         assertFalse(CollectionUtils.exists(null, null));\n         assertFalse(CollectionUtils.exists(list, null));\n         assertFalse(CollectionUtils.exists(null, EQUALS_TWO));\n \n     @Test\n     public void select() {\n-        List<Integer> list = new ArrayList<Integer>();\n+        final List<Integer> list = new ArrayList<Integer>();\n         list.add(1);\n         list.add(2);\n         list.add(3);\n         list.add(4);\n         // Ensure that the collection is the input type or a super type\n-        Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);\n-        Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);\n-        HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n+        final Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);\n+        final Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n         assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n         assertEquals(4, list.size());\n         assertEquals(1, output1.size());\n \n     @Test\n     public void selectRejected() {\n-        List<Long> list = new ArrayList<Long>();\n+        final List<Long> list = new ArrayList<Long>();\n         list.add(1L);\n         list.add(2L);\n         list.add(3L);\n         list.add(4L);\n-        Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n-        Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n-        HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n+        final Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        final Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n         assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n         assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n         assertEquals(4, list.size());\n \n     @Test\n     public void collect() {\n-        Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);\n+        final Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);\n         Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);\n         assertTrue(collection.size() == collectionA.size());\n         assertCollectResult(collection);\n         collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);\n         assertTrue(collection.size() == 0);\n \n-        int size = collectionA.size();\n+        final int size = collectionA.size();\n         collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);\n         assertTrue(collectionA.size() == size && collectionA.contains(1));\n         CollectionUtils.collect(collectionB, null, collectionA);\n \n     }\n \n-    private void assertCollectResult(Collection<Number> collection) {\n+    private void assertCollectResult(final Collection<Number> collection) {\n         assertTrue(collectionA.contains(1) && !collectionA.contains(2L));\n         assertTrue(collection.contains(2L) && !collection.contains(1));\n     }\n \n     Transformer<Object, Integer> TRANSFORM_TO_INTEGER = new Transformer<Object, Integer>() {\n-        public Integer transform(Object input) {\n+        public Integer transform(final Object input) {\n             return new Integer(((Long)input).intValue());\n         }\n     };\n \n     @Test\n     public void transform2() {\n-        Set<Number> set = new HashSet<Number>();\n+        final Set<Number> set = new HashSet<Number>();\n         set.add(1L);\n         set.add(2L);\n         set.add(3L);\n         CollectionUtils.transform(set, new Transformer<Object, Integer>() {\n-            public Integer transform(Object input) {\n+            public Integer transform(final Object input) {\n                 return 4;\n             }\n         });\n     // -----------------------------------------------------------------------\n     @Test\n     public void addIgnoreNull() {\n-        Set<String> set = new HashSet<String>();\n+        final Set<String> set = new HashSet<String>();\n         set.add(\"1\");\n         set.add(\"2\");\n         set.add(\"3\");\n     // -----------------------------------------------------------------------\n     @Test\n     public void predicatedCollection() {\n-        Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n+        final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n         Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), predicate);\n         assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection);\n         try {\n             collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             CollectionUtils.predicatedCollection(null, predicate);\n             fail(\"Expecting IllegalArgumentException for null collection.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n     @Test\n     public void isFull() {\n-        Set<String> set = new HashSet<String>();\n+        final Set<String> set = new HashSet<String>();\n         set.add(\"1\");\n         set.add(\"2\");\n         set.add(\"3\");\n         try {\n             CollectionUtils.isFull(null);\n             fail();\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n         assertFalse(CollectionUtils.isFull(set));\n \n-        BoundedFifoBuffer<String> buf = new BoundedFifoBuffer<String>(set);\n+        final BoundedFifoBuffer<String> buf = new BoundedFifoBuffer<String>(set);\n         assertEquals(true, CollectionUtils.isFull(buf));\n         buf.remove(\"2\");\n         assertFalse(CollectionUtils.isFull(buf));\n         buf.add(\"2\");\n         assertEquals(true, CollectionUtils.isFull(buf));\n \n-        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n+        final Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n         assertEquals(true, CollectionUtils.isFull(buf2));\n         buf2.remove(\"2\");\n         assertFalse(CollectionUtils.isFull(buf2));\n \n     @Test\n     public void maxSize() {\n-        Set<String> set = new HashSet<String>();\n+        final Set<String> set = new HashSet<String>();\n         set.add(\"1\");\n         set.add(\"2\");\n         set.add(\"3\");\n         try {\n             CollectionUtils.maxSize(null);\n             fail();\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n         assertEquals(-1, CollectionUtils.maxSize(set));\n \n-        Buffer<String> buf = new BoundedFifoBuffer<String>(set);\n+        final Buffer<String> buf = new BoundedFifoBuffer<String>(set);\n         assertEquals(3, CollectionUtils.maxSize(buf));\n         buf.remove(\"2\");\n         assertEquals(3, CollectionUtils.maxSize(buf));\n         buf.add(\"2\");\n         assertEquals(3, CollectionUtils.maxSize(buf));\n \n-        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n+        final Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n         assertEquals(3, CollectionUtils.maxSize(buf2));\n         buf2.remove(\"2\");\n         assertEquals(3, CollectionUtils.maxSize(buf2));\n     @Test\n     public void intersectionUsesMethodEquals() {\n         // Let elta and eltb be objects...\n-        Integer elta = new Integer(17);\n-        Integer eltb = new Integer(17);\n+        final Integer elta = new Integer(17);\n+        final Integer eltb = new Integer(17);\n \n         // ...which are equal...\n         assertEquals(elta, eltb);\n         assertTrue(elta != eltb);\n \n         // Let cola and colb be collections...\n-        Collection<Number> cola = new ArrayList<Number>();\n-        Collection<Integer> colb = new ArrayList<Integer>();\n+        final Collection<Number> cola = new ArrayList<Number>();\n+        final Collection<Integer> colb = new ArrayList<Integer>();\n \n         // ...which contain elta and eltb,\n         // respectively.\n \n         // Then the intersection of the two\n         // should contain one element.\n-        Collection<Number> intersection = CollectionUtils.intersection(cola, colb);\n+        final Collection<Number> intersection = CollectionUtils.intersection(cola, colb);\n         assertEquals(1, intersection.size());\n \n         // In practice, this element will be the same (==) as elta\n         // or eltb, although this isn't strictly part of the\n         // contract.\n-        Object eltc = intersection.iterator().next();\n+        final Object eltc = intersection.iterator().next();\n         assertTrue(eltc == elta && eltc != eltb || eltc != elta && eltc == eltb);\n \n         // In any event, this element remains equal,\n     //Up to here\n     @Test\n     public void testRetainAll() {\n-        List<String> base = new ArrayList<String>();\n+        final List<String> base = new ArrayList<String>();\n         base.add(\"A\");\n         base.add(\"B\");\n         base.add(\"C\");\n-        List<Object> sub = new ArrayList<Object>();\n+        final List<Object> sub = new ArrayList<Object>();\n         sub.add(\"A\");\n         sub.add(\"C\");\n         sub.add(\"X\");\n \n-        Collection<String> result = CollectionUtils.retainAll(base, sub);\n+        final Collection<String> result = CollectionUtils.retainAll(base, sub);\n         assertEquals(2, result.size());\n         assertEquals(true, result.contains(\"A\"));\n         assertFalse(result.contains(\"B\"));\n         try {\n             CollectionUtils.retainAll(null, null);\n             fail(\"expecting NullPointerException\");\n-        } catch (NullPointerException npe) {\n+        } catch (final NullPointerException npe) {\n         } // this is what we want\n     }\n \n     @Test\n     public void testRemoveAll() {\n-        List<String> base = new ArrayList<String>();\n+        final List<String> base = new ArrayList<String>();\n         base.add(\"A\");\n         base.add(\"B\");\n         base.add(\"C\");\n-        List<String> sub = new ArrayList<String>();\n+        final List<String> sub = new ArrayList<String>();\n         sub.add(\"A\");\n         sub.add(\"C\");\n         sub.add(\"X\");\n \n-        Collection<String> result = CollectionUtils.removeAll(base, sub);\n+        final Collection<String> result = CollectionUtils.removeAll(base, sub);\n         assertEquals(1, result.size());\n         assertFalse(result.contains(\"A\"));\n         assertEquals(true, result.contains(\"B\"));\n         try {\n             CollectionUtils.removeAll(null, null);\n             fail(\"expecting NullPointerException\");\n-        } catch (NullPointerException npe) {\n+        } catch (final NullPointerException npe) {\n         } // this is what we want\n     }\n \n     // -----------------------------------------------------------------------\n     @Test\n     public void testTransformedCollection() {\n-        Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n+        final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n         Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), transformer);\n         assertTrue(\"returned object should be a TransformedCollection\", collection instanceof TransformedCollection);\n         try {\n             collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null transformer.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             collection = CollectionUtils.transformingCollection(null, transformer);\n             fail(\"Expecting IllegalArgumentException for null collection.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n     @Test\n     public void testTransformedCollection_2() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         list.add(\"1\");\n         list.add(\"2\");\n         list.add(\"3\");\n-        Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);\n+        final Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);\n         assertEquals(true, result.contains(\"1\")); // untransformed\n         assertEquals(true, result.contains(\"2\")); // untransformed\n         assertEquals(true, result.contains(\"3\")); // untransformed\n         try {\n             col = CollectionUtils.synchronizedCollection(null);\n             fail(\"Expecting IllegalArgumentException for null collection.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n         try {\n             col = CollectionUtils.unmodifiableCollection(null);\n             fail(\"Expecting IllegalArgumentException for null collection.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n     @Test\n     public void emptyCollection() throws Exception {\n-        Collection<Number> coll = CollectionUtils.emptyCollection();\n+        final Collection<Number> coll = CollectionUtils.emptyCollection();\n         assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);\n     }\n \n     @Test\n     public void emptyIfNull() {\n         assertTrue(CollectionUtils.emptyIfNull(null).isEmpty());\n-        Collection<Object> collection = new ArrayList<Object>();\n+        final Collection<Object> collection = new ArrayList<Object>();\n         assertSame(collection, CollectionUtils.emptyIfNull(collection));\n     }\n     \n      */\n     @Test\n     public void addAllForIterable() {\n-        Collection<Integer> inputCollection = createMock(Collection.class);\n-        Iterable<Integer> inputIterable = inputCollection;\n-        Iterable<Long> iterable = createMock(Iterable.class);\n-        Iterator<Long> iterator = createMock(Iterator.class);\n-        Collection<Number> c = createMock(Collection.class);\n+        final Collection<Integer> inputCollection = createMock(Collection.class);\n+        final Iterable<Integer> inputIterable = inputCollection;\n+        final Iterable<Long> iterable = createMock(Iterable.class);\n+        final Iterator<Long> iterator = createMock(Iterator.class);\n+        final Collection<Number> c = createMock(Collection.class);\n \n         expect(iterable.iterator()).andReturn(iterator);\n         next(iterator, 1L);\n \n     @Test\n     public void addAllForEnumeration() {\n-        Hashtable<Integer, Integer> h = new Hashtable<Integer, Integer>();\n+        final Hashtable<Integer, Integer> h = new Hashtable<Integer, Integer>();\n         h.put(5, 5);\n-        Enumeration<? extends Integer> enumeration = h.keys();\n+        final Enumeration<? extends Integer> enumeration = h.keys();\n         CollectionUtils.addAll(collectionA, enumeration);\n         assertTrue(collectionA.contains(5));\n     }\n     public void get() {\n         assertEquals(2, CollectionUtils.get((Object)collectionA, 2));\n         assertEquals(2, CollectionUtils.get((Object)collectionA.iterator(), 2));\n-        Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);\n+        final Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);\n         assertEquals(map.entrySet().iterator().next(), CollectionUtils.get(\n                 (Object)map, 0));\n     }\n     @Test\n     public void reverse() {\n         CollectionUtils.reverseArray(new Object[] {});\n-        Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);\n+        final Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);\n         CollectionUtils.reverseArray(a);\n         // assume our implementation is correct if it returns the same order as the Java function\n         Collections.reverse(collectionA);\n         try {\n             CollectionUtils.extractSingleton(coll);\n             fail(\"expected IllegalArgumentException from extractSingleton(null)\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n         }\n         coll = new ArrayList<String>();\n         try {\n             CollectionUtils.extractSingleton(coll);\n             fail(\"expected IllegalArgumentException from extractSingleton(empty)\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n         }\n         coll.add(\"foo\");\n         assertEquals(\"foo\", CollectionUtils.extractSingleton(coll));\n         try {\n             CollectionUtils.extractSingleton(coll);\n             fail(\"expected IllegalArgumentException from extractSingleton(size == 2)\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n         }\n     }\n \n     /**\n      * Records the next object returned for a mock iterator\n      */\n-    private <T> void next(Iterator<T> iterator, T t) {\n+    private <T> void next(final Iterator<T> iterator, final T t) {\n         expect(iterator.hasNext()).andReturn(true);\n         expect(iterator.next()).andReturn(t);\n     }\n--- a/src/test/java/org/apache/commons/collections/EnumerationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/EnumerationUtilsTest.java\n  */\n public class EnumerationUtilsTest extends BulkTest {\n \n-    public EnumerationUtilsTest(String name) {\n+    public EnumerationUtilsTest(final String name) {\n         super(name);\n     }\n \n     public static final String TO_LIST_FIXTURE = \"this is a test\";\n     \n     public void testToListWithStringTokenizer() {\n-        List<String> expectedList1 = new ArrayList<String>();\n-        StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n+        final List<String> expectedList1 = new ArrayList<String>();\n+        final StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n              while (st.hasMoreTokens()) {\n                  expectedList1.add(st.nextToken());\n              }\n-        List<String> expectedList2 = new ArrayList<String>();\n+        final List<String> expectedList2 = new ArrayList<String>();\n         expectedList2.add(\"this\");\n         expectedList2.add(\"is\");\n         expectedList2.add(\"a\");\n         expectedList2.add(\"test\");\n-        List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n+        final List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n         Assert.assertEquals(expectedList1, expectedList2);\n         Assert.assertEquals(expectedList1, actualList);\n         Assert.assertEquals(expectedList2, actualList);\n     }\n \n     public void testToListWithHashtable() {\n-        Hashtable<String, Integer> expected = new Hashtable<String, Integer>();\n+        final Hashtable<String, Integer> expected = new Hashtable<String, Integer>();\n         expected.put(\"one\", new Integer(1));\n         expected.put(\"two\", new Integer(2));\n         expected.put(\"three\", new Integer(3));\n         // validate elements.\n-        List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());\n+        final List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());\n         Assert.assertEquals(expected.size(), actualEltList.size());\n         Assert.assertTrue(actualEltList.contains(new Integer(1)));\n         Assert.assertTrue(actualEltList.contains(new Integer(2)));\n         Assert.assertTrue(actualEltList.contains(new Integer(3)));\n-        List<Integer> expectedEltList = new ArrayList<Integer>();\n+        final List<Integer> expectedEltList = new ArrayList<Integer>();\n         expectedEltList.add(new Integer(1));\n         expectedEltList.add(new Integer(2));\n         expectedEltList.add(new Integer(3));\n         Assert.assertTrue(actualEltList.containsAll(expectedEltList));\n \n         // validate keys.\n-        List<String> actualKeyList = EnumerationUtils.toList(expected.keys());\n+        final List<String> actualKeyList = EnumerationUtils.toList(expected.keys());\n         Assert.assertEquals(expected.size(), actualEltList.size());\n         Assert.assertTrue(actualKeyList.contains(\"one\"));\n         Assert.assertTrue(actualKeyList.contains(\"two\"));\n         Assert.assertTrue(actualKeyList.contains(\"three\"));\n-        List<String> expectedKeyList = new ArrayList<String>();\n+        final List<String> expectedKeyList = new ArrayList<String>();\n         expectedKeyList.add(\"one\");\n         expectedKeyList.add(\"two\");\n         expectedKeyList.add(\"three\");\n--- a/src/test/java/org/apache/commons/collections/ExtendedPropertiesTest.java\n+++ b/src/test/java/org/apache/commons/collections/ExtendedPropertiesTest.java\n     \n     protected ExtendedProperties eprop = new ExtendedProperties();\n \n-    public ExtendedPropertiesTest(String testName) {\n+    public ExtendedPropertiesTest(final String testName) {\n         super(testName);\n     }\n \n         /*\n          * test comma separated string properties\n          */\n-        String prop = \"hey, that's a test\";\n+        final String prop = \"hey, that's a test\";\n         eprop.setProperty(\"prop.string\", prop);\n         assertTrue(\"This returns vector\", eprop.getVector(\"prop.string\") instanceof java.util.Vector);\n         assertTrue(\"This returns list\", eprop.getList(\"prop.string\") instanceof java.util.List);\n \n-        String prop2 = \"hey\\\\, that's a test\";\n+        final String prop2 = \"hey\\\\, that's a test\";\n         eprop.remove(\"prop.string\");\n         eprop.setProperty(\"prop.string\", prop2);\n         assertTrue(\"This returns array\", eprop.getString(\"prop.string\") instanceof java.lang.String);\n          *  elements when generating the subset\n          */\n \n-        ExtendedProperties subEprop = eprop.subset(\"prop\");\n+        final ExtendedProperties subEprop = eprop.subset(\"prop\");\n \n         assertTrue(\"Returns the full string\", subEprop.getString(\"string\").equals(prop));\n         assertTrue(\"This returns string for subset\", subEprop.getString(\"string\") instanceof java.lang.String);\n     public void testInterpolation() {\n         eprop.setProperty(\"applicationRoot\", \"/home/applicationRoot\");\n         eprop.setProperty(\"db\", \"${applicationRoot}/db/hypersonic\");\n-        String dbProp = \"/home/applicationRoot/db/hypersonic\";\n+        final String dbProp = \"/home/applicationRoot/db/hypersonic\";\n         assertTrue(\"Checking interpolated variable\", eprop.getString(\"db\").equals(dbProp));\n     }\n \n     public void testSaveAndLoad() {\n-        ExtendedProperties ep1 = new ExtendedProperties();\n-        ExtendedProperties ep2 = new ExtendedProperties();\n+        final ExtendedProperties ep1 = new ExtendedProperties();\n+        final ExtendedProperties ep2 = new ExtendedProperties();\n \n         try {\n             /* initialize value:\n             two=Hello\\,World\n             three=Hello,World\n             */\n-            String s1 = \"one=Hello\\\\World\\ntwo=Hello\\\\,World\\nthree=Hello,World\";\n+            final String s1 = \"one=Hello\\\\World\\ntwo=Hello\\\\,World\\nthree=Hello,World\";\n             byte[] bytes = s1.getBytes();\n             ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             ep1.load(bais);\n             assertEquals(\"Commas not interpreted properly\", \n                     \"World\", ep1.getList(\"three\").get(1));\n                     \n-            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n             ep1.save(baos, null);\n             bytes = baos.toByteArray();\n             bais = new ByteArrayInputStream(bytes);\n                     ep1.getString(\"two\"), ep2.getString(\"two\"));\n             assertEquals(\"Comma not same after being saved and loaded\",\n                     ep1.getString(\"three\"), ep2.getString(\"three\"));\n-        } catch (IOException ioe) {\n+        } catch (final IOException ioe) {\n             fail(\"There was an exception saving and loading the EP\");\n         }\n     }\n \n     public void testTrailingBackSlash() {\n-        ExtendedProperties ep1 = new ExtendedProperties();\n+        final ExtendedProperties ep1 = new ExtendedProperties();\n \n         try {\n             /*\n             two=TWO \\\\\n             three=THREE\n             */\n-            String s1 = \"one=ONE\\ntwo=TWO \\\\\\\\\\nthree=THREE\";\n-            byte[] bytes = s1.getBytes();\n-            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            final String s1 = \"one=ONE\\ntwo=TWO \\\\\\\\\\nthree=THREE\";\n+            final byte[] bytes = s1.getBytes();\n+            final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n             ep1.load(bais);\n             assertEquals(\"Trailing back-slashes not interpreted properly\", \n                     3, ep1.size());\n             assertEquals(\"Back-slash not escaped properly\", \n                     \"TWO \\\\\", ep1.getString(\"two\"));\n-        } catch (IOException ioe) {\n+        } catch (final IOException ioe) {\n             fail(\"There was an exception loading the EP\");\n         }\n     }\n     \n     public void testMultipleSameKey1() throws Exception {\n-        ExtendedProperties ep1 = new ExtendedProperties();\n+        final ExtendedProperties ep1 = new ExtendedProperties();\n \n         /*\n         initialize using:\n         one=a\n         one=b,c\n         */\n-        String s1 = \"one=a\\none=b,c\\n\";\n-        byte[] bytes = s1.getBytes();\n-        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        final String s1 = \"one=a\\none=b,c\\n\";\n+        final byte[] bytes = s1.getBytes();\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ep1.load(bais);\n         assertEquals(1, ep1.size());\n \n     }\n     \n     public void testMultipleSameKey2() throws Exception {\n-        ExtendedProperties ep1 = new ExtendedProperties();\n+        final ExtendedProperties ep1 = new ExtendedProperties();\n \n         /*\n         initialize using:\n         one=a,b\n         one=c,d\n         */\n-        String s1 = \"one=a,b\\none=c,d\\n\";\n-        byte[] bytes = s1.getBytes();\n-        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        final String s1 = \"one=a,b\\none=c,d\\n\";\n+        final byte[] bytes = s1.getBytes();\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ep1.load(bais);\n         assertEquals(1, ep1.size());\n \n     }\n     \n     public void testMultipleSameKey3() throws Exception {\n-        ExtendedProperties ep1 = new ExtendedProperties();\n+        final ExtendedProperties ep1 = new ExtendedProperties();\n \n         /*\n         initialize using:\n         one=a,b\n         one=c\n         */\n-        String s1 = \"one=a,b\\none=c\\n\";\n-        byte[] bytes = s1.getBytes();\n-        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        final String s1 = \"one=a,b\\none=c\\n\";\n+        final byte[] bytes = s1.getBytes();\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n         ep1.load(bais);\n         assertEquals(1, ep1.size());\n \n     }\n     \n     public void testMultipleSameKeyByCode() throws Exception {\n-        ExtendedProperties ep1 = new ExtendedProperties();\n+        final ExtendedProperties ep1 = new ExtendedProperties();\n \n         ep1.addProperty(\"one\", \"a\");\n         assertEquals(1, ep1.size());\n     }\n \n     public void testInheritDefaultProperties() {\n-        Properties defaults = new Properties();\n+        final Properties defaults = new Properties();\n         defaults.setProperty(\"resource.loader\", \"class\");\n \n-        Properties properties = new Properties(defaults);\n+        final Properties properties = new Properties(defaults);\n         properties.setProperty(\"test\", \"foo\");\n \n-        ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n+        final ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n \n         assertEquals(\"foo\", extended.getString(\"test\"));\n         assertEquals(\"class\", extended.getString(\"resource.loader\"));\n     }\n \n     public void testInclude() {\n-        ExtendedProperties a = new ExtendedProperties();\n-        ExtendedProperties b = new ExtendedProperties();\n+        final ExtendedProperties a = new ExtendedProperties();\n+        final ExtendedProperties b = new ExtendedProperties();\n         \n         assertEquals(\"include\", a.getInclude());\n         assertEquals(\"include\", b.getInclude());\n     }\n \n     public void testKeySet1() {\n-            ExtendedProperties p = new ExtendedProperties();\n+            final ExtendedProperties p = new ExtendedProperties();\n             p.addProperty(\"a\", \"foo\");\n             p.addProperty(\"b\", \"bar\");\n             p.addProperty(\"c\", \"bar\");\n \n-            Iterator<String> it = p.getKeys();\n+            final Iterator<String> it = p.getKeys();\n             assertEquals(\"a\", it.next());\n             assertEquals(\"b\", it.next());\n             assertEquals(\"c\", it.next());\n     }\n \n     public void testKeySet2() {\n-        ExtendedProperties p = new ExtendedProperties();\n+        final ExtendedProperties p = new ExtendedProperties();\n         p.put(\"a\", \"foo\");\n         p.put(\"b\", \"bar\");\n         p.put(\"c\", \"bar\");\n \n-        Iterator<String> it = p.getKeys();\n+        final Iterator<String> it = p.getKeys();\n         assertEquals(\"a\", it.next());\n         assertEquals(\"b\", it.next());\n         assertEquals(\"c\", it.next());\n \n \n     public void testKeySet3() {\n-        ExtendedProperties q = new ExtendedProperties();\n+        final ExtendedProperties q = new ExtendedProperties();\n         q.addProperty(\"a\", \"foo\");\n         q.addProperty(\"b\", \"bar\");\n         q.addProperty(\"c\", \"bar\");\n \n-        ExtendedProperties p = new ExtendedProperties();\n+        final ExtendedProperties p = new ExtendedProperties();\n         p.putAll(q);\n \n-        Iterator<String> it = p.getKeys();\n+        final Iterator<String> it = p.getKeys();\n         assertEquals(\"a\", it.next());\n         assertEquals(\"b\", it.next());\n         assertEquals(\"c\", it.next());\n     }\n \n     public void testKeySet4() {\n-        ExtendedProperties q = new ExtendedProperties();\n+        final ExtendedProperties q = new ExtendedProperties();\n         q.addProperty(\"a\", \"foo\");\n         q.addProperty(\"b\", \"bar\");\n         q.addProperty(\"c\", \"bar\");\n \n         q.remove(\"b\");\n \n-        Iterator<String> it = q.getKeys();\n+        final Iterator<String> it = q.getKeys();\n         assertEquals(\"a\", it.next());\n         assertEquals(\"c\", it.next());\n         assertFalse(it.hasNext());\n     }\n \n     public void testCollections271() {\n-        ExtendedProperties props = new ExtendedProperties();\n+        final ExtendedProperties props = new ExtendedProperties();\n         props.setProperty(\"test\", \"\\\\\\\\\\\\\\\\192.168.1.91\\\\\\\\test\");\n         props.getProperty(\"test\");\n         assertEquals( \"\\\\\\\\192.168.1.91\\\\test\", props.getProperty(\"test\") );\n \n-        ExtendedProperties props2 = new ExtendedProperties();\n+        final ExtendedProperties props2 = new ExtendedProperties();\n         props2.combine(props);\n         assertEquals( \"\\\\\\\\192.168.1.91\\\\test\", props2.getProperty(\"test\") );\n \n-        ExtendedProperties props3 = new ExtendedProperties();\n+        final ExtendedProperties props3 = new ExtendedProperties();\n         props3.setProperty(\"sub.test\", \"foo\");\n         props2.combine(props3);\n         assertEquals(\"foo\", props2.getProperty(\"sub.test\"));\n \n-        ExtendedProperties subs = props2.subset(\"sub\");\n+        final ExtendedProperties subs = props2.subset(\"sub\");\n         assertNotNull(subs);\n         assertEquals(\"foo\", subs.getProperty(\"test\"));\n     }\n \n     public void testCollections238() throws IOException {\n-        ExtendedProperties props = new ExtendedProperties();\n-        String txt = \"x=1\\ny=\\nz=3\";\n-        byte[] bytes = txt.getBytes();\n-        ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n+        final ExtendedProperties props = new ExtendedProperties();\n+        final String txt = \"x=1\\ny=\\nz=3\";\n+        final byte[] bytes = txt.getBytes();\n+        final ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n         props.load(in);\n         assertEquals(\"1\", props.getProperty(\"x\"));\n         assertEquals(\"3\", props.getProperty(\"z\"));\n     }\n \n     public void testCollections299() {\n-        Properties defaults = new Properties();\n+        final Properties defaults = new Properties();\n         defaults.put(\"objectTrue\", Boolean.TRUE);\n \n-        Properties properties = new Properties(defaults);\n+        final Properties properties = new Properties(defaults);\n         properties.put(\"objectFalse\", Boolean.FALSE);\n \n-        ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n+        final ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n \n         assertNull(extended.getString(\"objectTrue\"));\n         assertNull(extended.getString(\"objectFalse\"));\n--- a/src/test/java/org/apache/commons/collections/FactoryUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/FactoryUtilsTest.java\n     /**\n      * Construct\n      */\n-    public FactoryUtilsTest(String name) {\n+    public FactoryUtilsTest(final String name) {\n         super(name);\n     }\n \n         assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());\n         try {\n             FactoryUtils.exceptionFactory().create();\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             try {\n                 FactoryUtils.exceptionFactory().create();\n-            } catch (FunctorException ex2) {\n+            } catch (final FunctorException ex2) {\n                 return;\n             }\n         }\n     //------------------------------------------------------------------\n \n     public void testNullFactory() {\n-        Factory<Object> factory = FactoryUtils.nullFactory();\n-        assertNotNull(factory);\n-        Object created = factory.create();\n+        final Factory<Object> factory = FactoryUtils.nullFactory();\n+        assertNotNull(factory);\n+        final Object created = factory.create();\n         assertNull(created);\n     }\n \n     //------------------------------------------------------------------\n \n     public void testConstantFactoryNull() {\n-        Factory<Object> factory = FactoryUtils.constantFactory(null);\n-        assertNotNull(factory);\n-        Object created = factory.create();\n+        final Factory<Object> factory = FactoryUtils.constantFactory(null);\n+        assertNotNull(factory);\n+        final Object created = factory.create();\n         assertNull(created);\n     }\n \n     public void testConstantFactoryConstant() {\n-        Integer constant = new Integer(9);\n-        Factory<Integer> factory = FactoryUtils.constantFactory(constant);\n-        assertNotNull(factory);\n-        Integer created = factory.create();\n+        final Integer constant = new Integer(9);\n+        final Factory<Integer> factory = FactoryUtils.constantFactory(constant);\n+        assertNotNull(factory);\n+        final Integer created = factory.create();\n         assertSame(constant, created);\n     }\n \n     }\n \n     public void testPrototypeFactoryPublicCloneMethod() throws Exception {\n-        Date proto = new Date();\n-        Factory<Date> factory = FactoryUtils.prototypeFactory(proto);\n-        assertNotNull(factory);\n-        Date created = factory.create();\n+        final Date proto = new Date();\n+        final Factory<Date> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        final Date created = factory.create();\n         assertTrue(proto != created);\n         assertEquals(proto, created);\n \n         // check serialisation works\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n         out.writeObject(factory);\n         out.close();\n-        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n         in.readObject();\n         in.close();\n     }\n \n     public void testPrototypeFactoryPublicCopyConstructor() throws Exception {\n-        Mock1 proto = new Mock1(6);\n+        final Mock1 proto = new Mock1(6);\n         Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n         assertNotNull(factory);\n-        Object created = factory.create();\n+        final Object created = factory.create();\n         assertTrue(proto != created);\n         assertEquals(proto, created);\n \n         ObjectOutputStream out = new ObjectOutputStream(buffer);\n         try {\n             out.writeObject(factory);\n-        } catch (NotSerializableException ex) {\n+        } catch (final NotSerializableException ex) {\n             out.close();\n         }\n         factory = FactoryUtils.<Object>prototypeFactory(new Mock2(\"S\"));\n         out = new ObjectOutputStream(buffer);\n         out.writeObject(factory);\n         out.close();\n-        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n         in.readObject();\n         in.close();\n     }\n \n     public void testPrototypeFactoryPublicSerialization() throws Exception {\n-        Integer proto = new Integer(9);\n-        Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);\n-        assertNotNull(factory);\n-        Integer created = factory.create();\n+        final Integer proto = new Integer(9);\n+        final Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        final Integer created = factory.create();\n         assertTrue(proto != created);\n         assertEquals(proto, created);\n \n         // check serialisation works\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n         out.writeObject(factory);\n         out.close();\n-        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n         in.readObject();\n         in.close();\n     }\n \n     public void testPrototypeFactoryPublicSerializationError() {\n-        Mock2 proto = new Mock2(new Object());\n-        Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n+        final Mock2 proto = new Mock2(new Object());\n+        final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n         assertNotNull(factory);\n         try {\n             factory.create();\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             assertTrue(ex.getCause() instanceof IOException);\n             return;\n         }\n     }\n \n     public void testPrototypeFactoryPublicBad() {\n-        Object proto = new Object();\n+        final Object proto = new Object();\n         try {\n             FactoryUtils.prototypeFactory(proto);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n \n     public static class Mock1 {\n         private final int iVal;\n-        public Mock1(int val) {\n+        public Mock1(final int val) {\n             iVal = val;\n         }\n-        public Mock1(Mock1 mock) {\n+        public Mock1(final Mock1 mock) {\n             iVal = mock.iVal;\n         }\n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj instanceof Mock1) {\n                 if (iVal == ((Mock1) obj).iVal) {\n                     return true;\n     @SuppressWarnings(\"serial\")\n     public static class Mock2 implements Serializable {\n         private final Object iVal;\n-        public Mock2(Object val) {\n+        public Mock2(final Object val) {\n             iVal = val;\n         }\n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             if (obj instanceof Mock2) {\n                 if (iVal == ((Mock2) obj).iVal) {\n                     return true;\n \n     @Test\n     public void instantiateFactorySimple() {\n-        Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);\n+        final Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);\n         assertNotNull(factory);\n         Mock3 created = factory.create();\n         assertEquals(0, created.getValue());\n     public void instantiateFactoryComplex() {\n         TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n         // 2nd Jan 1970\n-        Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,\n+        final Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,\n             new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},\n             new Object[] {new Integer(70), new Integer(0), new Integer(2)});\n         assertNotNull(factory);\n-        Date created = factory.create();\n+        final Date created = factory.create();\n         // long time of 1 day (== 2nd Jan 1970)\n         assertEquals(new Date(1000 * 60 * 60 * 24), created);\n     }\n--- a/src/test/java/org/apache/commons/collections/IteratorUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/IteratorUtilsTest.java\n  */\n public class IteratorUtilsTest extends BulkTest {\n \n-    public IteratorUtilsTest(String name) {\n+    public IteratorUtilsTest(final String name) {\n         super(name);\n     }\n \n     }\n \n     public void testAsIterable() {\n-        List<Integer> list = new ArrayList<Integer>();\n+        final List<Integer> list = new ArrayList<Integer>();\n         list.add(Integer.valueOf(0));\n         list.add(Integer.valueOf(1));\n         list.add(Integer.valueOf(2));\n-        Iterator<Integer> iterator = list.iterator();\n+        final Iterator<Integer> iterator = list.iterator();\n         \n-        Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);\n+        final Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);\n         int expected = 0;\n-        for(Integer actual : iterable) {\n+        for(final Integer actual : iterable) {\n             assertEquals(expected, actual.intValue());\n             ++expected;\n         }\n         assertTrue(expected > 0);\n \n         // single use iterator\n-        for(Integer actual : iterable) {\n+        for(final Integer actual : iterable) {\n             fail(\"should not be able to iterate twice\");\n         }\n     }\n         try {\n             IteratorUtils.asIterable(null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             // success\n         }\n     }\n \n     public void testAsMultipleIterable() {\n-        List<Integer> list = new ArrayList<Integer>();\n+        final List<Integer> list = new ArrayList<Integer>();\n         list.add(Integer.valueOf(0));\n         list.add(Integer.valueOf(1));\n         list.add(Integer.valueOf(2));\n-        Iterator<Integer> iterator = list.iterator();\n+        final Iterator<Integer> iterator = list.iterator();\n         \n-        Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);\n+        final Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);\n         int expected = 0;\n-        for(Integer actual : iterable) {\n+        for(final Integer actual : iterable) {\n             assertEquals(expected, actual.intValue());\n             ++expected;\n         }\n \n         // multiple use iterator\n         expected = 0;\n-        for(Integer actual : iterable) {\n+        for(final Integer actual : iterable) {\n             assertEquals(expected, actual.intValue());\n             ++expected;\n         }\n         try {\n             IteratorUtils.asMultipleUseIterable(null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             // success\n         }\n     }\n     \n     public void testToList() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         list.add(new Integer(1));\n         list.add(\"Two\");\n         list.add(null);\n-        List<Object> result = IteratorUtils.toList(list.iterator());\n+        final List<Object> result = IteratorUtils.toList(list.iterator());\n         assertEquals(list, result);\n     }\n \n     public void testToArray() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         list.add(new Integer(1));\n         list.add(\"Two\");\n         list.add(null);\n-        Object[] result = IteratorUtils.toArray(list.iterator());\n+        final Object[] result = IteratorUtils.toArray(list.iterator());\n         assertEquals(list, Arrays.asList(result));\n     }\n \n     public void testToArray2() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.add(\"One\");\n         list.add(\"Two\");\n         list.add(null);\n-        String[] result = IteratorUtils.toArray(list.iterator(), String.class);\n+        final String[] result = IteratorUtils.toArray(list.iterator(), String.class);\n         assertEquals(list, Arrays.asList(result));\n     }\n \n     public void testArrayIterator() {\n-        Object[] objArray = {\"a\", \"b\", \"c\"};\n+        final Object[] objArray = {\"a\", \"b\", \"c\"};\n         ResettableIterator<Object> iterator = IteratorUtils.arrayIterator(objArray);\n         assertTrue(iterator.next().equals(\"a\"));\n         assertTrue(iterator.next().equals(\"b\"));\n         try {\n             iterator = IteratorUtils.arrayIterator(new Integer(0));\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n                 // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n                 // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(objArray, -1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(objArray, 4);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(objArray, 2, 4);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(objArray, -1, 1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(objArray, 2, 1);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-\n-        int[] intArray = {0, 1, 2};\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        final int[] intArray = {0, 1, 2};\n         iterator = IteratorUtils.arrayIterator(intArray);\n         assertTrue(iterator.next().equals(new Integer(0)));\n         assertTrue(iterator.next().equals(new Integer(1)));\n         try {\n             iterator = IteratorUtils.arrayIterator(intArray, -1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(intArray, 4);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(intArray, 2, 4);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(intArray, -1, 1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayIterator(intArray, 2, 1);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n     public void testArrayListIterator() {\n-        Object[] objArray = {\"a\", \"b\", \"c\", \"d\"};\n+        final Object[] objArray = {\"a\", \"b\", \"c\", \"d\"};\n         ResettableListIterator<Object> iterator = IteratorUtils.arrayListIterator(objArray);\n         assertTrue(!iterator.hasPrevious());\n         assertTrue(iterator.previousIndex() == -1);\n         try {\n             iterator = IteratorUtils.arrayListIterator(new Integer(0));\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n                 // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(null);\n             fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n                 // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(objArray, -1);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator.previous();\n             fail(\"Expecting NoSuchElementException.\");\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(objArray, 5);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(objArray, 2, 5);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(objArray, -1, 1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(objArray, 2, 1);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }\n-\n-        int[] intArray = {0, 1, 2};\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        final int[] intArray = {0, 1, 2};\n         iterator = IteratorUtils.arrayListIterator(intArray);\n         assertTrue(iterator.previousIndex() == -1);\n         assertTrue(!iterator.hasPrevious());\n         try {\n             iterator = IteratorUtils.arrayListIterator(intArray, -1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(intArray, 4);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(intArray, 2, 4);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(intArray, -1, 1);\n             fail(\"Expecting IndexOutOfBoundsException\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n \n         try {\n             iterator = IteratorUtils.arrayListIterator(intArray, 2, 1);\n             fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n      * Gets an immutable Iterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n      */\n     private Iterator<String> getImmutableIterator() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.add(\"a\");\n         list.add(\"b\");\n         list.add(\"c\");\n      * Gets an immutable ListIterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n      */\n     private ListIterator<String> getImmutableListIterator() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.add(\"a\");\n         list.add(\"b\");\n         list.add(\"c\");\n         try {\n             IteratorUtils.EMPTY_ITERATOR.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_ITERATOR.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         try {\n             IteratorUtils.EMPTY_LIST_ITERATOR.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_LIST_ITERATOR.previous();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_LIST_ITERATOR.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_LIST_ITERATOR.set(null);\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_LIST_ITERATOR.add(null);\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         try {\n             IteratorUtils.EMPTY_MAP_ITERATOR.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_MAP_ITERATOR.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_MAP_ITERATOR.getKey();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_MAP_ITERATOR.getValue();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_MAP_ITERATOR.setValue(null);\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         try {\n             IteratorUtils.EMPTY_ORDERED_ITERATOR.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_ORDERED_ITERATOR.previous();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_ORDERED_ITERATOR.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         try {\n             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.previous();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getKey();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getValue();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         try {\n             IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.setValue(null);\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n      * Test next() and hasNext() for an immutable Iterator.\n      */\n     public void testUnmodifiableIteratorIteration() {\n-        Iterator<String> iterator = getImmutableIterator();\n+        final Iterator<String> iterator = getImmutableIterator();\n \n         assertTrue(iterator.hasNext());\n \n      * ListIterator.\n      */\n     public void testUnmodifiableListIteratorIteration() {\n-        ListIterator<String> listIterator = getImmutableListIterator();\n+        final ListIterator<String> listIterator = getImmutableListIterator();\n \n         assertTrue(!listIterator.hasPrevious());\n         assertTrue(listIterator.hasNext());\n      * Test remove() for an immutable Iterator.\n      */\n     public void testUnmodifiableIteratorImmutability() {\n-        Iterator<String> iterator = getImmutableIterator();\n+        final Iterator<String> iterator = getImmutableIterator();\n \n         try {\n             iterator.remove();\n             // We shouldn't get to here.\n             fail(\"remove() should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n \n             iterator.remove();\n             // We shouldn't get to here.\n             fail(\"remove() should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n \n      * Test remove() for an immutable ListIterator.\n      */\n     public void testUnmodifiableListIteratorImmutability() {\n-        ListIterator<String> listIterator = getImmutableListIterator();\n+        final ListIterator<String> listIterator = getImmutableListIterator();\n \n         try {\n             listIterator.remove();\n             // We shouldn't get to here.\n             fail(\"remove() should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n \n             listIterator.set(\"a\");\n             // We shouldn't get to here.\n             fail(\"set(Object) should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n \n             listIterator.add(\"a\");\n             // We shouldn't get to here.\n             fail(\"add(Object) should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n \n             listIterator.remove();\n             // We shouldn't get to here.\n             fail(\"remove() should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n \n             listIterator.set(\"a\");\n             // We shouldn't get to here.\n             fail(\"set(Object) should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n \n             listIterator.add(\"a\");\n             // We shouldn't get to here.\n             fail(\"add(Object) should throw an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // This is correct; ignore the exception.\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/ListUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/ListUtilsTest.java\n     private String[] fullArray;\n     private List<String> fullList;\n \n-    public ListUtilsTest(String name) {\n+    public ListUtilsTest(final String name) {\n         super(name);\n     }\n \n      * Tests intersecting two lists in different orders.\n      */\n     public void testIntersectionOrderInsensitivity() {\n-        List<String> one = new ArrayList<String>();\n-        List<String> two = new ArrayList<String>();\n+        final List<String> one = new ArrayList<String>();\n+        final List<String> two = new ArrayList<String>();\n         one.add(\"a\");\n         one.add(\"b\");\n         two.add(\"a\");\n     }\n \n     public void testPredicatedList() {\n-        Predicate<Object> predicate = new Predicate<Object>() {\n-            public boolean evaluate(Object o) {\n+        final Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(final Object o) {\n                 return o instanceof String;\n             }\n         };\n         try {\n             list = ListUtils.predicatedList(new ArrayStack<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             list = ListUtils.predicatedList(null, predicate);\n             fail(\"Expecting IllegalArgumentException for null list.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n \n     public void testLazyList() {\n-        List<Integer> list = ListUtils.lazyList(new ArrayList<Integer>(), new Factory<Integer>() {\n+        final List<Integer> list = ListUtils.lazyList(new ArrayList<Integer>(), new Factory<Integer>() {\n \n             private int index;\n \n     public void testEmptyIfNull() {\n         assertTrue(ListUtils.emptyIfNull(null).isEmpty());\n         \n-        List<Long> list = new ArrayList<Long>();\n+        final List<Long> list = new ArrayList<Long>();\n         assertSame(list, ListUtils.emptyIfNull(list));\n     }\n     \n     public void testEquals() {\n-        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n-\n-        List<String> a = new ArrayList<String>( data );\n-        List<String> b = new ArrayList<String>( data );\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        final List<String> a = new ArrayList<String>( data );\n+        final List<String> b = new ArrayList<String>( data );\n \n         assertEquals(true, a.equals(b));\n         assertEquals(true, ListUtils.isEqualList(a, b));\n     }\n \n     public void testHashCode() {\n-        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n-\n-        List<String> a = new ArrayList<String>(data);\n-        List<String> b = new ArrayList<String>(data);\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        final List<String> a = new ArrayList<String>(data);\n+        final List<String> b = new ArrayList<String>(data);\n \n         assertEquals(true, a.hashCode() == b.hashCode());\n         assertEquals(true, a.hashCode() == ListUtils.hashCodeForList(a));\n     }\n \n     public void testRetainAll() {\n-        List<String> sub = new ArrayList<String>();\n+        final List<String> sub = new ArrayList<String>();\n         sub.add(a);\n         sub.add(b);\n         sub.add(x);\n \n-        List<String> retained = ListUtils.retainAll(fullList, sub);\n+        final List<String> retained = ListUtils.retainAll(fullList, sub);\n         assertTrue(retained.size() == 2);\n         sub.remove(x);\n         assertTrue(retained.equals(sub));\n         try {\n             ListUtils.retainAll(null, null);\n             fail(\"expecting NullPointerException\");\n-        } catch(NullPointerException npe){} // this is what we want\n+        } catch(final NullPointerException npe){} // this is what we want\n     }\n \n     public void testRemoveAll() {\n-        List<String> sub = new ArrayList<String>();\n+        final List<String> sub = new ArrayList<String>();\n         sub.add(a);\n         sub.add(b);\n         sub.add(x);\n \n-        List<String> remainder = ListUtils.removeAll(fullList, sub);\n+        final List<String> remainder = ListUtils.removeAll(fullList, sub);\n         assertTrue(remainder.size() == 3);\n         fullList.removeAll(sub);\n         assertTrue(remainder.equals(fullList));\n         try {\n             ListUtils.removeAll(null, null);\n             fail(\"expecting NullPointerException\");\n-        } catch(NullPointerException npe) {} // this is what we want\n+        } catch(final NullPointerException npe) {} // this is what we want\n     }\n \n     public void testSubtract() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.add(a);\n         list.add(b);\n         list.add(a);\n         list.add(x);\n \n-        List<String> sub = new ArrayList<String>();\n+        final List<String> sub = new ArrayList<String>();\n         sub.add(a);\n \n-        List<String> result = ListUtils.subtract(list, sub);\n+        final List<String> result = ListUtils.subtract(list, sub);\n         assertTrue(result.size() == 3);\n         \n-        List<String> expected = new ArrayList<String>();\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(b);\n         expected.add(a);\n         expected.add(x);\n         try {\n             ListUtils.subtract(list, null);\n             fail(\"expecting NullPointerException\");\n-        } catch(NullPointerException npe) {} // this is what we want\n+        } catch(final NullPointerException npe) {} // this is what we want\n     }\n \n     public void testSubtractNullElement() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.add(a);\n         list.add(null);\n         list.add(null);\n         list.add(x);\n \n-        List<String> sub = new ArrayList<String>();\n+        final List<String> sub = new ArrayList<String>();\n         sub.add(null);\n \n-        List<String> result = ListUtils.subtract(list, sub);\n+        final List<String> result = ListUtils.subtract(list, sub);\n         assertTrue(result.size() == 3);\n         \n-        List<String> expected = new ArrayList<String>();\n+        final List<String> expected = new ArrayList<String>();\n         expected.add(a);\n         expected.add(null);\n         expected.add(x);\n     }\n     \n     public void testPartition() {\n-        List<Integer> strings = new ArrayList<Integer>();\n+        final List<Integer> strings = new ArrayList<Integer>();\n         for (int i = 0; i <= 6; i++) {\n             strings.add(i);\n         }\n         try {\n             ListUtils.partition(null, 3);\n             Assert.fail(\"failed to check for null argument\");\n-        } catch (IllegalArgumentException e) {}\n+        } catch (final IllegalArgumentException e) {}\n         \n         try {\n             ListUtils.partition(strings, 0);\n             Assert.fail(\"failed to check for size argument\");\n-        } catch (IllegalArgumentException e) {}\n+        } catch (final IllegalArgumentException e) {}\n         \n         try {\n             ListUtils.partition(strings, -10);\n             Assert.fail(\"failed to check for size argument\");\n-        } catch (IllegalArgumentException e) {}\n+        } catch (final IllegalArgumentException e) {}\n         \n     }\n     \n     private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n-        public boolean evaluate(Number input) {\n+        public boolean evaluate(final Number input) {\n             return input.intValue() == 2;\n         }\n     };\n \n     public void testSelect() {\n-        List<Integer> list = new ArrayList<Integer>();\n+        final List<Integer> list = new ArrayList<Integer>();\n         list.add(1);\n         list.add(2);\n         list.add(3);\n         list.add(4);\n         // Ensure that the collection is the input type or a super type\n-        List<Integer> output1 = ListUtils.select(list, EQUALS_TWO);\n-        List<Number> output2 = ListUtils.<Number>select(list, EQUALS_TWO);\n-        HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n+        final List<Integer> output1 = ListUtils.select(list, EQUALS_TWO);\n+        final List<Number> output2 = ListUtils.<Number>select(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n         Assert.assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n         Assert.assertEquals(4, list.size());\n         Assert.assertEquals(1, output1.size());\n     }\n \n     public void testSelectRejected() {\n-        List<Long> list = new ArrayList<Long>();\n+        final List<Long> list = new ArrayList<Long>();\n         list.add(1L);\n         list.add(2L);\n         list.add(3L);\n         list.add(4L);\n-        List<Long> output1 = ListUtils.selectRejected(list, EQUALS_TWO);\n-        List<? extends Number> output2 = ListUtils.selectRejected(list, EQUALS_TWO);\n-        HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n+        final List<Long> output1 = ListUtils.selectRejected(list, EQUALS_TWO);\n+        final List<? extends Number> output2 = ListUtils.selectRejected(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n         Assert.assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n         Assert.assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n         Assert.assertEquals(4, list.size());\n--- a/src/test/java/org/apache/commons/collections/MapPerformance.java\n+++ b/src/test/java/org/apache/commons/collections/MapPerformance.java\n     /**\n      * Main method\n      */\n-    public static void main(String[] args) {\n+    public static void main(final String[] args) {\n         testAll();\n     }\n     \n     private static void testAll() {\n-        Map<String, String> dummyMap = new DummyMap<String, String>();\n-        Map<String, String> hashMap = new HashMap<String, String>();\n+        final Map<String, String> dummyMap = new DummyMap<String, String>();\n+        final Map<String, String> hashMap = new HashMap<String, String>();\n //        hashMap.put(\"Alpha\", \"A\");\n //        hashMap.put(\"Beta\", \"B\");\n //        hashMap.put(\"Gamma\", \"C\");\n //        hashMap.put(\"Delta\", \"D\");\n-        Map<String, String> flatMap = new Flat3Map<String, String>(hashMap);\n+        final Map<String, String> flatMap = new Flat3Map<String, String>(hashMap);\n         System.out.println(flatMap);\n //        Map<String, String> unmodHashMap = Collections.unmodifiableMap(new HashMap<String, String>(hashMap));\n //        Map fastHashMap = new FastHashMap(hashMap);\n //        test(doubleMap,     \"     DoubleMap \");\n     }\n \n-    private static void test(Map<String, String> map, String name) {\n+    private static void test(final Map<String, String> map, final String name) {\n         long start = 0, end = 0;\n //        int total = 0;\n         start = System.currentTimeMillis();\n     private static class DummyMap<K, V> implements Map<K, V> {\n         public void clear() {\n         }\n-        public boolean containsKey(Object key) {\n+        public boolean containsKey(final Object key) {\n             return false;\n         }\n-        public boolean containsValue(Object value) {\n+        public boolean containsValue(final Object value) {\n             return false;\n         }\n         public Set<Map.Entry<K, V>> entrySet() {\n             return null;\n         }\n-        public V get(Object key) {\n+        public V get(final Object key) {\n             return null;\n         }\n         public boolean isEmpty() {\n         public Set<K> keySet() {\n             return null;\n         }\n-        public V put(K key, V value) {\n+        public V put(final K key, final V value) {\n             return null;\n         }\n-        public void putAll(Map<? extends K, ? extends V> t) {\n+        public void putAll(final Map<? extends K, ? extends V> t) {\n         }\n-        public V remove(Object key) {\n+        public V remove(final Object key) {\n             return null;\n         }\n         public int size() {\n--- a/src/test/java/org/apache/commons/collections/MapUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/MapUtilsTest.java\n @SuppressWarnings(\"boxing\")\n public class MapUtilsTest extends BulkTest {\n \n-    public MapUtilsTest(String name) {\n+    public MapUtilsTest(final String name) {\n         super(name);\n     }\n \n \n     public Predicate<Object> getPredicate() {\n         return new Predicate<Object>() {\n-            public boolean evaluate(Object o) {\n+            public boolean evaluate(final Object o) {\n                 return o instanceof String;\n             }\n         };\n     }\n \n     public void testPredicatedMap() {\n-        Predicate<Object> p = getPredicate();\n+        final Predicate<Object> p = getPredicate();\n         Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<Object, Object>(), p, p);\n         assertTrue(\"returned object should be a PredicatedMap\", map instanceof PredicatedMap);\n         try {\n             map = MapUtils.predicatedMap(null, p, p);\n             fail(\"Expecting IllegalArgumentException for null map.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n \n     public void testLazyMapFactory() {\n-        Factory<Integer> factory = FactoryUtils.constantFactory(new Integer(5));\n+        final Factory<Integer> factory = FactoryUtils.constantFactory(new Integer(5));\n         Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), factory);\n         assertTrue(map instanceof LazyMap);\n         try {\n             map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Factory<Object>) null);\n             fail(\"Expecting IllegalArgumentException for null factory\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         try {\n             map = MapUtils.lazyMap((Map<Object, Object>) null, factory);\n             fail(\"Expecting IllegalArgumentException for null map\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n-        Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n+        final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n         map = MapUtils.lazyMap(new HashMap<Object, Object>(), transformer);\n         assertTrue(map instanceof LazyMap);\n         try {\n             map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Transformer<Object, Object>) null);\n             fail(\"Expecting IllegalArgumentException for null transformer\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         try {\n             map = MapUtils.lazyMap((Map<Object, Object>) null, transformer);\n             fail(\"Expecting IllegalArgumentException for null map\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n \n     public void testLazyMapTransformer() {\n-        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), new Transformer<Object, Object>() {\n-            public Object transform(Object mapKey) {\n+        final Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), new Transformer<Object, Object>() {\n+            public Object transform(final Object mapKey) {\n                 if (mapKey instanceof String) {\n                     return new Integer((String) mapKey);\n                 }\n         });\n \n         assertEquals(0, map.size());\n-        Integer i1 = (Integer) map.get(\"5\");\n+        final Integer i1 = (Integer) map.get(\"5\");\n         assertEquals(new Integer(5), i1);\n         assertEquals(1, map.size());\n-        Integer i2 = (Integer) map.get(new String(new char[] {'5'}));\n+        final Integer i2 = (Integer) map.get(new String(new char[] {'5'}));\n         assertEquals(new Integer(5), i2);\n         assertEquals(1, map.size());\n         assertSame(i1, i2);\n         try {\n             MapUtils.putAll(null, null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             MapUtils.putAll(null, new Object[0]);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n \n         Map<String, String> test = MapUtils.putAll(new HashMap<String, String>(), new String[0]);\n         assertEquals(0, test.size());\n                 {\"BLUE\", \"#0000FF\"}\n             });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n \n         try {\n             MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n                 {\"BLUE\", \"#0000FF\"}\n             });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n \n         try {\n             MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n                 {\"BLUE\", \"#0000FF\"}\n             });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n \n         // flat array\n         test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n         in.put(\"4\", \"D\");\n         in.put(\"5\", \"E\");\n \n-        ResourceBundle b = new ListResourceBundle() {\n+        final ResourceBundle b = new ListResourceBundle() {\n             @Override\n             public Object[][] getContents() {\n                 final Object[][] contents = new Object[ in.size() ][2];\n         try {\n             MapUtils.verbosePrint(null, \"Map\", new HashMap<Object, Object>());\n             fail(\"Should generate NullPointerException\");\n-        } catch (NullPointerException expected) {\n+        } catch (final NullPointerException expected) {\n         }\n     }\n \n         try {\n             MapUtils.debugPrint(null, \"Map\", new HashMap<Object, Object>());\n             fail(\"Should generate NullPointerException\");\n-        } catch (NullPointerException expected) {\n+        } catch (final NullPointerException expected) {\n         }\n     }\n \n     public void testEmptyIfNull() {\n         assertTrue(MapUtils.emptyIfNull(null).isEmpty());\n         \n-        Map<Long, Long> map = new HashMap<Long, Long>();\n+        final Map<Long, Long> map = new HashMap<Long, Long>();\n         assertSame(map, MapUtils.emptyIfNull(map));\n     }\n     \n     public void testIsEmptyWithEmptyMap() {\n-        Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n         assertEquals(true, MapUtils.isEmpty(map));\n     }\n \n     public void testIsEmptyWithNonEmptyMap() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"item\", \"value\");\n         assertEquals(false, MapUtils.isEmpty(map));\n     }\n \n     public void testIsEmptyWithNull() {\n-        Map<Object, Object> map = null;\n+        final Map<Object, Object> map = null;\n         assertEquals(true, MapUtils.isEmpty(map));\n     }\n \n     public void testIsNotEmptyWithEmptyMap() {\n-        Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n         assertEquals(false, MapUtils.isNotEmpty(map));\n     }\n \n     public void testIsNotEmptyWithNonEmptyMap() {\n-        Map<String, String> map = new HashMap<String, String>();\n+        final Map<String, String> map = new HashMap<String, String>();\n         map.put(\"item\", \"value\");\n         assertEquals(true, MapUtils.isNotEmpty(map));\n     }\n \n     public void testIsNotEmptyWithNull() {\n-        Map<Object, Object> map = null;\n+        final Map<Object, Object> map = null;\n         assertEquals(false, MapUtils.isNotEmpty(map));\n     }\n \n     public void testPopulateMap() {\n         // Setup Test Data\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.add(\"1\");\n         list.add(\"3\");\n         list.add(\"5\");\n         try {\n             MapUtils.iterableMap(null);\n             fail(\"Should throw IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n-        }\n-        HashMap<String, String> map = new HashMap<String, String>();\n+        } catch (final IllegalArgumentException e) {\n+        }\n+        final HashMap<String, String> map = new HashMap<String, String>();\n         map.put(\"foo\", \"foov\");\n         map.put(\"bar\", \"barv\");\n         map.put(\"baz\", \"bazv\");\n-        IterableMap<String, String> iMap = MapUtils.iterableMap(map);\n+        final IterableMap<String, String> iMap = MapUtils.iterableMap(map);\n         assertEquals(map, iMap);\n         assertNotSame(map, iMap);\n-        HashedMap<String, String> hMap = new HashedMap<String, String>(map);\n+        final HashedMap<String, String> hMap = new HashedMap<String, String>(map);\n         assertSame(hMap, MapUtils.iterableMap(hMap));\n     }\n \n         try {\n             MapUtils.iterableSortedMap(null);\n             fail(\"Should throw IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n-        }\n-        TreeMap<String, String> map = new TreeMap<String, String>();\n+        } catch (final IllegalArgumentException e) {\n+        }\n+        final TreeMap<String, String> map = new TreeMap<String, String>();\n         map.put(\"foo\", \"foov\");\n         map.put(\"bar\", \"barv\");\n         map.put(\"baz\", \"bazv\");\n-        IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);\n+        final IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);\n         assertEquals(map, iMap);\n         assertNotSame(map, iMap);\n         assertSame(iMap, MapUtils.iterableMap(iMap));\n--- a/src/test/java/org/apache/commons/collections/MockTestCase.java\n+++ b/src/test/java/org/apache/commons/collections/MockTestCase.java\n  * @author Stephen Kestle\n  */\n public abstract class MockTestCase {\n-    private List<Object> mockObjects = new ArrayList<Object>();\n+    private final List<Object> mockObjects = new ArrayList<Object>();\n \n     @SuppressWarnings(\"unchecked\")\n-    protected <T> T createMock(Class<?> name) {\n-        T mock = (T) EasyMock.createMock(name);\n+    protected <T> T createMock(final Class<?> name) {\n+        final T mock = (T) EasyMock.createMock(name);\n         return registerMock(mock);\n     }\n \n-    private <T> T registerMock(T mock) {\n+    private <T> T registerMock(final T mock) {\n         mockObjects.add(mock);\n         return mock;\n     }\n \n-    protected <T> IExpectationSetters<T> expect(T t) {\n+    protected <T> IExpectationSetters<T> expect(final T t) {\n         return EasyMock.expect(t);\n     }\n \n     protected final void replay() {\n-        for (Object o : mockObjects) {\n+        for (final Object o : mockObjects) {\n             EasyMock.replay(o);\n         }\n     }\n \n     protected final void verify() {\n-        for (ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {\n+        for (final ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {\n             try {\n                 EasyMock.verify(i.next());\n-            } catch (AssertionError e) {\n+            } catch (final AssertionError e) {\n                 throw new AssertionError(i.previousIndex() + 1 + \"\"\n                         + e.getMessage());\n             }\n--- a/src/test/java/org/apache/commons/collections/PredicateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/PredicateUtilsTest.java\n         assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());\n         try {\n             PredicateUtils.exceptionPredicate().evaluate(null);\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             try {\n                 PredicateUtils.exceptionPredicate().evaluate(cString);\n-            } catch (FunctorException ex2) {\n+            } catch (final FunctorException ex2) {\n                 return;\n             }\n         }\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n         assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n \n     @Test(expected=IllegalArgumentException.class) \n     public void testAllPredicateEx6() {\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         coll.add(null);\n         AllPredicate.allPredicate(coll);\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n         assertEquals(false, PredicateUtils.anyPredicate(new Predicate[] {\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n \n     @Test(expected=IllegalArgumentException.class) \n     public void testAnyPredicateEx6() {\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         coll.add(null);\n         PredicateUtils.anyPredicate(coll);\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n         assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n \n     @Test(expected=IllegalArgumentException.class)\n     public void testOnePredicateEx6() {\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         coll.add(null);\n         PredicateUtils.onePredicate(coll);\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n         assertEquals(true, PredicateUtils.nonePredicate(new Predicate[] {\n                 FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate() }).evaluate(null));\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n         coll.add(TruePredicate.truePredicate());\n \n     @Test(expected=IllegalArgumentException.class)\n     public void testNonePredicateEx6() {\n-        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         coll.add(null);\n         PredicateUtils.nonePredicate(coll);\n     //------------------------------------------------------------------\n \n     @Test public void testUniquePredicate() {\n-        Predicate<Object> p = PredicateUtils.uniquePredicate();\n+        final Predicate<Object> p = PredicateUtils.uniquePredicate();\n         assertEquals(true, p.evaluate(new Object()));\n         assertEquals(true, p.evaluate(new Object()));\n         assertEquals(true, p.evaluate(new Object()));\n     //------------------------------------------------------------------\n \n     @Test public void testInvokerPredicate() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         assertEquals(true, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n         list.add(new Object());\n         assertEquals(false, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n     //------------------------------------------------------------------\n \n     @Test public void testInvokerPredicate2() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         assertEquals(false, PredicateUtils.invokerPredicate(\n             \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n         list.add(cString);\n                 TransformerUtils.nopTransformer(),\n                 TruePredicate.truePredicate()).evaluate(new Object()));\n \n-        Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n         map.put(Boolean.TRUE, \"Hello\");\n-        Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);\n-        Predicate<Object> p = EqualPredicate.<Object>equalPredicate(\"Hello\");\n+        final Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);\n+        final Predicate<Object> p = EqualPredicate.<Object>equalPredicate(\"Hello\");\n         assertEquals(false, PredicateUtils.transformedPredicate(t, p).evaluate(null));\n         assertEquals(true, PredicateUtils.transformedPredicate(t, p).evaluate(Boolean.TRUE));\n         try {\n             PredicateUtils.transformedPredicate(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // misc tests\n--- a/src/test/java/org/apache/commons/collections/SetUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/SetUtilsTest.java\n  */\n public class SetUtilsTest extends BulkTest {\n \n-    public SetUtilsTest(String name) {\n+    public SetUtilsTest(final String name) {\n         super(name);\n     }\n \n     }\n \n     public void testpredicatedSet() {\n-        Predicate<Object> predicate = new Predicate<Object>() {\n-            public boolean evaluate(Object o) {\n+        final Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(final Object o) {\n                 return o instanceof String;\n             }\n         };\n         try {\n             set = SetUtils.predicatedSet(new HashSet<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n         try {\n             set = SetUtils.predicatedSet(null, predicate);\n             fail(\"Expecting IllegalArgumentException for null set.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n     public void testEmptyIfNull() {\n         assertTrue(SetUtils.emptyIfNull(null).isEmpty());\n         \n-        Set<Long> set = new HashSet<Long>();\n+        final Set<Long> set = new HashSet<Long>();\n         assertSame(set, SetUtils.emptyIfNull(set));\n     }\n     \n     public void testEquals() {\n-        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n \n-        Set<String> a = new HashSet<String>(data);\n-        Set<String> b = new HashSet<String>(data);\n+        final Set<String> a = new HashSet<String>(data);\n+        final Set<String> b = new HashSet<String>(data);\n \n         assertEquals(true, a.equals(b));\n         assertEquals(true, SetUtils.isEqualSet(a, b));\n     }\n \n     public void testHashCode() {\n-        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n \n-        Set<String> a = new HashSet<String>(data);\n-        Set<String> b = new HashSet<String>(data);\n+        final Set<String> a = new HashSet<String>(data);\n+        final Set<String> b = new HashSet<String>(data);\n \n         assertEquals(true, a.hashCode() == b.hashCode());\n         assertEquals(true, a.hashCode() == SetUtils.hashCodeForSet(a));\n--- a/src/test/java/org/apache/commons/collections/SplitMapUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/SplitMapUtilsTest.java\n     private Map<String, Integer> backingMap;\n     private TransformedMap<String, String, String, Integer> transformedMap;\n \n-    private Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n-        public Integer transform(String input) {\n+    private final Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(final String input) {\n             return Integer.valueOf(input);\n         }\n     };\n \n-    public SplitMapUtilsTest(String testName) {\n+    public SplitMapUtilsTest(final String testName) {\n         super(testName);\n     }\n \n         }\n \n         // mapIterator\n-        MapIterator<String, Integer> it = map.mapIterator();\n+        final MapIterator<String, Integer> it = map.mapIterator();\n         while (it.hasNext()) {\n-            String k = it.next();\n+            final String k = it.next();\n             assertEquals(k, it.getKey());\n             assertEquals(Integer.valueOf(k), it.getValue());\n         }\n         });\n \n         // equals, hashcode\n-        IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);\n+        final IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);\n         assertEquals(other, map);\n         assertEquals(other.hashCode(), map.hashCode());\n \n     }\n \n     public void testAlreadyReadableMap() {\n-        HashedMap<String, Integer> hashedMap = new HashedMap<String, Integer>();\n+        final HashedMap<String, Integer> hashedMap = new HashedMap<String, Integer>();\n         assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));\n     }\n \n         });\n \n         // equals, hashcode\n-        Map<String, String> other = SplitMapUtils.writableMap(transformedMap);\n+        final Map<String, String> other = SplitMapUtils.writableMap(transformedMap);\n         assertEquals(other, map);\n         assertEquals(other.hashCode(), map.hashCode());\n \n         assertEquals(++sz, backingMap.size());\n \n         // putall\n-        Map<String, String> more = new HashMap<String, String>();\n+        final Map<String, String> more = new HashMap<String, String>();\n         more.put(\"foo\", \"77\");\n         more.put(\"bar\", \"88\");\n         more.put(\"baz\", \"99\");\n     }\n \n     public void testAlreadyWritableMap() {\n-        HashedMap<String, String> hashedMap = new HashedMap<String, String>();\n+        final HashedMap<String, String> hashedMap = new HashedMap<String, String>();\n         assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));\n     }\n \n-    private void attemptGetOperation(Runnable r) {\n+    private void attemptGetOperation(final Runnable r) {\n         attemptMapOperation(\"Put exposed as writable Map must not allow Get operations\", r);\n     }\n \n-    private void attemptPutOperation(Runnable r) {\n+    private void attemptPutOperation(final Runnable r) {\n         attemptMapOperation(\"Get exposed as writable Map must not allow Put operations\", r);\n     }\n \n-    private void attemptMapOperation(String s, Runnable r) {\n+    private void attemptMapOperation(final String s, final Runnable r) {\n         try {\n             r.run();\n             fail(s);\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/collections/TestUtils.java\n+++ b/src/test/java/org/apache/commons/collections/TestUtils.java\n      * @param o object that will be tested.\n      * @see #assertSameAfterSerialization(Object)\n      */\n-    public static void assertSameAfterSerialization(String msg, Object o) {\n+    public static void assertSameAfterSerialization(final String msg, final Object o) {\n         try {\n             // write object to byte buffer\n             final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n \n             // assert that original object and deserialized objects are the same\n             assertSame(msg, o, object);\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             // should never happen\n             throw new RuntimeException(e);\n-        } catch (ClassNotFoundException e) {\n+        } catch (final ClassNotFoundException e) {\n             // should never happen\n             throw new RuntimeException(e);\n         }\n      * @param o object that will be tested.\n      * @see #assertSameAfterSerialization(String, Object)\n      */\n-    public static void assertSameAfterSerialization(Object o) {\n+    public static void assertSameAfterSerialization(final Object o) {\n         assertSameAfterSerialization(null, o);\n     }\n }\n--- a/src/test/java/org/apache/commons/collections/TransformerUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/TransformerUtilsTest.java\n     /**\n      * Construct\n      */\n-    public TransformerUtilsTest(String name) {\n+    public TransformerUtilsTest(final String name) {\n         super(name);\n     }\n \n         assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer());\n         try {\n             TransformerUtils.exceptionTransformer().transform(null);\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             try {\n                 TransformerUtils.exceptionTransformer().transform(cString);\n-            } catch (FunctorException ex2) {\n+            } catch (final FunctorException ex2) {\n                 return;\n             }\n         }\n         assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));\n         try {\n             assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject));\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     //------------------------------------------------------------------\n \n     public void testMapTransformer() {\n-        Map<Object, Integer> map = new HashMap<Object, Integer>();\n+        final Map<Object, Integer> map = new HashMap<Object, Integer>();\n         map.put(null, 0);\n         map.put(cObject, 1);\n         map.put(cString, 2);\n         assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));\n         try {\n             TransformerUtils.asTransformer((Closure<Object>) null);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n         assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cInteger));\n         try {\n             TransformerUtils.asTransformer((Predicate<Object>) null);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n         assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));\n         try {\n             TransformerUtils.asTransformer((Factory<Object>) null);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testChainedTransformer() {\n-        Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer(\"A\");\n-        Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) \"B\");\n+        final Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer(\"A\");\n+        final Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) \"B\");\n \n         assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).transform(null));\n         assertEquals(\"B\", TransformerUtils.chainedTransformer(a, b).transform(null));\n         try {\n             TransformerUtils.chainedTransformer(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.chainedTransformer((Transformer[]) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.chainedTransformer(new Transformer[] {null, null});\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             coll = new ArrayList<Transformer<Object, Object>>();\n             coll.add(null);\n             coll.add(null);\n             TransformerUtils.chainedTransformer(coll);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // switchTransformer\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSwitchTransformer() {\n-        Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n-        Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n-        Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+        final Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        final Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        final Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n \n         assertEquals(\"A\", TransformerUtils.switchTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n         assertEquals(\"B\", TransformerUtils.switchTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n         try {\n             TransformerUtils.switchTransformer(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer((Predicate[]) null, (Transformer[]) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer((Map<Predicate<Object>, Transformer<Object, Object>>) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.switchTransformer(\n                     new Predicate[] { TruePredicate.truePredicate() },\n                     new Transformer[] { a, b });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // switchMapTransformer\n     //------------------------------------------------------------------\n \n     public void testSwitchMapTransformer() {\n-        Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n-        Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n-        Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+        final Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        final Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        final Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n \n         Map<String, Transformer<String, String>> map = new HashMap<String, Transformer<String,String>>();\n         map.put(\"HELLO\", a);\n         try {\n             TransformerUtils.switchMapTransformer(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // invokerTransformer\n     //------------------------------------------------------------------\n \n     public void testInvokerTransformer() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         assertEquals(new Integer(0), TransformerUtils.invokerTransformer(\"size\").transform(list));\n         list.add(new Object());\n         assertEquals(new Integer(1), TransformerUtils.invokerTransformer(\"size\").transform(list));\n         try {\n             TransformerUtils.invokerTransformer(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"noSuchMethod\").transform(new Object());\n             fail();\n-        } catch (FunctorException ex) {}\n+        } catch (final FunctorException ex) {}\n     }\n \n     // invokerTransformer2\n     //------------------------------------------------------------------\n \n     public void testInvokerTransformer2() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer(\"contains\",\n                 new Class[] { Object.class }, new Object[] { cString }).transform(list));\n         list.add(cString);\n         try {\n             TransformerUtils.invokerTransformer(null, null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"noSuchMethod\", new Class[] { Object.class },\n                     new Object[] { cString }).transform(new Object());\n             fail();\n-        } catch (FunctorException ex) {}\n+        } catch (final FunctorException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"badArgs\", null, new Object[] { cString });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"badArgs\", new Class[] { Object.class }, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"badArgs\", new Class[] {}, new Object[] { cString });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     // stringValueTransformer\n         try {\n             TransformerUtils.instantiateTransformer(null, new Object[] { \"str\" });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             TransformerUtils.instantiateTransformer(new Class[] {}, new Object[] { \"str\" });\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n \n         Transformer<Class<?>, Object> trans = TransformerUtils.instantiateTransformer(new Class[] { Long.class }, new Object[] { null });\n         try {\n             trans.transform(String.class);\n             fail();\n-        } catch (FunctorException ex) {}\n+        } catch (final FunctorException ex) {}\n \n         trans = TransformerUtils.instantiateTransformer();\n         assertEquals(\"\", trans.transform(String.class));\n--- a/src/test/java/org/apache/commons/collections/bag/AbstractBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/AbstractBagTest.java\n      * \n      * @param testName  the test class name\n      */\n-    public AbstractBagTest(String testName) {\n+    public AbstractBagTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testBagAdd() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         bag.add((T) \"A\");\n         assertTrue(\"Should contain 'A'\", bag.contains(\"A\"));\n         assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testBagEqualsSelf() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         assertTrue(bag.equals(bag));\n         bag.add((T) \"elt\");\n         assertTrue(bag.equals(bag));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemove() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         bag.add((T) \"A\");\n         assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n         bag.remove(\"A\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveAll() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         bag.add((T) \"A\", 2);\n         assertEquals(\"Should have count of 2\", 2, bag.getCount(\"A\"));\n         bag.add((T) \"B\");\n         bag.add((T) \"C\");\n         assertEquals(\"Should have count of 4\", 4, bag.size());\n-        List<String> delete = new ArrayList<String>();\n+        final List<String> delete = new ArrayList<String>();\n         delete.add(\"A\");\n         delete.add(\"B\");\n         bag.removeAll(delete);\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testContains() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         \n         assertEquals(\"Bag does not have at least 1 'A'\", false, bag.contains(\"A\"));\n         assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testContainsAll() {\n-        Bag<T> bag = makeObject();\n-        List<String> known = new ArrayList<String>();\n-        List<String> known1A = new ArrayList<String>();\n+        final Bag<T> bag = makeObject();\n+        final List<String> known = new ArrayList<String>();\n+        final List<String> known1A = new ArrayList<String>();\n         known1A.add(\"A\");\n-        List<String> known2A = new ArrayList<String>();\n+        final List<String> known2A = new ArrayList<String>();\n         known2A.add(\"A\");\n         known2A.add(\"A\");\n-        List<String> known1B = new ArrayList<String>();\n+        final List<String> known1B = new ArrayList<String>();\n         known1B.add(\"B\");\n-        List<String> known1A1B = new ArrayList<String>();\n+        final List<String> known1A1B = new ArrayList<String>();\n         known1A1B.add(\"A\");\n         known1A1B.add(\"B\");\n         \n \n     @SuppressWarnings(\"unchecked\")\n     public void testSize() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         assertEquals(\"Should have 0 total items\", 0, bag.size());\n         bag.add((T) \"A\");\n         assertEquals(\"Should have 1 total items\", 1, bag.size());\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testRetainAll() {\n-        Bag<T> bag = makeObject();\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"C\");\n-        List<String> retains = new ArrayList<String>();\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final List<String> retains = new ArrayList<String>();\n         retains.add(\"B\");\n         retains.add(\"C\");\n         bag.retainAll(retains);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIterator() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         bag.add((T) \"A\");\n         bag.add((T) \"A\");\n         bag.add((T) \"B\");\n         assertEquals(\"Bag should have 3 items\", 3, bag.size());\n-        Iterator<T> i = bag.iterator();\n+        final Iterator<T> i = bag.iterator();\n     \n         boolean foundA = false;\n         while (i.hasNext()) {\n-            String element = (String) i.next();\n+            final String element = (String) i.next();\n             // ignore the first A, remove the second via Iterator.remove()\n             if (element.equals(\"A\")) {\n                 if (foundA == false) {\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIteratorFail() {\n-        Bag<T> bag = makeObject();\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"B\");\n-        Iterator<T> it = bag.iterator();\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        final Iterator<T> it = bag.iterator();\n         it.next();\n         bag.remove(\"A\");\n         try {\n             it.next();\n             fail(\"Should throw ConcurrentModificationException\");\n-        } catch (ConcurrentModificationException e) {\n+        } catch (final ConcurrentModificationException e) {\n             // expected\n         }\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testIteratorFailNoMore() {\n-        Bag<T> bag = makeObject();\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"B\");\n-        Iterator<T> it = bag.iterator();\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        final Iterator<T> it = bag.iterator();\n         it.next();\n         it.next();\n         it.next();\n         try {\n             it.next();\n             fail(\"Should throw NoSuchElementException\");\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n             // expected\n         }\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testIteratorFailDoubleRemove() {\n-        Bag<T> bag = makeObject();\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"B\");\n-        Iterator<T> it = bag.iterator();\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        final Iterator<T> it = bag.iterator();\n         it.next();\n         it.next();\n         assertEquals(3, bag.size());\n         try {\n             it.remove();\n             fail(\"Should throw IllegalStateException\");\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n             // expected\n         }\n         assertEquals(2, bag.size());\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testIteratorRemoveProtectsInvariants() {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         bag.add((T) \"A\");\n         bag.add((T) \"A\");\n         assertEquals(2, bag.size());\n-        Iterator<T> it = bag.iterator();\n+        final Iterator<T> it = bag.iterator();\n         assertEquals(\"A\", it.next());\n         assertEquals(true, it.hasNext());\n         it.remove();\n         assertEquals(0, bag.size());\n         assertEquals(false, it.hasNext());\n         \n-        Iterator<T> it2 = bag.iterator();\n+        final Iterator<T> it2 = bag.iterator();\n         assertEquals(false, it2.hasNext());\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testToArray() {\n-        Bag<T> bag = makeObject();\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"C\");\n-        Object[] array = bag.toArray();\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final Object[] array = bag.toArray();\n         int a = 0, b = 0, c = 0;\n-        for (Object element : array) {\n+        for (final Object element : array) {\n             a += element.equals(\"A\") ? 1 : 0;\n             b += element.equals(\"B\") ? 1 : 0;\n             c += element.equals(\"C\") ? 1 : 0;\n \n     @SuppressWarnings(\"unchecked\")\n     public void testToArrayPopulate() {\n-        Bag<T> bag = makeObject();\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"C\");\n-        String[] array = bag.toArray(new String[0]);\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final String[] array = bag.toArray(new String[0]);\n         int a = 0, b = 0, c = 0;\n-        for (String element : array) {\n+        for (final String element : array) {\n             a += element.equals(\"A\") ? 1 : 0;\n             b += element.equals(\"B\") ? 1 : 0;\n             c += element.equals(\"C\") ? 1 : 0;\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testEquals() {\n-        Bag<T> bag = makeObject();\n-        Bag<T> bag2 = makeObject();\n+        final Bag<T> bag = makeObject();\n+        final Bag<T> bag2 = makeObject();\n         assertEquals(true, bag.equals(bag2));\n         bag.add((T) \"A\");\n         assertEquals(false, bag.equals(bag2));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEqualsHashBag() {\n-        Bag<T> bag = makeObject();\n-        Bag<T> bag2 = new HashBag<T>();\n+        final Bag<T> bag = makeObject();\n+        final Bag<T> bag2 = new HashBag<T>();\n         assertEquals(true, bag.equals(bag2));\n         bag.add((T) \"A\");\n         assertEquals(false, bag.equals(bag2));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testHashCode() {\n-        Bag<T> bag = makeObject();\n-        Bag<T> bag2 = makeObject();\n+        final Bag<T> bag = makeObject();\n+        final Bag<T> bag2 = makeObject();\n         assertEquals(0, bag.hashCode());\n         assertEquals(0, bag2.hashCode());\n         assertEquals(bag.hashCode(), bag2.hashCode());\n \n     //-----------------------------------------------------------------------\n     public void testEmptyBagSerialization() throws IOException, ClassNotFoundException {\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         if (!(bag instanceof Serializable && isTestSerialization())) {\n             return;\n         }\n         \n-        byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n-        Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n+        final byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n+        final Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n \n         assertEquals(\"Bag should be empty\",0, bag.size());\n         assertEquals(\"Bag should be empty\",0, bag2.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testFullBagSerialization() throws IOException, ClassNotFoundException {\n-        Bag<T> bag = makeObject();\n-        bag.add((T) \"A\");\n-        bag.add((T) \"A\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"B\");\n-        bag.add((T) \"C\");\n-        int size = bag.size();\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final int size = bag.size();\n         if (!(bag instanceof Serializable && isTestSerialization())) {\n             return;\n         }\n         \n-        byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n-        Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n+        final byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n+        final Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n \n         assertEquals(\"Bag should be same size\", size, bag.size());\n         assertEquals(\"Bag should be same size\", size, bag2.size());\n      */\n     public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {\n         // test to make sure the canonical form has been preserved\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n-            Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));\n+            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));\n             assertTrue(\"Bag is empty\",bag2.size()  == 0);\n             assertEquals(bag, bag2);\n         }\n     @SuppressWarnings(\"unchecked\")\n     public void testFullBagCompatibility() throws IOException, ClassNotFoundException {\n         // test to make sure the canonical form has been preserved\n-        Bag<T> bag = makeObject();\n+        final Bag<T> bag = makeObject();\n         bag.add((T) \"A\");\n         bag.add((T) \"A\");\n         bag.add((T) \"B\");\n         bag.add((T) \"B\");\n         bag.add((T) \"C\");\n         if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n-            Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));\n+            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));\n             assertEquals(\"Bag is the right size\",bag.size(), bag2.size());\n             assertEquals(bag, bag2);\n         }\n--- a/src/test/java/org/apache/commons/collections/bag/AbstractSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/AbstractSortedBagTest.java\n  */\n public abstract class AbstractSortedBagTest<T> extends AbstractBagTest<T> {\n \n-    public AbstractSortedBagTest(String testName) {\n+    public AbstractSortedBagTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/bag/HashBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/HashBagTest.java\n  */\n public class HashBagTest<T> extends AbstractBagTest<T> {\n     \n-    public HashBagTest(String testName) {\n+    public HashBagTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/bag/PredicatedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/PredicatedBagTest.java\n  */\n public class PredicatedBagTest<T> extends AbstractBagTest<T> {\n \n-    public PredicatedBagTest(String testName) {\n+    public PredicatedBagTest(final String testName) {\n         super(testName);\n     }\n \n \n     protected Predicate<T> stringPredicate() {\n         return new Predicate<T>() {\n-            public boolean evaluate(T o) {\n+            public boolean evaluate(final T o) {\n                 return o instanceof String;\n             }\n         };\n \n     protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n \n-    protected Bag<T> decorateBag(HashBag<T> bag, Predicate<T> predicate) {\n+    protected Bag<T> decorateBag(final HashBag<T> bag, final Predicate<T> predicate) {\n         return PredicatedBag.predicatedBag(bag, predicate);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testlegalAddRemove() {\n-        Bag<T> bag = makeTestBag();\n+        final Bag<T> bag = makeTestBag();\n         assertEquals(0, bag.size());\n-        T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\n+        final T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\n         for (int i = 0; i < els.length; i++) {\n             bag.add(els[i]);\n             assertEquals(i + 1, bag.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        Bag<T> bag = makeTestBag();\n-        Integer i = new Integer(3);\n+        final Bag<T> bag = makeTestBag();\n+        final Integer i = new Integer(3);\n         try {\n             bag.add((T) i);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\",\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalDecorate() {\n-        HashBag<Object> elements = new HashBag<Object>();\n+        final HashBag<Object> elements = new HashBag<Object>();\n         elements.add(\"one\");\n         elements.add(\"two\");\n         elements.add(new Integer(3));\n         try {\n             decorateBag((HashBag<T>) elements, stringPredicate());\n             fail(\"Bag contains an element that should fail the predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         try {\n             decorateBag(new HashBag<T>(), null);\n             fail(\"Expectiing IllegalArgumentException for null predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/bag/PredicatedSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/PredicatedSortedBagTest.java\n  */\n public class PredicatedSortedBagTest<T> extends AbstractSortedBagTest<T> {\n \n-    private SortedBag<T> nullBag = null;\n+    private final SortedBag<T> nullBag = null;\n \n-    public PredicatedSortedBagTest(String testName) {\n+    public PredicatedSortedBagTest(final String testName) {\n         super(testName);\n     }\n \n \n     protected Predicate<T> stringPredicate() {\n         return new Predicate<T>() {\n-            public boolean evaluate(T o) {\n+            public boolean evaluate(final T o) {\n                 return o instanceof String;\n             }\n         };\n \n     protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n \n-    protected SortedBag<T> decorateBag(SortedBag<T> bag, Predicate<T> predicate) {\n+    protected SortedBag<T> decorateBag(final SortedBag<T> bag, final Predicate<T> predicate) {\n         return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n     }\n \n     //--------------------------------------------------------------------------\n \n     public void testDecorate() {\n-        SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n+        final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n         ((PredicatedSortedBag<T>) bag).decorated();\n         try {\n             decorateBag(new TreeBag<T>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate\");\n-        } catch (IllegalArgumentException e) {}\n+        } catch (final IllegalArgumentException e) {}\n         try {\n             decorateBag(nullBag, stringPredicate());\n             fail(\"Expecting IllegalArgumentException for null bag\");\n-        } catch (IllegalArgumentException e) {}\n+        } catch (final IllegalArgumentException e) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSortOrder() {\n-        SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n-        String one = \"one\";\n-        String two = \"two\";\n-        String three = \"three\";\n+        final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n+        final String one = \"one\";\n+        final String two = \"two\";\n+        final String three = \"three\";\n         bag.add((T) one);\n         bag.add((T) two);\n         bag.add((T) three);\n         assertEquals(\"first element\", bag.first(), one);\n         assertEquals(\"last element\", bag.last(), two);\n-        Comparator<? super T> c = bag.comparator();\n+        final Comparator<? super T> c = bag.comparator();\n         assertTrue(\"natural order, so comparator should be null\", c == null);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/bag/TransformedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/TransformedBagTest.java\n  */\n public class TransformedBagTest<T> extends AbstractBagTest<T> {\n \n-    public TransformedBagTest(String testName) {\n+    public TransformedBagTest(final String testName) {\n         super(testName);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n         //T had better be Object!\n-        Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(),\n+        final Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(),\n                 (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n             bag.add((T) els[i]);\n             assertEquals(i + 1, bag.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag_decorateTransform() {\n-        Bag<T> originalBag = new HashBag<T>();\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n-        for (Object el : els) {\n+        final Bag<T> originalBag = new HashBag<T>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n             originalBag.add((T) el);\n         }\n-        Bag<T> bag = TransformedBag.transformedBag(originalBag,\n+        final Bag<T> bag = TransformedBag.transformedBag(originalBag,\n                 (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, bag.size());\n-        for (Object el : els) {\n+        for (final Object el : els) {\n             assertEquals(true, bag.contains(new Integer((String) el)));\n             assertEquals(false, bag.contains(el));\n         }\n--- a/src/test/java/org/apache/commons/collections/bag/TransformedSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/TransformedSortedBagTest.java\n  */\n public class TransformedSortedBagTest<T> extends AbstractSortedBagTest<T> {\n \n-    public TransformedSortedBagTest(String testName) {\n+    public TransformedSortedBagTest(final String testName) {\n         super(testName);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedBag() {\n-        SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, bag.size());\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n             bag.add((T) els[i]);\n             assertEquals(i + 1, bag.size());\n     }\n \n     public void testTransformedBag_decorateTransform() {\n-        Bag<Object> originalBag = new TreeBag<Object>();\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n-        for (Object el : els) {\n+        final Bag<Object> originalBag = new TreeBag<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n             originalBag.add(el);\n         }\n-        Bag<?> bag = TransformedBag.transformedBag(originalBag, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final Bag<?> bag = TransformedBag.transformedBag(originalBag, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, bag.size());\n-        for (Object el : els) {\n+        for (final Object el : els) {\n             assertEquals(true, bag.contains(new Integer((String) el)));\n         }\n         \n--- a/src/test/java/org/apache/commons/collections/bag/TreeBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/TreeBagTest.java\n  */\n public class TreeBagTest<T> extends AbstractSortedBagTest<T> {\n \n-    public TreeBagTest(String testName) {\n+    public TreeBagTest(final String testName) {\n         super(testName);\n     }\n \n \n    // TODO: Generics (for example... is this even needed?)\n    public void testCollections265() {\n-       Bag<Object> bag = new TreeBag<Object>();\n+       final Bag<Object> bag = new TreeBag<Object>();\n        try {\n            bag.add(new Object());\n            fail(\"IllegalArgumentException expected\");\n-       } catch(IllegalArgumentException iae) {\n+       } catch(final IllegalArgumentException iae) {\n            // expected;\n        }\n    }\n    \n     @SuppressWarnings(\"unchecked\")\n     public SortedBag<T> setupBag() {\n-        SortedBag<T> bag = makeObject();\n+        final SortedBag<T> bag = makeObject();\n         bag.add((T) \"C\");\n         bag.add((T) \"A\");\n         bag.add((T) \"B\");\n     }\n \n     public void testOrdering() {\n-        Bag<T> bag = setupBag();\n+        final Bag<T> bag = setupBag();\n         assertEquals(\"Should get elements in correct order\", \"A\", bag.toArray()[0]);\n         assertEquals(\"Should get elements in correct order\", \"B\", bag.toArray()[1]);\n         assertEquals(\"Should get elements in correct order\", \"C\", bag.toArray()[2]);\n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractBidiMapTest.java\n  */\n public abstract class AbstractBidiMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public AbstractBidiMapTest(String testName) {\n+    public AbstractBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n             return;\n         }\n \n-        BidiMap<K, V> map = makeObject();\n-        BidiMap<V, K> inverse = map.inverseBidiMap();\n+        final BidiMap<K, V> map = makeObject();\n+        final BidiMap<V, K> inverse = map.inverseBidiMap();\n         assertEquals(0, map.size());\n         assertEquals(map.size(), inverse.size());\n \n \n     public void verifyInverse() {\n         assertEquals(map.size(), ((BidiMap<K, V>) map).inverseBidiMap().size());\n-        Map<K, V> map1 = new HashMap<K, V>(map);\n-        Map<V, K> map2 = new HashMap<V, K>(((BidiMap<K, V>) map).inverseBidiMap());\n-        Set<K> keys1 = map1.keySet();\n-        Set<V> keys2 = map2.keySet();\n-        Collection<V> values1 = map1.values();\n-        Collection<K> values2 = map2.values();\n+        final Map<K, V> map1 = new HashMap<K, V>(map);\n+        final Map<V, K> map2 = new HashMap<V, K>(((BidiMap<K, V>) map).inverseBidiMap());\n+        final Set<K> keys1 = map1.keySet();\n+        final Set<V> keys2 = map2.keySet();\n+        final Collection<V> values1 = map1.values();\n+        final Collection<K> values2 = map2.values();\n         assertEquals(true, keys1.containsAll(values2));\n         assertEquals(true, values2.containsAll(keys1));\n         assertEquals(true, values1.containsAll(keys2));\n             getSampleKeys()[0]);\n     }\n \n-    private final void doTestGetKey(BidiMap<?, ?> map, Object key, Object value) {\n+    private final void doTestGetKey(final BidiMap<?, ?> map, final Object key, final Object value) {\n         assertEquals(\"Value not found for key.\", value, map.get(key));\n         assertEquals(\"Key not found for value.\", key, map.getKey(value));\n     }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private final <T> void modifyEntrySet(BidiMap<?, T> map) {\n+    private final <T> void modifyEntrySet(final BidiMap<?, T> map) {\n         // Gets first entry\n         final Map.Entry<?, T> entry = map.entrySet().iterator().next();\n \n             try {\n                 makeFullMap().clear();\n                 fail();\n-            } catch(UnsupportedOperationException ex) {}\n+            } catch(final UnsupportedOperationException ex) {}\n             return;\n         }\n \n             try {\n                 makeFullMap().remove(getSampleKeys()[0]);\n                 fail();\n-            } catch(UnsupportedOperationException ex) {}\n+            } catch(final UnsupportedOperationException ex) {}\n             try {\n                 makeFullMap().removeValue(getSampleValues()[0]);\n                 fail();\n-            } catch(UnsupportedOperationException ex) {}\n+            } catch(final UnsupportedOperationException ex) {}\n             return;\n         }\n \n         assertEquals(null, makeFullMap().removeValue(\"NotPresent\"));\n     }\n \n-    private final void remove(BidiMap<?, ?> map, Object key) {\n+    private final void remove(final BidiMap<?, ?> map, final Object key) {\n         final Object value = map.remove(key);\n         assertTrue(\"Key was not removed.\", !map.containsKey(key));\n         assertNull(\"Value was not removed.\", map.getKey(value));\n     }\n \n-    private final void removeValue(BidiMap<?, ?> map, Object value) {\n+    private final void removeValue(final BidiMap<?, ?> map, final Object value) {\n         final Object key = map.removeValue(value);\n         assertTrue(\"Key was not removed.\", !map.containsKey(key));\n         assertNull(\"Value was not removed.\", map.getKey(value));\n     //-----------------------------------------------------------------------\n     public void testBidiKeySetValuesOrder() {\n         resetFull();\n-        Iterator<K> keys = map.keySet().iterator();\n-        Iterator<V> values = map.values().iterator();\n+        final Iterator<K> keys = map.keySet().iterator();\n+        final Iterator<V> values = map.values().iterator();\n         for (; keys.hasNext() && values.hasNext();) {\n-            K key = keys.next();\n-            V value = values.next();\n+            final K key = keys.next();\n+            final V value = values.next();\n             assertSame(map.get(key), value);\n         }\n         assertEquals(false, keys.hasNext());\n         removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n     }\n \n-    private final void removeByKeySet(BidiMap<?, ?> map, Object key, Object value) {\n+    private final void removeByKeySet(final BidiMap<?, ?> map, final Object key, final Object value) {\n         map.keySet().remove(key);\n \n         assertTrue(\"Key was not removed.\", !map.containsKey(key));\n         removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n     }\n \n-    private final void removeByEntrySet(BidiMap<?, ?> map, Object key, Object value) {\n-        Map<Object, Object> temp = new HashMap<Object, Object>();\n+    private final void removeByEntrySet(final BidiMap<?, ?> map, final Object key, final Object value) {\n+        final Map<Object, Object> temp = new HashMap<Object, Object>();\n         temp.put(key, value);\n         map.entrySet().remove(temp.entrySet().iterator().next());\n \n             super();\n         }\n         public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n-            K key1 = getSampleKeys()[0];\n-            K key2 = getSampleKeys()[1];\n-            V newValue1 = getNewSampleValues()[0];\n-            V newValue2 = getNewSampleValues()[1];\n+            final K key1 = getSampleKeys()[0];\n+            final K key2 = getSampleKeys()[1];\n+            final V newValue1 = getNewSampleValues()[0];\n+            final V newValue2 = getNewSampleValues()[1];\n \n             resetFull();\n             // explicitly get entries as sample values/keys are connected for some maps\n             // such as BeanMap\n             Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n-            Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n             it = TestBidiMapEntrySet.this.getCollection().iterator();\n-            Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n             Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n-            Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n             itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n-            Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n             TestBidiMapEntrySet.this.verify();\n \n             if (isSetValueSupported() == false) {\n                 try {\n                     entry1.setValue(newValue1);\n-                } catch (UnsupportedOperationException ex) {\n+                } catch (final UnsupportedOperationException ex) {\n                 }\n                 return;\n             }\n             // key1=newValue1, key2=newValue2\n             try {\n                 entry2.setValue(newValue1);  // should remove key1\n-            } catch (IllegalArgumentException ex) {\n+            } catch (final IllegalArgumentException ex) {\n                 return;  // simplest way of dealing with tricky situation\n             }\n             entryConfirmed2.setValue(newValue1);\n     public class TestInverseBidiMap extends AbstractBidiMapTest<V, K> {\n         final AbstractBidiMapTest<K, V> main;\n \n-        public TestInverseBidiMap(AbstractBidiMapTest<K, V> main) {\n+        public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main) {\n             super();\n             this.main = main;\n         }\n \n     //-----------------------------------------------------------------------\n     public void testBidiMapIteratorSet() {\n-        V newValue1 = getOtherValues()[0];\n-        V newValue2 = getOtherValues()[1];\n+        final V newValue1 = getOtherValues()[0];\n+        final V newValue2 = getOtherValues()[1];\n \n         resetFull();\n-        BidiMap<K, V> bidi = getMap();\n-        MapIterator<K, V> it = bidi.mapIterator();\n+        final BidiMap<K, V> bidi = getMap();\n+        final MapIterator<K, V> it = bidi.mapIterator();\n         assertEquals(true, it.hasNext());\n-        K key1 = it.next();\n+        final K key1 = it.next();\n \n         if (isSetValueSupported() == false) {\n             try {\n                 it.setValue(newValue1);\n                 fail();\n-            } catch (UnsupportedOperationException ex) {\n+            } catch (final UnsupportedOperationException ex) {\n             }\n             return;\n         }\n         assertEquals(newValue1, bidi.get(key1));\n         verify();\n \n-        K key2 = it.next();\n+        final K key2 = it.next();\n         it.setValue(newValue2);\n         confirmed.put(key2, newValue2);\n         assertSame(key2, it.getKey());\n         try {\n             it.setValue(newValue1);  // should remove key1\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;  // simplest way of dealing with tricky situation\n         }\n         confirmed.put(key2, newValue1);\n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecoratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecoratorTest.java\n public class AbstractOrderedBidiMapDecoratorTest<K, V>\n         extends AbstractOrderedBidiMapTest<K, V> {\n \n-    public AbstractOrderedBidiMapDecoratorTest(String testName) {\n+    public AbstractOrderedBidiMapDecoratorTest(final String testName) {\n         super(testName);\n     }\n \n             super(new DualTreeBidiMap<K, V>());\n         }\n \n-        public TestOrderedBidiMap(OrderedBidiMap<K, V> map) {\n+        public TestOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n             super(map);\n         }\n \n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapTest.java\n  */\n public abstract class AbstractOrderedBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n \n-    public AbstractOrderedBidiMapTest(String testName) {\n+    public AbstractOrderedBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n         try {\n             bidi.firstKey();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n \n         resetFull();\n         bidi = getMap();\n-        K confirmedFirst = confirmed.keySet().iterator().next();\n+        final K confirmedFirst = confirmed.keySet().iterator().next();\n         assertEquals(confirmedFirst, bidi.firstKey());\n     }\n \n         try {\n             bidi.lastKey();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n \n         resetFull();\n         bidi = getMap();\n         K confirmedLast = null;\n-        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+        for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n             confirmedLast = it.next();\n         }\n         assertEquals(confirmedLast, bidi.lastKey());\n         if (isAllowNullKey() == false) {\n             try {\n                 assertEquals(null, bidi.nextKey(null)); // this is allowed too\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             assertEquals(null, bidi.nextKey(null));\n         }\n \n         resetFull();\n         bidi = (OrderedBidiMap<K, V>) map;\n-        Iterator<K> it = confirmed.keySet().iterator();\n+        final Iterator<K> it = confirmed.keySet().iterator();\n         K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            K confirmedObject = it.next();\n+            final K confirmedObject = it.next();\n             assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n             try {\n                 bidi.nextKey(null);\n                 fail();\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             assertEquals(null, bidi.nextKey(null));\n         }\n         if (isAllowNullKey() == false) {\n             try {\n                 assertEquals(null, bidi.previousKey(null)); // this is allowed too\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             assertEquals(null, bidi.previousKey(null));\n         }\n \n         resetFull();\n         bidi = getMap();\n-        List<K> list = new ArrayList<K>(confirmed.keySet());\n+        final List<K> list = new ArrayList<K>(confirmed.keySet());\n         Collections.reverse(list);\n-        Iterator<K> it = list.iterator();\n+        final Iterator<K> it = list.iterator();\n         K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            K confirmedObject = it.next();\n+            final K confirmedObject = it.next();\n             assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n             try {\n                 bidi.previousKey(null);\n                 fail();\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             assertEquals(null, bidi.previousKey(null));\n         }\n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapTest.java\n     protected List<V> sortedValues = new ArrayList<V>();\n     protected SortedSet<V> sortedNewValues = new TreeSet<V>();\n \n-    public AbstractSortedBidiMapTest(String testName) {\n+    public AbstractSortedBidiMapTest(final String testName) {\n         super(testName);\n         sortedKeys = getAsList(getSampleKeys());\n         Collections.sort(sortedKeys);\n         sortedKeys = Collections.unmodifiableList(sortedKeys);\n \n-        Map<K, V> map = new TreeMap<K, V>();\n+        final Map<K, V> map = new TreeMap<K, V>();\n         addSampleMappings(map);\n \n         sortedValues.addAll(map.values());\n     //-----------------------------------------------------------------------\n     public void testBidiHeadMapContains() {\n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        K first = it.next();\n-        K toKey = it.next();\n-        K second = it.next();\n-        V firstValue = sm.get(first);\n-        V secondValue = sm.get(second);\n-\n-        SortedMap<K, V> head = sm.headMap(toKey);\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K toKey = it.next();\n+        final K second = it.next();\n+        final V firstValue = sm.get(first);\n+        final V secondValue = sm.get(second);\n+\n+        final SortedMap<K, V> head = sm.headMap(toKey);\n         assertEquals(1, head.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, head.containsKey(first));\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        K first = it.next();\n-        K second = it.next();\n-        K toKey = it.next();\n-\n-        V firstValue = sm.get(first);\n-        V secondValue = sm.get(second);\n-        V toKeyValue = sm.get(toKey);\n-\n-        SortedMap<K, V> sub = sm.headMap(toKey);\n-        int size = sm.size();\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final V firstValue = sm.get(first);\n+        final V secondValue = sm.get(second);\n+        final V toKeyValue = sm.get(toKey);\n+\n+        final SortedMap<K, V> sub = sm.headMap(toKey);\n+        final int size = sm.size();\n         assertEquals(2, sub.size());\n         sub.clear();\n         assertEquals(0, sub.size());\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        K first = it.next();\n-        K second = it.next();\n-        K toKey = it.next();\n-\n-        int size = sm.size();\n-        SortedMap<K, V> sub = sm.headMap(toKey);\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.headMap(toKey);\n         assertEquals(2, sub.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n \n-        V firstValue = sub.remove(first);\n+        final V firstValue = sub.remove(first);\n         assertEquals(1, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(size - 1, sm.inverseBidiMap().size());\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n \n-        V secondValue = sub.remove(second);\n+        final V secondValue = sub.remove(second);\n         assertEquals(0, sub.size());\n         assertEquals(size - 2, sm.size());\n         assertEquals(size - 2, sm.inverseBidiMap().size());\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        K first = it.next();\n-        K second = it.next();\n-        K toKey = it.next();\n-\n-        int size = sm.size();\n-        SortedMap<K, V> sub = sm.headMap(toKey);\n-        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.headMap(toKey);\n+        final Set<Map.Entry<K, V>> set = sub.entrySet();\n         assertEquals(2, sub.size());\n         assertEquals(2, set.size());\n \n-        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n-        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n-        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, set.contains(firstEntry));\n     //-----------------------------------------------------------------------\n     public void testBidiTailMapContains() {\n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        K first = it.next();\n-        K fromKey = it.next();\n-        K second = it.next();\n-        V firstValue = sm.get(first);\n-        V fromKeyValue = sm.get(fromKey);\n-        V secondValue = sm.get(second);\n-\n-        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K fromKey = it.next();\n+        final K second = it.next();\n+        final V firstValue = sm.get(first);\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V secondValue = sm.get(second);\n+\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n         assertEquals(sm.size() - 1, sub.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(false, sub.containsKey(first));\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        K first = it.next();\n-        K fromKey = it.next();\n-        K second = it.next();\n-\n-        V firstValue = sm.get(first);\n-        V fromKeyValue = sm.get(fromKey);\n-        V secondValue = sm.get(second);\n-\n-        SortedMap<K, V> sub = sm.tailMap(fromKey);\n-        int size = sm.size();\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K first = it.next();\n+        final K fromKey = it.next();\n+        final K second = it.next();\n+\n+        final V firstValue = sm.get(first);\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V secondValue = sm.get(second);\n+\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        final int size = sm.size();\n         assertEquals(size - 3, sub.size());\n         sub.clear();\n         assertEquals(0, sub.size());\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        K fromKey = it.next();\n-        K first = it.next();\n-        K second = it.next();\n-\n-        int size = sm.size();\n-        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n \n-        Object firstValue = sub.remove(first);\n+        final Object firstValue = sub.remove(first);\n         assertEquals(size - 3, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(size - 1, sm.inverseBidiMap().size());\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n \n-        Object secondValue = sub.remove(second);\n+        final Object secondValue = sub.remove(second);\n         assertEquals(size - 4, sub.size());\n         assertEquals(size - 2, sm.size());\n         assertEquals(size - 2, sm.inverseBidiMap().size());\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        K fromKey = it.next();\n-        K first = it.next();\n-        K second = it.next();\n-\n-        int size = sm.size();\n-        SortedMap<K, V> sub = sm.tailMap(fromKey);\n-        Set<Map.Entry<K, V>> set = sub.entrySet();\n-        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        final Set<Map.Entry<K, V>> set = sub.entrySet();\n+        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n         it2.next();\n-        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n-        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, set.contains(firstEntry));\n     //-----------------------------------------------------------------------\n     public void testBidiSubMapContains() {\n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        K first = it.next();\n-        K fromKey = it.next();\n-        K second = it.next();\n-        K toKey = it.next();\n-        K third = it.next();\n-        V firstValue = sm.get(first);\n-        V fromKeyValue = sm.get(fromKey);\n-        V secondValue = sm.get(second);\n-        V thirdValue = sm.get(third);\n-\n-        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K fromKey = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+        final K third = it.next();\n+        final V firstValue = sm.get(first);\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V secondValue = sm.get(second);\n+        final V thirdValue = sm.get(third);\n+\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n         assertEquals(2, sub.size());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(false, sub.containsKey(first));\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        it.next();\n-        K fromKey = it.next();\n-        K first = it.next();\n-        K second = it.next();\n-        K toKey = it.next();\n-\n-        V fromKeyValue = sm.get(fromKey);\n-        V firstValue = sm.get(first);\n-        V secondValue = sm.get(second);\n-        V toKeyValue = sm.get(toKey);\n-\n-        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n-        int size = sm.size();\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V firstValue = sm.get(first);\n+        final V secondValue = sm.get(second);\n+        final V toKeyValue = sm.get(toKey);\n+\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        final int size = sm.size();\n         assertEquals(3, sub.size());\n         sub.clear();\n         assertEquals(0, sub.size());\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        K fromKey = it.next();\n-        K first = it.next();\n-        K second = it.next();\n-        K toKey = it.next();\n-\n-        int size = sm.size();\n-        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, sm.containsKey(second));\n         assertEquals(true, sub.containsKey(second));\n \n-        V firstValue = sub.remove(first);\n+        final V firstValue = sub.remove(first);\n         assertEquals(2, sub.size());\n         assertEquals(size - 1, sm.size());\n         assertEquals(size - 1, sm.inverseBidiMap().size());\n         assertEquals(false, sub.containsKey(first));\n         assertEquals(false, sub.containsValue(firstValue));\n \n-        V secondValue = sub.remove(second);\n+        final V secondValue = sub.remove(second);\n         assertEquals(1, sub.size());\n         assertEquals(size - 2, sm.size());\n         assertEquals(size - 2, sm.inverseBidiMap().size());\n         }\n \n         // extra test as other tests get complex\n-        SortedBidiMap<K, V> sm = makeFullMap();\n-        Iterator<K> it = sm.keySet().iterator();\n-        it.next();\n-        it.next();\n-        K fromKey = it.next();\n-        K first = it.next();\n-        K second = it.next();\n-        K toKey = it.next();\n-\n-        int size = sm.size();\n-        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n-        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        final Set<Map.Entry<K, V>> set = sub.entrySet();\n         assertEquals(3, set.size());\n-        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n         it2.next();\n-        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n-        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n         assertEquals(true, sm.containsKey(first));\n         assertEquals(true, sub.containsKey(first));\n         assertEquals(true, set.contains(firstEntry));\n--- a/src/test/java/org/apache/commons/collections/bidimap/DualHashBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/DualHashBidiMapTest.java\n         return BulkTest.makeSuite(DualHashBidiMapTest.class);\n     }\n \n-    public DualHashBidiMapTest(String testName) {\n+    public DualHashBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/bidimap/DualTreeBidiMap2Test.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/DualTreeBidiMap2Test.java\n         return BulkTest.makeSuite(DualTreeBidiMap2Test.class);\n     }\n \n-    public DualTreeBidiMap2Test(String testName) {\n+    public DualTreeBidiMap2Test(final String testName) {\n         super(testName);\n     }\n \n \n     public void testComparator() {\n         resetEmpty();\n-        SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;\n+        final SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;\n         assertNotNull(bidi.comparator());\n         assertTrue(bidi.comparator() instanceof ReverseComparator);\n     }\n \n     public void testComparator2() {\n-        DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<String, Integer>(\n+        final DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<String, Integer>(\n                 String.CASE_INSENSITIVE_ORDER, null);\n         dtbm.put(\"two\", 0);\n         dtbm.put(\"one\", 1);\n     }\n \n     public void testSerializeDeserializeCheckComparator() throws Exception {\n-        SortedBidiMap<?, ?> obj = makeObject();\n+        final SortedBidiMap<?, ?> obj = makeObject();\n         if (obj instanceof Serializable && isTestSerialization()) {\n-            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n             out.writeObject(obj);\n             out.close();\n \n-            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n-            Object dest = in.readObject();\n+            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            final Object dest = in.readObject();\n             in.close();\n \n-            SortedBidiMap<?,?> bidi = (SortedBidiMap<?,?>) dest;\n+            final SortedBidiMap<?,?> bidi = (SortedBidiMap<?,?>) dest;\n             assertNotNull(obj.comparator());\n             assertNotNull(bidi.comparator());\n             assertTrue(bidi.comparator() instanceof ReverseComparator);\n \n     private static class IntegerComparator implements Comparator<Integer>, java.io.Serializable{\n         private static final long serialVersionUID = 1L;\n-        public int compare(Integer o1, Integer o2) {\n+        public int compare(final Integer o1, final Integer o2) {\n             return o1.compareTo(o2);\n         }\n     }\n \n     public void testCollections364() throws Exception {\n-        DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<String, Integer>(\n+        final DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<String, Integer>(\n                 String.CASE_INSENSITIVE_ORDER, new IntegerComparator());\n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n         out.writeObject(original);\n         out.close();\n \n-        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n         @SuppressWarnings(\"unchecked\")\n+        final\n         DualTreeBidiMap<String, Integer> deserialised = (DualTreeBidiMap<String, Integer>) in.readObject();\n         in.close();\n \n     }\n \n     public void testSortOrder() throws Exception {\n-        SortedBidiMap<K, V> sm = makeFullMap();\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n \n         // Sort by the comparator used in the makeEmptyBidiMap() method\n         List<K> newSortedKeys = getAsList(getSampleKeys());\n         Collections.sort(newSortedKeys, new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n         newSortedKeys = Collections.unmodifiableList(newSortedKeys);\n \n-        Iterator<K> mapIter = sm.keySet().iterator();\n-        Iterator<K> expectedIter = newSortedKeys.iterator();\n+        final Iterator<K> mapIter = sm.keySet().iterator();\n+        final Iterator<K> expectedIter = newSortedKeys.iterator();\n         while (expectedIter.hasNext()) {\n-            K expectedKey = expectedIter.next();\n-            K mapKey = mapIter.next();\n+            final K expectedKey = expectedIter.next();\n+            final K mapKey = mapIter.next();\n             assertNotNull(\"key in sorted list may not be null\", expectedKey);\n             assertNotNull(\"key in map may not be null\", mapKey);\n             assertEquals(\"key from sorted list and map must be equal\", expectedKey, mapKey);\n--- a/src/test/java/org/apache/commons/collections/bidimap/DualTreeBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/DualTreeBidiMapTest.java\n         return BulkTest.makeSuite(DualTreeBidiMapTest.class);\n     }\n \n-    public DualTreeBidiMapTest(String testName) {\n+    public DualTreeBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/bidimap/TreeBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TreeBidiMapTest.java\n         return BulkTest.makeSuite(TreeBidiMapTest.class);\n     }\n \n-    public TreeBidiMapTest(String testName) {\n+    public TreeBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMapTest.java\n         return BulkTest.makeSuite(UnmodifiableBidiMapTest.class);\n     }\n \n-    public UnmodifiableBidiMapTest(String testName) {\n+    public UnmodifiableBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public BidiMap<K, V> makeFullMap() {\n-        BidiMap<K, V> bidi = new DualHashBidiMap<K, V>();\n+        final BidiMap<K, V> bidi = new DualHashBidiMap<K, V>();\n         addSampleMappings(bidi);\n         return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);\n     }\n--- a/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMapTest.java\n         return BulkTest.makeSuite(UnmodifiableOrderedBidiMapTest.class);\n     }\n \n-    public UnmodifiableOrderedBidiMapTest(String testName) {\n+    public UnmodifiableOrderedBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public BidiMap<K, V> makeFullMap() {\n-        OrderedBidiMap<K, V> bidi = new TreeBidiMap<K, V>();\n+        final OrderedBidiMap<K, V> bidi = new TreeBidiMap<K, V>();\n         addSampleMappings(bidi);\n         return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);\n     }\n--- a/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMapTest.java\n         return BulkTest.makeSuite(UnmodifiableSortedBidiMapTest.class);\n     }\n \n-    public UnmodifiableSortedBidiMapTest(String testName) {\n+    public UnmodifiableSortedBidiMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public SortedBidiMap<K, V> makeFullMap() {\n-        SortedBidiMap<K, V> bidi = new DualTreeBidiMap<K, V>();\n+        final SortedBidiMap<K, V> bidi = new DualTreeBidiMap<K, V>();\n         addSampleMappings(bidi);\n         return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);\n     }\n--- a/src/test/java/org/apache/commons/collections/buffer/BlockingBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/BlockingBufferTest.java\n  */\n public class BlockingBufferTest<E> extends AbstractObjectTest {\n \n-    public BlockingBufferTest(String testName) {\n+    public BlockingBufferTest(final String testName) {\n         super(testName);\n     }\n \n      * {@link BlockingBuffer#add(Object)}.\n      */\n     public void testGetWithAdd() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n         new DelayedAdd<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n     }\n \n     public void testGetWithAddTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n+        final E obj = makeElement();\n         new DelayedAdd<E>(blockingBuffer, obj, 100).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n      * {@link BlockingBuffer#addAll(java.util.Collection)}.\n      */\n     public void testGetWithAddAll() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n         new DelayedAddAll<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n     }\n \n     public void testGetWithAddAllTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 500);\n+        final E obj = makeElement();\n         new DelayedAddAll<E>(blockingBuffer, obj, 100).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n      * {@link BlockingBuffer#add(Object)}.\n      */\n     public void testRemoveWithAdd() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n         new DelayedAdd<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n     }\n \n     public void testRemoveWithAddTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n+        final E obj = makeElement();\n         new DelayedAdd<E>(blockingBuffer, obj, 500).start();\n         try {\n             blockingBuffer.remove();\n-        } catch (BufferUnderflowException e) {\n+        } catch (final BufferUnderflowException e) {\n         }\n     }\n \n      * {@link BlockingBuffer#addAll(java.util.Collection)}.\n      */\n     public void testRemoveWithAddAll() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n         new DelayedAddAll<E>(blockingBuffer, obj).start();\n \n         // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n     }\n \n     public void testRemoveWithAddAllTimeout() {\n-        Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = BlockingBuffer.blockingBuffer(new MyBuffer<E>(), 100);\n+        final E obj = makeElement();\n         new DelayedAddAll<E>(blockingBuffer, obj, 500).start();\n         try {\n             blockingBuffer.remove();\n-        } catch (BufferUnderflowException e) {\n+        } catch (final BufferUnderflowException e) {\n         }\n     }\n \n      * then both threads should complete.\n      */\n     public void testBlockedGetWithAdd() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n \n         // run methods will get and compare -- must wait for add\n-        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n-        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n+        final Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        final Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n         thread1.start();\n         thread2.start();\n \n      * singleton is added then both threads should complete.\n      */\n     public void testBlockedGetWithAddAll() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n \n         // run methods will get and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n-        Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n+        final Thread thread1 = new ReadThread<E>(blockingBuffer, obj);\n+        final Thread thread2 = new ReadThread<E>(blockingBuffer, obj);\n         thread1.start();\n         thread2.start();\n \n      * Tests interrupted {@link BlockingBuffer#get()}.\n      */\n     public void testInterruptedGet() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n \n         // spawn a read thread to wait on the empty buffer\n-        ArrayList<String> exceptionList = new ArrayList<String>();\n-        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList);\n+        final ArrayList<String> exceptionList = new ArrayList<String>();\n+        final Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList);\n         thread.start();\n \n         // Interrupting the thread should cause it to throw BufferUnderflowException\n      * after the addition of a second object.\n      */\n     public void testBlockedRemoveWithAdd() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n \n         // run methods will remove and compare -- must wait for add\n-        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n-        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        final Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        final Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n         thread1.start();\n         thread2.start();\n \n      * singleton.\n      */\n     public void testBlockedRemoveWithAddAll1() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n \n         // run methods will remove and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n-        Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        final Thread thread1 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n+        final Thread thread2 = new ReadThread<E>(blockingBuffer, obj, null, \"remove\");\n         thread1.start();\n         thread2.start();\n \n      * complete. Each thread should have read a different object.\n      */\n     public void testBlockedRemoveWithAddAll2() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj1 = makeElement();\n-        E obj2 = makeElement();\n-        Set<E> objs = Collections.synchronizedSet(new HashSet<E>());\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj1 = makeElement();\n+        final E obj2 = makeElement();\n+        final Set<E> objs = Collections.synchronizedSet(new HashSet<E>());\n         objs.add(obj1);\n         objs.add(obj2);\n \n         // run methods will remove and compare -- must wait for addAll\n-        Thread thread1 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n-        Thread thread2 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n+        final Thread thread1 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n+        final Thread thread2 = new ReadThread<E>(blockingBuffer, objs, \"remove\");\n         thread1.start();\n         thread2.start();\n \n      * Tests interrupted remove.\n      */\n     public void testInterruptedRemove() {\n-        Buffer<E> blockingBuffer = makeObject();\n-        E obj = makeElement();\n+        final Buffer<E> blockingBuffer = makeObject();\n+        final E obj = makeElement();\n \n         // spawn a read thread to wait on the empty buffer\n-        ArrayList<String> exceptionList = new ArrayList<String>();\n-        Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList, \"remove\");\n+        final ArrayList<String> exceptionList = new ArrayList<String>();\n+        final Thread thread = new ReadThread<E>(blockingBuffer, obj, exceptionList, \"remove\");\n         thread.start();\n \n         // Interrupting the thread should cause it to throw BufferUnderflowException\n         try {\n             buffer.get(100);\n             fail(\"Get should have timed out.\");\n-        } catch (BufferUnderflowException e) {\n+        } catch (final BufferUnderflowException e) {\n         }\n     }\n \n         try {\n             buffer.remove(100);\n             fail(\"Get should have timed out.\");\n-        } catch (BufferUnderflowException e) {\n+        } catch (final BufferUnderflowException e) {\n         }\n     }\n \n \n         long delay = 1000;\n \n-        public DelayedAdd(Buffer<E> buffer, E obj, long delay) {\n+        public DelayedAdd(final Buffer<E> buffer, final E obj, final long delay) {\n             this.buffer = buffer;\n             this.obj = obj;\n             this.delay = delay;\n         }\n \n-        DelayedAdd(Buffer<E> buffer, E obj) {\n+        DelayedAdd(final Buffer<E> buffer, final E obj) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             try {\n                 // wait for other thread to block on get() or remove()\n                 Thread.sleep(delay);\n-            } catch (InterruptedException e) {\n+            } catch (final InterruptedException e) {\n             }\n             buffer.add(obj);\n         }\n \n         long delay = 100;\n \n-        public DelayedAddAll(Buffer<E> buffer, E obj, long delay) {\n+        public DelayedAddAll(final Buffer<E> buffer, final E obj, final long delay) {\n             this.buffer = buffer;\n             this.obj = obj;\n             this.delay = delay;\n         }\n \n-        DelayedAddAll(Buffer<E> buffer, E obj) {\n+        DelayedAddAll(final Buffer<E> buffer, final E obj) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             try {\n                 // wait for other thread to block on get() or remove()\n                 Thread.sleep(delay);\n-            } catch (InterruptedException e) {\n+            } catch (final InterruptedException e) {\n             }\n             buffer.addAll(Collections.singleton(obj));\n         }\n \n         Set<E> objs;\n \n-        ReadThread(Buffer<E> buffer, Object obj) {\n+        ReadThread(final Buffer<E> buffer, final Object obj) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n         }\n \n-        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList) {\n+        ReadThread(final Buffer<E> buffer, final Object obj, final ArrayList<String> exceptionList) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             this.exceptionList = exceptionList;\n         }\n \n-        ReadThread(Buffer<E> buffer, Object obj, ArrayList<String> exceptionList, String action) {\n+        ReadThread(final Buffer<E> buffer, final Object obj, final ArrayList<String> exceptionList, final String action) {\n             super();\n             this.buffer = buffer;\n             this.obj = obj;\n             this.action = action;\n         }\n \n-        ReadThread(Buffer<E> buffer, Set<E> objs, String action) {\n+        ReadThread(final Buffer<E> buffer, final Set<E> objs, final String action) {\n             super();\n             this.buffer = buffer;\n             this.objs = objs;\n                         assertTrue(objs.remove(buffer.remove()));\n                     }\n                 }\n-            } catch (BufferUnderflowException ex) {\n+            } catch (final BufferUnderflowException ex) {\n                 exceptionList.add(\"BufferUnderFlow\");\n             }\n         }\n     private void delay() {\n         try {\n             Thread.sleep( 200 );\n-        } catch (InterruptedException e) {\n+        } catch (final InterruptedException e) {\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/collections/buffer/BoundedBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/BoundedBufferTest.java\n \n public class BoundedBufferTest<E> extends AbstractObjectTest {\n \n-    public BoundedBufferTest(String testName) {\n+    public BoundedBufferTest(final String testName) {\n         super(testName);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testMaxSize() {\n         final Buffer<E> bounded = BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 2, 500);\n-        BoundedCollection<?> bc = (BoundedCollection<?>) bounded;\n+        final BoundedCollection<?> bc = (BoundedCollection<?>) bounded;\n         assertEquals(2, bc.maxSize());\n         assertEquals(false, bc.isFull());\n         bounded.add((E) \"A\");\n         try {\n             BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), 0);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             BoundedBuffer.boundedBuffer(new UnboundedFifoBuffer<E>(), -1);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         try {\n             bounded.add((E) \"World\");\n             fail();\n-        } catch (BufferOverflowException e) {\n+        } catch (final BufferOverflowException e) {\n         }\n     }\n \n         try {\n             bounded.addAll(Collections.singleton((E) \"World\"));\n             fail();\n-        } catch (BufferOverflowException e) {\n+        } catch (final BufferOverflowException e) {\n         }\n     }\n \n         try {\n             bounded.addAll(Collections.nCopies(2, (E) \"test\"));\n             fail();\n-        } catch (BufferOverflowException e) {\n+        } catch (final BufferOverflowException e) {\n         }\n     }\n \n         try {\n             bounded.add((E) \"!\");\n             fail();\n-        } catch (BufferOverflowException e) {\n+        } catch (final BufferOverflowException e) {\n         }\n     }\n \n         try {\n             bounded.add((E) \"!\");\n             fail();\n-        } catch (BufferOverflowException e) {\n+        } catch (final BufferOverflowException e) {\n         }\n     }\n \n \n         private final int nToRemove;\n \n-        public DelayedIteratorRemove(Buffer<?> buffer, long delay, int nToRemove) {\n+        public DelayedIteratorRemove(final Buffer<?> buffer, final long delay, final int nToRemove) {\n             this.buffer = buffer;\n             this.delay = delay;\n             this.nToRemove = nToRemove;\n         }\n \n-        public DelayedIteratorRemove(Buffer<?> buffer, long delay) {\n+        public DelayedIteratorRemove(final Buffer<?> buffer, final long delay) {\n             this(buffer, delay, 1);\n         }\n \n         public void run() {\n             try {\n                 Thread.sleep(delay);\n-                Iterator<?> iter = buffer.iterator();\n+                final Iterator<?> iter = buffer.iterator();\n                 for (int i = 0; i < nToRemove; ++i) {\n                     iter.next();\n                     iter.remove();\n                 }\n \n-            } catch (InterruptedException e) {\n+            } catch (final InterruptedException e) {\n             }\n         }\n     }\n \n         private final int nToRemove;\n \n-        public DelayedRemove(Buffer<?> buffer, long delay, int nToRemove) {\n+        public DelayedRemove(final Buffer<?> buffer, final long delay, final int nToRemove) {\n             this.buffer = buffer;\n             this.delay = delay;\n             this.nToRemove = nToRemove;\n         }\n \n-        public DelayedRemove(Buffer<?> buffer, long delay) {\n+        public DelayedRemove(final Buffer<?> buffer, final long delay) {\n             this(buffer, delay, 1);\n         }\n \n                 for (int i = 0; i < nToRemove; ++i) {\n                     buffer.remove();\n                 }\n-            } catch (InterruptedException e) {\n+            } catch (final InterruptedException e) {\n             }\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/buffer/BoundedFifoBuffer2Test.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/BoundedFifoBuffer2Test.java\n  */\n public class BoundedFifoBuffer2Test<E> extends BoundedFifoBufferTest<E> {\n \n-    public BoundedFifoBuffer2Test(String n) {\n+    public BoundedFifoBuffer2Test(final String n) {\n         super(n);\n     }\n \n         try {\n             getCollection().add(getOtherElements()[0]);\n             fail(\"add should raise BufferOverflow.\");\n-        } catch (BufferOverflowException e) {\n+        } catch (final BufferOverflowException e) {\n             // expected\n         }\n         verify();\n         try {\n             getCollection().addAll(Arrays.asList(getOtherElements()));\n             fail(\"addAll should raise BufferOverflow.\");\n-        } catch (BufferOverflowException e) {\n+        } catch (final BufferOverflowException e) {\n             // expected\n         }\n         verify();\n--- a/src/test/java/org/apache/commons/collections/buffer/BoundedFifoBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/BoundedFifoBufferTest.java\n  */\n public class BoundedFifoBufferTest<E> extends AbstractCollectionTest<E> {\n \n-    public BoundedFifoBufferTest(String n) {\n+    public BoundedFifoBufferTest(final String n) {\n         super(n);\n     }\n \n     @Override\n     public void verify() {\n         super.verify();\n-        Iterator<E> iterator1 = getCollection().iterator();\n-        Iterator<E> iterator2 = getConfirmed().iterator();\n+        final Iterator<E> iterator1 = getCollection().iterator();\n+        final Iterator<E> iterator2 = getConfirmed().iterator();\n         while (iterator2.hasNext()) {\n             assertTrue(iterator1.hasNext());\n-            E o1 = iterator1.next();\n-            E o2 = iterator2.next();\n+            final E o1 = iterator1.next();\n+            final E o2 = iterator2.next();\n             assertEquals(o1, o2);\n         }\n     }\n      */\n     @Override\n     public List<E> makeConfirmedFullCollection() {\n-        List<E> c = makeConfirmedCollection();\n+        final List<E> c = makeConfirmedCollection();\n         c.addAll(java.util.Arrays.asList(getFullElements()));\n         return c;\n     }\n      */\n     public void testBoundedFifoBufferRemove() {\n         resetFull();\n-        int size = getConfirmed().size();\n+        final int size = getConfirmed().size();\n         for (int i = 0; i < size; i++) {\n-            E o1 = getCollection().remove();\n-            E o2 = getConfirmed().remove(0);\n+            final E o1 = getCollection().remove();\n+            final E o2 = getConfirmed().remove(0);\n             assertEquals(\"Removed objects should be equal\", o1, o2);\n             verify();\n         }\n         try {\n             getCollection().remove();\n             fail(\"Empty buffer should raise Underflow.\");\n-        } catch (BufferUnderflowException e) {\n+        } catch (final BufferUnderflowException e) {\n             // expected\n         }\n     }\n     public void testConstructorException1() {\n         try {\n             new BoundedFifoBuffer<E>(0);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testConstructorException2() {\n         try {\n             new BoundedFifoBuffer<E>(-20);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testConstructorException3() {\n         try {\n             new BoundedFifoBuffer<E>(null);\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             return;\n         }\n         fail();\n         try {\n             getCollection().get(-1);\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n             // expected\n         }\n         \n         try {\n             getCollection().get(getCollection().size());\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n             // expected\n         }\n     }\n     public void testGetIndex() {\n         resetFull();\n         \n-        BoundedFifoBuffer<E> buffer = getCollection();\n-        List<E> confirmed = getConfirmed();\n+        final BoundedFifoBuffer<E> buffer = getCollection();\n+        final List<E> confirmed = getConfirmed();\n         for (int i = 0; i < confirmed.size(); i++) {\n             assertEquals(confirmed.get(i), buffer.get(i));\n         }\n     // BZ 33071 -- gets start=end=1 before removal of interior element\n     @SuppressWarnings(\"unchecked\")\n     public void testShift() {\n-        BoundedFifoBuffer<E> fifo = new BoundedFifoBuffer<E>(3);\n+        final BoundedFifoBuffer<E> fifo = new BoundedFifoBuffer<E>(3);\n         fifo.add((E) \"a\");\n         fifo.add((E) \"b\");\n         fifo.add((E) \"c\");\n--- a/src/test/java/org/apache/commons/collections/buffer/CircularFifoBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/CircularFifoBufferTest.java\n  */\n public class CircularFifoBufferTest<E> extends AbstractCollectionTest<E> {\n \n-    public CircularFifoBufferTest(String n) {\n+    public CircularFifoBufferTest(final String n) {\n         super(n);\n     }\n \n     @Override\n     public void verify() {\n         super.verify();\n-        Iterator<E> iterator1 = getCollection().iterator();\n-        Iterator<E> iterator2 = getConfirmed().iterator();\n+        final Iterator<E> iterator1 = getCollection().iterator();\n+        final Iterator<E> iterator2 = getConfirmed().iterator();\n         while (iterator2.hasNext()) {\n             assertTrue(iterator1.hasNext());\n-            Object o1 = iterator1.next();\n-            Object o2 = iterator2.next();\n+            final Object o1 = iterator1.next();\n+            final Object o2 = iterator2.next();\n             assertEquals(o1, o2);\n         }\n     }\n      */\n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        Collection<E> c = makeConfirmedCollection();\n+        final Collection<E> c = makeConfirmedCollection();\n         c.addAll(java.util.Arrays.asList(getFullElements()));\n         return c;\n     }\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testCircularFifoBufferCircular() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.add((E) \"A\");\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n-        Buffer<E> buf = new CircularFifoBuffer<E>(list);\n+        final Buffer<E> buf = new CircularFifoBuffer<E>(list);\n \n         assertEquals(true, buf.contains(\"A\"));\n         assertEquals(true, buf.contains(\"B\"));\n      */\n     public void testCircularFifoBufferRemove() {\n         resetFull();\n-        int size = getConfirmed().size();\n+        final int size = getConfirmed().size();\n         for (int i = 0; i < size; i++) {\n-            Object o1 = getCollection().remove();\n-            Object o2 = getConfirmed().remove(0);\n+            final Object o1 = getCollection().remove();\n+            final Object o2 = getConfirmed().remove(0);\n             assertEquals(\"Removed objects should be equal\", o1, o2);\n             verify();\n         }\n         try {\n             getCollection().remove();\n             fail(\"Empty buffer should raise Underflow.\");\n-        } catch (BufferUnderflowException e) {\n+        } catch (final BufferUnderflowException e) {\n             // expected\n         }\n     }\n     public void testConstructorException1() {\n         try {\n             new CircularFifoBuffer<E>(0);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testConstructorException2() {\n         try {\n             new CircularFifoBuffer<E>(-20);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testConstructorException3() {\n         try {\n             new CircularFifoBuffer<E>(null);\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n             return;\n         }\n         fail();\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError1() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError2() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError3() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError4() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError5() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError6() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError7() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError8() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveError9() throws Exception {\n         // based on bug 33071\n-        CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n+        final CircularFifoBuffer<E> fifo = new CircularFifoBuffer<E>(5);\n         fifo.add((E) \"1\");\n         fifo.add((E) \"2\");\n         fifo.add((E) \"3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testRepeatedSerialization() throws Exception {\n         // bug 31433\n-        CircularFifoBuffer<E> b = new CircularFifoBuffer<E>(2);\n+        final CircularFifoBuffer<E> b = new CircularFifoBuffer<E>(2);\n         b.add((E) \"a\");\n         assertEquals(1, b.size());\n         assertEquals(true, b.contains(\"a\"));\n         ByteArrayOutputStream bos = new ByteArrayOutputStream();\n         new ObjectOutputStream(bos).writeObject(b);\n \n-        CircularFifoBuffer<E> b2 = (CircularFifoBuffer<E>) new ObjectInputStream(\n+        final CircularFifoBuffer<E> b2 = (CircularFifoBuffer<E>) new ObjectInputStream(\n             new ByteArrayInputStream(bos.toByteArray())).readObject();\n \n         assertEquals(1, b2.size());\n         bos = new ByteArrayOutputStream();\n         new ObjectOutputStream(bos).writeObject(b2);\n \n-        CircularFifoBuffer<E> b3 = (CircularFifoBuffer<E>) new ObjectInputStream(\n+        final CircularFifoBuffer<E> b3 = (CircularFifoBuffer<E>) new ObjectInputStream(\n             new ByteArrayInputStream(bos.toByteArray())).readObject();\n \n         assertEquals(2, b3.size());\n     public void testGetIndex() {\n         resetFull();\n         \n-        CircularFifoBuffer<E> buffer = getCollection();\n-        List<E> confirmed = getConfirmed();\n+        final CircularFifoBuffer<E> buffer = getCollection();\n+        final List<E> confirmed = getConfirmed();\n         for (int i = 0; i < confirmed.size(); i++) {\n             assertEquals(confirmed.get(i), buffer.get(i));\n         }\n--- a/src/test/java/org/apache/commons/collections/buffer/PredicatedBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/PredicatedBufferTest.java\n  */\n public class PredicatedBufferTest<E> extends PredicatedCollectionTest<E> {\n \n-    public PredicatedBufferTest(String testName) {\n+    public PredicatedBufferTest(final String testName) {\n         super(testName);\n     }\n \n     //---------------------------------------------------------------\n \n-    protected Buffer<E> decorateCollection(Buffer<E> buffer, Predicate<E> predicate) {\n+    protected Buffer<E> decorateCollection(final Buffer<E> buffer, final Predicate<E> predicate) {\n         return PredicatedBuffer.predicatedBuffer(buffer, predicate);\n     }\n \n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayStack<E> list = new ArrayStack<E>();\n+        final ArrayStack<E> list = new ArrayStack<E>();\n         list.addAll(java.util.Arrays.asList(getFullElements()));\n         return list;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testGet() {\n-        Buffer<E> buffer = makeTestBuffer();\n+        final Buffer<E> buffer = makeTestBuffer();\n         try {\n             buffer.get();\n             fail(\"Expecting BufferUnderflowException\");\n-        } catch (BufferUnderflowException ex) {\n+        } catch (final BufferUnderflowException ex) {\n             // expected\n         }\n         buffer.add((E) \"one\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemove() {\n-        Buffer<E> buffer = makeTestBuffer();\n+        final Buffer<E> buffer = makeTestBuffer();\n         buffer.add((E) \"one\");\n         assertEquals(\"Buffer get\", \"one\", buffer.remove());\n         try {\n             buffer.remove();\n             fail(\"Expecting BufferUnderflowException\");\n-        } catch (BufferUnderflowException ex) {\n+        } catch (final BufferUnderflowException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/buffer/PriorityBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/PriorityBufferTest.java\n @SuppressWarnings(\"boxing\")\n public class PriorityBufferTest<E> extends AbstractCollectionTest<E> {\n \n-    public PriorityBufferTest(String testName) {\n+    public PriorityBufferTest(final String testName) {\n         super(testName);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void verify() {\n         super.verify();\n-        PriorityBuffer<E> heap = getCollection();\n+        final PriorityBuffer<E> heap = getCollection();\n \n         Comparator<? super E> c = heap.comparator;\n         if (c == null) {\n             c = ComparatorUtils.reversedComparator(c);\n         }\n \n-        E[] tree = heap.elements;\n+        final E[] tree = heap.elements;\n         for (int i = 1; i <= heap.size; i++) {\n-            E parent = tree[i];\n+            final E parent = tree[i];\n             if (i * 2 <= heap.size) {\n                 assertTrue(\"Parent is less than or equal to its left child\", c.compare(parent, tree[i * 2]) <= 0);\n             }\n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     //-----------------------------------------------------------------------\n     public void testBufferEmpty() {\n         resetEmpty();\n-        Buffer<E> buffer = getCollection();\n+        final Buffer<E> buffer = getCollection();\n \n         assertEquals(0, buffer.size());\n         assertEquals(true, buffer.isEmpty());\n         try {\n             buffer.get();\n             fail();\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n \n         try {\n             buffer.remove();\n             fail();\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testBasicOps() {\n-        PriorityBuffer<E> heap = new PriorityBuffer<E>();\n+        final PriorityBuffer<E> heap = new PriorityBuffer<E>();\n         heap.add((E) \"a\");\n         heap.add((E) \"c\");\n         heap.add((E) \"e\");\n         try {\n             heap.get();\n             fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n \n         try {\n             heap.remove();\n             fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testBasicComparatorOps() {\n-        PriorityBuffer<E> heap = new PriorityBuffer<E>(new ReverseComparator<E>((Comparator<E>) ComparableComparator.INSTANCE));\n+        final PriorityBuffer<E> heap = new PriorityBuffer<E>(new ReverseComparator<E>((Comparator<E>) ComparableComparator.INSTANCE));\n \n         assertTrue(\"heap should be empty after create\", heap.isEmpty());\n \n         try {\n             heap.get();\n             fail(\"NoSuchElementException should be thrown if get is called before any elements are added\");\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n \n         try {\n             heap.remove();\n             fail(\"NoSuchElementException should be thrown if remove is called before any elements are added\");\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n \n         heap.add((E) \"a\");\n         heap.add((E) \"c\");\n         try {\n             heap.get();\n             fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n \n         try {\n             heap.remove();\n             fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n-        } catch (BufferUnderflowException ex) {}\n+        } catch (final BufferUnderflowException ex) {}\n     }\n \n     /**\n     @SuppressWarnings(\"unchecked\")\n     public void testAddRemove() {\n         resetEmpty();\n-        PriorityBuffer heap = getCollection();\n+        final PriorityBuffer heap = getCollection();\n         heap.add(0);\n         heap.add(2);\n         heap.add(4);\n      *\n      */\n     public void testRandom() {\n-        int iterations = 500;\n-        int heapSize = 100;\n-        int operations = 20;\n-        Random randGenerator = new Random();\n+        final int iterations = 500;\n+        final int heapSize = 100;\n+        final int operations = 20;\n+        final Random randGenerator = new Random();\n         PriorityBuffer<Integer> h = null;\n         for (int i = 0; i < iterations; i++) {\n             if (i < iterations / 2) {\n      * Pops all elements from the heap and verifies that the elements come off\n      * in the correct order.  NOTE: this method empties the heap.\n      */\n-    protected void checkOrder(PriorityBuffer<?> h) {\n+    protected void checkOrder(final PriorityBuffer<?> h) {\n         Integer lastNum = null;\n         Integer num = null;\n         while (!h.isEmpty()) {\n      * Returns a string showing the contents of the heap formatted as a tree.\n      * Makes no attempt at padding levels or handling wrapping.\n      */\n-    protected String showTree(PriorityBuffer<?> h) {\n+    protected String showTree(final PriorityBuffer<?> h) {\n         int count = 1;\n-        StringBuilder buffer = new StringBuilder();\n+        final StringBuilder buffer = new StringBuilder();\n         for (int offset = 1; count < h.size() + 1; offset *= 2) {\n             for (int i = offset; i < offset * 2; i++) {\n                 if (i < h.elements.length && h.elements[i] != null) {\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testSerialization() {\n-        int iterations = 500;\n-        int heapSize = 100;\n+        final int iterations = 500;\n+        final int heapSize = 100;\n         PriorityBuffer h;\n-        Random randGenerator = new Random();\n+        final Random randGenerator = new Random();\n         for (int i = 0; i < iterations; i++) {\n             if (i < iterations / 2) {\n                 h = new PriorityBuffer<E>(true);\n                 h.add(new Integer(randGenerator.nextInt(heapSize)));\n             }\n             assertTrue(h.size() == heapSize);\n-            PriorityBuffer<?> h1 = serializeAndRestore(h);\n+            final PriorityBuffer<?> h1 = serializeAndRestore(h);\n             assertTrue(h1.size() == heapSize);\n-            Iterator<?> hit = h.iterator();\n+            final Iterator<?> hit = h.iterator();\n             while (hit.hasNext()) {\n-                Integer n = (Integer) hit.next();\n+                final Integer n = (Integer) hit.next();\n                 assertTrue(h1.contains(n));\n             }\n             checkOrder(h1);\n         }\n     }\n \n-    public PriorityBuffer<?> serializeAndRestore(PriorityBuffer<E> h) {\n+    public PriorityBuffer<?> serializeAndRestore(final PriorityBuffer<E> h) {\n         PriorityBuffer<?> h1 = null;\n         try {\n-            byte[] objekt = writeExternalFormToBytes(h);\n+            final byte[] objekt = writeExternalFormToBytes(h);\n             h1 = (PriorityBuffer<?>) readExternalFormFromBytes(objekt);\n-        } catch (IOException e) {\n+        } catch (final IOException e) {\n             e.printStackTrace();\n             fail(e.toString());\n-        } catch (ClassNotFoundException e) {\n+        } catch (final ClassNotFoundException e) {\n             e.printStackTrace();\n             fail(e.toString());\n         }\n--- a/src/test/java/org/apache/commons/collections/buffer/SynchronizedBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/SynchronizedBufferTest.java\n  */\n public class SynchronizedBufferTest<E> extends AbstractCollectionTest<E> {\n \n-    public SynchronizedBufferTest(String testName) {\n+    public SynchronizedBufferTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public Collection<E> makeFullCollection() {\n-        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n+        final Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n         buffer.addAll(Arrays.asList(getFullElements()));\n         return SynchronizedBuffer.synchronizedBuffer(buffer);\n     }\n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayStack<E> list = new ArrayStack<E>();\n+        final ArrayStack<E> list = new ArrayStack<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n--- a/src/test/java/org/apache/commons/collections/buffer/TransformedBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/TransformedBufferTest.java\n  */\n public class TransformedBufferTest extends TestCase {\n     \n-    public TransformedBufferTest(String testName) {\n+    public TransformedBufferTest(final String testName) {\n         super(testName);\n     }\n \n     public void testTransformedBuffer() {\n-        Buffer<Object> buffer = TransformedBuffer.transformingBuffer(new ArrayStack<Object>(), TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final Buffer<Object> buffer = TransformedBuffer.transformingBuffer(new ArrayStack<Object>(), TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, buffer.size());\n-        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             buffer.add(els[i]);\n             assertEquals(i + 1, buffer.size());\n     }\n \n     public void testTransformedBuffer_decorateTransform() {\n-        Buffer originalBuffer = new ArrayStack();\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n-        for (Object el : els) {\n+        final Buffer originalBuffer = new ArrayStack();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n             originalBuffer.add(el);\n         }\n-        Buffer buffer = TransformedBuffer.transformedBuffer(originalBuffer, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final Buffer buffer = TransformedBuffer.transformedBuffer(originalBuffer, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, buffer.size());\n-        for (Object el : els) {\n+        for (final Object el : els) {\n             assertEquals(true, buffer.contains(new Integer((String) el)));\n             assertEquals(false, buffer.contains(el));\n         }\n--- a/src/test/java/org/apache/commons/collections/buffer/UnboundedFifoBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/UnboundedFifoBufferTest.java\n  */\n public class UnboundedFifoBufferTest<E> extends AbstractCollectionTest<E> {\n \n-    public UnboundedFifoBufferTest(String n) {\n+    public UnboundedFifoBufferTest(final String n) {\n         super(n);\n     }\n \n     @Override\n     public void verify() {\n         super.verify();\n-        Iterator<E> iterator1 = getCollection().iterator();\n-        Iterator<E> iterator2 = getConfirmed().iterator();\n+        final Iterator<E> iterator1 = getCollection().iterator();\n+        final Iterator<E> iterator2 = getConfirmed().iterator();\n         while (iterator2.hasNext()) {\n             assertTrue(iterator1.hasNext());\n-            Object o1 = iterator1.next();\n-            Object o2 = iterator2.next();\n+            final Object o1 = iterator1.next();\n+            final Object o2 = iterator2.next();\n             assertEquals(o1, o2);\n         }\n     }\n      */\n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        Collection<E> c = makeConfirmedCollection();\n+        final Collection<E> c = makeConfirmedCollection();\n         c.addAll(java.util.Arrays.asList(getFullElements()));\n         return c;\n     }\n      */\n     public void testUnboundedFifoBufferRemove() {\n         resetFull();\n-        int size = getConfirmed().size();\n+        final int size = getConfirmed().size();\n         for (int i = 0; i < size; i++) {\n-            E o1 = getCollection().remove();\n-            E o2 = getConfirmed().remove(0);\n+            final E o1 = getCollection().remove();\n+            final E o2 = getConfirmed().remove(0);\n             assertEquals(\"Removed objects should be equal\", o1, o2);\n             verify();\n         }\n     public void testConstructorException1() {\n         try {\n             new UnboundedFifoBuffer<E>(0);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     public void testConstructorException2() {\n         try {\n             new UnboundedFifoBuffer<E>(-20);\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             return;\n         }\n         fail();\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateAdd() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(2);\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(2);\n         assertEquals(3, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(0, test.tail);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateAddWithWrap() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n         assertEquals(4, test.buffer.length);\n         assertEquals(0, test.head);\n         assertEquals(0, test.tail);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateRemove1() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n         test.add((E) \"A\");\n         test.add((E) \"B\");\n         test.add((E) \"C\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateRemove2() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n         test.add((E) \"A\");\n         test.add((E) \"B\");\n         test.add((E) \"C\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemove1() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n-        test.add((E) \"A\");\n-        test.add((E) \"B\");\n-        test.add((E) \"C\");\n-        assertEquals(5, test.buffer.length);\n-        assertEquals(0, test.head);\n-        assertEquals(3, test.tail);\n-        \n-        Iterator<E> it = test.iterator();\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        assertEquals(5, test.buffer.length);\n+        assertEquals(0, test.head);\n+        assertEquals(3, test.tail);\n+        \n+        final Iterator<E> it = test.iterator();\n         it.next();\n         it.remove();\n         assertEquals(5, test.buffer.length);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemove2() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n-        test.add((E) \"A\");\n-        test.add((E) \"B\");\n-        test.add((E) \"C\");\n-        \n-        Iterator<E> it = test.iterator();\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(4);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        \n+        final Iterator<E> it = test.iterator();\n         it.next();\n         it.next();\n         it.remove();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithTailAtEnd1() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n-        test.add((E) \"A\");\n-        test.add((E) \"B\");\n-        test.add((E) \"C\");\n-        test.remove(\"A\");\n-        test.add((E) \"D\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(1, test.head);\n-        assertEquals(0, test.tail);\n-        \n-        Iterator<E> it = test.iterator();\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        final Iterator<E> it = test.iterator();\n         assertEquals(\"B\", it.next());\n         it.remove();\n         assertEquals(4, test.buffer.length);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithTailAtEnd2() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n-        test.add((E) \"A\");\n-        test.add((E) \"B\");\n-        test.add((E) \"C\");\n-        test.remove(\"A\");\n-        test.add((E) \"D\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(1, test.head);\n-        assertEquals(0, test.tail);\n-        \n-        Iterator<E> it = test.iterator();\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        final Iterator<E> it = test.iterator();\n         assertEquals(\"B\", it.next());\n         assertEquals(\"C\", it.next());\n         it.remove();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithTailAtEnd3() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n-        test.add((E) \"A\");\n-        test.add((E) \"B\");\n-        test.add((E) \"C\");\n-        test.remove(\"A\");\n-        test.add((E) \"D\");\n-        assertEquals(4, test.buffer.length);\n-        assertEquals(1, test.head);\n-        assertEquals(0, test.tail);\n-        \n-        Iterator<E> it = test.iterator();\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        test.add((E) \"A\");\n+        test.add((E) \"B\");\n+        test.add((E) \"C\");\n+        test.remove(\"A\");\n+        test.add((E) \"D\");\n+        assertEquals(4, test.buffer.length);\n+        assertEquals(1, test.head);\n+        assertEquals(0, test.tail);\n+        \n+        final Iterator<E> it = test.iterator();\n         assertEquals(\"B\", it.next());\n         assertEquals(\"C\", it.next());\n         assertEquals(\"D\", it.next());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithWrap1() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n         test.add((E) \"A\");\n         test.add((E) \"B\");\n         test.add((E) \"C\");\n         assertEquals(2, test.head);\n         assertEquals(1, test.tail);\n         \n-        Iterator<E> it = test.iterator();\n+        final Iterator<E> it = test.iterator();\n         assertEquals(\"C\", it.next());\n         it.remove();\n         assertEquals(4, test.buffer.length);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithWrap2() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n         test.add((E) \"A\");\n         test.add((E) \"B\");\n         test.add((E) \"C\");\n         assertEquals(2, test.head);\n         assertEquals(1, test.tail);\n         \n-        Iterator<E> it = test.iterator();\n+        final Iterator<E> it = test.iterator();\n         assertEquals(\"C\", it.next());\n         assertEquals(\"D\", it.next());\n         it.remove();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInternalStateIteratorRemoveWithWrap3() {\n-        UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n+        final UnboundedFifoBuffer<E> test = new UnboundedFifoBuffer<E>(3);\n         test.add((E) \"A\");\n         test.add((E) \"B\");\n         test.add((E) \"C\");\n         assertEquals(2, test.head);\n         assertEquals(1, test.tail);\n         \n-        Iterator<E> it = test.iterator();\n+        final Iterator<E> it = test.iterator();\n         assertEquals(\"C\", it.next());\n         assertEquals(\"D\", it.next());\n         assertEquals(\"E\", it.next());\n--- a/src/test/java/org/apache/commons/collections/buffer/UnmodifiableBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/UnmodifiableBufferTest.java\n  */\n public class UnmodifiableBufferTest<E> extends AbstractCollectionTest<E> {\n \n-    public UnmodifiableBufferTest(String testName) {\n+    public UnmodifiableBufferTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public Collection<E> makeFullCollection() {\n-        Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n+        final Buffer<E> buffer = new UnboundedFifoBuffer<E>();\n         buffer.addAll(Arrays.asList(getFullElements()));\n         return UnmodifiableBuffer.unmodifiableBuffer(buffer);\n     }\n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayStack<E> list = new ArrayStack<E>();\n+        final ArrayStack<E> list = new ArrayStack<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n         try {\n             getCollection().remove();\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n     }\n \n     @Override\n--- a/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n      *\n      * @param testName  the test class name\n      */\n-    public AbstractCollectionTest(String testName) {\n+    public AbstractCollectionTest(final String testName) {\n         super(testName);\n     }\n \n      *  identical state.\n      */\n     public void verify() {\n-        int confirmedSize = getConfirmed().size();\n+        final int confirmedSize = getConfirmed().size();\n         assertEquals(\"Collection size should match confirmed collection's\", confirmedSize,\n                 getCollection().size());\n         assertEquals(\"Collection isEmpty() result should match confirmed collection's\",\n         // verification is a success.\n \n         // copy each collection value into an array\n-        Object[] confirmedValues = new Object[confirmedSize];\n+        final Object[] confirmedValues = new Object[confirmedSize];\n \n         Iterator<E> iter;\n \n \n         // allocate an array of boolean flags for tracking values that have\n         // been matched once and only once.\n-        boolean[] matched = new boolean[confirmedSize];\n+        final boolean[] matched = new boolean[confirmedSize];\n \n         // now iterate through the values of the collection and try to match\n         // the value with one in the confirmed array.\n         iter = getCollection().iterator();\n         while (iter.hasNext()) {\n-            Object o = iter.next();\n+            final Object o = iter.next();\n             boolean match = false;\n             for (int i = 0; i < confirmedSize; i++) {\n                 if (matched[i]) {\n      *  if your collection doesn't support addAll.\n      */\n     public Collection<E> makeFullCollection() {\n-        Collection<E> c = makeObject();\n+        final Collection<E> c = makeObject();\n         c.addAll(Arrays.asList(getFullElements()));\n         return c;\n     }\n     /**\n      * Creates a new Map Entry that is independent of the first and the map.\n      */\n-    public Map.Entry<E, E> cloneMapEntry(Map.Entry<E, E> entry) {\n-        HashMap<E, E> map = new HashMap<E, E>();\n+    public Map.Entry<E, E> cloneMapEntry(final Map.Entry<E, E> entry) {\n+        final HashMap<E, E> map = new HashMap<E, E>();\n         map.put(entry.getKey(), entry.getValue());\n         return map.entrySet().iterator().next();\n     }\n     @SuppressWarnings(\"unchecked\")\n     public E[] getFullElements() {\n         if (isNullSupported()) {\n-            ArrayList<E> list = new ArrayList<E>();\n+            final ArrayList<E> list = new ArrayList<E>();\n             list.addAll(Arrays.asList(getFullNonNullElements()));\n             list.add(4, null);\n             return (E[]) list.toArray();\n             return;\n         }\n \n-        E[] elements = getFullElements();\n-        for (E element : elements) {\n+        final E[] elements = getFullElements();\n+        for (final E element : elements) {\n             resetEmpty();\n-            boolean r = getCollection().add(element);\n+            final boolean r = getCollection().add(element);\n             getConfirmed().add(element);\n             verify();\n             assertTrue(\"Empty collection changed after add\", r);\n \n         resetEmpty();\n         int size = 0;\n-        for (E element : elements) {\n-            boolean r = getCollection().add(element);\n+        for (final E element : elements) {\n+            final boolean r = getCollection().add(element);\n             getConfirmed().add(element);\n             verify();\n             if (r) {\n         getConfirmed().addAll(Arrays.asList(elements));\n         verify();\n         assertTrue(\"Empty collection should change after addAll\", r);\n-        for (E element : elements) {\n+        for (final E element : elements) {\n             assertTrue(\"Collection should contain added element\", getCollection().contains(element));\n         }\n \n         getConfirmed().addAll(Arrays.asList(elements));\n         verify();\n         assertTrue(\"Full collection should change after addAll\", r);\n-        for (E element : elements) {\n+        for (final E element : elements) {\n             assertTrue(\"Full collection should contain added element\",\n                     getCollection().contains(element));\n         }\n         try {\n             getCollection().add(getFullNonNullElements()[0]);\n             fail(\"Empty collection should not support add.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         // make sure things didn't change even if the expected exception was\n         try {\n             getCollection().addAll(Arrays.asList(getFullElements()));\n             fail(\"Empty collection should not support addAll.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         // make sure things didn't change even if the expected exception was\n         try {\n             getCollection().add(getFullNonNullElements()[0]);\n             fail(\"Full collection should not support add.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         // make sure things didn't change even if the expected exception was\n         try {\n             getCollection().addAll(Arrays.asList(getOtherElements()));\n             fail(\"Full collection should not support addAll.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         // make sure things didn't change even if the expected exception was\n         // make sure calls to \"containsAll\" don't change anything\n         verify();\n \n-        int min = getFullElements().length < 2 ? 0 : 2;\n-        int max = getFullElements().length == 1 ? 1 :\n+        final int min = getFullElements().length < 2 ? 0 : 2;\n+        final int max = getFullElements().length == 1 ? 1 :\n                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n         col = Arrays.asList(getFullElements()).subList(min, max);\n         assertTrue(\"Full collection should containAll partial full elements\",\n             it1.next();\n             fail(\"Iterator at end of Collection should throw \"\n                     + \"NoSuchElementException when next is called.\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             // expected\n         }\n         // make sure nothing has changed after non-modification\n         }\n         assertTrue(\"Iterator should be finished\", !it1.hasNext());\n \n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         it1 = getCollection().iterator();\n         for (int i = 0; i < getCollection().size(); i++) {\n-            E next = it1.next();\n+            final E next = it1.next();\n             assertTrue(\"Collection should contain element returned by its iterator\",\n                     getCollection().contains(next));\n             list.add(next);\n         try {\n             it1.next();\n             fail(\"iterator.next() should raise NoSuchElementException after it finishes\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             // expected\n         }\n         // make sure nothing has changed after non-modification\n         try {\n             getCollection().iterator().remove();\n             fail(\"New iterator.remove should raise IllegalState\");\n-        } catch (IllegalStateException e) {\n-            // expected\n-        }\n-        verify();\n-\n-        try {\n-            Iterator<E> iter = getCollection().iterator();\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n             iter.hasNext();\n             iter.remove();\n             fail(\"New iterator.remove should raise IllegalState even after hasNext\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // expected\n         }\n         verify();\n         try {\n             iter.remove();\n             fail(\"Second iter.remove should raise IllegalState\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // expected\n         }\n     }\n         }\n \n         resetEmpty();\n-        E[] elements = getFullElements();\n+        final E[] elements = getFullElements();\n         for (int i = 0; i < elements.length; i++) {\n             assertTrue(\"Shouldn't remove nonexistent element\", !getCollection().remove(elements[i]));\n             verify();\n         }\n \n-        E[] other = getOtherElements();\n+        final E[] other = getOtherElements();\n \n         resetFull();\n         for (int i = 0; i < other.length; i++) {\n             verify();\n         }\n \n-        int size = getCollection().size();\n-        for (E element : elements) {\n+        final int size = getCollection().size();\n+        for (final E element : elements) {\n             resetFull();\n             assertTrue(\"Collection should remove extant element: \" + element,\n                     getCollection().remove(element));\n         verify();\n \n         resetFull();\n-        int size = getCollection().size();\n-        int min = getFullElements().length < 2 ? 0 : 2;\n-        int max = getFullElements().length == 1 ? 1 :\n+        final int size = getCollection().size();\n+        final int min = getFullElements().length < 2 ? 0 : 2;\n+        final int max = getFullElements().length == 1 ? 1 :\n                 getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n-        Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n+        final Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n         assertTrue(\"Full collection removeAll should work\", getCollection().removeAll(all));\n         getConfirmed().removeAll(all);\n         verify();\n \n         assertTrue(\"Collection should shrink after removeAll\", getCollection().size() < size);\n-        Iterator<E> iter = all.iterator();\n+        final Iterator<E> iter = all.iterator();\n         while (iter.hasNext()) {\n             assertTrue(\"Collection shouldn't contain removed element\",\n                     !getCollection().contains(iter.next()));\n         }\n \n         resetEmpty();\n-        List<E> elements = Arrays.asList(getFullElements());\n-        List<E> other = Arrays.asList(getOtherElements());\n+        final List<E> elements = Arrays.asList(getFullElements());\n+        final List<E> other = Arrays.asList(getOtherElements());\n \n         assertTrue(\"Empty retainAll() should return false\",\n                 !getCollection().retainAll(Collections.EMPTY_SET));\n         if (getFullElements().length > 1) {\n             resetFull();\n             size = getCollection().size();\n-            int min = getFullElements().length < 2 ? 0 : 2;\n-            int max = getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n+            final int min = getFullElements().length < 2 ? 0 : 2;\n+            final int max = getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n             assertTrue(\"Collection should changed by partial retainAll\",\n                     getCollection().retainAll(elements.subList(min, max)));\n             getConfirmed().retainAll(elements.subList(min, max));\n             verify();\n \n-            Iterator<E> iter = getCollection().iterator();\n+            final Iterator<E> iter = getCollection().iterator();\n             while (iter.hasNext()) {\n                 assertTrue(\"Collection only contains retained element\",\n                         elements.subList(min, max).contains(iter.next()));\n         }\n \n         resetFull();\n-        HashSet<E> set = new HashSet<E>(elements);\n+        final HashSet<E> set = new HashSet<E>(elements);\n         size = getCollection().size();\n         assertTrue(\"Collection shouldn't change from retainAll without \" +\n                    \"duplicate elements\", !getCollection().retainAll(set));\n                      0, getCollection().toArray().length);\n \n         resetFull();\n-        Object[] array = getCollection().toArray();\n+        final Object[] array = getCollection().toArray();\n         assertEquals(\"Full collection toArray should be same size as collection\",\n                 array.length, getCollection().size());\n-        Object[] confirmedArray = getConfirmed().toArray();\n+        final Object[] confirmedArray = getConfirmed().toArray();\n         assertEquals(\"length of array from confirmed collection should \"\n                 + \"match the length of the collection's array\", confirmedArray.length, array.length);\n-        boolean[] matched = new boolean[array.length];\n+        final boolean[] matched = new boolean[array.length];\n \n         for (int i = 0; i < array.length; i++) {\n             assertTrue(\"Collection should contain element in toArray\",\n                         + \"in the confirmed collection's array\");\n             }\n         }\n-        for (boolean element : matched) {\n+        for (final boolean element : matched) {\n             assertEquals(\"Collection should return all its elements in \" + \"toArray\", true,\n                     element);\n         }\n         try {\n             array = getCollection().toArray(new Void[0]);\n             fail(\"toArray(new Void[0]) should raise ArrayStore\");\n-        } catch (ArrayStoreException e) {\n+        } catch (final ArrayStoreException e) {\n             // expected\n         }\n         verify();\n         try {\n             array = getCollection().toArray(null);\n             fail(\"toArray(null) should raise NPE\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n         verify();\n \n         // Figure out if they're all the same class\n         // TODO: It'd be nicer to detect a common superclass\n-        HashSet<Class<?>> classes = new HashSet<Class<?>>();\n-        for (Object element : array) {\n+        final HashSet<Class<?>> classes = new HashSet<Class<?>>();\n+        for (final Object element : array) {\n             classes.add(element == null ? null : element.getClass());\n         }\n         if (classes.size() > 1) {\n         try {\n             getCollection().clear();\n             fail(\"clear should raise UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         verify();\n         try {\n             getCollection().remove(null);\n             fail(\"remove should raise UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         verify();\n         try {\n             getCollection().removeAll(null);\n             fail(\"removeAll should raise UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         verify();\n         try {\n             getCollection().retainAll(null);\n             fail(\"retainAll should raise UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n-            // expected\n-        }\n-        verify();\n-\n-        resetFull();\n-        try {\n-            Iterator<E> iterator = getCollection().iterator();\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iterator = getCollection().iterator();\n             iterator.next();\n             iterator.remove();\n             fail(\"iterator.remove should raise UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         verify();\n         if (isAddSupported()) {\n             resetFull();\n             try {\n-                Iterator<E> iter = getCollection().iterator();\n-                E o = getOtherElements()[0];\n+                final Iterator<E> iter = getCollection().iterator();\n+                final E o = getOtherElements()[0];\n                 getCollection().add(o);\n                 getConfirmed().add(o);\n                 iter.next();\n                 fail(\"next after add should raise ConcurrentModification\");\n-            } catch (ConcurrentModificationException e) {\n+            } catch (final ConcurrentModificationException e) {\n                 // expected\n             }\n             verify();\n \n             resetFull();\n             try {\n-                Iterator<E> iter = getCollection().iterator();\n+                final Iterator<E> iter = getCollection().iterator();\n                 getCollection().addAll(Arrays.asList(getOtherElements()));\n                 getConfirmed().addAll(Arrays.asList(getOtherElements()));\n                 iter.next();\n                 fail(\"next after addAll should raise ConcurrentModification\");\n-            } catch (ConcurrentModificationException e) {\n+            } catch (final ConcurrentModificationException e) {\n                 // expected\n             }\n             verify();\n \n         resetFull();\n         try {\n-            Iterator<E> iter = getCollection().iterator();\n+            final Iterator<E> iter = getCollection().iterator();\n             getCollection().clear();\n             iter.next();\n             fail(\"next after clear should raise ConcurrentModification\");\n-        } catch (ConcurrentModificationException e) {\n-            // expected\n-        } catch (NoSuchElementException e) {\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        } catch (final NoSuchElementException e) {\n             // (also legal given spec)\n         }\n \n         resetFull();\n         try {\n-            Iterator<E> iter = getCollection().iterator();\n+            final Iterator<E> iter = getCollection().iterator();\n             getCollection().remove(getFullElements()[0]);\n             iter.next();\n             fail(\"next after remove should raise ConcurrentModification\");\n-        } catch (ConcurrentModificationException e) {\n-            // expected\n-        }\n-\n-        resetFull();\n-        try {\n-            Iterator<E> iter = getCollection().iterator();\n-            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n+            final List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n             getCollection().removeAll(sublist);\n             iter.next();\n             fail(\"next after removeAll should raise ConcurrentModification\");\n-        } catch (ConcurrentModificationException e) {\n-            // expected\n-        }\n-\n-        resetFull();\n-        try {\n-            Iterator<E> iter = getCollection().iterator();\n-            List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n+            final List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n             getCollection().retainAll(sublist);\n             iter.next();\n             fail(\"next after retainAll should raise ConcurrentModification\");\n-        } catch (ConcurrentModificationException e) {\n+        } catch (final ConcurrentModificationException e) {\n             // expected\n         }\n     }\n     public void testSerializeDeserializeThenCompare() throws Exception {\n         Object obj = makeObject();\n         if (obj instanceof Serializable && isTestSerialization()) {\n-            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n             out.writeObject(obj);\n             out.close();\n \n-            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n-            Object dest = in.readObject();\n+            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            final Object dest = in.readObject();\n             in.close();\n             if (isEqualsCheckable()) {\n                 assertEquals(\"obj != deserialize(serialize(obj)) - EMPTY Collection\", obj, dest);\n         }\n         obj = makeFullCollection();\n         if (obj instanceof Serializable && isTestSerialization()) {\n-            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n             out.writeObject(obj);\n             out.close();\n \n-            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n-            Object dest = in.readObject();\n+            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            final Object dest = in.readObject();\n             in.close();\n             if (isEqualsCheckable()) {\n                 assertEquals(\"obj != deserialize(serialize(obj)) - FULL Collection\", obj, dest);\n      * Set the collection.\n      * @param collection the Collection<E> to set\n      */\n-    public void setCollection(Collection<E> collection) {\n+    public void setCollection(final Collection<E> collection) {\n         this.collection = collection;\n     }\n \n      * Set the confirmed.\n      * @param confirmed the Collection<E> to set\n      */\n-    public void setConfirmed(Collection<E> confirmed) {\n+    public void setConfirmed(final Collection<E> confirmed) {\n         this.confirmed = confirmed;\n     }\n \n      * @param coll\n      * @param element\n      */\n-    protected static void assertNotCollectionContains(Collection<?> coll, Object element) {\n+    protected static void assertNotCollectionContains(final Collection<?> coll, final Object element) {\n         try {\n             assertFalse(coll.contains(element));\n-        } catch (ClassCastException e) {\n+        } catch (final ClassCastException e) {\n             //apparently not\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             //apparently not\n         }\n     }\n      * @param coll\n      * @param sub\n      */\n-    protected static void assertNotCollectionContainsAll(Collection<?> coll, Collection<?> sub) {\n+    protected static void assertNotCollectionContainsAll(final Collection<?> coll, final Collection<?> sub) {\n         try {\n             assertFalse(coll.containsAll(sub));\n-        } catch (ClassCastException cce) {\n+        } catch (final ClassCastException cce) {\n             //apparently not\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             //apparently not\n         }\n     }\n      * @param coll\n      * @param element\n      */\n-    protected static void assertNotRemoveFromCollection(Collection<?> coll, Object element) {\n+    protected static void assertNotRemoveFromCollection(final Collection<?> coll, final Object element) {\n         try {\n             assertFalse(coll.remove(element));\n-        } catch (ClassCastException cce) {\n+        } catch (final ClassCastException cce) {\n             //apparently not\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             //apparently not\n         }\n     }\n      * @param coll\n      * @param sub\n      */\n-    protected static void assertNotRemoveAllFromCollection(Collection<?> coll, Collection<?> sub) {\n+    protected static void assertNotRemoveAllFromCollection(final Collection<?> coll, final Collection<?> sub) {\n         try {\n             assertFalse(coll.removeAll(sub));\n-        } catch (ClassCastException cce) {\n+        } catch (final ClassCastException cce) {\n             //apparently not\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             //apparently not\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/collection/CompositeCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/CompositeCollectionTest.java\n  */\n public class CompositeCollectionTest<E> extends AbstractCollectionTest<E> {\n \n-    public CompositeCollectionTest(String name) {\n+    public CompositeCollectionTest(final String name) {\n         super(name);\n     }\n \n      */\n     @Override\n     public Collection<E> makeFullCollection() {\n-        CompositeCollection<E> compositeCollection = new CompositeCollection<E>();\n-        E[] elements = getFullElements();\n-        for (E element : elements) {\n-            Collection<E> summand = new HashSet<E>();\n+        final CompositeCollection<E> compositeCollection = new CompositeCollection<E>();\n+        final E[] elements = getFullElements();\n+        for (final E element : elements) {\n+            final Collection<E> summand = new HashSet<E>();\n             summand.add(element);\n             compositeCollection.addComposited(summand);\n         }\n      */\n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        Collection<E> collection = new HashSet<E>();\n+        final Collection<E> collection = new HashSet<E>();\n         collection.addAll(Arrays.asList(getFullElements()));\n         return collection;\n     }\n         try {\n             getCollection().remove(null);\n             fail(\"remove should raise UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         verify();\n     protected void setUpMutatorTest() {\n         setUpTest();\n         c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n-            public boolean add(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, E obj) {\n-                for (Collection<E> collection : collections) {\n+            public boolean add(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final E obj) {\n+                for (final Collection<E> collection : collections) {\n                     collection.add(obj);\n                 }\n                 return true;\n             }\n \n-            public boolean addAll(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Collection<? extends E> coll) {\n-                for (Collection<E> collection : collections) {\n+            public boolean addAll(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n+                for (final Collection<E> collection : collections) {\n                     collection.addAll(coll);\n                 }\n                 return true;\n             }\n \n-            public boolean remove(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Object obj) {\n-                for (Collection<E> collection : collections) {\n+            public boolean remove(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Object obj) {\n+                for (final Collection<E> collection : collections) {\n                     collection.remove(obj);\n                 }\n                 return true;\n     @SuppressWarnings(\"unchecked\")\n     public void testSize() {\n         setUpTest();\n-        HashSet<E> set = new HashSet<E>();\n+        final HashSet<E> set = new HashSet<E>();\n         set.add((E) \"a\");\n         set.add((E) \"b\");\n         c.addComposited(set);\n     @SuppressWarnings(\"unchecked\")\n     public void testMultipleCollectionsSize() {\n         setUpTest();\n-        HashSet<E> set = new HashSet<E>();\n+        final HashSet<E> set = new HashSet<E>();\n         set.add((E) \"a\");\n         set.add((E) \"b\");\n         c.addComposited(set);\n-        HashSet<E> other = new HashSet<E>();\n+        final HashSet<E> other = new HashSet<E>();\n         other.add((E) \"c\");\n         c.addComposited(other);\n         assertEquals(set.size() + other.size(), c.size());\n     public void testIsEmpty() {\n         setUpTest();\n         assertTrue(c.isEmpty());\n-        HashSet<E> empty = new HashSet<E>();\n+        final HashSet<E> empty = new HashSet<E>();\n         c.addComposited(empty);\n         assertTrue(c.isEmpty());\n         empty.add((E) \"a\");\n         two.add((E) \"2\");\n         c.addComposited(one);\n         c.addComposited(two);\n-        Iterator<E> i = c.iterator();\n+        final Iterator<E> i = c.iterator();\n         E next = i.next();\n         assertTrue(c.contains(next));\n         assertTrue(one.contains(next));\n     public void testAddAllMutator() {\n         setUpTest();\n         c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n-            public boolean add(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, E obj) {\n-                for (Collection<E> collection : collections) {\n+            public boolean add(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final E obj) {\n+                for (final Collection<E> collection : collections) {\n                     collection.add(obj);\n                 }\n                 return true;\n             }\n \n-            public boolean addAll(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Collection<? extends E> coll) {\n-                for (Collection<E> collection : collections) {\n+            public boolean addAll(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n+                for (final Collection<E> collection : collections) {\n                     collection.addAll(coll);\n                 }\n                 return true;\n             }\n \n-            public boolean remove(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Object obj) {\n+            public boolean remove(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Object obj) {\n                 return false;\n             }\n         });\n     public void testAddMutator() {\n         setUpTest();\n         c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n-            public boolean add(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, E obj) {\n-                for (Collection<E> collection : collections) {\n+            public boolean add(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final E obj) {\n+                for (final Collection<E> collection : collections) {\n                     collection.add(obj);\n                 }\n                 return true;\n             }\n \n-            public boolean addAll(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Collection<? extends E> coll) {\n-                for (Collection<E> collection : collections) {\n+            public boolean addAll(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n+                for (final Collection<E> collection : collections) {\n                     collection.addAll(coll);\n                 }\n                 return true;\n             }\n \n-            public boolean remove(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Object obj) {\n+            public boolean remove(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Object obj) {\n                 return false;\n             }\n         });\n         one.add((E) \"1\");\n         two.add((E) \"2\");\n         c.addComposited(one, two);\n-        Collection<E> foo = c.toCollection();\n+        final Collection<E> foo = c.toCollection();\n         assertTrue(foo.containsAll(c));\n         assertEquals(c.size(), foo.size());\n         one.add((E) \"3\");\n         one.add((E) \"1\");\n         two.add((E) \"2\");\n         c.addComposited(one, two);\n-        Collection<E> toCollection = new HashSet<E>();\n+        final Collection<E> toCollection = new HashSet<E>();\n         toCollection.addAll(c);\n         assertTrue(toCollection.containsAll(c));\n         assertEquals(c.size(), toCollection.size());\n         two.add((E) \"2\");\n         two.add((E) \"1\");\n         // need separate list to remove, as otherwise one clears itself\n-        Collection<E> removing = new ArrayList<E>(one);\n+        final Collection<E> removing = new ArrayList<E>(one);\n         c.addComposited(one, two);\n         c.removeAll(removing);\n         assertTrue(!c.contains(\"1\"));\n--- a/src/test/java/org/apache/commons/collections/collection/IndexedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/IndexedCollectionTest.java\n @SuppressWarnings(\"boxing\")\n public class IndexedCollectionTest extends AbstractCollectionTest<String> {\n \n-    public IndexedCollectionTest(String name) {\n+    public IndexedCollectionTest(final String name) {\n         super(name);\n     }\n \n    //------------------------------------------------------------------------\n \n-    protected Collection<String> decorateCollection(Collection<String> collection) {\n+    protected Collection<String> decorateCollection(final Collection<String> collection) {\n         return IndexedCollection.uniqueIndexedCollection(collection, new IntegerTransformer());\n     }\n \n     private static final class IntegerTransformer implements Transformer<String, Integer>, Serializable {\n         private static final long serialVersionUID = 809439581555072949L;\n \n-        public Integer transform(String input) {\n+        public Integer transform(final String input) {\n             return Integer.valueOf(input);\n         }\n     }\n \n     @Override\n     public Collection<String> makeFullCollection() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return decorateCollection(list);\n     }\n \n     @Override\n     public Collection<String> makeConfirmedFullCollection() {\n-        List<String> list = new ArrayList<String>();\n+        final List<String> list = new ArrayList<String>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n \n     @Test\n     public void addedObjectsCanBeRetrievedByKey() throws Exception {\n-        Collection<String> coll = getCollection();\n+        final Collection<String> coll = getCollection();\n         coll.add(\"12\");\n         coll.add(\"16\");\n         coll.add(\"1\");\n         coll.addAll(asList(\"2\",\"3\",\"4\"));\n         \n         @SuppressWarnings(\"unchecked\")\n+        final\n         IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;\n         assertEquals(\"12\", indexed.get(12));\n         assertEquals(\"16\", indexed.get(16));\n--- a/src/test/java/org/apache/commons/collections/collection/PredicatedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/PredicatedCollectionTest.java\n  */\n public class PredicatedCollectionTest<E> extends AbstractCollectionTest<E> {\n \n-    public PredicatedCollectionTest(String name) {\n+    public PredicatedCollectionTest(final String name) {\n         super(name);\n     }\n \n     protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n \n     protected Collection<E> decorateCollection(\n-                Collection<E> collection, Predicate<E> predicate) {\n+                final Collection<E> collection, final Predicate<E> predicate) {\n         return PredicatedCollection.predicatedCollection(collection, predicate);\n     }\n \n \n     @Override\n     public Collection<E> makeFullCollection() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return decorateCollection(list, truePredicate);\n     }\n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     //-----------------------------------------------------------------------\n     protected Predicate<E> testPredicate =\n         new Predicate<E>() {\n-            public boolean evaluate(E o) {\n+            public boolean evaluate(final E o) {\n                 return o instanceof String;\n             }\n         };\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        Collection<E> c = makeTestCollection();\n-        Integer i = new Integer(3);\n+        final Collection<E> c = makeTestCollection();\n+        final Integer i = new Integer(3);\n         try {\n             c.add((E) i);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\",\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        Collection<E> c = makeTestCollection();\n-        List<E> elements = new ArrayList<E>();\n+        final Collection<E> c = makeTestCollection();\n+        final List<E> elements = new ArrayList<E>();\n         elements.add((E) \"one\");\n         elements.add((E) \"two\");\n         elements.add((E) new Integer(3));\n         try {\n             c.addAll(elements);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"one\"));\n--- a/src/test/java/org/apache/commons/collections/collection/SynchronizedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/SynchronizedCollectionTest.java\n  */\n public class SynchronizedCollectionTest<E> extends AbstractCollectionTest<E> {\n \n-    public SynchronizedCollectionTest(String testName) {\n+    public SynchronizedCollectionTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n--- a/src/test/java/org/apache/commons/collections/collection/TransformedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/TransformedCollectionTest.java\n public class TransformedCollectionTest extends AbstractCollectionTest<Object> {\n     \n     private static class StringToInteger implements Transformer<Object, Object> {\n-        public Object transform(Object input) {\n+        public Object transform(final Object input) {\n             return new Integer((String) input);\n         }\n     }\n     public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n     public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n \n-    public TransformedCollectionTest(String testName) {\n+    public TransformedCollectionTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public Collection<Object> makeConfirmedFullCollection() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n \n     @Override\n     public Collection<Object> makeFullCollection() {\n-        List<Object> list = new ArrayList<Object>();\n+        final List<Object> list = new ArrayList<Object>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testTransformedCollection() {\n-        Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n+        final Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, coll.size());\n-        Object[] els = getFullElements();\n+        final Object[] els = getFullElements();\n         for (int i = 0; i < els.length; i++) {\n             coll.add(els[i]);\n             assertEquals(i + 1, coll.size());\n     }\n \n     public void testTransformedCollection_decorateTransform() {\n-        Collection originalCollection = new ArrayList();\n-        Object[] els = getFullElements();\n-        for (Object el : els) {\n+        final Collection originalCollection = new ArrayList();\n+        final Object[] els = getFullElements();\n+        for (final Object el : els) {\n             originalCollection.add(el);\n         }\n-        Collection<Object> collection = TransformedCollection.transformedCollection(originalCollection, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final Collection<Object> collection = TransformedCollection.transformedCollection(originalCollection, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, collection.size());\n-        for (Object el : els) {\n+        for (final Object el : els) {\n             assertEquals(true, collection.contains(new Integer((String) el)));\n             assertEquals(false, collection.contains(el));\n         }\n--- a/src/test/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollectionTest.java\n  */\n public class UnmodifiableBoundedCollectionTest<E> extends AbstractCollectionTest<E> {\n \n-    public UnmodifiableBoundedCollectionTest(String testName) {\n+    public UnmodifiableBoundedCollectionTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public Collection<E> makeObject() {\n-        BoundedBuffer<E> buffer = BoundedBuffer.<E>boundedBuffer(new ArrayStack<E>(), 10);\n+        final BoundedBuffer<E> buffer = BoundedBuffer.<E>boundedBuffer(new ArrayStack<E>(), 10);\n         return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(buffer);\n     }\n \n     @Override\n     public Collection<E> makeFullCollection() {\n-        E[] allElements = getFullElements();\n-        Buffer<E> buffer = BufferUtils.boundedBuffer(new ArrayStack<E>(), allElements.length);\n+        final E[] allElements = getFullElements();\n+        final Buffer<E> buffer = BufferUtils.boundedBuffer(new ArrayStack<E>(), allElements.length);\n         buffer.addAll(Arrays.asList(allElements));\n         return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(buffer);\n     }\n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n--- a/src/test/java/org/apache/commons/collections/collection/UnmodifiableCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/UnmodifiableCollectionTest.java\n  */\n public class UnmodifiableCollectionTest<E> extends AbstractCollectionTest<E> {\n \n-    public UnmodifiableCollectionTest(String testName) {\n+    public UnmodifiableCollectionTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public Collection<E> makeFullCollection() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return UnmodifiableCollection.unmodifiableCollection(list);\n     }\n \n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n--- a/src/test/java/org/apache/commons/collections/comparators/AbstractComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/AbstractComparatorTest.java\n      * \n      * @param testName  the test class name\n      */\n-    public AbstractComparatorTest(String testName) {\n+    public AbstractComparatorTest(final String testName) {\n         super(testName);\n     }\n \n     /**\n      * Reverse the list.\n      */\n-    protected void reverseObjects(List<?> list) {\n+    protected void reverseObjects(final List<?> list) {\n         Collections.reverse(list);\n     }\n \n     /**\n      * Randomize the list.\n      */\n-    protected void randomizeObjects(List<?> list) {\n+    protected void randomizeObjects(final List<?> list) {\n         Collections.shuffle(list);\n     }\n \n     /**\n      * Sort the list.\n      */\n-    protected void sortObjects(List<T> list, Comparator<? super T> comparator) {\n+    protected void sortObjects(final List<T> list, final Comparator<? super T> comparator) {\n         Collections.sort(list, comparator);\n     }\n \n      */\n     @Test\n     public void testEmptyListSort() {\n-        List<T> list = new LinkedList<T>();\n+        final List<T> list = new LinkedList<T>();\n         sortObjects(list, makeObject());\n \n-        List<T> list2 = new LinkedList<T>();\n+        final List<T> list2 = new LinkedList<T>();\n \n         assertTrue(\"Comparator cannot sort empty lists\", list2.equals(list));\n     }\n      */\n     @Test\n     public void testReverseListSort() {\n-        Comparator<T> comparator = makeObject();\n-\n-        List<T> randomList = getComparableObjectsOrdered();\n+        final Comparator<T> comparator = makeObject();\n+\n+        final List<T> randomList = getComparableObjectsOrdered();\n         reverseObjects(randomList);\n         sortObjects(randomList, comparator);\n \n-        List<T> orderedList = getComparableObjectsOrdered();\n+        final List<T> orderedList = getComparableObjectsOrdered();\n \n         assertTrue(\"Comparator did not reorder the List correctly\",\n                    orderedList.equals(randomList));\n      */\n     @Test\n     public void testRandomListSort() {\n-        Comparator<T> comparator = makeObject();\n-\n-        List<T> randomList = getComparableObjectsOrdered();\n+        final Comparator<T> comparator = makeObject();\n+\n+        final List<T> randomList = getComparableObjectsOrdered();\n         randomizeObjects(randomList);\n         sortObjects(randomList,comparator);\n \n-        List<T> orderedList = getComparableObjectsOrdered();\n+        final List<T> orderedList = getComparableObjectsOrdered();\n \n         /* debug \n         Iterator i = randomList.iterator();\n      */\n     @Test\n     public void testComparatorIsSerializable() {\n-        Comparator<T> comparator = makeObject();\n+        final Comparator<T> comparator = makeObject();\n         assertTrue(\"This comparator should be Serializable.\",\n                    comparator instanceof Serializable);\n     }\n \n-    public String getCanonicalComparatorName(Object object) {\n-        StringBuilder retval = new StringBuilder();\n+    public String getCanonicalComparatorName(final Object object) {\n+        final StringBuilder retval = new StringBuilder();\n         retval.append(TEST_DATA_PATH);\n         String colName = object.getClass().getName();\n         colName = colName.substring(colName.lastIndexOf(\".\")+1,colName.length());\n             // test to make sure the canonical form has been preserved\n             try {\n                 comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));\n-            } catch (FileNotFoundException exception) {\n-    \n-                boolean autoCreateSerialized = false;\n+            } catch (final FileNotFoundException exception) {\n+    \n+                final boolean autoCreateSerialized = false;\n     \n                 if (autoCreateSerialized) {\n                     comparator = makeObject();\n-                    String fileName = getCanonicalComparatorName(comparator);\n+                    final String fileName = getCanonicalComparatorName(comparator);\n                     writeExternalFormToDisk((Serializable) comparator, fileName);\n                     fail(\"Serialized form could not be found.  A serialized version \"\n                             + \"has now been written (and should be added to CVS): \" + fileName);\n             \n             // make sure the canonical form produces the ordering we currently\n             // expect\n-            List<T> randomList = getComparableObjectsOrdered();\n+            final List<T> randomList = getComparableObjectsOrdered();\n             reverseObjects(randomList);\n             sortObjects(randomList, comparator);\n     \n-            List<T> orderedList = getComparableObjectsOrdered();\n+            final List<T> orderedList = getComparableObjectsOrdered();\n     \n             assertTrue(\"Comparator did not reorder the List correctly\",\n                        orderedList.equals(randomList));\n--- a/src/test/java/org/apache/commons/collections/comparators/AbstractNullComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/AbstractNullComparatorTest.java\n  */\n public abstract class AbstractNullComparatorTest extends AbstractComparatorTest<Integer> {\n \n-    public AbstractNullComparatorTest(String testName) {\n+    public AbstractNullComparatorTest(final String testName) {\n         super(testName);\n     }\n \n     public static Test suite() {\n-        TestSuite suite = new TestSuite(AbstractNullComparatorTest.class.getName());\n+        final TestSuite suite = new TestSuite(AbstractNullComparatorTest.class.getName());\n         suite.addTest(new TestSuite(TestNullComparator1.class));\n         suite.addTest(new TestSuite(TestNullComparator2.class));\n         return suite;\n      **/\n     public static class TestNullComparator1 extends AbstractNullComparatorTest {\n \n-        public TestNullComparator1(String testName) {\n+        public TestNullComparator1(final String testName) {\n             super(testName);\n         }\n \n \n         @Override\n         public List<Integer> getComparableObjectsOrdered() {\n-            List<Integer> list = new LinkedList<Integer>();\n+            final List<Integer> list = new LinkedList<Integer>();\n             list.add(new Integer(1));\n             list.add(new Integer(2));\n             list.add(new Integer(3));\n         }\n \n         @Override\n-        public String getCanonicalComparatorName(Object object) {\n+        public String getCanonicalComparatorName(final Object object) {\n             return super.getCanonicalComparatorName(object) + \"1\";\n         }\n     }\n      **/\n     public static class TestNullComparator2 extends AbstractNullComparatorTest {\n \n-        public TestNullComparator2(String testName) {\n+        public TestNullComparator2(final String testName) {\n             super(testName);\n         }\n \n \n         @Override\n         public List<Integer> getComparableObjectsOrdered() {\n-            List<Integer> list = new LinkedList<Integer>();\n+            final List<Integer> list = new LinkedList<Integer>();\n             list.add(null);\n             list.add(new Integer(1));\n             list.add(new Integer(2));\n         }\n \n         @Override\n-        public String getCanonicalComparatorName(Object object) {\n+        public String getCanonicalComparatorName(final Object object) {\n             return super.getCanonicalComparatorName(object) + \"2\";\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/comparators/BooleanComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/BooleanComparatorTest.java\n     // conventional\n     // ------------------------------------------------------------------------\n \n-    public BooleanComparatorTest(String testName) {\n+    public BooleanComparatorTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public List<Boolean> getComparableObjectsOrdered() {\n-        List<Boolean> list = new ArrayList<Boolean>();\n+        final List<Boolean> list = new ArrayList<Boolean>();\n         list.add(new Boolean(false));\n         list.add(Boolean.FALSE);\n         list.add(new Boolean(false));\n     // utilities\n     // ------------------------------------------------------------------------\n \n-    protected void allTests(boolean trueFirst, BooleanComparator comp) {\n+    protected void allTests(final boolean trueFirst, final BooleanComparator comp) {\n         orderIndependentTests(comp);\n         if(trueFirst) {\n             trueFirstTests(comp);\n         }\n     }\n \n-    protected void trueFirstTests(BooleanComparator comp) {\n+    protected void trueFirstTests(final BooleanComparator comp) {\n         assertNotNull(comp);\n         assertEquals(0,comp.compare(true, true));\n         assertEquals(0,comp.compare(false, false));\n         assertTrue(comp.compare(true, false) < 0);\n     }\n \n-    protected void falseFirstTests(BooleanComparator comp) {\n+    protected void falseFirstTests(final BooleanComparator comp) {\n         assertNotNull(comp);\n         assertEquals(0,comp.compare(true, true));\n         assertEquals(0,comp.compare(false, false));\n         assertTrue(comp.compare(true, false) > 0);\n     }\n \n-    protected void orderIndependentTests(BooleanComparator comp) {\n+    protected void orderIndependentTests(final BooleanComparator comp) {\n         nullArgumentTests(comp);\n     }\n \n-    protected void nullArgumentTests(BooleanComparator comp) {\n+    protected void nullArgumentTests(final BooleanComparator comp) {\n         assertNotNull(comp);\n         try {\n             comp.compare(null,null);\n             fail(\"Expected NullPointerException\");\n-        } catch(NullPointerException e) {\n+        } catch(final NullPointerException e) {\n             // expected\n         }\n         try {\n             comp.compare(Boolean.TRUE,null);\n             fail(\"Expected NullPointerException\");\n-        } catch(NullPointerException e) {\n+        } catch(final NullPointerException e) {\n             // expected\n         }\n         try {\n             comp.compare(Boolean.FALSE,null);\n             fail(\"Expected NullPointerException\");\n-        } catch(NullPointerException e) {\n+        } catch(final NullPointerException e) {\n             // expected\n         }\n         try {\n             comp.compare(null,Boolean.TRUE);\n             fail(\"Expected NullPointerException\");\n-        } catch(NullPointerException e) {\n+        } catch(final NullPointerException e) {\n             // expected\n         }\n         try {\n             comp.compare(null,Boolean.FALSE);\n             fail(\"Expected NullPointerException\");\n-        } catch(NullPointerException e) {\n+        } catch(final NullPointerException e) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/comparators/ComparableComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/ComparableComparatorTest.java\n @SuppressWarnings(\"boxing\")\n public class ComparableComparatorTest extends AbstractComparatorTest<Integer> {\n \n-    public ComparableComparatorTest(String testName) {\n+    public ComparableComparatorTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public List<Integer> getComparableObjectsOrdered() {\n-        List<Integer> list = new LinkedList<Integer>();\n+        final List<Integer> list = new LinkedList<Integer>();\n         list.add(1);\n         list.add(2);\n         list.add(3);\n--- a/src/test/java/org/apache/commons/collections/comparators/ComparatorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/ComparatorChainTest.java\n  */\n public class ComparatorChainTest extends AbstractComparatorTest<ComparatorChainTest.PseudoRow> {\n \n-    public ComparatorChainTest(String testName) {\n+    public ComparatorChainTest(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     public Comparator<PseudoRow> makeObject() {\n-        ComparatorChain<PseudoRow> chain = new ComparatorChain<PseudoRow>(new ColumnComparator(0));\n+        final ComparatorChain<PseudoRow> chain = new ComparatorChain<PseudoRow>(new ColumnComparator(0));\n         chain.addComparator(new ColumnComparator(1), true); // reverse the second column\n         chain.addComparator(new ColumnComparator(2), false);\n         return chain;\n \n     @Test\n     public void testNoopComparatorChain() {\n-        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n-        Integer i1 = new Integer(4);\n-        Integer i2 = new Integer(6);\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n         chain.addComparator(new ComparableComparator<Integer>());\n \n-        int correctValue = i1.compareTo(i2);\n+        final int correctValue = i1.compareTo(i2);\n         assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n     }\n \n     @Test\n     public void testBadNoopComparatorChain() {\n-        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n-        Integer i1 = new Integer(4);\n-        Integer i2 = new Integer(6);\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n         try {\n             chain.compare(i1,i2);\n             fail(\"An exception should be thrown when a chain contains zero comparators.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n         }\n     }\n \n     @Test\n     public void testListComparatorChain() {\n-        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        final List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n         list.add(new ComparableComparator<Integer>());\n-        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n-        Integer i1 = new Integer(4);\n-        Integer i2 = new Integer(6);\n-\n-        int correctValue = i1.compareTo(i2);\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n+\n+        final int correctValue = i1.compareTo(i2);\n         assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n     }\n \n     @Test\n     public void testBadListComparatorChain() {\n-        List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n-        ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n-        Integer i1 = new Integer(4);\n-        Integer i2 = new Integer(6);\n+        final List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n         try {\n             chain.compare(i1, i2);\n             fail(\"An exception should be thrown when a chain contains zero comparators.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n         }\n     }\n \n     public void testComparatorChainOnMinvaluedCompatator() {\n         // -1 * Integer.MIN_VALUE is less than 0,\n         // test that ComparatorChain handles this edge case correctly\n-        ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n         chain.addComparator(new Comparator<Integer>() {\n-            public int compare(Integer a, Integer b) {\n-                int result = a.compareTo(b);\n+            public int compare(final Integer a, final Integer b) {\n+                final int result = a.compareTo(b);\n                 if (result < 0) {\n                     return Integer.MIN_VALUE;\n                 }\n \n     @Override\n     public List<PseudoRow> getComparableObjectsOrdered() {\n-        List<PseudoRow> list = new LinkedList<PseudoRow>();\n+        final List<PseudoRow> list = new LinkedList<PseudoRow>();\n         // this is the correct order assuming a\n         // \"0th forward, 1st reverse, 2nd forward\" sort\n         list.add(new PseudoRow(1, 2, 3));\n \n         public int cols[] = new int[3];\n \n-        public PseudoRow(int col1, int col2, int col3) {\n+        public PseudoRow(final int col1, final int col2, final int col3) {\n             cols[0] = col1;\n             cols[1] = col2;\n             cols[2] = col3;\n         }\n \n-        public int getColumn(int colIndex) {\n+        public int getColumn(final int colIndex) {\n             return cols[colIndex];\n         }\n \n         @Override\n         public String toString() {\n-            StringBuilder buf = new StringBuilder();\n+            final StringBuilder buf = new StringBuilder();\n             buf.append(\"[\");\n             buf.append(cols[0]);\n             buf.append(\",\");\n         }\n \n         @Override\n-        public boolean equals(Object o) {\n+        public boolean equals(final Object o) {\n             if (!(o instanceof PseudoRow)) {\n                 return false;\n             }\n \n-            PseudoRow row = (PseudoRow) o;\n+            final PseudoRow row = (PseudoRow) o;\n             if (getColumn(0) != row.getColumn(0)) {\n                 return false;\n             }\n \n         protected int colIndex = 0;\n \n-        public ColumnComparator(int colIndex) {\n+        public ColumnComparator(final int colIndex) {\n             this.colIndex = colIndex;\n         }\n \n-        public int compare(PseudoRow o1, PseudoRow o2) {\n-\n-            int col1 = o1.getColumn(colIndex);\n-            int col2 = o2.getColumn(colIndex);\n+        public int compare(final PseudoRow o1, final PseudoRow o2) {\n+\n+            final int col1 = o1.getColumn(colIndex);\n+            final int col2 = o2.getColumn(colIndex);\n \n             if (col1 > col2) {\n                 return 1;\n         }\n \n         @Override\n-        public boolean equals(Object that) {\n+        public boolean equals(final Object that) {\n             return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/comparators/FixedOrderComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/FixedOrderComparatorTest.java\n     // Initialization and busywork\n     //\n \n-    public FixedOrderComparatorTest(String name) {\n+    public FixedOrderComparatorTest(final String name) {\n         super(name);\n     }\n \n \n     @Override\n     public Comparator<String> makeObject() {\n-        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n         return comparator;\n     }\n \n      */\n     @Test\n     public void testConstructorPlusAdd() {\n-        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>();\n-        for (String topCitie : topCities) {\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>();\n+        for (final String topCitie : topCities) {\n             comparator.add(topCitie);\n         }\n-        String[] keys = topCities.clone();\n+        final String[] keys = topCities.clone();\n         assertComparatorYieldsOrder(keys, comparator);\n     }\n \n      */\n     @Test\n     public void testArrayConstructor() {\n-        String[] keys = topCities.clone();\n-        String[] topCitiesForTest = topCities.clone();\n-        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        final String[] keys = topCities.clone();\n+        final String[] topCitiesForTest = topCities.clone();\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n         assertComparatorYieldsOrder(keys, comparator);\n         // test that changing input after constructor has no effect\n         topCitiesForTest[0] = \"Brighton\";\n      */\n     @Test\n     public void testListConstructor() {\n-        String[] keys = topCities.clone();\n-        List<String> topCitiesForTest = new LinkedList<String>(Arrays.asList(topCities));\n-        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        final String[] keys = topCities.clone();\n+        final List<String> topCitiesForTest = new LinkedList<String>(Arrays.asList(topCities));\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n         assertComparatorYieldsOrder(keys, comparator);\n         // test that changing input after constructor has no effect\n         topCitiesForTest.set(0, \"Brighton\");\n      */\n     @Test\n     public void testAddAsEqual() {\n-        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n         comparator.addAsEqual(\"New York\", \"Minneapolis\");\n         assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n         assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n      */\n     @Test\n     public void testLock() {\n-        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n         assertEquals(false, comparator.isLocked());\n         comparator.compare(\"New York\", \"Tokyo\");\n         assertEquals(true, comparator.isLocked());\n         try {\n             comparator.add(\"Minneapolis\");\n             fail(\"Should have thrown an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // success -- ignore\n         }\n \n         try {\n             comparator.addAsEqual(\"New York\", \"Minneapolis\");\n             fail(\"Should have thrown an UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // success -- ignore\n         }\n     }\n         try {\n             comparator.compare(\"New York\", \"Minneapolis\");\n             fail(\"Should have thrown a IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // success-- ignore\n         }\n         try {\n             comparator.compare(\"Minneapolis\", \"New York\");\n             fail(\"Should have thrown a IllegalArgumentException\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // success-- ignore\n         }\n         assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());\n     /** Shuffles the keys and asserts that the comparator sorts them back to\n      * their original order.\n      */\n-    private void assertComparatorYieldsOrder(String[] orderedObjects,\n-                                             Comparator<String> comparator) {\n-        String[] keys = orderedObjects.clone();\n+    private void assertComparatorYieldsOrder(final String[] orderedObjects,\n+                                             final Comparator<String> comparator) {\n+        final String[] keys = orderedObjects.clone();\n \n         // shuffle until the order changes.  It's extremely rare that\n         // this requires more than one shuffle.\n \n         boolean isInNewOrder = false;\n-        Random rand = new Random();\n+        final Random rand = new Random();\n         while (keys.length > 1 && isInNewOrder == false) {\n             // shuffle:\n             for (int i = keys.length-1; i > 0; i--) {\n-                String swap = keys[i];\n-                int j = rand.nextInt(i+1);\n+                final String swap = keys[i];\n+                final int j = rand.nextInt(i+1);\n                 keys[i] = keys[j];\n                 keys[j] = swap;\n             }\n--- a/src/test/java/org/apache/commons/collections/comparators/ReverseComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/ReverseComparatorTest.java\n  */\n public class ReverseComparatorTest extends AbstractComparatorTest<Integer> {\n \n-    public ReverseComparatorTest(String testName) {\n+    public ReverseComparatorTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public List<Integer> getComparableObjectsOrdered() {\n-        List<Integer> list = new LinkedList<Integer>();\n+        final List<Integer> list = new LinkedList<Integer>();\n         list.add(new Integer(1));\n         list.add(new Integer(2));\n         list.add(new Integer(3));\n     @SuppressWarnings(\"unchecked\")\n     @Test\n     public void testSerializeDeserializeThenCompare() throws Exception {\n-        Comparator comp = new ReverseComparator(new ComparableComparator());\n+        final Comparator comp = new ReverseComparator(new ComparableComparator());\n \n-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n         out.writeObject(comp);\n         out.close();\n \n-        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n-        Object dest = in.readObject();\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final Object dest = in.readObject();\n         in.close();\n         assertEquals(\"obj != deserialize(serialize(obj))\",comp,dest);\n     }\n--- a/src/test/java/org/apache/commons/collections/comparators/TransformingComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/TransformingComparatorTest.java\n     // Initialization and busywork\n     //\n \n-    public TransformingComparatorTest(String name) {\n+    public TransformingComparatorTest(final String name) {\n         super(name);\n     }\n \n \n     @Override\n     public Comparator<Integer> makeObject() {\n-       Comparator<Integer> decorated = new ComparableComparator<Integer>();\n-       TransformingComparator<Integer> comparator =\n+       final Comparator<Integer> decorated = new ComparableComparator<Integer>();\n+       final TransformingComparator<Integer> comparator =\n                new TransformingComparator<Integer>(TransformerUtils.<Integer>nopTransformer(), decorated);\n        return comparator;\n     }\n \n     @Override\n     public List<Integer> getComparableObjectsOrdered() {\n-        List<Integer> list = new LinkedList<Integer>();\n+        final List<Integer> list = new LinkedList<Integer>();\n         list.add(1);\n         list.add(2);\n         list.add(3);\n--- a/src/test/java/org/apache/commons/collections/comparators/sequence/SequencesComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/sequence/SequencesComparatorTest.java\n     @Test\n     public void testLength() {\n         for (int i = 0; i < before.size(); ++i) {\n-            SequencesComparator<Character> comparator =\n+            final SequencesComparator<Character> comparator =\n                     new SequencesComparator<Character>(sequence(before.get(i)),\n                             sequence(after.get(i)));\n             Assert.assertEquals(length[i], comparator.getScript().getModifications());\n \n     @Test\n     public void testExecution() {\n-        ExecutionVisitor<Character> ev = new ExecutionVisitor<Character>();\n+        final ExecutionVisitor<Character> ev = new ExecutionVisitor<Character>();\n         for (int i = 0; i < before.size(); ++i) {\n             ev.setList(sequence(before.get(i)));\n             new SequencesComparator<Character>(sequence(before.get(i)),\n \n     @Test\n     public void testMinimal() {\n-        String[] shadokAlph = new String[] {\n+        final String[] shadokAlph = new String[] {\n             new String(\"GA\"),\n             new String(\"BU\"),\n             new String(\"ZO\"),\n             new String(\"MEU\")\n         };\n-        List<String> sentenceBefore = new ArrayList<String>();\n-        List<String> sentenceAfter  = new ArrayList<String>();\n-        sentenceBefore.add(shadokAlph[0]);\n-        sentenceBefore.add(shadokAlph[2]);\n-        sentenceBefore.add(shadokAlph[3]);\n-        sentenceBefore.add(shadokAlph[1]);\n-        sentenceBefore.add(shadokAlph[0]);\n-        sentenceBefore.add(shadokAlph[0]);\n-        sentenceBefore.add(shadokAlph[2]);\n-        sentenceBefore.add(shadokAlph[1]);\n-        sentenceBefore.add(shadokAlph[3]);\n-        sentenceBefore.add(shadokAlph[0]);\n-        sentenceBefore.add(shadokAlph[2]);\n-        sentenceBefore.add(shadokAlph[1]);\n-        sentenceBefore.add(shadokAlph[3]);\n-        sentenceBefore.add(shadokAlph[2]);\n-        sentenceBefore.add(shadokAlph[2]);\n-        sentenceBefore.add(shadokAlph[0]);\n-        sentenceBefore.add(shadokAlph[1]);\n-        sentenceBefore.add(shadokAlph[3]);\n-        sentenceBefore.add(shadokAlph[0]);\n-        sentenceBefore.add(shadokAlph[3]);\n-\n-        Random random = new Random(4564634237452342L);\n+        final List<String> sentenceBefore = new ArrayList<String>();\n+        final List<String> sentenceAfter  = new ArrayList<String>();\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[3]);\n+\n+        final Random random = new Random(4564634237452342L);\n \n         for (int nbCom = 0; nbCom <= 40; nbCom+=5) {\n             sentenceAfter.clear();\n                 }\n             }\n \n-            SequencesComparator<String> comparator =\n+            final SequencesComparator<String> comparator =\n                     new SequencesComparator<String>(sentenceBefore, sentenceAfter);\n             Assert.assertTrue(comparator.getScript().getModifications() <= nbCom);\n         }\n \n     @Test\n     public void testShadok() {\n-        int lgMax = 5;\n-        String[] shadokAlph = new String[] {\n+        final int lgMax = 5;\n+        final String[] shadokAlph = new String[] {\n             new String(\"GA\"),\n             new String(\"BU\"),\n             new String(\"ZO\"),\n         };\n         List<List<String>> shadokSentences = new ArrayList<List<String>>();\n         for (int lg=0; lg<lgMax; ++lg) {\n-            List<List<String>> newTab = new ArrayList<List<String>>();\n+            final List<List<String>> newTab = new ArrayList<List<String>>();\n             newTab.add(new ArrayList<String>());\n-            for (String element : shadokAlph) {\n-                for (List<String> sentence : shadokSentences) {\n-                    List<String> newSentence = new ArrayList<String>(sentence);\n+            for (final String element : shadokAlph) {\n+                for (final List<String> sentence : shadokSentences) {\n+                    final List<String> newSentence = new ArrayList<String>(sentence);\n                     newSentence.add(element);\n                     newTab.add(newSentence);\n                 }\n             shadokSentences = newTab;\n         }\n \n-        ExecutionVisitor<String> ev = new ExecutionVisitor<String>();\n+        final ExecutionVisitor<String> ev = new ExecutionVisitor<String>();\n \n         for (int i = 0; i < shadokSentences.size(); ++i) {\n             for (int j = 0; j < shadokSentences.size(); ++j) {\n                 new SequencesComparator<String>(shadokSentences.get(i),\n                         shadokSentences.get(j)).getScript().visit(ev);\n \n-                StringBuilder concat = new StringBuilder();\n+                final StringBuilder concat = new StringBuilder();\n                 for (final String s : shadokSentences.get(j)) {\n                     concat.append(s);\n                 }\n         }\n     }\n \n-    private List<Character> sequence(String string) {\n-        List<Character> list = new ArrayList<Character>();\n+    private List<Character> sequence(final String string) {\n+        final List<Character> list = new ArrayList<Character>();\n         for (int i = 0; i < string.length(); ++i) {\n             list.add(new Character(string.charAt(i)));\n         }\n         private List<T> v;\n         private int index;\n \n-        public void setList(List<T> array) {\n+        public void setList(final List<T> array) {\n             v = new ArrayList<T>(array);\n             index = 0;\n         }\n \n-        public void visitInsertCommand(T object) {\n+        public void visitInsertCommand(final T object) {\n             v.add(index++, object);\n         }\n \n-        public void visitKeepCommand(T object) {\n+        public void visitKeepCommand(final T object) {\n             ++index;\n         }\n \n-        public void visitDeleteCommand(T object) {\n+        public void visitDeleteCommand(final T object) {\n             v.remove(index);\n         }\n \n         public String getString() {\n-            StringBuffer buffer = new StringBuffer();\n-            for (T c : v) {\n+            final StringBuffer buffer = new StringBuffer();\n+            for (final T c : v) {\n                 buffer.append(c);\n             }\n             return buffer.toString();\n--- a/src/test/java/org/apache/commons/collections/functors/AbstractClosureTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/AbstractClosureTest.java\n \n     @Test\n     public void closureSanityTests() throws Exception {\n-        Closure<?> closure = generateClosure();\n+        final Closure<?> closure = generateClosure();\n         Assert.assertNotNull(closure);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/functors/AbstractCompositePredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/AbstractCompositePredicateTest.java\n      */\n     protected final Predicate<T> getPredicateInstance(final Boolean... mockReturnValues) {\n         final List<Predicate<T>> predicates = new ArrayList<Predicate<T>>();\n-        for (Boolean returnValue : mockReturnValues) {\n+        for (final Boolean returnValue : mockReturnValues) {\n             predicates.add(createMockPredicate(returnValue));\n         }\n         return getPredicateInstance(predicates);\n--- a/src/test/java/org/apache/commons/collections/functors/AbstractMockPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/AbstractMockPredicateTest.java\n     @After\n     public final void verifyPredicates()\n     {\n-        for (Predicate<? super T> predicate : mockPredicatesToVerify) {\n+        for (final Predicate<? super T> predicate : mockPredicatesToVerify) {\n             verify(predicate);\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/functors/AbstractPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/AbstractPredicateTest.java\n     \n     @Test\n     public void predicateSanityTests() throws Exception {\n-        Predicate<?> predicate = generatePredicate();\n+        final Predicate<?> predicate = generatePredicate();\n         Assert.assertNotNull(predicate);\n     }\n \n      */\n     protected abstract Predicate<?> generatePredicate();\n \n-    protected <T> void assertFalse(Predicate<T> predicate, T testObject) {\n+    protected <T> void assertFalse(final Predicate<T> predicate, final T testObject) {\n         Assert.assertFalse(predicate.evaluate(testObject));\n     }\n \n-    protected <T> void assertTrue(Predicate<T> predicate, T testObject) {\n+    protected <T> void assertTrue(final Predicate<T> predicate, final T testObject) {\n         Assert.assertTrue(predicate.evaluate(testObject));\n     }\n }\n--- a/src/test/java/org/apache/commons/collections/functors/CatchAndRethrowClosureTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/CatchAndRethrowClosureTest.java\n         return new CatchAndRethrowClosure<T>() {\n \n             @Override\n-            protected void executeAndThrow(T input) throws IOException  {\n+            protected void executeAndThrow(final T input) throws IOException  {\n                 throw new IOException();\n             }\n         };\n         return new CatchAndRethrowClosure<T>() {\n \n             @Override\n-            protected void executeAndThrow(T input) {\n+            protected void executeAndThrow(final T input) {\n                 throw new NullPointerException();\n             }\n         };\n         return new CatchAndRethrowClosure<T>() {\n \n             @Override\n-            protected void executeAndThrow(T input) {\n+            protected void executeAndThrow(final T input) {\n             }\n         };\n     }\n         Closure<Integer> closure = generateNoExceptionClosure();\n         try {\n             closure.execute(Integer.valueOf(0));\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             Assert.fail();\n-        } catch (RuntimeException ex) {\n+        } catch (final RuntimeException ex) {\n             Assert.fail();\n         }\n         \n         try {\n             closure.execute(Integer.valueOf(0));\n             Assert.fail();\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             Assert.assertTrue(ex.getCause() instanceof IOException);\n-        } catch (RuntimeException ex) {\n+        } catch (final RuntimeException ex) {\n             Assert.fail();\n         }\n \n         try {\n             closure.execute(Integer.valueOf(0));\n             Assert.fail();\n-        } catch (FunctorException ex) {\n+        } catch (final FunctorException ex) {\n             Assert.fail();\n-        } catch (RuntimeException ex) {\n+        } catch (final RuntimeException ex) {\n             Assert.assertTrue(ex instanceof NullPointerException);\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/functors/ComparatorPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/ComparatorPredicateTest.java\n \n public class ComparatorPredicateTest extends AbstractPredicateTest {\n     private class TestComparator<T extends Comparable<T>> implements Comparator<T> {\n-        public int compare(T first, T second) {\n+        public int compare(final T first, final T second) {\n             return first.compareTo(second);\n         }\n     }\n \n     @Test\n     public void compareEquals() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());\n         assertFalse(p, Integer.valueOf(value.intValue() - 1));\n         assertTrue(p, Integer.valueOf(value.intValue()));\n         assertFalse(p, Integer.valueOf(value.intValue() + 1));\n \n     @Test\n     public void compareGreater() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);\n         assertTrue(p, Integer.valueOf(value.intValue() - 1));\n         assertFalse(p, Integer.valueOf(value.intValue()));\n         assertFalse(p, Integer.valueOf(value.intValue() + 1));\n \n     @Test\n     public void compareLess() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);\n         assertFalse(p, Integer.valueOf(value.intValue() - 1));\n         assertFalse(p, Integer.valueOf(value.intValue()));\n         assertTrue(p, Integer.valueOf(value.intValue() + 1));\n \n     @Test\n     public void compareGreaterOrEqual() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n         assertTrue(p, Integer.valueOf(value.intValue() - 1));\n         assertTrue(p, Integer.valueOf(value.intValue()));\n         assertFalse(p, Integer.valueOf(value.intValue() + 1));\n \n     @Test\n     public void compareLessOrEqual() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n         assertFalse(p, Integer.valueOf(value.intValue() - 1));\n         assertTrue(p, Integer.valueOf(value.intValue()));\n         assertTrue(p, Integer.valueOf(value.intValue() + 1));\n--- a/src/test/java/org/apache/commons/collections/functors/EqualPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/EqualPredicateTest.java\n     \n     @Test\n     public void objectFactoryUsesEqualsForTest() throws Exception {\n-        Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);\n+        final Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);\n         assertFalse(predicate, FALSE_OBJECT);\n         assertTrue(equalPredicate(TRUE_OBJECT), TRUE_OBJECT);\n     }\n     @SuppressWarnings(\"boxing\")\n     @Test\n     public void testPredicateTypeCanBeSuperClassOfObject() throws Exception {\n-        Predicate<Number> predicate = equalPredicate((Number) 4);\n+        final Predicate<Number> predicate = equalPredicate((Number) 4);\n         assertTrue(predicate, 4);\n     }\n \n     public static class EqualsTestObject {\n         private final boolean b;\n \n-        public EqualsTestObject(boolean b) {\n+        public EqualsTestObject(final boolean b) {\n             this.b = b;\n         }\n         \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             return b;\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/functors/NullPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections/functors/NullPredicateTest.java\n     }\n     \n     public void ensurePredicateCanBeTypedWithoutWarning() throws Exception {\n-        Predicate<String> predicate = NullPredicate.nullPredicate();\n+        final Predicate<String> predicate = NullPredicate.nullPredicate();\n         assertFalse(predicate, cString);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/iterators/AbstractIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractIteratorTest.java\n      * \n      * @param testName  the test class name\n      */\n-    public AbstractIteratorTest(String testName) {\n+    public AbstractIteratorTest(final String testName) {\n         super(testName);\n     }\n \n             return;\n         }\n \n-        Iterator<E> it = makeEmptyIterator();\n+        final Iterator<E> it = makeEmptyIterator();\n         \n         // hasNext() should return false\n         assertEquals(\"hasNext() should return false for empty iterators\", false, it.hasNext());\n         try {\n             it.next();\n             fail(\"NoSuchElementException must be thrown when Iterator is exhausted\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n         verify();\n         \n             return;\n         }\n \n-        Iterator<E> it = makeObject();\n+        final Iterator<E> it = makeObject();\n \n         // hasNext() must be true (ensure makeFullIterator is correct!)\n         assertEquals(\"hasNext() should return true for at least one element\", true, it.hasNext());\n         // next() must not throw exception (ensure makeFullIterator is correct!)\n         try {\n             it.next();\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             fail(\"Full iterators must have at least one element\");\n         }\n \n         try {\n             it.next();\n             fail(\"NoSuchElementException must be thrown when Iterator is exhausted\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n         \n         assertNotNull(it.toString());\n      * Test remove behaviour.\n      */\n     public void testRemove() {\n-        Iterator<E> it = makeObject();\n+        final Iterator<E> it = makeObject();\n         \n         if (supportsRemove() == false) {\n             // check for UnsupportedOperationException if not supported\n             try {\n                 it.remove();\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n             return;\n         }\n         \n         try {\n             it.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         verify();\n         \n         // remove after next should be fine\n         try {\n             it.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n     \n }\n--- a/src/test/java/org/apache/commons/collections/iterators/AbstractListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractListIteratorTest.java\n      *\n      * @param testName  the test class name\n      */\n-    public AbstractListIteratorTest(String testName) {\n+    public AbstractListIteratorTest(final String testName) {\n         super(testName);\n     }\n \n             return;\n         }\n \n-        ListIterator<E> it = makeEmptyIterator();\n+        final ListIterator<E> it = makeEmptyIterator();\n \n         assertEquals(false, it.hasNext());\n         assertEquals(0, it.nextIndex());\n         try {\n             it.next();\n             fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n \n         // previous() should throw a NoSuchElementException\n         try {\n             it.previous();\n             fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n     }\n \n      * Test navigation through the iterator.\n      */\n     public void testWalkForwardAndBack() {\n-        ArrayList<E> list = new ArrayList<E>();\n-        ListIterator<E> it = makeObject();\n+        final ArrayList<E> list = new ArrayList<E>();\n+        final ListIterator<E> it = makeObject();\n         while (it.hasNext()) {\n             list.add(it.next());\n         }\n         try {\n             it.next();\n             fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n \n         // loop back through comparing\n             assertEquals(i + 1, it.nextIndex());\n             assertEquals(i, it.previousIndex());\n \n-            Object obj = list.get(i);\n+            final Object obj = list.get(i);\n             assertEquals(obj, it.previous());\n         }\n \n         try {\n             it.previous();\n             fail(\"NoSuchElementException must be thrown from previous at start of ListIterator\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n     }\n \n     public void testAdd() {\n         ListIterator<E> it = makeObject();\n \n-        E addValue = addSetValue();\n+        final E addValue = addSetValue();\n         if (supportsAdd() == false) {\n             // check for UnsupportedOperationException if not supported\n             try {\n                 it.add(addValue);\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n             return;\n         }\n \n      * Test set behaviour.\n      */\n     public void testSet() {\n-        ListIterator<E> it = makeObject();\n+        final ListIterator<E> it = makeObject();\n \n         if (supportsSet() == false) {\n             // check for UnsupportedOperationException if not supported\n             try {\n                 it.set(addSetValue());\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n             return;\n         }\n \n         try {\n             it.set(addSetValue());\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n \n         // set after next should be fine\n         it.next();\n     }\n \n     public void testRemoveThenSet() {\n-        ListIterator<E> it = makeObject();\n+        final ListIterator<E> it = makeObject();\n         if (supportsRemove() && supportsSet()) {\n             it.next();\n             it.remove();\n             try {\n                 it.set(addSetValue());\n                 fail(\"IllegalStateException must be thrown from set after remove\");\n-            } catch (IllegalStateException e) {\n+            } catch (final IllegalStateException e) {\n             }\n         }\n     }\n \n     public void testAddThenSet() {\n-        ListIterator<E> it = makeObject();\n+        final ListIterator<E> it = makeObject();\n         // add then set\n         if (supportsAdd() && supportsSet()) {\n             it.next();\n             try {\n                 it.set(addSetValue());\n                 fail(\"IllegalStateException must be thrown from set after add\");\n-            } catch (IllegalStateException e) {\n+            } catch (final IllegalStateException e) {\n             }\n         }\n     }\n      * Test remove after add behaviour.\n      */\n     public void testAddThenRemove() {\n-        ListIterator<E> it = makeObject();\n+        final ListIterator<E> it = makeObject();\n \n         // add then remove\n         if (supportsAdd() && supportsRemove()) {\n             try {\n                 it.remove();\n                 fail(\"IllegalStateException must be thrown from remove after add\");\n-            } catch (IllegalStateException e) {\n+            } catch (final IllegalStateException e) {\n             }\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/iterators/AbstractMapIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractMapIteratorTest.java\n      *\n      * @param testName  the test class name\n      */\n-    public AbstractMapIteratorTest(String testName) {\n+    public AbstractMapIteratorTest(final String testName) {\n         super(testName);\n     }\n \n             return;\n         }\n \n-        MapIterator<K, V> it = makeEmptyIterator();\n+        final MapIterator<K, V> it = makeEmptyIterator();\n         assertEquals(false, it.hasNext());\n \n         // next() should throw a NoSuchElementException\n         try {\n             it.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n \n         // getKey() should throw an IllegalStateException\n         try {\n             it.getKey();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n \n         // getValue() should throw an IllegalStateException\n         try {\n             it.getValue();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n \n         if (supportsSetValue() == false) {\n             // setValue() should throw an UnsupportedOperationException/IllegalStateException\n             try {\n                 it.setValue(addSetValues()[0]);\n                 fail();\n-            } catch (UnsupportedOperationException ex) {\n-            } catch (IllegalStateException ex) {}\n+            } catch (final UnsupportedOperationException ex) {\n+            } catch (final IllegalStateException ex) {}\n         } else {\n             // setValue() should throw an IllegalStateException\n             try {\n                 it.setValue(addSetValues()[0]);\n                 fail();\n-            } catch (IllegalStateException ex) {}\n+            } catch (final IllegalStateException ex) {}\n         }\n     }\n \n             return;\n         }\n \n-        MapIterator<K, V> it = makeObject();\n-        Map<K, V> map = getMap();\n-        assertEquals(true, it.hasNext());\n-\n-        assertEquals(true, it.hasNext());\n-        Set<K> set = new HashSet<K>();\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+        assertEquals(true, it.hasNext());\n+\n+        assertEquals(true, it.hasNext());\n+        final Set<K> set = new HashSet<K>();\n         while (it.hasNext()) {\n             // getKey\n-            K key = it.next();\n+            final K key = it.next();\n             assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n             assertTrue(\"Key must be in map\",  map.containsKey(key));\n             assertTrue(\"Key must be unique\", set.add(key));\n \n             // getValue\n-            V value = it.getValue();\n+            final V value = it.getValue();\n             if (isGetStructuralModify() == false) {\n                 assertSame(\"Value must be mapped to key\", map.get(key), value);\n             }\n             return;\n         }\n \n-        V newValue = addSetValues()[0];\n-        V newValue2 = addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1];\n-        MapIterator<K, V> it = makeObject();\n-        Map<K, V> map = getMap();\n-        Map<K, V> confirmed = getConfirmedMap();\n-        assertEquals(true, it.hasNext());\n-        K key = it.next();\n-        V value = it.getValue();\n+        final V newValue = addSetValues()[0];\n+        final V newValue2 = addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1];\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n+        final V value = it.getValue();\n \n         if (supportsSetValue() == false) {\n             try {\n                 it.setValue(newValue);\n                 fail();\n-            } catch (UnsupportedOperationException ex) {}\n-            return;\n-        }\n-        V old = it.setValue(newValue);\n+            } catch (final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+        final V old = it.setValue(newValue);\n         confirmed.put(key, newValue);\n         assertSame(\"Key must not change after setValue\", key, it.getKey());\n         assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n     //-----------------------------------------------------------------------\n     @Override\n     public void testRemove() { // override\n-        MapIterator<K, V> it = makeObject();\n-        Map<K, V> map = getMap();\n-        Map<K, V> confirmed = getConfirmedMap();\n-        assertEquals(true, it.hasNext());\n-        K key = it.next();\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n \n         if (supportsRemove() == false) {\n             try {\n                 it.remove();\n                 fail();\n-            } catch (UnsupportedOperationException ex) {\n+            } catch (final UnsupportedOperationException ex) {\n             }\n             return;\n         }\n \n         try {\n             it.remove();  // second remove fails\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n         }\n         verify();\n     }\n         if (supportsSetValue() == false || supportsRemove() == false) {\n             return;\n         }\n-        V newValue = addSetValues()[0];\n-        MapIterator<K, V> it = makeObject();\n-        Map<K, V> confirmed = getConfirmedMap();\n-\n-        assertEquals(true, it.hasNext());\n-        K key = it.next();\n+        final V newValue = addSetValues()[0];\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n \n         it.setValue(newValue);\n         it.remove();\n         try {\n             it.setValue(newValue);\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         verify();\n     }\n \n         if (supportsRemove() == false) {\n             return;\n         }\n-        MapIterator<K, V> it = makeObject();\n-        Map<K, V> confirmed = getConfirmedMap();\n-\n-        assertEquals(true, it.hasNext());\n-        K key = it.next();\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n \n         it.remove();\n         confirmed.remove(key);\n         try {\n             it.getKey();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         verify();\n     }\n \n         if (supportsRemove() == false) {\n             return;\n         }\n-        MapIterator<K, V> it = makeObject();\n-        Map<K, V> confirmed = getConfirmedMap();\n-\n-        assertEquals(true, it.hasNext());\n-        K key = it.next();\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n \n         it.remove();\n         confirmed.remove(key);\n         try {\n             it.getValue();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n         verify();\n     }\n \n--- a/src/test/java/org/apache/commons/collections/iterators/AbstractOrderedMapIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractOrderedMapIteratorTest.java\n      *\n      * @param testName  the test class name\n      */\n-    public AbstractOrderedMapIteratorTest(String testName) {\n+    public AbstractOrderedMapIteratorTest(final String testName) {\n         super(testName);\n     }\n \n \n         super.testEmptyMapIterator();\n \n-        OrderedMapIterator<K, V> it = makeEmptyIterator();\n+        final OrderedMapIterator<K, V> it = makeEmptyIterator();\n         assertEquals(false, it.hasPrevious());\n         try {\n             it.previous();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n \n         super.testFullMapIterator();\n \n-        OrderedMapIterator<K, V> it = makeObject();\n-        Map<K, V> map = getMap();\n+        final OrderedMapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n \n         assertEquals(true, it.hasNext());\n         assertEquals(false, it.hasPrevious());\n-        Set<K> set = new HashSet<K>();\n+        final Set<K> set = new HashSet<K>();\n         while (it.hasNext()) {\n             // getKey\n-            K key = it.next();\n+            final K key = it.next();\n             assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n             assertTrue(\"Key must be in map\",  map.containsKey(key));\n             assertTrue(\"Key must be unique\", set.add(key));\n \n             // getValue\n-            V value = it.getValue();\n+            final V value = it.getValue();\n             if (isGetStructuralModify() == false) {\n                 assertSame(\"Value must be mapped to key\", map.get(key), value);\n             }\n         }\n         while (it.hasPrevious()) {\n             // getKey\n-            Object key = it.previous();\n+            final Object key = it.previous();\n             assertSame(\"it.previous() should equals getKey()\", key, it.getKey());\n             assertTrue(\"Key must be in map\",  map.containsKey(key));\n             assertTrue(\"Key must be unique\", set.remove(key));\n \n             // getValue\n-            Object value = it.getValue();\n+            final Object value = it.getValue();\n             if (isGetStructuralModify() == false) {\n                 assertSame(\"Value must be mapped to key\", map.get(key), value);\n             }\n             return;\n         }\n \n-        OrderedMapIterator<K, V> it = makeObject();\n-        Map<K, V> map = getMap();\n+        final OrderedMapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n \n         assertEquals(\"keySet() not consistent\", new ArrayList<K>(map.keySet()), new ArrayList<K>(map.keySet()));\n \n-        Iterator<K> it2 = map.keySet().iterator();\n+        final Iterator<K> it2 = map.keySet().iterator();\n         assertEquals(true, it.hasNext());\n         assertEquals(true, it2.hasNext());\n-        List<K> list = new ArrayList<K>();\n+        final List<K> list = new ArrayList<K>();\n         while (it.hasNext()) {\n-            K key = it.next();\n+            final K key = it.next();\n             assertEquals(it2.next(), key);\n             list.add(key);\n         }\n         assertEquals(map.size(), list.size());\n         while (it.hasPrevious()) {\n-            K key = it.previous();\n+            final K key = it.previous();\n             assertEquals(list.get(list.size() - 1), key);\n             list.remove(list.size() - 1);\n         }\n--- a/src/test/java/org/apache/commons/collections/iterators/ArrayIterator2Test.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ArrayIterator2Test.java\n \n     protected int[] testArray = { 2, 4, 6, 8 };\n \n-    public ArrayIterator2Test(String testName) {\n+    public ArrayIterator2Test(final String testName) {\n         super(testName);\n     }\n \n         return new ArrayIterator<E>(testArray);\n     }\n \n-    public ArrayIterator<E> makeArrayIterator(Object array) {\n+    public ArrayIterator<E> makeArrayIterator(final Object array) {\n         return new ArrayIterator<E>(array);\n     }\n \n-    public ArrayIterator<E> makeArrayIterator(Object array, int index) {\n+    public ArrayIterator<E> makeArrayIterator(final Object array, final int index) {\n         return new ArrayIterator<E>(array, index);\n     }\n \n-    public ArrayIterator<E> makeArrayIterator(Object array, int start, int end) {\n+    public ArrayIterator<E> makeArrayIterator(final Object array, final int start, final int end) {\n         return new ArrayIterator<E>(array, start, end);\n     }\n \n     }\n \n     public void testIterator() {\n-        Iterator<E> iter = makeObject();\n-        for (int element : testArray) {\n-            Integer testValue = new Integer(element);\n-            Number iterValue = (Number) iter.next();\n+        final Iterator<E> iter = makeObject();\n+        for (final int element : testArray) {\n+            final Integer testValue = new Integer(element);\n+            final Number iterValue = (Number) iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n                 e.getClass().equals(new NoSuchElementException().getClass()));\n     // proves that an ArrayIterator set with the constructor has the same number of elements\n     // as an ArrayIterator set with setArray(Object)\n     public void testSetArray() {\n-        Iterator<E> iter1 = makeArrayIterator(testArray);\n+        final Iterator<E> iter1 = makeArrayIterator(testArray);\n         int count1 = 0;\n         while (iter1.hasNext()) {\n             ++count1;\n \n         assertEquals(\"the count should be right using the constructor\", count1, testArray.length);\n \n-        ArrayIterator<E> iter2 = makeObject();\n+        final ArrayIterator<E> iter2 = makeObject();\n         iter2.setArray(testArray);\n         int count2 = 0;\n         while (iter2.hasNext()) {\n         try {\n             iter = makeArrayIterator(testArray, -1);\n             fail(\"new ArrayIterator(Object,-1) should throw an ArrayIndexOutOfBoundsException\");\n-        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n             // expected\n         }\n \n         try {\n             iter = makeArrayIterator(testArray, testArray.length + 1);\n             fail(\"new ArrayIterator(Object,length+1) should throw an ArrayIndexOutOfBoundsException\");\n-        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n             // expected\n         }\n \n         try {\n             iter = makeArrayIterator(testArray, 0, -1);\n             fail(\"new ArrayIterator(Object,0,-1) should throw an ArrayIndexOutOfBoundsException\");\n-        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n             // expected\n         }\n \n         try {\n             iter = makeArrayIterator(testArray, 0, testArray.length + 1);\n             fail(\"new ArrayIterator(Object,0,length+1) should throw an ArrayIndexOutOfBoundsException\");\n-        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n             // expected\n         }\n \n         try {\n             iter = makeArrayIterator(testArray, 1, 1);\n             // expected not to fail\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // MODIFIED: an iterator over a zero-length section of array\n             //  should be perfectly legal behavior\n             fail(\"new ArrayIterator(Object,1,1) should NOT throw an IllegalArgumentException\");\n         try {\n             iter = makeArrayIterator(testArray, testArray.length - 1, testArray.length - 2);\n             fail(\"new ArrayIterator(Object,length-2,length-1) should throw an IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/iterators/ArrayIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ArrayIteratorTest.java\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n \n-    public ArrayIteratorTest(String testName) {\n+    public ArrayIteratorTest(final String testName) {\n         super(testName);\n     }\n \n     }\n \n     public void testIterator() {\n-        Iterator<E> iter = makeObject();\n-        for (String testValue : testArray) {\n-            E iterValue = iter.next();\n+        final Iterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final E iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n                 e.getClass().equals(new NoSuchElementException().getClass()));\n         try {\n             new ArrayIterator<Object>(null);\n             fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n \n-        ArrayIterator<Object> iter = new ArrayIterator<Object>();\n+        final ArrayIterator<Object> iter = new ArrayIterator<Object>();\n         try {\n             iter.setArray(null);\n \n             fail(\"setArray(null) should throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n     }\n     \n     public void testReset() {\n-        ArrayIterator<E> it = makeObject();\n+        final ArrayIterator<E> it = makeObject();\n         it.next();\n         it.reset();\n         assertEquals(\"One\", it.next());\n--- a/src/test/java/org/apache/commons/collections/iterators/ArrayListIterator2Test.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ArrayListIterator2Test.java\n  */\n public class ArrayListIterator2Test<E> extends ArrayIterator2Test<E> {\n \n-    public ArrayListIterator2Test(String testName) {\n+    public ArrayListIterator2Test(final String testName) {\n         super(testName);\n     }\n \n         return new ArrayListIterator<E>(testArray);\n     }\n \n-    public ArrayListIterator<E> makeArrayListIterator(Object array) {\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array) {\n         return new ArrayListIterator<E>(array);\n     }\n \n-    public ArrayListIterator<E> makeArrayListIterator(Object array, int index) {\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array, final int index) {\n         return new ArrayListIterator<E>(array, index);\n     }\n \n-    public ArrayListIterator<E> makeArrayListIterator(Object array, int start, int end) {\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array, final int start, final int end) {\n         return new ArrayListIterator<E>(array, start, end);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/iterators/ArrayListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ArrayListIteratorTest.java\n  */\n public class ArrayListIteratorTest<E> extends ArrayIteratorTest<E> {\n \n-    public ArrayListIteratorTest(String testName) {\n+    public ArrayListIteratorTest(final String testName) {\n         super(testName);\n     }\n \n         return new ArrayListIterator<E>(testArray);\n     }\n \n-    public ArrayListIterator<E> makeArrayListIterator(Object array) {\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array) {\n         return new ArrayListIterator<E>(array);\n     }\n \n      * <code>previous()</code>.\n      */\n     public void testListIterator() {\n-        ListIterator<E> iter = makeObject();\n+        final ListIterator<E> iter = makeObject();\n \n         // TestArrayIterator#testIterator() has already tested the iterator forward,\n         //  now we need to test it in reverse\n         }\n \n         for (int x = testArray.length - 1; x >= 0; x--) {\n-            Object testValue = testArray[x];\n-            Object iterValue = iter.previous();\n+            final Object testValue = testArray[x];\n+            final Object iterValue = iter.previous();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n         try {\n             iter.previous();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n                 e.getClass().equals(new NoSuchElementException().getClass()));\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testListIteratorSet() {\n-        String[] testData = new String[] { \"a\", \"b\", \"c\" };\n+        final String[] testData = new String[] { \"a\", \"b\", \"c\" };\n \n-        String[] result = new String[] { \"0\", \"1\", \"2\" };\n+        final String[] result = new String[] { \"0\", \"1\", \"2\" };\n \n         ListIterator<E> iter = makeArrayListIterator(testData);\n         int x = 0;\n         try {\n             iter.set((E) \"should fail\");\n             fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // expected\n-        } catch (Throwable t) { // should never happen\n+        } catch (final Throwable t) { // should never happen\n             fail(t.toString());\n         }\n \n--- a/src/test/java/org/apache/commons/collections/iterators/CollatingIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/CollatingIteratorTest.java\n \n     //------------------------------------------------------------ Conventional\n \n-    public CollatingIteratorTest(String testName) {\n+    public CollatingIteratorTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public CollatingIterator<Integer> makeObject() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         iter.addIterator(odds.iterator());\n         iter.addIterator(fib.iterator());\n     //------------------------------------------------------------------- Tests\n \n     public void testGetSetComparator() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>();\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>();\n         assertNull(iter.getComparator());\n         iter.setComparator(comparator);\n         assertSame(comparator, iter.getComparator());\n     }\n \n     public void testIterateEven() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         for (int i = 0; i < evens.size(); i++) {\n             assertTrue(iter.hasNext());\n     }\n \n     public void testIterateEvenOdd() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, evens.iterator(), odds.iterator());\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, evens.iterator(), odds.iterator());\n         for (int i = 0; i < 20; i++) {\n             assertTrue(iter.hasNext());\n             assertEquals(new Integer(i), iter.next());\n     }\n \n     public void testIterateOddEven() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, odds.iterator(), evens.iterator());\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, odds.iterator(), evens.iterator());\n         for (int i = 0; i < 20; i++) {\n             assertTrue(iter.hasNext());\n             assertEquals(new Integer(i),iter.next());\n     }\n \n     public void testIterateEvenEven() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         iter.addIterator(evens.iterator());\n         for (int i = 0; i < evens.size(); i++) {\n     }\n \n     public void testIterateFibEvenOdd() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(fib.iterator());\n         iter.addIterator(evens.iterator());\n         iter.addIterator(odds.iterator());\n     }\n \n     public void testRemoveFromSingle() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         int expectedSize = evens.size();\n         while (iter.hasNext()) {\n-            Object o = iter.next();\n-            Integer val = (Integer) o;\n+            final Object o = iter.next();\n+            final Integer val = (Integer) o;\n             if (val.intValue() % 4 == 0) {\n                 expectedSize--;\n                 iter.remove();\n     }\n \n     public void testRemoveFromDouble() {\n-        CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n         iter.addIterator(evens.iterator());\n         iter.addIterator(odds.iterator());\n         int expectedSize = evens.size() + odds.size();\n         while (iter.hasNext()) {\n-            Object o = iter.next();\n-            Integer val = (Integer) o;\n+            final Object o = iter.next();\n+            final Integer val = (Integer) o;\n             if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {\n                 expectedSize--;\n                 iter.remove();\n     }\n \n     public void testNullComparator() {\n-       List<Integer> l1 = Arrays.asList(1, 3, 5);\n-       List<Integer> l2 = Arrays.asList(2, 4, 6);\n-\n-       CollatingIterator<Integer> collatingIterator1 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n+       final List<Integer> l1 = Arrays.asList(1, 3, 5);\n+       final List<Integer> l2 = Arrays.asList(2, 4, 6);\n+\n+       final CollatingIterator<Integer> collatingIterator1 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n        try {\n            collatingIterator1.next();\n-       } catch (NullPointerException e) {\n+       } catch (final NullPointerException e) {\n            assertTrue(e.getMessage().startsWith(\"You must invoke setComparator\"));\n        }\n \n        int i = 0;\n-       CollatingIterator<Integer> collatingIterator2 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n+       final CollatingIterator<Integer> collatingIterator2 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n        collatingIterator2.setComparator(new ComparableComparator<Integer>());\n        for ( ; collatingIterator2.hasNext(); i++ ) {\n-          Integer n = collatingIterator2.next();\n+          final Integer n = collatingIterator2.next();\n           assertEquals(\"wrong order\", (int)n, i + 1);\n        }\n        assertEquals(\"wrong size\", i, l1.size() + l2.size());\n--- a/src/test/java/org/apache/commons/collections/iterators/FilterIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/FilterIteratorTest.java\n public class FilterIteratorTest<E> extends AbstractIteratorTest<E> {\n \n     /** Creates new TestFilterIterator */\n-    public FilterIteratorTest(String name) {\n+    public FilterIteratorTest(final String name) {\n         super(name);\n     }\n \n     }\n \n     public void testRepeatedNext() {\n-        for (String element : array) {\n+        for (final String element : array) {\n             iterator.next();\n         }\n         verifyNoMoreElements();\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testSetIterator() {\n-        Iterator<E> iter1 = Collections.singleton((E) new Object()).iterator();\n-        Iterator<E> iter2 = Collections.<E>emptyList().iterator();\n-\n-        FilterIterator<E> filterIterator = new FilterIterator<E>(iter1);\n+        final Iterator<E> iter1 = Collections.singleton((E) new Object()).iterator();\n+        final Iterator<E> iter2 = Collections.<E>emptyList().iterator();\n+\n+        final FilterIterator<E> filterIterator = new FilterIterator<E>(iter1);\n         filterIterator.setPredicate(truePredicate());\n         // this iterator has elements\n         assertEquals(true, filterIterator.hasNext());\n      * correct response for the new predicate.\n      */\n     public void testSetPredicate() {\n-        Iterator<E> iter = Collections.singleton((E) null).iterator();\n-\n-        FilterIterator<E> filterIterator = new FilterIterator<E>(iter);\n+        final Iterator<E> iter = Collections.singleton((E) null).iterator();\n+\n+        final FilterIterator<E> filterIterator = new FilterIterator<E>(iter);\n         filterIterator.setPredicate(truePredicate());\n         // this predicate matches\n         assertEquals(true, filterIterator.hasNext());\n             iterator.next();\n             fail(\"NoSuchElementException expected\");\n         }\n-        catch (NoSuchElementException e) {\n+        catch (final NoSuchElementException e) {\n             // success\n         }\n     }\n \n     private void verifyElementsInPredicate(final String[] elements) {\n-        Predicate<E> pred = new Predicate<E>() {\n-            public boolean evaluate(E x) {\n-                for (String element : elements) {\n+        final Predicate<E> pred = new Predicate<E>() {\n+            public boolean evaluate(final E x) {\n+                for (final String element : elements) {\n                     if (element.equals(x)) {\n                         return true;\n                     }\n         initIterator();\n         iterator.setPredicate(pred);\n         for (int i = 0; i < elements.length; i++) {\n-            String s = (String)iterator.next();\n+            final String s = (String)iterator.next();\n             assertEquals(elements[i], s);\n             assertTrue(i == elements.length - 1 ? !iterator.hasNext() : iterator.hasNext());\n         }\n         initIterator();\n         iterator.setPredicate(pred);\n         if (iterator.hasNext()) {\n-            Object last = iterator.next();\n+            final Object last = iterator.next();\n             iterator.remove();\n             assertTrue(\"Base of FilterIterator still contains removed element.\", !list.contains(last));\n         }\n      * @param i      the Iterator to \"filter\"\n      * @return \"filtered\" iterator\n      */\n-    protected FilterIterator<E> makePassThroughFilter(Iterator<E> i) {\n-        Predicate<E> pred = new Predicate<E>() {\n-                public boolean evaluate(E x) { return true; }\n+    protected FilterIterator<E> makePassThroughFilter(final Iterator<E> i) {\n+        final Predicate<E> pred = new Predicate<E>() {\n+                public boolean evaluate(final E x) { return true; }\n         };\n         return new FilterIterator<E>(i, pred);\n     }\n      * @param i      the Iterator to \"filter\"\n      * @return \"filtered\" iterator\n      */\n-    protected FilterIterator<E> makeBlockAllFilter(Iterator<E> i) {\n-        Predicate<E> pred = new Predicate<E>() {\n-                public boolean evaluate(E x) { return false; }\n+    protected FilterIterator<E> makeBlockAllFilter(final Iterator<E> i) {\n+        final Predicate<E> pred = new Predicate<E>() {\n+                public boolean evaluate(final E x) { return false; }\n         };\n         return new FilterIterator<E>(i, pred);\n     }\n--- a/src/test/java/org/apache/commons/collections/iterators/FilterListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/FilterListIteratorTest.java\n  */\n @SuppressWarnings(\"boxing\")\n public class FilterListIteratorTest extends TestCase {\n-    public FilterListIteratorTest(String testName) {\n+    public FilterListIteratorTest(final String testName) {\n         super(testName);\n     }\n \n     private Predicate<Integer> oddPred = null;\n     private Predicate<Integer> threePred = null;\n     private Predicate<Integer> fourPred = null;\n-    private Random random = new Random();\n+    private final Random random = new Random();\n \n     @Override\n     public void setUp() {\n         }\n \n         truePred = new Predicate<Integer>() {\n-            public boolean evaluate(Integer x) { \n+            public boolean evaluate(final Integer x) { \n                 return true;\n             }\n         };\n \n         falsePred = new Predicate<Integer>() {\n-            public boolean evaluate(Integer x) { \n+            public boolean evaluate(final Integer x) { \n                 return true;\n             }\n         };\n \n         evenPred = new Predicate<Integer>() {\n-            public boolean evaluate(Integer x) { \n+            public boolean evaluate(final Integer x) { \n                 return x % 2 == 0;\n             }\n         };\n \n         oddPred = new Predicate<Integer>() {\n-            public boolean evaluate(Integer x) { \n+            public boolean evaluate(final Integer x) { \n                 return x % 2 == 1;\n             }\n         };\n \n         threePred = new Predicate<Integer>() {\n-            public boolean evaluate(Integer x) { \n+            public boolean evaluate(final Integer x) { \n                 return x % 3 == 0;\n             }\n         };\n \n         fourPred = new Predicate<Integer>() {\n-            public boolean evaluate(Integer x) { \n+            public boolean evaluate(final Integer x) { \n                 return x % 4 == 0;\n             }\n         };\n \n     public void testManual() {\n         // do this one \"by hand\" as a sanity check\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n         \n         assertEquals(new Integer(0), filtered.next());\n         assertEquals(new Integer(3), filtered.next());\n     }\n \n     public void testTruePredicate() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n         walkLists(list, filtered);\n     }\n     \n     public void testFalsePredicate() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), falsePred);\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), falsePred);\n         walkLists(new ArrayList<Integer>(), filtered);\n     }\n \n     public void testEvens() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), evenPred);\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), evenPred);\n         walkLists(evens, filtered);\n     }\n     \n     public void testOdds() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), oddPred);\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), oddPred);\n         walkLists(odds, filtered);\n     }\n \n     public void testThrees() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n         walkLists(threes, filtered);\n     }\n \n     public void testFours() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n         walkLists(fours, filtered);\n     }\n \n     public void testNestedSixes() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n                                         new FilterListIterator<Integer>(list.listIterator(), threePred),\n                                         evenPred\n                                       );\n     }\n \n     public void testNestedSixes2() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n                                         new FilterListIterator<Integer>(list.listIterator(), evenPred),\n                                         threePred\n                                       );\n     }\n \n     public void testNestedSixes3() {        \n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n                                         new FilterListIterator<Integer>(list.listIterator(), threePred),\n                                         evenPred\n                                       );\n \n     public void testNextChangesPrevious() {\n         {\n-            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n             nextNextPrevious(threes.listIterator(), filtered);\n         }\n     \n         {\n-            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n             nextNextPrevious(list.listIterator(), filtered);\n         }\n     }\n \n     public void testPreviousChangesNext() {\n         {\n-            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n-            ListIterator<Integer> expected = threes.listIterator();\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            final ListIterator<Integer> expected = threes.listIterator();\n             walkForward(expected,filtered);\n             previousPreviousNext(expected,filtered);\n         }\n         {\n-            FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n-            ListIterator<Integer> expected = list.listIterator();\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            final ListIterator<Integer> expected = list.listIterator();\n             walkForward(expected, filtered);\n             previousPreviousNext(expected, filtered);\n         }\n     }\n \n     public void testFailingHasNextBug() {\n-        FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n-        ListIterator<Integer> expected = fours.listIterator();\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        final ListIterator<Integer> expected = fours.listIterator();\n         while (expected.hasNext()) {\n             expected.next();\n             filtered.next();\n      * Test for {@link \"https://issues.apache.org/jira/browse/COLLECTIONS-360 COLLECTIONS-360\"}\n      */\n     public void testCollections360() throws Throwable {\n-        Collection<Predicate<Object>> var7 = new GrowthList<Predicate<Object>>();\n-        Predicate<Object> var9 = PredicateUtils.anyPredicate(var7);\n-        FilterListIterator<Object> var13 = new FilterListIterator<Object>(var9);\n+        final Collection<Predicate<Object>> var7 = new GrowthList<Predicate<Object>>();\n+        final Predicate<Object> var9 = PredicateUtils.anyPredicate(var7);\n+        final FilterListIterator<Object> var13 = new FilterListIterator<Object>(var9);\n         Assert.assertFalse(var13.hasNext());\n-        FilterListIterator<Object> var14 = new FilterListIterator<Object>(var9);\n+        final FilterListIterator<Object> var14 = new FilterListIterator<Object>(var9);\n         Assert.assertFalse(var14.hasPrevious());\n     }\n \n     // Utilities\n \n-    private void walkForward(ListIterator<?> expected, ListIterator<?> testing) {\n+    private void walkForward(final ListIterator<?> expected, final ListIterator<?> testing) {\n         while (expected.hasNext()) {\n             assertEquals(expected.nextIndex(), testing.nextIndex());\n             assertEquals(expected.previousIndex(), testing.previousIndex());\n         }\n     }\n \n-    private void walkBackward(ListIterator<?> expected, ListIterator<?> testing) {\n+    private void walkBackward(final ListIterator<?> expected, final ListIterator<?> testing) {\n         while (expected.hasPrevious()) {\n             assertEquals(expected.nextIndex(), testing.nextIndex());\n             assertEquals(expected.previousIndex(), testing.previousIndex());\n         }\n     }\n \n-    private void nextNextPrevious(ListIterator<?> expected, ListIterator<?> testing) {\n+    private void nextNextPrevious(final ListIterator<?> expected, final ListIterator<?> testing) {\n         // calls to next() should change the value returned by previous()\n         // even after previous() has been set by a call to hasPrevious()\n         assertEquals(expected.next(), testing.next());\n         assertEquals(expected.hasPrevious(), testing.hasPrevious());\n-        Object expecteda = expected.next();\n-        Object testinga = testing.next();\n+        final Object expecteda = expected.next();\n+        final Object testinga = testing.next();\n         assertEquals(expecteda, testinga);\n-        Object expectedb = expected.previous();\n-        Object testingb = testing.previous();\n+        final Object expectedb = expected.previous();\n+        final Object testingb = testing.previous();\n         assertEquals(expecteda, expectedb);\n         assertEquals(testinga, testingb);\n     }\n \n-    private void previousPreviousNext(ListIterator<?> expected, ListIterator<?> testing) {\n+    private void previousPreviousNext(final ListIterator<?> expected, final ListIterator<?> testing) {\n         // calls to previous() should change the value returned by next()\n         // even after next() has been set by a call to hasNext()\n         assertEquals(expected.previous(), testing.previous());\n         assertEquals(expected.hasNext(), testing.hasNext());\n-        Object expecteda = expected.previous();\n-        Object testinga = testing.previous();\n+        final Object expecteda = expected.previous();\n+        final Object testinga = testing.previous();\n         assertEquals(expecteda, testinga);\n-        Object expectedb = expected.next();\n-        Object testingb = testing.next();\n+        final Object expectedb = expected.next();\n+        final Object testingb = testing.next();\n         assertEquals(expecteda, testingb);\n         assertEquals(expecteda, expectedb);\n         assertEquals(testinga, testingb);\n     }\n \n-    private <E> void walkLists(List<E> list, ListIterator<E> testing) {\n-        ListIterator<E> expected = list.listIterator();\n+    private <E> void walkLists(final List<E> list, final ListIterator<E> testing) {\n+        final ListIterator<E> expected = list.listIterator();\n \n         // walk all the way forward\n         walkForward(expected,testing);\n         }\n \n         // random walk\n-        StringBuilder walkdescr = new StringBuilder(500);\n+        final StringBuilder walkdescr = new StringBuilder(500);\n         for (int i = 0; i < 500; i++) {\n             if (random.nextBoolean()) {\n                 // step forward\n--- a/src/test/java/org/apache/commons/collections/iterators/IteratorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/IteratorChainTest.java\n     protected List<String> list2 = null;\n     protected List<String> list3 = null;\n \n-    public IteratorChainTest(String testName) {\n+    public IteratorChainTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public IteratorChain<String> makeEmptyIterator() {\n-        ArrayList<String> list = new ArrayList<String>();\n+        final ArrayList<String> list = new ArrayList<String>();\n         return new IteratorChain<String>(list.iterator());\n     }\n \n     @Override\n     public IteratorChain<String> makeObject() {\n-        IteratorChain<String> chain = new IteratorChain<String>();\n+        final IteratorChain<String> chain = new IteratorChain<String>();\n \n         chain.addIterator(list1.iterator());\n         chain.addIterator(list2.iterator());\n     }\n \n     public void testIterator() {\n-        Iterator<String> iter = makeObject();\n-        for (String testValue : testArray) {\n-            Object iterValue = iter.next();\n+        final Iterator<String> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n \n             assertEquals( \"Iteration value is correct\", testValue, iterValue );\n         }\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\", \n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n     public void testRemoveFromFilteredIterator() {\n \n         final Predicate<Integer> myPredicate = new Predicate<Integer>() {\n-            public boolean evaluate(Integer i) {\n+            public boolean evaluate(final Integer i) {\n                 return i.compareTo(new Integer(4)) < 0;\n             }\n         };\n \n-        List<Integer> list1 = new ArrayList<Integer>();\n-        List<Integer> list2 = new ArrayList<Integer>();\n+        final List<Integer> list1 = new ArrayList<Integer>();\n+        final List<Integer> list2 = new ArrayList<Integer>();\n \n         list1.add(new Integer(1));\n         list1.add(new Integer(2));\n         list2.add(new Integer(3));\n         list2.add(new Integer(4)); // will be ignored by the predicate\n \n-        Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n-        Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n+        final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n+        final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n \n-        Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n+        final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n         while (it.hasNext()) {\n             it.next();\n             it.remove();\n     \n     @Override\n     public void testRemove() {\n-        Iterator<String> iter = makeObject();\n+        final Iterator<String> iter = makeObject();\n \n         try {\n             iter.remove();\n             fail(\"Calling remove before the first call to next() should throw an exception\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n \n         }\n \n-        for (String testValue : testArray) {\n-            String iterValue = iter.next();\n+        for (final String testValue : testArray) {\n+            final String iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n \n     }\n \n     public void testFirstIteratorIsEmptyBug() {\n-        List<String> empty = new ArrayList<String>();\n-        List<String> notEmpty = new ArrayList<String>();\n+        final List<String> empty = new ArrayList<String>();\n+        final List<String> notEmpty = new ArrayList<String>();\n         notEmpty.add(\"A\");\n         notEmpty.add(\"B\");\n         notEmpty.add(\"C\");\n-        IteratorChain<String> chain = new IteratorChain<String>();\n+        final IteratorChain<String> chain = new IteratorChain<String>();\n         chain.addIterator(empty.iterator());\n         chain.addIterator(notEmpty.iterator());\n         assertTrue(\"should have next\",chain.hasNext());\n     }\n     \n     public void testEmptyChain() {\n-        IteratorChain<Object> chain = new IteratorChain<Object>();\n+        final IteratorChain<Object> chain = new IteratorChain<Object>();\n         assertEquals(false, chain.hasNext());\n         try {\n             chain.next();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n         try {\n             chain.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n         \n }\n--- a/src/test/java/org/apache/commons/collections/iterators/IteratorIterableTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/IteratorIterableTest.java\n         return BulkTest.makeSuite(IteratorIterableTest.class);\n     }\n \n-    public IteratorIterableTest(String name) {\n+    public IteratorIterableTest(final String name) {\n         super(name);\n     }\n \n     private Iterator<Integer> createIterator() {\n-        List<Integer> list = new ArrayList<Integer>();\n+        final List<Integer> list = new ArrayList<Integer>();\n         list.add(Integer.valueOf(0));\n         list.add(Integer.valueOf(1));\n         list.add(Integer.valueOf(2));\n-        Iterator<Integer> iter = list.iterator();\n+        final Iterator<Integer> iter = list.iterator();\n         return iter;\n     }\n \n     public void testIterator() {\n-        Iterator<Integer> iter = createIterator();\n-        Iterable<Number> iterable = new IteratorIterable<Number>(iter);\n+        final Iterator<Integer> iter = createIterator();\n+        final Iterable<Number> iterable = new IteratorIterable<Number>(iter);\n         \n         // first use\n         verifyIteration(iterable);\n         \n         // second use\n-        for (@SuppressWarnings(\"unused\") Number actual : iterable) {\n+        for (@SuppressWarnings(\"unused\") final Number actual : iterable) {\n             fail(\"should not be able to iterate twice\");\n         }\n     }\n \n     public void testMultipleUserIterator() {\n-        Iterator<Integer> iter = createIterator();\n+        final Iterator<Integer> iter = createIterator();\n \n-        Iterable<Number> iterable = new IteratorIterable<Number>(iter, true);\n+        final Iterable<Number> iterable = new IteratorIterable<Number>(iter, true);\n         \n         // first use\n         verifyIteration(iterable);\n         verifyIteration(iterable);\n     }\n \n-    private void verifyIteration(Iterable<Number> iterable) {\n+    private void verifyIteration(final Iterable<Number> iterable) {\n         int expected = 0;\n-        for (Number actual : iterable) {\n+        for (final Number actual : iterable) {\n             assertEquals(expected, actual.intValue());\n             ++expected;\n         }\n--- a/src/test/java/org/apache/commons/collections/iterators/ListIteratorWrapper2Test.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ListIteratorWrapper2Test.java\n \n     protected List<E> list1 = null;\n \n-    public ListIteratorWrapper2Test(String testName) {\n+    public ListIteratorWrapper2Test(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public ResettableListIterator<E> makeEmptyIterator() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         return new ListIteratorWrapper<E>(list.listIterator());\n     }\n \n     }\n \n     public void testIterator() {\n-        ListIterator<E> iter = makeObject();\n-        for (String testValue : testArray) {\n-            Object iterValue = iter.next();\n+        final ListIterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\",\n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n \n         // now, read it backwards\n         for (int i = testArray.length - 1; i > -1; --i) {\n-            Object testValue = testArray[i];\n-            E iterValue = iter.previous();\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.previous();\n \n             assertEquals( \"Iteration value is correct\", testValue, iterValue );\n         }\n \n         try {\n             iter.previous();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\",\n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n \n         // now, read it forwards again\n-        for (String testValue : testArray) {\n-            Object iterValue = iter.next();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n     @Override\n     public void testRemove() {\n-        ListIterator<E> iter = makeObject();\n+        final ListIterator<E> iter = makeObject();\n \n         //initial state:\n         assertEquals(-1, iter.previousIndex());\n         try {\n             iter.remove();\n             fail(\"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n         }\n \n         //no change from invalid op:\n         try {\n             iter.remove();\n             fail(\"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n         }\n \n         //no change from invalid op:\n     }\n \n     public void testReset() {\n-        ResettableListIterator<E> iter = makeObject();\n-        E first = iter.next();\n-        E second = iter.next();\n+        final ResettableListIterator<E> iter = makeObject();\n+        final E first = iter.next();\n+        final E second = iter.next();\n \n         iter.reset();\n \n \n         // after passing the point, where we resetted, continuation should work as expected\n         for (int i = 2; i < testArray.length; i++) {\n-            Object testValue = testArray[i];\n-            E iterValue = iter.next();\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n--- a/src/test/java/org/apache/commons/collections/iterators/ListIteratorWrapperTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ListIteratorWrapperTest.java\n \n     protected List<E> list1 = null;\n \n-    public ListIteratorWrapperTest(String testName) {\n+    public ListIteratorWrapperTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public ResettableListIterator<E> makeEmptyIterator() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         return new ListIteratorWrapper<E>(list.iterator());\n     }\n \n     }\n \n     public void testIterator() {\n-        ListIterator<E> iter = makeObject();\n-        for (String testValue : testArray) {\n-            Object iterValue = iter.next();\n+        final ListIterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\",\n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n \n         // now, read it backwards\n         for (int i = testArray.length - 1; i > -1; --i) {\n-            Object testValue = testArray[i];\n-            E iterValue = iter.previous();\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.previous();\n \n             assertEquals( \"Iteration value is correct\", testValue, iterValue );\n         }\n \n         try {\n             iter.previous();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\",\n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n \n         // now, read it forwards again\n-        for (String testValue : testArray) {\n-            Object iterValue = iter.next();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n     @Override\n     public void testRemove() {\n-        ListIterator<E> iter = makeObject();\n+        final ListIterator<E> iter = makeObject();\n \n         //initial state:\n         assertEquals(-1, iter.previousIndex());\n         try {\n             iter.remove();\n             fail(\"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n         }\n \n         //no change from invalid op:\n         try {\n             iter.remove();\n             fail(\"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n         }\n \n         //no change from invalid op:\n         try {\n             iter.remove();\n             fail(\"ListIteratorWrapper does not support the remove() method while dug into the cache via previous()\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n         }\n \n         //no change from invalid op:\n     }\n \n     public void testReset() {\n-        ResettableListIterator<E> iter = makeObject();\n-        E first = iter.next();\n-        E second = iter.next();\n+        final ResettableListIterator<E> iter = makeObject();\n+        final E first = iter.next();\n+        final E second = iter.next();\n \n         iter.reset();\n \n \n         // after passing the point, where we resetted, continuation should work as expected\n         for (int i = 2; i < testArray.length; i++) {\n-            Object testValue = testArray[i];\n-            E iterValue = iter.next();\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n--- a/src/test/java/org/apache/commons/collections/iterators/LoopingIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/LoopingIteratorTest.java\n  */\n public class LoopingIteratorTest extends TestCase {\n \n-    public LoopingIteratorTest(String testName) {\n+    public LoopingIteratorTest(final String testName) {\n         super(testName);\n     }\n \n         try {\n             new LoopingIterator<Object>(null);\n             fail();\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n     }\n     \n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping0() throws Exception {\n-        List<Object> list = new ArrayList<Object>();\n-        LoopingIterator<Object> loop = new LoopingIterator<Object>(list);\n+        final List<Object> list = new ArrayList<Object>();\n+        final LoopingIterator<Object> loop = new LoopingIterator<Object>(list);\n         assertTrue(\"hasNext should return false\", loop.hasNext() == false);\n \n         try {\n             loop.next();\n             fail(\"NoSuchElementException was not thrown during next() call.\");\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping1() throws Exception {\n-        List<String> list = Arrays.asList(new String[] { \"a\" });\n-        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        final List<String> list = Arrays.asList(new String[] { \"a\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n         assertEquals(\"a\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping2() throws Exception {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n-        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n         assertEquals(\"a\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testLooping3() throws Exception {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n-        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n         assertEquals(\"a\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testRemoving1() throws Exception {\n-        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n         assertEquals(\"list should have 3 elements.\", 3, list.size());\n \n         assertTrue(\"1st hasNext should return true\", loop.hasNext());\n         try {\n             loop.next();\n             fail(\"Expected NoSuchElementException to be thrown.\");\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testReset() throws Exception {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n-        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertEquals(\"a\", loop.next());\n         assertEquals(\"b\", loop.next());\n      * @throws Exception  If something unexpected occurs.\n      */\n     public void testSize() throws Exception {\n-        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n \n         assertEquals(3, loop.size());\n         loop.next();\n--- a/src/test/java/org/apache/commons/collections/iterators/LoopingListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/LoopingListIteratorTest.java\n  */\n public class LoopingListIteratorTest extends TestCase {\n \n-    public LoopingListIteratorTest(String testName) {\n+    public LoopingListIteratorTest(final String testName) {\n         super(testName);\n     }\n     \n         try {\n             new LoopingListIterator<Object>(null);\n             fail();\n-        } catch (NullPointerException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n     }\n \n      * Tests whether an empty looping list iterator works.\n      */\n     public void testLooping0() throws Exception {\n-        List<Object> list = new ArrayList<Object>();\n-        LoopingListIterator<Object> loop = new LoopingListIterator<Object>(list);\n+        final List<Object> list = new ArrayList<Object>();\n+        final LoopingListIterator<Object> loop = new LoopingListIterator<Object>(list);\n         assertFalse(loop.hasNext());\n         assertFalse(loop.hasPrevious());\n         \n         try {\n             loop.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n \n         try {\n             loop.previous();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n      * one element.\n      */\n     public void testLooping1() throws Exception {\n-        List<String> list = Arrays.asList(new String[] { \"a\" });\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a>\n+        final List<String> list = Arrays.asList(new String[] { \"a\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a>\n \n         assertTrue(loop.hasNext());\n         assertEquals(\"a\", loop.next());     // <a>\n      * elements.\n      */\n     public void testLooping2() throws Exception {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n \n         assertTrue(loop.hasNext());\n         assertEquals(\"a\", loop.next());     // a <b>\n      * the begin/end boundary of the list.\n      */\n     public void testJoggingNotOverBoundary() {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n     \n         // Try jogging back and forth between the elements, but not\n         // over the begin/end boundary.\n      * begin/end boundary of the list.\n      */\n     public void testJoggingOverBoundary() {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n     \n         // Try jogging back and forth between the elements, but not\n         // over the begin/end boundary.\n      * Tests removing an element from a wrapped ArrayList.\n      */\n     public void testRemovingElementsAndIteratingForward() {\n-        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertTrue(loop.hasNext());\n         assertEquals(\"a\", loop.next()); // a <b> c\n         try {\n             loop.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n      * Tests removing an element from a wrapped ArrayList.\n      */\n     public void testRemovingElementsAndIteratingBackwards() {\n-        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertTrue(loop.hasPrevious());\n         assertEquals(\"c\", loop.previous()); // a b <c>\n         try {\n             loop.previous();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n      * Tests the reset method.\n      */\n     public void testReset() {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertEquals(\"a\", loop.next()); // a <b> c\n         assertEquals(\"b\", loop.next()); // a b <c>\n      * Tests nextIndex and previousIndex.\n      */\n     public void testNextAndPreviousIndex() {\n-        List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n \n         assertEquals(0, loop.nextIndex());\n         assertEquals(2, loop.previousIndex());\n      * Tests using the set method to change elements.\n      */\n     public void testSet() {\n-        List<String> list = Arrays.asList(new String[] { \"q\", \"r\", \"z\" });\n-        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <q> r z\n+        final List<String> list = Arrays.asList(new String[] { \"q\", \"r\", \"z\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <q> r z\n \n         assertEquals(\"z\", loop.previous()); // q r <z>\n         loop.set(\"c\");                      // q r <c>\n--- a/src/test/java/org/apache/commons/collections/iterators/ObjectArrayIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ObjectArrayIteratorTest.java\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n \n-    public ObjectArrayIteratorTest(String testName) {\n+    public ObjectArrayIteratorTest(final String testName) {\n         super(testName);\n     }\n \n         return new ObjectArrayIterator<E>();\n     }\n \n-    public ObjectArrayIterator<E> makeArrayIterator(E[] array) {\n+    public ObjectArrayIterator<E> makeArrayIterator(final E[] array) {\n         return new ObjectArrayIterator<E>(array);\n     }\n \n-    public ObjectArrayIterator<E> makeArrayIterator(E[] array, int index) {\n+    public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int index) {\n         return new ObjectArrayIterator<E>(array, index);\n     }\n \n-    public ObjectArrayIterator<E> makeArrayIterator(E[] array, int start, int end) {\n+    public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int start, final int end) {\n         return new ObjectArrayIterator<E>(array, start, end);\n     }\n \n     }\n \n     public void testIterator() {\n-        Iterator<E> iter = makeObject();\n-        for (String testValue : testArray) {\n-            E iterValue = iter.next();\n+        final Iterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final E iterValue = iter.next();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n                 e.getClass().equals(new NoSuchElementException().getClass()));\n             makeArrayIterator(null);\n \n             fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n \n-        ObjectArrayIterator<E> iter = makeArrayIterator();\n+        final ObjectArrayIterator<E> iter = makeArrayIterator();\n         try {\n             iter.setArray(null);\n \n             fail(\"setArray(null) should throw a NullPointerException\");\n-        } catch (NullPointerException e) {\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testDoubleSet() {\n-        ObjectArrayIterator<E> it = makeArrayIterator();\n+        final ObjectArrayIterator<E> it = makeArrayIterator();\n         it.setArray((E[]) new String[0]);\n         try {\n             it.setArray((E[]) new String[0]);\n             fail();\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testReset() {\n-        ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);\n+        final ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);\n         it.next();\n         it.reset();\n         assertEquals(\"One\", it.next());\n--- a/src/test/java/org/apache/commons/collections/iterators/ObjectArrayListIterator2Test.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ObjectArrayListIterator2Test.java\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n \n-    public ObjectArrayListIterator2Test(String testName) {\n+    public ObjectArrayListIterator2Test(final String testName) {\n         super(testName);\n     }\n \n         return new ObjectArrayListIterator<E>((E[]) testArray);\n     }\n \n-    public ObjectArrayListIterator<E> makeArrayListIterator(E[] array) {\n+    public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {\n         return new ObjectArrayListIterator<E>(array);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/iterators/ObjectArrayListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ObjectArrayListIteratorTest.java\n  */\n public class ObjectArrayListIteratorTest<E> extends ObjectArrayIteratorTest<E> {\n \n-    public ObjectArrayListIteratorTest(String testName) {\n+    public ObjectArrayListIteratorTest(final String testName) {\n         super(testName);\n     }\n \n         return new ObjectArrayListIterator<E>((E[]) testArray);\n     }\n \n-    public ObjectArrayListIterator<E> makeArrayListIterator(E[] array) {\n+    public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {\n         return new ObjectArrayListIterator<E>(array);\n     }\n \n      * <code>previous()</code>.\n      */\n     public void testListIterator() {\n-        ListIterator<E> iter = makeObject();\n+        final ListIterator<E> iter = makeObject();\n \n         // TestArrayIterator#testIterator() has already tested the iterator forward,\n         //  now we need to test it in reverse\n         }\n \n         for (int x = testArray.length - 1; x >= 0; x--) {\n-            Object testValue = testArray[x];\n-            Object iterValue = iter.previous();\n+            final Object testValue = testArray[x];\n+            final Object iterValue = iter.previous();\n \n             assertEquals(\"Iteration value is correct\", testValue, iterValue);\n         }\n \n         try {\n             iter.previous();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n                 e.getClass().equals(new NoSuchElementException().getClass()));\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testListIteratorSet() {\n-        String[] testData = new String[] { \"a\", \"b\", \"c\" };\n+        final String[] testData = new String[] { \"a\", \"b\", \"c\" };\n \n-        String[] result = new String[] { \"0\", \"1\", \"2\" };\n+        final String[] result = new String[] { \"0\", \"1\", \"2\" };\n \n         ListIterator<E> iter = makeArrayListIterator((E[]) testData);\n         int x = 0;\n         try {\n             iter.set((E) \"should fail\");\n             fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // expected\n-        } catch (Throwable t) { // should never happen\n+        } catch (final Throwable t) { // should never happen\n             fail(t.toString());\n         }\n \n--- a/src/test/java/org/apache/commons/collections/iterators/ObjectGraphIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ObjectGraphIteratorTest.java\n     protected List<String> list3 = null;\n     protected List<Iterator<String>> iteratorList = null;\n \n-    public ObjectGraphIteratorTest(String testName) {\n+    public ObjectGraphIteratorTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public ObjectGraphIterator<Object> makeEmptyIterator() {\n-        ArrayList<Object> list = new ArrayList<Object>();\n+        final ArrayList<Object> list = new ArrayList<Object>();\n         return new ObjectGraphIterator<Object>(list.iterator());\n     }\n \n \n     //-----------------------------------------------------------------------\n     public void testIteratorConstructor_null1() {\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n-\n-        assertEquals(false, it.hasNext());\n-        try {\n-            it.next();\n-            fail();\n-        } catch (NoSuchElementException ex) {\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n         }\n         try {\n             it.remove();\n             fail();\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n         }\n     }\n \n     public void testIteratorConstructor_null_next() {\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n-        try {\n-            it.next();\n-            fail();\n-        } catch (NoSuchElementException ex) {\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     public void testIteratorConstructor_null_remove() {\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n         try {\n             it.remove();\n             fail();\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n         }\n     }\n \n     //-----------------------------------------------------------------------\n     public void testIteratorConstructorIteration_Empty() {\n-        List<Iterator<Object>> iteratorList = new ArrayList<Iterator<Object>>();\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n-\n-        assertEquals(false, it.hasNext());\n-        try {\n-            it.next();\n-            fail();\n-        } catch (NoSuchElementException ex) {\n+        final List<Iterator<Object>> iteratorList = new ArrayList<Iterator<Object>>();\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n         }\n         try {\n             it.remove();\n             fail();\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n         }\n     }\n \n     public void testIteratorConstructorIteration_Simple() {\n-        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n         try {\n             it.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     public void testIteratorConstructorIteration_SimpleNoHasNext() {\n-        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n-\n-        for (int i = 0; i < 6; i++) {\n-            assertEquals(testArray[i], it.next());\n-        }\n-        try {\n-            it.next();\n-            fail();\n-        } catch (NoSuchElementException ex) {\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(testArray[i], it.next());\n+        }\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     public void testIteratorConstructorIteration_WithEmptyIterators() {\n-        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        iteratorList.add(list3.iterator());\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n         try {\n             it.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     public void testIteratorConstructorRemove() {\n-        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(testArray[i], it.next());\n \n     //-----------------------------------------------------------------------\n     public void testIteration_IteratorOfIterators() {\n-        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(list3.iterator());\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n     }\n \n     public void testIteration_IteratorOfIteratorsWithEmptyIterators() {\n-        List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        iteratorList.add(list1.iterator());\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        iteratorList.add(list2.iterator());\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        iteratorList.add(list3.iterator());\n-        iteratorList.add(IteratorUtils.<String>emptyIterator());\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n \n         for (int i = 0; i < 6; i++) {\n             assertEquals(true, it.hasNext());\n \n     //-----------------------------------------------------------------------\n     public void testIteration_RootNull() {\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(null, null);\n-\n-        assertEquals(false, it.hasNext());\n-        try {\n-            it.next();\n-            fail();\n-        } catch (NoSuchElementException ex) {\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null, null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n         }\n         try {\n             it.remove();\n             fail();\n-        } catch (IllegalStateException ex) {\n+        } catch (final IllegalStateException ex) {\n         }\n     }\n \n     public void testIteration_RootNoTransformer() {\n-        Forest forest = new Forest();\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, null);\n+        final Forest forest = new Forest();\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, null);\n \n         assertEquals(true, it.hasNext());\n         assertSame(forest, it.next());\n         try {\n             it.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     public void testIteration_Transformed1() {\n-        Forest forest = new Forest();\n-        Leaf l1 = forest.addTree().addBranch().addLeaf();\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+        final Forest forest = new Forest();\n+        final Leaf l1 = forest.addTree().addBranch().addLeaf();\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n \n         assertEquals(true, it.hasNext());\n         assertSame(l1, it.next());\n         try {\n             it.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     public void testIteration_Transformed2() {\n-        Forest forest = new Forest();\n-        forest.addTree();\n-        forest.addTree();\n-        forest.addTree();\n-        Branch b1 = forest.getTree(0).addBranch();\n-        Branch b2 = forest.getTree(0).addBranch();\n-        Branch b3 = forest.getTree(2).addBranch();\n+        final Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        final Branch b1 = forest.getTree(0).addBranch();\n+        final Branch b2 = forest.getTree(0).addBranch();\n+        final Branch b3 = forest.getTree(2).addBranch();\n         /* Branch b4 = */ forest.getTree(2).addBranch();\n-        Branch b5 = forest.getTree(2).addBranch();\n-        Leaf l1 = b1.addLeaf();\n-        Leaf l2 = b1.addLeaf();\n-        Leaf l3 = b2.addLeaf();\n-        Leaf l4 = b3.addLeaf();\n-        Leaf l5 = b5.addLeaf();\n-\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+        final Branch b5 = forest.getTree(2).addBranch();\n+        final Leaf l1 = b1.addLeaf();\n+        final Leaf l2 = b1.addLeaf();\n+        final Leaf l3 = b2.addLeaf();\n+        final Leaf l4 = b3.addLeaf();\n+        final Leaf l5 = b5.addLeaf();\n+\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n \n         assertEquals(true, it.hasNext());\n         assertSame(l1, it.next());\n         try {\n             it.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     public void testIteration_Transformed3() {\n-        Forest forest = new Forest();\n-        forest.addTree();\n-        forest.addTree();\n-        forest.addTree();\n-        Branch b1 = forest.getTree(1).addBranch();\n-        Branch b2 = forest.getTree(1).addBranch();\n-        Branch b3 = forest.getTree(2).addBranch();\n-        Branch b4 = forest.getTree(2).addBranch();\n+        final Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        final Branch b1 = forest.getTree(1).addBranch();\n+        final Branch b2 = forest.getTree(1).addBranch();\n+        final Branch b3 = forest.getTree(2).addBranch();\n+        final Branch b4 = forest.getTree(2).addBranch();\n         /* Branch b5 = */ forest.getTree(2).addBranch();\n-        Leaf l1 = b1.addLeaf();\n-        Leaf l2 = b1.addLeaf();\n-        Leaf l3 = b2.addLeaf();\n-        Leaf l4 = b3.addLeaf();\n-        Leaf l5 = b4.addLeaf();\n-\n-        Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+        final Leaf l1 = b1.addLeaf();\n+        final Leaf l2 = b1.addLeaf();\n+        final Leaf l3 = b2.addLeaf();\n+        final Leaf l4 = b3.addLeaf();\n+        final Leaf l5 = b4.addLeaf();\n+\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n \n         assertEquals(true, it.hasNext());\n         assertSame(l1, it.next());\n         try {\n             it.next();\n             fail();\n-        } catch (NoSuchElementException ex) {\n+        } catch (final NoSuchElementException ex) {\n         }\n     }\n \n     //-----------------------------------------------------------------------\n     static class LeafFinder implements Transformer<Object, Object> {\n-        public Object transform(Object input) {\n+        public Object transform(final Object input) {\n             if (input instanceof Forest) {\n                 return ((Forest) input).treeIterator();\n             }\n             return getTree(trees.size() - 1);\n         }\n \n-        Tree getTree(int index) {\n+        Tree getTree(final int index) {\n             return trees.get(index);\n         }\n \n             return getBranch(branches.size() - 1);\n         }\n \n-        Branch getBranch(int index) {\n+        Branch getBranch(final int index) {\n             return branches.get(index);\n         }\n \n             return getLeaf(leaves.size() - 1);\n         }\n \n-        Leaf getLeaf(int index) {\n+        Leaf getLeaf(final int index) {\n             return leaves.get(index);\n         }\n \n             return colour;\n         }\n \n-        void setColour(String colour) {\n+        void setColour(final String colour) {\n             this.colour = colour;\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/iterators/ReverseListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/ReverseListIteratorTest.java\n \n     protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\" };\n \n-    public ReverseListIteratorTest(String testName) {\n+    public ReverseListIteratorTest(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public ReverseListIterator<E> makeObject() {\n-        List<E> list = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+        final List<E> list = new ArrayList<E>(Arrays.asList((E[]) testArray));\n         return new ReverseListIterator<E>(list);\n     }\n \n     //-----------------------------------------------------------------------\n     @Override\n     public void testEmptyListIteratorIsIndeedEmpty() {\n-        ListIterator<E> it = makeEmptyIterator();\n+        final ListIterator<E> it = makeEmptyIterator();\n \n         assertEquals(false, it.hasNext());\n         assertEquals(-1, it.nextIndex());  // reversed index\n         try {\n             it.next();\n             fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n \n         // previous() should throw a NoSuchElementException\n         try {\n             it.previous();\n             fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n     }\n \n     @Override\n     public void testWalkForwardAndBack() {\n-        ArrayList<E> list = new ArrayList<E>();\n-        ListIterator<E> it = makeObject();\n+        final ArrayList<E> list = new ArrayList<E>();\n+        final ListIterator<E> it = makeObject();\n         while (it.hasNext()) {\n             list.add(it.next());\n         }\n             assertEquals(\"\" + i, list.size() - i - 2, it.nextIndex());  // reversed index\n             assertEquals(list.size() - i - 1, it.previousIndex());  // reversed index\n \n-            Object obj = list.get(i);\n+            final Object obj = list.get(i);\n             assertEquals(obj, it.previous());\n         }\n \n         try {\n             it.previous();\n             fail(\"NoSuchElementException must be thrown from previous at start of ListIterator\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n         }\n     }\n \n     //-----------------------------------------------------------------------\n     public void testReverse() {\n-        ListIterator<E> it = makeObject();\n+        final ListIterator<E> it = makeObject();\n         assertEquals(true, it.hasNext());\n         assertEquals(3, it.nextIndex());\n         assertEquals(false, it.hasPrevious());\n     }\n \n     public void testReset() {\n-        ResettableListIterator<E> it = makeObject();\n+        final ResettableListIterator<E> it = makeObject();\n         assertEquals(\"Four\", it.next());\n         it.reset();\n         assertEquals(\"Four\", it.next());\n--- a/src/test/java/org/apache/commons/collections/iterators/SingletonIterator2Test.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/SingletonIterator2Test.java\n \n     private static final Object testValue = \"foo\";\n \n-    public SingletonIterator2Test(String testName) {\n+    public SingletonIterator2Test(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public SingletonIterator<E> makeEmptyIterator() {\n-        SingletonIterator<E> iter = new SingletonIterator<E>((E) testValue);\n+        final SingletonIterator<E> iter = new SingletonIterator<E>((E) testValue);\n         iter.next();\n         iter.remove();\n         iter.reset();\n \n     //-----------------------------------------------------------------------\n     public void testIterator() {\n-        Iterator<E> iter = makeObject();\n+        final Iterator<E> iter = makeObject();\n         assertTrue(\"Iterator has a first item\", iter.hasNext());\n \n-        E iterValue = iter.next();\n+        final E iterValue = iter.next();\n         assertEquals(\"Iteration value is correct\", testValue, iterValue);\n \n         assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n                 e.getClass().equals(new NoSuchElementException().getClass()));\n     }\n \n     public void testReset() {\n-        ResettableIterator<E> it = makeObject();\n+        final ResettableIterator<E> it = makeObject();\n \n         assertEquals(true, it.hasNext());\n         assertEquals(testValue, it.next());\n--- a/src/test/java/org/apache/commons/collections/iterators/SingletonIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/SingletonIteratorTest.java\n \n     private static final Object testValue = \"foo\";\n \n-    public SingletonIteratorTest(String testName) {\n+    public SingletonIteratorTest(final String testName) {\n         super(testName);\n     }\n \n      */\n     @Override\n     public SingletonIterator<E> makeEmptyIterator() {\n-        SingletonIterator<E> iter = makeObject();\n+        final SingletonIterator<E> iter = makeObject();\n         iter.next();\n         iter.remove();\n         iter.reset();\n     }\n \n     public void testIterator() {\n-        Iterator<E> iter = makeObject();\n+        final Iterator<E> iter = makeObject();\n         assertTrue(\"Iterator has a first item\", iter.hasNext());\n \n-        E iterValue = iter.next();\n+        final E iterValue = iter.next();\n         assertEquals(\"Iteration value is correct\", testValue, iterValue);\n \n         assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\n                 \"NoSuchElementException must be thrown\",\n                 e.getClass().equals(new NoSuchElementException().getClass()));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSingletonIteratorRemove() {\n-        ResettableIterator<E> iter = new SingletonIterator<E>((E) \"xyzzy\");\n+        final ResettableIterator<E> iter = new SingletonIterator<E>((E) \"xyzzy\");\n         assertTrue(iter.hasNext());\n         assertEquals(\"xyzzy\",iter.next());\n         iter.remove();\n     }\n \n     public void testReset() {\n-        ResettableIterator<E> it = makeObject();\n+        final ResettableIterator<E> it = makeObject();\n \n         assertEquals(true, it.hasNext());\n         assertEquals(testValue, it.next());\n--- a/src/test/java/org/apache/commons/collections/iterators/SingletonListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/SingletonListIteratorTest.java\n \n     private static final Object testValue = \"foo\";\n     \n-    public SingletonListIteratorTest(String testName) {\n+    public SingletonListIteratorTest(final String testName) {\n         super(testName);\n     }\n     \n      */\n     @Override\n     public SingletonListIterator<E> makeEmptyIterator() {\n-        SingletonListIterator<E> iter = makeObject();\n+        final SingletonListIterator<E> iter = makeObject();\n         iter.next();\n         iter.remove();\n         iter.reset();        \n     }\n \n     public void testIterator() {\n-        ListIterator<E> iter = makeObject();\n+        final ListIterator<E> iter = makeObject();\n         assertTrue( \"Iterator should have next item\", iter.hasNext() );\n         assertTrue( \"Iterator should have no previous item\", !iter.hasPrevious() );\n         assertEquals( \"Iteration next index\", 0, iter.nextIndex() );\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n           assertTrue(\"NoSuchElementException must be thrown\", \n              e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n         iter.previous();\n         try {\n             iter.previous();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n           assertTrue(\"NoSuchElementException must be thrown\", \n              e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n     }\n     \n     public void testReset() {\n-        ResettableListIterator<E> it = makeObject();\n+        final ResettableListIterator<E> it = makeObject();\n         \n         assertEquals(true, it.hasNext());\n         assertEquals(false, it.hasPrevious());\n--- a/src/test/java/org/apache/commons/collections/iterators/UniqueFilterIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/UniqueFilterIteratorTest.java\n \n     protected List<E> list1 = null;\n \n-    public UniqueFilterIteratorTest(String testName) {\n+    public UniqueFilterIteratorTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public UniqueFilterIterator<E> makeEmptyIterator() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         return new UniqueFilterIterator<E>(list.iterator());\n     }\n \n     @Override\n     public UniqueFilterIterator<E> makeObject() {\n-        Iterator<E> i = list1.iterator();\n+        final Iterator<E> i = list1.iterator();\n         return new UniqueFilterIterator<E>(i);\n     }\n \n     public void testIterator() {\n-        Iterator<E> iter = makeObject();\n-        for (String testValue : testArray) {\n-            E iterValue = iter.next();\n+        final Iterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final E iterValue = iter.next();\n \n             assertEquals( \"Iteration value is correct\", testValue, iterValue );\n         }\n \n         try {\n             iter.next();\n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             assertTrue(\"NoSuchElementException must be thrown\", \n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n--- a/src/test/java/org/apache/commons/collections/iterators/UnmodifiableIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/UnmodifiableIteratorTest.java\n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n     protected List<E> testList;\n \n-    public UnmodifiableIteratorTest(String testName) {\n+    public UnmodifiableIteratorTest(final String testName) {\n         super(testName);\n     }\n \n         try {\n             UnmodifiableIterator.unmodifiableIterator(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections/iterators/UnmodifiableListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/UnmodifiableListIteratorTest.java\n     protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n     protected List<E> testList;\n \n-    public UnmodifiableListIteratorTest(String testName) {\n+    public UnmodifiableListIteratorTest(final String testName) {\n         super(testName);\n     }\n \n         try {\n             UnmodifiableListIterator.umodifiableListIterator(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections/iterators/UnmodifiableMapIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/UnmodifiableMapIteratorTest.java\n  */\n public class UnmodifiableMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {\n \n-    public UnmodifiableMapIteratorTest(String testName) {\n+    public UnmodifiableMapIteratorTest(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public IterableMap<K, V> getMap() {\n-        IterableMap<K, V> testMap = new DualHashBidiMap<K, V>();\n+        final IterableMap<K, V> testMap = new DualHashBidiMap<K, V>();\n         testMap.put((K) \"A\", (V) \"a\");\n         testMap.put((K) \"B\", (V)\"b\");\n         testMap.put((K) \"C\", (V) \"c\");\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Map<K, V> getConfirmedMap() {\n-        Map<K, V> testMap = new HashMap<K, V>();\n+        final Map<K, V> testMap = new HashMap<K, V>();\n         testMap.put((K) \"A\", (V) \"a\");\n         testMap.put((K) \"B\", (V)\"b\");\n         testMap.put((K) \"C\", (V) \"c\");\n         try {\n             UnmodifiableMapIterator.unmodifiableMapIterator(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/UnmodifiableOrderedMapIteratorTest.java\n  */\n public class UnmodifiableOrderedMapIteratorTest<K, V> extends AbstractOrderedMapIteratorTest<K, V> {\n \n-    public UnmodifiableOrderedMapIteratorTest(String testName) {\n+    public UnmodifiableOrderedMapIteratorTest(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public OrderedMap<K, V> getMap() {\n-        OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+        final OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n         testMap.put((K) \"A\", (V) \"a\");\n         testMap.put((K) \"B\", (V) \"b\");\n         testMap.put((K) \"C\", (V) \"c\");\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Map<K, V> getConfirmedMap() {\n-        Map<K, V> testMap = new TreeMap<K, V>();\n+        final Map<K, V> testMap = new TreeMap<K, V>();\n         testMap.put((K) \"A\", (V) \"a\");\n         testMap.put((K) \"B\", (V) \"b\");\n         testMap.put((K) \"C\", (V) \"c\");\n         try {\n             UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections/keyvalue/AbstractMapEntryTest.java\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/AbstractMapEntryTest.java\n      * \n      * @param testName  the test name\n      */\n-    public AbstractMapEntryTest(String testName) {\n+    public AbstractMapEntryTest(final String testName) {\n         super(testName);\n     }\n \n     /**\n      * Makes a Map.Entry of a type that's known to work correctly.\n      */\n-    public Map.Entry<K, V> makeKnownMapEntry(K key, V value) {\n-        Map<K, V> map = new HashMap<K, V>(1);\n+    public Map.Entry<K, V> makeKnownMapEntry(final K key, final V value) {\n+        final Map<K, V> map = new HashMap<K, V>(1);\n         map.put(key, value);\n-        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n         return entry;\n     }\n \n         //  the MapEntry to contain itself (and thus cause infinite recursion\n         //  in #hashCode and #toString)\n \n-        Map.Entry<K, V> entry = makeMapEntry();\n+        final Map.Entry<K, V> entry = makeMapEntry();\n \n         try {\n             entry.setValue((V) entry);\n             fail(\"Should throw an IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // expected to happen...\n \n             // check that the KVP's state has not changed\n--- a/src/test/java/org/apache/commons/collections/keyvalue/DefaultKeyValueTest.java\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/DefaultKeyValueTest.java\n      * \n      * @param testName  the test name\n      */\n-    public DefaultKeyValueTest(String testName) {\n+    public DefaultKeyValueTest(final String testName) {\n         super(testName);\n \n     }\n      * Subclasses should override this method to return a DefaultKeyValue\n      * of the type being tested.\n      */\n-    protected DefaultKeyValue<K, V> makeDefaultKeyValue(K key, V value) {\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue(final K key, final V value) {\n         return new DefaultKeyValue<K, V>(key, value);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testAccessorsAndMutators() {\n-        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n \n         kv.setKey((K) key);\n         assertTrue(kv.getKey() == key);\n         //  the KVP to contain itself (and thus cause infinite recursion\n         //  in #hashCode and #toString)\n \n-        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n \n         try {\n             kv.setKey((K) kv);\n             fail(\"Should throw an IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // expected to happen...\n \n             // check that the KVP's state has not changed\n         try {\n             kv.setValue((V) kv);\n             fail(\"Should throw an IllegalArgumentException\");\n-        } catch (IllegalArgumentException iae) {\n+        } catch (final IllegalArgumentException iae) {\n             // expected to happen...\n \n             // check that the KVP's state has not changed\n         assertTrue(kv.getKey() == key && kv.getValue() == value);\n \n         // 3. test copy constructor\n-        DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<K, V>(kv);\n+        final DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<K, V>(kv);\n         assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n \n         // test that the KVPs are independent\n         assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n \n         // 4. test Map.Entry constructor\n-        Map<K, V> map = new HashMap<K, V>();\n+        final Map<K, V> map = new HashMap<K, V>();\n         map.put((K) key, (V) value);\n-        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n \n         kv = new DefaultKeyValue<K, V>(entry);\n         assertTrue(kv.getKey() == key && kv.getValue() == value);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testToMapEntry() {\n-        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n \n-        Map<K, V> map = new HashMap<K, V>();\n+        final Map<K, V> map = new HashMap<K, V>();\n         map.put(kv.getKey(), kv.getValue());\n-        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n \n         assertTrue(entry.equals(kv.toMapEntry()));\n         assertTrue(entry.hashCode() == kv.hashCode());\n--- a/src/test/java/org/apache/commons/collections/keyvalue/DefaultMapEntryTest.java\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/DefaultMapEntryTest.java\n  */\n public class DefaultMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n \n-    public DefaultMapEntryTest(String testName) {\n+    public DefaultMapEntryTest(final String testName) {\n         super(testName);\n     }\n \n      * of the type being tested.\n      */\n     @Override\n-    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n         return new DefaultMapEntry<K, V>(key, value);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testConstructors() {\n         // 1. test key-value constructor\n-        Map.Entry<K, V> entry = new DefaultMapEntry<K, V>((K) key, (V) value);\n+        final Map.Entry<K, V> entry = new DefaultMapEntry<K, V>((K) key, (V) value);\n         assertSame(key, entry.getKey());\n         assertSame(value, entry.getValue());\n \n         // 2. test pair constructor\n-        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        final KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n         assertSame(key, pair.getKey());\n         assertSame(value, pair.getValue());\n \n         // 3. test copy constructor\n-        Map.Entry<K, V> entry2 = new DefaultMapEntry<K, V>(entry);\n+        final Map.Entry<K, V> entry2 = new DefaultMapEntry<K, V>(entry);\n         assertSame(key, entry2.getKey());\n         assertSame(value, entry2.getValue());\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public void testSelfReferenceHandling() {\n-        Map.Entry<K, V> entry = makeMapEntry();\n+        final Map.Entry<K, V> entry = makeMapEntry();\n \n         try {\n             entry.setValue((V) entry);\n             assertSame(entry, entry.getValue());\n \n-        } catch (Exception e) {\n+        } catch (final Exception e) {\n             fail(\"This Map.Entry implementation supports value self-reference.\");\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/keyvalue/MultiKeyTest.java\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/MultiKeyTest.java\n     Integer FOUR = new Integer(4);\n     Integer FIVE = new Integer(5);\n \n-    public MultiKeyTest(String name) {\n+    public MultiKeyTest(final String name) {\n         super(name);\n     }\n \n     }\n \n     public void testConstructorsByArrayNull() throws Exception {\n-        Integer[] keys = null;\n+        final Integer[] keys = null;\n         try {\n             new MultiKey<Integer>(keys);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             new MultiKey<Integer>(keys, true);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n         try {\n             new MultiKey<Integer>(keys, false);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     public void testSize() {\n     }\n \n     public void testGetIndexed() {\n-        MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n         Assert.assertSame(ONE, mk.getKey(0));\n         Assert.assertSame(TWO, mk.getKey(1));\n         try {\n             mk.getKey(-1);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             mk.getKey(2);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n     }\n \n     public void testGetKeysSimpleConstructor() {\n-        MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n-        Object[] array = mk.getKeys();\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        final Object[] array = mk.getKeys();\n         Assert.assertSame(ONE, array[0]);\n         Assert.assertSame(TWO, array[1]);\n         Assert.assertEquals(2, array.length);\n     }\n \n     public void testGetKeysArrayConstructorCloned() {\n-        Integer[] keys = new Integer[] { ONE, TWO };\n-        MultiKey<Integer> mk = new MultiKey<Integer>(keys, true);\n-        Object[] array = mk.getKeys();\n+        final Integer[] keys = new Integer[] { ONE, TWO };\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(keys, true);\n+        final Object[] array = mk.getKeys();\n         Assert.assertTrue(array != keys);\n         Assert.assertTrue(Arrays.equals(array, keys));\n         Assert.assertSame(ONE, array[0]);\n     }\n \n     public void testGetKeysArrayConstructorNonCloned() {\n-        Integer[] keys = new Integer[] { ONE, TWO };\n-        MultiKey<Integer> mk = new MultiKey<Integer>(keys, false);\n-        Object[] array = mk.getKeys();\n+        final Integer[] keys = new Integer[] { ONE, TWO };\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(keys, false);\n+        final Object[] array = mk.getKeys();\n         Assert.assertTrue(array != keys);  // still not equal\n         Assert.assertTrue(Arrays.equals(array, keys));\n         Assert.assertSame(ONE, array[0]);\n     }\n \n     public void testHashCode() {\n-        MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n-        MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n-        MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+        final MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n \n         Assert.assertTrue(mk1.hashCode() == mk1.hashCode());\n         Assert.assertTrue(mk1.hashCode() == mk2.hashCode());\n         Assert.assertTrue(mk1.hashCode() != mk3.hashCode());\n \n-        int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();\n+        final int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();\n         Assert.assertEquals(total, mk1.hashCode());\n     }\n \n     public void testEquals() {\n-        MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n-        MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n-        MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+        final MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n \n         Assert.assertEquals(mk1, mk1);\n         Assert.assertEquals(mk1, mk2);\n         private final String name;\n         private int hashCode = 1;\n \n-        public SystemHashCodeSimulatingKey(String name)\n+        public SystemHashCodeSimulatingKey(final String name)\n         {\n             this.name = name;\n         }\n \n         @Override\n-        public boolean equals(Object obj)\n+        public boolean equals(final Object obj)\n         {\n             return obj instanceof SystemHashCodeSimulatingKey \n                 && name.equals(((SystemHashCodeSimulatingKey)obj).name);\n     public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException\n     {\n         SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey(\"test\");\n-        MultiKey mk = new MultiKey(ONE, sysKey);\n-        Map map = new HashMap();\n+        final MultiKey mk = new MultiKey(ONE, sysKey);\n+        final Map map = new HashMap();\n         map.put(mk, TWO);\n \n         // serialize\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(baos);\n         out.writeObject(sysKey);\n         out.writeObject(map);\n         out.close();\n \n         // deserialize\n-        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n-        ObjectInputStream in = new ObjectInputStream(bais);\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+        final ObjectInputStream in = new ObjectInputStream(bais);\n         sysKey = (SystemHashCodeSimulatingKey)in.readObject(); // simulate deserialization in another process\n-        Map map2 = (Map) in.readObject();\n+        final Map map2 = (Map) in.readObject();\n         in.close();\n \n         assertEquals(2, sysKey.hashCode()); // different hashCode now\n \n-        MultiKey mk2 = new MultiKey(ONE, sysKey);\n+        final MultiKey mk2 = new MultiKey(ONE, sysKey);\n         assertEquals(TWO, map2.get(mk2));        \n     }\n }\n--- a/src/test/java/org/apache/commons/collections/keyvalue/TiedMapEntryTest.java\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/TiedMapEntryTest.java\n  */\n public class TiedMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n \n-    public TiedMapEntryTest(String testName) {\n+    public TiedMapEntryTest(final String testName) {\n         super(testName);\n     }\n \n      * Gets the instance to test\n      */\n     @Override\n-    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n-        Map<K, V> map = new HashMap<K, V>();\n+    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n+        final Map<K, V> map = new HashMap<K, V>();\n         map.put(key, value);\n         return new TiedMapEntry<K, V>(map, key);\n     }\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void testSetValue() {\n-        Map<K, V> map = new HashMap<K, V>();\n+        final Map<K, V> map = new HashMap<K, V>();\n         map.put((K) \"A\", (V) \"a\");\n         map.put((K) \"B\", (V) \"b\");\n         map.put((K) \"C\", (V) \"c\");\n--- a/src/test/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntryTest.java\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntryTest.java\n  */\n public class UnmodifiableMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n \n-    public UnmodifiableMapEntryTest(String testName) {\n+    public UnmodifiableMapEntryTest(final String testName) {\n         super(testName);\n     }\n \n      * of the type being tested.\n      */\n     @Override\n-    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n         return new UnmodifiableMapEntry<K, V>(key, value);\n     }\n \n         assertSame(value, entry.getValue());\n \n         // 2. test pair constructor\n-        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        final KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n         entry = new UnmodifiableMapEntry<K, V>(pair);\n         assertSame(key, entry.getKey());\n         assertSame(value, entry.getValue());\n \n         // 3. test copy constructor\n-        Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<K, V>(entry);\n+        final Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<K, V>(entry);\n         assertSame(key, entry2.getKey());\n         assertSame(value, entry2.getValue());\n \n     }\n \n     public void testUnmodifiable() {\n-        Map.Entry<K, V> entry = makeMapEntry();\n+        final Map.Entry<K, V> entry = makeMapEntry();\n         try {\n             entry.setValue(null);\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections/list/AbstractLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/AbstractLinkedListTest.java\n  */\n public abstract class AbstractLinkedListTest<E> extends AbstractListTest<E> {\n \n-    public AbstractLinkedListTest(String testName) {\n+    public AbstractLinkedListTest(final String testName) {\n         super(testName);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveFirst() {\n         resetEmpty();\n-        AbstractLinkedList<E> list = getCollection();\n+        final AbstractLinkedList<E> list = getCollection();\n         if (isRemoveSupported() == false) {\n             try {\n                 list.removeFirst();\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n         }\n \n         list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveLast() {\n         resetEmpty();\n-        AbstractLinkedList<E> list = getCollection();\n+        final AbstractLinkedList<E> list = getCollection();\n         if (isRemoveSupported() == false) {\n             try {\n                 list.removeLast();\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n         }\n \n         list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n     @SuppressWarnings(\"unchecked\")\n     public void testAddNodeAfter() {\n         resetEmpty();\n-        AbstractLinkedList<E> list = getCollection();\n+        final AbstractLinkedList<E> list = getCollection();\n         if (isAddSupported() == false) {\n             try {\n                 list.addFirst(null);\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n         }\n \n         list.addFirst((E) \"value1\");\n         if (isAddSupported() == false || isRemoveSupported() == false) {\n             return;\n         }\n-        AbstractLinkedList<E> list = getCollection();\n+        final AbstractLinkedList<E> list = getCollection();\n \n         list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n         list.removeNode(list.getNode(0, false));\n     @SuppressWarnings(\"unchecked\")\n     public void testGetNode() {\n         resetEmpty();\n-        AbstractLinkedList<E> list = getCollection();\n+        final AbstractLinkedList<E> list = getCollection();\n         // get marker\n         assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n         try {\n             list.getNode(0, false);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n         list.addAll( Arrays.asList((E[]) new String[]{\"value1\", \"value2\"}));\n         try {\n             list.getNode(2, false);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n         try {\n             list.getNode(-1, false);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n          try {\n             list.getNode(3, true);\n             fail(\"Expecting IndexOutOfBoundsException.\");\n-        } catch (IndexOutOfBoundsException ex) {\n+        } catch (final IndexOutOfBoundsException ex) {\n             // expected\n         }\n     }\n \n     protected void checkNodes() {\n-        AbstractLinkedList<E> list = getCollection();\n+        final AbstractLinkedList<E> list = getCollection();\n         for (int i = 0; i < list.size; i++) {\n             assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n             if (i < list.size - 1) {\n--- a/src/test/java/org/apache/commons/collections/list/AbstractListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/AbstractListTest.java\n      *\n      * @param testName  the test class name\n      */\n-    public AbstractListTest(String testName) {\n+    public AbstractListTest(final String testName) {\n         super(testName);\n     }\n \n     public void verify() {\n         super.verify();\n \n-        List<E> list1 = getCollection();\n-        List<E> list2 = getConfirmed();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n \n         assertEquals(\"List should equal confirmed\", list1, list2);\n         assertEquals(\"Confirmed should equal list\", list2, list1);\n         assertEquals(\"Hash codes should be equal\", list1.hashCode(), list2.hashCode());\n \n         int i = 0;\n-        Iterator<E> iterator1 = list1.iterator();\n-        Iterator<E> iterator2 = list2.iterator();\n-        E[] array = (E[]) list1.toArray();\n+        final Iterator<E> iterator1 = list1.iterator();\n+        final Iterator<E> iterator2 = list2.iterator();\n+        final E[] array = (E[]) list1.toArray();\n         while (iterator2.hasNext()) {\n             assertTrue(\"List iterator should have next\", iterator1.hasNext());\n-            Object o1 = iterator1.next();\n+            final Object o1 = iterator1.next();\n             Object o2 = iterator2.next();\n             assertEquals(\"Iterator elements should be equal\", o1, o2);\n             o2 = list1.get(i);\n      */\n     @Override\n     public Collection<E> makeConfirmedCollection() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         return list;\n     }\n \n      */\n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     @Override\n     public List<E> makeFullCollection() {\n         // only works if list supports optional \"addAll(Collection)\"\n-        List<E> list = makeObject();\n+        final List<E> list = makeObject();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n         }\n \n         List<E> list;\n-        E element = getOtherElements()[0];\n+        final E element = getOtherElements()[0];\n \n         try {\n             list = makeObject();\n             list.add(Integer.MIN_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list = makeObject();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list = makeObject();\n             list.add(1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list = makeObject();\n             list.add(Integer.MAX_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n         }\n \n         List<E> list;\n-        E element = getOtherElements()[0];\n+        final E element = getOtherElements()[0];\n \n         try {\n             list = makeFullCollection();\n             list.add(Integer.MIN_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list = makeFullCollection();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list = makeFullCollection();\n             list.add(list.size() + 1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [size + 1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list = makeFullCollection();\n             list.add(Integer.MAX_VALUE, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n             return;\n         }\n \n-        E element = getOtherElements()[0];\n-        int max = getFullElements().length;\n+        final E element = getOtherElements()[0];\n+        final int max = getFullElements().length;\n \n         for (int i = 0; i <= max; i++) {\n             resetFull();\n         verify();\n \n         final List<E> listForC = Arrays.asList(getFullElements());\n-        Collection<E> c = new AbstractCollection<E>() {\n+        final Collection<E> c = new AbstractCollection<E>() {\n             @Override\n             public int size() {\n                 return listForC.size();\n      */\n     public void testListGetByIndex() {\n         resetFull();\n-        List<E> list = getCollection();\n-        E[] elements = getFullElements();\n+        final List<E> list = getCollection();\n+        final E[] elements = getFullElements();\n         for (int i = 0; i < elements.length; i++) {\n             assertEquals(\"List should contain correct elements\", elements[i], list.get(i));\n             verify();\n      *  empty list.\n      */\n     public void testListGetByIndexBoundsChecking() {\n-        List<E> list = makeObject();\n+        final List<E> list = makeObject();\n \n         try {\n             list.get(Integer.MIN_VALUE);\n             fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(-1);\n             fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(0);\n             fail(\"List.get should throw IndexOutOfBoundsException [0]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(1);\n             fail(\"List.get should throw IndexOutOfBoundsException [1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(Integer.MAX_VALUE);\n             fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n      *  full list.\n      */\n     public void testListGetByIndexBoundsChecking2() {\n-        List<E> list = makeFullCollection();\n+        final List<E> list = makeFullCollection();\n \n         try {\n             list.get(Integer.MIN_VALUE);\n             fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(-1);\n             fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(getFullElements().length);\n             fail(\"List.get should throw IndexOutOfBoundsException [size]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(Integer.MAX_VALUE);\n             fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n      */\n     public void testListIndexOf() {\n         resetFull();\n-        List<E> list1 = getCollection();\n-        List<E> list2 = getConfirmed();\n-\n-        Iterator<E> iterator = list2.iterator();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final Iterator<E> iterator = list2.iterator();\n         while (iterator.hasNext()) {\n-            Object element = iterator.next();\n+            final Object element = iterator.next();\n             assertEquals(\"indexOf should return correct result\",\n                 list1.indexOf(element), list2.indexOf(element));\n             verify();\n         }\n \n-        E[] other = getOtherElements();\n-        for (E element : other) {\n+        final E[] other = getOtherElements();\n+        for (final E element : other) {\n             assertEquals(\"indexOf should return -1 for nonexistent element\",\n                 -1, list1.indexOf(element));\n             verify();\n      */\n     public void testListLastIndexOf() {\n         resetFull();\n-        List<E> list1 = getCollection();\n-        List<E> list2 = getConfirmed();\n-\n-        Iterator<E> iterator = list2.iterator();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final Iterator<E> iterator = list2.iterator();\n         while (iterator.hasNext()) {\n-            E element = iterator.next();\n+            final E element = iterator.next();\n             assertEquals(\"lastIndexOf should return correct result\",\n               list1.lastIndexOf(element), list2.lastIndexOf(element));\n             verify();\n         }\n \n-        E[] other = getOtherElements();\n-        for (E element : other) {\n+        final E[] other = getOtherElements();\n+        for (final E element : other) {\n             assertEquals(\"lastIndexOf should return -1 for nonexistent \" +\n                 \"element\", -1, list1.lastIndexOf(element));\n             verify();\n             return;\n         }\n \n-        List<E> list = makeObject();\n-        E element = getOtherElements()[0];\n+        final List<E> list = makeObject();\n+        final E element = getOtherElements()[0];\n \n         try {\n             list.set(Integer.MIN_VALUE, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.set(0, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [0]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.set(1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.set(Integer.MAX_VALUE, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n             return;\n         }\n \n-        List<E> list = makeFullCollection();\n-        E element = getOtherElements()[0];\n+        final List<E> list = makeFullCollection();\n+        final E element = getOtherElements()[0];\n \n         try {\n             list.set(Integer.MIN_VALUE, element);\n             fail(\"List.set should throw IndexOutOfBoundsException \" +\n               \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.set(getFullElements().length, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [size]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list.set(Integer.MAX_VALUE, element);\n             fail(\"List.set should throw IndexOutOfBoundsException \" +\n               \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n         }\n \n         resetFull();\n-        E[] elements = getFullElements();\n-        E[] other = getOtherElements();\n+        final E[] elements = getFullElements();\n+        final E[] other = getOtherElements();\n \n         for (int i = 0; i < elements.length; i++) {\n-            E n = other[i % other.length];\n-            E v = getCollection().set(i, n);\n+            final E n = other[i % other.length];\n+            final E v = getCollection().set(i, n);\n             assertEquals(\"Set should return correct element\", elements[i], v);\n             getConfirmed().set(i, n);\n             verify();\n         try {\n             getCollection().set(0, getFullElements()[0]);\n             fail(\"Emtpy collection should not support set.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         // make sure things didn't change even if the expected exception was\n             return;\n         }\n \n-        List<E> list = makeObject();\n+        final List<E> list = makeObject();\n \n         try {\n             list.remove(Integer.MIN_VALUE);\n             fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.remove(-1);\n             fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.remove(0);\n             fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.remove(1);\n             fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.remove(Integer.MAX_VALUE);\n             fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n             return;\n         }\n \n-        List<E> list = makeFullCollection();\n+        final List<E> list = makeFullCollection();\n \n         try {\n             list.remove(Integer.MIN_VALUE);\n             fail(\"List.remove should throw IndexOutOfBoundsException \" +\n               \"[Integer.MIN_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.remove(-1);\n             fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.remove(getFullElements().length);\n             fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n             list.remove(Integer.MAX_VALUE);\n             fail(\"List.remove should throw IndexOutOfBoundsException \" +\n               \"[Integer.MAX_VALUE]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n             return;\n         }\n \n-        int max = getFullElements().length;\n+        final int max = getFullElements().length;\n         for (int i = 0; i < max; i++) {\n             resetFull();\n-            E o1 = getCollection().remove(i);\n-            E o2 = getConfirmed().remove(i);\n+            final E o1 = getCollection().remove(i);\n+            final E o2 = getConfirmed().remove(i);\n             assertEquals(\"remove should return correct element\", o1, o2);\n             verify();\n         }\n         resetFull();\n         try {\n             getCollection().listIterator(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         resetFull();\n         try {\n             getCollection().listIterator(getCollection().size() + 1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         resetFull();\n         for (int i = 0; i <= getConfirmed().size(); i++) {\n             forwardTest(getCollection().listIterator(i), i);\n         if (getCollection().size() < 4) {\n             return;\n         }\n-        ListIterator<E> it = getCollection().listIterator();\n-        E zero = it.next();\n-        E one = it.next();\n-        E two = it.next();\n-        E two2 = it.previous();\n-        E one2 = it.previous();\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n+        final E two2 = it.previous();\n+        final E one2 = it.previous();\n         assertEquals(one, one2);\n         assertEquals(two, two2);\n         assertEquals(zero, getCollection().get(0));\n         it.remove(); // removed element at index 1 (one)\n         assertEquals(zero, getCollection().get(0));\n         assertEquals(two, getCollection().get(1));\n-        E two3 = it.next();  // do next after remove\n+        final E two3 = it.next();  // do next after remove\n         assertEquals(two, two3);\n         assertEquals(getCollection().size() > 2, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n         if (getCollection().size() < 4) {\n             return;\n         }\n-        ListIterator<E> it = getCollection().listIterator();\n-        E zero = it.next();\n-        E one = it.next();\n-        E two = it.next();\n-        E two2 = it.previous();\n-        E one2 = it.previous();\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n+        final E two2 = it.previous();\n+        final E one2 = it.previous();\n         assertEquals(one, one2);\n         assertEquals(two, two2);\n         assertEquals(zero, getCollection().get(0));\n         it.remove(); // removed element at index 1 (one)\n         assertEquals(zero, getCollection().get(0));\n         assertEquals(two, getCollection().get(1));\n-        E zero3 = it.previous();  // do previous after remove\n+        final E zero3 = it.previous();  // do previous after remove\n         assertEquals(zero, zero3);\n         assertEquals(false, it.hasPrevious());\n         assertEquals(getCollection().size() > 2, it.hasNext());\n         if (getCollection().size() < 4) {\n             return;\n         }\n-        ListIterator<E> it = getCollection().listIterator();\n-        E zero = it.next();\n-        E one = it.next();\n-        E two = it.next();\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n         assertEquals(zero, getCollection().get(0));\n         assertEquals(one, getCollection().get(1));\n         assertEquals(two, getCollection().get(2));\n-        E three = getCollection().get(3);\n+        final E three = getCollection().get(3);\n \n         it.remove(); // removed element at index 2 (two)\n         assertEquals(zero, getCollection().get(0));\n         assertEquals(one, getCollection().get(1));\n-        E three2 = it.next();  // do next after remove\n+        final E three2 = it.next();  // do next after remove\n         assertEquals(three, three2);\n         assertEquals(getCollection().size() > 3, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n         if (getCollection().size() < 4) {\n             return;\n         }\n-        ListIterator<E> it = getCollection().listIterator();\n-        E zero = it.next();\n-        E one = it.next();\n-        E two = it.next();\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n         assertEquals(zero, getCollection().get(0));\n         assertEquals(one, getCollection().get(1));\n         assertEquals(two, getCollection().get(2));\n         it.remove(); // removed element at index 2 (two)\n         assertEquals(zero, getCollection().get(0));\n         assertEquals(one, getCollection().get(1));\n-        E one2 = it.previous();  // do previous after remove\n+        final E one2 = it.previous();  // do previous after remove\n         assertEquals(one, one2);\n         assertEquals(true, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n      *  @param iter  the iterator to traverse\n      *  @param i     the starting index\n      */\n-    private void forwardTest(ListIterator<E> iter, int i) {\n-        List<E> list = getCollection();\n-        int max = getFullElements().length;\n+    private void forwardTest(final ListIterator<E> iter, int i) {\n+        final List<E> list = getCollection();\n+        final int max = getFullElements().length;\n \n         while (i < max) {\n             assertTrue(\"Iterator should have next\", iter.hasNext());\n                 i, iter.nextIndex());\n             assertEquals(\"Iterator.previousIndex should work\",\n                 i - 1, iter.previousIndex());\n-            Object o = iter.next();\n+            final Object o = iter.next();\n             assertEquals(\"Iterator returned correct element\", list.get(i), o);\n             i++;\n         }\n         try {\n             iter.next();\n             fail(\"Exhausted iterator should raise NoSuchElement\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             // expected\n         }\n     }\n      *  @param iter  the iterator to traverse\n      *  @param i     the starting index\n      */\n-    private void backwardTest(ListIterator<E> iter, int i) {\n-        List<E> list = getCollection();\n+    private void backwardTest(final ListIterator<E> iter, int i) {\n+        final List<E> list = getCollection();\n \n         while (i > 0) {\n             assertTrue(\"Iterator should have previous, i:\" + i,\n                 i, iter.nextIndex());\n             assertEquals(\"Iterator.previousIndex should work, i:\" + i,\n                 i - 1, iter.previousIndex());\n-            E o = iter.previous();\n+            final E o = iter.previous();\n             assertEquals(\"Iterator returned correct element\",\n                 list.get(i - 1), o);\n             i--;\n         }\n \n         assertTrue(\"Iterator shouldn't have previous\", !iter.hasPrevious());\n-        int nextIndex = iter.nextIndex();\n+        final int nextIndex = iter.nextIndex();\n         assertEquals(\"nextIndex should be 0\", 0, nextIndex);\n-        int prevIndex = iter.previousIndex();\n+        final int prevIndex = iter.previousIndex();\n         assertEquals(\"previousIndex should be -1\", -1, prevIndex);\n \n         try {\n             iter.previous();\n             fail(\"Exhausted iterator should raise NoSuchElement\");\n-        } catch (NoSuchElementException e) {\n+        } catch (final NoSuchElementException e) {\n             // expected\n         }\n \n         }\n \n         resetEmpty();\n-        List<E> list1 = getCollection();\n-        List<E> list2 = getConfirmed();\n-\n-        E[] elements = getFullElements();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final E[] elements = getFullElements();\n         ListIterator<E> iter1 = list1.listIterator();\n         ListIterator<E> iter2 = list2.listIterator();\n \n-        for (E element : elements) {\n+        for (final E element : elements) {\n             iter1.add(element);\n             iter2.add(element);\n             verify();\n         resetFull();\n         iter1 = getCollection().listIterator();\n         iter2 = getConfirmed().listIterator();\n-        for (E element : elements) {\n+        for (final E element : elements) {\n             iter1.next();\n             iter2.next();\n             iter1.add(element);\n             return;\n         }\n \n-        E[] elements = getFullElements();\n-\n-        resetFull();\n-        ListIterator<E> iter1 = getCollection().listIterator();\n-        ListIterator<E> iter2 = getConfirmed().listIterator();\n-        for (E element : elements) {\n+        final E[] elements = getFullElements();\n+\n+        resetFull();\n+        final ListIterator<E> iter1 = getCollection().listIterator();\n+        final ListIterator<E> iter2 = getConfirmed().listIterator();\n+        for (final E element : elements) {\n             iter1.next();\n             iter2.next();\n             iter1.set(element);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEmptyListSerialization() throws IOException, ClassNotFoundException {\n-        List<E> list = makeObject();\n+        final List<E> list = makeObject();\n         if (!(list instanceof Serializable && isTestSerialization())) {\n             return;\n         }\n \n-        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n-        List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n+        final byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        final List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n \n         assertEquals(\"Both lists are empty\", 0, list.size());\n         assertEquals(\"Both lists are empty\", 0, list2.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testFullListSerialization() throws IOException, ClassNotFoundException {\n-        List<E> list = makeFullCollection();\n-        int size = getFullElements().length;\n+        final List<E> list = makeFullCollection();\n+        final int size = getFullElements().length;\n         if (!(list instanceof Serializable && isTestSerialization())) {\n             return;\n         }\n \n-        byte[] objekt = writeExternalFormToBytes((Serializable) list);\n-        List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n+        final byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        final List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n \n         assertEquals(\"Both lists are same size\", size, list.size());\n         assertEquals(\"Both lists are same size\", size, list2.size());\n         */\n \n         // test to make sure the canonical form has been preserved\n-        List<E> list = makeObject();\n+        final List<E> list = makeObject();\n         if (list instanceof Serializable && !skipSerializedCanonicalTests()\n                 && isTestSerialization()) {\n-            List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n+            final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n             assertEquals(\"List is empty\", 0, list2.size());\n             assertEquals(list, list2);\n         }\n         */\n \n         // test to make sure the canonical form has been preserved\n-        List<E> list = makeFullCollection();\n+        final List<E> list = makeFullCollection();\n         if(list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n-            List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n+            final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n             if (list2.size() == 4) {\n                 // old serialized tests\n                 return;\n \n    public static class BulkTestSubList<E> extends AbstractListTest<E> {\n \n-       private AbstractListTest<E> outer;\n-\n-       public BulkTestSubList(AbstractListTest<E> outer) {\n+       private final AbstractListTest<E> outer;\n+\n+       public BulkTestSubList(final AbstractListTest<E> outer) {\n            super(\"\");\n            this.outer = outer;\n        }\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public E[] getFullElements() {\n-           List<E> l = Arrays.asList(outer.getFullElements());\n+           final List<E> l = Arrays.asList(outer.getFullElements());\n            return (E[]) l.subList(3, l.size() - 3).toArray();\n        }\n \n \n        @Override\n        public List<E> makeFullCollection() {\n-           int size = getFullElements().length;\n+           final int size = getFullElements().length;\n            return outer.makeFullCollection().subList(3, size - 3);\n        }\n \n        @Override\n        public void resetFull() {\n            outer.resetFull();\n-           int size = outer.getConfirmed().size();\n+           final int size = outer.getConfirmed().size();\n            this.setCollection(outer.getCollection().subList(3, size - 3));\n            this.setConfirmed(outer.getConfirmed().subList(3, size - 3));\n        }\n     }\n \n        resetFull();\n-       int size = getCollection().size();\n+       final int size = getCollection().size();\n        List<E> sub = getCollection().subList(1, size);\n        getCollection().add(getOtherElements()[0]);\n        failFastAll(sub);\n     }\n \n        resetFull();\n-       int size = getCollection().size();\n+       final int size = getCollection().size();\n        List<E> sub = getCollection().subList(1, size);\n        getCollection().remove(0);\n        failFastAll(sub);\n     *  Invokes all the methods on the given sublist to make sure they raise\n     *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n     */\n-   protected void failFastAll(List<E> list) {\n-       Method[] methods = List.class.getMethods();\n-       for (Method method : methods) {\n+   protected void failFastAll(final List<E> list) {\n+       final Method[] methods = List.class.getMethods();\n+       for (final Method method : methods) {\n            failFastMethod(list, method);\n        }\n    }\n     *  @param list  the sublist to test\n     *  @param m     the method to invoke\n     */\n-   protected void failFastMethod(List<E> list, Method m) {\n+   protected void failFastMethod(final List<E> list, final Method m) {\n        if (m.getName().equals(\"equals\")) {\n         return;\n     }\n \n-       E element = getOtherElements()[0];\n-       Collection<E> c = Collections.singleton(element);\n-\n-       Class<?>[] types = m.getParameterTypes();\n-       Object[] params = new Object[types.length];\n+       final E element = getOtherElements()[0];\n+       final Collection<E> c = Collections.singleton(element);\n+\n+       final Class<?>[] types = m.getParameterTypes();\n+       final Object[] params = new Object[types.length];\n        for (int i = 0; i < params.length; i++) {\n            if (types[i] == Integer.TYPE) {\n             params[i] = new Integer(0);\n        try {\n            m.invoke(list, params);\n            fail(m.getName() + \" should raise ConcurrentModification\");\n-       } catch (IllegalAccessException e) {\n+       } catch (final IllegalAccessException e) {\n            // impossible\n-       } catch (InvocationTargetException e) {\n-           Throwable t = e.getTargetException();\n+       } catch (final InvocationTargetException e) {\n+           final Throwable t = e.getTargetException();\n            if (t instanceof ConcurrentModificationException) {\n                // expected\n                return;\n--- a/src/test/java/org/apache/commons/collections/list/CursorableLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/CursorableLinkedListTest.java\n  * @author Simon Kitching\n  */\n public class CursorableLinkedListTest<E> extends AbstractLinkedListTest<E> {\n-    public CursorableLinkedListTest(String testName) {\n+    public CursorableLinkedListTest(final String testName) {\n         super(testName);\n     }\n \n         list.add(7,(E) new Integer(5));\n         assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5]\",list.toString());\n \n-        java.util.List<E> list2 = new java.util.LinkedList<E>();\n+        final java.util.List<E> list2 = new java.util.LinkedList<E>();\n         list2.add((E) \"A\");\n         list2.add((E) \"B\");\n         list2.add((E) \"C\");\n     @SuppressWarnings(\"unchecked\")\n     public void testContainsAll() {\n         assertTrue(list.containsAll(list));\n-        java.util.List<E> list2 = new java.util.LinkedList<E>();\n+        final java.util.List<E> list2 = new java.util.LinkedList<E>();\n         assertTrue(list.containsAll(list2));\n         list2.add((E) \"A\");\n         assertTrue(!list.containsAll(list2));\n         list.add((E) \"3\");\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n-        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n         assertTrue(it.hasNext());\n         assertTrue(!it.hasPrevious());\n         assertEquals(\"1\", it.next());\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n \n-        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n         assertEquals(\"1\", it.next());\n         it.set((E) \"a\");\n         assertEquals(\"a\", it.previous());\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n \n-        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n         try {\n             it.remove();\n             fail();\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // expected\n         }\n         assertEquals(\"1\", it.next());\n         assertEquals(\"[4, 5]\", list.toString());\n         try {\n             it.remove();\n-        } catch (IllegalStateException e) {\n+        } catch (final IllegalStateException e) {\n             // expected\n         }\n         assertEquals(\"4\", it.next());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testCursorAdd() {\n-        CursorableLinkedList.Cursor<E> it = list.cursor();\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n         it.add((E) \"1\");\n         assertEquals(\"[1]\", list.toString());\n         it.add((E) \"3\");\n         list.add((E) \"7\");\n         list.add((E) \"9\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n-        CursorableLinkedList.Cursor<E> c2 = list.cursor();\n-        Iterator<E> li = list.iterator();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c2 = list.cursor();\n+        final Iterator<E> li = list.iterator();\n \n         // test cursors remain valid when list modified by std Iterator\n         // test cursors skip elements removed via ListIterator\n         try {\n             c2.next();\n             fail();\n-        } catch (NoSuchElementException nse) {\n+        } catch (final NoSuchElementException nse) {\n         }\n \n         try {\n             li.next();\n             fail();\n-        } catch (ConcurrentModificationException cme) {\n+        } catch (final ConcurrentModificationException cme) {\n         }\n \n         c1.close(); // not necessary\n         list.add((E) \"3\");\n         list.add((E) \"5\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n-        Iterator<E> li = list.iterator();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final Iterator<E> li = list.iterator();\n \n         // test cursors remain valid when list modified by std Iterator\n         // test cursors skip elements removed via ListIterator\n         list.add((E) \"3\");\n         list.add((E) \"5\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n \n         assertEquals(0, c1.nextIndex());\n         list.remove(0);\n         list.add((E) \"3\");\n         list.add((E) \"5\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n \n         assertEquals(0, c1.nextIndex());\n         assertEquals(\"1\", c1.next());\n         list.add((E) \"3\");\n         list.add((E) \"5\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n \n         assertEquals(0, c1.nextIndex());\n         list.add(0, (E) \"0\");\n         list.add((E) \"3\");\n         list.add((E) \"5\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n \n         assertEquals(0, c1.nextIndex());\n         list.add(1, (E) \"0\");\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n         assertEquals(\"B\", c1.previous());\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n \n         assertEquals(\"B\", list.remove(1));\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n \n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"C\");\n         list.add((E) \"D\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n         assertEquals(\"C\", c1.next());\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n         assertEquals(\"B\", c1.previous());\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n \n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n         assertEquals(\"B\", c1.previous());\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n \n         list.add(1, (E) \"Z\");\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n \n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n         assertEquals(\"B\", c1.previous());\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n \n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n \n         try {\n             c1.set((E) \"Z\");\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n         assertEquals(\"B\", c1.previous());\n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         list.add((E) \"B\");\n         list.add((E) \"C\");\n \n-        CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n         assertEquals(\"A\", c1.next());\n         assertEquals(\"B\", c1.next());\n \n         try {\n             c1.remove();\n             fail();\n-        } catch (IllegalStateException ex) {}\n+        } catch (final IllegalStateException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n         assertTrue(list.equals(list));\n         assertEquals(list.hashCode(),list.hashCode());\n \n-        CursorableLinkedList<E> list2 = new CursorableLinkedList<E>();\n+        final CursorableLinkedList<E> list2 = new CursorableLinkedList<E>();\n         assertTrue(!list.equals(list2));\n         assertTrue(!list2.equals(list));\n \n-        java.util.List<E> list3 = new java.util.LinkedList<E>();\n+        final java.util.List<E> list3 = new java.util.LinkedList<E>();\n         assertTrue(!list.equals(list3));\n         assertTrue(!list3.equals(list));\n         assertTrue(list2.equals(list3));\n         try {\n             list.get(0);\n             fail(\"shouldn't get here\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(-1);\n             fail(\"shouldn't get here\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n \n         try {\n             list.get(2);\n             fail(\"shouldn't get here\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n         list.add((E) \"3\");\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n-        ListIterator<E> it = list.listIterator();\n+        final ListIterator<E> it = list.listIterator();\n         assertTrue(it.hasNext());\n         assertTrue(!it.hasPrevious());\n         assertEquals(-1, it.previousIndex());\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n \n-        ListIterator<E> it = list.listIterator();\n+        final ListIterator<E> it = list.listIterator();\n         assertEquals(\"1\", it.next());\n         it.set((E) \"a\");\n         assertEquals(\"a\", it.previous());\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n \n-        ListIterator<E> it = list.listIterator();\n+        final ListIterator<E> it = list.listIterator();\n         try {\n             it.remove();\n-        } catch(IllegalStateException e) {\n+        } catch(final IllegalStateException e) {\n             // expected\n         }\n         assertEquals(\"1\",it.next());\n         assertEquals(\"[4, 5]\",list.toString());\n         try {\n             it.remove();\n-        } catch(IllegalStateException e) {\n+        } catch(final IllegalStateException e) {\n             // expected\n         }\n         assertEquals(\"4\",it.next());\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public void testListIteratorAdd() {\n-        ListIterator<E> it = list.listIterator();\n+        final ListIterator<E> it = list.listIterator();\n         it.add((E) \"1\");\n         assertEquals(\"[1]\", list.toString());\n         it.add((E) \"3\");\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n \n-        HashSet<E> set = new HashSet<E>();\n+        final HashSet<E> set = new HashSet<E>();\n         set.add((E) \"A\");\n         set.add((E) \"2\");\n         set.add((E) \"C\");\n         list.add((E) \"5\");\n         list.add((E) \"5\");\n \n-        HashSet<E> set = new HashSet<E>();\n+        final HashSet<E> set = new HashSet<E>();\n         set.add((E) \"A\");\n         set.add((E) \"2\");\n         set.add((E) \"C\");\n         list.add((E) \"D\");\n         list.add((E) \"E\");\n \n-        List<E> sublist = list.subList(5, 5);\n+        final List<E> sublist = list.subList(5, 5);\n         sublist.add((E) \"F\");\n         assertEquals(\"[A, B, C, D, E, F]\", list.toString());\n         assertEquals(\"[F]\", sublist.toString());\n         list.add((E) \"D\");\n         list.add((E) \"E\");\n \n-        List<E> sublist = list.subList(0, 0);\n+        final List<E> sublist = list.subList(0, 0);\n         sublist.add((E) \"a\");\n         assertEquals(\"[a, A, B, C, D, E]\", list.toString());\n         assertEquals(\"[a]\", sublist.toString());\n         list.add((E) \"D\");\n         list.add((E) \"E\");\n \n-        List<E> sublist = list.subList(1, 3);\n+        final List<E> sublist = list.subList(1, 3);\n         sublist.add((E) \"a\");\n         assertEquals(\"[A, B, C, a, D, E]\", list.toString());\n         assertEquals(\"[B, C, a]\", sublist.toString());\n         list.add((E) \"D\");\n         list.add((E) \"E\");\n \n-        List<E> sublist = list.subList(1, 4);\n+        final List<E> sublist = list.subList(1, 4);\n         assertEquals(\"[B, C, D]\", sublist.toString());\n         assertEquals(\"[A, B, C, D, E]\", list.toString());\n         sublist.remove(\"C\");\n         list.add((E) \"4\");\n         list.add((E) \"5\");\n \n-        Object[] elts = list.toArray();\n+        final Object[] elts = list.toArray();\n         assertEquals(\"1\", elts[0]);\n         assertEquals(\"2\", elts[1]);\n         assertEquals(\"3\", elts[2]);\n         assertEquals(\"5\", elts[4]);\n         assertEquals(5, elts.length);\n \n-        String[] elts2 = list.toArray(new String[0]);\n+        final String[] elts2 = list.toArray(new String[0]);\n         assertEquals(\"1\", elts2[0]);\n         assertEquals(\"2\", elts2[1]);\n         assertEquals(\"3\", elts2[2]);\n         assertEquals(\"5\", elts2[4]);\n         assertEquals(5, elts2.length);\n \n-        String[] elts3 = new String[5];\n+        final String[] elts3 = new String[5];\n         assertSame(elts3, list.toArray(elts3));\n         assertEquals(\"1\", elts3[0]);\n         assertEquals(\"2\", elts3[1]);\n         assertEquals(\"5\", elts3[4]);\n         assertEquals(5, elts3.length);\n \n-        String[] elts4 = new String[3];\n-        String[] elts4b = list.toArray(elts4);\n+        final String[] elts4 = new String[3];\n+        final String[] elts4b = list.toArray(elts4);\n         assertTrue(elts4 != elts4b);\n         assertEquals(\"1\", elts4b[0]);\n         assertEquals(\"2\", elts4b[1]);\n         list.add((E) \"D\");\n         list.add((E) \"E\");\n \n-        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n-        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n         out.writeObject(list);\n         out.flush();\n         out.close();\n \n-        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n-        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n-        Object list2 = in.readObject();\n+        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        final Object list2 = in.readObject();\n \n         assertTrue(list != list2);\n         assertTrue(list2.equals(list));\n         list.add((E) \"C\");\n         list.add((E) \"D\");\n         list.add((E) \"E\");\n-        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n-        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n         out.writeObject(list);\n         out.flush();\n         out.close();\n \n-        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n-        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n-        Object list2 = in.readObject();\n+        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        final Object list2 = in.readObject();\n \n         assertTrue(list != list2);\n         assertTrue(list2.equals(list));\n             list.add((E) new Integer(i));\n         }\n \n-        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n-        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n         out.writeObject(list);\n         out.flush();\n         out.close();\n \n-        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n-        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n-        Object list2 = in.readObject();\n+        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        final Object list2 = in.readObject();\n \n         assertTrue(list != list2);\n         assertTrue(list2.equals(list));\n      */\n     @Override\n     public String[] ignoredTests() {\n-        ArrayList<String> list = new ArrayList<String>();\n-        String prefix = \"CursorableLinkedListTest\";\n-        String bulk = \".bulkTestSubList\";\n-        String[] ignored = new String[] {\n+        final ArrayList<String> list = new ArrayList<String>();\n+        final String prefix = \"CursorableLinkedListTest\";\n+        final String bulk = \".bulkTestSubList\";\n+        final String[] ignored = new String[] {\n                 \".testEmptyListSerialization\",\n                 \".testFullListSerialization\",\n                 \".testEmptyListCompatibility\",\n                 \".testCanonicalFullCollectionExists\",\n                 \".testSerializeDeserializeThenCompare\"\n         };\n-        for (String element : ignored) {\n+        for (final String element : ignored) {\n             list.add(prefix + bulk + element);\n             list.add(prefix + bulk + bulk + element);\n         }\n--- a/src/test/java/org/apache/commons/collections/list/FixedSizeListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/FixedSizeListTest.java\n  */\n public class FixedSizeListTest<E> extends AbstractListTest<E> {\n \n-    public FixedSizeListTest(String testName) {\n+    public FixedSizeListTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public List<E> makeFullCollection() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return FixedSizeList.fixedSizeList(list);\n     }\n--- a/src/test/java/org/apache/commons/collections/list/GrowthListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/GrowthListTest.java\n  */\n public class GrowthListTest<E> extends AbstractListTest<E> {\n \n-    public GrowthListTest(String testName) {\n+    public GrowthListTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public List<E> makeFullCollection() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return GrowthList.growthList(list);\n     }\n \n     //-----------------------------------------------------------------------\n     public void testGrowthAdd() {\n-        Integer one = new Integer(1);\n-        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        final Integer one = new Integer(1);\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.add(1, one);\n         assertEquals(2, grower.size());\n     }\n \n     public void testGrowthAddAll() {\n-        Integer one = new Integer(1);\n-        Integer two = new Integer(2);\n-        Collection<Integer> coll = new ArrayList<Integer>();\n+        final Integer one = new Integer(1);\n+        final Integer two = new Integer(2);\n+        final Collection<Integer> coll = new ArrayList<Integer>();\n         coll.add(one);\n         coll.add(two);\n-        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.addAll(1, coll);\n         assertEquals(3, grower.size());\n     }\n \n     public void testGrowthSet1() {\n-        Integer one = new Integer(1);\n-        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        final Integer one = new Integer(1);\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.set(1, one);\n         assertEquals(2, grower.size());\n     }\n \n     public void testGrowthSet2() {\n-        Integer one = new Integer(1);\n-        GrowthList<Integer> grower = new GrowthList<Integer>();\n+        final Integer one = new Integer(1);\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n         assertEquals(0, grower.size());\n         grower.set(0, one);\n         assertEquals(1, grower.size());\n     @Override\n     public void testListAddByIndexBoundsChecking() {\n         List<E> list;\n-        E element = getOtherElements()[0];\n+        final E element = getOtherElements()[0];\n         try {\n             list = makeObject();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n     @Override\n     public void testListAddByIndexBoundsChecking2() {\n         List<E> list;\n-        E element = getOtherElements()[0];\n+        final E element = getOtherElements()[0];\n         try {\n             list = makeFullCollection();\n             list.add(-1, element);\n             fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n      */\n     @Override\n     public void testListSetByIndexBoundsChecking() {\n-        List<E> list = makeObject();\n-        E element = getOtherElements()[0];\n+        final List<E> list = makeObject();\n+        final E element = getOtherElements()[0];\n         try {\n             list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (final IndexOutOfBoundsException e) {\n             // expected\n         }\n     }\n      */\n     @Override\n     public void testListSetByIndexBoundsChecking2() {\n-        List<E> list = makeFullCollection();\n-        E element = getOtherElements()[0];\n+        final List<E> list = makeFullCollection();\n+        final E element = getOtherElements()[0];\n         try {\n             list.set(-1, element);\n             fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n-        } catch(IndexOutOfBoundsException e) {\n+        } catch(final IndexOutOfBoundsException e) {\n             // expected\n         } \n     }\n--- a/src/test/java/org/apache/commons/collections/list/NodeCachingLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/NodeCachingLinkedListTest.java\n  */\n public class NodeCachingLinkedListTest<E> extends AbstractLinkedListTest<E> {\n \n-    public NodeCachingLinkedListTest(String testName) {\n+    public NodeCachingLinkedListTest(final String testName) {\n         super(testName);\n     }\n \n             return;\n         }\n         resetEmpty();\n-        NodeCachingLinkedList<E> list = getCollection();\n+        final NodeCachingLinkedList<E> list = getCollection();\n \n         list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n         list.removeAllNodes(); // Will dump all 4 elements into cache\n \n     //-----------------------------------------------------------------------\n     public static void compareSpeed() {\n-        NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<Object>();\n-        LinkedList<Object> ll = new LinkedList<Object>();\n+        final NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<Object>();\n+        final LinkedList<Object> ll = new LinkedList<Object>();\n \n-        Object o1 = new Object();\n-        Object o2 = new Object();\n+        final Object o1 = new Object();\n+        final Object o2 = new Object();\n \n-        int loopCount = 4000000;\n+        final int loopCount = 4000000;\n \n         long startTime, endTime;\n \n--- a/src/test/java/org/apache/commons/collections/list/PredicatedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/PredicatedListTest.java\n  */\n public class PredicatedListTest<E> extends AbstractListTest<E> {\n \n-    public PredicatedListTest(String testName) {\n+    public PredicatedListTest(final String testName) {\n         super(testName);\n     }\n \n \n     protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n \n-    protected List<E> decorateList(List<E> list, Predicate<E> predicate) {\n+    protected List<E> decorateList(final List<E> list, final Predicate<E> predicate) {\n         return PredicatedList.predicatedList(list, predicate);\n     }\n \n \n     protected Predicate<E> testPredicate =\n         new Predicate<E>() {\n-            public boolean evaluate(E o) {\n+            public boolean evaluate(final E o) {\n                 return o instanceof String;\n             }\n         };\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        List<E> list = makeTestList();\n-        Integer i = new Integer(3);\n+        final List<E> list = makeTestList();\n+        final Integer i = new Integer(3);\n         try {\n             list.add((E) i);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\",\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        List<E> list = makeTestList();\n-        List<E> elements = new ArrayList<E>();\n+        final List<E> list = makeTestList();\n+        final List<E> elements = new ArrayList<E>();\n         elements.add((E) \"one\");\n         elements.add((E) \"two\");\n         elements.add((E) new Integer(3));\n         try {\n             list.addAll(0, elements);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"List shouldn't contain illegal element\",\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalSet() {\n-        List<E> list = makeTestList();\n+        final List<E> list = makeTestList();\n         try {\n             list.set(0, (E) new Integer(3));\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testLegalAddAll() {\n-        List<E> list = makeTestList();\n+        final List<E> list = makeTestList();\n         list.add((E) \"zero\");\n-        List<E> elements = new ArrayList<E>();\n+        final List<E> elements = new ArrayList<E>();\n         elements.add((E) \"one\");\n         elements.add((E) \"two\");\n         elements.add((E) \"three\");\n--- a/src/test/java/org/apache/commons/collections/list/SetUniqueListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/SetUniqueListTest.java\n  */\n public class SetUniqueListTest<E> extends AbstractListTest<E> {\n \n-    public SetUniqueListTest(String testName) {\n+    public SetUniqueListTest(final String testName) {\n         super(testName);\n     }\n \n     public void testListIteratorSet() {\n         // override to block\n         resetFull();\n-        ListIterator<E> it = getCollection().listIterator();\n+        final ListIterator<E> it = getCollection().listIterator();\n         it.next();\n         try {\n             it.set(null);\n             fail();\n-        } catch (UnsupportedOperationException ex) {}\n+        } catch (final UnsupportedOperationException ex) {}\n     }\n \n     @Override\n     public void testListIteratorAdd() {\n         // override to cope with Set behaviour\n         resetEmpty();\n-        List<E> list1 = getCollection();\n-        List<E> list2 = getConfirmed();\n-\n-        E[] elements = getOtherElements();  // changed here\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final E[] elements = getOtherElements();  // changed here\n         ListIterator<E> iter1 = list1.listIterator();\n         ListIterator<E> iter2 = list2.listIterator();\n \n-        for (E element : elements) {\n+        for (final E element : elements) {\n             iter1.add(element);\n             iter2.add(element);\n             super.verify();  // changed here\n         resetFull();\n         iter1 = getCollection().listIterator();\n         iter2 = getConfirmed().listIterator();\n-        for (E element : elements) {\n+        for (final E element : elements) {\n             iter1.next();\n             iter2.next();\n             iter1.add(element);\n         getConfirmed().addAll(Arrays.asList(elements));\n         verify();\n         assertTrue(\"Empty collection should change after addAll\", r);\n-        for (E element : elements) {\n+        for (final E element : elements) {\n             assertTrue(\"Collection should contain added element\",\n                     getCollection().contains(element));\n         }\n \n         resetFull();\n-        int size = getCollection().size();\n+        final int size = getCollection().size();\n         elements = getOtherElements();\n         r = getCollection().addAll(Arrays.asList(elements));\n         getConfirmed().addAll(Arrays.asList(elements));\n \n     public void testIntCollectionAddAll() {\n       // make a SetUniqueList with one element\n-      List<Integer> list = new SetUniqueList<Integer>(new ArrayList<Integer>(), new HashSet<Integer>());\n+      final List<Integer> list = new SetUniqueList<Integer>(new ArrayList<Integer>(), new HashSet<Integer>());\n       final Integer existingElement = new Integer(1);\n       list.add(existingElement);\n \n     public void testListSetByIndex() {\n         // override for set behaviour\n         resetFull();\n-        int size = getCollection().size();\n+        final int size = getCollection().size();\n         getCollection().set(0, (E) new Long(1000));\n         assertEquals(size, getCollection().size());\n \n         super.verify();\n \n         if (extraVerify) {\n-            int size = getCollection().size();\n+            final int size = getCollection().size();\n             getCollection().add((E) new Long(1000));\n             assertEquals(size + 1, getCollection().size());\n \n \n     //-----------------------------------------------------------------------\n     public void testFactory() {\n-        Integer[] array = new Integer[] { new Integer(1), new Integer(2), new Integer(1) };\n-        ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(array));\n+        final Integer[] array = new Integer[] { new Integer(1), new Integer(2), new Integer(1) };\n+        final ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(array));\n         final SetUniqueList<Integer> lset = SetUniqueList.setUniqueList(list);\n \n         assertEquals(\"Duplicate element was added.\", 2, lset.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testUniqueListReInsert() {\n-        List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n+        final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n         l.add((E) new Object());\n         l.add((E) new Object());\n \n-        E a = l.get(0);\n+        final E a = l.get(0);\n \n         // duplicate is removed\n         l.set(0, l.get(1));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testUniqueListDoubleInsert() {\n-        List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n+        final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n         l.add((E) new Object());\n         l.add((E) new Object());\n \n          * set(0,b): [b]->a\n          * So UniqList contains [b] and a is returned\n          */\n-        ArrayList<E> l = new ArrayList<E>();\n-        HashSet<E> s = new HashSet<E>();\n+        final ArrayList<E> l = new ArrayList<E>();\n+        final HashSet<E> s = new HashSet<E>();\n         final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n \n-        E a = (E) new Object();\n-        E b = (E) new Object();\n+        final E a = (E) new Object();\n+        final E b = (E) new Object();\n         ul.add(a);\n         ul.add(b);\n         assertEquals(a, l.get(0));\n          * set(0,b): [b,c]->a\n          * So UniqList contains [b,c] and a is returned\n          */\n-        ArrayList<E> l = new ArrayList<E>();\n-        HashSet<E> s = new HashSet<E>();\n+        final ArrayList<E> l = new ArrayList<E>();\n+        final HashSet<E> s = new HashSet<E>();\n         final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n \n-        E a = (E) new Object();\n-        E b = (E) new Object();\n-        E c = (E) new Object();\n+        final E a = (E) new Object();\n+        final E b = (E) new Object();\n+        final E c = (E) new Object();\n \n         ul.add(a);\n         ul.add(b);\n          * set(1,a): [a,c]->b\n          * So UniqList contains [a,c] and b is returned\n          */\n-        ArrayList<E> l = new ArrayList<E>();\n-        HashSet<E> s = new HashSet<E>();\n+        final ArrayList<E> l = new ArrayList<E>();\n+        final HashSet<E> s = new HashSet<E>();\n         final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n \n-        E a = (E) new String(\"A\");\n-        E b = (E) new String(\"B\");\n-        E c = (E) new String(\"C\");\n+        final E a = (E) new String(\"A\");\n+        final E b = (E) new String(\"B\");\n+        final E c = (E) new String(\"C\");\n \n         ul.add(a);\n         ul.add(b);\n \n     // TODO: Generics\n     public void testCollections304() {\n-        List<String> list = new LinkedList<String>();\n-        SetUniqueList<String> decoratedList = SetUniqueList.setUniqueList(list);\n-        String s1 = \"Apple\";\n-        String s2 = \"Lemon\";\n-        String s3 = \"Orange\";\n-        String s4 = \"Strawberry\";\n+        final List<String> list = new LinkedList<String>();\n+        final SetUniqueList<String> decoratedList = SetUniqueList.setUniqueList(list);\n+        final String s1 = \"Apple\";\n+        final String s2 = \"Lemon\";\n+        final String s3 = \"Orange\";\n+        final String s4 = \"Strawberry\";\n \n         decoratedList.add(s1);\n         decoratedList.add(s2);\n         List<E> list = new ArrayList<E>();\n         List<E> uniqueList = SetUniqueList.setUniqueList(list);\n \n-        String hello = \"Hello\";\n-        String world = \"World\";\n+        final String hello = \"Hello\";\n+        final String world = \"World\";\n         uniqueList.add((E) hello);\n         uniqueList.add((E) world);\n \n \n     @SuppressWarnings(\"unchecked\")\n \tpublic void testRetainAll() {\n-    \tList<E> list = new ArrayList<E>(10);\n-    \tSetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n+    \tfinal List<E> list = new ArrayList<E>(10);\n+    \tfinal SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n     \tfor (int i = 0; i < 10; ++i) {\n     \t\tuniqueList.add((E)Integer.valueOf(i));\n     \t}\n     \t\n-    \tCollection<E> retained = new ArrayList<E>(5);\n+    \tfinal Collection<E> retained = new ArrayList<E>(5);\n     \tfor (int i = 0; i < 5; ++i) {\n     \t\tretained.add((E)Integer.valueOf(i * 2));\n     \t}\n     @SuppressWarnings(\"unchecked\")\n \tpublic void testRetainAllWithInitialList() {\n     \t// initialized with empty list\n-    \tList<E> list = new ArrayList<E>(10);\n+    \tfinal List<E> list = new ArrayList<E>(10);\n     \tfor (int i = 0; i < 5; ++i) {\n     \t\tlist.add((E)Integer.valueOf(i));\n     \t}\n-    \tSetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n+    \tfinal SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n     \tfor (int i = 5; i < 10; ++i) {\n     \t\tuniqueList.add((E)Integer.valueOf(i));\n     \t}\n     \t\n-    \tCollection<E> retained = new ArrayList<E>(5);\n+    \tfinal Collection<E> retained = new ArrayList<E>(5);\n     \tfor (int i = 0; i < 5; ++i) {\n     \t\tretained.add((E)Integer.valueOf(i * 2));\n     \t}\n      * test case for https://issues.apache.org/jira/browse/COLLECTIONS-427\n      */\n     public void testRetainAllCollections427() {\n-        int size = 50000;\n-        ArrayList<Integer> list = new ArrayList<Integer>();\n+        final int size = 50000;\n+        final ArrayList<Integer> list = new ArrayList<Integer>();\n         for (int i = 0; i < size; i++) {\n             list.add(i);\n         }\n-        SetUniqueList<Integer> uniqueList = SetUniqueList.setUniqueList(list);\n-        ArrayList<Integer> toRetain = new ArrayList<Integer>();\n+        final SetUniqueList<Integer> uniqueList = SetUniqueList.setUniqueList(list);\n+        final ArrayList<Integer> toRetain = new ArrayList<Integer>();\n         for (int i = size; i < 2*size; i++) {\n             toRetain.add(i);\n         }\n \n-        long start = System.currentTimeMillis();\n+        final long start = System.currentTimeMillis();\n         uniqueList.retainAll(toRetain);\n-        long stop = System.currentTimeMillis();\n+        final long stop = System.currentTimeMillis();\n         \n         // make sure retainAll completes under 5 seconds\n         // TODO if test is migrated to JUnit 4, add a Timeout rule.\n     \n     @SuppressWarnings(\"serial\")\n     class SetUniqueList307 extends SetUniqueList<E> {\n-        public SetUniqueList307(List<E> list, Set<E> set) {\n+        public SetUniqueList307(final List<E> list, final Set<E> set) {\n             super(list, set);\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/list/SynchronizedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/SynchronizedListTest.java\n  */\n public class SynchronizedListTest<E> extends AbstractListTest<E> {\n \n-    public SynchronizedListTest(String testName) {\n+    public SynchronizedListTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/list/TransformedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/TransformedListTest.java\n  */\n public class TransformedListTest<E> extends AbstractListTest<E> {\n \n-    public TransformedListTest(String testName) {\n+    public TransformedListTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public List<E> makeConfirmedFullCollection() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public List<E> makeFullCollection() {\n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return TransformedList.transformingList(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedList() {\n-        List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, list.size());\n-        E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        final E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n         for (int i = 0; i < els.length; i++) {\n             list.add(els[i]);\n             assertEquals(i + 1, list.size());\n         list.set(0, (E) \"22\");\n         assertEquals(new Integer(22), list.get(0));\n \n-        ListIterator<E> it = list.listIterator();\n+        final ListIterator<E> it = list.listIterator();\n         it.next();\n         it.set((E) \"33\");\n         assertEquals(new Integer(33), list.get(0));\n         it.add((E) \"44\");\n         assertEquals(new Integer(44), list.get(1));\n \n-        List<E> adds = new ArrayList<E>();\n+        final List<E> adds = new ArrayList<E>();\n         adds.add((E) \"1\");\n         adds.add((E) \"2\");\n         list.clear();\n     }\n \n     public void testTransformedList_decorateTransform() {\n-        List<Object> originalList = new ArrayList<Object>();\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n-        for (Object el : els) {\n+        final List<Object> originalList = new ArrayList<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n             originalList.add(el);\n         }\n-        List<?> list = TransformedList.transformedList(originalList, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final List<?> list = TransformedList.transformedList(originalList, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, list.size());\n-        for (Object el : els) {\n+        for (final Object el : els) {\n             assertEquals(true, list.contains(new Integer((String) el)));\n             assertEquals(false, list.contains(el));\n         }\n--- a/src/test/java/org/apache/commons/collections/list/TreeListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/TreeListTest.java\n  */\n public class TreeListTest<E> extends AbstractListTest<E> {\n \n-    public TreeListTest(String name) {\n+    public TreeListTest(final String name) {\n         super(name);\n     }\n \n         return BulkTest.makeSuite(TreeListTest.class);\n     }\n \n-    public static void benchmark(List<? super Integer> l) {\n+    public static void benchmark(final List<? super Integer> l) {\n         long start = System.currentTimeMillis();\n         for (int i = 0; i < 100000; i++) {\n             l.add(new Integer(i));\n \n         start = System.currentTimeMillis();\n         for (int i = 0; i < 100; i++) {\n-            java.util.Iterator<? super Integer> it = l.iterator();\n+            final java.util.Iterator<? super Integer> it = l.iterator();\n             while (it.hasNext()) {\n                 it.next();\n             }\n \n         start = System.currentTimeMillis();\n         for (int i = 0; i < 10000; i++) {\n-            int j = (int) (Math.random() * 100000);\n+            final int j = (int) (Math.random() * 100000);\n             l.add(j, new Integer(-j));\n         }\n         System.out.print(System.currentTimeMillis() - start + \";\");\n \n         start = System.currentTimeMillis();\n         for (int i = 0; i < 50000; i++) {\n-            int j = (int) (Math.random() * 110000);\n+            final int j = (int) (Math.random() * 110000);\n             l.get(j);\n         }\n         System.out.print(System.currentTimeMillis() - start + \";\");\n \n         start = System.currentTimeMillis();\n         for (int i = 0; i < 200; i++) {\n-            int j = (int) (Math.random() * 100000);\n+            final int j = (int) (Math.random() * 100000);\n             l.indexOf(new Integer(j));\n         }\n         System.out.print(System.currentTimeMillis() - start + \";\");\n \n         start = System.currentTimeMillis();\n         for (int i = 0; i < 10000; i++) {\n-            int j = (int) (Math.random() * 100000);\n+            final int j = (int) (Math.random() * 100000);\n             l.remove(j);\n         }\n         System.out.print(System.currentTimeMillis() - start + \";\");\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testAddMultiple() {\n-        List<E> l = makeObject();\n+        final List<E> l = makeObject();\n         l.add((E) \"hugo\");\n         l.add((E) \"erna\");\n         l.add((E) \"daniel\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemove() {\n-        List<E> l = makeObject();\n+        final List<E> l = makeObject();\n         l.add((E) \"hugo\");\n         l.add((E) \"erna\");\n         l.add((E) \"daniel\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testInsertBefore() {\n-        List<E> l = makeObject();\n+        final List<E> l = makeObject();\n         l.add((E) \"erna\");\n         l.add(0, (E) \"hugo\");\n         assertEquals(\"hugo\", l.get(0));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIndexOf() {\n-        List<E> l = makeObject();\n+        final List<E> l = makeObject();\n         l.add((E) \"0\");\n         l.add((E) \"1\");\n         l.add((E) \"2\");\n //    }\n \n     public void testBug35258() {\n-        Object objectToRemove = new Integer(3);\n-\n-        List<Integer> treelist = new TreeList<Integer>();\n+        final Object objectToRemove = new Integer(3);\n+\n+        final List<Integer> treelist = new TreeList<Integer>();\n         treelist.add(new Integer(0));\n         treelist.add(new Integer(1));\n         treelist.add(new Integer(2));\n         // this cause inconsistence of ListIterator()\n         treelist.remove(objectToRemove);\n \n-        ListIterator<Integer> li = treelist.listIterator();\n+        final ListIterator<Integer> li = treelist.listIterator();\n         assertEquals(new Integer(0), li.next());\n         assertEquals(new Integer(0), li.previous());\n         assertEquals(new Integer(0), li.next());\n--- a/src/test/java/org/apache/commons/collections/list/UnmodifiableListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/UnmodifiableListTest.java\n  */\n public class UnmodifiableListTest<E> extends AbstractListTest<E> {\n \n-    public UnmodifiableListTest(String testName) {\n+    public UnmodifiableListTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public UnmodifiableList<E> makeFullCollection() {\n-        ArrayList<E> list = new ArrayList<E>();\n+        final ArrayList<E> list = new ArrayList<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return new UnmodifiableList<E>(list);\n     }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    protected void verifyUnmodifiable(List<E> list) {\n+    protected void verifyUnmodifiable(final List<E> list) {\n         try {\n             list.add(0, (E) new Integer(0));\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.add((E) new Integer(0));\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.addAll(0, array);\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.addAll(array);\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.clear();\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.remove(0);\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.remove(new Integer(0));\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.removeAll(array);\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.retainAll(array);\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             list.set(0, (E) new Integer(0));\n              fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n     }\n      */\n     public void testUnmodifiableIterator() {\n         setupList();\n-        Iterator<E> iterator = list.iterator();\n+        final Iterator<E> iterator = list.iterator();\n         try {\n             iterator.next();\n             iterator.remove();\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/map/AbstractIterableMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractIterableMapTest.java\n      *\n      * @param testName  the test name\n      */\n-    public AbstractIterableMapTest(String testName) {\n+    public AbstractIterableMapTest(final String testName) {\n         super(testName);\n     }\n \n         }\n         resetFull();\n         Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();\n-        Map.Entry<K, V> val = it.next();\n+        final Map.Entry<K, V> val = it.next();\n         getMap().remove(val.getKey());\n         try {\n             it.next();\n             fail();\n-        } catch (ConcurrentModificationException ex) {}\n+        } catch (final ConcurrentModificationException ex) {}\n \n         resetFull();\n         it = getMap().entrySet().iterator();\n         try {\n             it.next();\n             fail();\n-        } catch (ConcurrentModificationException ex) {}\n+        } catch (final ConcurrentModificationException ex) {}\n     }\n \n     public void testFailFastKeySet() {\n         }\n         resetFull();\n         Iterator<K> it = getMap().keySet().iterator();\n-        K val = it.next();\n+        final K val = it.next();\n         getMap().remove(val);\n         try {\n             it.next();\n             fail();\n-        } catch (ConcurrentModificationException ex) {}\n+        } catch (final ConcurrentModificationException ex) {}\n \n         resetFull();\n         it = getMap().keySet().iterator();\n         try {\n             it.next();\n             fail();\n-        } catch (ConcurrentModificationException ex) {}\n+        } catch (final ConcurrentModificationException ex) {}\n     }\n \n     public void testFailFastValues() {\n         try {\n             it.next();\n             fail();\n-        } catch (ConcurrentModificationException ex) {}\n+        } catch (final ConcurrentModificationException ex) {}\n \n         resetFull();\n         it = getMap().values().iterator();\n         try {\n             it.next();\n             fail();\n-        } catch (ConcurrentModificationException ex) {}\n+        } catch (final ConcurrentModificationException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections/map/AbstractMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractMapTest.java\n      */\n     private static final boolean JDK12;\n     static {\n-        String str = System.getProperty(\"java.version\");\n+        final String str = System.getProperty(\"java.version\");\n         JDK12 = str.startsWith(\"1.2\");\n     }\n \n      *\n      * @param testName  the test name\n      */\n-    public AbstractMapTest(String testName) {\n+    public AbstractMapTest(final String testName) {\n         super(testName);\n     }\n \n      */\n     @SuppressWarnings(\"unchecked\")\n     public K[] getSampleKeys() {\n-        Object[] result = new Object[] {\n+        final Object[] result = new Object[] {\n             \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\",\n             \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n             \"key\",\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    protected <E> List<E> getAsList(Object[] o) {\n-        ArrayList<E> result = new ArrayList<E>();\n-        for (Object element : o) {\n+    protected <E> List<E> getAsList(final Object[] o) {\n+        final ArrayList<E> result = new ArrayList<E>();\n+        for (final Object element : o) {\n             result.add((E) element);\n         }\n         return result;\n      */\n     @SuppressWarnings(\"unchecked\")\n     public V[] getSampleValues() {\n-        Object[] result = new Object[] {\n+        final Object[] result = new Object[] {\n             \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n             \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n             isAllowNullValue() && !JDK12 ? null : \"nonnullvalue\",\n      */\n     @SuppressWarnings(\"unchecked\")\n     public V[] getNewSampleValues() {\n-        Object[] result = new Object[] {\n+        final Object[] result = new Object[] {\n             isAllowNullValue() && !JDK12 && isAllowDuplicateValues() ? null : \"newnonnullvalue\",\n             \"newvalue\",\n             isAllowDuplicateValues() ? \"newvalue\" : \"newvalue2\",\n      *  Helper method to add all the mappings described by\n      * {@link #getSampleKeys()} and {@link #getSampleValues()}.\n      */\n-    public void addSampleMappings(Map<? super K, ? super V> m) {\n-\n-        K[] keys = getSampleKeys();\n-        V[] values = getSampleValues();\n+    public void addSampleMappings(final Map<? super K, ? super V> m) {\n+\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n \n         for (int i = 0; i < keys.length; i++) {\n             try {\n                 m.put(keys[i], values[i]);\n-            } catch (NullPointerException exception) {\n+            } catch (final NullPointerException exception) {\n                 assertTrue(\"NullPointerException only allowed to be thrown \" +\n                            \"if either the key or value is null.\",\n                            keys[i] == null || values[i] == null);\n      * @return the map to be tested\n      */\n     public Map<K, V> makeFullMap() {\n-        Map<K, V> m = makeObject();\n+        final Map<K, V> m = makeObject();\n         addSampleMappings(m);\n         return m;\n     }\n     /**\n      * Creates a new Map Entry that is independent of the first and the map.\n      */\n-    public static <K, V> Map.Entry<K, V> cloneMapEntry(Map.Entry<K, V> entry) {\n-        HashMap<K, V> map = new HashMap<K, V>();\n+    public static <K, V> Map.Entry<K, V> cloneMapEntry(final Map.Entry<K, V> entry) {\n+        final HashMap<K, V> map = new HashMap<K, V>();\n         map.put(entry.getKey(), entry.getValue());\n         return map.entrySet().iterator().next();\n     }\n      * isAllowDuplicateValues() returns true.\n      */\n     public void testSampleMappings() {\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        Object[] newValues = getNewSampleValues();\n+        final Object[] keys = getSampleKeys();\n+        final Object[] values = getSampleValues();\n+        final Object[] newValues = getNewSampleValues();\n \n         assertNotNull(\"failure in test: Must have keys returned from \" +\n                  \"getSampleKeys.\", keys);\n      * map with each invocation.\n      */\n     public void testMakeMap() {\n-        Map<K, V> em = makeObject();\n+        final Map<K, V> em = makeObject();\n         assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n                    em != null);\n \n-        Map<K, V> em2 = makeObject();\n+        final Map<K, V> em2 = makeObject();\n         assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n                    em != null);\n \n         assertTrue(\"failure in test: makeEmptyMap must return a new map \" +\n                    \"with each invocation.\", em != em2);\n \n-        Map<K, V> fm = makeFullMap();\n+        final Map<K, V> fm = makeFullMap();\n         assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n                    fm != null);\n \n-        Map<K, V> fm2 = makeFullMap();\n+        final Map<K, V> fm2 = makeFullMap();\n         assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n                    fm != null);\n \n                 resetFull();\n                 getMap().clear();\n                 fail(\"Expected UnsupportedOperationException on clear\");\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n             return;\n         }\n \n      * all sample keys returned on a full map.\n      */\n     public void testMapContainsKey() {\n-        Object[] keys = getSampleKeys();\n+        final Object[] keys = getSampleKeys();\n \n         resetEmpty();\n         for(int i = 0; i < keys.length; i++) {\n         verify();\n \n         resetFull();\n-        for (Object key : keys) {\n+        for (final Object key : keys) {\n             assertTrue(\"Map must contain key for a mapping in the map. \" +\n                        \"Missing: \" + key, getMap().containsKey(key));\n         }\n      * a full map.\n      */\n     public void testMapContainsValue() {\n-        Object[] values = getSampleValues();\n+        final Object[] values = getSampleValues();\n \n         resetEmpty();\n         for(int i = 0; i < values.length; i++) {\n         verify();\n \n         resetFull();\n-        for (Object value : values) {\n+        for (final Object value : values) {\n             assertTrue(\"Map must contain value for a mapping in the map.\",\n                     getMap().containsValue(value));\n         }\n         resetFull();\n         // modify the HashMap created from the full map and make sure this\n         // change results in map.equals() to return false.\n-        Iterator<K> iter = confirmed.keySet().iterator();\n+        final Iterator<K> iter = confirmed.keySet().iterator();\n         iter.next();\n         iter.remove();\n         assertTrue(\"Different maps equal.\", !getMap().equals(confirmed));\n     public void testMapGet() {\n         resetEmpty();\n \n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-\n-        for (Object key : keys) {\n+        final Object[] keys = getSampleKeys();\n+        final Object[] values = getSampleValues();\n+\n+        for (final Object key : keys) {\n             assertTrue(\"Empty map.get() should return null.\",\n                     getMap().get(key) == null);\n         }\n         */\n \n         // test to make sure the canonical form has been preserved\n-        Map<K, V> map = makeObject();\n+        final Map<K, V> map = makeObject();\n         if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n             @SuppressWarnings(\"unchecked\")\n+            final\n             Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n             assertEquals(\"Map is empty\", 0, map2.size());\n         }\n         */\n \n         // test to make sure the canonical form has been preserved\n-        Map<K, V> map = makeFullMap();\n+        final Map<K, V> map = makeFullMap();\n         if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n             @SuppressWarnings(\"unchecked\")\n+            final\n             Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n             assertEquals(\"Map is the right size\", getSampleKeys().length, map2.size());\n         }\n      */\n     public void testMapPut() {\n         resetEmpty();\n-        K[] keys = getSampleKeys();\n-        V[] values = getSampleValues();\n-        V[] newValues = getNewSampleValues();\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+        final V[] newValues = getNewSampleValues();\n \n         if (isPutAddSupported()) {\n             for (int i = 0; i < keys.length; i++) {\n-                Object o = getMap().put(keys[i], values[i]);\n+                final Object o = getMap().put(keys[i], values[i]);\n                 getConfirmed().put(keys[i], values[i]);\n                 verify();\n                 assertTrue(\"First map.put should return null\", o == null);\n             }\n             if (isPutChangeSupported()) {\n                 for (int i = 0; i < keys.length; i++) {\n-                    Object o = getMap().put(keys[i], newValues[i]);\n+                    final Object o = getMap().put(keys[i], newValues[i]);\n                     getConfirmed().put(keys[i], newValues[i]);\n                     verify();\n                     assertEquals(\"Map.put should return previous value when changed\", values[i], o);\n                     // two possible exception here, either valid\n                     getMap().put(keys[0], newValues[0]);\n                     fail(\"Expected IllegalArgumentException or UnsupportedOperationException on put (change)\");\n-                } catch (IllegalArgumentException ex) {\n-                } catch (UnsupportedOperationException ex) {}\n+                } catch (final IllegalArgumentException ex) {\n+                } catch (final UnsupportedOperationException ex) {}\n             }\n \n         } else if (isPutChangeSupported()) {\n             try {\n                 getMap().put(keys[0], values[0]);\n                 fail(\"Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size\");\n-            } catch (IllegalArgumentException ex) {\n-            } catch (UnsupportedOperationException ex) {\n+            } catch (final IllegalArgumentException ex) {\n+            } catch (final UnsupportedOperationException ex) {\n             }\n \n             resetFull();\n             int i = 0;\n-            for (Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n-                K  key = it.next();\n-                V o = getMap().put(key, newValues[i]);\n-                V value = getConfirmed().put(key, newValues[i]);\n+            for (final Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n+                final K  key = it.next();\n+                final V o = getMap().put(key, newValues[i]);\n+                final V value = getConfirmed().put(key, newValues[i]);\n                 verify();\n                 assertEquals(\"Map.put should return previous value when changed\", value, o);\n                 assertTrue(\"Map should still contain key after put when changed\", getMap()\n             try {\n                 getMap().put(keys[0], values[0]);\n                 fail(\"Expected UnsupportedOperationException on put (add)\");\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n         }\n     }\n \n      */\n     public void testMapPutNullKey() {\n         resetFull();\n-        V[] values = getSampleValues();\n+        final V[] values = getSampleValues();\n \n         if (isPutAddSupported()) {\n             if (isAllowNullKey()) {\n                 try {\n                     getMap().put(null, values[0]);\n                     fail(\"put(null, value) should throw NPE/IAE\");\n-                } catch (NullPointerException ex) {\n-                } catch (IllegalArgumentException ex) {}\n+                } catch (final NullPointerException ex) {\n+                } catch (final IllegalArgumentException ex) {}\n             }\n         }\n     }\n      */\n     public void testMapPutNullValue() {\n         resetFull();\n-        K[] keys = getSampleKeys();\n+        final K[] keys = getSampleKeys();\n \n         if (isPutAddSupported()) {\n             if (isAllowNullValue()) {\n                 try {\n                     getMap().put(keys[0], null);\n                     fail(\"put(key, null) should throw NPE/IAE\");\n-                } catch (NullPointerException ex) {\n-                } catch (IllegalArgumentException ex) {}\n+                } catch (final NullPointerException ex) {\n+                } catch (final IllegalArgumentException ex) {}\n             }\n         }\n     }\n     public void testMapPutAll() {\n         if (!isPutAddSupported()) {\n             if (!isPutChangeSupported()) {\n-                Map<K, V> temp = makeFullMap();\n+                final Map<K, V> temp = makeFullMap();\n                 resetEmpty();\n                 try {\n                     getMap().putAll(temp);\n                     fail(\"Expected UnsupportedOperationException on putAll\");\n-                } catch (UnsupportedOperationException ex) {}\n+                } catch (final UnsupportedOperationException ex) {}\n             }\n             return;\n         }\n \n         // check putAll OK adding empty map to non-empty map\n         resetFull();\n-        int size = getMap().size();\n+        final int size = getMap().size();\n         getMap().putAll(new HashMap<K, V>());\n         assertEquals(size, getMap().size());\n \n         // check putAll OK adding non-empty JDK map to empty map\n         resetEmpty();\n         m2 = makeConfirmedMap();\n-        K[] keys = getSampleKeys();\n-        V[] values = getSampleValues();\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n         for(int i = 0; i < keys.length; i++) {\n             m2.put(keys[i], values[i]);\n         }\n                 resetFull();\n                 getMap().remove(getMap().keySet().iterator().next());\n                 fail(\"Expected UnsupportedOperationException on remove\");\n-            } catch (UnsupportedOperationException ex) {}\n+            } catch (final UnsupportedOperationException ex) {}\n             return;\n         }\n \n         resetEmpty();\n \n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        for (Object key : keys) {\n-            Object o = getMap().remove(key);\n+        final Object[] keys = getSampleKeys();\n+        final Object[] values = getSampleValues();\n+        for (final Object key : keys) {\n+            final Object o = getMap().remove(key);\n             assertTrue(\"First map.remove should return null\", o == null);\n         }\n         verify();\n         resetFull();\n \n         for (int i = 0; i < keys.length; i++) {\n-            Object o = getMap().remove(keys[i]);\n+            final Object o = getMap().remove(keys[i]);\n             getConfirmed().remove(keys[i]);\n             verify();\n \n                          values[i], o);\n         }\n \n-        Object[] other = getOtherKeys();\n-\n-        resetFull();\n-        int size = getMap().size();\n-        for (Object element : other) {\n-            Object o = getMap().remove(element);\n+        final Object[] other = getOtherKeys();\n+\n+        resetFull();\n+        final int size = getMap().size();\n+        for (final Object element : other) {\n+            final Object o = getMap().remove(element);\n             assertNull(\"map.remove for nonexistent key should return null\", o);\n             assertEquals(\"map.remove for nonexistent key should not \" +\n                          \"shrink map\", size, getMap().size());\n     //-----------------------------------------------------------------------\n     public void testEntrySetContains1() {\n         resetFull();\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n         assertEquals(true, entrySet.contains(entry));\n     }\n \n     public void testEntrySetContains2() {\n         resetFull();\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        Map.Entry<K, V> entry = entrySet.iterator().next();\n-        Map.Entry<K, V> test = cloneMapEntry(entry);\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final Map.Entry<K, V> test = cloneMapEntry(entry);\n         assertEquals(true, entrySet.contains(test));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEntrySetContains3() {\n         resetFull();\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        Map.Entry<K, V> entry = entrySet.iterator().next();\n-        HashMap<K, V> temp = new HashMap<K, V>();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final HashMap<K, V> temp = new HashMap<K, V>();\n         temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n-        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+        final Map.Entry<K, V> test = temp.entrySet().iterator().next();\n         assertEquals(false, entrySet.contains(test));\n     }\n \n             return;\n         }\n         resetFull();\n-        int size = getMap().size();\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        Map.Entry<K, V> entry = entrySet.iterator().next();\n-        K key = entry.getKey();\n+        final int size = getMap().size();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final K key = entry.getKey();\n \n         assertEquals(true, entrySet.remove(entry));\n         assertEquals(false, getMap().containsKey(key));\n             return;\n         }\n         resetFull();\n-        int size = getMap().size();\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        Map.Entry<K, V> entry = entrySet.iterator().next();\n-        K key = entry.getKey();\n-        Map.Entry<K, V> test = cloneMapEntry(entry);\n+        final int size = getMap().size();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final K key = entry.getKey();\n+        final Map.Entry<K, V> test = cloneMapEntry(entry);\n \n         assertEquals(true, entrySet.remove(test));\n         assertEquals(false, getMap().containsKey(key));\n             return;\n         }\n         resetFull();\n-        int size = getMap().size();\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        Map.Entry<K, V> entry = entrySet.iterator().next();\n-        K key = entry.getKey();\n-        HashMap<K, V> temp = new HashMap<K, V>();\n+        final int size = getMap().size();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final K key = entry.getKey();\n+        final HashMap<K, V> temp = new HashMap<K, V>();\n         temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n-        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+        final Map.Entry<K, V> test = temp.entrySet().iterator().next();\n \n         assertEquals(false, entrySet.remove(test));\n         assertEquals(true, getMap().containsKey(key));\n      */\n     public void testValuesRemoveChangesMap() {\n         resetFull();\n-        V[] sampleValues = getSampleValues();\n-        Collection<V> values = getMap().values();\n+        final V[] sampleValues = getSampleValues();\n+        final Collection<V> values = getMap().values();\n         for (int i = 0; i < sampleValues.length; i++) {\n             if (map.containsValue(sampleValues[i])) {\n                 int j = 0;  // loop counter prevents infinite loops when remove is broken\n                 while (values.contains(sampleValues[i]) && j < 10000) {\n                     try {\n                         values.remove(sampleValues[i]);\n-                    } catch (UnsupportedOperationException e) {\n+                    } catch (final UnsupportedOperationException e) {\n                         // if values.remove is unsupported, just skip this test\n                         return;\n                     }\n      */\n     public void testValuesRemoveAll() {\n         resetFull();\n-        Collection<V> values = getMap().values();\n-        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        final Collection<V> values = getMap().values();\n+        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n         if (!values.equals(sampleValuesAsList)) {\n             return;\n         }\n         try {\n             assertFalse(values.removeAll(Collections.<V> emptySet()));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // if values.removeAll is unsupported, just skip this test\n             return;\n         }\n         assertEquals(sampleValuesAsList.size(), getMap().size());\n         try {\n             assertTrue(values.removeAll(sampleValuesAsList));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // if values.removeAll is unsupported, just skip this test\n             return;\n         }\n      */\n     public void testValuesRetainAll() {\n         resetFull();\n-        Collection<V> values = getMap().values();\n-        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        final Collection<V> values = getMap().values();\n+        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n         if (!values.equals(sampleValuesAsList)) {\n             return;\n         }\n         try {\n             assertFalse(values.retainAll(sampleValuesAsList));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // if values.retainAll is unsupported, just skip this test\n             return;\n         }\n         assertEquals(sampleValuesAsList.size(), getMap().size());\n         try {\n             assertTrue(values.retainAll(Collections.<V> emptySet()));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // if values.retainAll is unsupported, just skip this test\n             return;\n         }\n      */\n     public void testValuesIteratorRemoveChangesMap() {\n         resetFull();\n-        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n-        Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);\n-        Collection<V> values = getMap().values();\n-        for (Iterator<V> iter = values.iterator(); iter.hasNext();) {\n-            V value = iter.next();\n+        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        final Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);\n+        final Collection<V> values = getMap().values();\n+        for (final Iterator<V> iter = values.iterator(); iter.hasNext();) {\n+            final V value = iter.next();\n             Integer count = cardinality.get(value);\n             if (count == null) {\n                 return;\n             try {\n                 iter.remove();\n                 cardinality.put(value, --count);\n-            } catch (UnsupportedOperationException e) {\n+            } catch (final UnsupportedOperationException e) {\n                 // if values.iterator.remove is unsupported, just skip this test\n                 return;\n             }\n-            boolean expected = count > 0;\n-            StringBuilder msg = new StringBuilder(\"Value should \");\n+            final boolean expected = count > 0;\n+            final StringBuilder msg = new StringBuilder(\"Value should \");\n             msg.append(expected ? \"yet \" : \"no longer \");\n             msg.append(\"be present in the underlying map\");\n             assertEquals(msg.toString(), expected, getMap().containsValue(value));\n      */\n     public void testKeySetRemoveChangesMap() {\n         resetFull();\n-        K[] sampleKeys = getSampleKeys();\n-        Set<K> keys = getMap().keySet();\n+        final K[] sampleKeys = getSampleKeys();\n+        final Set<K> keys = getMap().keySet();\n         for (int i = 0; i < sampleKeys.length; i++) {\n             try {\n                 keys.remove(sampleKeys[i]);\n-            } catch (UnsupportedOperationException e) {\n+            } catch (final UnsupportedOperationException e) {\n                 // if key.remove is unsupported, just skip this test\n                 return;\n             }\n      */\n     public void testKeySetRemoveAll() {\n         resetFull();\n-        Set<K> keys = getMap().keySet();\n-        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        final Set<K> keys = getMap().keySet();\n+        final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n         if (!keys.equals(sampleKeysAsList)) {\n             return;\n         }\n         try {\n             assertFalse(keys.removeAll(Collections.<K> emptySet()));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertEquals(sampleKeysAsList, keys);\n         try {\n             assertTrue(keys.removeAll(sampleKeysAsList));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertTrue(getMap().isEmpty());\n      */\n     public void testKeySetRetainAll() {\n         resetFull();\n-        Set<K> keys = getMap().keySet();\n-        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        final Set<K> keys = getMap().keySet();\n+        final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n         if (!keys.equals(sampleKeysAsList)) {\n             return;\n         }\n         try {\n             assertFalse(keys.retainAll(sampleKeysAsList));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertEquals(sampleKeysAsList, keys);\n         try {\n             assertTrue(keys.retainAll(Collections.<K> emptySet()));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertTrue(getMap().isEmpty());\n      */\n     public void testKeySetIteratorRemoveChangesMap() {\n         resetFull();\n-        for (Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {\n-            K key = iter.next();\n+        for (final Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {\n+            final K key = iter.next();\n             try {\n                 iter.remove();\n-            } catch (UnsupportedOperationException e) {\n+            } catch (final UnsupportedOperationException e) {\n                 return;\n             }\n             assertFalse(getMap().containsKey(key));\n      */\n     public void testEntrySetRemoveChangesMap() {\n         resetFull();\n-        K[] sampleKeys = getSampleKeys();\n-        V[] sampleValues = getSampleValues();\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final K[] sampleKeys = getSampleKeys();\n+        final V[] sampleValues = getSampleValues();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n         for (int i = 0; i < sampleKeys.length; i++) {\n             try {\n                 entrySet.remove(new DefaultMapEntry<K, V>(sampleKeys[i], sampleValues[i]));\n-            } catch (UnsupportedOperationException e) {\n+            } catch (final UnsupportedOperationException e) {\n                 // if entrySet removal is unsupported, just skip this test\n                 return;\n             }\n      */\n     public void testEntrySetRemoveAll() {\n         resetFull();\n-        K[] sampleKeys = getSampleKeys();\n-        V[] sampleValues = getSampleValues();\n+        final K[] sampleKeys = getSampleKeys();\n+        final V[] sampleValues = getSampleValues();\n         //verify map looks as expected:\n         for (int i = 0; i < sampleKeys.length; i++) {\n             if (!getMap().containsKey(sampleKeys[i])) {\n                 return;\n             }\n-            V value = sampleValues[i];\n-            V test = getMap().get(sampleKeys[i]);\n+            final V value = sampleValues[i];\n+            final V test = getMap().get(sampleKeys[i]);\n             if (value == test || value != null && value.equals(test)) {\n                 continue;\n             }\n             return;\n         }\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n         try {\n             assertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>> emptySet()));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertEquals(sampleKeys.length, getMap().size());\n         try {\n             assertTrue(entrySet.removeAll(comparisonSet));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertTrue(getMap().isEmpty());\n      */\n     public void testEntrySetRetainAll() {\n         resetFull();\n-        K[] sampleKeys = getSampleKeys();\n-        V[] sampleValues = getSampleValues();\n+        final K[] sampleKeys = getSampleKeys();\n+        final V[] sampleValues = getSampleValues();\n         //verify map looks as expected:\n         for (int i = 0; i < sampleKeys.length; i++) {\n             if (!getMap().containsKey(sampleKeys[i])) {\n                 return;\n             }\n-            V value = sampleValues[i];\n-            V test = getMap().get(sampleKeys[i]);\n+            final V value = sampleValues[i];\n+            final V test = getMap().get(sampleKeys[i]);\n             if (value == test || value != null && value.equals(test)) {\n                 continue;\n             }\n             return;\n         }\n-        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n-        HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n         try {\n             assertFalse(entrySet.retainAll(comparisonSet));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertEquals(sampleKeys.length, getMap().size());\n         try {\n             assertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>> emptySet()));\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             return;\n         }\n         assertTrue(getMap().isEmpty());\n      */\n     public void testEntrySetIteratorRemoveChangesMap() {\n         resetFull();\n-        for (Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {\n-            K key = iter.next().getKey();\n+        for (final Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {\n+            final K key = iter.next().getKey();\n             try {\n                 iter.remove();\n-            } catch (UnsupportedOperationException e) {\n+            } catch (final UnsupportedOperationException e) {\n                 return;\n             }\n             assertFalse(getMap().containsKey(key));\n      * @return an array of Map.Entry of those keys to those values\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private Map.Entry<K, V>[] makeEntryArray(K[] keys, V[] values) {\n-        Map.Entry<K, V>[] result = new Map.Entry[keys.length];\n+    private Map.Entry<K, V>[] makeEntryArray(final K[] keys, final V[] values) {\n+        final Map.Entry<K, V>[] result = new Map.Entry[keys.length];\n         for (int i = 0; i < keys.length; i++) {\n-            Map<K, V> map = makeConfirmedMap();\n+            final Map<K, V> map = makeConfirmedMap();\n             map.put(keys[i], values[i]);\n             result[i] = map.entrySet().iterator().next();\n         }\n          */\n         @Override\n         public Map.Entry<K, V>[] getFullNonNullElements() {\n-            K[] k = getSampleKeys();\n-            V[] v = getSampleValues();\n+            final K[] k = getSampleKeys();\n+            final V[] v = getSampleValues();\n             return makeEntryArray(k, v);\n         }\n \n         // Have to implement manually; entrySet doesn't support addAll\n         @Override\n         public Map.Entry<K, V>[] getOtherElements() {\n-            K[] k = getOtherKeys();\n-            V[] v = getOtherValues();\n+            final K[] k = getOtherKeys();\n+            final V[] v = getOtherValues();\n             return makeEntryArray(k, v);\n         }\n \n \n         public void testMapEntrySetIteratorEntry() {\n             resetFull();\n-            Iterator<Map.Entry<K, V>> it = getCollection().iterator();\n+            final Iterator<Map.Entry<K, V>> it = getCollection().iterator();\n             int count = 0;\n             while (it.hasNext()) {\n-                Map.Entry<K, V> entry = it.next();\n+                final Map.Entry<K, V> entry = it.next();\n                 assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry.getKey()));\n                 assertEquals(true, AbstractMapTest.this.getMap().containsValue(entry.getValue()));\n                 if (isGetStructuralModify() == false) {\n         }\n \n         public void testMapEntrySetIteratorEntrySetValue() {\n-            K key1 = getSampleKeys()[0];\n-            K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];\n-            V newValue1 = getNewSampleValues()[0];\n-            V newValue2 = getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1];\n+            final K key1 = getSampleKeys()[0];\n+            final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];\n+            final V newValue1 = getNewSampleValues()[0];\n+            final V newValue2 = getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1];\n \n             resetFull();\n             // explicitly get entries as sample values/keys are connected for some maps\n             // such as BeanMap\n             Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n-            Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n             it = TestMapEntrySet.this.getCollection().iterator();\n-            Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n             Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n-            Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n             itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n-            Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n             verify();\n \n             if (isSetValueSupported() == false) {\n                 try {\n                     entry1.setValue(newValue1);\n-                } catch (UnsupportedOperationException ex) {\n+                } catch (final UnsupportedOperationException ex) {\n                 }\n                 return;\n             }\n             verify();\n         }\n \n-        public Map.Entry<K, V> getEntry(Iterator<Map.Entry<K, V>> itConfirmed, K key) {\n+        public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key) {\n             Map.Entry<K, V> entry = null;\n             while (itConfirmed.hasNext()) {\n-                Map.Entry<K, V> temp = itConfirmed.next();\n+                final Map.Entry<K, V> temp = itConfirmed.next();\n                 if (temp.getKey() == null) {\n                     if (key == null) {\n                         entry = temp;\n         this.map = makeFullMap();\n         views();\n         this.confirmed = makeConfirmedMap();\n-        K[] k = getSampleKeys();\n-        V[] v = getSampleValues();\n+        final K[] k = getSampleKeys();\n+        final V[] v = getSampleValues();\n         for (int i = 0; i < k.length; i++) {\n             confirmed.put(k[i], v[i]);\n         }\n     }\n \n     public void verifyMap() {\n-        int size = getConfirmed().size();\n-        boolean empty = getConfirmed().isEmpty();\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n         assertEquals(\"Map should be same size as HashMap\", size, getMap().size());\n         assertEquals(\"Map should be empty if HashMap is\", empty, getMap().isEmpty());\n         assertEquals(\"hashCodes should be the same\", getConfirmed().hashCode(), getMap().hashCode());\n     }\n \n     public void verifyEntrySet() {\n-        int size = getConfirmed().size();\n-        boolean empty = getConfirmed().isEmpty();\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n         assertEquals(\"entrySet should be same size as HashMap's\" +\n                      \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n                      size, entrySet.size());\n     }\n \n     public void verifyKeySet() {\n-        int size = getConfirmed().size();\n-        boolean empty = getConfirmed().isEmpty();\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n         assertEquals(\"keySet should be same size as HashMap's\" +\n                      \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n                      size, keySet.size());\n     }\n \n     public void verifyValues() {\n-        List<V> known = new ArrayList<V>(getConfirmed().values());\n-        List<V> test = new ArrayList<V>(values);\n-\n-        int size = getConfirmed().size();\n-        boolean empty = getConfirmed().isEmpty();\n+        final List<V> known = new ArrayList<V>(getConfirmed().values());\n+        final List<V> test = new ArrayList<V>(values);\n+\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n         assertEquals(\"values should be same size as HashMap's\" +\n                      \"\\nTest: \" + test + \"\\nReal: \" + known,\n                      size, values.size());\n                    \"\\nTest: \" + test + \"\\nReal: \" + known,\n                    known.containsAll(test));\n         // originally coded to use a HashBag, but now separate jar so...\n-        for (V v : known) {\n-            boolean removed = test.remove(v);\n+        for (final V v : known) {\n+            final boolean removed = test.remove(v);\n             assertTrue(\"Map's values should still equal HashMap's\", removed);\n         }\n         assertTrue(\"Map's values should still equal HashMap's\", test.isEmpty());\n--- a/src/test/java/org/apache/commons/collections/map/AbstractOrderedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractOrderedMapTest.java\n      *\n      * @param testName  the test name\n      */\n-    public AbstractOrderedMapTest(String testName) {\n+    public AbstractOrderedMapTest(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public K[] getSampleKeys() {\n-        List<K> list = new ArrayList<K>(Arrays.asList(super.getSampleKeys()));\n+        final List<K> list = new ArrayList<K>(Arrays.asList(super.getSampleKeys()));\n         Collections.sort(list, new NullComparator<K>());\n         return (K[]) list.toArray();\n     }\n         try {\n             ordered.firstKey();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n-\n-        resetFull();\n-        ordered = getMap();\n-        K confirmedFirst = confirmed.keySet().iterator().next();\n+        } catch (final NoSuchElementException ex) {}\n+\n+        resetFull();\n+        ordered = getMap();\n+        final K confirmedFirst = confirmed.keySet().iterator().next();\n         assertEquals(confirmedFirst, ordered.firstKey());\n     }\n \n         try {\n             ordered.lastKey();\n             fail();\n-        } catch (NoSuchElementException ex) {}\n+        } catch (final NoSuchElementException ex) {}\n \n         resetFull();\n         ordered = getMap();\n         K confirmedLast = null;\n-        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+        for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n             confirmedLast = it.next();\n         }\n         assertEquals(confirmedLast, ordered.lastKey());\n         if (!isAllowNullKey()) {\n             try {\n                 assertEquals(null, ordered.nextKey(null)); // this is allowed too\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             assertEquals(null, ordered.nextKey(null));\n         }\n \n         resetFull();\n         ordered = getMap();\n-        Iterator<K> it = confirmed.keySet().iterator();\n+        final Iterator<K> it = confirmed.keySet().iterator();\n         K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            K confirmedObject = it.next();\n+            final K confirmedObject = it.next();\n             assertEquals(confirmedObject, ordered.nextKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n             try {\n                 ordered.nextKey(null);\n                 fail();\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             assertEquals(null, ordered.nextKey(null));\n         }\n         if (isAllowNullKey() == false) {\n             try {\n                 assertEquals(null, ordered.previousKey(null)); // this is allowed too\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             assertEquals(null, ordered.previousKey(null));\n         }\n \n         resetFull();\n         ordered = getMap();\n-        List<K> list = new ArrayList<K>(confirmed.keySet());\n+        final List<K> list = new ArrayList<K>(confirmed.keySet());\n         Collections.reverse(list);\n-        Iterator<K> it = list.iterator();\n+        final Iterator<K> it = list.iterator();\n         K confirmedLast = it.next();\n         while (it.hasNext()) {\n-            K confirmedObject = it.next();\n+            final K confirmedObject = it.next();\n             assertEquals(confirmedObject, ordered.previousKey(confirmedLast));\n             confirmedLast = confirmedObject;\n         }\n             try {\n                 ordered.previousKey(null);\n                 fail();\n-            } catch (NullPointerException ex) {}\n+            } catch (final NullPointerException ex) {}\n         } else {\n             if (isAllowNullKey() == false) {\n                 assertEquals(null, ordered.previousKey(null));\n--- a/src/test/java/org/apache/commons/collections/map/AbstractSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractSortedMapTest.java\n      *\n      * @param testName  the test name\n      */\n-    public AbstractSortedMapTest(String testName) {\n+    public AbstractSortedMapTest(final String testName) {\n         super(testName);\n     }\n \n     }\n \n     public void testFirstKey() {\n-        SortedMap<K, V> sm = makeFullMap();\n+        final SortedMap<K, V> sm = makeFullMap();\n         assertSame(sm.keySet().iterator().next(), sm.firstKey());\n     }\n \n     public void testLastKey() {\n-        SortedMap<K, V> sm = makeFullMap();\n+        final SortedMap<K, V> sm = makeFullMap();\n         K obj = null;\n-        for (Iterator<K> it = sm.keySet().iterator(); it.hasNext();) {\n+        for (final Iterator<K> it = sm.keySet().iterator(); it.hasNext();) {\n             obj = it.next();\n         }\n         assertSame(obj, sm.lastKey());\n         protected final List<V> subSortedValues = new ArrayList<V>();\n         protected final List<V> subSortedNewValues = new ArrayList<V>();\n \n-        public TestViewMap(String name, AbstractMapTest<K, V> main) {\n+        public TestViewMap(final String name, final AbstractMapTest<K, V> main) {\n             super(name);\n             this.main = main;\n         }\n         static final int SUBSIZE = 6;\n         final K toKey;\n \n-        public TestHeadMap(AbstractMapTest<K, V> main) {\n+        public TestHeadMap(final AbstractMapTest<K, V> main) {\n             super(\"SortedMap.HeadMap\", main);\n-            Map<K, V> sm = main.makeFullMap();\n-            for (Entry<K, V> entry : sm.entrySet()) {\n+            final Map<K, V> sm = main.makeFullMap();\n+            for (final Entry<K, V> entry : sm.entrySet()) {\n                 this.subSortedKeys.add(entry.getKey());\n                 this.subSortedValues.add(entry.getValue());\n             }\n             try {\n                 getMap().put(toKey, subSortedValues.get(0));\n                 fail();\n-            } catch (IllegalArgumentException ex) {}\n+            } catch (final IllegalArgumentException ex) {}\n             verify();\n         }\n         @Override\n         final K fromKey;\n         final K invalidKey;\n \n-        public TestTailMap(AbstractMapTest<K, V> main) {\n+        public TestTailMap(final AbstractMapTest<K, V> main) {\n             super(\"SortedMap.TailMap\", main);\n-            Map<K, V> sm = main.makeFullMap();\n-            for (Entry<K, V> entry : sm.entrySet()) {\n+            final Map<K, V> sm = main.makeFullMap();\n+            for (final Entry<K, V> entry : sm.entrySet()) {\n                 this.subSortedKeys.add(entry.getKey());\n                 this.subSortedValues.add(entry.getValue());\n             }\n             try {\n                 getMap().put(invalidKey, subSortedValues.get(0));\n                 fail();\n-            } catch (IllegalArgumentException ex) {}\n+            } catch (final IllegalArgumentException ex) {}\n             verify();\n         }\n         @Override\n         final K fromKey;\n         final K toKey;\n \n-        public TestSubMap(AbstractMapTest<K, V> main) {\n+        public TestSubMap(final AbstractMapTest<K, V> main) {\n             super(\"SortedMap.SubMap\", main);\n-            Map<K, V> sm = main.makeFullMap();\n-            for (Entry<K, V> entry : sm.entrySet()) {\n+            final Map<K, V> sm = main.makeFullMap();\n+            for (final Entry<K, V> entry : sm.entrySet()) {\n                 this.subSortedKeys.add(entry.getKey());\n                 this.subSortedValues.add(entry.getValue());\n             }\n             try {\n                 getMap().put(toKey, subSortedValues.get(0));\n                 fail();\n-            } catch (IllegalArgumentException ex) {}\n+            } catch (final IllegalArgumentException ex) {}\n             verify();\n         }\n         @Override\n--- a/src/test/java/org/apache/commons/collections/map/CaseInsensitiveMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/CaseInsensitiveMapTest.java\n  */\n public class CaseInsensitiveMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public CaseInsensitiveMapTest(String testName) {\n+    public CaseInsensitiveMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testCaseInsensitive() {\n-        Map<K, V> map = makeObject();\n+        final Map<K, V> map = makeObject();\n         map.put((K) \"One\", (V) \"One\");\n         map.put((K) \"Two\", (V) \"Two\");\n         assertEquals(\"One\", map.get(\"one\"));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testNullHandling() {\n-        Map<K, V> map = makeObject();\n+        final Map<K, V> map = makeObject();\n         map.put((K) \"One\", (V) \"One\");\n         map.put((K) \"Two\", (V) \"Two\");\n         map.put(null, (V) \"Three\");\n         assertEquals(\"Three\", map.get(null));\n         map.put(null, (V) \"Four\");\n         assertEquals(\"Four\", map.get(null));\n-        Set<K> keys = map.keySet();\n+        final Set<K> keys = map.keySet();\n         assertTrue(keys.contains(\"one\"));\n         assertTrue(keys.contains(\"two\"));\n         assertTrue(keys.contains(null));\n     }\n \n     public void testPutAll() {\n-        Map<Object, String> map = new HashMap<Object, String>();\n+        final Map<Object, String> map = new HashMap<Object, String>();\n         map.put(\"One\", \"One\");\n         map.put(\"Two\", \"Two\");\n         map.put(\"one\", \"Three\");\n         map.put(null, \"Four\");\n         map.put(new Integer(20), \"Five\");\n-        Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<Object, String>(map);\n+        final Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<Object, String>(map);\n         assertEquals(4, caseInsensitiveMap.size()); // ones collapsed\n-        Set<Object> keys = caseInsensitiveMap.keySet();\n+        final Set<Object> keys = caseInsensitiveMap.keySet();\n         assertTrue(keys.contains(\"one\"));\n         assertTrue(keys.contains(\"two\"));\n         assertTrue(keys.contains(null));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<K, V>(10);\n+        final CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<K, V>(10);\n         map.put((K) \"1\", (V) \"1\");\n-        CaseInsensitiveMap<K, V> cloned = map.clone();\n+        final CaseInsensitiveMap<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n \n     // COLLECTIONS-294\n     public void testLocaleIndependence() {\n-        Locale orig = Locale.getDefault();\n+        final Locale orig = Locale.getDefault();\n \n-        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\", \"\", \"\"), Locale.getDefault() };\n+        final Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\", \"\", \"\"), Locale.getDefault() };\n \n-        String[][] data = { \n+        final String[][] data = { \n             { \"i\", \"I\" },\n             { \"\\u03C2\", \"\\u03C3\" },\n             { \"\\u03A3\", \"\\u03C2\" },\n         };\n \n         try {\n-            for (Locale locale : locales) {\n+            for (final Locale locale : locales) {\n                 Locale.setDefault(locale);\n                 for (int j = 0; j < data.length; j++) {\n                     assertTrue(\"Test data corrupt: \" + j, data[j][0].equalsIgnoreCase(data[j][1]));\n-                    CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<String, String>();\n+                    final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<String, String>();\n                     map.put(data[j][0], \"value\");\n                     assertEquals(Locale.getDefault() + \": \" + j, \"value\", map.get(data[j][1]));\n                 }\n--- a/src/test/java/org/apache/commons/collections/map/CompositeMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/CompositeMapTest.java\n     /** used as a flag in MapMutator tests */\n     private boolean pass = false;\n     \n-    public CompositeMapTest(String testName) {\n+    public CompositeMapTest(final String testName) {\n         super(testName);\n     }\n     \n     \n     @Override\n     public CompositeMap<K, V> makeObject() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>();\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>();\n         map.addComposited(new HashMap<K, V>());\n         map.setMutator( new EmptyMapMutator<K, V>() );\n         return map;\n     \n     @SuppressWarnings(\"unchecked\")\n     private Map<K, V> buildOne() {\n-        HashMap<K, V> map = new HashMap<K, V>();\n+        final HashMap<K, V> map = new HashMap<K, V>();\n         map.put((K) \"1\", (V) \"one\");\n         map.put((K) \"2\", (V) \"two\");\n         return map;\n     \n     @SuppressWarnings(\"unchecked\")\n     public Map<K, V> buildTwo() {\n-        HashMap<K, V> map = new HashMap<K, V>();\n+        final HashMap<K, V> map = new HashMap<K, V>();\n         map.put((K) \"3\", (V) \"three\");\n         map.put((K) \"4\", (V) \"four\");\n         return map;\n     }\n     \n     public void testGet() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n         Assert.assertEquals(\"one\", map.get(\"1\"));\n         Assert.assertEquals(\"four\", map.get(\"4\"));\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testAddComposited() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n-        HashMap<K, V> three = new HashMap<K, V>();\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n         three.put((K) \"5\", (V) \"five\");\n         map.addComposited(three);\n         assertTrue(map.containsKey(\"5\"));\n         try {\n             map.addComposited(three);\n             fail(\"Expecting IllegalArgumentException.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // expected\n         }\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveComposited() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n-        HashMap<K, V> three = new HashMap<K, V>();\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n         three.put((K) \"5\", (V) \"five\");\n         map.addComposited(three);\n         assertTrue(map.containsKey(\"5\"));\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveFromUnderlying() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n-        HashMap<K, V> three = new HashMap<K, V>();\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n         three.put((K) \"5\", (V) \"five\");\n         map.addComposited(three);\n         assertTrue(map.containsKey(\"5\"));\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveFromComposited() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n-        HashMap<K, V> three = new HashMap<K, V>();\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n         three.put((K) \"5\", (V) \"five\");\n         map.addComposited(three);\n         assertTrue(map.containsKey(\"5\"));\n     }\n     \n     public void testResolveCollision() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n             new CompositeMap.MapMutator<K, V>() {\n             private static final long serialVersionUID = 1L;\n \n-            public void resolveCollision(CompositeMap<K, V> composite,\n-            Map<K, V> existing,\n-            Map<K, V> added,\n-            Collection<K> intersect) {\n+            public void resolveCollision(final CompositeMap<K, V> composite,\n+            final Map<K, V> existing,\n+            final Map<K, V> added,\n+            final Collection<K> intersect) {\n                 pass = true;\n             }\n             \n-            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n-                V value) {\n-                throw new UnsupportedOperationException();\n-            }\n-            \n-            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+                final V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                 throw new UnsupportedOperationException();\n             }\n         });\n     \n     @SuppressWarnings(\"unchecked\")\n     public void testPut() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n             new CompositeMap.MapMutator<K, V>() {\n             private static final long serialVersionUID = 1L;\n-            public void resolveCollision(CompositeMap<K, V> composite,\n-            Map<K, V> existing,\n-            Map<K, V> added,\n-            Collection<K> intersect) {\n-                throw new UnsupportedOperationException();\n-            }\n-            \n-            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n-                V value) {\n+            public void resolveCollision(final CompositeMap<K, V> composite,\n+            final Map<K, V> existing,\n+            final Map<K, V> added,\n+            final Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+                final V value) {\n                 pass = true;\n                 return (V) \"foo\";\n             }\n             \n-            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+            public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                 throw new UnsupportedOperationException();\n             }\n         });\n     }\n     \n     public void testPutAll() {\n-        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n             new CompositeMap.MapMutator<K, V>() {\n             private static final long serialVersionUID = 1L;\n-            public void resolveCollision(CompositeMap<K, V> composite,\n-            Map<K, V> existing,\n-            Map<K, V> added,\n-            Collection<K> intersect) {\n-                throw new UnsupportedOperationException();\n-            }\n-            \n-            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n-                V value) {\n-                throw new UnsupportedOperationException();\n-            }\n-            \n-            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+            public void resolveCollision(final CompositeMap<K, V> composite,\n+            final Map<K, V> existing,\n+            final Map<K, V> added,\n+            final Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+                final V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                 pass = true;\n             }\n         });\n--- a/src/test/java/org/apache/commons/collections/map/DefaultedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/DefaultedMapTest.java\n \n     protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();\n \n-    public DefaultedMapTest(String testName) {\n+    public DefaultedMapTest(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public void testMapGet() {\n-        Map<K, V> map = new DefaultedMap<K, V>((V) \"NULL\");\n+        final Map<K, V> map = new DefaultedMap<K, V>((V) \"NULL\");\n \n         assertEquals(0, map.size());\n         assertEquals(false, map.containsKey(\"NotInMap\"));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testMapGet2() {\n-        HashMap<K, V> base = new HashMap<K, V>();\n-        Map<K, V> map = DefaultedMap.defaultedMap(base, (V) \"NULL\");\n+        final HashMap<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> map = DefaultedMap.defaultedMap(base, (V) \"NULL\");\n \n         assertEquals(0, map.size());\n         assertEquals(0, base.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testMapGet3() {\n-        HashMap<K, V> base = new HashMap<K, V>();\n-        Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) \"NULL\"));\n+        final HashMap<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) \"NULL\"));\n \n         assertEquals(0, map.size());\n         assertEquals(0, base.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testMapGet4() {\n-        HashMap<K, V> base = new HashMap<K, V>();\n-        Map<K, V> map = DefaultedMap.defaultedMap(base, new Transformer<K, V>() {\n-            public V transform(K input) {\n+        final HashMap<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> map = DefaultedMap.defaultedMap(base, new Transformer<K, V>() {\n+            public V transform(final K input) {\n                 if (input instanceof String) {\n                     return (V) \"NULL\";\n                 }\n--- a/src/test/java/org/apache/commons/collections/map/EmptyMapMutator.java\n+++ b/src/test/java/org/apache/commons/collections/map/EmptyMapMutator.java\n     /** Serialization version */\n     private static final long serialVersionUID = -2729718980002476794L;\n \n-    public void resolveCollision(CompositeMap<K,V> composite,\n-    Map<K,V> existing,\n-    Map<K,V> added,\n-    Collection<K> intersect) {\n+    public void resolveCollision(final CompositeMap<K,V> composite,\n+    final Map<K,V> existing,\n+    final Map<K,V> added,\n+    final Collection<K> intersect) {\n         // Do nothing\n     }\n     \n-    public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, V value) {\n+    public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, final V value) {\n         return composited[0].put(key, value);\n     }\n     \n-    public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+    public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n         composited[0].putAll(t);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/map/FixedSizeMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/FixedSizeMapTest.java\n  */\n public class FixedSizeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public FixedSizeMapTest(String testName) {\n+    public FixedSizeMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public IterableMap<K, V> makeFullMap() {\n-        Map<K, V> map = new HashMap<K, V>();\n+        final Map<K, V> map = new HashMap<K, V>();\n         addSampleMappings(map);\n         return FixedSizeMap.fixedSizeMap(map);\n     }\n--- a/src/test/java/org/apache/commons/collections/map/FixedSizeSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/FixedSizeSortedMapTest.java\n  */\n public class FixedSizeSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n \n-    public FixedSizeSortedMapTest(String testName) {\n+    public FixedSizeSortedMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public SortedMap<K, V> makeFullMap() {\n-        SortedMap<K, V> map = new TreeMap<K, V>();\n+        final SortedMap<K, V> map = new TreeMap<K, V>();\n         addSampleMappings(map);\n         return FixedSizeSortedMap.fixedSizeSortedMap(map);\n     }\n--- a/src/test/java/org/apache/commons/collections/map/Flat3MapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/Flat3MapTest.java\n     private static final String TWENTY = \"20\";\n     private static final String THIRTY = \"30\";\n \n-    public Flat3MapTest(String testName) {\n+    public Flat3MapTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testEquals1() {\n-        Flat3Map<K, V> map1 = makeObject();\n+        final Flat3Map<K, V> map1 = makeObject();\n         map1.put((K) \"a\", (V) \"testA\");\n         map1.put((K) \"b\", (V) \"testB\");\n-        Flat3Map<K, V> map2 = makeObject();\n+        final Flat3Map<K, V> map2 = makeObject();\n         map2.put((K) \"a\", (V) \"testB\");\n         map2.put((K) \"b\", (V) \"testA\");\n         assertEquals(false, map1.equals(map2));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEquals2() {\n-        Flat3Map<K, V> map1 = makeObject();\n+        final Flat3Map<K, V> map1 = makeObject();\n         map1.put((K) \"a\", (V) \"testA\");\n         map1.put((K) \"b\", (V) \"testB\");\n-        Flat3Map<K, V> map2 = makeObject();\n+        final Flat3Map<K, V> map2 = makeObject();\n         map2.put((K) \"a\", (V) \"testB\");\n         map2.put((K) \"c\", (V) \"testA\");\n         assertEquals(false, map1.equals(map2));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testClone2() {\n-        Flat3Map<K, V> map = makeObject();\n+        final Flat3Map<K, V> map = makeObject();\n         assertEquals(0, map.size());\n         map.put((K) ONE, (V) TEN);\n         map.put((K) TWO, (V) TWENTY);\n         assertSame(TWENTY, map.get(TWO));\n \n         // clone works (size = 2)\n-        Flat3Map<K, V> cloned = map.clone();\n+        final Flat3Map<K, V> cloned = map.clone();\n         assertEquals(2, cloned.size());\n         assertEquals(true, cloned.containsKey(ONE));\n         assertEquals(true, cloned.containsKey(TWO));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testClone4() {\n-        Flat3Map<K, V> map = makeObject();\n+        final Flat3Map<K, V> map = makeObject();\n         assertEquals(0, map.size());\n         map.put((K) ONE, (V) TEN);\n         map.put((K) TWO, (V) TWENTY);\n         map.put((K) TWENTY, (V) TWO);\n \n         // clone works (size = 4)\n-        Flat3Map<K, V> cloned = map.clone();\n+        final Flat3Map<K, V> cloned = map.clone();\n         assertEquals(4, map.size());\n         assertEquals(4, cloned.size());\n         assertEquals(true, cloned.containsKey(ONE));\n     }\n \n     public void testSerialisation0() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        final Flat3Map<K, V> map = makeObject();\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(bout);\n         out.writeObject(map);\n-        byte[] bytes = bout.toByteArray();\n+        final byte[] bytes = bout.toByteArray();\n         out.close();\n-        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n-        ObjectInputStream in = new ObjectInputStream(bin);\n-        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        final ObjectInputStream in = new ObjectInputStream(bin);\n+        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n         in.close();\n         assertEquals(0, map.size());\n         assertEquals(0, ser.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSerialisation2() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        map.put((K) ONE, (V) TEN);\n-        map.put((K) TWO, (V) TWENTY);\n-\n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(bout);\n         out.writeObject(map);\n-        byte[] bytes = bout.toByteArray();\n+        final byte[] bytes = bout.toByteArray();\n         out.close();\n-        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n-        ObjectInputStream in = new ObjectInputStream(bin);\n-        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        final ObjectInputStream in = new ObjectInputStream(bin);\n+        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n         in.close();\n         assertEquals(2, map.size());\n         assertEquals(2, ser.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSerialisation4() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n+        final Flat3Map<K, V> map = makeObject();\n         map.put((K) ONE, (V) TEN);\n         map.put((K) TWO, (V) TWENTY);\n         map.put((K) TEN, (V) ONE);\n         map.put((K) TWENTY, (V) TWO);\n \n-        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(bout);\n         out.writeObject(map);\n-        byte[] bytes = bout.toByteArray();\n+        final byte[] bytes = bout.toByteArray();\n         out.close();\n-        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n-        ObjectInputStream in = new ObjectInputStream(bin);\n-        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        final ObjectInputStream in = new ObjectInputStream(bin);\n+        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n         in.close();\n         assertEquals(4, map.size());\n         assertEquals(4, ser.size());\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testEntryIteratorSetValue1() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        map.put((K) ONE, (V) TEN);\n-        map.put((K) TWO, (V) TWENTY);\n-        map.put((K) THREE, (V) THIRTY);\n-\n-        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n-        Map.Entry<K, V> entry = it.next();\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        final Map.Entry<K, V> entry = it.next();\n         entry.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEntryIteratorSetValue2() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        map.put((K) ONE, (V) TEN);\n-        map.put((K) TWO, (V) TWENTY);\n-        map.put((K) THREE, (V) THIRTY);\n-\n-        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n-        it.next();\n-        Map.Entry<K, V> entry = it.next();\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        final Map.Entry<K, V> entry = it.next();\n         entry.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testEntryIteratorSetValue3() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        map.put((K) ONE, (V) TEN);\n-        map.put((K) TWO, (V) TWENTY);\n-        map.put((K) THREE, (V) THIRTY);\n-\n-        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n-        it.next();\n-        it.next();\n-        Map.Entry<K, V> entry = it.next();\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        it.next();\n+        final Map.Entry<K, V> entry = it.next();\n         entry.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n         assertEquals(true, map.containsKey(ONE));\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testMapIteratorSetValue1() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        map.put((K) ONE, (V) TEN);\n-        map.put((K) TWO, (V) TWENTY);\n-        map.put((K) THREE, (V) THIRTY);\n-\n-        MapIterator<K, V> it = map.mapIterator();\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final MapIterator<K, V> it = map.mapIterator();\n         it.next();\n         it.setValue((V) \"NewValue\");\n         assertEquals(3, map.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testMapIteratorSetValue2() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        map.put((K) ONE, (V) TEN);\n-        map.put((K) TWO, (V) TWENTY);\n-        map.put((K) THREE, (V) THIRTY);\n-\n-        MapIterator<K, V> it = map.mapIterator();\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final MapIterator<K, V> it = map.mapIterator();\n         it.next();\n         it.next();\n         it.setValue((V) \"NewValue\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testMapIteratorSetValue3() throws Exception {\n-        Flat3Map<K, V> map = makeObject();\n-        map.put((K) ONE, (V) TEN);\n-        map.put((K) TWO, (V) TWENTY);\n-        map.put((K) THREE, (V) THIRTY);\n-\n-        MapIterator<K, V> it = map.mapIterator();\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final MapIterator<K, V> it = map.mapIterator();\n         it.next();\n         it.next();\n         it.next();\n //    }\n \n     public void testCollections261() {\n-        Flat3Map<Integer, Integer> m = new Flat3Map<Integer, Integer>();\n+        final Flat3Map<Integer, Integer> m = new Flat3Map<Integer, Integer>();\n         m.put( new Integer(1), new Integer(1) );\n         m.put( new Integer(0), new Integer(0) );\n         assertEquals( new Integer(1), m.remove( new Integer(1) ) ); \n--- a/src/test/java/org/apache/commons/collections/map/HashedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/HashedMapTest.java\n  */\n public class HashedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public HashedMapTest(String testName) {\n+    public HashedMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        HashedMap<K, V> map = new HashedMap<K, V>(10);\n+        final HashedMap<K, V> map = new HashedMap<K, V>(10);\n         map.put((K) \"1\", (V) \"1\");\n-        HashedMap<K, V> cloned = map.clone();\n+        final HashedMap<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n \n     public void testInternalState() {\n-        HashedMap<K, V> map = new HashedMap<K, V>(42, 0.75f);\n+        final HashedMap<K, V> map = new HashedMap<K, V>(42, 0.75f);\n         assertEquals(0.75f, map.loadFactor, 0.1f);\n         assertEquals(0, map.size);\n         assertEquals(64, map.data.length);\n--- a/src/test/java/org/apache/commons/collections/map/IdentityMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/IdentityMapTest.java\n     private static final Integer I2A = new Integer(2);\n     private static final Integer I2B = new Integer(2);\n \n-    public IdentityMapTest(String testName) {\n+    public IdentityMapTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testBasics() {\n-        IterableMap<K, V> map = new IdentityMap<K, V>();\n+        final IterableMap<K, V> map = new IdentityMap<K, V>();\n         assertEquals(0, map.size());\n \n         map.put((K) I1A, (V) I2A);\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testHashEntry() {\n-        IterableMap<K, V> map = new IdentityMap<K, V>();\n+        final IterableMap<K, V> map = new IdentityMap<K, V>();\n \n         map.put((K) I1A, (V) I2A);\n         map.put((K) I1B, (V) I2A);\n \n-        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n-        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n-        Map.Entry<K, V> entry2 = it.next();\n-        Map.Entry<K, V> entry3 = it.next();\n+        final Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        final Map.Entry<K, V> entry2 = it.next();\n+        final Map.Entry<K, V> entry3 = it.next();\n \n         assertEquals(true, entry1.equals(entry2));\n         assertEquals(true, entry2.equals(entry1));\n      */\n     public void testEmptyMapCompatibility() throws IOException, ClassNotFoundException {\n         // test to make sure the canonical form has been preserved\n-        Map<K, V> map = makeObject();\n+        final Map<K, V> map = makeObject();\n         if (map instanceof Serializable && !skipSerializedCanonicalTests()) {\n             @SuppressWarnings(\"unchecked\")\n+            final\n             Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n             assertEquals(\"Map is empty\", 0, map2.size());\n         }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        IdentityMap<K, V> map = new IdentityMap<K, V>(10);\n+        final IdentityMap<K, V> map = new IdentityMap<K, V>(10);\n         map.put((K) \"1\", (V) \"1\");\n-        Map<K, V> cloned = map.clone();\n+        final Map<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n--- a/src/test/java/org/apache/commons/collections/map/LRUMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/LRUMapTest.java\n  */\n public class LRUMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n \n-    public LRUMapTest(String testName) {\n+    public LRUMapTest(final String testName) {\n         super(testName);\n     }\n \n         if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n             return;\n         }\n-        K[] keys = getSampleKeys();\n-        V[] values = getSampleValues();\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n         Iterator<K> kit;\n         Iterator<V> vit;\n \n-        LRUMap<K, V> map = new LRUMap<K, V>(2);\n+        final LRUMap<K, V> map = new LRUMap<K, V>(2);\n         assertEquals(0, map.size());\n         assertEquals(false, map.isFull());\n         assertEquals(2, map.maxSize());\n \n         resetFull();\n         ordered = getMap();\n-        List<K> list = new ArrayList<K>(ordered.keySet());\n-        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        final List<K> list = new ArrayList<K>(ordered.keySet());\n+        final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n         assertSame(list.get(0), it.next());\n         assertSame(list.get(1), it.next());\n         it.reset();\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n             return;\n         }\n-        K[] keys = getSampleKeys();\n-        V[] values = getSampleValues();\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n         Iterator<K> kit = null;\n         Iterator<V> vit = null;\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        LRUMap<K, V> map = new LRUMap<K, V>(10);\n+        final LRUMap<K, V> map = new LRUMap<K, V>(10);\n         map.put((K) \"1\", (V) \"1\");\n-        Map<K, V> cloned = map.clone();\n+        final Map<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRU() {\n-        MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<K, String>(2);\n+        final MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<K, String>(2);\n         assertNull(map.entry);\n         map.put((K) \"A\", \"a\");\n         assertNull(map.entry);\n         K key;\n         V value;\n \n-        MockLRUMapSubclass(int size) {\n+        MockLRUMapSubclass(final int size) {\n             super(size);\n         }\n \n         @Override\n-        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n             this.entry = entry;\n             this.key = entry.getKey();\n             this.value = entry.getValue();\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRUBlocksRemove() {\n-        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, false);\n+        final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, false);\n         assertEquals(0, map.size());\n         map.put((K) \"A\", (V) \"a\");\n         assertEquals(1, map.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRUBlocksRemoveScan() {\n-        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, true);\n+        final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, true);\n         assertEquals(0, map.size());\n         map.put((K) \"A\", (V) \"a\");\n         assertEquals(1, map.size());\n \n     @SuppressWarnings(\"serial\")\n     static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {\n-        MockLRUMapSubclassBlocksRemove(int size, boolean scanUntilRemove) {\n+        MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove) {\n             super(size, scanUntilRemove);\n         }\n \n         @Override\n-        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n             return false;\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveLRUFirstBlocksRemove() {\n-        MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<K, V>(2);\n+        final MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<K, V>(2);\n         assertEquals(0, map.size());\n         map.put((K) \"A\", (V) \"a\");\n         assertEquals(1, map.size());\n \n     @SuppressWarnings(\"serial\")\n     static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {\n-        MockLRUMapSubclassFirstBlocksRemove(int size) {\n+        MockLRUMapSubclassFirstBlocksRemove(final int size) {\n             super(size, true);\n         }\n \n         @Override\n-        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n             if (\"a\".equals(entry.getValue())) {\n                 return false;\n             } else {\n     //-----------------------------------------------------------------------\n     static class SingleHashCode {\n         private final String code;\n-        SingleHashCode(String code) {\n+        SingleHashCode(final String code) {\n             this.code = code;\n         }\n         @Override\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n             return;\n         }\n-        SingleHashCode one = new SingleHashCode(\"1\");\n-        SingleHashCode two = new SingleHashCode(\"2\");\n-        SingleHashCode three = new SingleHashCode(\"3\");\n-        SingleHashCode four = new SingleHashCode(\"4\");\n-        SingleHashCode five = new SingleHashCode(\"5\");\n-        SingleHashCode six = new SingleHashCode(\"6\");\n-\n-        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n-        int hashIndex = map.hashIndex(map.hash(one), 4);\n+        final SingleHashCode one = new SingleHashCode(\"1\");\n+        final SingleHashCode two = new SingleHashCode(\"2\");\n+        final SingleHashCode three = new SingleHashCode(\"3\");\n+        final SingleHashCode four = new SingleHashCode(\"4\");\n+        final SingleHashCode five = new SingleHashCode(\"5\");\n+        final SingleHashCode six = new SingleHashCode(\"6\");\n+\n+        final LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        final int hashIndex = map.hashIndex(map.hash(one), 4);\n         map.put((K) one, (V) \"A\");\n         map.put((K) two, (V) \"B\");\n         map.put((K) three, (V) \"C\");\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n             return;\n         }\n-        SingleHashCode one = new SingleHashCode(\"1\");\n-        SingleHashCode two = new SingleHashCode(\"2\");\n-        SingleHashCode three = new SingleHashCode(\"3\");\n-\n-        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        final SingleHashCode one = new SingleHashCode(\"1\");\n+        final SingleHashCode two = new SingleHashCode(\"2\");\n+        final SingleHashCode three = new SingleHashCode(\"3\");\n+\n+        final LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n         map.put((K) one, (V) \"A\");\n         map.put((K) two, (V) \"B\");\n         map.put((K) three, (V) \"C\");\n         try {\n             map.getEntry(-1);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             map.getEntry(3);\n             fail();\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n     }\n     \n     public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n+            public void uncaughtException(final Thread t, final Throwable e) {\n                 exceptions.put(e, t.getName());\n                 super.uncaughtException(t, e);\n             }\n                             notifyAll();\n                             wait();\n                         }\n-                        Thread thread = Thread.currentThread();\n+                        final Thread thread = Thread.currentThread();\n                         while (i < 1000  && !interrupted()) {\n                             synchronized (map) {\n                                 map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                             }\n                         }\n                         synchronized (map) {\n-                            for (MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {\n+                            for (final MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {\n                                 iter.next();\n                                 if (iter.getValue() == this) {\n                                     iter.remove();\n                                 }\n                             }\n                         }\n-                    } catch (InterruptedException e) {\n+                    } catch (final InterruptedException e) {\n                         fail(\"Unexpected InterruptedException\");\n                     }\n                     if (i > 0) {\n             };\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.start();\n                 thread.wait();\n             }\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.notifyAll();\n             }\n \n         Thread.sleep(1000);\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             thread.interrupt();\n         }\n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.join();\n             }\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n+            public void uncaughtException(final Thread t, final Throwable e) {\n                 exceptions.put(e, t.getName());\n                 super.uncaughtException(t, e);\n             }\n                             notifyAll();\n                             wait();\n                         }\n-                        Thread thread = Thread.currentThread();\n+                        final Thread thread = Thread.currentThread();\n                         while (i < 1000  && !interrupted()) {\n                             synchronized (map) {\n                                 map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                             }\n                         }\n                         synchronized (map) {\n-                            for (Iterator<Map.Entry<Object, Thread>> iter = map.entrySet().iterator(); iter.hasNext();) {\n-                                Map.Entry<Object, Thread> entry = iter.next();\n+                            for (final Iterator<Map.Entry<Object, Thread>> iter = map.entrySet().iterator(); iter.hasNext();) {\n+                                final Map.Entry<Object, Thread> entry = iter.next();\n                                 if (entry.getValue() == this) {\n                                     iter.remove();\n                                 }\n                             }\n                         }\n-                    } catch (InterruptedException e) {\n+                    } catch (final InterruptedException e) {\n                         fail(\"Unexpected InterruptedException\");\n                     }\n                     if (i > 0) {\n             };\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.start();\n                 thread.wait();\n             }\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.notifyAll();\n             }\n \n         Thread.sleep(1000);\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             thread.interrupt();\n         }\n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.join();\n             }\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n+            public void uncaughtException(final Thread t, final Throwable e) {\n                 exceptions.put(e, t.getName());\n                 super.uncaughtException(t, e);\n             }\n                             notifyAll();\n                             wait();\n                         }\n-                        Thread thread = Thread.currentThread();\n+                        final Thread thread = Thread.currentThread();\n                         while (i < 1000  && !interrupted()) {\n                             synchronized (map) {\n                                 map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                             }\n                         }\n                         synchronized (map) {\n-                            for (Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {\n-                                String name = (String) iter.next();\n+                            for (final Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {\n+                                final String name = (String) iter.next();\n                                 if (name.substring(0, name.indexOf('[')).equals(getName())) {\n                                     iter.remove();\n                                 }\n                             }\n                         }\n-                    } catch (InterruptedException e) {\n+                    } catch (final InterruptedException e) {\n                         fail(\"Unexpected InterruptedException\");\n                     }\n                     if (i > 0) {\n             };\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.start();\n                 thread.wait();\n             }\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.notifyAll();\n             }\n \n         Thread.sleep(1000);\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             thread.interrupt();\n         }\n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.join();\n             }\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n+            public void uncaughtException(final Thread t, final Throwable e) {\n                 exceptions.put(e, t.getName());\n                 super.uncaughtException(t, e);\n             }\n                             notifyAll();\n                             wait();\n                         }\n-                        Thread thread = Thread.currentThread();\n+                        final Thread thread = Thread.currentThread();\n                         while (i < 1000  && !interrupted()) {\n                             synchronized (map) {\n                                 map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n                             }\n                         }\n                         synchronized (map) {\n-                            for (Iterator<Thread> iter = map.values().iterator(); iter.hasNext();) {\n+                            for (final Iterator<Thread> iter = map.values().iterator(); iter.hasNext();) {\n                                 if (iter.next() == this) {\n                                     iter.remove();\n                                 }\n                             }\n                         }\n-                    } catch (InterruptedException e) {\n+                    } catch (final InterruptedException e) {\n                         fail(\"Unexpected InterruptedException\");\n                     }\n                     if (i > 0) {\n             };\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.start();\n                 thread.wait();\n             }\n         }\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.notifyAll();\n             }\n \n         Thread.sleep(1000);\n \n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             thread.interrupt();\n         }\n-        for (Thread thread : threads) {\n+        for (final Thread thread : threads) {\n             synchronized (thread) {\n                 thread.join();\n             }\n--- a/src/test/java/org/apache/commons/collections/map/LazyMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/LazyMapTest.java\n \n     private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n \n-    public LazyMapTest(String testName) {\n+    public LazyMapTest(final String testName) {\n         super(testName);\n     }\n \n     public void mapGetWithFactory() {\n         Map<Integer, Number> map = lazyMap(new HashMap<Integer,Number>(), oneFactory);\n         assertEquals(0, map.size());\n-        Number i1 = map.get(\"Five\");\n+        final Number i1 = map.get(\"Five\");\n         assertEquals(1, i1);\n         assertEquals(1, map.size());\n-        Number i2 = map.get(new String(new char[] {'F','i','v','e'}));\n+        final Number i2 = map.get(new String(new char[] {'F','i','v','e'}));\n         assertEquals(1, i2);\n         assertEquals(1, map.size());\n         assertSame(i1, i2);\n \n         map = lazyMap(new HashMap<Integer,Number>(), FactoryUtils.<Long>nullFactory());\n-        Object o = map.get(\"Five\");\n+        final Object o = map.get(\"Five\");\n         assertEquals(null,o);\n         assertEquals(1, map.size());\n     }\n \n     @Test\n     public void mapGetWithTransformer() {\n-        Transformer<Number, Integer> intConverter = new Transformer<Number, Integer>(){\n-            public Integer transform(Number input) {\n+        final Transformer<Number, Integer> intConverter = new Transformer<Number, Integer>(){\n+            public Integer transform(final Number input) {\n                 return input.intValue();\n             }\n         };\n-        Map<Long, Number> map = lazyMap(new HashMap<Long,Number>(), intConverter );\n+        final Map<Long, Number> map = lazyMap(new HashMap<Long,Number>(), intConverter );\n         assertEquals(0, map.size());\n-        Number i1 = map.get(123L);\n+        final Number i1 = map.get(123L);\n         assertEquals(123, i1);\n         assertEquals(1, map.size());\n     }\n--- a/src/test/java/org/apache/commons/collections/map/LazySortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/LazySortedMapTest.java\n     \n     private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n    \n-    public LazySortedMapTest(String testName) {\n+    public LazySortedMapTest(final String testName) {\n         super(testName);\n     }\n     \n     public void mapGet() {\n         Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer,Number>(), oneFactory);\n         assertEquals(0, map.size());\n-        Number i1 = map.get(5);\n+        final Number i1 = map.get(5);\n         assertEquals(1, i1);\n         assertEquals(1, map.size());\n \n         map = lazySortedMap(new TreeMap<Integer,Number>(), FactoryUtils.<Number>nullFactory());\n-        Number o = map.get(5);\n+        final Number o = map.get(5);\n         assertEquals(null,o);\n         assertEquals(1, map.size());\n         \n     \n     //-----------------------------------------------------------------------\n     public void testSortOrder() {\n-        SortedMap<String, Number> map = lazySortedMap(new TreeMap<String,Number>(), oneFactory);\n+        final SortedMap<String, Number> map = lazySortedMap(new TreeMap<String,Number>(), oneFactory);\n         map.put(\"A\",  5);\n         map.get(\"B\"); // Entry with value \"One\" created\n         map.put(\"C\", 8);\n         assertEquals(\"Last key in submap should be B\",\n             \"B\", map.subMap(\"A\",\"C\").lastKey());\n         \n-        Comparator<?> c = map.comparator();\n+        final Comparator<?> c = map.comparator();\n         assertTrue(\"natural order, so comparator should be null\", \n             c == null);      \n     } \n     \n     public void testTransformerDecorate() {\n-        Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n+        final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n         SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);     \n         assertTrue(map instanceof LazySortedMap);  \n          try {\n             map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n             fail(\"Expecting IllegalArgumentException for null transformer\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         try {\n             map = lazySortedMap((SortedMap<Integer,Number>) null, transformer);\n             fail(\"Expecting IllegalArgumentException for null map\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         } \n     }\n--- a/src/test/java/org/apache/commons/collections/map/LinkedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/LinkedMapTest.java\n  */\n public class LinkedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n \n-    public LinkedMapTest(String testName) {\n+    public LinkedMapTest(final String testName) {\n         super(testName);\n     }\n \n \n         resetFull();\n         ordered = getMap();\n-        List<K> list = new ArrayList<K>(ordered.keySet());\n-        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        final List<K> list = new ArrayList<K>(ordered.keySet());\n+        final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n         assertSame(list.get(0), it.next());\n         assertSame(list.get(1), it.next());\n         it.reset();\n         if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n             return;\n         }\n-        K[] keys = getSampleKeys();\n-        V[] values = getSampleValues();\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n         Iterator<K> keyIter;\n         Iterator<V> valueIter;\n \n         LinkedMap<K, V> lm = getMap();\n         try {\n             lm.get(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lm.get(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lm = getMap();\n         try {\n             lm.get(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lm.get(lm.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         int i = 0;\n-        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n             assertSame(it.next(), lm.get(i));\n         }\n     }\n         LinkedMap<K, V> lm = getMap();\n         try {\n             lm.getValue(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lm.getValue(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lm = getMap();\n         try {\n             lm.getValue(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lm.getValue(lm.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         int i = 0;\n-        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n             it.next();\n             assertSame(it.getValue(), lm.getValue(i));\n         }\n \n         resetFull();\n         lm = getMap();\n-        List<K> list = new ArrayList<K>();\n-        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n         LinkedMap<K, V> lm = getMap();\n         try {\n             lm.remove(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lm.remove(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lm = getMap();\n         try {\n             lm.remove(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lm.remove(lm.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n-\n-        List<K> list = new ArrayList<K>();\n-        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n-            Object key = list.get(i);\n-            Object value = lm.get(key);\n+            final Object key = list.get(i);\n+            final Object value = lm.get(key);\n             assertEquals(value, lm.remove(i));\n             list.remove(i);\n             assertEquals(false, lm.containsKey(key));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        LinkedMap<K, V> map = new LinkedMap<K, V>(10);\n+        final LinkedMap<K, V> map = new LinkedMap<K, V>(10);\n         map.put((K) \"1\", (V) \"1\");\n-        Map<K, V> cloned = map.clone();\n+        final Map<K, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(\"1\"), cloned.get(\"1\"));\n     }\n--- a/src/test/java/org/apache/commons/collections/map/ListOrderedMap2Test.java\n+++ b/src/test/java/org/apache/commons/collections/map/ListOrderedMap2Test.java\n  */\n public class ListOrderedMap2Test<K, V> extends AbstractOrderedMapTest<K, V> {\n \n-    public ListOrderedMap2Test(String testName) {\n+    public ListOrderedMap2Test(final String testName) {\n         super(testName);\n     }\n \n         ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.get(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lom = getMap();\n         try {\n             lom.get(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(lom.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         int i = 0;\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             assertSame(it.next(), lom.get(i));\n         }\n     }\n         ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.getValue(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lom = getMap();\n         try {\n             lom.getValue(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(lom.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         int i = 0;\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             it.next();\n             assertSame(it.getValue(), lom.getValue(i));\n         }\n \n         resetFull();\n         lom = getMap();\n-        List<K> list = new ArrayList<K>();\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n         ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.remove(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lom = getMap();\n         try {\n             lom.remove(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(lom.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n-\n-        List<K> list = new ArrayList<K>();\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n-            Object key = list.get(i);\n-            Object value = lom.get(key);\n+            final Object key = list.get(i);\n+            final Object value = lom.get(key);\n             assertEquals(value, lom.remove(i));\n             list.remove(i);\n             assertEquals(false, lom.containsKey(key));\n--- a/src/test/java/org/apache/commons/collections/map/ListOrderedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/ListOrderedMapTest.java\n  */\n public class ListOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n \n-    public ListOrderedMapTest(String testName) {\n+    public ListOrderedMapTest(final String testName) {\n         super(testName);\n     }\n \n         ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.get(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lom = getMap();\n         try {\n             lom.get(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.get(lom.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         int i = 0;\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             assertSame(it.next(), lom.get(i));\n         }\n     }\n         ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.getValue(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lom = getMap();\n         try {\n             lom.getValue(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.getValue(lom.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         int i = 0;\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n             it.next();\n             assertSame(it.getValue(), lom.getValue(i));\n         }\n \n         resetFull();\n         lom = getMap();\n-        List<K> list = new ArrayList<K>();\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n         ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.setValue(0, (V) \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.setValue(-1, (V) \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lom = getMap();\n         try {\n             lom.setValue(-1, (V) \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.setValue(lom.size(), (V) \"\");\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         for (int i = 0; i < lom.size(); i++) {\n-            V value = lom.getValue(i);\n-            Object input = new Integer(i);\n+            final V value = lom.getValue(i);\n+            final Object input = new Integer(i);\n             assertEquals(value, lom.setValue(i, (V) input));\n             assertEquals(input, lom.getValue(i));\n         }\n         ListOrderedMap<K, V> lom = getMap();\n         try {\n             lom.remove(0);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         resetFull();\n         lom = getMap();\n         try {\n             lom.remove(-1);\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.remove(lom.size());\n-        } catch (IndexOutOfBoundsException ex) {}\n-\n-        List<K> list = new ArrayList<K>();\n-        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n             list.add(it.next());\n         }\n         for (int i = 0; i < list.size(); i++) {\n-            Object key = list.get(i);\n-            Object value = lom.get(key);\n+            final Object key = list.get(i);\n+            final Object value = lom.get(key);\n             assertEquals(value, lom.remove(i));\n             list.remove(i);\n             assertEquals(false, lom.containsKey(key));\n         try {\n             lom.put(1, (K) \"testInsert1\", (V) \"testInsert1v\");\n             fail(\"should not be able to insert at pos 1 in empty Map\");\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n         try {\n             lom.put(-1, (K) \"testInsert-1\", (V) \"testInsert-1v\");\n             fail(\"should not be able to insert at pos -1 in empty Map\");\n-        } catch (IndexOutOfBoundsException ex) {}\n+        } catch (final IndexOutOfBoundsException ex) {}\n \n         // put where key doesn't exist\n         lom.put(0, (K) \"testInsert1\", (V) \"testInsert1v\");\n         // put in a full map\n         resetFull();\n         lom = getMap();\n-        ListOrderedMap<K, V> lom2 = new ListOrderedMap<K, V>();\n+        final ListOrderedMap<K, V> lom2 = new ListOrderedMap<K, V>();\n         lom2.putAll(lom);\n \n         lom2.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n         }\n \n         // put where key does exist\n-        Integer i1 = new Integer(1);\n-        Integer i1b = new Integer(1);\n-        Integer i2 = new Integer(2);\n-        Integer i3 = new Integer(3);\n+        final Integer i1 = new Integer(1);\n+        final Integer i1b = new Integer(1);\n+        final Integer i2 = new Integer(2);\n+        final Integer i3 = new Integer(3);\n \n         resetEmpty();\n         lom = getMap();\n \n     public void testPutAllWithIndex() {\n         resetEmpty();\n-        ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;\n+        final ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;\n \n         // Create Initial Data\n         lom.put(\"testInsert0\", \"testInsert0v\");\n         assertEquals(\"testInsert2v\", lom.getValue(2));\n \n         // Create New Test Map and Add using putAll(int, Object, Object)\n-        Map<String, String> values = new ListOrderedMap<String, String>();\n+        final Map<String, String> values = new ListOrderedMap<String, String>();\n         values.put(\"NewInsert0\", \"NewInsert0v\");\n         values.put(\"NewInsert1\", \"NewInsert1v\");\n         lom.putAll(1, values);\n     public void testPutAllWithIndexBug441() {\n         // see COLLECTIONS-441\n         resetEmpty();\n-        ListOrderedMap<K, V> lom = getMap();\n-\n-        int size = 5;\n+        final ListOrderedMap<K, V> lom = getMap();\n+\n+        final int size = 5;\n         for (int i = 0; i < size; i++) {\n             lom.put((K) Integer.valueOf(i), (V) Boolean.valueOf(true));\n         }\n \n-        Map<K, V> map = new TreeMap<K, V>();\n+        final Map<K, V> map = new TreeMap<K, V>();\n         for (int i = 0; i < size; i++) {\n             map.put((K) Integer.valueOf(i), (V) Boolean.valueOf(false));\n         }\n \n         lom.putAll(3, map);\n         \n-        List<K> orderedList = lom.asList();\n+        final List<K> orderedList = lom.asList();\n         for (int i = 0; i < size; i++) {\n             assertEquals(i, orderedList.get(i));\n         }\n     //-----------------------------------------------------------------------\n     public void testValueList_getByIndex() {\n         resetFull();\n-        ListOrderedMap<K, V> lom = getMap();\n+        final ListOrderedMap<K, V> lom = getMap();\n         for (int i = 0; i < lom.size(); i++) {\n-            V expected = lom.getValue(i);\n+            final V expected = lom.getValue(i);\n             assertEquals(expected, lom.valueList().get(i));\n         }\n     }\n     @SuppressWarnings(\"unchecked\")\n     public void testValueList_setByIndex() {\n         resetFull();\n-        ListOrderedMap<K, V> lom = getMap();\n+        final ListOrderedMap<K, V> lom = getMap();\n         for (int i = 0; i < lom.size(); i++) {\n-            Object input = new Integer(i);\n-            V expected = lom.getValue(i);\n+            final Object input = new Integer(i);\n+            final V expected = lom.getValue(i);\n             assertEquals(expected, lom.valueList().set(i, (V) input));\n             assertEquals(input, lom.getValue(i));\n             assertEquals(input, lom.valueList().get(i));\n \n     public void testValueList_removeByIndex() {\n         resetFull();\n-        ListOrderedMap<K, V> lom = getMap();\n+        final ListOrderedMap<K, V> lom = getMap();\n         while (lom.size() > 1) {\n-            V expected = lom.getValue(1);\n+            final V expected = lom.getValue(1);\n             assertEquals(expected, lom.valueList().remove(1));\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/map/MultiKeyMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/MultiKeyMapTest.java\n     static final Integer I7 = new Integer(7);\n     static final Integer I8 = new Integer(8);\n \n-    public MultiKeyMapTest(String testName) {\n+    public MultiKeyMapTest(final String testName) {\n         super(testName);\n     }\n \n         try {\n             map.put(null, null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n         assertEquals(null, map.put(new MultiKey<K>(null, null), null));\n         try {\n             map.put(null, (V) new Object());\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n     public void testMultiKeyGet() {\n         resetFull();\n-        MultiKeyMap<K, V> multimap = getMap();\n-        MultiKey<K>[] keys = getMultiKeyKeys();\n-        V[] values = getSampleValues();\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+        final V[] values = getSampleValues();\n \n         for (int i = 0; i < keys.length; i++) {\n-            MultiKey<K> key = keys[i];\n-            V value = values[i];\n+            final MultiKey<K> key = keys[i];\n+            final V value = values[i];\n \n             switch (key.size()) {\n                 case 2:\n \n     public void testMultiKeyContainsKey() {\n         resetFull();\n-        MultiKeyMap<K, V> multimap = getMap();\n-        MultiKey<K>[] keys = getMultiKeyKeys();\n-\n-        for (MultiKey<K> key : keys) {\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+\n+        for (final MultiKey<K> key : keys) {\n             switch (key.size()) {\n                 case 2:\n                 assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n     }\n \n     public void testMultiKeyPut() {\n-        MultiKey<K>[] keys = getMultiKeyKeys();\n-        V[] values = getSampleValues();\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+        final V[] values = getSampleValues();\n \n         for (int i = 0; i < keys.length; i++) {\n-            MultiKeyMap<K, V> multimap = new MultiKeyMap<K, V>();\n-\n-            MultiKey<K> key = keys[i];\n-            V value = values[i];\n+            final MultiKeyMap<K, V> multimap = new MultiKeyMap<K, V>();\n+\n+            final MultiKey<K> key = keys[i];\n+            final V value = values[i];\n \n             switch (key.size()) {\n                 case 2:\n     }\n \n     public void testMultiKeyRemove() {\n-        MultiKey<K>[] keys = getMultiKeyKeys();\n-        V[] values = getSampleValues();\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+        final V[] values = getSampleValues();\n \n         for (int i = 0; i < keys.length; i++) {\n             resetFull();\n-            MultiKeyMap<K, V> multimap = getMap();\n-            int size = multimap.size();\n-\n-            MultiKey<K> key = keys[i];\n-            V value = values[i];\n+            final MultiKeyMap<K, V> multimap = getMap();\n+            final int size = multimap.size();\n+\n+            final MultiKey<K> key = keys[i];\n+            final V value = values[i];\n \n             switch (key.size()) {\n                 case 2:\n \n     public void testMultiKeyRemoveAll1() {\n         resetFull();\n-        MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n \n         multimap.removeAll(I1);\n         assertEquals(8, multimap.size());\n-        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey<? extends K> key = it.next();\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n             assertEquals(false, I1.equals(key.getKey(0)));\n         }\n     }\n \n     public void testMultiKeyRemoveAll2() {\n         resetFull();\n-        MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n \n         multimap.removeAll(I2, I3);\n         assertEquals(9, multimap.size());\n-        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey<? extends K> key = it.next();\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n             assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));\n         }\n     }\n \n     public void testMultiKeyRemoveAll3() {\n         resetFull();\n-        MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n \n         multimap.removeAll(I1, I1, I2);\n         assertEquals(9, multimap.size());\n-        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey<? extends K> key = it.next();\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));\n         }\n     }\n \n     public void testMultiKeyRemoveAll4() {\n         resetFull();\n-        MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKeyMap<K, V> multimap = getMap();\n         assertEquals(12, multimap.size());\n \n         multimap.removeAll(I1, I1, I2, I3);\n         assertEquals(10, multimap.size());\n-        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n-            MultiKey<? extends K> key = it.next();\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n             assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));\n         }\n     }\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testClone() {\n-        MultiKeyMap<K, V> map = new MultiKeyMap<K, V>();\n+        final MultiKeyMap<K, V> map = new MultiKeyMap<K, V>();\n         map.put(new MultiKey<K>((K) I1, (K) I2), (V) \"1-2\");\n-        Map<MultiKey<? extends K>, V> cloned = map.clone();\n+        final Map<MultiKey<? extends K>, V> cloned = map.clone();\n         assertEquals(map.size(), cloned.size());\n         assertSame(map.get(new MultiKey<K>((K) I1, (K) I2)), cloned.get(new MultiKey<K>((K) I1, (K) I2)));\n     }\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testLRUMultiKeyMap() {\n-        MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));\n+        final MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));\n         map.put((K) I1, (K) I2, (V) \"1-2\");\n         map.put((K) I1, (K) I3, (V) \"1-1\");\n         assertEquals(2, map.size());\n         assertEquals(true, map.containsKey(I1, I4));\n         assertEquals(false, map.containsKey(I1, I2));\n \n-        MultiKeyMap<K, V> cloned = map.clone();\n+        final MultiKeyMap<K, V> cloned = map.clone();\n         assertEquals(2, map.size());\n         assertEquals(true, cloned.containsKey(I1, I3));\n         assertEquals(true, cloned.containsKey(I1, I4));\n--- a/src/test/java/org/apache/commons/collections/map/MultiValueMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/MultiValueMapTest.java\n  */\n public class MultiValueMapTest<K, V> extends AbstractObjectTest {\n \n-    public MultiValueMapTest(String testName) {\n+    public MultiValueMapTest(final String testName) {\n         super(testName);\n     }\n \n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(Class<C> collectionClass) {\n+    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(final Class<C> collectionClass) {\n         final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);\n         map.put((K) \"one\", (V) \"uno\");\n         map.put((K) \"one\", (V) \"un\");\n \n     public void testRemoveAllViaIterator() {\n         final MultiValueMap<K, V> map = createTestMap();\n-        for (Iterator<?> i = map.values().iterator(); i.hasNext();) {\n+        for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {\n             i.next();\n             i.remove();\n         }\n \n     public void testRemoveAllViaKeyedIterator() {\n         final MultiValueMap<K, V> map = createTestMap();\n-        for (Iterator<?> i = map.iterator(\"one\"); i.hasNext();) {\n+        for (final Iterator<?> i = map.iterator(\"one\"); i.hasNext();) {\n             i.next();\n             i.remove();\n         }\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testMapEquals() {\n-        MultiValueMap<K, V> one = new MultiValueMap<K, V>();\n-        Integer value = new Integer(1);\n+        final MultiValueMap<K, V> one = new MultiValueMap<K, V>();\n+        final Integer value = new Integer(1);\n         one.put((K) \"One\", value);\n         one.remove(\"One\", value);\n \n-        MultiValueMap<K, V> two = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> two = new MultiValueMap<K, V>();\n         assertEquals(two, one);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testGetCollection() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         map.put((K) \"A\", \"AA\");\n         assertSame(map.get(\"A\"), map.getCollection(\"A\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTotalSize() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         assertEquals(0, map.totalSize());\n         map.put((K) \"A\", \"AA\");\n         assertEquals(1, map.totalSize());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSize() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         assertEquals(0, map.size());\n         map.put((K) \"A\", \"AA\");\n         assertEquals(1, map.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSize_Key() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         assertEquals(0, map.size(\"A\"));\n         assertEquals(0, map.size(\"B\"));\n         map.put((K) \"A\", \"AA\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIterator_Key() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         assertEquals(false, map.iterator(\"A\").hasNext());\n         map.put((K) \"A\", \"AA\");\n-        Iterator<?> it = map.iterator(\"A\");\n+        final Iterator<?> it = map.iterator(\"A\");\n         assertEquals(true, it.hasNext());\n         it.next();\n         assertEquals(false, it.hasNext());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testContainsValue_Key() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         assertEquals(false, map.containsValue(\"A\", \"AA\"));\n         assertEquals(false, map.containsValue(\"B\", \"BB\"));\n         map.put((K) \"A\", \"AA\");\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutWithList() {\n-        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);\n+        final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);\n         assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n         assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n         assertEquals(1, test.size());\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutWithSet() {\n-        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);\n+        final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);\n         assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n         assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n         assertEquals(null, test.put((K) \"A\", \"a\"));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutAll_Map1() {\n-        MultiMap<K, V> original = new MultiValueMap<K, V>();\n+        final MultiMap<K, V> original = new MultiValueMap<K, V>();\n         original.put((K) \"key\", \"object1\");\n         original.put((K) \"key\", \"object2\");\n \n-        MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n         test.put((K) \"keyA\", \"objectA\");\n         test.put((K) \"key\", \"object0\");\n         test.putAll(original);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutAll_Map2() {\n-        Map<K, V> original = new HashMap<K, V>();\n+        final Map<K, V> original = new HashMap<K, V>();\n         original.put((K) \"keyX\", (V) \"object1\");\n         original.put((K) \"keyY\", (V) \"object2\");\n \n-        MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n         test.put((K) \"keyA\", \"objectA\");\n         test.put((K) \"keyX\", \"object0\");\n         test.putAll(original);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutAll_KeyCollection() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         Collection<V> coll = (Collection<V>) Arrays.asList(new Object[] { \"X\", \"Y\", \"Z\" });\n \n         assertEquals(true, map.putAll((K) \"A\", coll));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemove_KeyItem() {\n-        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n         map.put((K) \"A\", \"AA\");\n         map.put((K) \"A\", \"AB\");\n         map.put((K) \"A\", \"AC\");\n \n     @Override\n     public Object makeObject() {\n-        Map m = makeEmptyMap();\n+        final Map m = makeEmptyMap();\n         m.put(\"a\", \"1\");\n         m.put(\"a\", \"1b\");\n         m.put(\"b\", \"2\");\n //    }\n \n     public void testEmptyMapCompatibility() throws Exception {\n-        Map<?,?> map = makeEmptyMap();\n-        Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+        final Map<?,?> map = makeEmptyMap();\n+        final Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n         assertEquals(\"Map is empty\", 0, map2.size());\n     }\n     public void testFullMapCompatibility() throws Exception {\n-        Map<?,?> map = (Map<?,?>) makeObject();\n-        Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+        final Map<?,?> map = (Map<?,?>) makeObject();\n+        final Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n         assertEquals(\"Map is the right size\", map.size(), map2.size());\n-        for (Object key : map.keySet()) {\n+        for (final Object key : map.keySet()) {\n             assertEquals( \"Map had inequal elements\", map.get(key), map2.get(key) );\n             map2.remove(key);\n         }\n--- a/src/test/java/org/apache/commons/collections/map/PassiveExpiringMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/PassiveExpiringMapTest.java\n \n         private static final long serialVersionUID = 1L;\n \n-        public long expirationTime(Integer key, String value) {\n+        public long expirationTime(final Integer key, final String value) {\n             // odd keys expire immediately, even keys never expire\n             if (key == null) {\n                 return 0;\n         return BulkTest.makeSuite(PassiveExpiringMapTest.class);\n     }\n \n-    public PassiveExpiringMapTest(String testName) {\n+    public PassiveExpiringMapTest(final String testName) {\n         super(testName);\n     }\n \n     }\n \n     private Map<Integer, String> makeDecoratedTestMap() {\n-        Map<Integer, String> m = new HashMap<Integer, String>();\n+        final Map<Integer, String> m = new HashMap<Integer, String>();\n         m.put(Integer.valueOf(1), \"one\");\n         m.put(Integer.valueOf(2), \"two\");\n         m.put(Integer.valueOf(3), \"three\");\n     }\n \n     private Map<Integer, String> makeTestMap() {\n-        Map<Integer, String> m = new PassiveExpiringMap<Integer, String>(\n+        final Map<Integer, String> m = new PassiveExpiringMap<Integer, String>(\n                                                                          new TestExpirationPolicy());\n         m.put(Integer.valueOf(1), \"one\");\n         m.put(Integer.valueOf(2), \"two\");\n \n     public void testConstructors() {\n         try {\n-            Map<String, String> map = null;\n+            final Map<String, String> map = null;\n             new PassiveExpiringMap<String, String>(map);\n             fail(\"constructor - exception should have been thrown.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n-            ExpirationPolicy<String, String> policy = null;\n+            final ExpirationPolicy<String, String> policy = null;\n             new PassiveExpiringMap<String, String>(policy);\n             fail(\"constructor - exception should have been thrown.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // success\n         }\n \n         try {\n-            TimeUnit unit = null;\n+            final TimeUnit unit = null;\n             new PassiveExpiringMap<String, String>(10L, unit);\n             fail(\"constructor - exception should have been thrown.\");\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n             // success\n         }\n     }\n \n     public void testContainsKey() {\n-        Map<Integer, String> m = makeTestMap();\n+        final Map<Integer, String> m = makeTestMap();\n         assertFalse(m.containsKey(Integer.valueOf(1)));\n         assertFalse(m.containsKey(Integer.valueOf(3)));\n         assertFalse(m.containsKey(Integer.valueOf(5)));\n     }\n \n     public void testContainsValue() {\n-        Map<Integer, String> m = makeTestMap();\n+        final Map<Integer, String> m = makeTestMap();\n         assertFalse(m.containsValue(\"one\"));\n         assertFalse(m.containsValue(\"three\"));\n         assertFalse(m.containsValue(\"five\"));\n \n     public void testDecoratedMap() {\n         // entries shouldn't expire\n-        Map<Integer, String> m = makeDecoratedTestMap();\n+        final Map<Integer, String> m = makeDecoratedTestMap();\n         assertEquals(6, m.size());\n         assertEquals(\"one\", m.get(Integer.valueOf(1)));\n \n     }\n \n     public void testEntrySet() {\n-        Map<Integer, String> m = makeTestMap();\n+        final Map<Integer, String> m = makeTestMap();\n         assertEquals(3, m.entrySet().size());\n     }\n \n     public void testGet() {\n-        Map<Integer, String> m = makeTestMap();\n+        final Map<Integer, String> m = makeTestMap();\n         assertNull(m.get(Integer.valueOf(1)));\n         assertEquals(\"two\", m.get(Integer.valueOf(2)));\n         assertNull(m.get(Integer.valueOf(3)));\n     }\n \n     public void testKeySet() {\n-        Map<Integer, String> m = makeTestMap();\n+        final Map<Integer, String> m = makeTestMap();\n         assertEquals(3, m.keySet().size());\n     }\n \n     public void testSize() {\n-        Map<Integer, String> m = makeTestMap();\n+        final Map<Integer, String> m = makeTestMap();\n         assertEquals(3, m.size());\n     }\n \n     public void testValues() {\n-        Map<Integer, String> m = makeTestMap();\n+        final Map<Integer, String> m = makeTestMap();\n         assertEquals(3, m.values().size());\n     }\n \n     public void testZeroTimeToLive() {\n         // item should not be available\n-        PassiveExpiringMap<String, String> m = new PassiveExpiringMap<String, String>(\n+        final PassiveExpiringMap<String, String> m = new PassiveExpiringMap<String, String>(\n                                                                                       0L);\n         m.put(\"a\", \"b\");\n         assertNull(m.get(\"a\"));\n--- a/src/test/java/org/apache/commons/collections/map/PredicatedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/PredicatedMapTest.java\n     protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();\n \n     protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n-        public boolean evaluate(Object o) {\n+        public boolean evaluate(final Object o) {\n             return o instanceof String;\n         }\n     };\n \n-    public PredicatedMapTest(String testName) {\n+    public PredicatedMapTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n-    protected IterableMap<K, V> decorateMap(Map<K, V> map, Predicate<? super K> keyPredicate,\n-        Predicate<? super V> valuePredicate) {\n+    protected IterableMap<K, V> decorateMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,\n+        final Predicate<? super V> valuePredicate) {\n         return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testPut() {\n-        Map<K, V> map = makeTestMap();\n+        final Map<K, V> map = makeTestMap();\n         try {\n             map.put((K) \"Hi\", (V) new Integer(3));\n             fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             map.put((K) new Integer(3), (V) \"Hi\");\n             fail(\"Illegal key should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         assertTrue(!map.containsKey(new Integer(3)));\n         assertTrue(!map.containsValue(new Integer(3)));\n \n-        Map<K, V> map2 = new HashMap<K, V>();\n+        final Map<K, V> map2 = new HashMap<K, V>();\n         map2.put((K) \"A\", (V) \"a\");\n         map2.put((K) \"B\", (V) \"b\");\n         map2.put((K) \"C\", (V) \"c\");\n         try {\n             map.putAll(map2);\n             fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         map.put((K) \"E\", (V) \"e\");\n         Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n         try {\n-            Map.Entry<K, V> entry = iterator.next();\n+            final Map.Entry<K, V> entry = iterator.next();\n             entry.setValue((V) new Integer(3));\n             fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         map.put((K) \"F\", (V) \"f\");\n         iterator = map.entrySet().iterator();\n-        Map.Entry<K, V> entry = iterator.next();\n+        final Map.Entry<K, V> entry = iterator.next();\n         entry.setValue((V) \"x\");\n \n     }\n--- a/src/test/java/org/apache/commons/collections/map/PredicatedSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/PredicatedSortedMapTest.java\n     protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();\n \n     protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n-        public boolean evaluate(Object o) {\n+        public boolean evaluate(final Object o) {\n             return o instanceof String;\n         }\n     };\n \n-    public PredicatedSortedMapTest(String testName) {\n+    public PredicatedSortedMapTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n-    protected SortedMap<K, V> decorateMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n-        Predicate<? super V> valuePredicate) {\n+    protected SortedMap<K, V> decorateMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,\n+        final Predicate<? super V> valuePredicate) {\n         return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testPut() {\n-        Map<K, V> map = makeTestMap();\n+        final Map<K, V> map = makeTestMap();\n         try {\n             map.put((K) \"Hi\", (V) new Integer(3));\n             fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         try {\n             map.put((K) new Integer(3), (V) \"Hi\");\n             fail(\"Illegal key should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         assertTrue(!map.containsKey(new Integer(3)));\n         assertTrue(!map.containsValue(new Integer(3)));\n \n-        Map<K, V> map2 = new HashMap<K, V>();\n+        final Map<K, V> map2 = new HashMap<K, V>();\n         map2.put((K) \"A\", (V) \"a\");\n         map2.put((K) \"B\", (V) \"b\");\n         map2.put((K) \"C\", (V) \"c\");\n         try {\n             map.putAll(map2);\n             fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         map.put((K) \"E\", (V) \"e\");\n         Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n         try {\n-            Map.Entry<K, V> entry = iterator.next();\n+            final Map.Entry<K, V> entry = iterator.next();\n             entry.setValue((V) new Integer(3));\n             fail(\"Illegal value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n \n         map.put((K) \"F\", (V) \"f\");\n         iterator = map.entrySet().iterator();\n-        Map.Entry<K, V> entry = iterator.next();\n+        final Map.Entry<K, V> entry = iterator.next();\n         entry.setValue((V) \"x\");\n \n     }\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testSortOrder() {\n-        SortedMap<K, V> map = makeTestMap();\n+        final SortedMap<K, V> map = makeTestMap();\n         map.put((K) \"A\",  (V) \"a\");\n         map.put((K) \"B\", (V) \"b\");\n         try {\n             map.put(null, (V) \"c\");\n             fail(\"Null key should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         map.put((K) \"C\", (V) \"c\");\n         try {\n             map.put((K) \"D\", null);\n             fail(\"Null value should raise IllegalArgument\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertEquals(\"First key should be A\", \"A\", map.firstKey());\n         assertEquals(\"Last key in submap should be B\",\n            \"B\", map.subMap((K) \"A\",(K) \"C\").lastKey());\n \n-        Comparator<? super K> c = map.comparator();\n+        final Comparator<? super K> c = map.comparator();\n         assertTrue(\"natural order, so comparator should be null\",\n             c == null);\n     }\n--- a/src/test/java/org/apache/commons/collections/map/ReferenceIdentityMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/ReferenceIdentityMapTest.java\n     private static final Integer I2A = new Integer(2);\n     private static final Integer I2B = new Integer(2);\n \n-    public ReferenceIdentityMapTest(String testName) {\n+    public ReferenceIdentityMapTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testBasics() {\n-        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+        final IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n         assertEquals(0, map.size());\n \n         map.put((K) I1A, (V) I2A);\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testHashEntry() {\n-        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+        final IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n \n         map.put((K) I1A, (V) I2A);\n         map.put((K) I1B, (V) I2A);\n \n-        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n-        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n-        Map.Entry<K, V> entry2 = it.next();\n-        Map.Entry<K, V> entry3 = it.next();\n+        final Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        final Map.Entry<K, V> entry2 = it.next();\n+        final Map.Entry<K, V> entry3 = it.next();\n \n         assertEquals(true, entry1.equals(entry2));\n         assertEquals(true, entry2.equals(entry1));\n         try {\n             getMap().put(null, null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             getMap().put((K) new Object(), null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             getMap().put(null, (V) new Object());\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n \n     @SuppressWarnings(\"unchecked\")\n     private Map<K, V> buildRefMap() {\n-        K key = (K) new Object();\n-        V value = (V) new Object();\n+        final K key = (K) new Object();\n+        final V value = (V) new Object();\n \n         keyReference = new WeakReference<K>(key);\n         valueReference = new WeakReference<V>(value);\n \n-        Map<K, V> testMap = new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        final Map<K, V> testMap = new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n         testMap.put(key, value);\n \n         assertEquals(\"In map\", value, testMap.get(key));\n     /** Tests whether purge values setting works */\n     public void testPurgeValues() throws Exception {\n         // many thanks to Juozas Baliuka for suggesting this method\n-        Map<K, V> testMap = buildRefMap();\n+        final Map<K, V> testMap = buildRefMap();\n \n         int iterations = 0;\n         int bytz = 2;\n             } else {\n                 // create garbage:\n                 @SuppressWarnings(\"unused\")\n+                final\n                 byte[] b =  new byte[bytz];\n                 bytz = bytz * 2;\n             }\n     private static void gc() {\n         try {\n             // trigger GC\n-            byte[][] tooLarge = new byte[1000000000][1000000000];\n+            final byte[][] tooLarge = new byte[1000000000][1000000000];\n             fail(\"you have too much RAM\");\n-        } catch (OutOfMemoryError ex) {\n+        } catch (final OutOfMemoryError ex) {\n             System.gc(); // ignore\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/map/ReferenceMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/ReferenceMapTest.java\n  */\n public class ReferenceMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public ReferenceMapTest(String testName) {\n+    public ReferenceMapTest(final String testName) {\n         super(testName);\n     }\n \n         try {\n             map.put(null, null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             map.put((K) new Object(), null);\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             map.put(null, (V) new Object());\n             fail();\n-        } catch (NullPointerException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n \n     @SuppressWarnings(\"unchecked\")\n     public Map<K, V> buildRefMap() {\n-        K key = (K) new Object();\n-        V value = (V) new Object();\n+        final K key = (K) new Object();\n+        final V value = (V) new Object();\n \n         keyReference = new WeakReference<K>(key);\n         valueReference = new WeakReference<V>(value);\n \n-        Map<K, V> testMap = new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        final Map<K, V> testMap = new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n         testMap.put(key, value);\n \n         assertEquals(\"In map\", value, testMap.get(key));\n     /** Tests whether purge values setting works */\n     public void testPurgeValues() throws Exception {\n         // many thanks to Juozas Baliuka for suggesting this method\n-        Map<K, V> testMap = buildRefMap();\n+        final Map<K, V> testMap = buildRefMap();\n \n         int iterations = 0;\n         int bytz = 2;\n             } else {\n                 // create garbage:\n                 @SuppressWarnings(\"unused\")\n+                final\n                 byte[] b = new byte[bytz];\n                 bytz = bytz * 2;\n             }\n     private static void gc() {\n         try {\n             // trigger GC\n-            byte[][] tooLarge = new byte[1000000000][1000000000];\n+            final byte[][] tooLarge = new byte[1000000000][1000000000];\n             fail(\"you have too much RAM\");\n-        } catch (OutOfMemoryError ex) {\n+        } catch (final OutOfMemoryError ex) {\n             System.gc(); // ignore\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/map/SingletonMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/SingletonMapTest.java\n     private static final Integer TWO = new Integer(2);\n     private static final String TEN = \"10\";\n \n-    public SingletonMapTest(String testName) {\n+    public SingletonMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     //-----------------------------------------------------------------------\n     public void testClone() {\n-        SingletonMap<K, V> map = makeFullMap();\n+        final SingletonMap<K, V> map = makeFullMap();\n         assertEquals(1, map.size());\n-        SingletonMap<K, V> cloned = map.clone();\n+        final SingletonMap<K, V> cloned = map.clone();\n         assertEquals(1, cloned.size());\n         assertEquals(true, cloned.containsKey(ONE));\n         assertEquals(true, cloned.containsValue(TWO));\n     }\n \n     public void testKeyValue() {\n-        SingletonMap<K, V> map = makeFullMap();\n+        final SingletonMap<K, V> map = makeFullMap();\n         assertEquals(1, map.size());\n         assertEquals(ONE, map.getKey());\n         assertEquals(TWO, map.getValue());\n     }\n \n     public void testBoundedMap() {\n-        SingletonMap<K, V> map = makeFullMap();\n+        final SingletonMap<K, V> map = makeFullMap();\n         assertEquals(1, map.size());\n         assertEquals(true, map.isFull());\n         assertEquals(1, map.maxSize());\n--- a/src/test/java/org/apache/commons/collections/map/StaticBucketMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/StaticBucketMapTest.java\n  */\n public class StaticBucketMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public StaticBucketMapTest(String name) {\n+    public StaticBucketMapTest(final String name) {\n         super(name);\n     }\n \n \n     @Override\n     public String[] ignoredTests() {\n-        String pre = \"StaticBucketMapTest.bulkTestMap\";\n-        String post = \".testCollectionIteratorFailFast\";\n+        final String pre = \"StaticBucketMapTest.bulkTestMap\";\n+        final String post = \".testCollectionIteratorFailFast\";\n         return new String[] {\n             pre + \"EntrySet\" + post,\n             pre + \"KeySet\" + post,\n     // Bugzilla 37567\n     @SuppressWarnings(\"unchecked\")\n     public void test_get_nullMatchesIncorrectly() {\n-        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        final StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n         map.put(null, (V) \"A\");\n         assertEquals(\"A\", map.get(null));\n         // loop so we find a string that is in the same bucket as the null\n         for (int i = 'A'; i <= 'Z'; i++) {\n-            String str = String.valueOf((char) i);\n+            final String str = String.valueOf((char) i);\n             assertEquals(\"String: \" + str, null, map.get(str));\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void test_containsKey_nullMatchesIncorrectly() {\n-        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        final StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n         map.put(null, (V) \"A\");\n         assertEquals(true, map.containsKey(null));\n         // loop so we find a string that is in the same bucket as the null\n         for (int i = 'A'; i <= 'Z'; i++) {\n-            String str = String.valueOf((char) i);\n+            final String str = String.valueOf((char) i);\n             assertEquals(\"String: \" + str, false, map.containsKey(str));\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void test_containsValue_nullMatchesIncorrectly() {\n-        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        final StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n         map.put((K) \"A\", null);\n         assertEquals(true, map.containsValue(null));\n         // loop so we find a string that is in the same bucket as the null\n         for (int i = 'A'; i <= 'Z'; i++) {\n-            String str = String.valueOf((char) i);\n+            final String str = String.valueOf((char) i);\n             assertEquals(\"String: \" + str, false, map.containsValue(str));\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/map/TransformedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/TransformedMapTest.java\n  */\n public class TransformedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public TransformedMapTest(String testName) {\n+    public TransformedMapTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedMap() {\n-        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n \n         Map<K, V> map = TransformedMap\n                 .transformingMap(\n \n         assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n \n-        Set<Map.Entry<K, V>> entrySet = map.entrySet();\n-        Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        final Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n         array[0].setValue((V) \"66\");\n         assertEquals(new Integer(66), array[0].getValue());\n         assertEquals(new Integer(66), map.get(array[0].getKey()));\n \n-        Map.Entry entry = entrySet.iterator().next();\n+        final Map.Entry entry = entrySet.iterator().next();\n         entry.setValue(\"88\");\n         assertEquals(new Integer(88), entry.getValue());\n         assertEquals(new Integer(88), map.get(entry.getKey()));\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testFactory_Decorate() {\n-        Map<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> base = new HashMap<K, V>();\n         base.put((K) \"A\", (V) \"1\");\n         base.put((K) \"B\", (V) \"2\");\n         base.put((K) \"C\", (V) \"3\");\n \n-        Map<K, V> trans = TransformedMap\n+        final Map<K, V> trans = TransformedMap\n                 .transformingMap(\n                         base,\n                         null,\n \n     @SuppressWarnings(\"unchecked\")\n     public void testFactory_decorateTransform() {\n-        Map<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> base = new HashMap<K, V>();\n         base.put((K) \"A\", (V) \"1\");\n         base.put((K) \"B\", (V) \"2\");\n         base.put((K) \"C\", (V) \"3\");\n \n-        Map<K, V> trans = TransformedMap\n+        final Map<K, V> trans = TransformedMap\n                 .transformedMap(\n                         base,\n                         null,\n--- a/src/test/java/org/apache/commons/collections/map/TransformedSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/TransformedSortedMapTest.java\n  */\n public class TransformedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n \n-    public TransformedSortedMapTest(String testName) {\n+    public TransformedSortedMapTest(final String testName) {\n         super(testName);\n     }\n \n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedMap() {\n-        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n \n         SortedMap<K, V> map = TransformedSortedMap\n                 .transformingSortedMap(\n             try {\n                 map.containsKey(els[i]);\n                 fail();\n-            } catch (ClassCastException ex) {}\n+            } catch (final ClassCastException ex) {}\n             assertEquals(true, map.containsValue(els[i]));\n             assertEquals(els[i], map.get(new Integer((String) els[i])));\n         }\n         try {\n             map.remove(els[0]);\n             fail();\n-        } catch (ClassCastException ex) {}\n+        } catch (final ClassCastException ex) {}\n         assertEquals(els[0], map.remove(new Integer((String) els[0])));\n \n         map = TransformedSortedMap\n \n         assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n \n-        Set<Map.Entry<K, V>> entrySet = map.entrySet();\n-        Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        final Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n         array[0].setValue((V) \"66\");\n         assertEquals(new Integer(66), array[0].getValue());\n         assertEquals(new Integer(66), map.get(array[0].getKey()));\n \n-        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n         entry.setValue((V) \"88\");\n         assertEquals(new Integer(88), entry.getValue());\n         assertEquals(new Integer(88), map.get(entry.getKey()));\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testFactory_Decorate() {\n-        SortedMap<K, V> base = new TreeMap<K, V>();\n+        final SortedMap<K, V> base = new TreeMap<K, V>();\n         base.put((K) \"A\", (V) \"1\");\n         base.put((K) \"B\", (V) \"2\");\n         base.put((K) \"C\", (V) \"3\");\n \n-        SortedMap<K, V> trans = TransformedSortedMap\n+        final SortedMap<K, V> trans = TransformedSortedMap\n                 .transformingSortedMap(\n                         base,\n                         null,\n \n     @SuppressWarnings(\"unchecked\")\n     public void testFactory_decorateTransform() {\n-        SortedMap<K, V> base = new TreeMap<K, V>();\n+        final SortedMap<K, V> base = new TreeMap<K, V>();\n         base.put((K) \"A\", (V) \"1\");\n         base.put((K) \"B\", (V) \"2\");\n         base.put((K) \"C\", (V) \"3\");\n \n-        SortedMap<K, V> trans = TransformedSortedMap\n+        final SortedMap<K, V> trans = TransformedSortedMap\n                 .transformedSortedMap(\n                         base,\n                         null,\n--- a/src/test/java/org/apache/commons/collections/map/UnmodifiableMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/UnmodifiableMapTest.java\n  */\n public class UnmodifiableMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n-    public UnmodifiableMapTest(String testName) {\n+    public UnmodifiableMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public IterableMap<K, V> makeFullMap() {\n-        Map<K, V> m = new HashMap<K, V>();\n+        final Map<K, V> m = new HashMap<K, V>();\n         addSampleMappings(m);\n         return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);\n     }\n     }\n \n     public void testDecorateFactory() {\n-        Map<K, V> map = makeFullMap();\n+        final Map<K, V> map = makeFullMap();\n         assertSame(map, UnmodifiableMap.unmodifiableMap(map));\n \n         try {\n             UnmodifiableMap.unmodifiableMap(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     @Override\n--- a/src/test/java/org/apache/commons/collections/map/UnmodifiableOrderedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/UnmodifiableOrderedMapTest.java\n  */\n public class UnmodifiableOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n \n-    public UnmodifiableOrderedMapTest(String testName) {\n+    public UnmodifiableOrderedMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public OrderedMap<K, V> makeFullMap() {\n-        OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+        final OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n         addSampleMappings(m);\n         return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);\n     }\n     }\n \n     public void testDecorateFactory() {\n-        OrderedMap<K, V> map = makeFullMap();\n+        final OrderedMap<K, V> map = makeFullMap();\n         assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));\n \n         try {\n             UnmodifiableOrderedMap.unmodifiableOrderedMap(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     @Override\n--- a/src/test/java/org/apache/commons/collections/map/UnmodifiableSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/map/UnmodifiableSortedMapTest.java\n  */\n public class UnmodifiableSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n \n-    public UnmodifiableSortedMapTest(String testName) {\n+    public UnmodifiableSortedMapTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public SortedMap<K, V> makeFullMap() {\n-        SortedMap<K, V> m = new TreeMap<K, V>();\n+        final SortedMap<K, V> m = new TreeMap<K, V>();\n         addSampleMappings(m);\n         return UnmodifiableSortedMap.unmodifiableSortedMap(m);\n     }\n     }\n \n     public void testDecorateFactory() {\n-        SortedMap<K, V> map = makeFullMap();\n+        final SortedMap<K, V> map = makeFullMap();\n         assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));\n \n         try {\n             UnmodifiableSortedMap.unmodifiableSortedMap(null);\n             fail();\n-        } catch (IllegalArgumentException ex) {}\n+        } catch (final IllegalArgumentException ex) {}\n     }\n \n     @Override\n--- a/src/test/java/org/apache/commons/collections/set/AbstractSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/AbstractSetTest.java\n      *\n      * @param name  name for test\n      */\n-    public AbstractSetTest(String name) {\n+    public AbstractSetTest(final String name) {\n         super(name);\n     }\n \n         assertEquals(\"Sets should be equal\", getConfirmed(), getCollection());\n         assertEquals(\"Sets should have equal hashCodes\", \n                      getConfirmed().hashCode(), getCollection().hashCode());\n-        Collection<E> set = makeConfirmedCollection();\n-        Iterator<E> iterator = getCollection().iterator();\n+        final Collection<E> set = makeConfirmedCollection();\n+        final Iterator<E> iterator = getCollection().iterator();\n         while (iterator.hasNext()) {\n             assertTrue(\"Set.iterator should only return unique elements\", set.add(iterator.next()));\n         }\n      */\n     @Override\n     public Collection<E> makeConfirmedFullCollection() {\n-        Collection<E> set = makeConfirmedCollection();\n+        final Collection<E> set = makeConfirmedCollection();\n         set.addAll(Arrays.asList(getFullElements()));\n         return set;\n     }\n      */\n     @Override\n     public Set<E> makeFullCollection() {\n-        Set<E> set = makeObject();\n+        final Set<E> set = makeObject();\n         set.addAll(Arrays.asList(getFullElements()));\n         return set;\n     }\n         assertEquals(\"Empty sets should be equal\", getCollection(), getConfirmed());\n         verify();\n \n-        Collection<E> set2 = makeConfirmedCollection();\n+        final Collection<E> set2 = makeConfirmedCollection();\n         set2.add((E) \"foo\");\n         assertTrue(\"Empty set shouldn't equal nonempty set\", !getCollection().equals(set2));\n \n--- a/src/test/java/org/apache/commons/collections/set/AbstractSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/AbstractSortedSetTest.java\n      *\n      * @param name  name for test\n      */\n-    public AbstractSortedSetTest(String name) {\n+    public AbstractSortedSetTest(final String name) {\n         super(name);\n     }\n \n         \n         // Check that iterator returns elements in order and first() and last()\n         // are consistent\n-        Iterator<E> colliter = getCollection().iterator();\n-        Iterator<E> confiter = getConfirmed().iterator();\n+        final Iterator<E> colliter = getCollection().iterator();\n+        final Iterator<E> confiter = getConfirmed().iterator();\n         E first = null;\n         E last = null;\n         while (colliter.hasNext()) {\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public E[] getFullNonNullElements() {\n-        Object[] elements = new Object[30];\n+        final Object[] elements = new Object[30];\n \n         for (int i = 0; i < 30; i++) {\n             elements[i] = new Integer(i + i + 1);\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public E[] getOtherNonNullElements() {\n-        Object[] elements = new Object[30];\n+        final Object[] elements = new Object[30];\n         for (int i = 0; i < 30; i++) {\n             elements[i] = new Integer(i + i + 2);\n         }\n      * @return a {@link AbstractSetTest} instance for testing a subset.\n      */\n     public BulkTest bulkTestSortedSetSubSet() {\n-        int length = getFullElements().length;\n-\n-        int lobound = length / 3;\n-        int hibound = lobound * 2;\n+        final int length = getFullElements().length;\n+\n+        final int lobound = length / 3;\n+        final int hibound = lobound * 2;\n         return new TestSortedSetSubSet(lobound, hibound);\n \n     }\n      * @return a {@link AbstractSetTest} instance for testing a headset.\n      */\n     public BulkTest bulkTestSortedSetHeadSet() {\n-        int length = getFullElements().length;\n-\n-        int lobound = length / 3;\n-        int hibound = lobound * 2;\n+        final int length = getFullElements().length;\n+\n+        final int lobound = length / 3;\n+        final int hibound = lobound * 2;\n         return new TestSortedSetSubSet(hibound, true);\n \n     }\n      * @return a {@link AbstractSetTest} instance for testing a tailset.\n      */\n     public BulkTest bulkTestSortedSetTailSet() {\n-        int length = getFullElements().length;\n-        int lobound = length / 3;\n+        final int length = getFullElements().length;\n+        final int lobound = length / 3;\n         return new TestSortedSetSubSet(lobound, false);\n     }\n \n         private E[] m_OtherElements;\n \n         @SuppressWarnings(\"unchecked\")\n-        public TestSortedSetSubSet(int bound, boolean head) {\n+        public TestSortedSetSubSet(final int bound, final boolean head) {\n             super(\"TestSortedSetSubSet\");\n             if (head) {\n                 //System.out.println(\"HEADSET\");\n                 //System.out.println(\"TAILSET\");\n                 m_Type = TYPE_TAILSET;\n                 m_LowBound = bound;\n-                Object[] allelements = AbstractSortedSetTest.this.getFullElements();\n+                final Object[] allelements = AbstractSortedSetTest.this.getFullElements();\n                 //System.out.println(\"bound = \"+bound +\"::length=\"+allelements.length);\n                 m_FullElements = (E[]) new Object[allelements.length - bound];\n                 System.arraycopy(allelements, bound, m_FullElements, 0, allelements.length - bound);\n         } //type\n \n         @SuppressWarnings(\"unchecked\")\n-        public TestSortedSetSubSet(int lobound, int hibound) {\n+        public TestSortedSetSubSet(final int lobound, final int hibound) {\n             super(\"TestSortedSetSubSet\");\n             //System.out.println(\"SUBSET\");\n             m_Type = TYPE_SUBSET;\n             m_LowBound = lobound;\n             m_HighBound = hibound;\n-            int length = hibound - lobound;\n+            final int length = hibound - lobound;\n             //System.out.println(\"Low=\" + lobound + \"::High=\" + hibound + \"::Length=\" + length);\n             m_FullElements = (E[]) new Object[length];\n             System.arraycopy(AbstractSortedSetTest.this.getFullElements(), lobound, m_FullElements, 0, length);\n             return m_OtherElements;\n         }\n \n-        private SortedSet<E> getSubSet(SortedSet<E> set) {\n-            E[] elements = AbstractSortedSetTest.this.getFullElements();\n+        private SortedSet<E> getSubSet(final SortedSet<E> set) {\n+            final E[] elements = AbstractSortedSetTest.this.getFullElements();\n             switch (m_Type) {\n                 case TYPE_SUBSET :\n                     return set.subSet(elements[m_LowBound], elements[m_HighBound]);\n--- a/src/test/java/org/apache/commons/collections/set/CompositeSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/CompositeSetTest.java\n  * @version $Id$\n  */\n public class CompositeSetTest<E> extends AbstractSetTest<E> {\n-    public CompositeSetTest(String name) {\n+    public CompositeSetTest(final String name) {\n         super(name);\n     }\n \n     @Override\n     public CompositeSet<E> makeObject() {\n         final HashSet<E> contained = new HashSet<E>();\n-        CompositeSet<E> set = new CompositeSet<E>(contained);\n+        final CompositeSet<E> set = new CompositeSet<E>(contained);\n         set.setMutator( new EmptySetMutator<E>(contained) );\n         return set;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public Set<E> buildOne() {\n-        HashSet<E> set = new HashSet<E>();\n+        final HashSet<E> set = new HashSet<E>();\n         set.add((E) \"1\");\n         set.add((E) \"2\");\n         return set;\n \n     @SuppressWarnings(\"unchecked\")\n     public Set<E> buildTwo() {\n-        HashSet<E> set = new HashSet<E>();\n+        final HashSet<E> set = new HashSet<E>();\n         set.add((E) \"3\");\n         set.add((E) \"4\");\n         return set;\n \n     @SuppressWarnings(\"unchecked\")\n     public void testContains() {\n-        CompositeSet<E> set = new CompositeSet<E>(new Set[]{ buildOne(), buildTwo() });\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[]{ buildOne(), buildTwo() });\n         assertTrue(set.contains(\"1\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveUnderlying() {\n-        Set<E> one = buildOne();\n-        Set<E> two = buildTwo();\n-        CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n         one.remove(\"1\");\n         assertFalse(set.contains(\"1\"));\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveComposited() {\n-        Set<E> one = buildOne();\n-        Set<E> two = buildTwo();\n-        CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n         set.remove(\"1\");\n         assertFalse(one.contains(\"1\"));\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testFailedCollisionResolution() {\n-        Set<E> one = buildOne();\n-        Set<E> two = buildTwo();\n-        CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n         set.setMutator(new CompositeSet.SetMutator<E>() {\n             private static final long serialVersionUID = 1L;\n \n-            public void resolveCollision(CompositeSet<E> comp, Set<E> existing,\n-                Set<E> added, Collection<E> intersects) {\n+            public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing,\n+                final Set<E> added, final Collection<E> intersects) {\n                 //noop\n             }\n \n-            public boolean add(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, E obj) {\n+            public boolean add(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final E obj) {\n                 throw new UnsupportedOperationException();\n             }\n \n-            public boolean addAll(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Collection<? extends E> coll) {\n+            public boolean addAll(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n                 throw new UnsupportedOperationException();\n             }\n \n-            public boolean remove(CompositeCollection<E> composite,\n-                    List<Collection<E>> collections, Object obj) {\n+            public boolean remove(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Object obj) {\n                 throw new UnsupportedOperationException();\n             }\n         });\n \n-        HashSet<E> three = new HashSet<E>();\n+        final HashSet<E> three = new HashSet<E>();\n         three.add((E) \"1\");\n         try {\n             set.addComposited(three);\n             fail(\"IllegalArgumentException should have been thrown\");\n         }\n-        catch (IllegalArgumentException e) {\n+        catch (final IllegalArgumentException e) {\n             // expected\n         }\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testAddComposited() {\n-        Set<E> one = buildOne();\n-        Set<E> two = buildTwo();\n-        CompositeSet<E> set = new CompositeSet<E>();\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>();\n         set.addComposited(one, two);\n-        CompositeSet<E> set2 = new CompositeSet<E>(buildOne());\n+        final CompositeSet<E> set2 = new CompositeSet<E>(buildOne());\n         set2.addComposited(buildTwo());\n         assertTrue(set.equals(set2));\n-        HashSet<E> set3 = new HashSet<E>();\n+        final HashSet<E> set3 = new HashSet<E>();\n         set3.add((E) \"1\");\n         set3.add((E) \"2\");\n         set3.add((E) \"3\");\n-        HashSet<E> set4 = new HashSet<E>();\n+        final HashSet<E> set4 = new HashSet<E>();\n         set4.add((E) \"4\");\n-        CompositeSet<E> set5 = new CompositeSet<E>(set3);\n+        final CompositeSet<E> set5 = new CompositeSet<E>(set3);\n         set5.addComposited(set4);\n         assertTrue(set.equals(set5));\n         try {\n             set.addComposited(set3);\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException ex) {\n+        } catch (final UnsupportedOperationException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections/set/EmptySetMutator.java\n+++ b/src/test/java/org/apache/commons/collections/set/EmptySetMutator.java\n     /** Serialization version */\n     private static final long serialVersionUID = 5321193666420238910L;\n \n-    private Set<E> contained;\n+    private final Set<E> contained;\n \n-    public EmptySetMutator(Set<E> set) {\n+    public EmptySetMutator(final Set<E> set) {\n         this.contained = set;\n     }\n \n-    public void resolveCollision(CompositeSet<E> comp, Set<E> existing, Set<E> added, Collection<E> intersects) {\n+    public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing, final Set<E> added, final Collection<E> intersects) {\n         throw new IllegalArgumentException();\n     }\n     \n-    public boolean add(CompositeCollection<E> composite, List<Collection<E>> collections, E obj) {\n+    public boolean add(final CompositeCollection<E> composite, final List<Collection<E>> collections, final E obj) {\n         return contained.add(obj);\n     }\n     \n-    public boolean addAll(CompositeCollection<E> composite, List<Collection<E>> collections, Collection<? extends E> coll) {\n+    public boolean addAll(final CompositeCollection<E> composite, final List<Collection<E>> collections, final Collection<? extends E> coll) {\n         return contained.addAll(coll);\n     }\n     \n-    public boolean remove(CompositeCollection<E> composite, List<Collection<E>> collections, Object obj) {\n+    public boolean remove(final CompositeCollection<E> composite, final List<Collection<E>> collections, final Object obj) {\n         return contained.remove(obj);\n     }\n }\n--- a/src/test/java/org/apache/commons/collections/set/ListOrderedSet2Test.java\n+++ b/src/test/java/org/apache/commons/collections/set/ListOrderedSet2Test.java\n     private static final Integer TWO = new Integer(2);\n     private static final Integer THREE = new Integer(3);\n \n-    public ListOrderedSet2Test(String testName) {\n+    public ListOrderedSet2Test(final String testName) {\n         super(testName);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     protected ListOrderedSet<E> setupSet() {\n-        ListOrderedSet<E> set = makeObject();\n+        final ListOrderedSet<E> set = makeObject();\n \n         for (int i = 0; i < 10; i++) {\n             set.add((E) Integer.toString(i));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testOrdering() {\n-        ListOrderedSet<E> set = setupSet();\n+        final ListOrderedSet<E> set = setupSet();\n         Iterator<E> it = set.iterator();\n \n         for (int i = 0; i < 10; i++) {\n \n     @SuppressWarnings(\"unchecked\")\n     public void testListAddRemove() {\n-        ListOrderedSet<E> set = makeObject();\n-        List<E> view = set.asList();\n+        final ListOrderedSet<E> set = makeObject();\n+        final List<E> view = set.asList();\n         set.add((E) ZERO);\n         set.add((E) ONE);\n         set.add((E) TWO);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testListAddIndexed() {\n-        ListOrderedSet<E> set = makeObject();\n+        final ListOrderedSet<E> set = makeObject();\n         set.add((E) ZERO);\n         set.add((E) TWO);\n \n         assertSame(ONE, set.get(1));\n         assertSame(TWO, set.get(2));\n \n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.add((E) ZERO);\n         list.add((E) TWO);\n \n--- a/src/test/java/org/apache/commons/collections/set/ListOrderedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/ListOrderedSetTest.java\n \n     private static final Integer THREE = new Integer(3);\n \n-    public ListOrderedSetTest(String testName) {\n+    public ListOrderedSetTest(final String testName) {\n         super(testName);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     protected ListOrderedSet<E> setupSet() {\n-        ListOrderedSet<E> set = makeObject();\n+        final ListOrderedSet<E> set = makeObject();\n \n         for (int i = 0; i < 10; i++) {\n             set.add((E) Integer.toString(i));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testOrdering() {\n-        ListOrderedSet<E> set = setupSet();\n+        final ListOrderedSet<E> set = setupSet();\n         Iterator<E> it = set.iterator();\n \n         for (int i = 0; i < 10; i++) {\n \n     @SuppressWarnings(\"unchecked\")\n     public void testListAddRemove() {\n-        ListOrderedSet<E> set = makeObject();\n-        List<E> view = set.asList();\n+        final ListOrderedSet<E> set = makeObject();\n+        final List<E> view = set.asList();\n         set.add((E) ZERO);\n         set.add((E) ONE);\n         set.add((E) TWO);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testListAddIndexed() {\n-        ListOrderedSet<E> set = makeObject();\n+        final ListOrderedSet<E> set = makeObject();\n         set.add((E) ZERO);\n         set.add((E) TWO);\n \n         assertSame(ONE, set.get(1));\n         assertSame(TWO, set.get(2));\n \n-        List<E> list = new ArrayList<E>();\n+        final List<E> list = new ArrayList<E>();\n         list.add((E) ZERO);\n         list.add((E) TWO);\n \n \n     @SuppressWarnings(\"unchecked\")\n     public void testListAddReplacing() {\n-        ListOrderedSet<E> set = makeObject();\n-        A a = new A();\n-        B b = new B();\n+        final ListOrderedSet<E> set = makeObject();\n+        final A a = new A();\n+        final B b = new B();\n         set.add((E) a);\n         assertEquals(1, set.size());\n         set.add((E) b); // will match but not replace A as equal\n \n     @SuppressWarnings(\"unchecked\")\n     public void testRetainAll() {\n-        List<E> list = new ArrayList<E>(10);\n-        Set<E> set = new HashSet<E>(10);\n-        ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(set, list);\n+        final List<E> list = new ArrayList<E>(10);\n+        final Set<E> set = new HashSet<E>(10);\n+        final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(set, list);\n         for (int i = 0; i < 10; ++i) {\n             orderedSet.add((E) Integer.valueOf(10 - i - 1));\n         }\n \n-        Collection<E> retained = new ArrayList<E>(5);\n+        final Collection<E> retained = new ArrayList<E>(5);\n         for (int i = 0; i < 5; ++i) {\n             retained.add((E) Integer.valueOf(i * 2));\n         }\n      * test case for https://issues.apache.org/jira/browse/COLLECTIONS-426\n      */\n     public void testRetainAllCollections426() {\n-        int size = 100000;\n-        ListOrderedSet<Integer> set = new ListOrderedSet<Integer>();\n+        final int size = 100000;\n+        final ListOrderedSet<Integer> set = new ListOrderedSet<Integer>();\n         for (int i = 0; i < size; i++) {\n             set.add(i);\n         }\n-        ArrayList<Integer> list = new ArrayList<Integer>();\n+        final ArrayList<Integer> list = new ArrayList<Integer>();\n         for (int i = size; i < 2 * size; i++) {\n             list.add(i);\n         }\n \n-        long start = System.currentTimeMillis();\n+        final long start = System.currentTimeMillis();\n         set.retainAll(list);\n-        long stop = System.currentTimeMillis();\n+        final long stop = System.currentTimeMillis();\n \n         // make sure retainAll completes under 5 seconds\n         // TODO if test is migrated to JUnit 4, add a Timeout rule.\n     static class A {\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             return obj instanceof A || obj instanceof B;\n         }\n \n     static class B {\n \n         @Override\n-        public boolean equals(Object obj) {\n+        public boolean equals(final Object obj) {\n             return obj instanceof A || obj instanceof B;\n         }\n \n         try {\n             ListOrderedSet.listOrderedSet((List<E>) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet((Set<E>) null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet(null, null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet(new HashSet<E>(), null);\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet(null, new ArrayList<E>());\n             fail();\n-        } catch (IllegalArgumentException ex) {\n+        } catch (final IllegalArgumentException ex) {\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/collections/set/MapBackedSet2Test.java\n+++ b/src/test/java/org/apache/commons/collections/set/MapBackedSet2Test.java\n  */\n public class MapBackedSet2Test<E> extends AbstractSetTest<E> {\n \n-    public MapBackedSet2Test(String testName) {\n+    public MapBackedSet2Test(final String testName) {\n         super(testName);\n     }\n \n \n     @SuppressWarnings(\"unchecked\")\n     protected Set<E> setupSet() {\n-        Set<E> set = makeObject();\n+        final Set<E> set = makeObject();\n \n         for (int i = 0; i < 10; i++) {\n             set.add((E) Integer.toString(i));\n \n     @SuppressWarnings(\"unchecked\")\n     public void testOrdering() {\n-        Set<E> set = setupSet();\n+        final Set<E> set = setupSet();\n         Iterator<E> it = set.iterator();\n \n         for (int i = 0; i < 10; i++) {\n--- a/src/test/java/org/apache/commons/collections/set/MapBackedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/MapBackedSetTest.java\n  */\n public class MapBackedSetTest<E> extends AbstractSetTest<E> {\n \n-    public MapBackedSetTest(String testName) {\n+    public MapBackedSetTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/set/PredicatedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/PredicatedSetTest.java\n  */\n public class PredicatedSetTest<E> extends AbstractSetTest<E> {\n \n-    public PredicatedSetTest(String testName) {\n+    public PredicatedSetTest(final String testName) {\n         super(testName);\n     }\n \n \n     protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n \n-    protected PredicatedSet<E> decorateSet(Set<E> set, Predicate<? super E> predicate) {\n+    protected PredicatedSet<E> decorateSet(final Set<E> set, final Predicate<? super E> predicate) {\n         return PredicatedSet.predicatedSet(set, predicate);\n     }\n \n \n     protected Predicate<E> testPredicate =\n         new Predicate<E>() {\n-            public boolean evaluate(E o) {\n+            public boolean evaluate(final E o) {\n                 return o instanceof String;\n             }\n         };\n     }\n \n     public void testGetSet() {\n-        PredicatedSet<E> set = makeTestSet();\n+        final PredicatedSet<E> set = makeTestSet();\n         assertTrue(\"returned set should not be null\", set.decorated() != null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        Set<E> set = makeTestSet();\n-        Integer i = new Integer(3);\n+        final Set<E> set = makeTestSet();\n+        final Integer i = new Integer(3);\n         try {\n             set.add((E) i);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\",\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        Set<E> set = makeTestSet();\n-        Set<E> elements = new HashSet<E>();\n+        final Set<E> set = makeTestSet();\n+        final Set<E> elements = new HashSet<E>();\n         elements.add((E) \"one\");\n         elements.add((E) \"two\");\n         elements.add((E) new Integer(3));\n         try {\n             set.addAll(elements);\n             fail(\"Integer should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Set shouldn't contain illegal element\",\n--- a/src/test/java/org/apache/commons/collections/set/PredicatedSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/PredicatedSortedSetTest.java\n  */\n public class PredicatedSortedSetTest<E> extends AbstractSortedSetTest<E> {\n \n-    public PredicatedSortedSetTest(String testName) {\n+    public PredicatedSortedSetTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public SortedSet<E> makeFullCollection() {\n-        TreeSet<E> set = new TreeSet<E>();\n+        final TreeSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n         return PredicatedSortedSet.predicatedSortedSet(set, truePredicate);\n     }\n //--------------------------------------------------------------------\n     protected Predicate<E> testPredicate =\n         new Predicate<E>() {\n-            public boolean evaluate(E o) {\n+            public boolean evaluate(final E o) {\n                 return o instanceof String && ((String) o).startsWith(\"A\");\n             }\n         };\n     }\n \n     public void testGetSet() {\n-        PredicatedSortedSet<E> set = makeTestSet();\n+        final PredicatedSortedSet<E> set = makeTestSet();\n         assertTrue(\"returned set should not be null\", set.decorated() != null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAdd() {\n-        SortedSet<E> set = makeTestSet();\n-        String testString = \"B\";\n+        final SortedSet<E> set = makeTestSet();\n+        final String testString = \"B\";\n         try {\n             set.add((E) testString);\n             fail(\"Should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Collection shouldn't contain illegal element\",\n \n     @SuppressWarnings(\"unchecked\")\n     public void testIllegalAddAll() {\n-        SortedSet<E> set = makeTestSet();\n-        Set<E> elements = new TreeSet<E>();\n+        final SortedSet<E> set = makeTestSet();\n+        final Set<E> elements = new TreeSet<E>();\n         elements.add((E) \"Aone\");\n         elements.add((E) \"Atwo\");\n         elements.add((E) \"Bthree\");\n         try {\n             set.addAll(elements);\n             fail(\"Should fail string predicate.\");\n-        } catch (IllegalArgumentException e) {\n+        } catch (final IllegalArgumentException e) {\n             // expected\n         }\n         assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Aone\"));\n     }\n \n     public void testComparator() {\n-        SortedSet<E> set = makeTestSet();\n-        Comparator<? super E> c = set.comparator();\n+        final SortedSet<E> set = makeTestSet();\n+        final Comparator<? super E> c = set.comparator();\n         assertTrue(\"natural order, so comparator should be null\", c == null);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/set/SynchronizedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/SynchronizedSetTest.java\n  */\n public class SynchronizedSetTest<E> extends AbstractSetTest<E> {\n \n-    public SynchronizedSetTest(String testName) {\n+    public SynchronizedSetTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/set/SynchronizedSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/SynchronizedSortedSetTest.java\n  */\n public class SynchronizedSortedSetTest<E> extends AbstractSortedSetTest<E> {\n \n-    public SynchronizedSortedSetTest(String testName) {\n+    public SynchronizedSortedSetTest(final String testName) {\n         super(testName);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/set/TransformedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/TransformedSetTest.java\n  */\n public class TransformedSetTest<E> extends AbstractSetTest<E> {\n \n-    public TransformedSetTest(String testName) {\n+    public TransformedSetTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public Set<E> makeConfirmedFullCollection() {\n-        Set<E> set = new HashSet<E>();\n+        final Set<E> set = new HashSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n         return set;\n     }\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Set<E> makeFullCollection() {\n-        Set<E> list = new HashSet<E>();\n+        final Set<E> list = new HashSet<E>();\n         list.addAll(Arrays.asList(getFullElements()));\n         return TransformedSet.transformingSet(list,\n                 (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n \n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n-        Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),\n+        final Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),\n                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n-        E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             set.add(els[i]);\n             assertEquals(i + 1, set.size());\n     }\n \n     public void testTransformedSet_decorateTransform() {\n-        Set<Object> originalSet = new HashSet<Object>();\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n-        for (Object el : els) {\n+        final Set<Object> originalSet = new HashSet<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n             originalSet.add(el);\n         }\n-        Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, set.size());\n-        for (Object el : els) {\n+        for (final Object el : els) {\n             assertEquals(true, set.contains(new Integer((String) el)));\n             assertEquals(false, set.contains(el));\n         }\n--- a/src/test/java/org/apache/commons/collections/set/TransformedSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/TransformedSortedSetTest.java\n  */\n public class TransformedSortedSetTest<E> extends AbstractSortedSetTest<E> {\n \n-    public TransformedSortedSetTest(String testName) {\n+    public TransformedSortedSetTest(final String testName) {\n         super(testName);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public SortedSet<E> makeFullCollection() {\n-        SortedSet<E> set = new TreeSet<E>();\n+        final SortedSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n         return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n     }\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testTransformedSet() {\n-        SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),\n+        final SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),\n                 (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(0, set.size());\n-        E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n         for (int i = 0; i < els.length; i++) {\n             set.add(els[i]);\n             assertEquals(i + 1, set.size());\n     }\n \n     public void testTransformedSet_decorateTransform() {\n-        Set<Object> originalSet = new TreeSet<Object>();\n-        Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n-        for (Object el : els) {\n+        final Set<Object> originalSet = new TreeSet<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n             originalSet.add(el);\n         }\n-        Set<?> set = TransformedSortedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        final Set<?> set = TransformedSortedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(els.length, set.size());\n-        for (Object el : els) {\n+        for (final Object el : els) {\n             assertEquals(true, set.contains(new Integer((String) el)));\n         }\n         \n--- a/src/test/java/org/apache/commons/collections/set/UnmodifiableSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/UnmodifiableSetTest.java\n  */\n public class UnmodifiableSetTest<E> extends AbstractSetTest<E> {\n \n-    public UnmodifiableSetTest(String testName) {\n+    public UnmodifiableSetTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public Set<E> makeFullCollection() {\n-        HashSet<E> set = new HashSet<E>();\n+        final HashSet<E> set = new HashSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n         return UnmodifiableSet.unmodifiableSet(set);\n     }\n--- a/src/test/java/org/apache/commons/collections/set/UnmodifiableSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections/set/UnmodifiableSortedSetTest.java\n     protected UnmodifiableSortedSet<E> set = null;\n     protected ArrayList<E> array = null;\n \n-    public UnmodifiableSortedSetTest(String testName) {\n+    public UnmodifiableSortedSetTest(final String testName) {\n         super(testName);\n     }\n \n \n     @Override\n     public UnmodifiableSortedSet<E> makeFullCollection() {\n-        TreeSet<E> set = new TreeSet<E>();\n+        final TreeSet<E> set = new TreeSet<E>();\n         set.addAll(Arrays.asList(getFullElements()));\n         return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.unmodifiableSortedSet(set);\n     }\n      * Verifies that a set is not modifiable\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public void verifyUnmodifiable(Set<E> set) {\n+    public void verifyUnmodifiable(final Set<E> set) {\n         try {\n             set.add((E) \"value\");\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             set.addAll(new TreeSet<E>());\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             set.clear();\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             set.remove(\"x\");\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             set.removeAll(array);\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n         try {\n             set.retainAll(array);\n             fail(\"Expecting UnsupportedOperationException.\");\n-        } catch (UnsupportedOperationException e) {\n+        } catch (final UnsupportedOperationException e) {\n             // expected\n         }\n     }\n \n     public void testComparator() {\n         setupSet();\n-        Comparator<? super E> c = set.comparator();\n+        final Comparator<? super E> c = set.comparator();\n         assertTrue(\"natural order, so comparator should be null\", c == null);\n     }\n \n--- a/src/test/java/org/apache/commons/collections/splitmap/TransformedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/splitmap/TransformedMapTest.java\n @SuppressWarnings(\"boxing\")\n public class TransformedMapTest extends BulkTest {\n \n-    private Transformer<Integer, String> intToString = new Transformer<Integer, String>() {\n-        public String transform(Integer input) {\n+    private final Transformer<Integer, String> intToString = new Transformer<Integer, String>() {\n+        public String transform(final Integer input) {\n             return String.valueOf(input);\n         }\n     };\n \n-    private Transformer<Object, Class<?>> objectToClass = new Transformer<Object, Class<?>>() {\n-        public java.lang.Class<?> transform(Object input) {\n+    private final Transformer<Object, Class<?>> objectToClass = new Transformer<Object, Class<?>>() {\n+        public java.lang.Class<?> transform(final Object input) {\n             return input == null ? null : input.getClass();\n         }\n     };\n \n-    private Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n-        public Integer transform(String input) {\n+    private final Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(final String input) {\n             return Integer.valueOf(input);\n         }\n     };\n \n-    public TransformedMapTest(String testName) {\n+    public TransformedMapTest(final String testName) {\n         super(testName);\n     }\n \n     // -----------------------------------------------------------------------\n     public void testTransformedMap() {\n-        TransformedMap<Integer, String, Object, Class<?>> map = TransformedMap.transformingMap(\n+        final TransformedMap<Integer, String, Object, Class<?>> map = TransformedMap.transformingMap(\n                 new HashMap<String, Class<?>>(), intToString, objectToClass);\n \n-        Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };\n-        Object[] v = new Object[] { \"\", new Object(), new HashMap<Object, Object>(), 0, BigInteger.TEN, null,\n+        final Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };\n+        final Object[] v = new Object[] { \"\", new Object(), new HashMap<Object, Object>(), 0, BigInteger.TEN, null,\n                 new Object[0] };\n \n         assertEquals(0, map.size());\n         assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));\n         assertEquals(--sz, map.size());\n \n-        TransformedMap<String, String, String, Integer> map2 = TransformedMap.transformingMap(\n+        final TransformedMap<String, String, String, Integer> map2 = TransformedMap.transformingMap(\n                 new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n         assertEquals(0, map2.size());\n         for (int i = 0; i < 6; i++) {\n     // -----------------------------------------------------------------------\n \n     public void testMapIterator() {\n-        TransformedMap<String, String, String, Integer> map = TransformedMap.transformingMap(\n+        final TransformedMap<String, String, String, Integer> map = TransformedMap.transformingMap(\n                 new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n         assertEquals(0, map.size());\n         for (int i = 0; i < 6; i++) {\n             map.put(String.valueOf(i), String.valueOf(i));\n         }\n \n-        for (MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {\n-            String k = it.next();\n+        for (final MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {\n+            final String k = it.next();\n             assertEquals(k, it.getKey());\n             assertEquals(map.get(k), it.getValue());\n         }\n     }\n \n     public void testEmptyMap() throws IOException, ClassNotFoundException {\n-        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+        final TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n                 new HashMap<String, String>(),\n                 NOPTransformer.<String>nopTransformer(),\n                 NOPTransformer.<String>nopTransformer() );\n \n-        ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"/TransformedMap.emptyCollection.version3.2.obj\" ) );\n-        Object readObject = in.readObject();\n+        final ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"/TransformedMap.emptyCollection.version3.2.obj\" ) );\n+        final Object readObject = in.readObject();\n         in.close();\n \n-        TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        final TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n         assertTrue( \"Map should be empty\", readMap.size() == 0 );\n         assertEquals( map.entrySet(), readMap.entrySet() );\n     }\n \n     public void testFullMap() throws IOException, ClassNotFoundException {\n-        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+        final TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n                 new HashMap<String, String>(),\n                 NOPTransformer.<String>nopTransformer(),\n                 NOPTransformer.<String>nopTransformer() );\n         map.put( \"e\", \"f\" );\n         map.put( \"g\", \"h\" );\n \n-        ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"TransformedMap.fullCollection.version3.2.obj\" ) );\n-        Object readObject = in.readObject();\n+        final ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"TransformedMap.fullCollection.version3.2.obj\" ) );\n+        final Object readObject = in.readObject();\n         in.close();\n \n-        TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        final TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n         assertFalse( \"Map should not be empty\", readMap.size() == 0 );\n         assertEquals( map.entrySet(), readMap.entrySet() );\n     }\n--- a/src/test/java/org/apache/commons/collections/trie/ByteArrayKeyAnalyzerTest.java\n+++ b/src/test/java/org/apache/commons/collections/trie/ByteArrayKeyAnalyzerTest.java\n     \n     @Test\n     public void bitSet() {\n-        byte[] key = toByteArray(\"10100110\", 2);\n-        ByteArrayKeyAnalyzer ka = new ByteArrayKeyAnalyzer(key.length * 8);\n-        int length = ka.lengthInBits(key);\n+        final byte[] key = toByteArray(\"10100110\", 2);\n+        final ByteArrayKeyAnalyzer ka = new ByteArrayKeyAnalyzer(key.length * 8);\n+        final int length = ka.lengthInBits(key);\n         \n         Assert.assertTrue(ka.isBitSet(key, 0, length));\n         Assert.assertFalse(ka.isBitSet(key, 1, length));\n     \n     @Test\n     public void keys() {\n-        PatriciaTrie<byte[], BigInteger> trie\n+        final PatriciaTrie<byte[], BigInteger> trie\n             = new PatriciaTrie<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n         \n-        Map<byte[], BigInteger> map \n+        final Map<byte[], BigInteger> map \n             = new TreeMap<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n         \n         for (int i = 0; i < SIZE; i++) {\n-            BigInteger value = BigInteger.valueOf(i);\n-            byte[] key = toByteArray(value);\n+            final BigInteger value = BigInteger.valueOf(i);\n+            final byte[] key = toByteArray(value);\n             \n-            BigInteger existing = trie.put(key, value);\n+            final BigInteger existing = trie.put(key, value);\n             Assert.assertNull(existing);\n             \n             map.put(key, value);\n         \n         Assert.assertEquals(map.size(), trie.size());\n         \n-        for (byte[] key : map.keySet()) {\n-            BigInteger expected = new BigInteger(1, key);\n-            BigInteger value = trie.get(key);\n+        for (final byte[] key : map.keySet()) {\n+            final BigInteger expected = new BigInteger(1, key);\n+            final BigInteger value = trie.get(key);\n             \n             Assert.assertEquals(expected, value);\n         }\n     \n     @Test\n     public void prefix() {\n-        byte[] prefix   = toByteArray(\"00001010\", 2);\n-        byte[] key1     = toByteArray(\"11001010\", 2);\n-        byte[] key2     = toByteArray(\"10101100\", 2);\n+        final byte[] prefix   = toByteArray(\"00001010\", 2);\n+        final byte[] key1     = toByteArray(\"11001010\", 2);\n+        final byte[] key2     = toByteArray(\"10101100\", 2);\n         \n-        ByteArrayKeyAnalyzer keyAnalyzer = new ByteArrayKeyAnalyzer(key1.length * 8);\n+        final ByteArrayKeyAnalyzer keyAnalyzer = new ByteArrayKeyAnalyzer(key1.length * 8);\n         \n-        int prefixLength = keyAnalyzer.lengthInBits(prefix);\n+        final int prefixLength = keyAnalyzer.lengthInBits(prefix);\n             \n         Assert.assertFalse(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key1));\n         Assert.assertTrue(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key2));\n     }\n     \n-    private static byte[] toByteArray(String value, int radix) {\n+    private static byte[] toByteArray(final String value, final int radix) {\n         return toByteArray(Long.parseLong(value, radix));\n     }\n     \n-    private static byte[] toByteArray(long value) {\n+    private static byte[] toByteArray(final long value) {\n         return toByteArray(BigInteger.valueOf(value));\n     }\n     \n-    private static byte[] toByteArray(BigInteger value) {\n-        byte[] src = value.toByteArray();\n+    private static byte[] toByteArray(final BigInteger value) {\n+        final byte[] src = value.toByteArray();\n         if (src.length <= 1) {\n             return src;\n         }\n             return src;\n         }\n         \n-        byte[] dst = new byte[src.length-1];\n+        final byte[] dst = new byte[src.length-1];\n         System.arraycopy(src, 1, dst, 0, dst.length);\n         return dst;\n     }\n--- a/src/test/java/org/apache/commons/collections/trie/PatriciaTrieTest.java\n+++ b/src/test/java/org/apache/commons/collections/trie/PatriciaTrieTest.java\n     \n     @Test\n     public void testSimple() {\n-        PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n+        final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n         Assert.assertTrue(intTrie.isEmpty());\n         Assert.assertEquals(0, intTrie.size());\n         \n     \n     @Test\n     public void testCeilingEntry() {\n-        PatriciaTrie<Character, String> charTrie \n+        final PatriciaTrie<Character, String> charTrie \n             = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('c', \"c\");\n         charTrie.put('p', \"p\");\n         charTrie.put('f', \"f\");\n         charTrie.put('d', \"d\");\n         \n-        Object[] results = new Object[] {\n+        final Object[] results = new Object[] {\n             'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n             'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n             'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n         };\n         \n         for(int i = 0; i < results.length; i++) {\n-            Map.Entry<Character, String> found = charTrie.ceilingEntry((Character)results[i]);\n+            final Map.Entry<Character, String> found = charTrie.ceilingEntry((Character)results[i]);\n             Assert.assertNotNull(found);\n             Assert.assertEquals(results[i], found.getKey());\n             Assert.assertEquals(results[++i], found.getValue());\n     \n     @Test\n     public void testLowerEntry() {\n-        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('c', \"c\");\n         charTrie.put('p', \"p\");\n         charTrie.put('l', \"l\");\n         charTrie.put('f', \"f\");\n         charTrie.put('d', \"d\");\n         \n-        Object[] results = new Object[] {\n+        final Object[] results = new Object[] {\n             'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n             'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n             'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n         \n         for(int i = 0; i < results.length; i+=2) {\n             //System.out.println(\"Looking for: \" + results[i]);\n-            Map.Entry<Character, String> found = charTrie.lowerEntry((Character)results[i]);\n+            final Map.Entry<Character, String> found = charTrie.lowerEntry((Character)results[i]);\n             if(i == 0) {\n                 Assert.assertNull(found);\n             } else {\n     \n     @Test\n     public void testIteration() {\n-        PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n+        final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n         intTrie.put(1, \"One\");\n         intTrie.put(5, \"Five\");\n         intTrie.put(4, \"Four\");\n         cursor.finished();\n         \n         cursor.starting();\n-        for (Map.Entry<Integer, String> entry : intTrie.entrySet()) {\n+        for (final Map.Entry<Integer, String> entry : intTrie.entrySet()) {\n             cursor.select(entry);\n         }\n         cursor.finished();\n         \n         cursor.starting();\n-        for (Integer integer : intTrie.keySet()) {\n+        for (final Integer integer : intTrie.keySet()) {\n             cursor.checkKey(integer);\n         }\n         cursor.finished();\n         \n         cursor.starting();\n-        for (String string : intTrie.values()) {\n+        for (final String string : intTrie.values()) {\n             cursor.checkValue(string);\n         }\n         cursor.finished();\n \n-        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('c', \"c\");\n         charTrie.put('p', \"p\");\n         charTrie.put('l', \"l\");\n         cursor.finished();\n \n         cursor.starting();\n-        for (Map.Entry<Character, String> entry : charTrie.entrySet()) {\n+        for (final Map.Entry<Character, String> entry : charTrie.entrySet()) {\n             cursor.select(entry);\n         }\n         cursor.finished();\n         \n         cursor.starting();\n-        for (Character character : charTrie.keySet()) {\n+        for (final Character character : charTrie.keySet()) {\n             cursor.checkKey(character);\n         }\n         cursor.finished();\n         \n         cursor.starting();\n-        for (String string : charTrie.values()) {\n+        for (final String string : charTrie.values()) {\n             cursor.checkValue(string);\n         }\n         cursor.finished();\n     \n     @Test\n     public void testSelect() {\n-        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('c', \"c\");\n         charTrie.put('p', \"p\");\n         charTrie.put('l', \"l\");\n         charTrie.put('z', \"z\");\n         charTrie.put('f', \"f\");\n         charTrie.put('d', \"d\");\n-        TestCursor cursor = new TestCursor(\n+        final TestCursor cursor = new TestCursor(\n                 'd', \"d\", 'e', \"e\", 'f', \"f\", 'g', \"g\",\n                 'a', \"a\", 'b', \"b\", 'c', \"c\",  \n                 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n     \n     @Test\n     public void testTraverseCursorRemove() {\n-        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('c', \"c\");\n         charTrie.put('p', \"p\");\n         charTrie.put('l', \"l\");\n         charTrie.put('z', \"z\");\n         charTrie.put('f', \"f\");\n         charTrie.put('d', \"d\");\n-        TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+        final TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n                 'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n                 'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n                 'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n         \n         Assert.assertEquals(26, charTrie.size());\n         \n-        Object[] toRemove = new Object[] { 'g', 'd', 'e', 'm', 'p', 'q', 'r', 's' };\n+        final Object[] toRemove = new Object[] { 'g', 'd', 'e', 'm', 'p', 'q', 'r', 's' };\n         cursor.addToRemove(toRemove);\n         \n         cursor.starting();\n         cursor.finished();\n         \n         cursor.starting();\n-        for (Entry<Character, String> entry : charTrie.entrySet()) {\n+        for (final Entry<Character, String> entry : charTrie.entrySet()) {\n             cursor.select(entry);\n             if (Arrays.asList(toRemove).contains(entry.getKey())) {\n                 Assert.fail(\"got an: \" + entry);\n     \n     @Test\n     public void testIteratorRemove() {\n-        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('c', \"c\");\n         charTrie.put('p', \"p\");\n         charTrie.put('l', \"l\");\n         charTrie.put('z', \"z\");\n         charTrie.put('f', \"f\");\n         charTrie.put('d', \"d\");\n-        TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+        final TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n                 'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n                 'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n                 'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n         \n         Assert.assertEquals(26, charTrie.size());\n         \n-        Object[] toRemove = new Object[] { 'e', 'm', 'p', 'q', 'r', 's' };\n-        \n-        cursor.starting();\n-        for(Iterator<Map.Entry<Character, String>> i = charTrie.entrySet().iterator(); i.hasNext(); ) {\n-            Map.Entry<Character,String> entry = i.next();\n+        final Object[] toRemove = new Object[] { 'e', 'm', 'p', 'q', 'r', 's' };\n+        \n+        cursor.starting();\n+        for(final Iterator<Map.Entry<Character, String>> i = charTrie.entrySet().iterator(); i.hasNext(); ) {\n+            final Map.Entry<Character,String> entry = i.next();\n             cursor.select(entry);\n             if(Arrays.asList(toRemove).contains(entry.getKey())) {\n                 i.remove();            \n         cursor.remove(toRemove);\n \n         cursor.starting();\n-        for (Entry<Character, String> entry : charTrie.entrySet()) {\n+        for (final Entry<Character, String> entry : charTrie.entrySet()) {\n             cursor.select(entry);\n             if (Arrays.asList(toRemove).contains(entry.getKey())) {\n                 Assert.fail(\"got an: \" + entry);\n     @Test\n     public void testHamlet() throws Exception {\n         // Make sure that Hamlet is read & stored in the same order as a SortedSet.\n-        List<String> original = new ArrayList<String>();\n-        List<String> control = new ArrayList<String>();\n-        SortedMap<String, String> sortedControl = new TreeMap<String, String>();\n-        PatriciaTrie<String, String> trie = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-        \n-        InputStream in = getClass().getResourceAsStream(\"hamlet.txt\");\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n+        final List<String> original = new ArrayList<String>();\n+        final List<String> control = new ArrayList<String>();\n+        final SortedMap<String, String> sortedControl = new TreeMap<String, String>();\n+        final PatriciaTrie<String, String> trie = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final InputStream in = getClass().getResourceAsStream(\"hamlet.txt\");\n+        final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n         \n         String read = null;\n         while( (read = reader.readLine()) != null) {\n-            StringTokenizer st = new StringTokenizer(read);\n+            final StringTokenizer st = new StringTokenizer(read);\n             while(st.hasMoreTokens()) {\n-                String token = st.nextToken();\n+                final String token = st.nextToken();\n                 original.add(token);\n                 sortedControl.put(token, token);\n                 trie.put(token, token);\n         Assert.assertEquals(control.size(), sortedControl.size());\n         Assert.assertEquals(sortedControl.size(), trie.size());\n         Iterator<String> iter = trie.values().iterator();\n-        for (String aControl : control) {\n+        for (final String aControl : control) {\n             Assert.assertEquals(aControl, iter.next());\n         }\n         \n-        Random rnd = new Random();\n+        final Random rnd = new Random();\n         int item = 0;\n         iter = trie.values().iterator();\n         int removed = 0;\n         \n         // reset hamlet\n         trie.clear();\n-        for (String anOriginal : original) {\n+        for (final String anOriginal : original) {\n             trie.put(anOriginal, anOriginal);\n         }\n         \n         try {\n             sub.headMap(control.get(524));\n             Assert.fail(\"should have thrown IAE\");\n-        } catch(IllegalArgumentException expected) {}\n+        } catch(final IllegalArgumentException expected) {}\n         \n         Assert.assertEquals(sub.lastKey(), control.get(522));\n         Assert.assertEquals(sub.firstKey(), control.get(0));\n         try {\n             sub.tailMap(control.get(232));\n             Assert.fail(\"should have thrown IAE\");\n-        } catch(IllegalArgumentException expected) {}\n+        } catch(final IllegalArgumentException expected) {}\n         \n         sub = sub.subMap(control.get(300), control.get(400));\n         Assert.assertEquals(100, sub.size());\n     \n     @Test\n     public void testPrefixedBy() {\n-        PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie \n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n         \n         final String[] keys = new String[]{\n                 \"Amma\"\n         };\n \n-        for (String key : keys) {\n+        for (final String key : keys) {\n             trie.put(key, key);\n         }\n         \n         try {\n             iterator.next();\n             Assert.fail(\"CME expected\");\n-        } catch(ConcurrentModificationException expected) {}\n+        } catch(final ConcurrentModificationException expected) {}\n         Assert.assertEquals(\"Amber\", map.firstKey());\n         Assert.assertEquals(\"Ammun\", map.lastKey());\n         \n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         try {\n-            Object o = map.firstKey();\n+            final Object o = map.firstKey();\n             Assert.fail(\"got a first key: \" + o);\n-        } catch(NoSuchElementException nsee) {}\n+        } catch(final NoSuchElementException nsee) {}\n         try {\n-            Object o = map.lastKey();\n+            final Object o = map.lastKey();\n             Assert.fail(\"got a last key: \" + o);\n-        } catch(NoSuchElementException nsee) {}\n+        } catch(final NoSuchElementException nsee) {}\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n         \n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         try {\n-            Object o = map.firstKey();\n+            final Object o = map.firstKey();\n             Assert.fail(\"got a first key: \" + o);\n-        } catch(NoSuchElementException nsee) {}\n+        } catch(final NoSuchElementException nsee) {}\n         try {\n-            Object o = map.lastKey();\n+            final Object o = map.lastKey();\n             Assert.fail(\"got a last key: \" + o);\n-        } catch(NoSuchElementException nsee) {}\n+        } catch(final NoSuchElementException nsee) {}\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n         \n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         try {\n-            Object o = map.firstKey();\n+            final Object o = map.firstKey();\n             Assert.fail(\"got a first key: \" + o);\n-        } catch(NoSuchElementException nsee) {}\n+        } catch(final NoSuchElementException nsee) {}\n         try {\n-            Object o = map.lastKey();\n+            final Object o = map.lastKey();\n             Assert.fail(\"got a last key: \" + o);\n-        } catch(NoSuchElementException nsee) {}\n+        } catch(final NoSuchElementException nsee) {}\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n     }\n     \n     @Test\n     public void testPrefixByOffsetAndLength() {\n-        PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie \n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n         \n         final String[] keys = new String[]{\n                 \"Amma\"\n         };\n     \n-        for (String key : keys) {\n+        for (final String key : keys) {\n             trie.put(key, key);\n         }\n         \n     \n     @Test\n     public void testPrefixedByRemoval() {\n-        PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie \n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n         \n         final String[] keys = new String[]{\n                 \"Amma\"\n         };\n \n-        for (String key : keys) {\n+        for (final String key : keys) {\n             trie.put(key, key);\n         }\n         \n \n     @Test\n     public void testTraverseWithAllNullBitKey() {\n-        PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie \n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n         \n         //\n         \n         final List<String> strings = new ArrayList<String>();\n         trie.traverse(new Cursor<String, String>() {\n-            public Decision select(Entry<? extends String, ? extends String> entry) {\n+            public Decision select(final Entry<? extends String, ? extends String> entry) {\n                 strings.add(entry.getValue());\n                 return Decision.CONTINUE;\n             }\n         Assert.assertEquals(1, strings.size());\n         \n         strings.clear();\n-        for (String s : trie.values()) {\n+        for (final String s : trie.values()) {\n             strings.add(s);\n         }\n         Assert.assertEquals(1, strings.size());\n     \n     @Test\n     public void testSelectWithAllNullBitKey() {\n-        PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie \n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n         \n         // trie.put(\"\", \"All Bits Are Zero\");\n         \n         final List<String> strings = new ArrayList<String>();\n         trie.select(\"Hello\", new Cursor<String, String>() {\n-            public Decision select(Entry<? extends String, ? extends String> entry) {\n+            public Decision select(final Entry<? extends String, ? extends String> entry) {\n                 strings.add(entry.getValue());\n                 return Decision.CONTINUE;\n             }\n     }\n     \n     private static class TestCursor implements Cursor<Object, Object> {\n-        private List<Object> keys;\n-        private List<Object> values;\n+        private final List<Object> keys;\n+        private final List<Object> values;\n         private Object selectFor;\n         private List<Object> toRemove;\n         private int index = 0;\n         \n-        TestCursor(Object... objects) {\n+        TestCursor(final Object... objects) {\n             if(objects.length % 2 != 0) {\n                 throw new IllegalArgumentException(\"must be * 2\");\n             }\n             }\n         }\n         \n-        void selectFor(Object object) {\n+        void selectFor(final Object object) {\n             selectFor = object;\n         }\n         \n-        void addToRemove(Object... objects) {\n+        void addToRemove(final Object... objects) {\n             toRemove = new ArrayList<Object>(Arrays.asList(objects));\n         }\n         \n-        void remove(Object... objects) {\n-            for (Object object : objects) {\n-                int idx = keys.indexOf(object);\n+        void remove(final Object... objects) {\n+            for (final Object object : objects) {\n+                final int idx = keys.indexOf(object);\n                 keys.remove(idx);\n                 values.remove(idx);\n             }\n             index = 0;\n         }\n         \n-        public void checkKey(Object k) {\n+        public void checkKey(final Object k) {\n             Assert.assertEquals(keys.get(index++), k);\n         }\n         \n-        public void checkValue(Object o) {\n+        public void checkValue(final Object o) {\n             Assert.assertEquals(values.get(index++), o);\n         }\n \n-        public Decision select(Entry<?, ?> entry) {\n+        public Decision select(final Entry<?, ?> entry) {\n           //  System.out.println(\"Scanning: \" + entry.getKey());\n             Assert.assertEquals(keys.get(index), entry.getKey());\n             Assert.assertEquals(values.get(index), entry.getValue());\n         }\n     }\n     \n-    private static void assertEqualArrays(Object[] a, Object[] b) {\n+    private static void assertEqualArrays(final Object[] a, final Object[] b) {\n         Assert.assertTrue(Arrays.equals(a, b));\n     }\n }", "timestamp": 1357578914, "metainfo": ""}