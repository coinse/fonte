{"sha": "420a1017eb0e5eb8e0f1486e9f413c69f03d1b39", "log": "37473: Implement a BoundedBuffer class  ", "commit": "\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n import org.apache.commons.collections.buffer.TransformedBuffer;\n import org.apache.commons.collections.buffer.TypedBuffer;\n import org.apache.commons.collections.buffer.UnmodifiableBuffer;\n+import org.apache.commons.collections.buffer.BoundedBuffer;\n \n /**\n  * Provides utility methods and decorators for {@link Buffer} instances.\n     }\n \n     /**\n+     * Returns a synchronized buffer backed by the given buffer that will block on {@link Buffer#add(Object)} and\n+     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are removed from the buffer to allow\n+     * the object(s) to be added and still maintain the maximum size.\n+     * @param buffer the buffer to make bounded\n+     * @param maximumSize the maximum size\n+     * @return a bounded buffer backed by the given buffer\n+     * @throws IllegalArgumentException if the given buffer is null\n+     */\n+    public static Buffer boundedBuffer( Buffer buffer, int maximumSize ) {\n+        return BoundedBuffer.decorate( buffer, maximumSize );\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will block on {@link Buffer#add(Object)} and\n+     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are removed from the buffer to allow\n+     * the object(s) to be added and still maintain the maximum size or the timeout expires.\n+     * @param buffer the buffer to make bounded\n+     * @param maximumSize the maximum size\n+     * @param timeout the maximum time to wait\n+     * @return a bounded buffer backed by the given buffer\n+     * @throws IllegalArgumentException if the given buffer is null\n+     */\n+    public static Buffer boundedBuffer( Buffer buffer, int maximumSize, long timeout ) {\n+        return BoundedBuffer.decorate( buffer, maximumSize, timeout );\n+    }\n+    \n+    /**\n      * Returns an unmodifiable buffer backed by the given buffer.\n      *\n      * @param buffer  the buffer to make unmodifiable, must not be null\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n+/*\n+ *  Copyright 2001-2005 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferOverflowException;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * A wrapper class for buffers which makes them bounded.\n+ * @author James Carman\n+ * @since 3.2\n+ */\n+public class BoundedBuffer extends SynchronizedBuffer {\n+\n+    private static final long serialVersionUID = 1536432911093974264L;\n+\n+    private final int maximumSize;\n+    private final long timeout;\n+\n+    /**\n+     * Factory method to create a bounded buffer.\n+     * @param buffer the buffer to decorate, must not be null\n+     * @param maximumSize the maximum size\n+     * @return a new bounded buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    public static Buffer decorate( Buffer buffer, int maximumSize ) {\n+        return new BoundedBuffer( buffer, maximumSize );\n+    }\n+\n+    /**\n+     * Factory method to create a bounded buffer that blocks for a maximum\n+     * amount of time.\n+     * @param buffer the buffer to decorate, must not be null\n+     * @param maximumSize the maximum size\n+     * @param timeout the maximum amount of time to wait.\n+     * @return a new bounded buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    public static Buffer decorate( Buffer buffer, int maximumSize, long timeout ) {\n+        return new BoundedBuffer( buffer, maximumSize, timeout );\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies) another buffer, making it bounded.\n+     * @param buffer the buffer to wrap, must not be null\n+     * @param maximumSize the maximum size of the buffer\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    protected BoundedBuffer( Buffer buffer, int maximumSize ) {\n+        this( buffer, maximumSize, -1 );\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies) another buffer, making it bounded waiting only up to\n+     * a maximum amount of time.\n+     * @param buffer the buffer to wrap, must not be null\n+     * @param maximumSize the maximum size of the buffer\n+     * @param timeout the maximum amount of time to wait\n+     * @throws IllegalArgumentException if the buffer is null\n+     */\n+    protected BoundedBuffer( Buffer buffer, int maximumSize, long timeout ) {\n+        super( buffer );\n+        this.maximumSize = maximumSize;\n+        this.timeout = timeout;\n+    }\n+\n+    public Object remove() {\n+        synchronized( lock ) {\n+            Object returnValue = getBuffer().remove();\n+            lock.notifyAll();\n+            return returnValue;\n+        }\n+    }\n+\n+    public boolean add( Object o ) {\n+        synchronized( lock ) {\n+            timeoutWait( 1 );\n+            return getBuffer().add( o );\n+        }\n+    }\n+\n+    public boolean addAll( final Collection c ) {\n+        synchronized( lock ) {\n+            timeoutWait( c.size() );\n+            return getBuffer().addAll( c );\n+        }\n+    }\n+\n+    public Iterator iterator() {\n+        return new NotifyingIterator( collection.iterator() );\n+    }\n+\n+    private void timeoutWait( final int nAdditions ) {\n+        synchronized( lock ) {\n+            if( timeout < 0 && getBuffer().size() + nAdditions > maximumSize ) {\n+                throw new BufferOverflowException( \"Buffer size cannot exceed \" + maximumSize + \".\" );\n+            }\n+            final long expiration = System.currentTimeMillis() + timeout;\n+            long timeLeft = expiration - System.currentTimeMillis();\n+            while( timeLeft > 0 && getBuffer().size() + nAdditions > maximumSize ) {\n+                try {\n+                    lock.wait( timeLeft );\n+                    timeLeft = expiration - System.currentTimeMillis();\n+                }\n+                catch( InterruptedException e ) {\n+                    PrintWriter out = new PrintWriter( new StringWriter() );\n+                    e.printStackTrace( out );\n+                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n+                }\n+            }\n+            if( getBuffer().size() + nAdditions > maximumSize ) {\n+                throw new BufferOverflowException( \"Timeout expired.\" );\n+            }\n+        }\n+    }\n+\n+    private class NotifyingIterator implements Iterator {\n+\n+        private final Iterator i;\n+\n+        public NotifyingIterator( Iterator i ) {\n+            this.i = i;\n+        }\n+\n+        public void remove() {\n+            synchronized( lock ) {\n+                i.remove();\n+                lock.notifyAll();\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return i.hasNext();\n+        }\n+\n+        public Object next() {\n+            return i.next();\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n+/*\n+ *  Copyright 2001-2005 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferOverflowException;\n+\n+import java.util.Iterator;\n+import java.util.Collections;\n+import java.util.Arrays;\n+\n+public class TestBoundedBuffer extends AbstractTestObject {\n+\n+    public TestBoundedBuffer( String testName ) {\n+        super( testName );\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    public Object makeObject() {\n+        return BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1 );\n+    }\n+\n+    public void testAddToFullBufferNoTimeout() {\n+        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1 );\n+        bounded.add( \"Hello\" );\n+        try {\n+            bounded.add( \"World\" );\n+            fail();\n+        }\n+        catch( BufferOverflowException e ) {\n+        }\n+    }\n+\n+    public void testAddAllToFullBufferNoTimeout() {\n+        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1 );\n+        bounded.add( \"Hello\" );\n+        try {\n+            bounded.addAll( Collections.singleton( \"World\" ) );\n+            fail();\n+        }\n+        catch( BufferOverflowException e ) {\n+        }\n+    }\n+\n+    public void testAddToFullBufferRemoveViaIterator() {\n+        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1, 500 );\n+        bounded.add( \"Hello\" );\n+        new DelayedIteratorRemove( bounded, 200 ).start();\n+        bounded.add( \"World\" );\n+        assertEquals( 1, bounded.size() );\n+        assertEquals( \"World\", bounded.get() );\n+\n+    }\n+\n+    public void testAddAllToFullBufferRemoveViaIterator() {\n+        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 2, 500 );\n+        bounded.add( \"Hello\" );\n+        bounded.add( \"World\" );\n+        new DelayedIteratorRemove( bounded, 200, 2 ).start();\n+        bounded.addAll( Arrays.asList( new String[] { \"Foo\", \"Bar\" } ) );\n+        assertEquals( 2, bounded.size() );\n+        assertEquals( \"Foo\", bounded.remove() );\n+        assertEquals( \"Bar\", bounded.remove() );\n+    }\n+\n+    public void testAddToFullBufferWithTimeout() {\n+        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1, 500 );\n+        bounded.add( \"Hello\" );\n+        new DelayedRemove( bounded, 200 ).start();\n+        bounded.add( \"World\" );\n+        assertEquals( 1, bounded.size() );\n+        assertEquals( \"World\", bounded.get() );\n+        try {\n+            bounded.add( \"!\" );\n+            fail();\n+        }\n+        catch( BufferOverflowException e ) {\n+        }\n+    }\n+\n+    public void testAddAllToFullBufferWithTimeout() {\n+        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 2, 500 );\n+        bounded.add( \"Hello\" );\n+        bounded.add( \"World\" );\n+        new DelayedRemove( bounded, 200, 2 ).start();\n+\n+        bounded.addAll( Arrays.asList( new String[] { \"Foo\", \"Bar\" } ) );\n+        assertEquals( 2, bounded.size() );\n+        assertEquals( \"Foo\", bounded.get() );\n+        try {\n+            bounded.add( \"!\" );\n+            fail();\n+        }\n+        catch( BufferOverflowException e ) {\n+        }\n+    }\n+\n+    private class DelayedIteratorRemove extends Thread {\n+\n+        private final Buffer buffer;\n+\n+        private final long delay;\n+\n+        private final int nToRemove;\n+\n+        public DelayedIteratorRemove( Buffer buffer, long delay, int nToRemove ) {\n+            this.buffer = buffer;\n+            this.delay = delay;\n+            this.nToRemove = nToRemove;\n+        }\n+\n+        public DelayedIteratorRemove( Buffer buffer, long delay ) {\n+            this( buffer, delay, 1 );\n+        }\n+\n+        public void run() {\n+            try {\n+                Thread.sleep( delay );\n+                Iterator iter = buffer.iterator();\n+                for( int i = 0; i < nToRemove; ++i ) {\n+                    iter.next();\n+                    iter.remove();\n+                }\n+\n+            }\n+            catch( InterruptedException e ) {\n+            }\n+        }\n+    }\n+\n+    private class DelayedRemove extends Thread {\n+\n+        private final Buffer buffer;\n+\n+        private final long delay;\n+\n+        private final int nToRemove;\n+\n+        public DelayedRemove( Buffer buffer, long delay, int nToRemove ) {\n+            this.buffer = buffer;\n+            this.delay = delay;\n+            this.nToRemove = nToRemove;\n+        }\n+\n+        public DelayedRemove( Buffer buffer, long delay ) {\n+            this( buffer, delay, 1 );\n+        }\n+\n+        public void run() {\n+            try {\n+                Thread.sleep( delay );\n+                for( int i = 0; i < nToRemove; ++i ) {\n+                    buffer.remove();\n+                }\n+            }\n+            catch( InterruptedException e ) {\n+            }\n+        }\n+    }\n+}", "timestamp": 1132751803, "metainfo": ""}