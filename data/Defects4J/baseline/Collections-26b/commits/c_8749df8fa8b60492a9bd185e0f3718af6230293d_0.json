{"sha": "8749df8fa8b60492a9bd185e0f3718af6230293d", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r751887 | mbenson | 2009-03-09 15:40:01 -0700 (Mon, 09 Mar 2009) | 1 line          add methods to wrap Maps and SortedMaps not based on Commons Collections classes to their Iterable*Map counterparts     ------------------------------------------------------------------------     r740457 | mbenson | 2009-02-03 13:23:15 -0800 (Tue, 03 Feb 2009) | 1 line          ws     ------------------------------------------------------------------------     r740150 | mbenson | 2009-02-02 15:24:00 -0800 (Mon, 02 Feb 2009) | 1 line          make all [collections] maps implement IterableMap     ------------------------------------------------------------------------     r471166 | scolebourne | 2006-11-04 03:33:22 -0800 (Sat, 04 Nov 2006) | 1 line          Removed Typed* containers such as TypedList and TypedMap as generics now provides type safety     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n import java.io.PrintStream;\n import java.text.NumberFormat;\n import java.text.ParseException;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.TreeMap;\n import java.util.Collection;\n \n+import org.apache.commons.collections.map.AbstractMapDecorator;\n+import org.apache.commons.collections.map.AbstractSortedMapDecorator;\n import org.apache.commons.collections.map.FixedSizeMap;\n import org.apache.commons.collections.map.FixedSizeSortedMap;\n import org.apache.commons.collections.map.LazyMap;\n import org.apache.commons.collections.map.PredicatedSortedMap;\n import org.apache.commons.collections.map.TransformedMap;\n import org.apache.commons.collections.map.TransformedSortedMap;\n-import org.apache.commons.collections.map.TypedMap;\n-import org.apache.commons.collections.map.TypedSortedMap;\n import org.apache.commons.collections.map.UnmodifiableMap;\n import org.apache.commons.collections.map.UnmodifiableSortedMap;\n \n-/** \n+/**\n  * Provides utility methods and decorators for\n  * {@link Map} and {@link SortedMap} instances.\n  * <p>\n  * @author Neil O'Toole\n  */\n public class MapUtils {\n-    \n+\n     /**\n      * An empty unmodifiable map.\n      * This was not provided in JDK1.2.\n      */\n-    public static final Map EMPTY_MAP = UnmodifiableMap.decorate(new HashMap(1));\n+    public static final Map<Object, Object> EMPTY_MAP = UnmodifiableMap.decorate(new HashMap<Object, Object>(1));\n+\n     /**\n      * An empty unmodifiable sorted map.\n      * This is not provided in the JDK.\n      */\n-    public static final SortedMap EMPTY_SORTED_MAP = UnmodifiableSortedMap.decorate(new TreeMap());\n+    public static final SortedMap<Object, Object> EMPTY_SORTED_MAP = UnmodifiableSortedMap.decorate(new TreeMap<Object, Object>());\n+\n     /**\n      * String used to indent the verbose and debug Map prints.\n      */\n      * <code>MapUtils</code> should not normally be instantiated.\n      */\n     public MapUtils() {\n-    }    \n-    \n+    }\n+\n     // Type safe getters\n     //-------------------------------------------------------------------------\n     /**\n      * @param key  the key to look up\n      * @return the value in the Map, <code>null</code> if null map input\n      */\n-    public static Object getObject(final Map map, final Object key) {\n+    public static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n         if (map != null) {\n             return map.get(key);\n         }\n      * @param key  the key to look up\n      * @return the value in the Map as a String, <code>null</code> if null map input\n      */\n-    public static String getString(final Map map, final Object key) {\n+    public static <K> String getString(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n             Object answer = map.get(key);\n             if (answer != null) {\n      * @param key  the key to look up\n      * @return the value in the Map as a Boolean, <code>null</code> if null map input\n      */\n-    public static Boolean getBoolean(final Map map, final Object key) {\n+    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n             Object answer = map.get(key);\n             if (answer != null) {\n                 if (answer instanceof Boolean) {\n                     return (Boolean) answer;\n-                    \n-                } else if (answer instanceof String) {\n+                }\n+                if (answer instanceof String) {\n                     return new Boolean((String) answer);\n-                    \n-                } else if (answer instanceof Number) {\n+                }\n+                if (answer instanceof Number) {\n                     Number n = (Number) answer;\n                     return (n.intValue() != 0) ? Boolean.TRUE : Boolean.FALSE;\n                 }\n      * @param key  the key to look up\n      * @return the value in the Map as a Number, <code>null</code> if null map input\n      */\n-    public static Number getNumber(final Map map, final Object key) {\n+    public static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n             Object answer = map.get(key);\n             if (answer != null) {\n                 if (answer instanceof Number) {\n                     return (Number) answer;\n-                    \n-                } else if (answer instanceof String) {\n+                }\n+                if (answer instanceof String) {\n                     try {\n                         String text = (String) answer;\n                         return NumberFormat.getInstance().parse(text);\n-                        \n                     } catch (ParseException e) {\n                         logInfo(e);\n                     }\n      * @param key  the key to look up\n      * @return the value in the Map as a Byte, <code>null</code> if null map input\n      */\n-    public static Byte getByte(final Map map, final Object key) {\n+    public static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n         Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n-        } else if (answer instanceof Byte) {\n+        }\n+        if (answer instanceof Byte) {\n             return (Byte) answer;\n         }\n         return new Byte(answer.byteValue());\n      * @param key  the key to look up\n      * @return the value in the Map as a Short, <code>null</code> if null map input\n      */\n-    public static Short getShort(final Map map, final Object key) {\n+    public static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n         Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n-        } else if (answer instanceof Short) {\n+        }\n+        if (answer instanceof Short) {\n             return (Short) answer;\n         }\n         return new Short(answer.shortValue());\n      * @param key  the key to look up\n      * @return the value in the Map as a Integer, <code>null</code> if null map input\n      */\n-    public static Integer getInteger(final Map map, final Object key) {\n+    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n         Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n-        } else if (answer instanceof Integer) {\n+        }\n+        if (answer instanceof Integer) {\n             return (Integer) answer;\n         }\n         return new Integer(answer.intValue());\n      * @param key  the key to look up\n      * @return the value in the Map as a Long, <code>null</code> if null map input\n      */\n-    public static Long getLong(final Map map, final Object key) {\n+    public static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n         Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n-        } else if (answer instanceof Long) {\n+        }\n+        if (answer instanceof Long) {\n             return (Long) answer;\n         }\n         return new Long(answer.longValue());\n      * @param key  the key to look up\n      * @return the value in the Map as a Float, <code>null</code> if null map input\n      */\n-    public static Float getFloat(final Map map, final Object key) {\n+    public static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n         Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n-        } else if (answer instanceof Float) {\n+        }\n+        if (answer instanceof Float) {\n             return (Float) answer;\n         }\n         return new Float(answer.floatValue());\n      * @param key  the key to look up\n      * @return the value in the Map as a Double, <code>null</code> if null map input\n      */\n-    public static Double getDouble(final Map map, final Object key) {\n+    public static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n         Number answer = getNumber(map, key);\n         if (answer == null) {\n             return null;\n-        } else if (answer instanceof Double) {\n+        }\n+        if (answer instanceof Double) {\n             return (Double) answer;\n         }\n         return new Double(answer.doubleValue());\n      * @param key  the key to look up\n      * @return the value in the Map as a Map, <code>null</code> if null map input\n      */\n-    public static Map getMap(final Map map, final Object key) {\n+    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n         if (map != null) {\n             Object answer = map.get(key);\n             if (answer != null && answer instanceof Map) {\n-                return (Map) answer;\n+                return (Map<?, ?>) answer;\n             }\n         }\n         return null;\n      *  @return  the value in the map, or defaultValue if the original value\n      *    is null or the map is null\n      */\n-    public static Object getObject( Map map, Object key, Object defaultValue ) {\n-        if ( map != null ) {\n-            Object answer = map.get( key );\n-            if ( answer != null ) {\n+    public static <K, V> V getObject(Map<K, V> map, K key, V defaultValue) {\n+        if (map != null) {\n+            V answer = map.get(key);\n+            if (answer != null) {\n                 return answer;\n             }\n         }\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a string, or defaultValue if the \n+     *  @return  the value in the map as a string, or defaultValue if the\n      *    original value is null, the map is null or the string conversion\n      *    fails\n      */\n-    public static String getString( Map map, Object key, String defaultValue ) {\n-        String answer = getString( map, key );\n-        if ( answer == null ) {\n+    public static <K> String getString(Map<? super K, ?> map, K key, String defaultValue) {\n+        String answer = getString(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a boolean, or defaultValue if the \n+     *  @return  the value in the map as a boolean, or defaultValue if the\n      *    original value is null, the map is null or the boolean conversion\n      *    fails\n      */\n-    public static Boolean getBoolean( Map map, Object key, Boolean defaultValue ) {\n-        Boolean answer = getBoolean( map, key );\n-        if ( answer == null ) {\n+    public static <K> Boolean getBoolean(Map<? super K, ?> map, K key, Boolean defaultValue) {\n+        Boolean answer = getBoolean(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static Number getNumber( Map map, Object key, Number defaultValue ) {\n-        Number answer = getNumber( map, key );\n-        if ( answer == null ) {\n+    public static <K> Number getNumber(Map<? super K, ?> map, K key, Number defaultValue) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static Byte getByte( Map map, Object key, Byte defaultValue ) {\n-        Byte answer = getByte( map, key );\n-        if ( answer == null ) {\n+    public static <K> Byte getByte(Map<? super K, ?> map, K key, Byte defaultValue) {\n+        Byte answer = getByte(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static Short getShort( Map map, Object key, Short defaultValue ) {\n-        Short answer = getShort( map, key );\n-        if ( answer == null ) {\n+    public static <K> Short getShort(Map<? super K, ?> map, K key, Short defaultValue) {\n+        Short answer = getShort(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static Integer getInteger( Map map, Object key, Integer defaultValue ) {\n-        Integer answer = getInteger( map, key );\n-        if ( answer == null ) {\n+    public static <K> Integer getInteger(Map<? super K, ?> map, K key, Integer defaultValue) {\n+        Integer answer = getInteger(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static Long getLong( Map map, Object key, Long defaultValue ) {\n-        Long answer = getLong( map, key );\n-        if ( answer == null ) {\n+    public static <K> Long getLong(Map<? super K, ?> map, K key, Long defaultValue) {\n+        Long answer = getLong(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static Float getFloat( Map map, Object key, Float defaultValue ) {\n-        Float answer = getFloat( map, key );\n-        if ( answer == null ) {\n+    public static <K> Float getFloat(Map<? super K, ?> map, K key, Float defaultValue) {\n+        Float answer = getFloat(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the number conversion\n      *    fails\n      */\n-    public static Double getDouble( Map map, Object key, Double defaultValue ) {\n-        Double answer = getDouble( map, key );\n-        if ( answer == null ) {\n+    public static <K> Double getDouble(Map<? super K, ?> map, K key, Double defaultValue) {\n+        Double answer = getDouble(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n      *  @param key  the key of the value to look up in that map\n      *  @param defaultValue  what to return if the value is null or if the\n      *     conversion fails\n-     *  @return  the value in the map as a number, or defaultValue if the \n+     *  @return  the value in the map as a number, or defaultValue if the\n      *    original value is null, the map is null or the map conversion\n      *    fails\n      */\n-    public static Map getMap( Map map, Object key, Map defaultValue ) {\n-        Map answer = getMap( map, key );\n-        if ( answer == null ) {\n+    public static <K> Map<?, ?> getMap(Map<? super K, ?> map, K key, Map<?, ?> defaultValue) {\n+        Map<?, ?> answer = getMap(map, key);\n+        if (answer == null) {\n             answer = defaultValue;\n         }\n         return answer;\n     }\n-    \n \n     // Type safe primitive getters\n     //-------------------------------------------------------------------------\n      * @param key  the key to look up\n      * @return the value in the Map as a Boolean, <code>false</code> if null map input\n      */\n-    public static boolean getBooleanValue(final Map map, final Object key) {\n-        Boolean booleanObject = getBoolean(map, key);\n-        if (booleanObject == null) {\n-            return false;\n-        }\n-        return booleanObject.booleanValue();\n+    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n+        return Boolean.TRUE.equals(getBoolean(map, key));\n     }\n \n     /**\n      * @param key  the key to look up\n      * @return the value in the Map as a byte, <code>0</code> if null map input\n      */\n-    public static byte getByteValue(final Map map, final Object key) {\n+    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n         Byte byteObject = getByte(map, key);\n         if (byteObject == null) {\n             return 0;\n      * @param key  the key to look up\n      * @return the value in the Map as a short, <code>0</code> if null map input\n      */\n-    public static short getShortValue(final Map map, final Object key) {\n+    public static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n         Short shortObject = getShort(map, key);\n         if (shortObject == null) {\n             return 0;\n      * @param key  the key to look up\n      * @return the value in the Map as an int, <code>0</code> if null map input\n      */\n-    public static int getIntValue(final Map map, final Object key) {\n+    public static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n         Integer integerObject = getInteger(map, key);\n         if (integerObject == null) {\n             return 0;\n      * @param key  the key to look up\n      * @return the value in the Map as a long, <code>0L</code> if null map input\n      */\n-    public static long getLongValue(final Map map, final Object key) {\n+    public static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n         Long longObject = getLong(map, key);\n         if (longObject == null) {\n             return 0L;\n      * @param key  the key to look up\n      * @return the value in the Map as a float, <code>0.0F</code> if null map input\n      */\n-    public static float getFloatValue(final Map map, final Object key) {\n+    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n         Float floatObject = getFloat(map, key);\n         if (floatObject == null) {\n             return 0f;\n      * @param key  the key to look up\n      * @return the value in the Map as a double, <code>0.0</code> if null map input\n      */\n-    public static double getDoubleValue(final Map map, final Object key) {\n+    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n         Double doubleObject = getDouble(map, key);\n         if (doubleObject == null) {\n             return 0d;\n      *     conversion fails\n      * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n      */\n-    public static boolean getBooleanValue(final Map map, final Object key, boolean defaultValue) {\n+    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, boolean defaultValue) {\n         Boolean booleanObject = getBoolean(map, key);\n         if (booleanObject == null) {\n             return defaultValue;\n \n     /**\n      * Gets a byte from a Map in a null-safe manner,\n-     * using the default value if the the conversion fails.     \n+     * using the default value if the the conversion fails.\n      * <p>\n      * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n      *     conversion fails\n      * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n      */\n-    public static byte getByteValue(final Map map, final Object key, byte defaultValue) {\n+    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key, byte defaultValue) {\n         Byte byteObject = getByte(map, key);\n         if (byteObject == null) {\n             return defaultValue;\n \n     /**\n      * Gets a short from a Map in a null-safe manner,\n-     * using the default value if the the conversion fails.     \n+     * using the default value if the the conversion fails.\n      * <p>\n      * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n      *     conversion fails\n      * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n      */\n-    public static short getShortValue(final Map map, final Object key, short defaultValue) {\n+    public static <K> short getShortValue(final Map<? super K, ?> map, final K key, short defaultValue) {\n         Short shortObject = getShort(map, key);\n         if (shortObject == null) {\n             return defaultValue;\n \n     /**\n      * Gets an int from a Map in a null-safe manner,\n-     * using the default value if the the conversion fails.     \n+     * using the default value if the the conversion fails.\n      * <p>\n      * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n      *     conversion fails\n      * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n      */\n-    public static int getIntValue(final Map map, final Object key, int defaultValue) {\n+    public static <K> int getIntValue(final Map<? super K, ?> map, final K key, int defaultValue) {\n         Integer integerObject = getInteger(map, key);\n         if (integerObject == null) {\n             return defaultValue;\n \n     /**\n      * Gets a long from a Map in a null-safe manner,\n-     * using the default value if the the conversion fails.     \n+     * using the default value if the the conversion fails.\n      * <p>\n      * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n      *     conversion fails\n      * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n      */\n-    public static long getLongValue(final Map map, final Object key, long defaultValue) {\n+    public static <K> long getLongValue(final Map<? super K, ?> map, final K key, long defaultValue) {\n         Long longObject = getLong(map, key);\n         if (longObject == null) {\n             return defaultValue;\n \n     /**\n      * Gets a float from a Map in a null-safe manner,\n-     * using the default value if the the conversion fails.     \n+     * using the default value if the the conversion fails.\n      * <p>\n      * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n      *     conversion fails\n      * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n      */\n-    public static float getFloatValue(final Map map, final Object key, float defaultValue) {\n+    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key, float defaultValue) {\n         Float floatObject = getFloat(map, key);\n         if (floatObject == null) {\n             return defaultValue;\n \n     /**\n      * Gets a double from a Map in a null-safe manner,\n-     * using the default value if the the conversion fails.     \n+     * using the default value if the the conversion fails.\n      * <p>\n      * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n      *\n      *     conversion fails\n      * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n      */\n-    public static double getDoubleValue(final Map map, final Object key, double defaultValue) {\n+    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, double defaultValue) {\n         Double doubleObject = getDouble(map, key);\n         if (doubleObject == null) {\n             return defaultValue;\n     /**\n      * Gets a new Properties object initialised with the values from a Map.\n      * A null input will return an empty properties object.\n-     * \n+     *\n      * @param map  the map to convert to a Properties object, may not be null\n      * @return the properties object\n      */\n-    public static Properties toProperties(final Map map) {\n+    public static <K, V> Properties toProperties(final Map<K, V> map) {\n         Properties answer = new Properties();\n         if (map != null) {\n-            for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {\n-                Map.Entry entry = (Map.Entry) iter.next();\n+            for (Iterator<Map.Entry<K, V>> iter = map.entrySet().iterator(); iter.hasNext();) {\n+                Map.Entry<?, ?> entry = iter.next();\n                 Object key = entry.getKey();\n                 Object value = entry.getValue();\n                 answer.put(key, value);\n \n     /**\n      * Creates a new HashMap using data copied from a ResourceBundle.\n-     * \n+     *\n      * @param resourceBundle  the resource bundle to convert, may not be null\n      * @return the hashmap containing the data\n      * @throws NullPointerException if the bundle is null\n      */\n-    public static Map toMap(final ResourceBundle resourceBundle) {\n-        Enumeration enumeration = resourceBundle.getKeys();\n-        Map map = new HashMap();\n+    public static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n+        Enumeration<String> enumeration = resourceBundle.getKeys();\n+        Map<String, Object> map = new HashMap<String, Object>();\n \n         while (enumeration.hasMoreElements()) {\n             String key = (String) enumeration.nextElement();\n             Object value = resourceBundle.getObject(key);\n             map.put(key, value);\n         }\n-        \n+\n         return map;\n     }\n- \n+\n     // Printing methods\n     //-------------------------------------------------------------------------\n     /**\n     public static void verbosePrint(\n         final PrintStream out,\n         final Object label,\n-        final Map map) {\n-\n-        verbosePrintInternal(out, label, map, new ArrayStack(), false);\n+        final Map<?, ?> map) {\n+\n+        verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), false);\n     }\n \n     /**\n     public static void debugPrint(\n         final PrintStream out,\n         final Object label,\n-        final Map map) {\n-\n-        verbosePrintInternal(out, label, map, new ArrayStack(), true);\n+        final Map<?, ?> map) {\n+\n+        verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), true);\n     }\n \n     // Implementation methods\n     }\n \n     /**\n-     * Implementation providing functionality for {@link #debugPrint} and for \n+     * Implementation providing functionality for {@link #debugPrint} and for\n      * {@link #verbosePrint}.  This prints the given map with nice line breaks.\n-     * If the debug flag is true, it additionally prints the type of the object \n-     * value.  If the contents of a map include the map itself, then the text \n-     * <em>(this Map)</em> is printed out.  If the contents include a \n-     * parent container of the map, the the text <em>(ancestor[i] Map)</em> is \n-     * printed, where i actually indicates the number of levels which must be \n-     * traversed in the sequential list of ancestors (e.g. father, grandfather, \n-     * great-grandfather, etc).  \n+     * If the debug flag is true, it additionally prints the type of the object\n+     * value.  If the contents of a map include the map itself, then the text\n+     * <em>(this Map)</em> is printed out.  If the contents include a\n+     * parent container of the map, the the text <em>(ancestor[i] Map)</em> is\n+     * printed, where i actually indicates the number of levels which must be\n+     * traversed in the sequential list of ancestors (e.g. father, grandfather,\n+     * great-grandfather, etc).\n      *\n      * @param out  the stream to print to\n      * @param label  the label to be used, may be <code>null</code>.\n      *  It typically represents the name of the property in a bean or similar.\n      * @param map  the map to print, may be <code>null</code>.\n      *  If <code>null</code>, the text 'null' is output\n-     * @param lineage  a stack consisting of any maps in which the previous \n+     * @param lineage  a stack consisting of any maps in which the previous\n      *  argument is contained. This is checked to avoid infinite recursion when\n      *  printing the output\n      * @param debug  flag indicating whether type names should be output.\n     private static void verbosePrintInternal(\n         final PrintStream out,\n         final Object label,\n-        final Map map,\n-        final ArrayStack lineage,\n+        final Map<?, ?> map,\n+        final ArrayStack<Map<?, ?>> lineage,\n         final boolean debug) {\n-        \n+\n         printIndent(out, lineage.size());\n \n         if (map == null) {\n \n         lineage.push(map);\n \n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n+        for (Map.Entry<?, ?> entry : map.entrySet()) {\n             Object childKey = entry.getKey();\n             Object childValue = entry.getValue();\n             if (childValue instanceof Map && !lineage.contains(childValue)) {\n                 verbosePrintInternal(\n                     out,\n                     (childKey == null ? \"null\" : childKey),\n-                    (Map) childValue,\n+                    (Map<?, ?>) childValue,\n                     lineage,\n                     debug);\n             } else {\n                 printIndent(out, lineage.size());\n                 out.print(childKey);\n                 out.print(\" = \");\n-                \n+\n                 final int lineageIndex = lineage.indexOf(childValue);\n                 if (lineageIndex == -1) {\n                     out.print(childValue);\n                 } else if (lineage.size() - 1 == lineageIndex) {\n-                    out.print(\"(this Map)\");    \n+                    out.print(\"(this Map)\");\n                 } else {\n                     out.print(\n                         \"(ancestor[\"\n                             + (lineage.size() - 1 - lineageIndex - 1)\n                             + \"] Map)\");\n                 }\n-                \n+\n                 if (debug && childValue != null) {\n                     out.print(' ');\n                     out.println(childValue.getClass().getName());\n                 }\n             }\n         }\n-        \n+\n         lineage.pop();\n \n         printIndent(out, lineage.size());\n             out.print(INDENT_STRING);\n         }\n     }\n-    \n+\n     // Misc\n     //-----------------------------------------------------------------------\n     /**\n      * <p>\n      * This operation assumes that the inverse mapping is well defined.\n      * If the input map had multiple entries with the same value mapped to\n-     * different keys, the returned map will map one of those keys to the \n+     * different keys, the returned map will map one of those keys to the\n      * value, but the exact key which will be mapped is undefined.\n      *\n      * @param map  the map to invert, may not be null\n      * @return a new HashMap containing the inverted data\n      * @throws NullPointerException if the map is null\n      */\n-    public static Map invertMap(Map map) {\n-        Map out = new HashMap(map.size());\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n+    public static <K, V> Map<V, K> invertMap(Map<K, V> map) {\n+        Map<V, K> out = new HashMap<V, K>(map.size());\n+        for (Iterator<Map.Entry<K, V>> it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry<K, V> entry = it.next();\n             out.put(entry.getValue(), entry.getKey());\n         }\n         return out;\n     }\n-     \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Protects against adding null values to a map.\n      * which should be held in the same way in the map.\n      * <p>\n      * Keys are not validated.\n-     * \n+     * Note that this method can be used to circumvent the map's\n+     * value type at runtime.\n+     *\n      * @param map  the map to add to, may not be null\n      * @param key  the key\n      * @param value  the value, null converted to \"\"\n      * @throws NullPointerException if the map is null\n      */\n-    public static void safeAddToMap(Map map, Object key, Object value) throws NullPointerException {\n-        if (value == null) {\n-            map.put(key, \"\");\n-        } else {\n-            map.put(key, value);\n-        }\n+    public static <K> void safeAddToMap(Map<? super K, Object> map, K key, Object value) throws NullPointerException {\n+        map.put(key, value == null ? \"\" : value);\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws ClassCastException if the array contents is mixed\n      * @since Commons Collections 3.2\n      */\n-    public static Map putAll(Map map, Object[] array) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> Map<K, V> putAll(Map<K, V> map, Object[] array) {\n         map.size();  // force NPE\n         if (array == null || array.length == 0) {\n             return map;\n         Object obj = array[0];\n         if (obj instanceof Map.Entry) {\n             for (int i = 0; i < array.length; i++) {\n-                Map.Entry entry = (Map.Entry) array[i];\n+                Map.Entry<K, V> entry = (Map.Entry<K, V>) array[i];\n                 map.put(entry.getKey(), entry.getValue());\n             }\n         } else if (obj instanceof KeyValue) {\n             for (int i = 0; i < array.length; i++) {\n-                KeyValue keyval = (KeyValue) array[i];\n+                KeyValue<K, V> keyval = (KeyValue<K, V>) array[i];\n                 map.put(keyval.getKey(), keyval.getValue());\n             }\n         } else if (obj instanceof Object[]) {\n                 if (sub == null || sub.length < 2) {\n                     throw new IllegalArgumentException(\"Invalid array element: \" + i);\n                 }\n-                map.put(sub[0], sub[1]);\n+                map.put((K) sub[0], (V) sub[1]);\n             }\n         } else {\n             for (int i = 0; i < array.length - 1;) {\n-                map.put(array[i++], array[i++]);\n+                map.put((K) array[i++], (V) array[i++]);\n             }\n         }\n         return map;\n      * Null-safe check if the specified map is empty.\n      * <p>\n      * Null returns true.\n-     * \n+     *\n      * @param map  the map to check, may be null\n      * @return true if empty or null\n      * @since Commons Collections 3.2\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static boolean isEmpty(Map map) {\n         return (map == null || map.isEmpty());\n     }\n      * Null-safe check if the specified map is not empty.\n      * <p>\n      * Null returns false.\n-     * \n+     *\n      * @param map  the map to check, may be null\n      * @return true if non-null and non-empty\n      * @since Commons Collections 3.2\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public static boolean isNotEmpty(Map map) {\n         return !MapUtils.isEmpty(map);\n     }\n     /**\n      * Returns a synchronized map backed by the given map.\n      * <p>\n-     * You must manually synchronize on the returned buffer's iterator to \n+     * You must manually synchronize on the returned buffer's iterator to\n      * avoid non-deterministic behavior:\n-     *  \n+     *\n      * <pre>\n      * Map m = MapUtils.synchronizedMap(myMap);\n      * Set s = m.keySet();  // outside synchronized block\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * This method uses the implementation in {@link java.util.Collections Collections}.\n-     * \n+     *\n      * @param map  the map to synchronize, must not be null\n      * @return a synchronized map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      */\n-    public static Map synchronizedMap(Map map) {\n+    public static <K, V> Map<K, V> synchronizedMap(Map<K, V> map) {\n         return Collections.synchronizedMap(map);\n     }\n \n      * @return an unmodifiable map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      */\n-    public static Map unmodifiableMap(Map map) {\n+    public static <K, V> Map<K, V> unmodifiableMap(Map<K, V> map) {\n         return UnmodifiableMap.decorate(map);\n     }\n \n      * @return a predicated map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static Map predicatedMap(Map map, Predicate keyPred, Predicate valuePred) {\n+    public static <K, V> IterableMap<K, V> predicatedMap(Map<K, V> map, Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n         return PredicatedMap.decorate(map, keyPred, valuePred);\n     }\n \n-    /**\n-     * Returns a typed map backed by the given map.\n-     * <p>\n-     * Only keys and values of the specified types can be added to the map.\n-     * \n-     * @param map  the map to limit to a specific type, must not be null\n-     * @param keyType  the type of keys which may be added to the map, must not be null\n-     * @param valueType  the type of values which may be added to the map, must not be null\n-     * @return a typed map backed by the specified map\n-     * @throws IllegalArgumentException  if the Map or Class is null\n-     */\n-    public static Map typedMap(Map map, Class keyType, Class valueType) {\n-        return TypedMap.decorate(map, keyType, valueType);\n-    }\n-    \n     /**\n      * Returns a transformed map backed by the given map.\n      * <p>\n      * If you want that behaviour, see {@link TransformedMap#decorateTransform}.\n      * <p>\n      * Each object is passed through the transformers as it is added to the\n-     * Map. It is important not to use the original map after invoking this \n+     * Map. It is important not to use the original map after invoking this\n      * method, as it is a backdoor for adding untransformed objects.\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * @return a transformed map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static Map transformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n+    public static <K, V> IterableMap<K, V> transformedMap(Map<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n         return TransformedMap.decorate(map, keyTransformer, valueTransformer);\n     }\n-    \n+\n     /**\n      * Returns a fixed-sized map backed by the given map.\n-     * Elements may not be added or removed from the returned map, but \n-     * existing elements can be changed (for instance, via the \n+     * Elements may not be added or removed from the returned map, but\n+     * existing elements can be changed (for instance, via the\n      * {@link Map#put(Object,Object)} method).\n      *\n      * @param map  the map whose size to fix, must not be null\n      * @return a fixed-size map backed by that map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static Map fixedSizeMap(Map map) {\n+    public static <K, V> IterableMap<K, V> fixedSizeMap(Map<K, V> map) {\n         return FixedSizeMap.decorate(map);\n     }\n \n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the Map or Factory is null\n      */\n-    public static Map lazyMap(Map map, Factory factory) {\n-        return LazyMap.decorate(map, factory);\n+    public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Factory<? extends V> factory) {\n+        return LazyMap.getLazyMap(map, factory);\n     }\n \n     /**\n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n-    public static Map lazyMap(Map map, Transformer transformerFactory) {\n-        return LazyMap.decorate(map, transformerFactory);\n+    public static <K, V> IterableMap<K, V> lazyMap(Map<K, V> map, Transformer<? super K, ? extends V> transformerFactory) {\n+        return LazyMap.getLazyMap(map, transformerFactory);\n     }\n \n     /**\n      * @return an ordered map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static Map orderedMap(Map map) {\n+    public static <K, V> OrderedMap<K, V> orderedMap(Map<K, V> map) {\n         return ListOrderedMap.decorate(map);\n     }\n \n      * @see MultiValueMap\n      * @since Commons Collections 3.2\n      */\n-    public static Map multiValueMap(Map map) {\n-        return MultiValueMap.decorate(map);\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(Map<K, ? super Collection<V>> map) {\n+        return MultiValueMap.<K, V>decorate(map);\n     }\n \n     /**\n      * @see MultiValueMap\n      * @since Commons Collections 3.2\n      */\n-    public static Map multiValueMap(Map map, Class collectionClass) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Class<C> collectionClass) {\n         return MultiValueMap.decorate(map, collectionClass);\n     }\n \n      * @see MultiValueMap\n      * @since Commons Collections 3.2\n      */\n-    public static Map multiValueMap(Map map, Factory collectionFactory) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(Map<K, C> map, Factory<C> collectionFactory) {\n         return MultiValueMap.decorate(map, collectionFactory);\n     }\n \n     /**\n      * Returns a synchronized sorted map backed by the given sorted map.\n      * <p>\n-     * You must manually synchronize on the returned buffer's iterator to \n+     * You must manually synchronize on the returned buffer's iterator to\n      * avoid non-deterministic behavior:\n-     *  \n+     *\n      * <pre>\n      * Map m = MapUtils.synchronizedSortedMap(myMap);\n      * Set s = m.keySet();  // outside synchronized block\n      *     }\n      * }\n      * </pre>\n-     * \n+     *\n      * This method uses the implementation in {@link java.util.Collections Collections}.\n-     * \n+     *\n      * @param map  the map to synchronize, must not be null\n      * @return a synchronized map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      */\n-    public static Map synchronizedSortedMap(SortedMap map) {\n+    public static <K, V> SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> map) {\n         return Collections.synchronizedSortedMap(map);\n     }\n \n      * @return an unmodifiable map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n      */\n-    public static Map unmodifiableSortedMap(SortedMap map) {\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, V> map) {\n         return UnmodifiableSortedMap.decorate(map);\n     }\n \n      * @return a predicated map backed by the given map\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n-    public static SortedMap predicatedSortedMap(SortedMap map, Predicate keyPred, Predicate valuePred) {\n+    public static <K, V> SortedMap<K, V> predicatedSortedMap(SortedMap<K, V> map,\n+            Predicate<? super K> keyPred, Predicate<? super V> valuePred) {\n         return PredicatedSortedMap.decorate(map, keyPred, valuePred);\n     }\n \n-    /**\n-     * Returns a typed sorted map backed by the given map.\n-     * <p>\n-     * Only keys and values of the specified types can be added to the map.\n-     * \n-     * @param map  the map to limit to a specific type, must not be null\n-     * @param keyType  the type of keys which may be added to the map, must not be null\n-     * @param valueType  the type of values which may be added to the map, must not be null\n-     * @return a typed map backed by the specified map\n-     */\n-    public static SortedMap typedSortedMap(SortedMap map, Class keyType, Class valueType) {\n-        return TypedSortedMap.decorate(map, keyType, valueType);\n-    }\n-    \n     /**\n      * Returns a transformed sorted map backed by the given map.\n      * <p>\n      * If you want that behaviour, see {@link TransformedSortedMap#decorateTransform}.\n      * <p>\n      * Each object is passed through the transformers as it is added to the\n-     * Map. It is important not to use the original map after invoking this \n+     * Map. It is important not to use the original map after invoking this\n      * method, as it is a backdoor for adding untransformed objects.\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * @return a transformed map backed by the given map\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n-    public static SortedMap transformedSortedMap(SortedMap map, Transformer keyTransformer, Transformer valueTransformer) {\n+    public static <K, V> SortedMap<K, V> transformedSortedMap(SortedMap<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n         return TransformedSortedMap.decorate(map, keyTransformer, valueTransformer);\n     }\n-    \n+\n     /**\n      * Returns a fixed-sized sorted map backed by the given sorted map.\n-     * Elements may not be added or removed from the returned map, but \n-     * existing elements can be changed (for instance, via the \n+     * Elements may not be added or removed from the returned map, but\n+     * existing elements can be changed (for instance, via the\n      * {@link Map#put(Object,Object)} method).\n      *\n      * @param map  the map whose size to fix, must not be null\n      * @return a fixed-size map backed by that map\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n-    public static SortedMap fixedSizeSortedMap(SortedMap map) {\n+    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(SortedMap<K, V> map) {\n         return FixedSizeSortedMap.decorate(map);\n     }\n \n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the SortedMap or Factory is null\n      */\n-    public static SortedMap lazySortedMap(SortedMap map, Factory factory) {\n-        return LazySortedMap.decorate(map, factory);\n-    }\n-    \n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n+            Factory<? extends V> factory) {\n+        return LazySortedMap.getLazySortedMap(map, factory);\n+    }\n+\n     /**\n      * Returns a \"lazy\" sorted map whose values will be created on demand.\n      * <p>\n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n-    public static SortedMap lazySortedMap(SortedMap map, Transformer transformerFactory) {\n-        return LazySortedMap.decorate(map, transformerFactory);\n+    public static <K, V> SortedMap<K, V> lazySortedMap(SortedMap<K, V> map,\n+            Transformer<? super K, ? extends V> transformerFactory) {\n+        return LazySortedMap.getLazySortedMap(map, transformerFactory);\n     }\n \n     /**\n      * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n      * @throws NullPointerException if the map, collection or transformer are null\n      */\n+    // TODO: Generics\n     public static void populateMap(Map map, Collection collection, Transformer keyTransformer) {\n         populateMap(map, collection, keyTransformer, TransformerUtils.nopTransformer());\n     }\n      * @param valueTransformer the <code>Transformer</code> used to transform the collection value into a value\n      * @throws NullPointerException if the map, collection or transformers are null\n      */\n+    // TODO: Generics\n     public static void populateMap(Map map, Collection collection, Transformer keyTransformer, Transformer valueTransformer) {\n         Iterator iter = collection.iterator();\n         while (iter.hasNext()) {\n             map.put(keyTransformer.transform(temp), valueTransformer.transform(temp));\n         }\n     }\n+\n+    /**\n+     * Get the specified {@link Map} as an {@link IterableMap}.\n+     * @param <K>\n+     * @param <V>\n+     * @param map to wrap if necessary.\n+     * @return IterableMap<K, V>\n+     * @since Commons Collections 5\n+     * @TODO fix version\n+     */\n+    public static <K, V> IterableMap<K, V> iterableMap(Map<K, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        return map instanceof IterableMap ? (IterableMap<K, V>) map\n+                : new AbstractMapDecorator<K, V>(map) {\n+                };\n+    }\n+\n+    /**\n+     * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n+     * @param <K>\n+     * @param <V>\n+     * @param sortedMap to wrap if necessary\n+     * @return {@link IterableSortedMap}<K, V>\n+     * @since Commons Collections 5\n+     * @TODO fix version\n+     */\n+    public static <K, V> IterableSortedMap<K, V> iterableSortedMap(SortedMap<K, V> sortedMap) {\n+        if (sortedMap == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap\n+                : new AbstractSortedMapDecorator<K, V>(sortedMap) {\n+                };\n+    }\n+\n }", "timestamp": 1252994185, "metainfo": ""}