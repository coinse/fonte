{"sha": "709aa7bf9c998cc75f6e0be7d258aa5a07ebce8b", "log": "[COLLECTIONS-466] Replace Collection with Iterable where applicable in CollectionUtils.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n \n /**\n  * Provides utility methods and decorators for {@link Collection} instances.\n- * Method parameters will take {@link Iterable} objects when possible.\n+ * <p>\n+ * NOTE: From 4.0, method parameters will take {@link Iterable} objects when possible.\n  *\n  * @since 1.0\n  * @version $Id$\n \n     /**\n      * Returns a {@link Collection} containing the union of the given\n-     * {@link Collection}s.\n+     * {@link Iterable}s.\n      * <p>\n      * The cardinality of each element in the returned {@link Collection} will\n      * be equal to the maximum of the cardinality of that element in the two\n-     * given {@link Collection}s.\n+     * given {@link Iterable}s.\n      *\n      * @param a the first collection, must not be null\n      * @param b the second collection, must not be null\n \n     /**\n      * Returns a {@link Collection} containing the intersection of the given\n-     * {@link Collection}s.\n+     * {@link Iterable}s.\n      * <p>\n      * The cardinality of each element in the returned {@link Collection} will\n      * be equal to the minimum of the cardinality of that element in the two\n-     * given {@link Collection}s.\n+     * given {@link Iterable}s.\n      *\n      * @param a the first collection, must not be null\n      * @param b the second collection, must not be null\n \n     /**\n      * Returns a {@link Collection} containing the exclusive disjunction\n-     * (symmetric difference) of the given {@link Collection}s.\n+     * (symmetric difference) of the given {@link Iterable}s.\n      * <p>\n      * The cardinality of each element <i>e</i> in the returned\n      * {@link Collection} will be equal to\n      * Only those elements present in the collection will appear as\n      * keys in the map.\n      *\n-     * @param coll\n-     *            the collection to get the cardinality map for, must not be\n-     *            null\n-     * @param <O>\n-     *            the type of object in the returned {@link Map}. This is a\n-     *            super type of <I>.\n+     * @param <O>  the type of object in the returned {@link Map}. This is a super type of <I>.\n+     * @param coll  the collection to get the cardinality map for, must not be null\n      * @return the populated cardinality map\n      */\n     public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n      * If the input collection or predicate is null, or no element of the collection\n      * matches the predicate, null is returned.\n      *\n-     * @param <T>  the type of object the {@link Collection} contains\n+     * @param <T>  the type of object the {@link Iterable} contains\n      * @param collection  the collection to search, may be null\n      * @param predicate  the predicate to use, may be null\n      * @return the first element of the collection which matches the predicate or null if none could be found\n      */\n-    public static <T> T find(final Collection<T> collection, final Predicate<? super T> predicate) {\n+    public static <T> T find(final Iterable<T> collection, final Predicate<? super T> predicate) {\n         if (collection != null && predicate != null) {\n             for (final T item : collection) {\n                 if (predicate.evaluate(item)) {\n      * <p>\n      * If the input collection or closure is null, there is no change made.\n      *\n-     * @param <T>  the type of object the {@link Collection} contains\n+     * @param <T>  the type of object the {@link Iterable} contains\n      * @param <C>  the closure type\n      * @param collection  the collection to get the input from, may be null\n      * @param closure  the closure to perform, may be null\n      * @return closure\n      */\n-    public static <T, C extends Closure<? super T>> C forAllDo(final Collection<T> collection, final C closure) {\n+    public static <T, C extends Closure<? super T>> C forAllDo(final Iterable<T> collection, final C closure) {\n         if (collection != null && closure != null) {\n             for (final T element : collection) {\n                 closure.execute(element);\n      * <p>\n      * If the input collection or closure is null, there is no change made.\n      *\n-     * @param <T>  the type of object the {@link Collection} contains\n+     * @param <T>  the type of object the {@link Iterable} contains\n      * @param <C>  the closure type\n      * @param collection  the collection to get the input from, may be null\n      * @param closure  the closure to perform, may be null\n      * @return the last element in the collection, or null if either collection or closure is null\n      * @since 4.0\n      */\n-    public static <T, C extends Closure<? super T>> T forAllButLastDo(final Collection<T> collection,\n+    public static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection,\n                                                                       final C closure) {\n         return collection != null && closure != null ? forAllButLastDo(collection.iterator(), closure) : null;\n     }\n      * may reduce in size due to calling this method.\n      *\n      * @param <C>  the type of object the {@link Collection} contains\n-     * @param collection  the {@link Iterable} to get the input from, may be null\n+     * @param collection  the {@link Collection} to get the input from, may be null\n      * @param transformer  the transformer to perform, may be null\n      */\n     public static <C> void transform(final Collection<C> collection,\n      * <p>\n      * A <code>null</code> predicate matches no elements.\n      *\n-     * @param <O>  the type of object the {@link Collection} contains\n+     * @param <O>  the type of object the {@link Iterable} contains\n      * @param inputCollection  the collection to get the input from, may not be null\n      * @param predicate  the predicate to use, may be null\n      * @return the elements matching the predicate (new list)\n      * @throws NullPointerException if the input collection is null\n      */\n-    public static <O> Collection<O> select(final Collection<? extends O> inputCollection,\n+    public static <O> Collection<O> select(final Iterable<? extends O> inputCollection,\n             final Predicate<? super O> predicate) {\n-        return select(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+        final Collection<O> answer = inputCollection instanceof Collection<?> ?\n+                new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n+        return select(inputCollection, predicate, answer);\n     }\n \n     /**\n      * If the input collection or predicate is null, there is no change to the\n      * output collection.\n      *\n-     * @param <O>  the type of object the {@link Collection} contains\n+     * @param <O>  the type of object the {@link Iterable} contains\n      * @param <R>  the type of the output {@link Collection}\n      * @param inputCollection  the collection to get the input from, may be null\n      * @param predicate  the predicate to use, may be null\n      *   and predicate or not null\n      * @return the outputCollection\n      */\n-    public static <O, R extends Collection<? super O>> R select(final Collection<? extends O> inputCollection,\n+    public static <O, R extends Collection<? super O>> R select(final Iterable<? extends O> inputCollection,\n             final Predicate<? super O> predicate, final R outputCollection) {\n \n         if (inputCollection != null && predicate != null) {\n      * If the input predicate is <code>null</code>, the result is an empty\n      * list.\n      *\n-     * @param <O>  the type of object the {@link Collection} contains\n+     * @param <O>  the type of object the {@link Iterable} contains\n      * @param inputCollection  the collection to get the input from, may not be null\n      * @param predicate  the predicate to use, may be null\n      * @return the elements <b>not</b> matching the predicate (new list)\n      * @throws NullPointerException if the input collection is null\n      */\n-    public static <O> Collection<O> selectRejected(final Collection<? extends O> inputCollection,\n+    public static <O> Collection<O> selectRejected(final Iterable<? extends O> inputCollection,\n             final Predicate<? super O> predicate) {\n-        return selectRejected(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+        final Collection<O> answer = inputCollection instanceof Collection<?> ?\n+                new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n+        return selectRejected(inputCollection, predicate, answer);\n     }\n \n     /**\n      * If the input predicate is <code>null</code>, no elements are added to\n      * <code>outputCollection</code>.\n      *\n-     * @param <O>  the type of object the {@link Collection} contains\n+     * @param <O>  the type of object the {@link Iterable} contains\n      * @param <R>  the type of the output {@link Collection}\n      * @param inputCollection  the collection to get the input from, may be null\n      * @param predicate  the predicate to use, may be null\n      *   and predicate or not null\n      * @return outputCollection\n      */\n-    public static <O, R extends Collection<? super O>> R selectRejected(final Collection<? extends O> inputCollection,\n+    public static <O, R extends Collection<? super O>> R selectRejected(final Iterable<? extends O> inputCollection,\n             final Predicate<? super O> predicate, final R outputCollection) {\n \n         if (inputCollection != null && predicate != null) {\n      * <p>\n      * If the input transformer is null, the result is an empty list.\n      *\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n      * @param inputCollection  the collection to get the input from, may not be null\n      * @param transformer  the transformer to use, may be null\n-     * @param <I> the type of object in the input collection\n-     * @param <O> the type of object in the output collection\n      * @return the transformed result (new list)\n      * @throws NullPointerException if the input collection is null\n      */\n     public static <I, O> Collection<O> collect(final Iterable<I> inputCollection,\n             final Transformer<? super I, ? extends O> transformer) {\n-        final ArrayList<O> answer = new ArrayList<O>();\n-        collect(inputCollection, transformer, answer);\n-        return answer;\n+        final Collection<O> answer = inputCollection instanceof Collection<?> ?\n+                new ArrayList<O>(((Collection<?>) inputCollection).size()) : new ArrayList<O>();\n+        return collect(inputCollection, transformer, answer);\n     }\n \n     /**\n      */\n     public static <I, O> Collection<O> collect(final Iterator<I> inputIterator,\n             final Transformer<? super I, ? extends O> transformer) {\n-        final ArrayList<O> answer = new ArrayList<O>();\n-        collect(inputIterator, transformer, answer);\n-        return answer;\n+        return collect(inputIterator, transformer, new ArrayList<O>());\n     }\n \n     /**\n      * If the input collection or transformer is null, there is no change to the\n      * output collection.\n      *\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @param <R> the output type of the transformer - this extends O.\n      * @param inputCollection  the collection to get the input from, may be null\n      * @param transformer  the transformer to use, may be null\n      * @param outputCollection  the collection to output into, may not be null if the inputCollection\n      *   and transformer are not null\n-     * @param <I> the type of object in the input collection\n-     * @param <O> the type of object in the output collection\n-     * @param <R> the output type of the transformer - this extends O.\n      * @return the outputCollection with the transformed input added\n      * @throws NullPointerException if the output collection is null and both, inputCollection and\n      *   transformer are not null\n      * @throws IllegalArgumentException if either collection is null\n      * @since 4.0\n      */\n-    public static <O extends Comparable<? super O>> List<O> collate(Collection<? extends O> a,\n-                                                                    Collection<? extends O> b) {\n+    public static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a,\n+                                                                    Iterable<? extends O> b) {\n         return collate(a, b, ComparatorUtils.<O>naturalComparator(), true);\n     }\n \n      * @throws IllegalArgumentException if either collection is null\n      * @since 4.0\n      */\n-    public static <O extends Comparable<? super O>> List<O> collate(final Collection<? extends O> a,\n-                                                                    final Collection<? extends O> b,\n+    public static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a,\n+                                                                    final Iterable<? extends O> b,\n                                                                     final boolean includeDuplicates) {\n         return collate(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n     }\n      * @throws IllegalArgumentException if either collection or the comparator is null\n      * @since 4.0\n      */\n-    public static <O> List<O> collate(final Collection<? extends O> a, final Collection<? extends O> b,\n+    public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,\n                                       final Comparator<? super O> c) {\n         return collate(a, b, c, true);\n     }\n      * @throws IllegalArgumentException if either collection or the comparator is null\n      * @since 4.0\n      */\n-    public static <O> List<O> collate(final Collection<? extends O> a, final Collection<? extends O> b,\n+    public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,\n                                       final Comparator<? super O> c, final boolean includeDuplicates) {\n \n         if (a == null || b == null) {\n             throw new IllegalArgumentException(\"The comparator must not be null\");\n         }\n \n-        final int totalSize = Math.max(1, a.size() + b.size());\n+        // if both Iterables are a Collection, we can estimate the size\n+        final int totalSize = a instanceof Collection<?> && b instanceof Collection<?> ?\n+                Math.max(1, ((Collection<?>) a).size() + ((Collection<?>) b).size()) : 10;\n+\n         final Iterator<O> iterator = new CollatingIterator<O>(c, a.iterator(), b.iterator());\n         if (includeDuplicates) {\n             return IteratorUtils.toList(iterator, totalSize);", "timestamp": 1368377786, "metainfo": ""}