{"sha": "80ea89fd05deb7cf51ba37f8b6d3f4758bfb7c90", "log": "Renamed AbstractBag to DefaultMapBag.  The implementation is more of a \"default map based implementation\" and differs in design from the AbstractSet, AbstractMap classes which do not make assumptions about how they might be implemented.  To be consistent with JDK AbstractX collections, an AbstractBag class should just be providing default implementations that could be used regardless of underlying storage mechanism.  For example, the add(Object) method would call the abstract add(Object,int) method passing the object and 1. Since this implementation assumes a Map based storage for the Bag, it does not follow the AbstractX pattern, and thus has been renamed.  There is still room for future addition of an AbstractBag that does not assume a storage data structure.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/DefaultMapBag.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/DefaultMapBag.java,v 1.1 2002/03/25 05:50:57 mas Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/03/25 05:50:57 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * This class provides a skeletal implementation of the {@link Bag}\n+ * interface to minimize the effort required for target implementations.\n+ * Subclasses need only to call {@link #setMap(Map)} in their constructor \n+ * specifying a map instance that will be used to store the contents of \n+ * the bag. \n+ *\n+ * @author Chuck Burdick\n+ * @author <a href=\"mas@apache.org\">Michael A. Smith</a>\n+ **/\n+public abstract class DefaultMapBag implements Bag {\n+   private Map _map = null;\n+   private int _total = 0;\n+   private int _mods = 0;\n+\n+   public boolean add(Object o) {\n+      return add(o, 1);\n+   }\n+\n+   public boolean add(Object o, int i) {\n+      _mods++;\n+      if (i > 0) {\n+         int count = (i + getCount(o));\n+         _map.put(o, new Integer(count));\n+         _total += i;\n+         return (count == i);\n+      } else {\n+         return false;\n+      }\n+   }\n+\n+   public boolean addAll(Collection c) {\n+      boolean changed = false;\n+      Iterator i = c.iterator();\n+      while (i.hasNext()) {\n+         boolean added = add(i.next());\n+         changed = changed || added;\n+      }\n+      return changed;\n+   }\n+\n+   public void clear() {\n+      _mods++;\n+      _map.clear();\n+      _total = 0;\n+   }\n+\n+   public boolean contains(Object o) {\n+      return _map.containsKey(o);\n+   }\n+\n+   public boolean containsAll(Collection c) {\n+      return containsAll(new HashBag(c));\n+   }\n+\n+   /**\n+    * Returns <code>true</code> if the bag contains all elements in\n+    * the given collection, respecting cardinality.\n+    * @see #containsAll(Collection)\n+    **/\n+   public boolean containsAll(Bag other) {\n+      boolean result = true;\n+      Iterator i = other.uniqueSet().iterator();\n+      while (i.hasNext()) {\n+         Object current = i.next();\n+         boolean contains =\n+            getCount(current) >= ((Bag)other).getCount(current);\n+         result = result && contains;\n+      }\n+      return result;\n+   }\n+\n+   public boolean equals(Object o) {\n+      return (o == this || \n+              (o != null && o.getClass().equals(this.getClass()) &&\n+               ((DefaultMapBag)o)._map.equals(this._map)));\n+   }\n+\n+   public int hashCode() {\n+      return _map.hashCode();\n+   }\n+\n+   public boolean isEmpty() {\n+      return _map.isEmpty();\n+   }\n+\n+   public Iterator iterator() {\n+      return new BagIterator(this, extractList().iterator()); \n+   }\n+\n+   private class BagIterator implements Iterator {\n+      private DefaultMapBag _parent = null;\n+      private Iterator _support = null;\n+      private Object _current = null;\n+      private int _mods = 0;\n+\n+      public BagIterator(DefaultMapBag parent, Iterator support) {\n+         _parent = parent;\n+         _support = support;\n+         _current = null;\n+         _mods = parent.modCount();\n+      }\n+\n+      public boolean hasNext() {\n+         return _support.hasNext();\n+      }\n+\n+      public Object next() {\n+         if (_parent.modCount() != _mods) {\n+            throw new ConcurrentModificationException();\n+         }\n+         _current = _support.next();\n+         return _current;\n+      }\n+      \n+      public void remove() {\n+         if (_parent.modCount() != _mods) {\n+            throw new ConcurrentModificationException();\n+         }\n+         _support.remove();\n+         _parent.remove(_current, 1);\n+         _mods++;\n+      }\n+   }\n+\n+   public boolean remove (Object o) {\n+      return remove(o, getCount(o));\n+   }\n+\n+   public boolean remove (Object o, int i) {\n+      _mods++;\n+      boolean result = false;\n+      int count = getCount(o);\n+      if (i <= 0) {\n+         result = false;\n+      } else if (count > i) {\n+         _map.put(o, new Integer(count - i));\n+         result = true;\n+         _total -= i;\n+      } else { // count > 0 && count <= i  \n+         // need to remove all\n+         result = (_map.remove(o) != null);\n+         _total -= count;\n+      }\n+      return result;\n+   }\n+\n+   public boolean removeAll(Collection c) {\n+      boolean result = false;\n+      if (c != null) {\n+         Iterator i = c.iterator();\n+         while (i.hasNext()) {\n+            boolean changed = remove(i.next(), 1);\n+            result = result || changed;\n+         }\n+      }\n+      return result;\n+   }\n+\n+   public boolean retainAll(Collection c) {\n+      return retainAll(new HashBag(c));\n+   }\n+\n+   /**\n+    * Remove any members of the bag that are not in the given\n+    * bag, respecting cardinality.\n+    * @see #retainAll(Collection)\n+    * @return <code>true</code> if this call changed the collection\n+    **/\n+   public boolean retainAll(Bag other) {\n+      boolean result = false;\n+      Bag excess = new HashBag();\n+      Iterator i = uniqueSet().iterator();\n+      while (i.hasNext()) {\n+         Object current = i.next();\n+         int myCount = getCount(current);\n+         int otherCount = other.getCount(current);\n+         if (1 <= otherCount && otherCount <= myCount) {\n+            excess.add(current, myCount - otherCount);\n+         } else {\n+            excess.add(current, myCount);\n+         }\n+      }\n+      if (!excess.isEmpty()) {\n+         result = removeAll(excess);\n+      }\n+      return result;\n+   }\n+\n+   public Object[] toArray() {\n+      return extractList().toArray();\n+   }\n+\n+   public Object[] toArray(Object[] a) {\n+      return extractList().toArray(a);\n+   }\n+\n+   public int getCount(Object o) {\n+      int result = 0;\n+      Integer count = MapUtils.getInteger(_map, o);\n+      if (count != null) {\n+         result = count.intValue();\n+      }\n+      return result;\n+   }\n+\n+   public Set uniqueSet() {\n+      return Collections.unmodifiableSet(_map.keySet());\n+   }\n+\n+   public int size() {\n+      return _total;\n+   }\n+\n+   /**\n+    * Actually walks the bag to make sure the count is correct and\n+    * resets the running total\n+    **/\n+   protected int calcTotalSize() {\n+      _total = extractList().size();\n+      return _total;\n+   }\n+\n+   /**\n+    * Utility method for implementations to set the map that backs\n+    * this bag. Not intended for interactive use outside of\n+    * subclasses.\n+    **/\n+   protected void setMap(Map m) {\n+      _map = m;\n+   }\n+\n+   /**\n+    * Utility method for implementations to access the map that backs\n+    * this bag. Not intended for interactive use outside of\n+    * subclasses.\n+    **/\n+   protected Map getMap() {\n+      return _map;\n+   }\n+\n+   /**\n+    * Create a list for use in iteration, etc.\n+    **/\n+   private List extractList() {\n+      List result = new ArrayList();\n+      Iterator i = uniqueSet().iterator();\n+      while (i.hasNext()) {\n+         Object current = i.next();\n+         for (int index = getCount(current); index > 0; index--) {\n+            result.add(current);\n+         }\n+      }\n+      return result;\n+   }\n+\n+   /**\n+    * Return number of modifications for iterator\n+    **/\n+   private int modCount() {\n+      return _mods;\n+   }\n+}\n+\n+\n+\n--- a/src/java/org/apache/commons/collections/HashBag.java\n+++ b/src/java/org/apache/commons/collections/HashBag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/HashBag.java,v 1.3 2002/03/13 05:40:30 mas Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/03/13 05:40:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/HashBag.java,v 1.4 2002/03/25 05:50:57 mas Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/03/25 05:50:57 $\n  *\n  * ====================================================================\n  *\n  *\n  * @author Chuck Burdick\n  **/\n-public class HashBag extends AbstractBag implements Bag {\n+public class HashBag extends DefaultMapBag implements Bag {\n    public HashBag() {\n       setMap(new HashMap());\n    }\n--- a/src/java/org/apache/commons/collections/TreeBag.java\n+++ b/src/java/org/apache/commons/collections/TreeBag.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/TreeBag.java,v 1.3 2002/03/13 05:40:31 mas Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/03/13 05:40:31 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/TreeBag.java,v 1.4 2002/03/25 05:50:57 mas Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/03/25 05:50:57 $\n  *\n  * ====================================================================\n  *\n  *\n  * @author Chuck Burdick\n  **/\n-public class TreeBag extends AbstractBag implements SortedBag, Bag {\n+public class TreeBag extends DefaultMapBag implements SortedBag, Bag {\n    public TreeBag() {\n       setMap(new TreeMap());\n    }", "timestamp": 1017035457, "metainfo": ""}