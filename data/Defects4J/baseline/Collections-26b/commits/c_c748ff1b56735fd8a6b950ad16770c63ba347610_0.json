{"sha": "c748ff1b56735fd8a6b950ad16770c63ba347610", "log": "Improve subclassability by delegating methods from entry to main map Add support for serializable subclasses   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n  */\n package org.apache.commons.collections.map;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.lang.ref.Reference;\n import java.lang.ref.ReferenceQueue;\n import java.lang.ref.SoftReference;\n  * provide synchronized access to a <code>ReferenceMap</code>.\n  *\n  * @see java.lang.ref.Reference\n- * @since Commons Collections 3.1 (from ReferenceMap in 3.0)\n- * @version $Revision: 1.1 $ $Date: 2004/04/09 22:18:18 $\n+ * @since Commons Collections 3.1 (extracted from ReferenceMap in 3.0)\n+ * @version $Revision: 1.2 $ $Date: 2004/04/27 21:32:52 $\n  * \n  * @author Paul Jack\n  * @author Stephen Colebourne\n      * The reference type for keys.  Must be HARD, SOFT, WEAK.\n      * @serial\n      */\n-    private int keyType;\n+    protected int keyType;\n \n     /**\n      * The reference type for values.  Must be HARD, SOFT, WEAK.\n      * @serial\n      */\n-    private int valueType;\n+    protected int valueType;\n \n     /**\n      * Should the value be automatically purged when the associated key has been collected?\n      */\n-    private boolean purgeValues;\n+    protected boolean purgeValues;\n \n     /**\n      * ReferenceQueue used to eliminate stale mappings.\n      * See purge.\n      */\n-    private transient ReferenceQueue queue = new ReferenceQueue();\n+    private transient ReferenceQueue queue;\n \n     //-----------------------------------------------------------------------\n     /**\n         this.purgeValues = purgeValues;\n     }\n \n+    /**\n+     * Initialise this subclass during construction, cloning or deserialization.\n+     */\n+    protected void init() {\n+        queue = new ReferenceQueue();\n+    }\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Checks the type int is a valid value.\n             throw new IllegalArgumentException(name + \" must be HARD, SOFT, WEAK.\");\n         }\n     }\n-\n-    //-----------------------------------------------------------------------\n-//    /**\n-//     * Writes this object to the given output stream.\n-//     *\n-//     * @param out  the output stream to write to\n-//     * @throws IOException  if the stream raises it\n-//     */\n-//    private void writeObject(ObjectOutputStream out) throws IOException {\n-//        out.defaultWriteObject();\n-//        out.writeInt(data.length);\n-//\n-//        // Have to use null-terminated list because size might shrink\n-//        // during iteration\n-//\n-//        for (Iterator iter = entrySet().iterator(); iter.hasNext();) {\n-//            Map.Entry entry = (Map.Entry)iter.next();\n-//            out.writeObject(entry.getKey());\n-//            out.writeObject(entry.getValue());\n-//        }\n-//        out.writeObject(null);\n-//    }\n-//\n-//\n-//    /**\n-//     * Reads the contents of this object from the given input stream.\n-//     *\n-//     * @param in  the input stream to read from\n-//     * @throws IOException  if the stream raises it\n-//     * @throws ClassNotFoundException  if the stream raises it\n-//     */\n-//    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-//        in.defaultReadObject();\n-//        data = new HashEntry[in.readInt()];\n-//        threshold = calculateThreshold(data.length, loadFactor);\n-//        queue = new ReferenceQueue();\n-//        Object key = in.readObject();\n-//        while (key != null) {\n-//            Object value = in.readObject();\n-//            put(key, value);\n-//            key = in.readObject();\n-//        }\n-//    }\n \n     //-----------------------------------------------------------------------\n     /**\n     }\n \n     /**\n+     * Gets the hash code for a MapEntry.\n+     * Subclasses can override this, for example to use the identityHashCode.\n+     * \n+     * @param key  the key to get a hash code for, may be null\n+     * @param value  the value to get a hash code for, may be null\n+     * @return the hash code, as per the MapEntry specification\n+     */\n+    protected int hashEntry(Object key, Object value) {\n+        return (key == null ? 0 : key.hashCode()) ^\n+               (value == null ? 0 : value.hashCode()); \n+    }\n+    \n+    /**\n      * Compares two keys, in internal converted form, to see if they are equal.\n      * <p>\n      * This implementation converts the key from the entry to a real reference\n      * @param key1  the first key to compare passed in from outside\n      * @param key2  the second key extracted from the entry via <code>entry.key</code>\n      * @return true if equal\n-     * @since Commons Collections 3.1\n      */\n     protected boolean isEqualKey(Object key1, Object key2) {\n         key2 = (keyType > HARD ? ((Reference) key2).get() : key2);\n      * @param key  the key to store\n      * @param value  the value to store\n      * @return the newly created entry\n-     * @since Commons Collections 3.1\n      */\n     protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n         return new ReferenceEntry(this, next, hashCode, key, value);\n      * Creates an entry set iterator.\n      * \n      * @return the entrySet iterator\n-     * @since Commons Collections 3.1\n      */\n     protected Iterator createEntrySetIterator() {\n         return new ReferenceEntrySetIterator(this);\n      * Creates an key set iterator.\n      * \n      * @return the keySet iterator\n-     * @since Commons Collections 3.1\n      */\n     protected Iterator createKeySetIterator() {\n         return new ReferenceKeySetIterator(this);\n      * Creates an values iterator.\n      * \n      * @return the values iterator\n-     * @since Commons Collections 3.1\n      */\n     protected Iterator createValuesIterator() {\n         return new ReferenceValuesIterator(this);\n             super(next, hashCode, null, null);\n             this.parent = parent;\n             this.key = toReference(parent.keyType, key, hashCode);\n-            this.value = toReference(parent.valueType, value, hashCode);\n-        }\n-\n+            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately\n+        }\n+\n+        /**\n+         * Gets the key from the entry.\n+         * This method dereferences weak and soft keys and thus may return null.\n+         * \n+         * @return the key, which may be null if it was garbage collected\n+         */\n         public Object getKey() {\n             return (parent.keyType > HARD) ? ((Reference) key).get() : key;\n         }\n \n+        /**\n+         * Gets the value from the entry.\n+         * This method dereferences weak and soft value and thus may return null.\n+         * \n+         * @return the value, which may be null if it was garbage collected\n+         */\n         public Object getValue() {\n             return (parent.valueType > HARD) ? ((Reference) value).get() : value;\n         }\n \n+        /**\n+         * Sets the value of the entry.\n+         * \n+         * @param obj  the object to store\n+         * @return the previous value\n+         */\n         public Object setValue(Object obj) {\n             Object old = getValue();\n             if (parent.valueType > HARD) {\n             return old;\n         }\n \n+        /**\n+         * Compares this map entry to another.\n+         * <p>\n+         * This implementation uses <code>isEqualKey</code> and\n+         * <code>isEqualValue</code> on the main map for comparison.\n+         * \n+         * @param obj  the other map entry to compare to\n+         * @return true if equal, false if not\n+         */\n         public boolean equals(Object obj) {\n             if (obj == this) {\n                 return true;\n             }\n             \n             Map.Entry entry = (Map.Entry)obj;\n-            Object key = entry.getKey();\n-            Object value = entry.getValue();\n-            if ((key == null) || (value == null)) {\n+            Object entryKey = entry.getKey();  // convert to hard reference\n+            Object entryValue = entry.getValue();  // convert to hard reference\n+            if ((entryKey == null) || (entryValue == null)) {\n                 return false;\n             }\n-            return key.equals(getKey()) && value.equals(getValue());\n+            // compare using map methods, aiding identity subclass\n+            // note that key is direct access and value is via method\n+            return parent.isEqualKey(entryKey, key) &&\n+                   parent.isEqualValue(entryValue, getValue());\n+        }\n+\n+        /**\n+         * Gets the hashcode of the entry using temporary hard references.\n+         * <p>\n+         * This implementation uses <code>hashEntry</code> on the main map.\n+         * \n+         * @return the hashcode of the entry\n+         */\n+        public int hashCode() {\n+            return parent.hashEntry(getKey(), getValue());\n         }\n \n         /**\n          * @param hash  the hash code of the <i>key</i> of the mapping;\n          *    this number might be different from referent.hashCode() if\n          *    the referent represents a value and not a key\n-         * @since Commons Collections 3.1\n          */\n         protected Object toReference(int type, Object referent, int hash) {\n             switch (type) {\n      * A soft reference holder.\n      */\n     static class SoftRef extends SoftReference {\n+        /** the hashCode of the key (even if the reference points to a value) */\n         private int hash;\n \n         public SoftRef(int hash, Object r, ReferenceQueue q) {\n      * A weak reference holder.\n      */\n     static class WeakRef extends WeakReference {\n+        /** the hashCode of the key (even if the reference points to a value) */\n         private int hash;\n \n         public WeakRef(int hash, Object r, ReferenceQueue q) {\n         }\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the superclass method to store the state of this class.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to serialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>writeObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if they have a specific field that must be present\n+     * on read before this implementation will work. Generally, the read determines\n+     * what must be serialized here, if anything.\n+     * \n+     * @param out  the output stream\n+     */\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        out.writeInt(keyType);\n+        out.writeInt(valueType);\n+        out.writeBoolean(purgeValues);\n+        out.writeFloat(loadFactor);\n+        out.writeInt(data.length);\n+        for (MapIterator it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+            out.writeObject(it.getValue());\n+        }\n+        out.writeObject(null);  // null terminate map\n+        // do not call super.doWriteObject() as code there doesn't work for reference map\n+    }\n+\n+    /**\n+     * Replaces the superclassm method to read the state of this class.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to deserialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>readObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if the subclass has a specific field that must be present\n+     * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n+     * \n+     * @param in  the input stream\n+     */\n+    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        this.keyType = in.readInt();\n+        this.valueType = in.readInt();\n+        this.purgeValues = in.readBoolean();\n+        this.loadFactor = in.readFloat();\n+        int capacity = in.readInt();\n+        init();\n+        data = new HashEntry[capacity];\n+        while (true) {\n+            Object key = in.readObject();\n+            if (key == null) {\n+                break;\n+            }\n+            Object value = in.readObject();\n+            put(key, value);\n+        }\n+        threshold = calculateThreshold(data.length, loadFactor);\n+        // do not call super.doReadObject() as code there doesn't work for reference map\n+    }\n \n }", "timestamp": 1083101572, "metainfo": ""}