{"sha": "7d9196da0ef3889ca60a5dd90e9b9eea77bdb01b", "log": "Remove trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n \n     /**\n      * Gets the bag being decorated.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     @Override\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public int getCount(final Object object) {\n         return decorated().getCount(object);\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java\n     /**\n      * Constructor that assigns the specified Map as the backing store. The map\n      * must be empty and non-null.\n-     * \n+     *\n      * @param map the map to assign\n      */\n     protected AbstractMapBag(final Map<E, MutableInteger> map) {\n     /**\n      * Utility method for implementations to access the map that backs this bag.\n      * Not intended for interactive use outside of subclasses.\n-     * \n+     *\n      * @return the map being used by the Bag\n      */\n     protected Map<E, MutableInteger> getMap() {\n     //-----------------------------------------------------------------------\n     /**\n      * Returns the number of elements in this bag.\n-     * \n+     *\n      * @return current size of the bag\n      */\n     public int size() {\n \n     /**\n      * Returns true if the underlying map is empty.\n-     * \n+     *\n      * @return true if bag is empty\n      */\n     public boolean isEmpty() {\n     /**\n      * Returns the number of occurrence of the given element in this bag by\n      * looking up its count in the underlying map.\n-     * \n+     *\n      * @param object the object to search for\n      * @return the number of occurrences of the object, zero if not found\n      */\n     /**\n      * Determines if the bag contains the given element by checking if the\n      * underlying map contains the element as a key.\n-     * \n+     *\n      * @param object the object to search for\n      * @return true if the bag contains the given element\n      */\n \n     /**\n      * Determines if the bag contains the given elements.\n-     * \n+     *\n      * @param coll the collection to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n     /**\n      * Returns <code>true</code> if the bag contains all elements in the given\n      * collection, respecting cardinality.\n-     * \n+     *\n      * @param other the bag to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      */\n     /**\n      * Gets an iterator over the bag elements. Elements present in the Bag more\n      * than once will be returned repeatedly.\n-     * \n+     *\n      * @return the iterator\n      */\n     public Iterator<E> iterator() {\n \n         /**\n          * Constructor.\n-         * \n+         *\n          * @param parent the parent bag\n          */\n         public BagIterator(final AbstractMapBag<E> parent) {\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Adds a new element to the bag, incrementing its count in the underlying\n-     * map.\n-     * \n+     * Adds a new element to the bag, incrementing its count in the underlying map.\n+     *\n      * @param object the object to add\n-     * @return <code>true</code> if the object was not already in the\n-     * <code>uniqueSet</code>\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n      */\n     public boolean add(final E object) {\n         return add(object, 1);\n \n     /**\n      * Adds a new element to the bag, incrementing its count in the map.\n-     * \n+     *\n      * @param object the object to search for\n      * @param nCopies the number of copies to add\n-     * @return <code>true</code> if the object was not already in the\n-     * <code>uniqueSet</code>\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n      */\n     public boolean add(final E object, final int nCopies) {\n         modCount++;\n \n     /**\n      * Invokes {@link #add(Object)} for each element in the given collection.\n-     * \n+     *\n      * @param coll the collection to add\n      * @return <code>true</code> if this call changed the bag\n      */\n \n     /**\n      * Removes all copies of the specified object from the bag.\n-     * \n+     *\n      * @param object the object to remove\n      * @return true if the bag changed\n      */\n \n     /**\n      * Removes a specified number of copies of an object from the bag.\n-     * \n+     *\n      * @param object the object to remove\n      * @param nCopies the number of copies to remove\n      * @return true if the bag changed\n     /**\n      * Removes objects from the bag according to their count in the specified\n      * collection.\n-     * \n+     *\n      * @param coll the collection to use\n      * @return true if the bag changed\n      */\n     /**\n      * Remove any members of the bag that are not in the given bag, respecting\n      * cardinality.\n-     * \n+     *\n      * @param coll the collection to retain\n      * @return true if this call changed the collection\n      */\n      * Remove any members of the bag that are not in the given bag, respecting\n      * cardinality.\n      * @see #retainAll(Collection)\n-     * \n+     *\n      * @param other the bag to retain\n      * @return <code>true</code> if this call changed the collection\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Returns an array of all of this bag's elements.\n-     * \n+     *\n      * @return an array of all of this bag's elements\n      */\n     public Object[] toArray() {\n      * Returns an array of all of this bag's elements.\n      * If the input array has more elements than are in the bag,\n      * trailing elements will be set to null.\n-     * \n+     *\n      * @param <T> the type of the array elements\n      * @param array the array to populate\n      * @return an array of all of this bag's elements\n             final E current = it.next();\n             for (int index = getCount(current); index > 0; index--) {\n                 // unsafe, will throw ArrayStoreException if types are not compatible, see javadoc\n-                @SuppressWarnings(\"unchecked\") \n+                @SuppressWarnings(\"unchecked\")\n                 final T unchecked = (T) current;\n                 array[i++] = unchecked;\n             }\n \n     /**\n      * Returns an unmodifiable view of the underlying map's key set.\n-     * \n+     *\n      * @return the set of unique elements in this bag\n      */\n     public Set<E> uniqueSet() {\n     /**\n      * Compares this Bag to another. This Bag equals another Bag if it contains\n      * the same number of occurrences of the same elements.\n-     * \n+     *\n      * @param object the Bag to compare to\n      * @return true if equal\n      */\n      * element. The per element hash code is defined as\n      * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>. This hash code\n      * is compatible with the Set interface.\n-     * \n+     *\n      * @return the hash code of the Bag\n      */\n     @Override\n \n     /**\n      * Implement a toString() method suitable for debugging.\n-     * \n+     *\n      * @return a debugging toString\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if list is null\n      */\n \n     /**\n      * Gets the bag being decorated.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     @Override\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public E first() {\n         return decorated().first();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/HashBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/HashBag.java\n \n     /** Serial version lock */\n     private static final long serialVersionUID = -6561115435802554013L;\n-    \n+\n     /**\n      * Constructs an empty {@link HashBag}.\n      */\n \n     /**\n      * Constructs a bag containing all the members of the given collection.\n-     * \n+     *\n      * @param coll  a collection to copy into this bag\n      */\n     public HashBag(final Collection<? extends E> coll) {\n         in.defaultReadObject();\n         super.doReadObject(new HashMap<E, MutableInteger>(), in);\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @throws IllegalArgumentException if bag or predicate is null\n \n     /**\n      * Gets the decorated bag.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     @Override\n     protected Bag<E> decorated() {\n         return (Bag<E>) super.decorated();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n-    \n+\n     public boolean add(final E object, final int count) {\n         validate(object);\n         return decorated().add(object, count);\n--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * Constructor that wraps (not copies).\n      * <p>If there are any elements already in the bag being decorated, they\n      * are validated.\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @throws IllegalArgumentException if bag or predicate is null\n \n     /**\n      * Gets the decorated sorted bag.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     @Override\n     protected SortedBag<E> decorated() {\n         return (SortedBag<E>) super.decorated();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n-    \n+\n     public E first() {\n         return decorated().first();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n \n     /**\n      * Factory method to create a synchronized bag.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return a new synchronized Bag\n     public static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n         return new SynchronizedBag<E>(bag);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @param lock  the lock to use, must not be null\n      * @throws IllegalArgumentException if bag is null\n \n     /**\n      * Gets the bag being decorated.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     protected Bag<E> getBag() {\n         return (Bag<E>) decorated();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n-    \n+\n     public boolean add(final E object, final int count) {\n         synchronized (lock) {\n             return getBag().add(object, count);\n             return getBag().getCount(object);\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Synchronized Set for the Bag class.\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n \n     /**\n      * Factory method to create a synchronized sorted bag.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return a new synchronized SortedBag\n     public static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n         return new SynchronizedSortedBag<E>(bag);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n \n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @param lock  the lock to use, must not be null\n      * @throws IllegalArgumentException if bag is null\n \n     /**\n      * Gets the bag being decorated.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     protected SortedBag<E> getSortedBag() {\n         return (SortedBag<E>) decorated();\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n-    \n+\n     public synchronized E first() {\n         synchronized (lock) {\n             return getSortedBag().first();\n--- a/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n     public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedBag<E>(bag, transformer);\n     }\n-    \n+\n     /**\n      * Factory method to create a transforming bag that will transform\n      * existing contents of the specified bag.\n      * If there are any elements already in the bag being decorated, they\n      * will be transformed by this method.\n      * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are NOT transformed.\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n \n     /**\n      * Gets the decorated bag.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     protected Bag<E> getBag() {\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public int getCount(final Object object) {\n         return getBag().getCount(object);\n     }\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public boolean add(final E object, final int nCopies) {\n         return getBag().add(transform(object), nCopies);\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n             final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSortedBag<E>(bag, transformer);\n     }\n-    \n+\n     /**\n      * Factory method to create a transforming sorted bag that will transform\n      * existing contents of the specified sorted bag.\n      * If there are any elements already in the bag being decorated, they\n      * will be transformed by this method.\n      * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * <p>\n      * If there are any elements already in the bag being decorated, they\n      * are NOT transformed.\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @throws IllegalArgumentException if bag or transformer is null\n \n     /**\n      * Gets the decorated bag.\n-     * \n+     *\n      * @return the decorated bag\n      */\n     protected SortedBag<E> getSortedBag() {\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public E first() {\n         return getSortedBag().first();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/TreeBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TreeBag.java\n     /**\n      * Constructs an empty bag that maintains order on its unique representative\n      * members according to the given {@link Comparator}.\n-     * \n+     *\n      * @param comparator the comparator to use\n      */\n     public TreeBag(final Comparator<? super E> comparator) {\n     /**\n      * Constructs a {@link TreeBag} containing all the members of the\n      * specified collection.\n-     * \n+     *\n      * @param coll the collection to copy into the bag\n      */\n     public TreeBag(final Collection<? extends E> coll) {\n     //-----------------------------------------------------------------------\n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * @throws IllegalArgumentException if the object to be added does not implement\n      * {@link Comparable} and the {@link TreeBag} is using natural ordering\n      */\n     @Override\n     public boolean add(final E object) {\n         if(comparator() == null && !(object instanceof Comparable)) {\n-            throw new IllegalArgumentException(\"Objects of type \" + object.getClass() + \" cannot be added to \" + \n+            throw new IllegalArgumentException(\"Objects of type \" + object.getClass() + \" cannot be added to \" +\n                                                \"a naturally ordered TreeBag as it does not implement Comparable\");\n         }\n         return super.add(object);\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public E first() {\n         return getMap().firstKey();\n     }\n--- a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an UnsupportedOperationException.\n  *\n  * @since 3.0\n  * @version $Id$\n      * Factory method to create an unmodifiable bag.\n      * <p>\n      * If the bag passed in is already unmodifiable, it is returned.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return an unmodifiable Bag\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Write the collection out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      */\n \n     /**\n      * Read the collection in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n--- a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an UnsupportedOperationException.\n  *\n  * @since 3.0\n  * @version $Id$\n      * Factory method to create an unmodifiable bag.\n      * <p>\n      * If the bag passed in is already unmodifiable, it is returned.\n-     * \n+     *\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return an unmodifiable SortedBag\n     //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param bag  the bag to decorate, must not be null\n      * @throws IllegalArgumentException if bag is null\n      */\n     //-----------------------------------------------------------------------\n     /**\n      * Write the collection out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      */\n \n     /**\n      * Read the collection in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n--- a/src/main/java/org/apache/commons/collections4/bag/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/package-info.java\n  * limitations under the License.\n  */\n /**\n- * This package contains implementations of the {@link org.apache.commons.collections4.Bag Bag} and \n+ * This package contains implementations of the {@link org.apache.commons.collections4.Bag Bag} and\n  * {@link org.apache.commons.collections4.SortedBag SortedBag} interfaces.\n  * A bag stores an object and a count of the number of occurrences of the object.\n  * <p>", "timestamp": 1367346112, "metainfo": ""}