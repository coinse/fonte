{"sha": "5f7c041ae08986d535106c4faa891ea7446d3317", "log": "Unify the variable names across implementations   ", "commit": "\n--- a/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java,v 1.5 2003/12/14 12:59:38 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java,v 1.6 2003/12/29 00:38:08 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <code>createMap</code> method.\n  * \n  * @since Commons Collections 3.0\n- * @version $Id: AbstractDualBidiMap.java,v 1.5 2003/12/14 12:59:38 scolebourne Exp $\n+ * @version $Id: AbstractDualBidiMap.java,v 1.6 2003/12/29 00:38:08 scolebourne Exp $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n      */\n     protected static abstract class View extends AbstractCollectionDecorator {\n         \n-        protected final AbstractDualBidiMap map;\n-        \n-        protected View(Collection coll, AbstractDualBidiMap map) {\n+        /** The parent map */\n+        protected final AbstractDualBidiMap parent;\n+        \n+        protected View(Collection coll, AbstractDualBidiMap parent) {\n             super(coll);\n-            this.map = map;\n+            this.parent = parent;\n         }\n \n         public boolean removeAll(Collection coll) {\n-            if (map.isEmpty() || coll.isEmpty()) {\n+            if (parent.isEmpty() || coll.isEmpty()) {\n                 return false;\n             }\n             boolean modified = false;\n         }\n \n         public boolean retainAll(Collection coll) {\n-            if (map.isEmpty()) {\n+            if (parent.isEmpty()) {\n                 return false;\n             }\n             if (coll.isEmpty()) {\n-                map.clear();\n+                parent.clear();\n                 return true;\n             }\n             boolean modified = false;\n         }\n         \n         public void clear() {\n-            map.clear();\n+            parent.clear();\n         }\n     }\n     \n      */\n     protected static class KeySet extends View implements Set {\n         \n-        protected KeySet(AbstractDualBidiMap map) {\n-            super(map.maps[0].keySet(), map);\n+        protected KeySet(AbstractDualBidiMap parent) {\n+            super(parent.maps[0].keySet(), parent);\n         }\n \n         public Iterator iterator() {\n-            return new KeySetIterator(super.iterator(), map);\n+            return new KeySetIterator(super.iterator(), parent);\n         }\n         \n         public boolean contains(Object key) {\n-            return map.maps[0].containsKey(key);\n+            return parent.maps[0].containsKey(key);\n         }\n \n         public boolean remove(Object key) {\n-            if (map.maps[0].containsKey(key)) {\n-                Object value = map.maps[0].remove(key);\n-                map.maps[1].remove(value);\n+            if (parent.maps[0].containsKey(key)) {\n+                Object value = parent.maps[0].remove(key);\n+                parent.maps[1].remove(value);\n                 return true;\n             }\n             return false;\n      */\n     protected static class KeySetIterator extends AbstractIteratorDecorator {\n         \n-        private final AbstractDualBidiMap map;\n-        private Object lastKey = null;\n-        private boolean canRemove = false;\n-        \n-        protected KeySetIterator(Iterator iterator, AbstractDualBidiMap map) {\n+        /** The parent map */\n+        protected final AbstractDualBidiMap parent;\n+        /** The last returned key */\n+        protected Object lastKey = null;\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+        \n+        protected KeySetIterator(Iterator iterator, AbstractDualBidiMap parent) {\n             super(iterator);\n-            this.map = map;\n+            this.parent = parent;\n         }\n         \n         public Object next() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n-            Object value = map.maps[0].get(lastKey);\n+            Object value = parent.maps[0].get(lastKey);\n             super.remove();\n-            map.maps[1].remove(value);\n+            parent.maps[1].remove(value);\n             lastKey = null;\n             canRemove = false;\n         }\n      */\n     protected static class Values extends View implements Set {\n         \n-        protected Values(AbstractDualBidiMap map) {\n-            super(map.maps[0].values(), map);\n+        protected Values(AbstractDualBidiMap parent) {\n+            super(parent.maps[0].values(), parent);\n         }\n \n         public Iterator iterator() {\n-            return new ValuesIterator(super.iterator(), map);\n+            return new ValuesIterator(super.iterator(), parent);\n         }\n         \n         public boolean contains(Object value) {\n-            return map.maps[1].containsKey(value);\n+            return parent.maps[1].containsKey(value);\n         }\n \n         public boolean remove(Object value) {\n-            if (map.maps[1].containsKey(value)) {\n-                Object key = map.maps[1].remove(value);\n-                map.maps[0].remove(key);\n+            if (parent.maps[1].containsKey(value)) {\n+                Object key = parent.maps[1].remove(value);\n+                parent.maps[0].remove(key);\n                 return true;\n             }\n             return false;\n      */\n     protected static class ValuesIterator extends AbstractIteratorDecorator {\n         \n-        private final AbstractDualBidiMap map;\n-        private Object lastValue = null;\n-        private boolean canRemove = false;\n-        \n-        protected ValuesIterator(Iterator iterator, AbstractDualBidiMap map) {\n+        /** The parent map */\n+        protected final AbstractDualBidiMap parent;\n+        /** The last returned value */\n+        protected Object lastValue = null;\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+        \n+        protected ValuesIterator(Iterator iterator, AbstractDualBidiMap parent) {\n             super(iterator);\n-            this.map = map;\n+            this.parent = parent;\n         }\n         \n         public Object next() {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n             super.remove(); // removes from maps[0]\n-            map.maps[1].remove(lastValue);\n+            parent.maps[1].remove(lastValue);\n             lastValue = null;\n             canRemove = false;\n         }\n      */\n     protected static class EntrySet extends View implements Set {\n         \n-        protected EntrySet(AbstractDualBidiMap map) {\n-            super(map.maps[0].entrySet(), map);\n+        protected EntrySet(AbstractDualBidiMap parent) {\n+            super(parent.maps[0].entrySet(), parent);\n         }\n \n         public Iterator iterator() {\n-            return new EntrySetIterator(super.iterator(), map);\n+            return new EntrySetIterator(super.iterator(), parent);\n         }\n         \n         public boolean remove(Object obj) {\n                 return false;\n             }\n             Map.Entry entry = (Map.Entry) obj;\n-            if (map.containsKey(entry.getKey())) {\n-                Object value = map.maps[0].remove(entry.getKey());\n-                map.maps[1].remove(value);\n+            if (parent.containsKey(entry.getKey())) {\n+                Object value = parent.maps[0].remove(entry.getKey());\n+                parent.maps[1].remove(value);\n                 return true;\n             }\n             return false;\n      */\n     protected static class EntrySetIterator extends AbstractIteratorDecorator {\n         \n-        private final AbstractDualBidiMap map;\n-        private Map.Entry last = null;\n-        private boolean canRemove = false;\n-        \n-        protected EntrySetIterator(Iterator iterator, AbstractDualBidiMap map) {\n+        /** The parent map */\n+        protected final AbstractDualBidiMap parent;\n+        /** The last returned entry */\n+        protected Map.Entry last = null;\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+        \n+        protected EntrySetIterator(Iterator iterator, AbstractDualBidiMap parent) {\n             super(iterator);\n-            this.map = map;\n+            this.parent = parent;\n         }\n         \n         public Object next() {\n-            last = new MapEntry((Map.Entry) super.next(), map);\n+            last = new MapEntry((Map.Entry) super.next(), parent);\n             canRemove = true;\n             return last;\n         }\n             // store value as remove may change the entry in the decorator (eg.TreeMap)\n             Object value = last.getValue();\n             super.remove();\n-            map.maps[1].remove(value);\n+            parent.maps[1].remove(value);\n             last = null;\n             canRemove = false;\n         }\n      * Inner class MapEntry.\n      */\n     protected static class MapEntry extends AbstractMapEntryDecorator {\n-        \n-        protected final AbstractDualBidiMap map;\n-        \n-        protected MapEntry(Map.Entry entry, AbstractDualBidiMap map) {\n+\n+        /** The parent map */        \n+        protected final AbstractDualBidiMap parent;\n+        \n+        protected MapEntry(Map.Entry entry, AbstractDualBidiMap parent) {\n             super(entry);\n-            this.map = map;\n+            this.parent = parent;\n         }\n         \n         public Object setValue(Object value) {\n             Object key = MapEntry.this.getKey();\n-            if (map.maps[1].containsKey(value) &&\n-                map.maps[1].get(value) != key) {\n+            if (parent.maps[1].containsKey(value) &&\n+                parent.maps[1].get(value) != key) {\n                 throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n             }\n-            map.put(key, value);\n+            parent.put(key, value);\n             final Object oldValue = super.setValue(value);\n             return oldValue;\n         }\n      */\n     protected static class BidiMapIterator implements MapIterator, ResettableIterator {\n         \n-        protected final AbstractDualBidiMap map;\n+        /** The parent map */\n+        protected final AbstractDualBidiMap parent;\n+        /** The iterator being wrapped */\n         protected Iterator iterator;\n-        private Map.Entry last = null;\n-        private boolean canRemove = false;\n-        \n-        protected BidiMapIterator(AbstractDualBidiMap map) {\n+        /** The last returned entry */\n+        protected Map.Entry last = null;\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+        \n+        protected BidiMapIterator(AbstractDualBidiMap parent) {\n             super();\n-            this.map = map;\n-            this.iterator = map.maps[0].entrySet().iterator();\n+            this.parent = parent;\n+            this.iterator = parent.maps[0].entrySet().iterator();\n         }\n         \n         public boolean hasNext() {\n             // store value as remove may change the entry in the decorator (eg.TreeMap)\n             Object value = last.getValue();\n             iterator.remove();\n-            map.maps[1].remove(value);\n+            parent.maps[1].remove(value);\n             last = null;\n             canRemove = false;\n         }\n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n             }\n-            if (map.maps[1].containsKey(value) &&\n-                map.maps[1].get(value) != last.getKey()) {\n+            if (parent.maps[1].containsKey(value) &&\n+                parent.maps[1].get(value) != last.getKey()) {\n                 throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n             }\n-            return map.put(last.getKey(), value);\n+            return parent.put(last.getKey(), value);\n         }\n         \n         public void reset() {\n-            iterator = map.maps[0].entrySet().iterator();\n+            iterator = parent.maps[0].entrySet().iterator();\n             last = null;\n             canRemove = false;\n         }\n--- a/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n+++ b/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java,v 1.6 2003/12/25 00:33:04 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java,v 1.7 2003/12/29 00:38:08 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * not store each object twice, which can save on memory use.\n  * \n  * @since Commons Collections 3.0\n- * @version $Id: DualTreeBidiMap.java,v 1.6 2003/12/25 00:33:04 scolebourne Exp $\n+ * @version $Id: DualTreeBidiMap.java,v 1.7 2003/12/29 00:38:08 scolebourne Exp $\n  * \n  * @author Matthew Hawthorne\n  * @author Stephen Colebourne\n      */\n     protected static class BidiOrderedMapIterator implements OrderedMapIterator, ResettableIterator {\n         \n-        protected final AbstractDualBidiMap map;\n+        /** The parent map */\n+        protected final AbstractDualBidiMap parent;\n+        /** The iterator being decorated */\n         protected ListIterator iterator;\n+        /** The last returned entry */\n         private Map.Entry last = null;\n         \n-        protected BidiOrderedMapIterator(AbstractDualBidiMap map) {\n+        protected BidiOrderedMapIterator(AbstractDualBidiMap parent) {\n             super();\n-            this.map = map;\n-            iterator = new ArrayList(map.entrySet()).listIterator();\n+            this.parent = parent;\n+            iterator = new ArrayList(parent.entrySet()).listIterator();\n         }\n         \n         public boolean hasNext() {\n         \n         public void remove() {\n             iterator.remove();\n-            map.remove(last.getKey());\n+            parent.remove(last.getKey());\n             last = null;\n         }\n         \n             if (last == null) {\n                 throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n             }\n-            if (map.maps[1].containsKey(value) &&\n-                map.maps[1].get(value) != last.getKey()) {\n+            if (parent.maps[1].containsKey(value) &&\n+                parent.maps[1].get(value) != last.getKey()) {\n                 throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n             }\n-            return map.put(last.getKey(), value);\n+            return parent.put(last.getKey(), value);\n         }\n         \n         public void reset() {\n-            iterator = new ArrayList(map.entrySet()).listIterator();\n+            iterator = new ArrayList(parent.entrySet()).listIterator();\n             last = null;\n         }\n         \n--- a/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/AbstractLinkedList.java,v 1.3 2003/12/28 17:58:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/AbstractLinkedList.java,v 1.4 2003/12/29 00:38:08 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * is here.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/12/28 17:58:54 $\n+ * @version $Revision: 1.4 $ $Date: 2003/12/29 00:38:08 $\n  *\n  * @author Rich Dougherty\n  * @author Phil Steitz\n     protected static class LinkedListIterator implements ListIterator, OrderedIterator {\n         \n         /** The parent list */\n-        protected final AbstractLinkedList list;\n+        protected final AbstractLinkedList parent;\n \n         /**\n          * The node that will be returned by {@link #next()}. If this is equal\n          * @param parent  the parent list\n          * @param fromIndex  the index to start at\n          */\n-        public LinkedListIterator(AbstractLinkedList parent, int fromIndex) throws IndexOutOfBoundsException {\n+        protected LinkedListIterator(AbstractLinkedList parent, int fromIndex) throws IndexOutOfBoundsException {\n             super();\n-            this.list = parent;\n-            this.expectedModCount = list.modCount;\n-            this.next = list.getNode(fromIndex, true);\n+            this.parent = parent;\n+            this.expectedModCount = parent.modCount;\n+            this.next = parent.getNode(fromIndex, true);\n             this.nextIndex = fromIndex;\n         }\n \n          * count isn't the value that was expected.\n          */\n         protected void checkModCount() {\n-            if (list.modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n         }\n         }\n \n         public boolean hasNext() {\n-            return next != list.header;\n+            return next != parent.header;\n         }\n \n         public Object next() {\n         }\n \n         public boolean hasPrevious() {\n-            return next.previous != list.header;\n+            return next.previous != parent.header;\n         }\n \n         public Object previous() {\n \n         public void remove() {\n             checkModCount();\n-            list.removeNode(getLastNodeReturned());\n+            parent.removeNode(getLastNodeReturned());\n             current = null;\n             nextIndex--;\n             expectedModCount++;\n \n         public void add(Object obj) {\n             checkModCount();\n-            list.addNodeBefore(next, obj);\n+            parent.addNodeBefore(next, obj);\n             current = null;\n             nextIndex++;\n             expectedModCount++;\n         protected final LinkedSubList sub;\n         \n         protected LinkedSubListIterator(LinkedSubList sub, int startIndex) {\n-            super(sub.list, startIndex + sub.offset);\n+            super(sub.parent, startIndex + sub.offset);\n             this.sub = sub;\n         }\n \n \n         public void add(Object obj) {\n             super.add(obj);\n-            sub.expectedModCount = list.modCount;\n+            sub.expectedModCount = parent.modCount;\n             sub.size++;\n         }\n         \n         public void remove() {\n             super.remove();\n-            sub.expectedModCount = list.modCount;\n+            sub.expectedModCount = parent.modCount;\n             sub.size--;\n         }\n     }\n      */\n     protected static class LinkedSubList extends AbstractList {\n         /** The main list */\n-        private AbstractLinkedList list;\n+        private AbstractLinkedList parent;\n         /** Offset from the main list */\n         private int offset;\n         /** Sublist size */\n         /** Sublist modCount */\n         private int expectedModCount;\n \n-        protected LinkedSubList(AbstractLinkedList list, int fromIndex, int toIndex) {\n+        protected LinkedSubList(AbstractLinkedList parent, int fromIndex, int toIndex) {\n             if (fromIndex < 0) {\n                 throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n             }\n-            if (toIndex > list.size()) {\n+            if (toIndex > parent.size()) {\n                 throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n             }\n             if (fromIndex > toIndex) {\n                 throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n             }\n-            this.list = list;\n+            this.parent = parent;\n             this.offset = fromIndex;\n             this.size = toIndex - fromIndex;\n-            this.expectedModCount = list.modCount;\n+            this.expectedModCount = parent.modCount;\n         }\n \n         public int size() {\n         public Object get(int index) {\n             rangeCheck(index, size);\n             checkModCount();\n-            return list.get(index + offset);\n+            return parent.get(index + offset);\n         }\n \n         public void add(int index, Object obj) {\n             rangeCheck(index, size + 1);\n             checkModCount();\n-            list.add(index + offset, obj);\n-            expectedModCount = list.modCount;\n+            parent.add(index + offset, obj);\n+            expectedModCount = parent.modCount;\n             size++;\n             LinkedSubList.this.modCount++;\n         }\n         public Object remove(int index) {\n             rangeCheck(index, size);\n             checkModCount();\n-            Object result = list.remove(index + offset);\n-            expectedModCount = list.modCount;\n+            Object result = parent.remove(index + offset);\n+            expectedModCount = parent.modCount;\n             size--;\n             LinkedSubList.this.modCount++;\n             return result;\n             }\n \n             checkModCount();\n-            list.addAll(offset + index, coll);\n-            expectedModCount = list.modCount;\n+            parent.addAll(offset + index, coll);\n+            expectedModCount = parent.modCount;\n             size += cSize;\n             LinkedSubList.this.modCount++;\n             return true;\n         public Object set(int index, Object obj) {\n             rangeCheck(index, size);\n             checkModCount();\n-            return list.set(index + offset, obj);\n+            return parent.set(index + offset, obj);\n         }\n \n         public void clear() {\n \n         public Iterator iterator() {\n             checkModCount();\n-            return list.createSubListIterator(this);\n+            return parent.createSubListIterator(this);\n         }\n \n         public ListIterator listIterator(final int index) {\n             rangeCheck(index, size + 1);\n             checkModCount();\n-            return list.createSubListListIterator(this, index);\n+            return parent.createSubListListIterator(this, index);\n         }\n \n         public List subList(int fromIndexInclusive, int toIndexExclusive) {\n-            return new LinkedSubList(list, fromIndexInclusive + offset, toIndexExclusive + offset);\n+            return new LinkedSubList(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n         }\n \n         protected void rangeCheck(int index, int beyond) {\n         }\n \n         protected void checkModCount() {\n-            if (list.modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n         }\n--- a/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/CursorableLinkedList.java,v 1.1 2003/12/24 01:15:40 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/CursorableLinkedList.java,v 1.2 2003/12/29 00:38:08 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n  * @see java.util.LinkedList\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.1 $ $Date: 2003/12/24 01:15:40 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/29 00:38:08 $\n  * \n  * @author Rodney Waldhoff\n  * @author Janek Bogucki\n          */\n         public int nextIndex() {\n             if (nextIndexValid == false) {\n-                if (next == list.header) {\n-                    nextIndex = list.size();\n+                if (next == parent.header) {\n+                    nextIndex = parent.size();\n                 } else {\n                     int pos = 0;\n-                    Node temp = list.header.next;\n+                    Node temp = parent.header.next;\n                     while (temp != next) {\n                         pos++;\n                         temp = temp.next;\n          */\n         public void close() {\n             if (valid) {\n-                ((CursorableLinkedList) list).unregisterCursor(this);\n+                ((CursorableLinkedList) parent).unregisterCursor(this);\n                 valid = false;\n             }\n         }\n     }\n }\n-\n-//class CursorableSubList extends CursorableLinkedList implements List {\n-//\n-//    //--- constructors -----------------------------------------------\n-//\n-//    CursorableSubList(CursorableLinkedList list, int from, int to) {\n-//        if(0 > from || list.size() < to) {\n-//            throw new IndexOutOfBoundsException();\n-//        } else if(from > to) {\n-//            throw new IllegalArgumentException();\n-//        }\n-//        _list = list;\n-//        if(from < list.size()) {\n-//            _head.setNext(_list.getListableAt(from));\n-//            _pre = (null == _head.next()) ? null : _head.next().prev();\n-//        } else {\n-//            _pre = _list.getListableAt(from-1);\n-//        }\n-//        if(from == to) {\n-//            _head.setNext(null);\n-//            _head.setPrev(null);\n-//            if(to < list.size()) {\n-//                _post = _list.getListableAt(to);\n-//            } else {\n-//                _post = null;\n-//            }\n-//        } else {\n-//            _head.setPrev(_list.getListableAt(to-1));\n-//            _post = _head.prev().next();\n-//        }\n-//        _size = to - from;\n-//        _modCount = _list._modCount;\n-//    }\n-//\n-//    //--- public methods ------------------------------------------\n-//\n-//    public void clear() {\n-//        checkForComod();\n-//        Iterator it = iterator();\n-//        while(it.hasNext()) {\n-//            it.next();\n-//            it.remove();\n-//        }\n-//    }\n-//\n-//    public Iterator iterator() {\n-//        checkForComod();\n-//        return super.iterator();\n-//    }\n-//\n-//    public int size() {\n-//        checkForComod();\n-//        return super.size();\n-//    }\n-//\n-//    public boolean isEmpty() {\n-//        checkForComod();\n-//        return super.isEmpty();\n-//    }\n-//\n-//    public Object[] toArray() {\n-//        checkForComod();\n-//        return super.toArray();\n-//    }\n-//\n-//    public Object[] toArray(Object a[]) {\n-//        checkForComod();\n-//        return super.toArray(a);\n-//    }\n-//\n-//    public boolean contains(Object o) {\n-//        checkForComod();\n-//        return super.contains(o);\n-//    }\n-//\n-//    public boolean remove(Object o) {\n-//        checkForComod();\n-//        return super.remove(o);\n-//    }\n-//\n-//    public Object removeFirst() {\n-//        checkForComod();\n-//        return super.removeFirst();\n-//    }\n-//\n-//    public Object removeLast() {\n-//        checkForComod();\n-//        return super.removeLast();\n-//    }\n-//\n-//    public boolean addAll(Collection c) {\n-//        checkForComod();\n-//        return super.addAll(c);\n-//    }\n-//\n-//    public boolean add(Object o) {\n-//        checkForComod();\n-//        return super.add(o);\n-//    }\n-//\n-//    public boolean addFirst(Object o) {\n-//        checkForComod();\n-//        return super.addFirst(o);\n-//    }\n-//\n-//    public boolean addLast(Object o) {\n-//        checkForComod();\n-//        return super.addLast(o);\n-//    }\n-//\n-//    public boolean removeAll(Collection c) {\n-//        checkForComod();\n-//        return super.removeAll(c);\n-//    }\n-//\n-//    public boolean containsAll(Collection c) {\n-//        checkForComod();\n-//        return super.containsAll(c);\n-//    }\n-//\n-//    public boolean addAll(int index, Collection c) {\n-//        checkForComod();\n-//        return super.addAll(index,c);\n-//    }\n-//\n-//    public int hashCode() {\n-//        checkForComod();\n-//        return super.hashCode();\n-//    }\n-//\n-//    public boolean retainAll(Collection c) {\n-//        checkForComod();\n-//        return super.retainAll(c);\n-//    }\n-//\n-//    public Object set(int index, Object element) {\n-//        checkForComod();\n-//        return super.set(index,element);\n-//    }\n-//\n-//    public boolean equals(Object o) {\n-//        checkForComod();\n-//        return super.equals(o);\n-//    }\n-//\n-//    public Object get(int index) {\n-//        checkForComod();\n-//        return super.get(index);\n-//    }\n-//\n-//    public Object getFirst() {\n-//        checkForComod();\n-//        return super.getFirst();\n-//    }\n-//\n-//    public Object getLast() {\n-//        checkForComod();\n-//        return super.getLast();\n-//    }\n-//\n-//    public void add(int index, Object element) {\n-//        checkForComod();\n-//        super.add(index,element);\n-//    }\n-//\n-//    public ListIterator listIterator(int index) {\n-//        checkForComod();\n-//        return super.listIterator(index);\n-//    }\n-//\n-//    public Object remove(int index) {\n-//        checkForComod();\n-//        return super.remove(index);\n-//    }\n-//\n-//    public int indexOf(Object o) {\n-//        checkForComod();\n-//        return super.indexOf(o);\n-//    }\n-//\n-//    public int lastIndexOf(Object o) {\n-//        checkForComod();\n-//        return super.lastIndexOf(o);\n-//    }\n-//\n-//    public ListIterator listIterator() {\n-//        checkForComod();\n-//        return super.listIterator();\n-//    }\n-//\n-//    public List subList(int fromIndex, int toIndex) {\n-//        checkForComod();\n-//        return super.subList(fromIndex,toIndex);\n-//    }\n-//\n-//    //--- protected methods ------------------------------------------\n-//\n-//    /**\n-//     * Inserts a new <i>value</i> into my\n-//     * list, after the specified <i>before</i> element, and before the\n-//     * specified <i>after</i> element\n-//     *\n-//     * @return the newly created {@link CursorableLinkedList.Listable}\n-//     */\n-//    protected Listable insertListable(Listable before, Listable after, Object value) {\n-//        _modCount++;\n-//        _size++;\n-//        Listable elt = _list.insertListable((null == before ? _pre : before), (null == after ? _post : after),value);\n-//        if(null == _head.next()) {\n-//            _head.setNext(elt);\n-//            _head.setPrev(elt);\n-//        }\n-//        if(before == _head.prev()) {\n-//            _head.setPrev(elt);\n-//        }\n-//        if(after == _head.next()) {\n-//            _head.setNext(elt);\n-//        }\n-//        broadcastListableInserted(elt);\n-//        return elt;\n-//    }\n-//\n-//    /**\n-//     * Removes the given {@link CursorableLinkedList.Listable} from my list.\n-//     */\n-//    protected void removeListable(Listable elt) {\n-//        _modCount++;\n-//        _size--;\n-//        if(_head.next() == elt && _head.prev() == elt) {\n-//            _head.setNext(null);\n-//            _head.setPrev(null);\n-//        }\n-//        if(_head.next() == elt) {\n-//            _head.setNext(elt.next());\n-//        }\n-//        if(_head.prev() == elt) {\n-//            _head.setPrev(elt.prev());\n-//        }\n-//        _list.removeListable(elt);\n-//        broadcastListableRemoved(elt);\n-//    }\n-//\n-//    /**\n-//     * Test to see if my underlying list has been modified\n-//     * by some other process.  If it has, throws a\n-//     * {@link ConcurrentModificationException}, otherwise\n-//     * quietly returns.\n-//     *\n-//     * @throws ConcurrentModificationException\n-//     */\n-//    protected void checkForComod() throws ConcurrentModificationException {\n-//        if(_modCount != _list._modCount) {\n-//            throw new ConcurrentModificationException();\n-//        }\n-//    }\n-//\n-//    //--- protected attributes ---------------------------------------\n-//\n-//    /** My underlying list */\n-//    protected CursorableLinkedList _list = null;\n-//\n-//    /** The element in my underlying list preceding the first element in my list. */\n-//    protected Listable _pre = null;\n-//\n-//    /** The element in my underlying list following the last element in my list. */\n-//    protected Listable _post = null;\n-//\n-//}\n--- a/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractHashedMap.java,v 1.3 2003/12/28 22:44:18 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractHashedMap.java,v 1.4 2003/12/29 00:38:08 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * need for unusual subclasses is here.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/12/28 22:44:18 $\n+ * @version $Revision: 1.4 $ $Date: 2003/12/29 00:38:08 $\n  *\n  * @author java util HashMap\n  * @author Stephen Colebourne\n      */\n     protected static class HashMapIterator extends HashIterator implements MapIterator {\n         \n-        HashMapIterator(AbstractHashedMap map) {\n-            super(map);\n+        protected HashMapIterator(AbstractHashedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      * EntrySet implementation.\n      */\n     protected static class EntrySet extends AbstractSet {\n-        private final AbstractHashedMap map;\n-        \n-        EntrySet(AbstractHashedMap map) {\n+        /** The parent map */\n+        protected final AbstractHashedMap parent;\n+        \n+        protected EntrySet(AbstractHashedMap parent) {\n             super();\n-            this.map = map;\n+            this.parent = parent;\n         }\n \n         public int size() {\n-            return map.size();\n+            return parent.size();\n         }\n         \n         public void clear() {\n-            map.clear();\n+            parent.clear();\n         }\n         \n         public boolean contains(Object entry) {\n             if (entry instanceof Map.Entry) {\n-                return map.containsKey(((Map.Entry) entry).getKey());\n+                return parent.containsKey(((Map.Entry) entry).getKey());\n             }\n             return false;\n         }\n             }\n             Map.Entry entry = (Map.Entry) obj;\n             Object key = entry.getKey();\n-            boolean result = map.containsKey(key);\n-            map.remove(key);\n+            boolean result = parent.containsKey(key);\n+            parent.remove(key);\n             return result;\n         }\n \n         public Iterator iterator() {\n-            return map.createEntrySetIterator();\n+            return parent.createEntrySetIterator();\n         }\n     }\n \n      */\n     protected static class EntrySetIterator extends HashIterator {\n         \n-        EntrySetIterator(AbstractHashedMap map) {\n-            super(map);\n+        protected EntrySetIterator(AbstractHashedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      * KeySet implementation.\n      */\n     protected static class KeySet extends AbstractSet {\n-        private final AbstractHashedMap map;\n-        \n-        KeySet(AbstractHashedMap map) {\n+        /** The parent map */\n+        protected final AbstractHashedMap parent;\n+        \n+        protected KeySet(AbstractHashedMap parent) {\n             super();\n-            this.map = map;\n+            this.parent = parent;\n         }\n \n         public int size() {\n-            return map.size();\n+            return parent.size();\n         }\n         \n         public void clear() {\n-            map.clear();\n+            parent.clear();\n         }\n         \n         public boolean contains(Object key) {\n-            return map.containsKey(key);\n+            return parent.containsKey(key);\n         }\n         \n         public boolean remove(Object key) {\n-            boolean result = map.containsKey(key);\n-            map.remove(key);\n+            boolean result = parent.containsKey(key);\n+            parent.remove(key);\n             return result;\n         }\n \n         public Iterator iterator() {\n-            return map.createKeySetIterator();\n+            return parent.createKeySetIterator();\n         }\n     }\n \n      */\n     protected static class KeySetIterator extends EntrySetIterator {\n         \n-        KeySetIterator(AbstractHashedMap map) {\n-            super(map);\n+        protected KeySetIterator(AbstractHashedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      * Values implementation.\n      */\n     protected static class Values extends AbstractCollection {\n-        private final AbstractHashedMap map;\n-        \n-        Values(AbstractHashedMap map) {\n+        /** The parent map */\n+        protected final AbstractHashedMap parent;\n+        \n+        protected Values(AbstractHashedMap parent) {\n             super();\n-            this.map = map;\n+            this.parent = parent;\n         }\n \n         public int size() {\n-            return map.size();\n+            return parent.size();\n         }\n         \n         public void clear() {\n-            map.clear();\n+            parent.clear();\n         }\n         \n         public boolean contains(Object value) {\n-            return map.containsValue(value);\n+            return parent.containsValue(value);\n         }\n         \n         public Iterator iterator() {\n-            return map.createValuesIterator();\n+            return parent.createValuesIterator();\n         }\n     }\n \n      */\n     protected static class ValuesIterator extends HashIterator {\n         \n-        ValuesIterator(AbstractHashedMap map) {\n-            super(map);\n+        protected ValuesIterator(AbstractHashedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      * Base Iterator\n      */\n     protected static abstract class HashIterator implements Iterator {\n-        protected final AbstractHashedMap map;\n+        \n+        /** The parent map */\n+        protected final AbstractHashedMap parent;\n+        /** The current index into the array of buckets */\n         protected int hashIndex;\n-        protected HashEntry current;\n+        /** The last returned entry */\n+        protected HashEntry last;\n+        /** The next entry */\n         protected HashEntry next;\n+        /** The modification count expected */\n         protected int expectedModCount;\n         \n-        protected HashIterator(AbstractHashedMap map) {\n+        protected HashIterator(AbstractHashedMap parent) {\n             super();\n-            this.map = map;\n-            HashEntry[] data = map.data;\n+            this.parent = parent;\n+            HashEntry[] data = parent.data;\n             int i = data.length;\n             HashEntry next = null;\n             while (i > 0 && next == null) {\n             }\n             this.next = next;\n             this.hashIndex = i;\n-            this.expectedModCount = map.modCount;\n+            this.expectedModCount = parent.modCount;\n         }\n \n         public boolean hasNext() {\n         }\n \n         protected HashEntry nextEntry() { \n-            if (map.modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n             HashEntry newCurrent = next;\n             if (newCurrent == null)  {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n-            HashEntry[] data = map.data;\n+            HashEntry[] data = parent.data;\n             int i = hashIndex;\n             HashEntry n = newCurrent.next;\n             while (n == null && i > 0) {\n             }\n             next = n;\n             hashIndex = i;\n-            current = newCurrent;\n+            last = newCurrent;\n             return newCurrent;\n         }\n \n         protected HashEntry currentEntry() {\n-            return current;\n+            return last;\n         }\n         \n         public void remove() {\n-            if (current == null) {\n+            if (last == null) {\n                 throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             }\n-            if (map.modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            map.remove(current.getKey());\n-            current = null;\n-            expectedModCount = map.modCount;\n+            parent.remove(last.getKey());\n+            last = null;\n+            expectedModCount = parent.modCount;\n         }\n \n         public String toString() {\n-            if (current != null) {\n-                return \"Iterator[\" + current.getKey() + \"=\" + current.getValue() + \"]\";\n+            if (last != null) {\n+                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n             } else {\n                 return \"Iterator[]\";\n             }\n--- a/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java,v 1.4 2003/12/28 22:53:28 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java,v 1.5 2003/12/29 00:38:08 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/12/28 22:53:28 $\n+ * @version $Revision: 1.5 $ $Date: 2003/12/29 00:38:08 $\n  *\n  * @author java util LinkedHashMap\n  * @author Stephen Colebourne\n      */\n     protected static class LinkMapIterator extends LinkIterator implements OrderedMapIterator {\n         \n-        LinkMapIterator(AbstractLinkedMap map) {\n-            super(map);\n+        protected LinkMapIterator(AbstractLinkedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      */\n     protected static class EntrySetIterator extends LinkIterator {\n         \n-        EntrySetIterator(AbstractLinkedMap map) {\n-            super(map);\n+        protected EntrySetIterator(AbstractLinkedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      */\n     protected static class KeySetIterator extends EntrySetIterator {\n         \n-        KeySetIterator(AbstractLinkedMap map) {\n-            super(map);\n+        protected KeySetIterator(AbstractLinkedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n      */\n     protected static class ValuesIterator extends LinkIterator {\n         \n-        ValuesIterator(AbstractLinkedMap map) {\n-            super(map);\n+        protected ValuesIterator(AbstractLinkedMap parent) {\n+            super(parent);\n         }\n \n         public Object next() {\n             implements OrderedIterator, ResettableIterator {\n                 \n         /** The parent map */\n-        protected final AbstractLinkedMap map;\n+        protected final AbstractLinkedMap parent;\n         /** The current (last returned) entry */\n-        protected LinkEntry current;\n+        protected LinkEntry last;\n         /** The next entry */\n         protected LinkEntry next;\n         /** The modification count expected */\n         protected int expectedModCount;\n         \n-        protected LinkIterator(AbstractLinkedMap map) {\n+        protected LinkIterator(AbstractLinkedMap parent) {\n             super();\n-            this.map = map;\n-            this.next = map.header.after;\n-            this.expectedModCount = map.modCount;\n+            this.parent = parent;\n+            this.next = parent.header.after;\n+            this.expectedModCount = parent.modCount;\n         }\n \n         public boolean hasNext() {\n-            return (next != map.header);\n+            return (next != parent.header);\n         }\n         \n         public boolean hasPrevious() {\n-            return (next.before != map.header);\n+            return (next.before != parent.header);\n         }\n \n         protected LinkEntry nextEntry() {\n-            if (map.modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            if (next == map.header)  {\n+            if (next == parent.header)  {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n-            current = next;\n+            last = next;\n             next = next.after;\n-            return current;\n+            return last;\n         }\n \n         protected LinkEntry previousEntry() {\n-            if (map.modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n             LinkEntry previous = next.before;\n-            if (previous == map.header)  {\n+            if (previous == parent.header)  {\n                 throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n             }\n             next = previous;\n-            current = previous;\n-            return current;\n+            last = previous;\n+            return last;\n         }\n         \n         protected LinkEntry currentEntry() {\n-            return current;\n+            return last;\n         }\n         \n         public void remove() {\n-            if (current == null) {\n+            if (last == null) {\n                 throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             }\n-            if (map.modCount != expectedModCount) {\n+            if (parent.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n-            map.remove(current.getKey());\n-            current = null;\n-            expectedModCount = map.modCount;\n+            parent.remove(last.getKey());\n+            last = null;\n+            expectedModCount = parent.modCount;\n         }\n         \n         public void reset() {\n-            current = null;\n-            next = map.header.after;\n+            last = null;\n+            next = parent.header.after;\n         }\n \n         public String toString() {\n-            if (current != null) {\n-                return \"Iterator[\" + current.getKey() + \"=\" + current.getValue() + \"]\";\n+            if (last != null) {\n+                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n             } else {\n                 return \"Iterator[]\";\n             }", "timestamp": 1072658288, "metainfo": ""}