{"sha": "467d516b9cd00c1aefd2569b41ef43bc187d1312", "log": "Cleanup of trie package.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractTrie.java\n         return keyAnalyzer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public K selectKey(final K key) {\n         final Map.Entry<K, V> entry = select(key);\n         if (entry == null) {\n         return entry.getKey();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public V selectValue(final K key) {\n         final Map.Entry<K, V> entry = select(key);\n         if (entry == null) {\n     }\n \n     /**\n-     * A utility method to cast keys. It actually doesn't\n-     * cast anything. It's just fooling the compiler!\n+     * A utility method to cast keys. It actually doesn't cast anything. It's just fooling the compiler!\n      */\n     @SuppressWarnings(\"unchecked\")\n     final K castKey(final Object key) {\n-        return (K)key;\n+        return (K) key;\n     }\n \n     /**\n     }\n \n     /**\n-     * Returns whether or not the given bit on the\n-     * key is set or false if the key is null.\n+     * Returns whether or not the given bit on the key is set or false if the key is null.\n      *\n      * @see KeyAnalyzer#isBitSet(Object, int, int)\n      */\n     }\n \n     /**\n-     * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}\n+     * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}.\n      */\n     final int bitIndex(final K key, final K foundKey) {\n-        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key),\n-                foundKey, 0, lengthInBits(foundKey));\n+        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key), foundKey, 0, lengthInBits(foundKey));\n     }\n \n     /**\n     }\n \n     /**\n-     * Returns true if both values are either null or equal\n+     * Returns true if both values are either null or equal.\n      */\n     static boolean compare(final Object a, final Object b) {\n         return a == null ? b == null : a.equals(b);\n     }\n \n     /**\n-     * A basic implementation of {@link Entry}\n+     * A basic implementation of {@link Entry}.\n      */\n     abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable {\n \n         public BasicEntry(final K key, final V value) {\n             this.key = key;\n             this.value = value;\n-\n-            this.hashCode = (key != null ? key.hashCode() : 0)\n-                    ^ (value != null ? value.hashCode() : 0);\n+            this.hashCode = (key != null ? key.hashCode() : 0) ^ (value != null ? value.hashCode() : 0);\n         }\n \n         /**\n-         * Replaces the current key and value with the provided\n-         * key &amp; value\n+         * Replaces the current key and value with the provided key &amp; value.\n          */\n         public V setKeyValue(final K key, final V value) {\n             this.key = key;\n             return setValue(value);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public K getKey() {\n             return key;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public V getValue() {\n             return value;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public V setValue(final V value) {\n             final V previous = this.value;\n             this.value = value;\n--- a/src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java\n  * @since 4.0\n  * @version $Id$\n  */\n-public interface KeyAnalyzer<K> extends Comparator<K>, Serializable {\n+public abstract class KeyAnalyzer<K> implements Comparator<K>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -20497563720380683L;\n \n     /**\n      * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n     public static final int OUT_OF_BOUNDS_BIT_KEY = -3;\n \n     /**\n+     * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}\n+     */\n+    static boolean isOutOfBoundsIndex(final int bitIndex) {\n+        return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n+    }\n+\n+    /**\n+     * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}\n+     */\n+    static boolean isEqualBitKey(final int bitIndex) {\n+        return bitIndex == EQUAL_BIT_KEY;\n+    }\n+\n+    /**\n+     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}\n+     */\n+    static boolean isNullBitKey(final int bitIndex) {\n+        return bitIndex == NULL_BIT_KEY;\n+    }\n+\n+    /**\n+     * Returns true if the given bitIndex is valid. Indices\n+     * are considered valid if they're between 0 and\n+     * {@link Integer#MAX_VALUE}\n+     */\n+    static boolean isValidBitIndex(final int bitIndex) {\n+        return bitIndex >= 0;\n+    }\n+\n+    /**\n      * Returns the number of bits per element in the key.\n      * This is only useful for variable-length keys, such as Strings.\n      *\n      * @return the number of bits per element\n      */\n-    public int bitsPerElement();\n+    public abstract int bitsPerElement();\n \n     /**\n      * Returns the length of the Key in bits.\n      * @param key  the key\n      * @return the bit length of the key\n      */\n-    public int lengthInBits(K key);\n+    public abstract int lengthInBits(K key);\n \n     /**\n      * Returns whether or not a bit is set.\n+     *\n+     * @param key  the key to check, may not be null\n+     * @param bitIndex  the bit index to check\n+     * @param lengthInBits  the maximum key length in bits to check\n+     * @return {@code true} if the bit is set in the given key and\n+     *   {@code bitIndex} &lt; {@code lengthInBits}, {@code false} otherwise.\n      */\n-    public boolean isBitSet(K key, int bitIndex, int lengthInBits);\n+    public abstract boolean isBitSet(K key, int bitIndex, int lengthInBits);\n \n     /**\n-     * Returns the n-th different bit between key and found. This starts the comparison in\n-     * key at 'keyStart' and goes for 'keyLength' bits, and compares to the found key starting\n-     * at 'foundStart' and going for 'foundLength' bits.\n+     * Returns the n-th different bit between key and other. This starts the comparison in\n+     * key at 'offsetInBits' and goes for 'lengthInBits' bits, and compares to the other key starting\n+     * at 'otherOffsetInBits' and going for 'otherLengthInBits' bits.\n+     *\n+     * @param key  the key to use\n+     * @param offsetInBits  the bit offset in the key\n+     * @param lengthInBits  the maximum key length in bits to use\n+     * @param other  the other key to use\n+     * @param otherOffsetInBits  the bit offset in the other key\n+     * @param otherLengthInBits  the maximum key length in bits for the other key\n+     * @return the bit index where the key and other first differ\n      */\n-    public int bitIndex(K key, int offsetInBits, int lengthInBits,\n-                        K other, int otherOffsetInBits, int otherLengthInBits);\n+    public abstract int bitIndex(K key, int offsetInBits, int lengthInBits,\n+                                 K other, int otherOffsetInBits, int otherLengthInBits);\n \n     /**\n      * Determines whether or not the given prefix (from offset to length) is a prefix of the given key.\n+     *\n+     * @param prefix  the prefix to check\n+     * @param offsetInBits  the bit offset in the key\n+     * @param lengthInBits  the maximum key length in bits to use\n+     * @param key  the key to check\n+     * @return {@code true} if this is a valid prefix for the given key\n      */\n-    public boolean isPrefix(K prefix, int offsetInBits, int lengthInBits, K key);\n+    public abstract boolean isPrefix(K prefix, int offsetInBits, int lengthInBits, K key);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public int compare(final K o1, final K o2) {\n+        if (o1 == null) {\n+            return o2 == null ? 0 : -1;\n+        } else if (o2 == null) {\n+            return 1;\n+        }\n+\n+        return ((Comparable<K>) o1).compareTo(o2);\n+    }\n+\n }\n--- a/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n         super(keyAnalyzer);\n     }\n \n-    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer,\n-            final Map<? extends K, ? extends V> m) {\n+    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> m) {\n         super(keyAnalyzer, m);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Comparator<? super K> comparator() {\n         return keyAnalyzer;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedBy(final K key) {\n         return getPrefixedByBits(key, 0, lengthInBits(key));\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n         return getPrefixedByBits(key, 0, length * bitsPerElement());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n         final int bitsPerElement = bitsPerElement();\n         return getPrefixedByBits(key, offset*bitsPerElement, length*bitsPerElement);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n         return getPrefixedByBits(key, 0, lengthInBits);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public K firstKey() {\n         return firstEntry().getKey();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public K lastKey() {\n         final TrieEntry<K, V> entry = lastEntry();\n         if (entry != null) {\n         return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> headMap(final K toKey) {\n         return new RangeEntryMap(null, toKey);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n         return new RangeEntryMap(fromKey, toKey);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public SortedMap<K, V> tailMap(final K fromKey) {\n         return new RangeEntryMap(fromKey, null);\n     }\n         }\n \n         final int bitIndex = bitIndex(key, found.key);\n-        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return ceil;\n-        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n             if (!root.isEmpty()) {\n                 return firstEntry();\n             } else if (size() > 1) {\n             } else {\n                 return null;\n             }\n-        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n             return nextEntry(found);\n         }\n \n         }\n \n         final int bitIndex = bitIndex(key, found.key);\n-        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return ceil;\n-        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n             if (!root.isEmpty()) {\n                 return root;\n             } else {\n                 return firstEntry();\n             }\n-        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n             return found;\n         }\n \n         }\n \n         final int bitIndex = bitIndex(key, found.key);\n-        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return prior;\n-        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n             return null;\n-        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n             return previousEntry(found);\n         }\n \n         }\n \n         final int bitIndex = bitIndex(key, found.key);\n-        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n             final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n             addEntry(added, lengthInBits);\n             incrementSize(); // must increment because remove will decrement\n             removeEntry(added);\n             modCount -= 2; // we didn't really modify it.\n             return floor;\n-        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n             if (!root.isEmpty()) {\n                 return root;\n             } else {\n                 return null;\n             }\n-        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n             return found;\n         }\n \n         TrieEntry<K, V> current = root.left;\n         TrieEntry<K, V> path = root;\n         while(true) {\n-            if (current.bitIndex <= path.bitIndex\n-                    || lengthInBits < current.bitIndex) {\n+            if (current.bitIndex <= path.bitIndex || lengthInBits < current.bitIndex) {\n                 break;\n             }\n \n             path = current;\n-            if (!isBitSet(prefix, offsetInBits + current.bitIndex,\n-                    offsetInBits + lengthInBits)) {\n+            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n                 current = current.left;\n             } else {\n                 current = current.right;\n      *          - If node.parent.left is not uplink from node.parent:\n      *              - Follow right path for first right child from node.parent.left\n      *\n-     * @param start\n+     * @param start  the start entry\n      */\n     TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n         if (start.predecessor == null) {\n     }\n \n     /**\n-     * A range view of the {@link Trie}\n+     * A range view of the {@link Trie}.\n      */\n     private abstract class RangeMap extends AbstractMap<K, V>\n             implements SortedMap<K, V> {\n \n-        /**\n-         * The {@link #entrySet()} view\n-         */\n+        /** The {@link #entrySet()} view. */\n         private transient volatile Set<Map.Entry<K, V>> entrySet;\n \n         /**\n-         * Creates and returns an {@link #entrySet()}\n-         * view of the {@link RangeMap}\n+         * Creates and returns an {@link #entrySet()} view of the {@link RangeMap}.\n          */\n         protected abstract Set<Map.Entry<K, V>> createEntrySet();\n \n         /**\n-         * Returns the FROM Key\n+         * Returns the FROM Key.\n          */\n         protected abstract K getFromKey();\n \n         /**\n-         * Whether or not the {@link #getFromKey()} is in the range\n+         * Whether or not the {@link #getFromKey()} is in the range.\n          */\n         protected abstract boolean isFromInclusive();\n \n         /**\n-         * Returns the TO Key\n+         * Returns the TO Key.\n          */\n         protected abstract K getToKey();\n \n         /**\n-         * Whether or not the {@link #getToKey()} is in the range\n+         * Whether or not the {@link #getToKey()} is in the range.\n          */\n         protected abstract boolean isToInclusive();\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public Comparator<? super K> comparator() {\n             return PatriciaTrie.this.comparator();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean containsKey(final Object key) {\n             if (!inRange(castKey(key))) {\n             return PatriciaTrie.this.containsKey(key);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public V remove(final Object key) {\n             if (!inRange(castKey(key))) {\n             return PatriciaTrie.this.remove(key);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public V get(final Object key) {\n             if (!inRange(castKey(key))) {\n             return PatriciaTrie.this.get(key);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public V put(final K key, final V value) {\n             if (!inRange(key)) {\n-                throw new IllegalArgumentException(\n-                        \"Key is out of range: \" + key);\n-            }\n-\n+                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n+            }\n             return PatriciaTrie.this.put(key, value);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public Set<Map.Entry<K, V>> entrySet() {\n             if (entrySet == null) {\n             return entrySet;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n             if (!inRange2(fromKey)) {\n-                throw new IllegalArgumentException(\n-                        \"FromKey is out of range: \" + fromKey);\n+                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n             }\n \n             if (!inRange2(toKey)) {\n-                throw new IllegalArgumentException(\n-                        \"ToKey is out of range: \" + toKey);\n-            }\n-\n-            return createRangeMap(fromKey, isFromInclusive(),\n-                    toKey, isToInclusive());\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n+                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n+            }\n+\n+            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n+        }\n+\n         public SortedMap<K, V> headMap(final K toKey) {\n             if (!inRange2(toKey)) {\n-                throw new IllegalArgumentException(\n-                        \"ToKey is out of range: \" + toKey);\n-            }\n-\n-            return createRangeMap(getFromKey(), isFromInclusive(),\n-                    toKey, isToInclusive());\n-        }\n-\n-        /**\n-         * {@inheritDoc}\n-         */\n+                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n+            }\n+            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n+        }\n+\n         public SortedMap<K, V> tailMap(final K fromKey) {\n             if (!inRange2(fromKey)) {\n-                throw new IllegalArgumentException(\n-                        \"FromKey is out of range: \" + fromKey);\n-            }\n-\n-            return createRangeMap(fromKey, isFromInclusive(),\n-                    getToKey(), isToInclusive());\n-        }\n-\n-        /**\n-         * Returns true if the provided key is greater than TO and\n-         * less than FROM\n+                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n+            }\n+            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n+        }\n+\n+        /**\n+         * Returns true if the provided key is greater than TO and less than FROM.\n          */\n         protected boolean inRange(final K key) {\n-\n             final K fromKey = getFromKey();\n             final K toKey = getToKey();\n \n-            return (fromKey == null || inFromRange(key, false))\n-                    && (toKey == null || inToRange(key, false));\n-        }\n-\n-        /**\n-         * This form allows the high endpoint (as well as all legit keys)\n+            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n+        }\n+\n+        /**\n+         * This form allows the high endpoint (as well as all legit keys).\n          */\n         protected boolean inRange2(final K key) {\n-\n             final K fromKey = getFromKey();\n             final K toKey = getToKey();\n \n-            return (fromKey == null || inFromRange(key, false))\n-                    && (toKey == null || inToRange(key, true));\n-        }\n-\n-        /**\n-         * Returns true if the provided key is in the FROM range\n-         * of the {@link RangeMap}\n+            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n+        }\n+\n+        /**\n+         * Returns true if the provided key is in the FROM range of the {@link RangeMap}.\n          */\n         protected boolean inFromRange(final K key, final boolean forceInclusive) {\n-\n             final K fromKey = getFromKey();\n             final boolean fromInclusive = isFromInclusive();\n \n         }\n \n         /**\n-         * Returns true if the provided key is in the TO range\n-         * of the {@link RangeMap}\n+         * Returns true if the provided key is in the TO range of the {@link RangeMap}.\n          */\n         protected boolean inToRange(final K key, final boolean forceInclusive) {\n-\n             final K toKey = getToKey();\n             final boolean toInclusive = isToInclusive();\n \n         }\n \n         /**\n-         * Creates and returns a sub-range view of the current {@link RangeMap}\n-         */\n-        protected abstract SortedMap<K, V> createRangeMap(K fromKey,\n-                boolean fromInclusive, K toKey, boolean toInclusive);\n+         * Creates and returns a sub-range view of the current {@link RangeMap}.\n+         */\n+        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n+                                                          K toKey, boolean toInclusive);\n     }\n \n    /**\n-    * A {@link RangeMap} that deals with {@link Entry}s\n+    * A {@link RangeMap} that deals with {@link Entry}s.\n     */\n    private class RangeEntryMap extends RangeMap {\n \n-       /**\n-        * The key to start from, null if the beginning.\n-        */\n+       /** The key to start from, null if the beginning. */\n        private final K fromKey;\n \n-       /**\n-        * The key to end at, null if till the end.\n-        */\n+       /** The key to end at, null if till the end. */\n        private final K toKey;\n \n-       /**\n-        * Whether or not the 'from' is inclusive.\n-        */\n+       /** Whether or not the 'from' is inclusive. */\n        private final boolean fromInclusive;\n \n-       /**\n-        * Whether or not the 'to' is inclusive.\n-        */\n+       /** Whether or not the 'to' is inclusive. */\n        private final boolean toInclusive;\n \n        /**\n         * Creates a {@link RangeEntryMap} with the fromKey included and\n-        * the toKey excluded from the range\n+        * the toKey excluded from the range.\n         */\n        protected RangeEntryMap(final K fromKey, final K toKey) {\n            this(fromKey, true, toKey, false);\n        }\n \n        /**\n-        * Creates a {@link RangeEntryMap}\n+        * Creates a {@link RangeEntryMap}.\n         */\n        protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n-               final K toKey, final boolean toInclusive) {\n+                               final K toKey, final boolean toInclusive) {\n \n            if (fromKey == null && toKey == null) {\n                throw new IllegalArgumentException(\"must have a from or to!\");\n            this.toInclusive = toInclusive;\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        public K firstKey() {\n            Map.Entry<K,V> e = null;\n            if (fromKey == null) {\n            return first;\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        public K lastKey() {\n            Map.Entry<K,V> e;\n            if (toKey == null) {\n            return last;\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        @Override\n        protected Set<Entry<K, V>> createEntrySet() {\n            return new RangeEntrySet(this);\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        @Override\n        public boolean isFromInclusive() {\n            return fromInclusive;\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        @Override\n        public boolean isToInclusive() {\n            return toInclusive;\n        }\n \n-       /**\n-        * {@inheritDoc}\n-        */\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                final K toKey, final boolean toInclusive) {\n    }\n \n     /**\n-     * A {@link Set} view of a {@link RangeMap}\n+     * A {@link Set} view of a {@link RangeMap}.\n      */\n     private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n \n         private transient int expectedModCount;\n \n         /**\n-         * Creates a {@link RangeEntrySet}\n+         * Creates a {@link RangeEntrySet}.\n          */\n         public RangeEntrySet(final RangeMap delegate) {\n             if (delegate == null) {\n             this.delegate = delegate;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public Iterator<Map.Entry<K, V>> iterator() {\n             final K fromKey = delegate.getFromKey();\n             return new EntryIterator(first, last);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public int size() {\n             if (size == -1 || expectedModCount != PatriciaTrie.this.modCount) {\n             return size;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean isEmpty() {\n             return !iterator().hasNext();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @SuppressWarnings(\"unchecked\")\n         @Override\n         public boolean contains(final Object o) {\n             return node != null && compare(node.getValue(), entry.getValue());\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @SuppressWarnings(\"unchecked\")\n         @Override\n         public boolean remove(final Object o) {\n             private final K excludedKey;\n \n             /**\n-             * Creates a {@link EntryIterator}\n+             * Creates a {@link EntryIterator}.\n              */\n-            private EntryIterator(\n-                    final TrieEntry<K,V> first,\n-                    final TrieEntry<K,V> last) {\n+            private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) {\n                 super(first);\n-\n                 this.excludedKey = last != null ? last.getKey() : null;\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             @Override\n             public boolean hasNext() {\n                 return next != null && !compare(next.key, excludedKey);\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             public Map.Entry<K,V> next() {\n                 if (next == null || compare(next.key, excludedKey)) {\n                     throw new NoSuchElementException();\n                 }\n-\n                 return nextEntry();\n             }\n         }\n         private int size = -1;\n \n         /**\n-         * Creates a {@link PrefixRangeMap}\n+         * Creates a {@link PrefixRangeMap}.\n          */\n         private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n             this.prefix = prefix;\n             return size;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public K firstKey() {\n             fixup();\n \n             return first;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public K lastKey() {\n             fixup();\n \n         }\n \n         /**\n-         * Returns true if this {@link PrefixRangeMap}'s key is a prefix\n-         * of the provided key.\n+         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n          */\n         @Override\n         protected boolean inRange(final K key) {\n         }\n \n         /**\n-         * Same as {@link #inRange(Object)}\n+         * Same as {@link #inRange(Object)}.\n          */\n         @Override\n         protected boolean inRange2(final K key) {\n         }\n \n         /**\n-         * Returns true if the provided Key is in the FROM range\n-         * of the {@link PrefixRangeMap}\n+         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n          */\n         @Override\n         protected boolean inFromRange(final K key, final boolean forceInclusive) {\n         }\n \n         /**\n-         * Returns true if the provided Key is in the TO range\n-         * of the {@link PrefixRangeMap}\n+         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n          */\n         @Override\n         protected boolean inToRange(final K key, final boolean forceInclusive) {\n             return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         protected Set<Map.Entry<K, V>> createEntrySet() {\n             return new PrefixRangeEntrySet(this);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public K getFromKey() {\n             return fromKey;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public K getToKey() {\n             return toKey;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean isFromInclusive() {\n             return false;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean isToInclusive() {\n             return false;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n-        @Override\n-        protected SortedMap<K, V> createRangeMap(\n-                final K fromKey, final boolean fromInclusive,\n-                final K toKey, final boolean toInclusive) {\n+        @Override\n+        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n+                                                 final K toKey, final boolean toInclusive) {\n             return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n         }\n     }\n \n     /**\n-     * A prefix {@link RangeEntrySet} view of the {@link Trie}\n+     * A prefix {@link RangeEntrySet} view of the {@link Trie}.\n      */\n     private final class PrefixRangeEntrySet extends RangeEntrySet {\n \n         private int expectedModCount = 0;\n \n         /**\n-         * Creates a {@link PrefixRangeEntrySet}\n+         * Creates a {@link PrefixRangeEntrySet}.\n          */\n         public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n             super(delegate);\n             this.delegate = delegate;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public int size() {\n             return delegate.fixup();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public Iterator<Map.Entry<K,V>> iterator() {\n             if (PatriciaTrie.this.modCount != expectedModCount) {\n                 this.entry = entry;\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             public boolean hasNext() {\n                 return hit == 0;\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             public Map.Entry<K, V> next() {\n                 if (hit != 0) {\n                     throw new NoSuchElementException();\n                 return entry;\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             public void remove() {\n                 if (hit != 1) {\n                     throw new IllegalStateException();\n                 this.lengthInBits = lengthInBits;\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             public Map.Entry<K,V> next() {\n                 final Map.Entry<K, V> entry = nextEntry();\n                 if (lastOne) {\n                 return entry;\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             @Override\n             protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                 return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n             }\n \n-            /**\n-             * {@inheritDoc}\n-             */\n             @Override\n             public void remove() {\n                 // If the current entry we're removing is the subtree\n--- a/src/main/java/org/apache/commons/collections4/trie/PatriciaTrieBase.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrieBase.java\n     private transient volatile Collection<V> values;\n     private transient volatile Set<Map.Entry<K,V>> entrySet;\n \n-    /**\n-     * The current size of the {@link Trie}\n-     */\n+    /** The current size of the {@link Trie}. */\n     private int size = 0;\n \n     /**\n      * The number of times this {@link Trie} has been modified.\n-     * It's used to detect concurrent modifications and fail-fast\n-     * the {@link Iterator}s.\n-     */\n-    transient int modCount = 0;\n+     * It's used to detect concurrent modifications and fail-fast the {@link Iterator}s.\n+     */\n+    protected transient int modCount = 0;\n \n     public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer) {\n         super(keyAnalyzer);\n     }\n \n     /**\n-     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given {@link KeyAnalyzer}\n-     * and initializes the {@link org.apache.commons.collections4.Trie Trie} with the values from the\n-     * provided {@link Map}.\n-     */\n-    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer,\n-            final Map<? extends K, ? extends V> m) {\n+     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given\n+     * {@link KeyAnalyzer} and initializes the {@link org.apache.commons.collections4.Trie Trie}\n+     * with the values from the provided {@link Map}.\n+     */\n+    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> m) {\n         super(keyAnalyzer);\n-\n-        if (m == null) {\n-            throw new NullPointerException(\"m\");\n-        }\n-\n         putAll(m);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public void clear() {\n         root.key = null;\n         incrementModCount();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public int size() {\n         return size;\n     }\n \n     /**\n-     * A helper method to increment the {@link Trie} size\n-     * and the modification counter.\n+     * A helper method to increment the {@link Trie} size and the modification counter.\n      */\n     void incrementSize() {\n         size++;\n     }\n \n     /**\n-     * A helper method to decrement the {@link Trie} size\n-     * and increment the modification counter.\n+     * A helper method to decrement the {@link Trie} size and increment the modification counter.\n      */\n     void decrementSize() {\n         size--;\n         ++modCount;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public V put(final K key, final V value) {\n         if (key == null) {\n         }\n \n         final int bitIndex = bitIndex(key, found.key);\n-        if (!AbstractKeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n-            if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n+        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n+            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n                 /* NEW KEY+VALUE TUPLE */\n                 final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n                 addEntry(t, lengthInBits);\n                 incrementSize();\n                 return null;\n-            } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n                 // A bits of the Key are zero. The only place to\n                 // store such a Key is the root Node!\n \n                 }\n                 return root.setKeyValue(key, value);\n \n-            } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n                 // This is a very special and rare case.\n \n                 /* REPLACE OLD KEY+VALUE */\n             }\n         }\n \n-        throw new IndexOutOfBoundsException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n-    }\n-\n-    /**\n-     * Adds the given {@link TrieEntry} to the {@link Trie}\n+        throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n+    }\n+\n+    /**\n+     * Adds the given {@link TrieEntry} to the {@link Trie}.\n      */\n     TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n         TrieEntry<K, V> current = root.left;\n         }\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public V get(final Object k) {\n         final TrieEntry<K, V> entry = getEntry(k);\n      * Returns the entry associated with the specified key in the\n      * PatriciaTrieBase.  Returns null if the map contains no mapping\n      * for this key.\n-     *\n+     * <p>\n      * This may throw ClassCastException if the object is not of type K.\n      */\n     TrieEntry<K,V> getEntry(final Object k) {\n         return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Map.Entry<K, V> select(final K key) {\n         final int lengthInBits = lengthInBits(key);\n-        final Reference<Map.Entry<K, V>> reference\n-            = new Reference<Map.Entry<K,V>>();\n+        final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>();\n         if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n             return reference.get();\n         }\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Map.Entry<K,V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n         final int lengthInBits = lengthInBits(key);\n-        final Reference<Map.Entry<K, V>> reference\n-            = new Reference<Map.Entry<K,V>>();\n+        final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>();\n         selectR(root.left, -1, key, lengthInBits, cursor, reference);\n         return reference.get();\n     }\n \n     /**\n-     * This is equivalent to the other {@link #selectR(TrieEntry, int,\n-     * Object, int, Cursor, Reference)} method but without its overhead\n-     * because we're selecting only one best matching Entry from the\n-     * {@link Trie}.\n+     * This is equivalent to the other {@link #selectR(TrieEntry, int, Object, int, Cursor, Reference)}\n+     * method but without its overhead because we're selecting only one best matching Entry from the {@link Trie}.\n      */\n     private boolean selectR(final TrieEntry<K, V> h, final int bitIndex,\n-            final K key, final int lengthInBits,\n-            final Reference<Map.Entry<K, V>> reference) {\n+                            final K key, final int lengthInBits,\n+                            final Reference<Map.Entry<K, V>> reference) {\n \n         if (h.bitIndex <= bitIndex) {\n             // If we hit the root Node and it is empty\n         return false;\n     }\n \n-    /**\n-     *\n-     */\n     private boolean selectR(final TrieEntry<K,V> h, final int bitIndex,\n             final K key,\n             final int lengthInBits,\n         return false;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     public Map.Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n         TrieEntry<K, V> entry = nextEntry(null);\n         while (entry != null) {\n         return null;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public boolean containsKey(final Object k) {\n         if (k == null) {\n         return !entry.isEmpty() && compareKeys(key, entry.key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public Set<Map.Entry<K,V>> entrySet() {\n         if (entrySet == null) {\n         return entrySet;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public Set<K> keySet() {\n         if (keySet == null) {\n         return keySet;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public Collection<V> values() {\n         if (values == null) {\n \n     /**\n      * Returns the first entry the {@link Trie} is storing.\n-     *\n+     * <p>\n      * This is implemented by going always to the left until\n      * we encounter a valid uplink. That uplink is the first key.\n      */\n     }\n \n     /**\n-     *  A {@link Trie} is a set of {@link TrieEntry} nodes\n+     *  A {@link Trie} is a set of {@link TrieEntry} nodes.\n      */\n     static class TrieEntry<K,V> extends BasicEntry<K, V> {\n \n         }\n \n         /**\n-         * Neither the left nor right child is a loopback\n+         * Neither the left nor right child is a loopback.\n          */\n         public boolean isInternalNode() {\n             return left != this && right != this;\n         }\n \n         /**\n-         * Either the left or right child is a loopback\n+         * Either the left or right child is a loopback.\n          */\n         public boolean isExternalNode() {\n             return !isInternalNode();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public String toString() {\n             final StringBuilder buffer = new StringBuilder();\n \n \n     /**\n-     * This is a entry set view of the {@link Trie} as returned\n-     * by {@link Map#entrySet()}\n+     * This is a entry set view of the {@link Trie} as returned by {@link Map#entrySet()}.\n      */\n     private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public Iterator<Map.Entry<K,V>> iterator() {\n             return new EntryIterator();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean contains(final Object o) {\n             if (!(o instanceof Map.Entry)) {\n             return candidate != null && candidate.equals(o);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean remove(final Object o) {\n             final int size = size();\n             return size != size();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public int size() {\n             return PatriciaTrieBase.this.size();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public void clear() {\n             PatriciaTrieBase.this.clear();\n         }\n \n         /**\n-         * An {@link Iterator} that returns {@link Entry} Objects\n+         * An {@link Iterator} that returns {@link Entry} Objects.\n          */\n         private class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n             public Map.Entry<K,V> next() {\n     }\n \n     /**\n-     * This is a key set view of the {@link Trie} as returned\n-     * by {@link Map#keySet()}\n+     * This is a key set view of the {@link Trie} as returned by {@link Map#keySet()}.\n      */\n     private class KeySet extends AbstractSet<K> {\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public Iterator<K> iterator() {\n             return new KeyIterator();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public int size() {\n             return PatriciaTrieBase.this.size();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean contains(final Object o) {\n             return containsKey(o);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean remove(final Object o) {\n             final int size = size();\n             return size != size();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public void clear() {\n             PatriciaTrieBase.this.clear();\n         }\n \n         /**\n-         * An {@link Iterator} that returns Key Objects\n+         * An {@link Iterator} that returns Key Objects.\n          */\n         private class KeyIterator extends TrieIterator<K> {\n             public K next() {\n     }\n \n     /**\n-     * This is a value view of the {@link Trie} as returned\n-     * by {@link Map#values()}\n+     * This is a value view of the {@link Trie} as returned by {@link Map#values()}.\n      */\n     private class Values extends AbstractCollection<V> {\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public Iterator<V> iterator() {\n             return new ValueIterator();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public int size() {\n             return PatriciaTrieBase.this.size();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean contains(final Object o) {\n             return containsValue(o);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public void clear() {\n             PatriciaTrieBase.this.clear();\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         @Override\n         public boolean remove(final Object o) {\n             for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n         }\n \n         /**\n-         * An {@link Iterator} that returns Value Objects\n+         * An {@link Iterator} that returns Value Objects.\n          */\n         private class ValueIterator extends TrieIterator<V> {\n             public V next() {\n      */\n     abstract class TrieIterator<E> implements Iterator<E> {\n \n-        /**\n-         * For fast-fail\n-         */\n+        /** For fast-fail. */\n         protected int expectedModCount = PatriciaTrieBase.this.modCount;\n \n         protected TrieEntry<K, V> next; // the next node to return\n         protected TrieEntry<K, V> current; // the current entry we're on\n \n         /**\n-         * Starts iteration from the root\n+         * Starts iteration from the root.\n          */\n         protected TrieIterator() {\n             next = PatriciaTrieBase.this.nextEntry(null);\n         }\n \n         /**\n-         * Starts iteration at the given entry\n+         * Starts iteration at the given entry.\n          */\n         protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n             next = firstEntry;\n         }\n \n         /**\n-         * Returns the next {@link TrieEntry}\n+         * Returns the next {@link TrieEntry}.\n          */\n         protected TrieEntry<K,V> nextEntry() {\n             if (expectedModCount != PatriciaTrieBase.this.modCount) {\n             return PatriciaTrieBase.this.nextEntry(prior);\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public boolean hasNext() {\n             return next != null;\n         }\n \n-        /**\n-         * {@inheritDoc}\n-         */\n         public void remove() {\n             if (current == null) {\n                 throw new IllegalStateException();\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/ByteArrayKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * A {@link KeyAnalyzer} for byte[]s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ByteArrayKeyAnalyzer extends KeyAnalyzer<byte[]> {\n+\n+    private static final long serialVersionUID = 7382825097492285877L;\n+\n+    /** A singleton instance of {@link ByteArrayKeyAnalyzer}. */\n+    public static final ByteArrayKeyAnalyzer INSTANCE = new ByteArrayKeyAnalyzer(Integer.MAX_VALUE);\n+\n+    /** The length of an {@link Byte} in bits. */\n+    public static final int LENGTH = Byte.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final int MSB = 0x80;\n+\n+    /** A place holder for null. */\n+    private static final byte[] NULL = new byte[0];\n+\n+    /** The maximum length of a key in bits. */\n+    private final int maxLengthInBits;\n+\n+    public ByteArrayKeyAnalyzer(final int maxLengthInBits) {\n+        if (maxLengthInBits < 0) {\n+            throw new IllegalArgumentException(\n+                    \"maxLengthInBits=\" + maxLengthInBits);\n+        }\n+\n+        this.maxLengthInBits = maxLengthInBits;\n+    }\n+\n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * Returns the maximum length of a key in bits\n+     * @return the maximum key length in bits\n+     */\n+    public int getMaxLengthInBits() {\n+        return maxLengthInBits;\n+    }\n+\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+\n+    public int lengthInBits(final byte[] key) {\n+        return key != null ? key.length * bitsPerElement() : 0;\n+    }\n+\n+    public boolean isBitSet(final byte[] key, final int bitIndex, final int lengthInBits) {\n+        if (key == null) {\n+            return false;\n+        }\n+\n+        final int prefix = maxLengthInBits - lengthInBits;\n+        final int keyBitIndex = bitIndex - prefix;\n+\n+        if (keyBitIndex >= lengthInBits || keyBitIndex < 0) {\n+            return false;\n+        }\n+\n+        final int index = keyBitIndex / LENGTH;\n+        final int bit = keyBitIndex % LENGTH;\n+        return (key[index] & mask(bit)) != 0;\n+    }\n+\n+    public int bitIndex(final byte[] key, final int offsetInBits, final int lengthInBits,\n+                        byte[] other, final int otherOffsetInBits, final int otherLengthInBits) {\n+\n+        if (other == null) {\n+            other = NULL;\n+        }\n+\n+        boolean allNull = true;\n+        final int length = Math.max(lengthInBits, otherLengthInBits);\n+        final int prefix = maxLengthInBits - length;\n+\n+        if (prefix < 0) {\n+            return KeyAnalyzer.OUT_OF_BOUNDS_BIT_KEY;\n+        }\n+\n+        for (int i = 0; i < length; i++) {\n+            final int index = prefix + offsetInBits + i;\n+            final boolean value = isBitSet(key, index, lengthInBits);\n+\n+            if (value) {\n+                allNull = false;\n+            }\n+\n+            final int otherIndex = prefix + otherOffsetInBits + i;\n+            final boolean otherValue = isBitSet(other, otherIndex, otherLengthInBits);\n+\n+            if (value != otherValue) {\n+                return index;\n+            }\n+        }\n+\n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isPrefix(final byte[] prefix, final int offsetInBits, final int lengthInBits, final byte[] key) {\n+\n+        final int keyLength = lengthInBits(key);\n+        if (lengthInBits > keyLength) {\n+            return false;\n+        }\n+\n+        final int elements = lengthInBits - offsetInBits;\n+        for (int i = 0; i < elements; i++) {\n+            if (isBitSet(prefix, i+offsetInBits, lengthInBits)\n+                    != isBitSet(key, i, keyLength)) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int compare(final byte[] o1, final byte[] o2) {\n+        if (o1 == null) {\n+            return o2 == null ? 0 : -1;\n+        } else if (o2 == null) {\n+            return 1;\n+        }\n+\n+        if (o1.length != o2.length) {\n+            return o1.length - o2.length;\n+        }\n+\n+        for (int i = 0; i < o1.length; i++) {\n+            final int diff = (o1[i] & 0xFF) - (o2[i] & 0xFF);\n+            if (diff != 0) {\n+                return diff;\n+            }\n+        }\n+\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/ByteKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Byte}s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ByteKeyAnalyzer extends KeyAnalyzer<Byte> {\n+\n+    private static final long serialVersionUID = 3395803342983289829L;\n+\n+    /** A singleton instance of {@link ByteKeyAnalyzer}. */\n+    public static final ByteKeyAnalyzer INSTANCE = new ByteKeyAnalyzer();\n+\n+    /** The length of an {@link Byte} in bits. */\n+    public static final int LENGTH = Byte.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final int MSB = 0x80;\n+\n+    /** Returns a bit mask where the given bit is set. */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+\n+    public int lengthInBits(final Byte key) {\n+        return LENGTH;\n+    }\n+\n+    public boolean isBitSet(final Byte key, final int bitIndex, final int lengthInBits) {\n+        return (key.intValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    public int bitIndex(final Byte key, final int offsetInBits, final int lengthInBits,\n+                        final Byte other, final int otherOffsetInBits, final int otherLengthInBits) {\n+\n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+\n+        final byte keyValue = key.byteValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final byte otherValue = other != null ? other.byteValue() : 0;\n+\n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isPrefix(final Byte prefix, final int offsetInBits, final int lengthInBits, final Byte key) {\n+\n+        final int value1 = prefix.byteValue() << offsetInBits;\n+        final int value2 = key.byteValue();\n+\n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+\n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/CharArrayKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * An {@link KeyAnalyzer} for {@code char[]}s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CharArrayKeyAnalyzer extends KeyAnalyzer<char[]> {\n+\n+    private static final long serialVersionUID = -8167897361549463457L;\n+\n+    /** A singleton instance of {@link CharArrayKeyAnalyzer}. */\n+    public static final CharArrayKeyAnalyzer INSTANCE = new CharArrayKeyAnalyzer();\n+\n+    /** The number of bits per {@link Character}. */\n+    public static final int LENGTH = Character.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final int MSB = 0x8000;\n+\n+    /** Returns a bit mask where the given bit is set. */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+\n+    public int lengthInBits(final char[] key) {\n+        return key != null ? key.length * LENGTH : 0;\n+    }\n+\n+    public int bitIndex(final char[] key, final int offsetInBits, final int lengthInBits,\n+                        final char[] other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        boolean allNull = true;\n+\n+        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0\n+                || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"The offsets and lengths must be at Character boundaries\");\n+        }\n+\n+\n+        final int beginIndex1 = offsetInBits / LENGTH;\n+        final int beginIndex2 = otherOffsetInBits / LENGTH;\n+\n+        final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+\n+        final int length = Math.max(endIndex1, endIndex2);\n+\n+        // Look at each character, and if they're different\n+        // then figure out which bit makes the difference\n+        // and return it.\n+        char k = 0, f = 0;\n+        for(int i = 0; i < length; i++) {\n+            final int index1 = beginIndex1 + i;\n+            final int index2 = beginIndex2 + i;\n+\n+            if (index1 >= endIndex1) {\n+                k = 0;\n+            } else {\n+                k = key[index1];\n+            }\n+\n+            if (other == null || index2 >= endIndex2) {\n+                f = 0;\n+            } else {\n+                f = other[index2];\n+            }\n+\n+            if (k != f) {\n+               final int x = k ^ f;\n+               return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n+            }\n+\n+            if (k != 0) {\n+                allNull = false;\n+            }\n+        }\n+\n+        // All bits are 0\n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+\n+        // Both keys are equal\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isBitSet(final char[] key, final int bitIndex, final int lengthInBits) {\n+        if (key == null || bitIndex >= lengthInBits) {\n+            return false;\n+        }\n+\n+        final int index = bitIndex / LENGTH;\n+        final int bit = bitIndex % LENGTH;\n+\n+        return (key[index] & mask(bit)) != 0;\n+    }\n+\n+    public boolean isPrefix(final char[] prefix, final int offsetInBits, final int lengthInBits, final char[] key) {\n+        if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"Cannot determine prefix outside of Character boundaries\");\n+        }\n+\n+        final int off = offsetInBits / LENGTH;\n+        final int len = lengthInBits / LENGTH;\n+        for (int i = 0; i < len; i ++) {\n+            if (prefix[i + off] != key[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/CharacterKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Character}s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CharacterKeyAnalyzer extends KeyAnalyzer<Character> {\n+\n+    private static final long serialVersionUID = 3928565962744720753L;\n+\n+    /** A singleton instance of the {@link CharacterKeyAnalyzer}. */\n+    public static final CharacterKeyAnalyzer INSTANCE\n+        = new CharacterKeyAnalyzer();\n+\n+    /** The length of a {@link Character} in bits. */\n+    public static final int LENGTH = Character.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final int MSB = 0x8000;\n+\n+    /** Returns a bit mask where the given bit is set. */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+\n+    public int lengthInBits(final Character key) {\n+        return LENGTH;\n+    }\n+\n+    public boolean isBitSet(final Character key, final int bitIndex, final int lengthInBits) {\n+        return (key.charValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    public int bitIndex(final Character key, final int offsetInBits, final int lengthInBits,\n+                        final Character other, final int otherOffsetInBits, final int otherLengthInBits) {\n+\n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+\n+        final char keyValue = key.charValue();\n+        if (keyValue == Character.MIN_VALUE) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final char otherValue = other != null ? other.charValue() : Character.MIN_VALUE;\n+\n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isPrefix(final Character prefix, final int offsetInBits,\n+                            final int lengthInBits, final Character key) {\n+\n+        final int value1 = prefix.charValue() << offsetInBits;\n+        final int value2 = key.charValue();\n+\n+        int mask = 0;\n+        for(int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+\n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/IntegerKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Integer}s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class IntegerKeyAnalyzer extends KeyAnalyzer<Integer> {\n+\n+    private static final long serialVersionUID = 4928508653722068982L;\n+\n+    /** A singleton instance of {@link IntegerKeyAnalyzer}. */\n+    public static final IntegerKeyAnalyzer INSTANCE = new IntegerKeyAnalyzer();\n+\n+    /** The length of an {@link Integer} in bits. */\n+    public static final int LENGTH = Integer.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final int MSB = 0x80000000;\n+\n+    /** Returns a bit mask where the given bit is set. */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+\n+    public int lengthInBits(final Integer key) {\n+        return LENGTH;\n+    }\n+\n+    public boolean isBitSet(final Integer key, final int bitIndex, final int lengthInBits) {\n+        return (key.intValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    public int bitIndex(final Integer key, final int offsetInBits, final int lengthInBits,\n+                        final Integer other, final int otherOffsetInBits, final int otherLengthInBits) {\n+\n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+\n+        final int keyValue = key.intValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final int otherValue = other != null ? other.intValue() : 0;\n+\n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isPrefix(final Integer prefix, final int offsetInBits,\n+                            final int lengthInBits, final Integer key) {\n+\n+        final int value1 = prefix.intValue() << offsetInBits;\n+        final int value2 = key.intValue();\n+\n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+\n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/LongKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Long}s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class LongKeyAnalyzer extends KeyAnalyzer<Long> {\n+\n+    private static final long serialVersionUID = -4119639247588227409L;\n+\n+    /** A singleton instance of {@link LongKeyAnalyzer}. */\n+    public static final LongKeyAnalyzer INSTANCE = new LongKeyAnalyzer();\n+\n+    /** The length of an {@link Long} in bits. */\n+    public static final int LENGTH = Long.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final long MSB = 0x8000000000000000L;\n+\n+    /** Returns a bit mask where the given bit is set. */\n+    private static long mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+\n+    public int lengthInBits(final Long key) {\n+        return LENGTH;\n+    }\n+\n+    public boolean isBitSet(final Long key, final int bitIndex, final int lengthInBits) {\n+        return (key.longValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    public int bitIndex(final Long key, final int offsetInBits, final int lengthInBits,\n+                        final Long other, final int otherOffsetInBits, final int otherLengthInBits) {\n+\n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+\n+        final long keyValue = key.longValue();\n+        if (keyValue == 0L) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final long otherValue = other != null ? other.longValue() : 0L;\n+\n+        if (keyValue != otherValue) {\n+            final long xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0L) {\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isPrefix(final Long prefix, final int offsetInBits,\n+                            final int lengthInBits, final Long key) {\n+\n+        final long value1 = prefix.longValue() << offsetInBits;\n+        final long value2 = key.longValue();\n+\n+        long mask = 0L;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1L << i;\n+        }\n+\n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/ShortKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Short}s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ShortKeyAnalyzer extends KeyAnalyzer<Short> {\n+\n+    private static final long serialVersionUID = -8631376733513512017L;\n+\n+    /** A singleton instance of {@link ShortKeyAnalyzer}. */\n+    public static final ShortKeyAnalyzer INSTANCE = new ShortKeyAnalyzer();\n+\n+    /** The length of an {@link Short} in bits. */\n+    public static final int LENGTH = Short.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final int MSB = 0x8000;\n+\n+    /** Returns a bit mask where the given bit is set. */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+\n+    public int lengthInBits(final Short key) {\n+        return LENGTH;\n+    }\n+\n+    public boolean isBitSet(final Short key, final int bitIndex, final int lengthInBits) {\n+        return (key.intValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    public int bitIndex(final Short key, final int offsetInBits, final int lengthInBits,\n+                        final Short other, final int otherOffsetInBits, final int otherLengthInBits) {\n+\n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits\n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+\n+        final int keyValue = key.shortValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final int otherValue = other != null ? other.shortValue() : 0;\n+\n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isPrefix(final Short prefix, final int offsetInBits,\n+                            final int lengthInBits, final Short key) {\n+\n+        final int value1 = prefix.shortValue() << offsetInBits;\n+        final int value2 = key.shortValue();\n+\n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+\n+        return (value1 & mask) == (value2 & mask);\n+    }\n+\n+    @Override\n+    public int compare(final Short o1, final Short o2) {\n+        return o1.compareTo(o2);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/StringKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import org.apache.commons.collections4.trie.KeyAnalyzer;\n+\n+/**\n+ * An {@link KeyAnalyzer} for {@link String}s.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class StringKeyAnalyzer extends KeyAnalyzer<String> {\n+\n+    private static final long serialVersionUID = -7032449491269434877L;\n+\n+    /** A singleton instance of {@link StringKeyAnalyzer}. */\n+    public static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();\n+\n+    /** The number of bits per {@link Character}. */\n+    public static final int LENGTH = Character.SIZE;\n+\n+    /** A bit mask where the first bit is 1 and the others are zero. */\n+    private static final int MSB = 0x8000;\n+\n+    /** Returns a bit mask where the given bit is set. */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+\n+    public int lengthInBits(final String key) {\n+        return key != null ? key.length() * LENGTH : 0;\n+    }\n+\n+    public int bitIndex(final String key, final int offsetInBits, final int lengthInBits,\n+                        final String other, final int otherOffsetInBits, final int otherLengthInBits) {\n+\n+        boolean allNull = true;\n+\n+        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0\n+                || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\"The offsets and lengths must be at Character boundaries\");\n+        }\n+\n+        final int beginIndex1 = offsetInBits / LENGTH;\n+        final int beginIndex2 = otherOffsetInBits / LENGTH;\n+\n+        final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+\n+        final int length = Math.max(endIndex1, endIndex2);\n+\n+        // Look at each character, and if they're different\n+        // then figure out which bit makes the difference\n+        // and return it.\n+        char k = 0, f = 0;\n+        for(int i = 0; i < length; i++) {\n+            final int index1 = beginIndex1 + i;\n+            final int index2 = beginIndex2 + i;\n+\n+            if (index1 >= endIndex1) {\n+                k = 0;\n+            } else {\n+                k = key.charAt(index1);\n+            }\n+\n+            if (other == null || index2 >= endIndex2) {\n+                f = 0;\n+            } else {\n+                f = other.charAt(index2);\n+            }\n+\n+            if (k != f) {\n+               final int x = k ^ f;\n+               return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n+            }\n+\n+            if (k != 0) {\n+                allNull = false;\n+            }\n+        }\n+\n+        // All bits are 0\n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+\n+        // Both keys are equal\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    public boolean isBitSet(final String key, final int bitIndex, final int lengthInBits) {\n+        if (key == null || bitIndex >= lengthInBits) {\n+            return false;\n+        }\n+\n+        final int index = bitIndex / LENGTH;\n+        final int bit = bitIndex % LENGTH;\n+\n+        return (key.charAt(index) & mask(bit)) != 0;\n+    }\n+\n+    public boolean isPrefix(final String prefix, final int offsetInBits,\n+                            final int lengthInBits, final String key) {\n+        if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"Cannot determine prefix outside of Character boundaries\");\n+        }\n+\n+        final String s1 = prefix.substring(offsetInBits / LENGTH, lengthInBits / LENGTH);\n+        return key.startsWith(s1);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/analyzer/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains various {@link org.apache.commons.collections4.trie.KeyAnalyzer} implementations.\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n--- a/src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java\n+++ b/src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java\n import java.util.Map.Entry;\n \n import org.apache.commons.collections4.Trie.Cursor;\n+import org.apache.commons.collections4.trie.analyzer.CharacterKeyAnalyzer;\n+import org.apache.commons.collections4.trie.analyzer.IntegerKeyAnalyzer;\n+import org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer;\n \n import org.junit.Assert;\n import org.junit.Test;\n             }\n         }\n \n+        @SuppressWarnings(\"unused\")\n         void selectFor(final Object object) {\n             selectFor = object;\n         }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/trie/analyzer/ByteArrayKeyAnalyzerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie.analyzer;\n+\n+import java.math.BigInteger;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.trie.PatriciaTrie;\n+import org.apache.commons.collections4.trie.analyzer.ByteArrayKeyAnalyzer;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ByteArrayKeyAnalyzerTest {\n+\n+    private static final int SIZE = 20000;\n+\n+    @Test\n+    public void bitSet() {\n+        final byte[] key = toByteArray(\"10100110\", 2);\n+        final ByteArrayKeyAnalyzer ka = new ByteArrayKeyAnalyzer(key.length * 8);\n+        final int length = ka.lengthInBits(key);\n+\n+        Assert.assertTrue(ka.isBitSet(key, 0, length));\n+        Assert.assertFalse(ka.isBitSet(key, 1, length));\n+        Assert.assertTrue(ka.isBitSet(key, 2, length));\n+        Assert.assertFalse(ka.isBitSet(key, 3, length));\n+        Assert.assertFalse(ka.isBitSet(key, 4, length));\n+        Assert.assertTrue(ka.isBitSet(key, 5, length));\n+        Assert.assertTrue(ka.isBitSet(key, 6, length));\n+        Assert.assertFalse(ka.isBitSet(key, 7, length));\n+    }\n+\n+    @Test\n+    public void keys() {\n+        final PatriciaTrie<byte[], BigInteger> trie\n+            = new PatriciaTrie<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n+\n+        final Map<byte[], BigInteger> map\n+            = new TreeMap<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            final BigInteger value = BigInteger.valueOf(i);\n+            final byte[] key = toByteArray(value);\n+\n+            final BigInteger existing = trie.put(key, value);\n+            Assert.assertNull(existing);\n+\n+            map.put(key, value);\n+        }\n+\n+        Assert.assertEquals(map.size(), trie.size());\n+\n+        for (final byte[] key : map.keySet()) {\n+            final BigInteger expected = new BigInteger(1, key);\n+            final BigInteger value = trie.get(key);\n+\n+            Assert.assertEquals(expected, value);\n+        }\n+    }\n+\n+    @Test\n+    public void prefix() {\n+        final byte[] prefix   = toByteArray(\"00001010\", 2);\n+        final byte[] key1     = toByteArray(\"11001010\", 2);\n+        final byte[] key2     = toByteArray(\"10101100\", 2);\n+\n+        final ByteArrayKeyAnalyzer keyAnalyzer = new ByteArrayKeyAnalyzer(key1.length * 8);\n+\n+        final int prefixLength = keyAnalyzer.lengthInBits(prefix);\n+\n+        Assert.assertFalse(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key1));\n+        Assert.assertTrue(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key2));\n+    }\n+\n+    private static byte[] toByteArray(final String value, final int radix) {\n+        return toByteArray(Long.parseLong(value, radix));\n+    }\n+\n+    private static byte[] toByteArray(final long value) {\n+        return toByteArray(BigInteger.valueOf(value));\n+    }\n+\n+    private static byte[] toByteArray(final BigInteger value) {\n+        final byte[] src = value.toByteArray();\n+        if (src.length <= 1) {\n+            return src;\n+        }\n+\n+        if (src[0] != 0) {\n+            return src;\n+        }\n+\n+        final byte[] dst = new byte[src.length-1];\n+        System.arraycopy(src, 1, dst, 0, dst.length);\n+        return dst;\n+    }\n+}", "timestamp": 1370900779, "metainfo": ""}