{"sha": "9bdfac0fad10c1947768aec9c1ac3645511f6ced", "log": "[COLLECTIONS-433] Improve performance of TreeList#addAll and TreeList(Collection). Thanks to Jeffrey Barnes for the patch.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/list/TreeList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/TreeList.java\n import java.util.ListIterator;\n import java.util.NoSuchElementException;\n \n+import org.apache.commons.collections4.ArrayStack;\n import org.apache.commons.collections4.OrderedIterator;\n \n /**\n  * @since 3.1\n  * @version $Id$\n  */\n+@SuppressWarnings(\"deprecation\") // replace ArrayStack by ArrayDeque when moving to Java 1.6\n public class TreeList<E> extends AbstractList<E> {\n //    add; toArray; iterator; insert; get; indexOf; remove\n //    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n     }\n \n     /**\n-     * Constructs a new empty list that copies the specified list.\n+     * Constructs a new empty list that copies the specified collection.\n      *\n      * @param coll  the collection to copy\n      * @throws NullPointerException if the collection is null\n      */\n     public TreeList(final Collection<E> coll) {\n         super();\n-        addAll(coll);\n+        if (!coll.isEmpty()) {\n+            root = new AVLNode<E>(coll);\n+            size = coll.size();\n+        }        \n     }\n \n     //-----------------------------------------------------------------------\n             root = root.insert(index, obj);\n         }\n         size++;\n+    }\n+\n+    /**\n+     * Appends all of the elements in the specified collection to the end of this list,\n+     * in the order that they are returned by the specified collection's Iterator.\n+     * <p>\n+     * This method runs in O(n + log m) time, where m is\n+     * the size of this list and n is the size of {@code c}.\n+     *\n+     * @param c  the collection to be added to this list\n+     * @return {@code true} if this list changed as a result of the call\n+     * @throws NullPointerException {@inheritDoc}\n+     */\n+    @Override\n+    public boolean addAll(final Collection<? extends E> c) {\n+        if (c.isEmpty()) {\n+            return false;\n+        }\n+        modCount += c.size();\n+        final AVLNode<E> cTree = new AVLNode<E>(c);\n+        root = root == null ? cTree : root.addAll(cTree, size);\n+        size += c.size();\n+        return true;\n     }\n \n     /**\n          * Constructs a new node with a relative position.\n          *\n          * @param relativePosition  the relative position of the node\n-         * @param obj  the value for the ndoe\n+         * @param obj  the value for the node\n          * @param rightFollower the node with the value following this one\n          * @param leftFollower the node with the value leading this one\n          */\n             leftIsPrevious = true;\n             right = rightFollower;\n             left = leftFollower;\n+        }\n+\n+        /**\n+         * Constructs a new AVL tree from a collection.\n+         * <p>\n+         * The collection must be nonempty.\n+         *\n+         * @param coll  a nonempty collection\n+         */\n+        private AVLNode(final Collection<? extends E> coll) {\n+            this(coll.iterator(), 0, coll.size() - 1, 0, null, null);\n+        }\n+\n+        /**\n+         * Constructs a new AVL tree from a collection.\n+         * <p>\n+         * This is a recursive helper for {@link #AVLNode(Collection)}. A call\n+         * to this method will construct the subtree for elements {@code start}\n+         * through {@code end} of the collection, assuming the iterator\n+         * {@code e} already points at element {@code start}.\n+         *\n+         * @param iterator  an iterator over the collection, which should already point\n+         *          to the element at index {@code start} within the collection\n+         * @param start  the index of the first element in the collection that\n+         *          should be in this subtree\n+         * @param end  the index of the last element in the collection that\n+         *          should be in this subtree\n+         * @param absolutePositionOfParent  absolute position of this node's\n+         *          parent, or 0 if this node is the root\n+         * @param prev  the {@code AVLNode} corresponding to element (start - 1)\n+         *          of the collection, or null if start is 0\n+         * @param next  the {@code AVLNode} corresponding to element (end + 1)\n+         *          of the collection, or null if end is the last element of the collection\n+         */\n+        private AVLNode(final Iterator<? extends E> iterator, final int start, final int end,\n+                        final int absolutePositionOfParent, final AVLNode<E> prev, final AVLNode<E> next) {\n+            final int mid = start + (end - start) / 2;\n+            if (start < mid) {\n+                left = new AVLNode<E>(iterator, start, mid - 1, mid, prev, this);\n+            } else {\n+                leftIsPrevious = true;\n+                left = prev;\n+            }\n+            value = iterator.next();\n+            relativePosition = mid - absolutePositionOfParent;\n+            if (mid < end) {\n+                right = new AVLNode<E>(iterator, mid + 1, end, mid, this, next);\n+            } else {\n+                rightIsNext = true;\n+                right = next;\n+            }\n+            recalcHeight();\n         }\n \n         /**\n             rightIsNext = node == null;\n             right = rightIsNext ? next : node;\n             recalcHeight();\n+        }\n+\n+        /**\n+         * Appends the elements of another tree list to this tree list by efficiently\n+         * merging the two AVL trees. This operation is destructive to both trees and\n+         * runs in O(log(m + n)) time.\n+         * \n+         * @param otherTree\n+         *            the root of the AVL tree to merge with this one\n+         * @param currentSize\n+         *            the number of elements in this AVL tree\n+         * @return the root of the new, merged AVL tree\n+         */\n+        private AVLNode<E> addAll(AVLNode<E> otherTree, final int currentSize) {\n+            final AVLNode<E> maxNode = max();\n+            final AVLNode<E> otherTreeMin = otherTree.min();\n+\n+            // We need to efficiently merge the two AVL trees while keeping them\n+            // balanced (or nearly balanced). To do this, we take the shorter\n+            // tree and combine it with a similar-height subtree of the taller\n+            // tree. There are two symmetric cases:\n+            //   * this tree is taller, or\n+            //   * otherTree is taller.\n+            if (otherTree.height > height) {\n+                // CASE 1: The other tree is taller than this one. We will thus\n+                // merge this tree into otherTree.\n+\n+                // STEP 1: Remove the maximum element from this tree.\n+                final AVLNode<E> leftSubTree = removeMax();\n+\n+                // STEP 2: Navigate left from the root of otherTree until we\n+                // find a subtree, s, that is no taller than me. (While we are\n+                // navigating left, we store the nodes we encounter in a stack\n+                // so that we can re-balance them in step 4.)\n+                final ArrayStack<AVLNode<E>> sAncestors = new ArrayStack<AVLNode<E>>();\n+                AVLNode<E> s = otherTree;\n+                int sAbsolutePosition = s.relativePosition + currentSize;\n+                int sParentAbsolutePosition = 0;\n+                while (s != null && s.height > getHeight(leftSubTree)) {\n+                    sParentAbsolutePosition = sAbsolutePosition;\n+                    sAncestors.push(s);\n+                    s = s.left;\n+                    if (s != null) {\n+                        sAbsolutePosition += s.relativePosition;\n+                    }\n+                }\n+\n+                // STEP 3: Replace s with a newly constructed subtree whose root\n+                // is maxNode, whose left subtree is leftSubTree, and whose right\n+                // subtree is s.\n+                maxNode.setLeft(leftSubTree, null);\n+                maxNode.setRight(s, otherTreeMin);\n+                if (leftSubTree != null) {\n+                    leftSubTree.max().setRight(null, maxNode);\n+                    leftSubTree.relativePosition -= currentSize - 1;\n+                }\n+                if (s != null) {\n+                    s.min().setLeft(null, maxNode);\n+                    s.relativePosition = sAbsolutePosition - currentSize + 1;\n+                }\n+                maxNode.relativePosition = currentSize - 1 - sParentAbsolutePosition;\n+                otherTree.relativePosition += currentSize;\n+\n+                // STEP 4: Re-balance the tree and recalculate the heights of s's ancestors.\n+                s = maxNode;\n+                while (!sAncestors.isEmpty()) {\n+                    final AVLNode<E> sAncestor = sAncestors.pop();\n+                    sAncestor.setLeft(s, null);\n+                    s = sAncestor.balance();\n+                }\n+                return s;\n+            } else {\n+                // CASE 2: This tree is taller. This is symmetric to case 1.\n+                // We merge otherTree into this tree by finding a subtree s of this\n+                // tree that is of similar height to otherTree and replacing it\n+                // with a new subtree whose root is otherTreeMin and whose\n+                // children are otherTree and s.\n+\n+                otherTree = otherTree.removeMin();\n+\n+                final ArrayStack<AVLNode<E>> sAncestors = new ArrayStack<AVLNode<E>>();\n+                AVLNode<E> s = this;\n+                int sAbsolutePosition = s.relativePosition;\n+                int sParentAbsolutePosition = 0;\n+                while (s != null && s.height > getHeight(otherTree)) {\n+                    sParentAbsolutePosition = sAbsolutePosition;\n+                    sAncestors.push(s);\n+                    s = s.right;\n+                    if (s != null) {\n+                        sAbsolutePosition += s.relativePosition;\n+                    }\n+                }\n+\n+                otherTreeMin.setRight(otherTree, null);\n+                otherTreeMin.setLeft(s, maxNode);\n+                if (otherTree != null) {\n+                    otherTree.min().setLeft(null, otherTreeMin);\n+                    otherTree.relativePosition++;\n+                }\n+                if (s != null) {\n+                    s.max().setRight(null, otherTreeMin);\n+                    s.relativePosition = sAbsolutePosition - currentSize;\n+                }\n+                otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n+\n+                s = otherTreeMin;\n+                while (!sAncestors.isEmpty()) {\n+                    final AVLNode<E> sAncestor = sAncestors.pop();\n+                    sAncestor.setRight(s, null);\n+                    s = sAncestor.balance();\n+                }\n+                return s;\n+            }\n         }\n \n //      private void checkFaedelung() {\n--- a/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\n  */\n package org.apache.commons.collections4.list;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.ListIterator;\n \n         // previous() after remove() should move to\n         // the element before the one just removed\n         assertEquals(\"A\", li.previous());\n-    }    \n+    }\n+    \n+    public void testIterationOrder() {\n+        // COLLECTIONS-433:\n+        // ensure that the iteration order of elements is correct\n+        // when initializing the TreeList with another collection\n+\n+        for (int size = 1; size < 1000; size++) {\n+            List<Integer> other = new ArrayList<Integer>(size);\n+            for (int i = 0; i < size; i++) {\n+                other.add(i);\n+            }\n+            TreeList<Integer> l = new TreeList<Integer>(other);\n+            ListIterator<Integer> it = l.listIterator();\n+            int i = 0;\n+            while (it.hasNext()) {\n+                Integer val = it.next();\n+                assertEquals(i++, val.intValue());\n+            }\n+            \n+            while (it.hasPrevious()) {\n+                Integer val = it.previous();\n+                assertEquals(--i, val.intValue());\n+            }\n+        }        \n+    }\n+\n+    public void testIterationOrderAfterAddAll() {\n+        // COLLECTIONS-433:\n+        // ensure that the iteration order of elements is correct\n+        // when calling addAll on the TreeList\n+\n+        // to simulate different cases in addAll, do different runs where\n+        // the number of elements already in the list and being added by addAll differ\n+        \n+        int size = 1000;\n+        for (int i = 0; i < 100; i++) {\n+            List<Integer> other = new ArrayList<Integer>(size);\n+            for (int j = i; j < size; j++) {\n+                other.add(j);\n+            }\n+            TreeList<Integer> l = new TreeList<Integer>();\n+            for (int j = 0; j < i; j++) {\n+                l.add(j);\n+            }\n+            \n+            l.addAll(other);\n+\n+            ListIterator<Integer> it = l.listIterator();\n+            int cnt = 0;\n+            while (it.hasNext()) {\n+                Integer val = it.next();\n+                assertEquals(cnt++, val.intValue());\n+            }\n+            \n+            while (it.hasPrevious()) {\n+                Integer val = it.previous();\n+                assertEquals(--cnt, val.intValue());\n+            }\n+        }        \n+    }\n \n }", "timestamp": 1366463474, "metainfo": ""}