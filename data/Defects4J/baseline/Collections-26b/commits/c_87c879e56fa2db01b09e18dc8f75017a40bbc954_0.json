{"sha": "87c879e56fa2db01b09e18dc8f75017a40bbc954", "log": "Allow multiple levels of interpolation bug 25553, from hoschek   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ExtendedProperties.java\n+++ b/src/java/org/apache/commons/collections/ExtendedProperties.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ExtendedProperties.java,v 1.17 2003/10/09 20:58:53 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ExtendedProperties.java,v 1.18 2003/12/29 18:18:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Enumeration;\n import java.util.Hashtable;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.NoSuchElementException;\n import java.util.Properties;\n import java.util.StringTokenizer;\n  * This class extends normal Java properties by adding the possibility\n  * to use the same key many times concatenating the value strings\n  * instead of overwriting them.\n- *\n- * <p>The Extended Properties syntax is explained here:\n+ * <p>\n+ * <b>Please consider using the <code>PropertiesConfiguration</code> class in\n+ * Commons-Configuration as soon as it is released.</b>\n+ * <p>\n+ * The Extended Properties syntax is explained here:\n  *\n  * <ul>\n  *  <li>\n  * it, go ahead and tune it up!\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.17 $ $Date: 2003/10/09 20:58:53 $\n+ * @version $Revision: 1.18 $ $Date: 2003/12/29 18:18:34 $\n  * \n  * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n  * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n     protected final static String START_TOKEN=\"${\";\n     protected final static String END_TOKEN=\"}\";\n \n+\n+    /**\n+     * Interpolate key names to handle ${key} stuff\n+     *\n+     * @param base string to interpolate\n+     * @return returns the key name with the ${key} substituted\n+     */\n     protected String interpolate(String base) {\n+        // COPIED from [configuration] 2003-12-29\n+        return (interpolateHelper(base, null));\n+    }\n+\n+    /**\n+     * Recursive handler for multple levels of interpolation.\n+     *\n+     * When called the first time, priorVariables should be null.\n+     *\n+     * @param base string with the ${key} variables\n+     * @param priorVariables serves two purposes: to allow checking for\n+     * loops, and creating a meaningful exception message should a loop\n+     * occur.  It's 0'th element will be set to the value of base from\n+     * the first call.  All subsequent interpolated variables are added\n+     * afterward.\n+     *\n+     * @return the string with the interpolation taken care of\n+     */\n+    protected String interpolateHelper(String base, List priorVariables) {\n+        // COPIED from [configuration] 2003-12-29\n         if (base == null) {\n             return null;\n         }\n-        \n+\n+        // on the first call initialize priorVariables\n+        // and add base as the first element\n+        if (priorVariables == null) {\n+            priorVariables = new ArrayList();\n+            priorVariables.add(base);\n+        }\n+\n         int begin = -1;\n         int end = -1;\n         int prec = 0 - END_TOKEN.length();\n         String variable = null;\n         StringBuffer result = new StringBuffer();\n-        \n+\n         // FIXME: we should probably allow the escaping of the start token\n-        while ( ((begin=base.indexOf(START_TOKEN,prec+END_TOKEN.length()))>-1)\n-                && ((end=base.indexOf(END_TOKEN,begin))>-1) ) {\n-            result.append(base.substring(prec+END_TOKEN.length(),begin));\n-            variable = base.substring(begin+START_TOKEN.length(),end);\n-            if (get(variable) != null) {\n-                result.append(get(variable));\n-            }\n-            prec=end;\n-        }\n-        result.append(base.substring(prec+END_TOKEN.length(),base.length()));\n-        \n+        while (((begin = base.indexOf(START_TOKEN, prec + END_TOKEN.length())) > -1)\n+            && ((end = base.indexOf(END_TOKEN, begin)) > -1)) {\n+            result.append(base.substring(prec + END_TOKEN.length(), begin));\n+            variable = base.substring(begin + START_TOKEN.length(), end);\n+\n+            // if we've got a loop, create a useful exception message and throw\n+            if (priorVariables.contains(variable)) {\n+                String initialBase = priorVariables.remove(0).toString();\n+                priorVariables.add(variable);\n+                StringBuffer priorVariableSb = new StringBuffer();\n+\n+                // create a nice trace of interpolated variables like so:\n+                // var1->var2->var3\n+                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n+                    priorVariableSb.append(it.next());\n+                    if (it.hasNext()) {\n+                        priorVariableSb.append(\"->\");\n+                    }\n+                }\n+\n+                throw new IllegalStateException(\n+                    \"infinite loop in property interpolation of \" + initialBase + \": \" + priorVariableSb.toString());\n+            }\n+            // otherwise, add this variable to the interpolation list.\n+            else {\n+                priorVariables.add(variable);\n+            }\n+\n+            //QUESTION: getProperty or getPropertyDirect\n+            Object value = getProperty(variable);\n+            if (value != null) {\n+                result.append(interpolateHelper(value.toString(), priorVariables));\n+\n+                // pop the interpolated variable off the stack\n+                // this maintains priorVariables correctness for\n+                // properties with multiple interpolations, e.g.\n+                // prop.name=${some.other.prop1}/blahblah/${some.other.prop2}\n+                priorVariables.remove(priorVariables.size() - 1);\n+            } else if (defaults != null && defaults.getString(variable, null) != null) {\n+                result.append(defaults.getString(variable));\n+            } else {\n+                //variable not defined - so put it back in the value\n+                result.append(START_TOKEN).append(variable).append(END_TOKEN);\n+            }\n+            prec = end;\n+        }\n+        result.append(base.substring(prec + END_TOKEN.length(), base.length()));\n+\n         return result.toString();\n     }\n     ", "timestamp": 1072721914, "metainfo": ""}