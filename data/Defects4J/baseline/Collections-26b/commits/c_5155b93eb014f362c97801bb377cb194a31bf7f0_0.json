{"sha": "5155b93eb014f362c97801bb377cb194a31bf7f0", "log": "added complete JavaDocs, added isLocked() and size() methods, made checkLocked() method private   ", "commit": "\n--- a/src/java/org/apache/commons/collections/comparators/ComparatorChain.java\n+++ b/src/java/org/apache/commons/collections/comparators/ComparatorChain.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/comparators/ComparatorChain.java,v 1.3 2002/03/01 23:48:59 morgand Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/03/01 23:48:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/comparators/ComparatorChain.java,v 1.4 2002/03/04 19:18:56 morgand Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/03/04 19:18:56 $\n  *\n  * ====================================================================\n  *\n  * Object) has been called</i> will result in an\n  * UnsupportedOperationException.</p>\n  * \n- * <p>Instances of ComparatorChain are not synchronized.</p>\n+ * <p>Instances of ComparatorChain are not synchronized.\n+ * The class is not thread-safe at construction time, but\n+ * it <i>is</i> thread-safe to perform multiple comparisons\n+ * after all the setup operations are complete.</p>\n  * \n  * @author Morgan Delagrange\n  */\n     // compare(Object,Object) is called)\n     protected boolean isLocked = false;\n \n+    /**\n+     * Construct a ComparatorChain with a single Comparator,\n+     * sorting in the forward order\n+     * \n+     * @param comparator First comparator in the Comparator chain\n+     */\n     public ComparatorChain(Comparator comparator) {\n         this(comparator,false);\n     }\n \n+    /**\n+     * Construct a Comparator chain with a single Comparator,\n+     * sorting in the given order\n+     * \n+     * @param comparator First Comparator in the ComparatorChain\n+     * @param reverse    false = forward sort; true = reverse sort\n+     */\n     public ComparatorChain(Comparator comparator, boolean reverse) {\n         comparatorChain = new ArrayList();\n         comparatorChain.add(comparator);\n     }\n \n     /**\n-     * \n-     * @param list\n+     * Construct a ComparatorChain from the Comparators in the\n+     * List.  All Comparators will default to the forward \n+     * sort order.\n+     * \n+     * @param list   List of Comparators\n      * @see #ComparatorChain(List,BitSet)\n      */\n     public ComparatorChain(List list) {\n     }\n \n     /**\n-     * \n-     * @param list   NOTE: This constructor performs a defensive\n-     *                     copy of the list elements into a new\n-     *                     List. \n-     * @param bits\n+     * Construct a ComparatorChain from the Comparators in the\n+     * given List.  The sort order of each column will be\n+     * drawn from the given BitSet.  When determining the sort\n+     * order for Comparator at index <i>i</i> in the List,\n+     * the ComparatorChain will call BitSet.get(<i>i</i>).\n+     * If that method returns <i>false</i>, the forward\n+     * sort order is used; a return value of <i>true</i>\n+     * indicates reverse sort order.\n+     * \n+     * @param list   List of Comparators.  NOTE: This constructor performs a\n+     *               defensive copy of the list elements into a new\n+     *               List.\n+     * @param bits   Sort order for each Comparator.  Extra bits are ignored,\n+     *               unless extra Comparators are added by another method.\n      */\n     public ComparatorChain(List list, BitSet bits) {\n         comparatorChain = new ArrayList();\n         orderingBits = bits;\n     }\n \n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * forward sort order\n+     * \n+     * @param comparator Comparator with the forward sort order\n+     */\n     public void addComparator(Comparator comparator) {\n         addComparator(comparator,false);\n     }\n \n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * given sort order\n+     * \n+     * @param comparator Comparator to add to the end of the chain\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n     public void addComparator(Comparator comparator, boolean reverse) {\n         checkLocked();\n         \n         }\n     }\n \n-    public void setComparator(int index, Comparator comparator) {\n+    /**\n+     * Replace the Comparator at the given index, maintaining\n+     * the existing sort order.\n+     * \n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to place at the given index\n+     * @exception IndexOutOfBoundsException\n+     *                   if index < 0 or index > size()\n+     */\n+    public void setComparator(int index, Comparator comparator) \n+    throws IndexOutOfBoundsException {\n         setComparator(index,comparator,false);\n     }\n \n+    /**\n+     * Replace the Comparator at the given index in the\n+     * ComparatorChain, using the given sort order\n+     * \n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to set\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n     public void setComparator(int index, Comparator comparator, boolean reverse) {\n         checkLocked();\n \n         }\n     }\n \n+\n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a forward sort.\n+     * \n+     * @param index  Index of the ComparatorChain\n+     */\n     public void setForwardSort(int index) {\n         checkLocked();\n         orderingBits.clear(index);\n     }\n \n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a reverse sort.\n+     * \n+     * @param index  Index of the ComparatorChain\n+     */\n     public void setReverseSort(int index) {\n         checkLocked();\n         orderingBits.set(index);\n     }\n \n-    public void checkLocked() {\n+    /**\n+     * Number of Comparators in the current ComparatorChain.\n+     * \n+     * @return Comparator count\n+     */\n+    public int size() {\n+        return comparatorChain.size();\n+    }\n+\n+    /**\n+     * Determine if modifications can still be made to the\n+     * ComparatorChain.  ComparatorChains cannot be modified\n+     * once they have performed a comparison.\n+     * \n+     * @return true = ComparatorChain cannot be modified; false = \n+     *         ComparatorChain can still be modified.\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    // throw an exception if the ComparatorChain is locked\n+    private void checkLocked() {\n         if (isLocked == true) {\n             throw new UnsupportedOperationException(\"Comparator ordering cannot be changed after the first comparison is performed\");\n         }", "timestamp": 1015269536, "metainfo": ""}