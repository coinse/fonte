{"sha": "68768dbe425462f0214f33b0dc7768ee40a34983", "log": "Renamed unit tests, removed unused LocalTestNode class.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractArrayListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.collections.list.AbstractListTest;\n+\n+/**\n+ * Abstract test class for ArrayList.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Jason van Zyl\n+ */\n+public abstract class AbstractArrayListTest<E> extends AbstractListTest<E> {\n+\n+    public AbstractArrayListTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract ArrayList<E> makeObject();\n+\n+    //-----------------------------------------------------------------------\n+    public void testNewArrayList() {\n+        ArrayList<E> list = makeObject();\n+        assertTrue(\"New list is empty\", list.isEmpty());\n+        assertEquals(\"New list has size zero\", 0, list.size());\n+\n+        try {\n+            list.get(1);\n+            fail(\"get(int i) should have thrown IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // Expected result\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        ArrayList<E> list = makeObject();\n+        list.add((E) \"First Item\");\n+        list.add((E) \"Last Item\");\n+        assertEquals(\"First item is 'First Item'\", \"First Item\", list.get(0));\n+        assertEquals(\"Last Item is 'Last Item'\", \"Last Item\", list.get(1));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractLinkedListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.list.AbstractListTest;\n+\n+/**\n+ * Tests base {@link java.util.LinkedList} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject()} method.\n+ * <p>\n+ * If your {@link LinkedList} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link List} fails.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Rich Dougherty\n+ */\n+public abstract class AbstractLinkedListTest<T> extends AbstractListTest<T> {\n+\n+    public AbstractLinkedListTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public abstract LinkedList<T> makeObject();\n+\n+    /**\n+     *  Returns the {@link #collection} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the collection field as a List\n+     */\n+    @Override\n+    public LinkedList<T> getCollection() {\n+        return (LinkedList<T>) super.getCollection();\n+    }\n+\n+    /**\n+     *  Returns the {@link #confirmed} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the confirmed field as a List\n+     */\n+    protected LinkedList<T> getConfirmedLinkedList() {\n+        return (LinkedList<T>) getConfirmed();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addFirst(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLinkedListAddFirst() {\n+        if (!isAddSupported()) return;\n+        T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+\n+        resetFull();\n+        getCollection().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addLast(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLinkedListAddLast() {\n+        if (!isAddSupported()) return;\n+        T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+\n+        resetFull();\n+        getCollection().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getFirst()}.\n+     */\n+    public void testLinkedListGetFirst() {\n+        resetEmpty();\n+        try {\n+            getCollection().getFirst();\n+            fail(\"getFirst() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        Object first = getCollection().getFirst();\n+        Object confirmedFirst = getConfirmedLinkedList().getFirst();\n+        assertEquals(\"Result returned by getFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getLast()}.\n+     */\n+    public void testLinkedListGetLast() {\n+        resetEmpty();\n+        try {\n+            getCollection().getLast();\n+            fail(\"getLast() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        Object last = getCollection().getLast();\n+        Object confirmedLast = getConfirmedLinkedList().getLast();\n+        assertEquals(\"Result returned by getLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeFirst()}.\n+     */\n+    public void testLinkedListRemoveFirst() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().removeFirst();\n+            fail(\"removeFirst() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        Object first = getCollection().removeFirst();\n+        Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n+        assertEquals(\"Result returned by removeFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeLast()}.\n+     */\n+    public void testLinkedListRemoveLast() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getCollection().removeLast();\n+            fail(\"removeLast() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        Object last = getCollection().removeLast();\n+        Object confirmedLast = getConfirmedLinkedList().removeLast();\n+        assertEquals(\"Result returned by removeLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Returns an empty {@link LinkedList}.\n+     */\n+    @Override\n+    public Collection<T> makeConfirmedCollection() {\n+        return new LinkedList<T>();\n+    }\n+\n+    /**\n+     *  Returns a full {@link LinkedList}.\n+     */\n+    @Override\n+    public Collection<T> makeConfirmedFullCollection() {\n+        List<T> list = new LinkedList<T>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractObjectTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * Abstract test class for {@link java.lang.Object} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject()} method.\n+ * <p>\n+ * If your {@link Object} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link Object} fails.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Stephen Colebourne\n+ * @author Anonymous\n+ */\n+public abstract class AbstractObjectTest extends BulkTest {\n+\n+    /** Current major release for Collections */\n+    public static final int COLLECTIONS_MAJOR_VERSION = 3;\n+    \n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractObjectTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return the object to test.\n+     * \n+     * @return the object to test\n+     */\n+    public abstract Object makeObject();\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize an \"empty\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsEmptyCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize a \"full\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsFullCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Is serialization testing supported.\n+     * Default is true.\n+     */\n+    public boolean isTestSerialization() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports equals() comparisons.\n+     * This implementation returns true;\n+     */\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testObjectEqualsSelf() {\n+        Object obj = makeObject();\n+        assertEquals(\"A Object should equal itself\", obj, obj);\n+    }\n+\n+    public void testEqualsNull() {\n+        Object obj = makeObject();\n+        assertEquals(false, obj.equals(null)); // make sure this doesn't throw NPE either\n+    }\n+\n+    public void testObjectHashCodeEqualsSelfHashCode() {\n+        Object obj = makeObject();\n+        assertEquals(\"hashCode should be repeatable\", obj.hashCode(), obj.hashCode());\n+    }\n+\n+    public void testObjectHashCodeEqualsContract() {\n+        Object obj1 = makeObject();\n+        if (obj1.equals(obj1)) {\n+            assertEquals(\n+                \"[1] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj1.hashCode());\n+        }\n+        Object obj2 = makeObject();\n+        if (obj1.equals(obj2)) {\n+            assertEquals(\n+                \"[2] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj2.hashCode());\n+            assertTrue(\n+                \"When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true\",\n+                obj2.equals(obj1));\n+        }\n+    }\n+\n+    protected Object serializeDeserialize(Object obj) throws Exception {\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(obj);\n+        out.close();\n+\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        Object dest = in.readObject();\n+        in.close();\n+\n+        return dest;\n+    }\n+\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Object obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            Object dest = serializeDeserialize(obj);\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj))\", obj, dest);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sanity check method, makes sure that any Serializable\n+     * class can be serialized and de-serialized in memory, \n+     * using the handy makeObject() method\n+     * \n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    public void testSimpleSerialization() throws Exception {\n+        Object o = makeObject();\n+        if (o instanceof Serializable && isTestSerialization()) {\n+            byte[] objekt = writeExternalFormToBytes((Serializable) o);\n+            readExternalFormFromBytes(objekt);\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalEmptyCollectionExists() {\n+        if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                String name = getCanonicalEmptyCollectionName(object);\n+                assertTrue(\n+                    \"Canonical empty collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalFullCollectionExists() {\n+        if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                String name = getCanonicalFullCollectionName(object);\n+                assertTrue(\n+                    \"Canonical full collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    // protected implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the version of Collections that this object tries to\n+     * maintain serialization compatibility with. Defaults to 1, the\n+     * earliest Collections version. (Note: some collections did not\n+     * even exist in this version).\n+     * \n+     * This constant makes it possible for TestMap (and other subclasses,\n+     * if necessary) to automatically check SVN for a versionX copy of a\n+     * Serialized object, so we can make sure that compatibility is maintained.\n+     * See, for example, TestMap.getCanonicalFullMapName(Map map).\n+     * Subclasses can override this variable, indicating compatibility\n+     * with earlier Collections versions.\n+     * \n+     * @return The version, or <code>null</code> if this object shouldn't be\n+     * tested for compatibility with previous versions.\n+     */\n+    public String getCompatibilityVersion() {\n+        return \"1\";\n+    }\n+\n+    protected String getCanonicalEmptyCollectionName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(TEST_DATA_PATH);\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".emptyCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    protected String getCanonicalFullCollectionName(Object object) {\n+        StringBuilder retval = new StringBuilder();\n+        retval.append(TEST_DATA_PATH);\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".fullCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Write a Serializable or Externalizable object as\n+     * a file at the given path.  NOT USEFUL as part\n+     * of a unit test; this is just a utility method\n+     * for creating disk-based objects in SVN that can become\n+     * the basis for compatibility tests using\n+     * readExternalFormFromDisk(String path)\n+     * \n+     * @param o Object to serialize\n+     * @param path path to write the serialized Object\n+     * @exception IOException\n+     */\n+    protected void writeExternalFormToDisk(Serializable o, String path) throws IOException {\n+        FileOutputStream fileStream = new FileOutputStream(path);\n+        writeExternalFormToStream(o, fileStream);\n+    }\n+\n+    /**\n+     * Converts a Serializable or Externalizable object to\n+     * bytes.  Useful for in-memory tests of serialization\n+     * \n+     * @param o Object to convert to bytes\n+     * @return serialized form of the Object\n+     * @exception IOException\n+     */\n+    protected byte[] writeExternalFormToBytes(Serializable o) throws IOException {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n+        writeExternalFormToStream(o, byteStream);\n+        return byteStream.toByteArray();\n+    }\n+\n+    /**\n+     * Reads a Serialized or Externalized Object from disk.\n+     * Useful for creating compatibility tests between\n+     * different SVN versions of the same class\n+     * \n+     * @param path path to the serialized Object\n+     * @return the Object at the given path\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromDisk(String path) throws IOException, ClassNotFoundException {\n+        FileInputStream stream = new FileInputStream(path);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    /**\n+     * Read a Serialized or Externalized Object from bytes.\n+     * Useful for verifying serialization in memory.\n+     * \n+     * @param b byte array containing a serialized Object\n+     * @return Object contained in the bytes\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromBytes(byte[] b) throws IOException, ClassNotFoundException {\n+        ByteArrayInputStream stream = new ByteArrayInputStream(b);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    protected boolean skipSerializedCanonicalTests() {\n+        return Boolean.getBoolean(\"org.apache.commons.collections:with-clover\");\n+    }\n+\n+    // private implementation\n+    //-----------------------------------------------------------------------\n+    private Object readExternalFormFromStream(InputStream stream) throws IOException, ClassNotFoundException {\n+        ObjectInputStream oStream = new ObjectInputStream(stream);\n+        return oStream.readObject();\n+    }\n+\n+    private void writeExternalFormToStream(Serializable o, OutputStream stream) throws IOException {\n+        ObjectOutputStream oStream = new ObjectOutputStream(stream);\n+        oStream.writeObject(o);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractTreeMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.map.AbstractTestMap;\n+\n+/**\n+ * Tests TreeMap.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Jason van Zyl\n+ */\n+public abstract class AbstractTreeMapTest<K, V> extends AbstractTestMap<K, V> {\n+\n+    public AbstractTreeMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract TreeMap<K, V> makeObject();\n+\n+    public void testNewMap() {\n+        TreeMap<K, V> map = makeObject();\n+        assertTrue(\"New map is empty\", map.isEmpty());\n+        assertEquals(\"New map has size zero\", 0, map.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        TreeMap<K, V> map = makeObject();\n+        map.put((K) \"first\", (V) \"First Item\");\n+        map.put((K) \"second\", (V) \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\",\n+            \"First Item\", map.get(\"first\"));\n+        assertEquals(\"Next Item is 'First Item'\",\n+            \"Second Item\", map.get(\"second\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/AbstractTypedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Tests TypedCollection.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTypedCollectionTest<T> extends BulkTest {\n+\n+    public AbstractTypedCollectionTest(String name) {\n+        super(name);\n+    }\n+\n+    protected abstract Collection<T> typedCollection();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected Class<T> getType() {\n+        return (Class<T>) String.class;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        Collection<T> c = typedCollection();\n+        Integer i = new Integer(3);\n+        try {\n+            c.add((T) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(i));   \n+    }\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        Collection<T> c = typedCollection();\n+        List<Object> elements = new ArrayList<Object>();\n+        elements.add(\"one\");\n+        elements.add(\"two\");\n+        elements.add(new Integer(3));\n+        elements.add(\"four\");\n+        try {\n+            c.addAll((Collection<? extends T>) elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"one\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"two\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(new Integer(3)));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"four\"));   \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/ArrayStackTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.EmptyStackException;\n+\n+import junit.framework.Test;\n+\n+/**\n+ * Tests ArrayStack.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Craig McClanahan\n+ */\n+public class ArrayStackTest<E> extends AbstractArrayListTest<E> {\n+    \n+    public ArrayStackTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ArrayStackTest.class);\n+    }\n+\n+    @Override\n+    public ArrayStack<E> makeObject() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNewStack() {\n+        ArrayStack<E> stack = makeObject();\n+        assertTrue(\"New stack is empty\", stack.empty());\n+        assertEquals(\"New stack has size zero\", 0, stack.size());\n+\n+        try {\n+            stack.peek();\n+            fail(\"peek() should have thrown EmptyStackException\");\n+        } catch (EmptyStackException e) {\n+            // Expected result\n+        }\n+\n+        try {\n+            stack.pop();\n+            fail(\"pop() should have thrown EmptyStackException\");\n+        } catch (EmptyStackException e) {\n+            // Expected result\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPushPeekPop() {\n+        ArrayStack<E> stack = makeObject();\n+\n+        stack.push((E) \"First Item\");\n+        assertTrue(\"Stack is not empty\", !stack.empty());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+        assertEquals(\"Top item is 'First Item'\",\n+                     \"First Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+\n+        stack.push((E) \"Second Item\");\n+        assertEquals(\"Stack size is two\", 2, stack.size());\n+        assertEquals(\"Top item is 'Second Item'\",\n+                     \"Second Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is two\", 2, stack.size());\n+\n+        assertEquals(\"Popped item is 'Second Item'\",\n+                     \"Second Item\", (String) stack.pop());\n+        assertEquals(\"Top item is 'First Item'\",\n+                     \"First Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+\n+        assertEquals(\"Popped item is 'First Item'\",\n+                     \"First Item\", (String) stack.pop());\n+        assertEquals(\"Stack size is zero\", 0, stack.size());\n+\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        ArrayStack<E> stack = makeObject();\n+\n+        stack.push((E) \"First Item\");\n+        stack.push((E) \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\",\n+                     1, stack.search(\"Second Item\"));\n+        assertEquals(\"Next Item is 'First Item'\",\n+                     2, stack.search(\"First Item\"));\n+        assertEquals(\"Cannot find 'Missing Item'\",\n+                     -1, stack.search(\"Missing Item\"));\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/BagUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.bag.HashBag;\n+import org.apache.commons.collections.bag.PredicatedBag;\n+import org.apache.commons.collections.bag.PredicatedSortedBag;\n+import org.apache.commons.collections.bag.SynchronizedBag;\n+import org.apache.commons.collections.bag.SynchronizedSortedBag;\n+import org.apache.commons.collections.bag.TransformedBag;\n+import org.apache.commons.collections.bag.TransformedSortedBag;\n+import org.apache.commons.collections.bag.TreeBag;\n+import org.apache.commons.collections.bag.UnmodifiableBag;\n+import org.apache.commons.collections.bag.UnmodifiableSortedBag;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Tests for BagUtils factory methods.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class BagUtilsTest extends BulkTest {\n+\n+    public BagUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(BagUtilsTest.class);\n+    }\n+\n+    //----------------------------------------------------------------------\n+\n+    protected Class<?> stringClass = this.getName().getClass();\n+    protected Predicate<Object> truePredicate = TruePredicate.truePredicate();\n+    protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();\n+\n+    //----------------------------------------------------------------------\n+\n+    public void testSynchronizedBag() {\n+        Bag<Object> bag = BagUtils.synchronizedBag(new HashBag<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedBag.\",\n+            bag instanceof SynchronizedBag);\n+        try {\n+            bag = BagUtils.synchronizedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testUnmodifiableBag() {\n+        Bag<Object> bag = BagUtils.unmodifiableBag(new HashBag<Object>());\n+        assertTrue(\"Returned object should be an UnmodifiableBag.\",\n+            bag instanceof UnmodifiableBag);\n+        try {\n+            bag = BagUtils.unmodifiableBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPredicatedBag() {\n+        Bag<Object> bag = BagUtils.predicatedBag(new HashBag<Object>(), truePredicate);\n+        assertTrue(\"Returned object should be a PredicatedBag.\",\n+            bag instanceof PredicatedBag);\n+        try {\n+            bag = BagUtils.predicatedBag(null,truePredicate);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.predicatedBag(new HashBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+     public void testTransformedBag() {\n+        Bag<Object> bag = BagUtils.transformingBag(new HashBag<Object>(), nopTransformer);\n+        assertTrue(\"Returned object should be an TransformedBag.\",\n+            bag instanceof TransformedBag);\n+        try {\n+            bag = BagUtils.transformingBag(null, nopTransformer);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.transformingBag(new HashBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSynchronizedSortedBag() {\n+        Bag<Object> bag = BagUtils.synchronizedSortedBag(new TreeBag<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedSortedBag.\",\n+            bag instanceof SynchronizedSortedBag);\n+        try {\n+            bag = BagUtils.synchronizedSortedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testUnmodifiableSortedBag() {\n+        Bag<Object> bag = BagUtils.unmodifiableSortedBag(new TreeBag<Object>());\n+        assertTrue(\"Returned object should be an UnmodifiableSortedBag.\",\n+            bag instanceof UnmodifiableSortedBag);\n+        try {\n+            bag = BagUtils.unmodifiableSortedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPredicatedSortedBag() {\n+        Bag<Object> bag = BagUtils.predicatedSortedBag(new TreeBag<Object>(), truePredicate);\n+        assertTrue(\"Returned object should be a PredicatedSortedBag.\",\n+            bag instanceof PredicatedSortedBag);\n+        try {\n+            bag = BagUtils.predicatedSortedBag(null, truePredicate);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.predicatedSortedBag(new TreeBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testTransformedSortedBag() {\n+        Bag<Object> bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), nopTransformer);\n+        assertTrue(\"Returned object should be an TransformedSortedBag\",\n+            bag instanceof TransformedSortedBag);\n+        try {\n+            bag = BagUtils.transformingSortedBag(null, nopTransformer);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/BufferUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.buffer.PredicatedBuffer;\n+\n+/**\n+ * Tests for BufferUtils.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Unknown\n+ */\n+public class BufferUtilsTest extends BulkTest {\n+\n+    public BufferUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(BufferUtilsTest.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public void testpredicatedBuffer() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        Buffer<Object> buffer = BufferUtils.predicatedBuffer(new ArrayStack<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedBuffer\",\n+            buffer instanceof PredicatedBuffer);\n+        try {\n+            buffer = BufferUtils.predicatedBuffer(new ArrayStack<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            buffer = BufferUtils.predicatedBuffer(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null buffer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/ClosureUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionClosure;\n+import org.apache.commons.collections.functors.FalsePredicate;\n+import org.apache.commons.collections.functors.NOPClosure;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Tests the org.apache.commons.collections.ClosureUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ClosureUtilsTest extends TestCase {\n+\n+    private static final Object cString = \"Hello\";\n+\n+    /**\n+     * Construct\n+     */\n+    public ClosureUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    static class MockClosure<T> implements Closure<T> {\n+        int count = 0;\n+\n+        public void execute(T object) {\n+            count++;\n+        }\n+\n+        public void reset() {\n+            count = 0;\n+        }\n+    }\n+\n+    static class MockTransformer<T> implements Transformer<T, T> {\n+        int count = 0;\n+\n+        public T transform(T object) {\n+            count++;\n+            return object;\n+        }\n+    }\n+\n+    // exceptionClosure\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionClosure() {\n+        assertNotNull(ClosureUtils.exceptionClosure());\n+        assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());\n+        try {\n+            ClosureUtils.exceptionClosure().execute(null);\n+        } catch (FunctorException ex) {\n+            try {\n+                ClosureUtils.exceptionClosure().execute(cString);\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nopClosure\n+    //------------------------------------------------------------------\n+\n+    public void testNopClosure() {\n+        StringBuilder buf = new StringBuilder(\"Hello\");\n+        ClosureUtils.nopClosure().execute(null);\n+        assertEquals(\"Hello\", buf.toString());\n+        ClosureUtils.nopClosure().execute(\"Hello\");\n+        assertEquals(\"Hello\", buf.toString());\n+    }\n+\n+    // invokeClosure\n+    //------------------------------------------------------------------\n+\n+    public void testInvokeClosure() {\n+        StringBuffer buf = new StringBuffer(\"Hello\"); // Only StringBuffer has setLength() method\n+        ClosureUtils.invokerClosure(\"reverse\").execute(buf);\n+        assertEquals(\"olleH\", buf.toString());\n+        buf = new StringBuffer(\"Hello\");\n+        ClosureUtils.invokerClosure(\"setLength\", new Class[] {Integer.TYPE}, new Object[] {new Integer(2)}).execute(buf);\n+        assertEquals(\"He\", buf.toString());\n+    }\n+\n+    // forClosure\n+    //------------------------------------------------------------------\n+\n+    public void testForClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.forClosure(5, cmd).execute(null);\n+        assertEquals(5, cmd.count);\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure<Object>()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(-1, new MockClosure<Object>()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(1, null));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(3, null));\n+        assertSame(cmd, ClosureUtils.forClosure(1, cmd));\n+    }\n+\n+    // whileClosure\n+    //------------------------------------------------------------------\n+\n+    public void testWhileClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), cmd).execute(null);\n+        assertEquals(0, cmd.count);\n+\n+        cmd = new MockClosure<Object>();\n+        ClosureUtils.whileClosure(PredicateUtils.uniquePredicate(), cmd).execute(null);\n+        assertEquals(1, cmd.count);\n+\n+        try {\n+            ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.whileClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // doWhileClosure\n+    //------------------------------------------------------------------\n+\n+    public void testDoWhileClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.doWhileClosure(cmd, FalsePredicate.falsePredicate()).execute(null);\n+        assertEquals(1, cmd.count);\n+\n+        cmd = new MockClosure<Object>();\n+        ClosureUtils.doWhileClosure(cmd, PredicateUtils.uniquePredicate()).execute(null);\n+        assertEquals(2, cmd.count);\n+\n+        try {\n+            ClosureUtils.doWhileClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // chainedClosure\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testChainedClosure() {\n+        MockClosure<Object> a = new MockClosure<Object>();\n+        MockClosure<Object> b = new MockClosure<Object>();\n+        ClosureUtils.chainedClosure(a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.<Object>chainedClosure(new Closure[] {a, b, a}).execute(null);\n+        assertEquals(2, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        Collection<Closure<Object>> coll = new ArrayList<Closure<Object>>();\n+        coll.add(b);\n+        coll.add(a);\n+        coll.add(b);\n+        ClosureUtils.<Object>chainedClosure(coll).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(2, b.count);\n+\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(new Closure[0]));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(Collections.<Closure<Object>>emptyList()));\n+\n+        try {\n+            ClosureUtils.chainedClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure((Closure[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure(new Closure[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList<Closure<Object>>();\n+            coll.add(null);\n+            coll.add(null);\n+            ClosureUtils.chainedClosure(coll);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // ifClosure\n+    //------------------------------------------------------------------\n+\n+    public void testIfClosure() {\n+        MockClosure<Object> a = new MockClosure<Object>();\n+        MockClosure<Object> b = null;\n+        ClosureUtils.ifClosure(TruePredicate.truePredicate(), a).execute(null);\n+        assertEquals(1, a.count);\n+\n+        a = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a).execute(null);\n+        assertEquals(0, a.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(TruePredicate.<Object>truePredicate(), a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a, b).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+    }\n+\n+    // switchClosure\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSwitchClosure() {\n+        MockClosure<String> a = new MockClosure<String>();\n+        MockClosure<String> b = new MockClosure<String>();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }).execute(\"HELLO\");\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        MockClosure<String> c = new MockClosure<String>();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }, c).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        a.reset();\n+        b.reset();\n+        Map<Predicate<String>, Closure<String>> map = new HashMap<Predicate<String>, Closure<String>>();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        ClosureUtils.<String>switchClosure(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        ClosureUtils.switchClosure(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        c.reset();\n+        map.clear();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        map.put(null, c);\n+        ClosureUtils.switchClosure(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new Predicate[0], new Closure[0]));\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new HashMap<Predicate<String>, Closure<String>>()));\n+        map.clear();\n+        map.put(null, null);\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchClosure(map));\n+\n+        try {\n+            ClosureUtils.switchClosure(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure(\n+                    new Predicate[] { TruePredicate.<String>truePredicate() },\n+                    new Closure[] { a, b });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // switchMapClosure\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchMapClosure() {\n+        MockClosure<String> a = new MockClosure<String>();\n+        MockClosure<String> b = new MockClosure<String>();\n+        Map<String, Closure<String>> map = new HashMap<String, Closure<String>>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ClosureUtils.switchMapClosure(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ClosureUtils.switchMapClosure(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        MockClosure<String> c = new MockClosure<String>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        map.put(null, c);\n+        ClosureUtils.switchMapClosure(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchMapClosure(new HashMap<String, Closure<String>>()));\n+\n+        try {\n+            ClosureUtils.switchMapClosure(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // asClosure\n+    //------------------------------------------------------------------\n+\n+    public void testTransformerClosure() {\n+        MockTransformer<Object> mock = new MockTransformer<Object>();\n+        Closure<Object> closure = ClosureUtils.asClosure(mock);\n+        closure.execute(null);\n+        assertEquals(1, mock.count);\n+        closure.execute(null);\n+        assertEquals(2, mock.count);\n+\n+        assertEquals(ClosureUtils.nopClosure(), ClosureUtils.asClosure(null));\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Closure singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionClosure.INSTANCE,\n+                NOPClosure.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/CollectionUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import static junit.framework.Assert.assertFalse;\n+import static org.apache.commons.collections.functors.EqualPredicate.equalPredicate;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.*;\n+\n+import org.apache.commons.collections.bag.HashBag;\n+import org.apache.commons.collections.buffer.BoundedFifoBuffer;\n+import org.apache.commons.collections.collection.PredicatedCollection;\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+import org.apache.commons.collections.collection.TransformedCollection;\n+import org.apache.commons.collections.collection.UnmodifiableCollection;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Tests for CollectionUtils.\n+ *\n+ * @author Rodney Waldhoff\n+ * @author Matthew Hawthorne\n+ * @author Stephen Colebourne\n+ * @author Phil Steitz\n+ * @author Steven Melzer\n+ * @author Neil O'Toole\n+ * @author Stephen Smith\n+ * @author Stephen Kestle\n+ *\n+ * @version $Revision$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class CollectionUtilsTest extends MockTestCase {\n+\n+    /**\n+     * Collection of {@link Integer}s\n+     */\n+    private List<Integer> collectionA = null;\n+\n+    /**\n+     * Collection of {@link Long}s\n+     */\n+    private List<Long> collectionB = null;\n+\n+    /**\n+     * Collection of {@link Integer}s that are equivalent to the Longs in\n+     * collectionB.\n+     */\n+    private Collection<Integer> collectionC = null;\n+\n+    /**\n+     * Collection of {@link Integer}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionA2 = null;\n+\n+    /**\n+     * Collection of {@link Long}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionB2 = null;\n+\n+    /**\n+     * Collection of {@link Integer}s (cast as {@link Number}s) that are\n+     * equivalent to the Longs in collectionB.\n+     */\n+    private Collection<Number> collectionC2 = null;\n+\n+    private Iterable<Integer> iterableA = null;\n+\n+    private Iterable<Long> iterableB = null;\n+\n+    private Iterable<Integer> iterableC = null;\n+\n+    private Iterable<Number> iterableA2 = null;\n+\n+    private Iterable<Number> iterableB2 = null;\n+\n+    @Before\n+    public void setUp() {\n+        collectionA = new ArrayList<Integer>();\n+        collectionA.add(1);\n+        collectionA.add(2);\n+        collectionA.add(2);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionB = new LinkedList<Long>();\n+        collectionB.add(5L);\n+        collectionB.add(4L);\n+        collectionB.add(4L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+\n+        collectionC = new ArrayList<Integer>();\n+        for (Long l : collectionB) {\n+            collectionC.add(l.intValue());\n+        }\n+\n+        iterableA = collectionA;\n+        iterableB = collectionB;\n+        iterableC = collectionC;\n+        collectionA2 = new ArrayList<Number>(collectionA);\n+        collectionB2 = new LinkedList<Number>(collectionB);\n+        collectionC2 = new LinkedList<Number>(collectionC);\n+        iterableA2 = collectionA2;\n+        iterableB2 = collectionB2;\n+    }\n+\n+    @Test\n+    public void getCardinalityMap() {\n+        Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);\n+        assertEquals(1, (int) freqA.get(1));\n+        assertEquals(2, (int) freqA.get(2));\n+        assertEquals(3, (int) freqA.get(3));\n+        assertEquals(4, (int) freqA.get(4));\n+        assertNull(freqA.get(5));\n+\n+        Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);\n+        assertNull(freqB.get(1L));\n+        assertEquals(4, (int) freqB.get(2L));\n+        assertEquals(3, (int) freqB.get(3L));\n+        assertEquals(2, (int) freqB.get(4L));\n+        assertEquals(1, (int) freqB.get(5L));\n+    }\n+\n+    @Test\n+    public void cardinality() {\n+        assertEquals(1, CollectionUtils.cardinality(1, iterableA));\n+        assertEquals(2, CollectionUtils.cardinality(2, iterableA));\n+        assertEquals(3, CollectionUtils.cardinality(3, iterableA));\n+        assertEquals(4, CollectionUtils.cardinality(4, iterableA));\n+        assertEquals(0, CollectionUtils.cardinality(5, iterableA));\n+\n+        assertEquals(0, CollectionUtils.cardinality(1L, iterableB));\n+        assertEquals(4, CollectionUtils.cardinality(2L, iterableB));\n+        assertEquals(3, CollectionUtils.cardinality(3L, iterableB));\n+        assertEquals(2, CollectionUtils.cardinality(4L, iterableB));\n+        assertEquals(1, CollectionUtils.cardinality(5L, iterableB));\n+\n+        // Ensure that generic bounds accept valid parameters, but return\n+        // expected results\n+        // e.g. no longs in the \"int\" Iterable<Number>, and vice versa.\n+        assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));\n+        assertEquals(0, CollectionUtils.cardinality(2, iterableB2));\n+\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"A\");\n+        set.add(\"C\");\n+        set.add(\"E\");\n+        set.add(\"E\");\n+        assertEquals(1, CollectionUtils.cardinality(\"A\", set));\n+        assertEquals(0, CollectionUtils.cardinality(\"B\", set));\n+        assertEquals(1, CollectionUtils.cardinality(\"C\", set));\n+        assertEquals(0, CollectionUtils.cardinality(\"D\", set));\n+        assertEquals(1, CollectionUtils.cardinality(\"E\", set));\n+\n+        Bag<String> bag = new HashBag<String>();\n+        bag.add(\"A\", 3);\n+        bag.add(\"C\");\n+        bag.add(\"E\");\n+        bag.add(\"E\");\n+        assertEquals(3, CollectionUtils.cardinality(\"A\", bag));\n+        assertEquals(0, CollectionUtils.cardinality(\"B\", bag));\n+        assertEquals(1, CollectionUtils.cardinality(\"C\", bag));\n+        assertEquals(0, CollectionUtils.cardinality(\"D\", bag));\n+        assertEquals(2, CollectionUtils.cardinality(\"E\", bag));\n+    }\n+\n+    @Test\n+    public void cardinalityOfNull() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertNull(freq.get(null));\n+        }\n+        list.add(\"A\");\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertNull(freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(1), freq.get(null));\n+        }\n+        list.add(\"B\");\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(1), freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(2), freq.get(null));\n+        }\n+        list.add(\"B\");\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(2), freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(3, CollectionUtils.cardinality(null, list));\n+        {\n+            Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(3), freq.get(null));\n+        }\n+    }\n+\n+    @Test\n+    public void containsAny() {\n+        Collection<String> empty = new ArrayList<String>(0);\n+        Collection<String> one = new ArrayList<String>(1);\n+        one.add(\"1\");\n+        Collection<String> two = new ArrayList<String>(1);\n+        two.add(\"2\");\n+        Collection<String> three = new ArrayList<String>(1);\n+        three.add(\"3\");\n+        Collection<String> odds = new ArrayList<String>(2);\n+        odds.add(\"1\");\n+        odds.add(\"3\");\n+\n+        assertTrue(\"containsAny({1},{1,3}) should return true.\", CollectionUtils.containsAny(one, odds));\n+        assertTrue(\"containsAny({1,3},{1}) should return true.\", CollectionUtils.containsAny(odds, one));\n+        assertTrue(\"containsAny({3},{1,3}) should return true.\", CollectionUtils.containsAny(three, odds));\n+        assertTrue(\"containsAny({1,3},{3}) should return true.\", CollectionUtils.containsAny(odds, three));\n+        assertTrue(\"containsAny({2},{2}) should return true.\", CollectionUtils.containsAny(two, two));\n+        assertTrue(\"containsAny({1,3},{1,3}) should return true.\", CollectionUtils.containsAny(odds, odds));\n+\n+        assertTrue(\"containsAny({2},{1,3}) should return false.\", !CollectionUtils.containsAny(two, odds));\n+        assertTrue(\"containsAny({1,3},{2}) should return false.\", !CollectionUtils.containsAny(odds, two));\n+        assertTrue(\"containsAny({1},{3}) should return false.\", !CollectionUtils.containsAny(one, three));\n+        assertTrue(\"containsAny({3},{1}) should return false.\", !CollectionUtils.containsAny(three, one));\n+        assertTrue(\"containsAny({1,3},{}) should return false.\", !CollectionUtils.containsAny(odds, empty));\n+        assertTrue(\"containsAny({},{1,3}) should return false.\", !CollectionUtils.containsAny(empty, odds));\n+        assertTrue(\"containsAny({},{}) should return false.\", !CollectionUtils.containsAny(empty, empty));\n+    }\n+\n+    @Test\n+    public void union() {\n+        Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertEquals(Integer.valueOf(4), freq.get(2));\n+        assertEquals(Integer.valueOf(3), freq.get(3));\n+        assertEquals(Integer.valueOf(4), freq.get(4));\n+        assertEquals(Integer.valueOf(1), freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(4), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(4), freq2.get(4));\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+    }\n+\n+    @Test\n+    public void intersection() {\n+        Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertNull(freq.get(1));\n+        assertEquals(Integer.valueOf(2), freq.get(2));\n+        assertEquals(Integer.valueOf(3), freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertNull(freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertNull(freq2.get(5));\n+    }\n+\n+    @Test\n+    public void disjunction() {\n+        Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertEquals(Integer.valueOf(2), freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertEquals(Integer.valueOf(1), freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertNull(freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+    }\n+\n+    @Test\n+    public void testDisjunctionAsUnionMinusIntersection() {\n+        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);\n+        Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));\n+    }\n+\n+    @Test\n+    public void testDisjunctionAsSymmetricDifference() {\n+        Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);\n+        Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);\n+        Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertNull(freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+        assertNull(freq2.get(4));\n+        assertNull(freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertNull(freq2.get(1));\n+    }\n+\n+    @Test\n+    public void testSubtractWithPredicate() {\n+        // greater than 3\n+        Predicate<Number> predicate = new Predicate<Number>() {\n+            public boolean evaluate(Number n) {\n+                return n.longValue() > 3L;\n+            }\n+        };\n+        \n+        Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);\n+        Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertNull(freq2.get(5));\n+    }\n+\n+    @Test\n+    public void testIsSubCollectionOfSelf() {\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n+    public void testIsSubCollection() {\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsSubCollection2() {\n+        Collection<Integer> c = new ArrayList<Integer>();\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(1);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(5);\n+        assertTrue(!CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionToSelf() {\n+        assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isEqualCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollection() {\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionReturnsFalse() {\n+        List<Integer> b = new ArrayList<Integer>(collectionA);\n+        // remove an extra '2', and add a 5.  This will increase the size of the cardinality\n+        b.remove(1);\n+        b.add(5);\n+        assertFalse(CollectionUtils.isEqualCollection(collectionA, b));\n+        assertFalse(CollectionUtils.isEqualCollection(b, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollection2() {\n+        Collection<String> a = new ArrayList<String>();\n+        Collection<String> b = new ArrayList<String>();\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"1\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"2\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"2\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"1\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+    }\n+\n+    @Test\n+    public void testIsProperSubCollection() {\n+        Collection<String> a = new ArrayList<String>();\n+        Collection<String> b = new ArrayList<String>();\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isProperSubCollection(a, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, a));\n+        a.add(\"1\");\n+        a.add(\"2\");\n+        b.add(\"2\");\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n+        a.add(\"1\");\n+        assertTrue(CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.intersection(collectionA, collectionC), collectionA));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.subtract(a, b), a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, CollectionUtils.subtract(a, b)));\n+    }\n+\n+    @Test\n+    public void find() {\n+        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n+        Integer test = CollectionUtils.find(collectionA, testPredicate);\n+        assertTrue(test.equals(4));\n+        testPredicate = equalPredicate((Number) 45);\n+        test = CollectionUtils.find(collectionA, testPredicate);\n+        assertTrue(test == null);\n+        assertNull(CollectionUtils.find(null,testPredicate));\n+        assertNull(CollectionUtils.find(collectionA, null));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void forAllDoCollection() {\n+        Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        col.add(collectionA);\n+        col.add(collectionB);\n+        Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col, testClosure);\n+        assertSame(testClosure, resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        // fix for various java 1.6 versions: keep the cast\n+        resultClosure = CollectionUtils.forAllDo(col, (Closure<List<? extends Number>>) null);\n+        assertNull(resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo((Collection) null, testClosure);\n+        col.add(null);\n+        // null should be OK\n+        CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void forAllDoIterator() {\n+        Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        col.add(collectionA);\n+        col.add(collectionB);\n+        Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col.iterator(), testClosure);\n+        assertSame(testClosure, resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        // fix for various java 1.6 versions: keep the cast\n+        resultClosure = CollectionUtils.forAllDo(col.iterator(), (Closure<List<? extends Number>>) null);\n+        assertNull(resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo((Iterator) null, testClosure);\n+        col.add(null);\n+        // null should be OK\n+        CollectionUtils.forAllDo(col.iterator(), testClosure);\n+    }\n+    \n+    @Test(expected = FunctorException.class)\n+    public void forAllDoFailure() {\n+        Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        Collection<String> col = new ArrayList<String>();\n+        col.add(\"x\");\n+        CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @Test\n+    public void getFromMap() {\n+        // Unordered map, entries exist\n+        Map<String, String> expected = new HashMap<String, String>();\n+        expected.put(\"zeroKey\", \"zero\");\n+        expected.put(\"oneKey\", \"one\");\n+\n+        Map<String, String> found = new HashMap<String, String>();\n+        Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);\n+        found.put(entry.getKey(), entry.getValue());\n+        entry = CollectionUtils.get(expected, 1);\n+        found.put(entry.getKey(), entry.getValue());\n+        assertEquals(expected, found);\n+\n+        // Map index out of range\n+        try {\n+            CollectionUtils.get(expected, 2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            CollectionUtils.get(expected, -2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        // Sorted map, entries exist, should respect order\n+        SortedMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"zeroKey\", \"zero\");\n+        map.put(\"oneKey\", \"one\");\n+        Map.Entry<String, String> test = CollectionUtils.get(map, 1);\n+        assertEquals(\"zeroKey\", test.getKey());\n+        assertEquals(\"zero\", test.getValue());\n+        test = CollectionUtils.get(map, 0);\n+        assertEquals(\"oneKey\", test.getKey());\n+        assertEquals(\"one\", test.getValue());\n+    }\n+\n+    /**\n+     * Tests that {@link List}s are handled correctly - e.g. using\n+     * {@link List#get(int)}.\n+     */\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getFromList() throws Exception {\n+        // List, entry exists\n+        List<String> list = createMock(List.class);\n+        expect(list.get(0)).andReturn(\"zero\");\n+        expect(list.get(1)).andReturn(\"one\");\n+        replay();\n+        String string = CollectionUtils.get(list, 0);\n+        assertEquals(\"zero\", string);\n+        assertEquals(\"one\", CollectionUtils.get(list, 1));\n+        // list, non-existent entry -- IndexOutOfBoundsException\n+        CollectionUtils.get(new ArrayList<Object>(), 2);\n+    }\n+\n+    @Test\n+    public void getFromIterator() throws Exception {\n+        // Iterator, entry exists\n+        Iterator<Integer> iterator = iterableA.iterator();\n+        assertEquals(1, (int) CollectionUtils.get(iterator, 0));\n+        iterator = iterableA.iterator();\n+        assertEquals(2, (int) CollectionUtils.get(iterator, 1));\n+\n+        // Iterator, non-existent entry\n+        try {\n+            CollectionUtils.get(iterator, 10);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!iterator.hasNext());\n+    }\n+\n+    @Test\n+    public void getFromEnumeration() throws Exception {\n+        // Enumeration, entry exists\n+        Vector<String> vector = new Vector<String>();\n+        vector.addElement(\"zero\");\n+        vector.addElement(\"one\");\n+        Enumeration<String> en = vector.elements();\n+        assertEquals(\"zero\", CollectionUtils.get(en, 0));\n+        en = vector.elements();\n+        assertEquals(\"one\", CollectionUtils.get(en, 1));\n+\n+        // Enumerator, non-existent entry\n+        try {\n+            CollectionUtils.get(en, 3);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!en.hasMoreElements());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromIterable() throws Exception {\n+        // Collection, entry exists\n+        Bag<String> bag = new HashBag<String>();\n+        bag.add(\"element\", 1);\n+        assertEquals(\"element\", CollectionUtils.get(bag, 0));\n+\n+        // Collection, non-existent entry\n+        CollectionUtils.get(bag, 1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromObjectArray() throws Exception {\n+        // Object array, entry exists\n+        Object[] objArray = new Object[2];\n+        objArray[0] = \"zero\";\n+        objArray[1] = \"one\";\n+        assertEquals(\"zero\", CollectionUtils.get(objArray, 0));\n+        assertEquals(\"one\", CollectionUtils.get(objArray, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(objArray, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromPrimativeArray() throws Exception {\n+        // Primitive array, entry exists\n+        int[] array = new int[2];\n+        array[0] = 10;\n+        array[1] = 20;\n+        assertEquals(10, CollectionUtils.get(array, 0));\n+        assertEquals(20, CollectionUtils.get(array, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(array, 2);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void getFromObject() throws Exception {\n+        // Invalid object\n+        Object obj = new Object();\n+        CollectionUtils.get(obj, 0);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testSize_List() {\n+        List<String> list = null;\n+        assertEquals(0, CollectionUtils.size(list));\n+        list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.size(list));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list));\n+    }\n+\n+    @Test\n+    public void testSize_Map() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        assertEquals(0, CollectionUtils.size(map));\n+        map.put(\"1\", \"a\");\n+        assertEquals(1, CollectionUtils.size(map));\n+        map.put(\"2\", \"b\");\n+        assertEquals(2, CollectionUtils.size(map));\n+    }\n+\n+    @Test\n+    public void testSize_Array() {\n+        Object[] objectArray = new Object[0];\n+        assertEquals(0, CollectionUtils.size(objectArray));\n+\n+        String[] stringArray = new String[3];\n+        assertEquals(3, CollectionUtils.size(stringArray));\n+        stringArray[0] = \"a\";\n+        stringArray[1] = \"b\";\n+        stringArray[2] = \"c\";\n+        assertEquals(3, CollectionUtils.size(stringArray));\n+    }\n+\n+    @Test\n+    public void testSize_PrimitiveArray() {\n+        int[] intArray = new int[0];\n+        assertEquals(0, CollectionUtils.size(intArray));\n+\n+        double[] doubleArray = new double[3];\n+        assertEquals(3, CollectionUtils.size(doubleArray));\n+        doubleArray[0] = 0.0d;\n+        doubleArray[1] = 1.0d;\n+        doubleArray[2] = 2.5d;\n+        assertEquals(3, CollectionUtils.size(doubleArray));\n+    }\n+\n+    @Test\n+    public void testSize_Enumeration() {\n+        Vector<String> list = new Vector<String>();\n+        assertEquals(0, CollectionUtils.size(list.elements()));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list.elements()));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list.elements()));\n+    }\n+\n+    @Test\n+    public void testSize_Iterator() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.size(list.iterator()));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list.iterator()));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list.iterator()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testSize_Other() {\n+        CollectionUtils.size(\"not a list\");\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testSizeIsEmpty_Null() {\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(null));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_List() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Map() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(map));\n+        map.put(\"1\", \"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(map));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Array() {\n+        Object[] objectArray = new Object[0];\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(objectArray));\n+\n+        String[] stringArray = new String[3];\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n+        stringArray[0] = \"a\";\n+        stringArray[1] = \"b\";\n+        stringArray[2] = \"c\";\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_PrimitiveArray() {\n+        int[] intArray = new int[0];\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(intArray));\n+\n+        double[] doubleArray = new double[3];\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n+        doubleArray[0] = 0.0d;\n+        doubleArray[1] = 1.0d;\n+        doubleArray[2] = 2.5d;\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Enumeration() {\n+        Vector<String> list = new Vector<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list.elements()));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list.elements()));\n+        Enumeration<String> en = list.elements();\n+        en.nextElement();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(en));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Iterator() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list.iterator()));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list.iterator()));\n+        Iterator<String> it = list.iterator();\n+        it.next();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(it));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Other() {\n+        try {\n+            CollectionUtils.sizeIsEmpty(\"not a list\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testIsEmptyWithEmptyCollection() {\n+        Collection<Object> coll = new ArrayList<Object>();\n+        assertEquals(true, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsEmptyWithNonEmptyCollection() {\n+        Collection<String> coll = new ArrayList<String>();\n+        coll.add(\"item\");\n+        assertEquals(false, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsEmptyWithNull() {\n+        Collection<?> coll = null;\n+        assertEquals(true, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithEmptyCollection() {\n+        Collection<Object> coll = new ArrayList<Object>();\n+        assertEquals(false, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithNonEmptyCollection() {\n+        Collection<String> coll = new ArrayList<String>();\n+        coll.add(\"item\");\n+        assertEquals(true, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithNull() {\n+        Collection<?> coll = null;\n+        assertEquals(false, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n+        public boolean evaluate(Number input) {\n+            return (input.intValue() == 2);\n+        }\n+    };\n+\n+//Up to here\n+    @SuppressWarnings(\"cast\")\n+    @Test\n+    public void filter() {\n+        List<Integer> ints = new ArrayList<Integer>();\n+        ints.add(1);\n+        ints.add(2);\n+        ints.add(3);\n+        ints.add(3);\n+        Iterable<Integer> iterable = ints;\n+        assertTrue(CollectionUtils.filter(iterable, EQUALS_TWO));\n+        assertEquals(1, (int) ints.size());\n+        assertEquals(2, (int) ints.get(0));\n+    }\n+\n+    @Test\n+    public void filterNullParameters() throws Exception {\n+        List<Long> longs = Collections.nCopies(4, 10L);\n+        assertFalse(CollectionUtils.filter(longs, null));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filter(null, EQUALS_TWO));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filter(null, null));\n+        assertEquals(4, longs.size());\n+    }\n+\n+    @Test\n+    public void countMatches() {\n+        assertEquals(4, CollectionUtils.countMatches(iterableB, EQUALS_TWO));\n+        assertEquals(0, CollectionUtils.countMatches(iterableA, null));\n+        assertEquals(0, CollectionUtils.countMatches(null, EQUALS_TWO));\n+        assertEquals(0, CollectionUtils.countMatches(null, null));\n+    }\n+\n+    @Test\n+    public void exists() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        assertFalse(CollectionUtils.exists(null, null));\n+        assertFalse(CollectionUtils.exists(list, null));\n+        assertFalse(CollectionUtils.exists(null, EQUALS_TWO));\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+        list.add(1);\n+        list.add(3);\n+        list.add(4);\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+\n+        list.add(2);\n+        assertEquals(true, CollectionUtils.exists(list, EQUALS_TWO));\n+    }\n+\n+    @Test\n+    public void select() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        // Ensure that the collection is the input type or a super type\n+        Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);\n+        Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);\n+        HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(1, output1.size());\n+        assertEquals(2, output2.iterator().next());\n+    }\n+\n+    @Test\n+    public void selectRejected() {\n+        List<Long> list = new ArrayList<Long>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        list.add(4L);\n+        Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(3, output1.size());\n+        assertTrue(output1.contains(1L));\n+        assertTrue(output1.contains(3L));\n+        assertTrue(output1.contains(4L));\n+    }\n+\n+    @Test\n+    public void collect() {\n+        Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);\n+        Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertCollectResult(collection);\n+\n+        ArrayList<Number> list;\n+        list = CollectionUtils.collect(collectionA, transformer, new ArrayList<Number>());\n+        assertTrue(list.size() == collectionA.size());\n+        assertCollectResult(list);\n+\n+        Iterator<Integer> iterator = null;\n+        list = CollectionUtils.collect(iterator, transformer, new ArrayList<Number>());\n+\n+        iterator = iterableA.iterator();\n+        list = CollectionUtils.collect(iterator, transformer, list);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertCollectResult(collection);\n+\n+        iterator = collectionA.iterator();\n+        collection = CollectionUtils.<Integer, Number>collect(iterator, transformer);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+        collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);\n+        assertTrue(collection.size() == 0);\n+\n+        int size = collectionA.size();\n+        collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n+        CollectionUtils.collect(collectionB, null, collectionA);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n+\n+    }\n+\n+    private void assertCollectResult(Collection<Number> collection) {\n+        assertTrue(collectionA.contains(1) && !collectionA.contains(2L));\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+    }\n+\n+    Transformer<Object, Integer> TRANSFORM_TO_INTEGER = new Transformer<Object, Integer>() {\n+        public Integer transform(Object input) {\n+            return new Integer(((Long)input).intValue());\n+        }\n+    };\n+\n+    @Test\n+    public void transform1() {\n+        List<Number> list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        CollectionUtils.transform(list, TRANSFORM_TO_INTEGER);\n+        assertEquals(3, list.size());\n+        assertEquals(1, list.get(0));\n+        assertEquals(2, list.get(1));\n+        assertEquals(3, list.get(2));\n+\n+        list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        CollectionUtils.transform(null, TRANSFORM_TO_INTEGER);\n+        assertEquals(3, list.size());\n+        CollectionUtils.transform(list, null);\n+        assertEquals(3, list.size());\n+        CollectionUtils.transform(null, null);\n+        assertEquals(3, list.size());\n+    }\n+\n+    @Test\n+    public void transform2() {\n+        Set<Number> set = new HashSet<Number>();\n+        set.add(1L);\n+        set.add(2L);\n+        set.add(3L);\n+        CollectionUtils.transform(set, new Transformer<Object, Integer>() {\n+            public Integer transform(Object input) {\n+                return 4;\n+            }\n+        });\n+        assertEquals(1, set.size());\n+        assertEquals(4, set.iterator().next());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void addIgnoreNull() {\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        assertFalse(CollectionUtils.addIgnoreNull(set, null));\n+        assertEquals(3, set.size());\n+        assertFalse(CollectionUtils.addIgnoreNull(set, \"1\"));\n+        assertEquals(3, set.size());\n+        assertEquals(true, CollectionUtils.addIgnoreNull(set, \"4\"));\n+        assertEquals(4, set.size());\n+        assertEquals(true, set.contains(\"4\"));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void predicatedCollection() {\n+        Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n+        Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection);\n+        try {\n+            collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            CollectionUtils.predicatedCollection(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void isFull() {\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        try {\n+            CollectionUtils.isFull(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+        assertFalse(CollectionUtils.isFull(set));\n+\n+        BoundedFifoBuffer<String> buf = new BoundedFifoBuffer<String>(set);\n+        assertEquals(true, CollectionUtils.isFull(buf));\n+        buf.remove(\"2\");\n+        assertFalse(CollectionUtils.isFull(buf));\n+        buf.add(\"2\");\n+        assertEquals(true, CollectionUtils.isFull(buf));\n+\n+        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n+        assertEquals(true, CollectionUtils.isFull(buf2));\n+        buf2.remove(\"2\");\n+        assertFalse(CollectionUtils.isFull(buf2));\n+        buf2.add(\"2\");\n+        assertEquals(true, CollectionUtils.isFull(buf2));\n+    }\n+\n+    @Test\n+    public void isEmpty() {\n+        assertFalse(CollectionUtils.isNotEmpty(null));\n+        assertTrue(CollectionUtils.isNotEmpty(collectionA));\n+    }\n+\n+    @Test\n+    public void maxSize() {\n+        Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        try {\n+            CollectionUtils.maxSize(null);\n+            fail();\n+        } catch (NullPointerException ex) {\n+        }\n+        assertEquals(-1, CollectionUtils.maxSize(set));\n+\n+        Buffer<String> buf = new BoundedFifoBuffer<String>(set);\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+        buf.remove(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+        buf.add(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+\n+        Buffer<String> buf2 = BufferUtils.synchronizedBuffer(buf);\n+        assertEquals(3, CollectionUtils.maxSize(buf2));\n+        buf2.remove(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf2));\n+        buf2.add(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf2));\n+    }\n+\n+    @Test\n+    public void intersectionUsesMethodEquals() {\n+        // Let elta and eltb be objects...\n+        Integer elta = new Integer(17);\n+        Integer eltb = new Integer(17);\n+\n+        // ...which are equal...\n+        assertEquals(elta, eltb);\n+        assertEquals(eltb, elta);\n+\n+        // ...but not the same (==).\n+        assertTrue(elta != eltb);\n+\n+        // Let cola and colb be collections...\n+        Collection<Number> cola = new ArrayList<Number>();\n+        Collection<Integer> colb = new ArrayList<Integer>();\n+\n+        // ...which contain elta and eltb,\n+        // respectively.\n+        cola.add(elta);\n+        colb.add(eltb);\n+\n+        // Then the intersection of the two\n+        // should contain one element.\n+        Collection<Number> intersection = CollectionUtils.intersection(cola, colb);\n+        assertEquals(1, intersection.size());\n+\n+        // In practice, this element will be the same (==) as elta\n+        // or eltb, although this isn't strictly part of the\n+        // contract.\n+        Object eltc = intersection.iterator().next();\n+        assertTrue((eltc == elta && eltc != eltb) || (eltc != elta && eltc == eltb));\n+\n+        // In any event, this element remains equal,\n+        // to both elta and eltb.\n+        assertEquals(elta, eltc);\n+        assertEquals(eltc, elta);\n+        assertEquals(eltb, eltc);\n+        assertEquals(eltc, eltb);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    //Up to here\n+    @Test\n+    public void testRetainAll() {\n+        List<String> base = new ArrayList<String>();\n+        base.add(\"A\");\n+        base.add(\"B\");\n+        base.add(\"C\");\n+        List<Object> sub = new ArrayList<Object>();\n+        sub.add(\"A\");\n+        sub.add(\"C\");\n+        sub.add(\"X\");\n+\n+        Collection<String> result = CollectionUtils.retainAll(base, sub);\n+        assertEquals(2, result.size());\n+        assertEquals(true, result.contains(\"A\"));\n+        assertFalse(result.contains(\"B\"));\n+        assertEquals(true, result.contains(\"C\"));\n+        assertEquals(3, base.size());\n+        assertEquals(true, base.contains(\"A\"));\n+        assertEquals(true, base.contains(\"B\"));\n+        assertEquals(true, base.contains(\"C\"));\n+        assertEquals(3, sub.size());\n+        assertEquals(true, sub.contains(\"A\"));\n+        assertEquals(true, sub.contains(\"C\"));\n+        assertEquals(true, sub.contains(\"X\"));\n+\n+        try {\n+            CollectionUtils.retainAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    @Test\n+    public void testRemoveAll() {\n+        List<String> base = new ArrayList<String>();\n+        base.add(\"A\");\n+        base.add(\"B\");\n+        base.add(\"C\");\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(\"A\");\n+        sub.add(\"C\");\n+        sub.add(\"X\");\n+\n+        Collection<String> result = CollectionUtils.removeAll(base, sub);\n+        assertEquals(1, result.size());\n+        assertFalse(result.contains(\"A\"));\n+        assertEquals(true, result.contains(\"B\"));\n+        assertFalse(result.contains(\"C\"));\n+        assertEquals(3, base.size());\n+        assertEquals(true, base.contains(\"A\"));\n+        assertEquals(true, base.contains(\"B\"));\n+        assertEquals(true, base.contains(\"C\"));\n+        assertEquals(3, sub.size());\n+        assertEquals(true, sub.contains(\"A\"));\n+        assertEquals(true, sub.contains(\"C\"));\n+        assertEquals(true, sub.contains(\"X\"));\n+\n+        try {\n+            CollectionUtils.removeAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testTransformedCollection() {\n+        Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n+        Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), transformer);\n+        assertTrue(\"returned object should be a TransformedCollection\", collection instanceof TransformedCollection);\n+        try {\n+            collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            collection = CollectionUtils.transformingCollection(null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testTransformedCollection_2() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);\n+        assertEquals(true, result.contains(\"1\")); // untransformed\n+        assertEquals(true, result.contains(\"2\")); // untransformed\n+        assertEquals(true, result.contains(\"3\")); // untransformed\n+    }\n+\n+    @Test\n+    public void testSynchronizedCollection() {\n+        Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedCollection.\", col instanceof SynchronizedCollection);\n+        try {\n+            col = CollectionUtils.synchronizedCollection(null);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testUnmodifiableCollection() {\n+        Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a UnmodifiableCollection.\", col instanceof UnmodifiableCollection);\n+        try {\n+            col = CollectionUtils.unmodifiableCollection(null);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void emptyCollection() throws Exception {\n+        Collection<Number> coll = CollectionUtils.emptyCollection();\n+        assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);\n+    }\n+\n+    /**\n+     * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.\n+     * Specifically, it uses mocks to ensure that if the passed in\n+     * {@link Iterable} is a {@link Collection} then\n+     * {@link Collection#addAll(Collection)} is called instead of iterating.\n+     */\n+    @Test\n+    public void addAllForIterable() {\n+        Collection<Integer> inputCollection = createMock(Collection.class);\n+        Iterable<Integer> inputIterable = inputCollection;\n+        Iterable<Long> iterable = createMock(Iterable.class);\n+        Iterator<Long> iterator = createMock(Iterator.class);\n+        Collection<Number> c = createMock(Collection.class);\n+\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        next(iterator, 2L);\n+        next(iterator, 3L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(true);\n+        expect(c.add(2L)).andReturn(true);\n+        expect(c.add(3L)).andReturn(true);\n+        // Check that the collection is added using\n+        // Collection.addAll(Collection)\n+        expect(c.addAll(inputCollection)).andReturn(true);\n+\n+        // Ensure the method returns false if nothing is added\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(false);\n+        expect(c.addAll(inputCollection)).andReturn(false);\n+\n+        replay();\n+        assertTrue(CollectionUtils.addAll(c, iterable));\n+        assertTrue(CollectionUtils.addAll(c, inputIterable));\n+\n+        assertFalse(CollectionUtils.addAll(c, iterable));\n+        assertFalse(CollectionUtils.addAll(c, inputIterable));\n+        verify();\n+    }\n+\n+    @Test\n+    public void addAllForEnumeration() {\n+        Hashtable<Integer, Integer> h = new Hashtable<Integer, Integer>();\n+        h.put(5, 5);\n+        Enumeration<? extends Integer> enumeration = h.keys();\n+        CollectionUtils.addAll(collectionA, enumeration);\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test\n+    public void addAllForElements() {\n+        CollectionUtils.addAll(collectionA, new Integer[]{5});\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getNegative() {\n+        CollectionUtils.get((Object)collectionA, -3);\n+    }\n+\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getPositiveOutOfBounds() {\n+        CollectionUtils.get((Object)collectionA.iterator(), 30);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void get1() {\n+        CollectionUtils.get((Object)null, 0);\n+    }\n+\n+    @Test\n+    public void get() {\n+        assertEquals(2, CollectionUtils.get((Object)collectionA, 2));\n+        assertEquals(2, CollectionUtils.get((Object)collectionA.iterator(), 2));\n+        Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);\n+        assertEquals(map.entrySet().iterator().next(), CollectionUtils.get(\n+                (Object)map, 0));\n+    }\n+\n+    /**\n+     * TODO: Should {@link CollectionUtils} be able to be extended? If it is extended, subclasses must 'override' the static methods with\n+     * call-throughs anyhow, otherwise java compiler warnings will result\n+     */\n+    @Test\n+    public void ensureCollectionUtilsCanBeExtended() {\n+        new CollectionUtils() {};\n+    }\n+\n+    @Test\n+    public void reverse() {\n+        CollectionUtils.reverseArray(new Object[] {});\n+        Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);\n+        CollectionUtils.reverseArray(a);\n+        // assume our implementation is correct if it returns the same order as the Java function\n+        Collections.reverse(collectionA);\n+        assertEquals(collectionA, Arrays.asList(a));\n+    }\n+\n+    @Test\n+    public void extractSingleton() {\n+        ArrayList<String> coll = null;\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(null)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        coll = new ArrayList<String>();\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(empty)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        coll.add(\"foo\");\n+        assertEquals(\"foo\", CollectionUtils.extractSingleton(coll));\n+        coll.add(\"bar\");\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(size == 2)\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    /**\n+     * Records the next object returned for a mock iterator\n+     */\n+    private <T> void next(Iterator<T> iterator, T t) {\n+        expect(iterator.hasNext()).andReturn(true);\n+        expect(iterator.next()).andReturn(t);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/EnumerationUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+\n+/**\n+ * Tests EnumerationUtils.\n+ *\n+ * @author <a href=\"mailto:ggregory@seagullsw.com\">Gary Gregory</a>\n+ * @version $Id$\n+ */\n+public class EnumerationUtilsTest extends BulkTest {\n+\n+    public EnumerationUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static final String TO_LIST_FIXTURE = \"this is a test\";\n+    \n+    public void testToListWithStringTokenizer() {\n+        List<String> expectedList1 = new ArrayList<String>();\n+        StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n+             while (st.hasMoreTokens()) {\n+                 expectedList1.add(st.nextToken());\n+             }\n+        List<String> expectedList2 = new ArrayList<String>();\n+        expectedList2.add(\"this\");\n+        expectedList2.add(\"is\");\n+        expectedList2.add(\"a\");\n+        expectedList2.add(\"test\");\n+        List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n+        Assert.assertEquals(expectedList1, expectedList2);\n+        Assert.assertEquals(expectedList1, actualList);\n+        Assert.assertEquals(expectedList2, actualList);\n+    }\n+\n+    public void testToListWithHashtable() {\n+        Hashtable<String, Integer> expected = new Hashtable<String, Integer>();\n+        expected.put(\"one\", new Integer(1));\n+        expected.put(\"two\", new Integer(2));\n+        expected.put(\"three\", new Integer(3));\n+        // validate elements.\n+        List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());\n+        Assert.assertEquals(expected.size(), actualEltList.size());\n+        Assert.assertTrue(actualEltList.contains(new Integer(1)));\n+        Assert.assertTrue(actualEltList.contains(new Integer(2)));\n+        Assert.assertTrue(actualEltList.contains(new Integer(3)));\n+        List<Integer> expectedEltList = new ArrayList<Integer>();\n+        expectedEltList.add(new Integer(1));\n+        expectedEltList.add(new Integer(2));\n+        expectedEltList.add(new Integer(3));\n+        Assert.assertTrue(actualEltList.containsAll(expectedEltList));\n+\n+        // validate keys.\n+        List<String> actualKeyList = EnumerationUtils.toList(expected.keys());\n+        Assert.assertEquals(expected.size(), actualEltList.size());\n+        Assert.assertTrue(actualKeyList.contains(\"one\"));\n+        Assert.assertTrue(actualKeyList.contains(\"two\"));\n+        Assert.assertTrue(actualKeyList.contains(\"three\"));\n+        List<String> expectedKeyList = new ArrayList<String>();\n+        expectedKeyList.add(\"one\");\n+        expectedKeyList.add(\"two\");\n+        expectedKeyList.add(\"three\");\n+        Assert.assertTrue(actualKeyList.containsAll(expectedKeyList));\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(EnumerationUtilsTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/ExtendedPropertiesTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.Properties;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests some basic functions of the ExtendedProperties class.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Geir Magnusson Jr.\n+ * @author Mohan Kishore\n+ * @author Stephen Colebourne\n+ * @author Shinobu Kawai\n+ * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n+ */\n+public class ExtendedPropertiesTest extends TestCase {\n+    \n+    protected ExtendedProperties eprop = new ExtendedProperties();\n+\n+    public ExtendedPropertiesTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testRetrieve() {\n+        /*\n+         * should be empty and return null\n+         */\n+        assertNull(\"This returns null\", eprop.getProperty(\"foo\"));\n+\n+        /*\n+         *  add a real value, and get it two different ways\n+         */\n+        eprop.setProperty(\"number\", \"1\");\n+        assertEquals(\"This returns '1'\", \"1\", eprop.getProperty(\"number\"));\n+        assertEquals(\"This returns '1'\", \"1\", eprop.getString(\"number\"));\n+\n+        /*\n+         * now add another and get a Vector/list\n+         */\n+        eprop.addProperty(\"number\", \"2\");\n+        assertTrue(\"This returns array\", (eprop.getVector(\"number\") instanceof java.util.Vector));\n+        assertTrue(\"This returns array\", (eprop.getList(\"number\") instanceof java.util.List));\n+\n+        /*\n+         *  now test dan's new fix where we get the first scalar \n+         *  when we access a vector/list valued\n+         *  property\n+         */\n+        assertTrue(\"This returns scalar\", (eprop.getString(\"number\") instanceof String));\n+\n+        /*\n+         * test comma separated string properties\n+         */\n+        String prop = \"hey, that's a test\";\n+        eprop.setProperty(\"prop.string\", prop);\n+        assertTrue(\"This returns vector\", (eprop.getVector(\"prop.string\") instanceof java.util.Vector));\n+        assertTrue(\"This returns list\", (eprop.getList(\"prop.string\") instanceof java.util.List));\n+\n+        String prop2 = \"hey\\\\, that's a test\";\n+        eprop.remove(\"prop.string\");\n+        eprop.setProperty(\"prop.string\", prop2);\n+        assertTrue(\"This returns array\", (eprop.getString(\"prop.string\") instanceof java.lang.String));\n+\n+        /*\n+         * test subset : we want to make sure that the EP doesn't reprocess the data \n+         *  elements when generating the subset\n+         */\n+\n+        ExtendedProperties subEprop = eprop.subset(\"prop\");\n+\n+        assertTrue(\"Returns the full string\", subEprop.getString(\"string\").equals(prop));\n+        assertTrue(\"This returns string for subset\", (subEprop.getString(\"string\") instanceof java.lang.String));\n+        assertTrue(\"This returns array for subset\", (subEprop.getVector(\"string\") instanceof java.util.Vector));\n+        assertTrue(\"This returns array for subset\", (subEprop.getList(\"string\") instanceof java.util.List));\n+\n+    }\n+\n+    public void testInterpolation() {\n+        eprop.setProperty(\"applicationRoot\", \"/home/applicationRoot\");\n+        eprop.setProperty(\"db\", \"${applicationRoot}/db/hypersonic\");\n+        String dbProp = \"/home/applicationRoot/db/hypersonic\";\n+        assertTrue(\"Checking interpolated variable\", eprop.getString(\"db\").equals(dbProp));\n+    }\n+\n+    public void testSaveAndLoad() {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+        ExtendedProperties ep2 = new ExtendedProperties();\n+\n+        try {\n+            /* initialize value:\n+            one=Hello\\World\n+            two=Hello\\,World\n+            three=Hello,World\n+            */\n+            String s1 = \"one=Hello\\\\World\\ntwo=Hello\\\\,World\\nthree=Hello,World\";\n+            byte[] bytes = s1.getBytes();\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            ep1.load(bais);\n+            assertEquals(\"Back-slashes not interpreted properly\", \n+                    \"Hello\\\\World\", ep1.getString(\"one\"));\n+            assertEquals(\"Escaped commas not interpreted properly\", \n+                    \"Hello,World\", ep1.getString(\"two\"));\n+            assertEquals(\"Commas not interpreted properly\", \n+                    2, ep1.getVector(\"three\").size());\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"Hello\", ep1.getVector(\"three\").get(0));\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"World\", ep1.getVector(\"three\").get(1));\n+\n+            assertEquals(\"Commas not interpreted properly\", \n+                    2, ep1.getList(\"three\").size());\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"Hello\", ep1.getList(\"three\").get(0));\n+            assertEquals(\"Commas not interpreted properly\", \n+                    \"World\", ep1.getList(\"three\").get(1));\n+                    \n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            ep1.save(baos, null);\n+            bytes = baos.toByteArray();\n+            bais = new ByteArrayInputStream(bytes);\n+            ep2.load(bais);\n+            assertEquals(\"Back-slash not same after being saved and loaded\",\n+                    ep1.getString(\"one\"), ep2.getString(\"one\"));\n+            assertEquals(\"Escaped comma not same after being saved and loaded\",\n+                    ep1.getString(\"two\"), ep2.getString(\"two\"));\n+            assertEquals(\"Comma not same after being saved and loaded\",\n+                    ep1.getString(\"three\"), ep2.getString(\"three\"));\n+        } catch (IOException ioe) {\n+            fail(\"There was an exception saving and loading the EP\");\n+        }\n+    }\n+\n+    public void testTrailingBackSlash() {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        try {\n+            /*\n+            initialize using:\n+            one=ONE\n+            two=TWO \\\\\n+            three=THREE\n+            */\n+            String s1 = \"one=ONE\\ntwo=TWO \\\\\\\\\\nthree=THREE\";\n+            byte[] bytes = s1.getBytes();\n+            ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+            ep1.load(bais);\n+            assertEquals(\"Trailing back-slashes not interpreted properly\", \n+                    3, ep1.size());\n+            assertEquals(\"Back-slash not escaped properly\", \n+                    \"TWO \\\\\", ep1.getString(\"two\"));\n+        } catch (IOException ioe) {\n+            fail(\"There was an exception loading the EP\");\n+        }\n+    }\n+    \n+    public void testMultipleSameKey1() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a\n+        one=b,c\n+        */\n+        String s1 = \"one=a\\none=b,c\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(3, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+\n+        assertEquals(3, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+    }\n+    \n+    public void testMultipleSameKey2() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a,b\n+        one=c,d\n+        */\n+        String s1 = \"one=a,b\\none=c,d\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(4, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getVector(\"one\").get(3));\n+\n+        assertEquals(4, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getList(\"one\").get(3));\n+    }\n+    \n+    public void testMultipleSameKey3() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a,b\n+        one=c\n+        */\n+        String s1 = \"one=a,b\\none=c\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(3, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+\n+        assertEquals(3, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+    }\n+    \n+    public void testMultipleSameKeyByCode() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        ep1.addProperty(\"one\", \"a\");\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(1, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+\n+        assertEquals(1, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        \n+        ep1.addProperty(\"one\", Boolean.TRUE);\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(2, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getVector(\"one\").get(1));\n+\n+        assertEquals(2, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getList(\"one\").get(1));\n+        \n+        ep1.addProperty(\"one\", \"c,d\");\n+        assertEquals(1, ep1.size());\n+\n+        assertEquals(4, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getVector(\"one\").get(3));\n+\n+        assertEquals(4, ep1.getList(\"one\").size());\n+        assertEquals(\"a\", ep1.getList(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getList(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getList(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getList(\"one\").get(3));\n+    }\n+\n+    public void testInheritDefaultProperties() {\n+        Properties defaults = new Properties();\n+        defaults.setProperty(\"resource.loader\", \"class\");\n+\n+        Properties properties = new Properties(defaults);\n+        properties.setProperty(\"test\", \"foo\");\n+\n+        ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n+\n+        assertEquals(\"foo\", extended.getString(\"test\"));\n+        assertEquals(\"class\", extended.getString(\"resource.loader\"));\n+    }\n+\n+    public void testInclude() {\n+        ExtendedProperties a = new ExtendedProperties();\n+        ExtendedProperties b = new ExtendedProperties();\n+        \n+        assertEquals(\"include\", a.getInclude());\n+        assertEquals(\"include\", b.getInclude());\n+        \n+        a.setInclude(\"import\");\n+        assertEquals(\"import\", a.getInclude());\n+        assertEquals(\"include\", b.getInclude());\n+        \n+        a.setInclude(null);\n+        assertEquals(null, a.getInclude());\n+        assertEquals(\"include\", b.getInclude());\n+    }\n+\n+    public void testKeySet1() {\n+            ExtendedProperties p = new ExtendedProperties();\n+            p.addProperty(\"a\", \"foo\");\n+            p.addProperty(\"b\", \"bar\");\n+            p.addProperty(\"c\", \"bar\");\n+\n+            Iterator<String> it = p.getKeys();\n+            assertEquals(\"a\", it.next());\n+            assertEquals(\"b\", it.next());\n+            assertEquals(\"c\", it.next());\n+            assertFalse(it.hasNext());\n+    }\n+\n+    public void testKeySet2() {\n+        ExtendedProperties p = new ExtendedProperties();\n+        p.put(\"a\", \"foo\");\n+        p.put(\"b\", \"bar\");\n+        p.put(\"c\", \"bar\");\n+\n+        Iterator<String> it = p.getKeys();\n+        assertEquals(\"a\", it.next());\n+        assertEquals(\"b\", it.next());\n+        assertEquals(\"c\", it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+\n+    public void testKeySet3() {\n+        ExtendedProperties q = new ExtendedProperties();\n+        q.addProperty(\"a\", \"foo\");\n+        q.addProperty(\"b\", \"bar\");\n+        q.addProperty(\"c\", \"bar\");\n+\n+        ExtendedProperties p = new ExtendedProperties();\n+        p.putAll(q);\n+\n+        Iterator<String> it = p.getKeys();\n+        assertEquals(\"a\", it.next());\n+        assertEquals(\"b\", it.next());\n+        assertEquals(\"c\", it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testKeySet4() {\n+        ExtendedProperties q = new ExtendedProperties();\n+        q.addProperty(\"a\", \"foo\");\n+        q.addProperty(\"b\", \"bar\");\n+        q.addProperty(\"c\", \"bar\");\n+\n+        q.remove(\"b\");\n+\n+        Iterator<String> it = q.getKeys();\n+        assertEquals(\"a\", it.next());\n+        assertEquals(\"c\", it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testCollections271() {\n+        ExtendedProperties props = new ExtendedProperties();\n+        props.setProperty(\"test\", \"\\\\\\\\\\\\\\\\192.168.1.91\\\\\\\\test\");\n+        props.getProperty(\"test\");\n+        assertEquals( \"\\\\\\\\192.168.1.91\\\\test\", props.getProperty(\"test\") );\n+\n+        ExtendedProperties props2 = new ExtendedProperties();\n+        props2.combine(props);\n+        assertEquals( \"\\\\\\\\192.168.1.91\\\\test\", props2.getProperty(\"test\") );\n+\n+        ExtendedProperties props3 = new ExtendedProperties();\n+        props3.setProperty(\"sub.test\", \"foo\");\n+        props2.combine(props3);\n+        assertEquals(\"foo\", props2.getProperty(\"sub.test\"));\n+\n+        ExtendedProperties subs = props2.subset(\"sub\");\n+        assertNotNull(subs);\n+        assertEquals(\"foo\", subs.getProperty(\"test\"));\n+    }\n+\n+    public void testCollections238() throws IOException {\n+        ExtendedProperties props = new ExtendedProperties();\n+        String txt = \"x=1\\ny=\\nz=3\";\n+        byte[] bytes = txt.getBytes();\n+        ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n+        props.load(in);\n+        assertEquals(\"1\", props.getProperty(\"x\"));\n+        assertEquals(\"3\", props.getProperty(\"z\"));\n+        assertEquals(\"\", props.getProperty(\"y\"));\n+        assertEquals(3, props.size());\n+    }\n+\n+    public void testCollections299() {\n+        Properties defaults = new Properties();\n+        defaults.put(\"objectTrue\", Boolean.TRUE);\n+\n+        Properties properties = new Properties(defaults);\n+        properties.put(\"objectFalse\", Boolean.FALSE);\n+\n+        ExtendedProperties extended = ExtendedProperties.convertProperties(properties);\n+\n+        assertNull(extended.getString(\"objectTrue\"));\n+        assertNull(extended.getString(\"objectFalse\"));\n+\n+        assertNull(extended.get(\"objectTrue\"));\n+        assertNull(extended.get(\"objectFalse\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/FactoryUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.collections.functors.ConstantFactory;\n+import org.apache.commons.collections.functors.ExceptionFactory;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the org.apache.commons.collections.FactoryUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FactoryUtilsTest extends junit.framework.TestCase {\n+\n+    /**\n+     * Construct\n+     */\n+    public FactoryUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() {\n+    }\n+\n+    // exceptionFactory\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionFactory() {\n+        assertNotNull(FactoryUtils.exceptionFactory());\n+        assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());\n+        try {\n+            FactoryUtils.exceptionFactory().create();\n+        } catch (FunctorException ex) {\n+            try {\n+                FactoryUtils.exceptionFactory().create();\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nullFactory\n+    //------------------------------------------------------------------\n+\n+    public void testNullFactory() {\n+        Factory<Object> factory = FactoryUtils.nullFactory();\n+        assertNotNull(factory);\n+        Object created = factory.create();\n+        assertNull(created);\n+    }\n+\n+    // constantFactory\n+    //------------------------------------------------------------------\n+\n+    public void testConstantFactoryNull() {\n+        Factory<Object> factory = FactoryUtils.constantFactory(null);\n+        assertNotNull(factory);\n+        Object created = factory.create();\n+        assertNull(created);\n+    }\n+\n+    public void testConstantFactoryConstant() {\n+        Integer constant = new Integer(9);\n+        Factory<Integer> factory = FactoryUtils.constantFactory(constant);\n+        assertNotNull(factory);\n+        Integer created = factory.create();\n+        assertSame(constant, created);\n+    }\n+\n+    // prototypeFactory\n+    //------------------------------------------------------------------\n+\n+    public void testPrototypeFactoryNull() {\n+        assertSame(ConstantFactory.NULL_INSTANCE, FactoryUtils.prototypeFactory(null));\n+    }\n+\n+    public void testPrototypeFactoryPublicCloneMethod() throws Exception {\n+        Date proto = new Date();\n+        Factory<Date> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        Date created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicCopyConstructor() throws Exception {\n+        Mock1 proto = new Mock1(6);\n+        Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n+        assertNotNull(factory);\n+        Object created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        try {\n+            out.writeObject(factory);\n+        } catch (NotSerializableException ex) {\n+            out.close();\n+        }\n+        factory = FactoryUtils.<Object>prototypeFactory(new Mock2(\"S\"));\n+        buffer = new ByteArrayOutputStream();\n+        out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicSerialization() throws Exception {\n+        Integer proto = new Integer(9);\n+        Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        Integer created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicSerializationError() {\n+        Mock2 proto = new Mock2(new Object());\n+        Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n+        assertNotNull(factory);\n+        try {\n+            factory.create();\n+        } catch (FunctorException ex) {\n+            assertTrue(ex.getCause() instanceof IOException);\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testPrototypeFactoryPublicBad() {\n+        Object proto = new Object();\n+        try {\n+            FactoryUtils.prototypeFactory(proto);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public static class Mock1 {\n+        private final int iVal;\n+        public Mock1(int val) {\n+            iVal = val;\n+        }\n+        public Mock1(Mock1 mock) {\n+            iVal = mock.iVal;\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof Mock1) {\n+                if (iVal == ((Mock1) obj).iVal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class Mock2 implements Serializable {\n+        private final Object iVal;\n+        public Mock2(Object val) {\n+            iVal = val;\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof Mock2) {\n+                if (iVal == ((Mock2) obj).iVal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static class Mock3 {\n+        private static int cCounter = 0;\n+        private final int iVal;\n+        public Mock3() {\n+            iVal = cCounter++;\n+        }\n+        public int getValue() {\n+            return iVal;\n+        }\n+    }\n+\n+    // instantiateFactory\n+    //------------------------------------------------------------------\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryNull() {\n+        FactoryUtils.instantiateFactory(null);\n+    }\n+\n+    @Test\n+    public void instantiateFactorySimple() {\n+        Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);\n+        assertNotNull(factory);\n+        Mock3 created = factory.create();\n+        assertEquals(0, created.getValue());\n+        created = factory.create();\n+        assertEquals(1, created.getValue());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryMismatch() {\n+        FactoryUtils.instantiateFactory(Date.class, null, new Object[] {null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryNoConstructor() {\n+        FactoryUtils.instantiateFactory(Date.class, new Class[] {Long.class}, new Object[] {null});\n+    }\n+\n+    @Test\n+    public void instantiateFactoryComplex() {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n+        // 2nd Jan 1970\n+        Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,\n+            new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},\n+            new Object[] {new Integer(70), new Integer(0), new Integer(2)});\n+        assertNotNull(factory);\n+        Date created = factory.create();\n+        // long time of 1 day (== 2nd Jan 1970)\n+        assertEquals(new Date(1000 * 60 * 60 * 24), created);\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Factory singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionFactory.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/IteratorUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.iterators.EmptyIterator;\n+import org.apache.commons.collections.iterators.EmptyListIterator;\n+import org.apache.commons.collections.iterators.EmptyMapIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedIterator;\n+import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n+\n+/**\n+ * Tests for IteratorUtils.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Unknown\n+ */\n+public class IteratorUtilsTest extends BulkTest {\n+\n+    public IteratorUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(IteratorUtilsTest.class);\n+    }\n+\n+    public void testAsIterable() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        Iterator<Integer> iterator = list.iterator();\n+        \n+        Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);\n+        int expected = 0;\n+        for(Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+\n+        // single use iterator\n+        for(Integer actual : iterable) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+\n+    public void testAsIterableNull() {\n+        try {\n+            IteratorUtils.asIterable(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testAsMultipleIterable() {\n+        List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        Iterator<Integer> iterator = list.iterator();\n+        \n+        Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);\n+        int expected = 0;\n+        for(Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+\n+        // multiple use iterator\n+        expected = 0;\n+        for(Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+    }\n+\n+    public void testAsMultipleIterableNull() {\n+        try {\n+            IteratorUtils.asMultipleUseIterable(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testToList() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.add(new Integer(1));\n+        list.add(\"Two\");\n+        list.add(null);\n+        List<Object> result = IteratorUtils.toList(list.iterator());\n+        assertEquals(list, result);\n+    }\n+\n+    public void testToArray() {\n+        List<Object> list = new ArrayList<Object>();\n+        list.add(new Integer(1));\n+        list.add(\"Two\");\n+        list.add(null);\n+        Object[] result = IteratorUtils.toArray(list.iterator());\n+        assertEquals(list, Arrays.asList(result));\n+    }\n+\n+    public void testToArray2() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(null);\n+        String[] result = IteratorUtils.toArray(list.iterator(), String.class);\n+        assertEquals(list, Arrays.asList(result));\n+    }\n+\n+    public void testArrayIterator() {\n+        Object[] objArray = {\"a\", \"b\", \"c\"};\n+        ResettableIterator<Object> iterator = IteratorUtils.arrayIterator(objArray);\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.next().equals(\"b\"));\n+        iterator.reset();\n+        assertTrue(iterator.next().equals(\"a\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(new Integer(0));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+                // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 1);\n+        assertTrue(iterator.next().equals(\"b\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 3);\n+        assertTrue(!iterator.hasNext());\n+        iterator.reset();\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 2, 3);\n+        assertTrue(iterator.next().equals(\"c\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        int[] intArray = {0, 1, 2};\n+        iterator = IteratorUtils.arrayIterator(intArray);\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        iterator.reset();\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 1);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 3);\n+        assertTrue(!iterator.hasNext());\n+        iterator.reset();\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 2, 3);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testArrayListIterator() {\n+        Object[] objArray = {\"a\", \"b\", \"c\", \"d\"};\n+        ResettableListIterator<Object> iterator = IteratorUtils.arrayListIterator(objArray);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.previous().equals(\"a\"));\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(\"b\"));\n+        assertTrue(iterator.next().equals(\"c\"));\n+        assertTrue(iterator.next().equals(\"d\"));\n+        assertTrue(iterator.nextIndex() == 4); // size of list\n+        assertTrue(iterator.previousIndex() == 3);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(new Integer(0));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+                // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException ex) {\n+                // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 1);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(\"b\"));\n+        assertTrue(iterator.previousIndex() == 0);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 3);\n+        assertTrue(iterator.hasNext());\n+        try {\n+            iterator.previous();\n+            fail(\"Expecting NoSuchElementException.\");\n+        } catch (NoSuchElementException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 5);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 2, 3);\n+        assertTrue(iterator.next().equals(\"c\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 2, 5);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        int[] intArray = {0, 1, 2};\n+        iterator = IteratorUtils.arrayListIterator(intArray);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previousIndex() == 1);\n+        assertTrue(iterator.nextIndex() == 2);\n+        assertTrue(iterator.previous().equals(new Integer(1)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 1);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previous().equals(new Integer(1)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+        assertTrue(iterator.previousIndex() == 1);\n+        assertTrue(iterator.nextIndex() == 2);\n+        assertTrue(iterator.previous().equals(new Integer(2)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 3);\n+        assertTrue(!iterator.hasNext());\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 2, 3);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+        assertTrue(iterator.hasPrevious());\n+        assertTrue(!iterator.hasNext());\n+\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     * Gets an immutable Iterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n+     */\n+    private Iterator<String> getImmutableIterator() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        list.add(\"c\");\n+        list.add(\"d\");\n+        return IteratorUtils.unmodifiableIterator(list.iterator());\n+    }\n+\n+    /**\n+     * Gets an immutable ListIterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n+     */\n+    private ListIterator<String> getImmutableListIterator() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        list.add(\"c\");\n+        list.add(\"d\");\n+        return IteratorUtils.unmodifiableListIterator(list.listIterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty iterator\n+     */\n+    public void testEmptyIterator() {\n+        assertSame(EmptyIterator.INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n+        assertSame(EmptyIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof OrderedIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR.hasNext());\n+        IteratorUtils.EMPTY_ITERATOR.reset();\n+        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.EMPTY_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.emptyIterator());\n+        try {\n+            IteratorUtils.EMPTY_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty list iterator\n+     */\n+    public void testEmptyListIterator() {\n+        assertSame(EmptyListIterator.INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertSame(EmptyListIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ListIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_LIST_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_LIST_ITERATOR.hasNext());\n+        assertEquals(0, IteratorUtils.EMPTY_LIST_ITERATOR.nextIndex());\n+        assertEquals(-1, IteratorUtils.EMPTY_LIST_ITERATOR.previousIndex());\n+        IteratorUtils.EMPTY_LIST_ITERATOR.reset();\n+        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.emptyListIterator());\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.set(null);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.add(null);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyMapIterator() {\n+        assertSame(EmptyMapIterator.INSTANCE, IteratorUtils.EMPTY_MAP_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof MapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedMapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR.hasNext());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_MAP_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.EMPTY_MAP_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.emptyMapIterator());\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.getKey();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.getValue();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.setValue(null);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyOrderedIterator() {\n+        assertSame(EmptyOrderedIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof OrderedIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR.hasNext());\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR.hasPrevious());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.emptyOrderedIterator());\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyOrderedMapIterator() {\n+        assertSame(EmptyOrderedMapIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof MapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof OrderedMapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasNext());\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasPrevious());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.emptyOrderedMapIterator());\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.next();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.previous();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.remove();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getKey();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getValue();\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.setValue(null);\n+            fail();\n+        } catch (IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test next() and hasNext() for an immutable Iterator.\n+     */\n+    public void testUnmodifiableIteratorIteration() {\n+        Iterator<String> iterator = getImmutableIterator();\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"a\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"b\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"c\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"d\", iterator.next());\n+\n+        assertTrue(!iterator.hasNext());\n+    }\n+\n+    /**\n+     * Test next(), hasNext(), previous() and hasPrevious() for an immutable\n+     * ListIterator.\n+     */\n+    public void testUnmodifiableListIteratorIteration() {\n+        ListIterator<String> listIterator = getImmutableListIterator();\n+\n+        assertTrue(!listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"a\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"b\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"c\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"d\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(!listIterator.hasNext());\n+\n+        assertEquals(\"d\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"c\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"b\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"a\", listIterator.previous());\n+\n+        assertTrue(!listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+    }\n+\n+    /**\n+     * Test remove() for an immutable Iterator.\n+     */\n+    public void testUnmodifiableIteratorImmutability() {\n+        Iterator<String> iterator = getImmutableIterator();\n+\n+        try {\n+            iterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        iterator.next();\n+\n+        try {\n+            iterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+    }\n+\n+    /**\n+     * Test remove() for an immutable ListIterator.\n+     */\n+    public void testUnmodifiableListIteratorImmutability() {\n+        ListIterator<String> listIterator = getImmutableListIterator();\n+\n+        try {\n+            listIterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.set(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"set(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.add(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"add(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        listIterator.next();\n+\n+        try {\n+            listIterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.set(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"set(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.add(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"add(Object) should throw an UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/ListUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import junit.framework.Assert;\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.list.PredicatedList;\n+\n+/**\n+ * Tests for ListUtils.\n+ *\n+ * @version $Id$\n+ */\n+public class ListUtilsTest extends BulkTest {\n+\n+    private static final String a = \"a\";\n+    private static final String b = \"b\";\n+    private static final String c = \"c\";\n+    private static final String d = \"d\";\n+    private static final String e = \"e\";\n+    private static final String x = \"x\";\n+\n+    private String[] fullArray;\n+    private List<String> fullList;\n+\n+    public ListUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ListUtilsTest.class);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        fullArray = new String[]{a, b, c, d, e};\n+        fullList = new ArrayList<String>(Arrays.asList(fullArray));\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an empty list.\n+     */\n+    public void testIntersectNonEmptyWithEmptyList() {\n+        final List<String> empty = Collections.<String>emptyList();\n+        assertTrue(\"result not empty\", ListUtils.intersection(empty, fullList).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an empty list.\n+     */\n+    public void testIntersectEmptyWithEmptyList() {\n+        final List<?> empty = Collections.EMPTY_LIST;\n+        assertTrue(\"result not empty\", ListUtils.intersection(empty, empty).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an subset of iteself.\n+     */\n+    public void testIntersectNonEmptySubset() {\n+        // create a copy\n+        final List<String> other = new ArrayList<String>(fullList);\n+\n+        // remove a few items\n+        assertNotNull(other.remove(0));\n+        assertNotNull(other.remove(1));\n+\n+        // make sure the intersection is equal to the copy\n+        assertEquals(other, ListUtils.intersection(fullList, other));\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an subset of iteself.\n+     */\n+    public void testIntersectListWithNoOverlapAndDifferentTypes() {\n+        @SuppressWarnings(\"boxing\")\n+        final List<Integer> other = Arrays.asList(1, 23);\n+        assertTrue(ListUtils.intersection(fullList, other).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with iteself.\n+     */\n+    public void testIntersectListWithSelf() {\n+        assertEquals(fullList, ListUtils.intersection(fullList, fullList));\n+    }\n+\n+    /**\n+     * Tests intersecting two lists in different orders.\n+     */\n+    public void testIntersectionOrderInsensitivity() {\n+        List<String> one = new ArrayList<String>();\n+        List<String> two = new ArrayList<String>();\n+        one.add(\"a\");\n+        one.add(\"b\");\n+        two.add(\"a\");\n+        two.add(\"a\");\n+        two.add(\"b\");\n+        two.add(\"b\");\n+        assertEquals(ListUtils.intersection(one,two),ListUtils.intersection(two, one));\n+    }\n+\n+    public void testPredicatedList() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        List<Object> list = ListUtils.predicatedList(new ArrayStack<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedList\", list instanceof PredicatedList);\n+        try {\n+            list = ListUtils.predicatedList(new ArrayStack<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            list = ListUtils.predicatedList(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null list.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyList() {\n+        List<Integer> list = ListUtils.lazyList(new ArrayList<Integer>(), new Factory<Integer>() {\n+\n+            private int index;\n+\n+            public Integer create() {\n+                index++;\n+                return new Integer(index);\n+            }\n+        });\n+\n+        assertNotNull(list.get(5));\n+        assertEquals(6, list.size());\n+\n+        assertNotNull(list.get(5));\n+        assertEquals(6, list.size());\n+    }\n+\n+    public void testEquals() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        List<String> a = new ArrayList<String>( data );\n+        List<String> b = new ArrayList<String>( data );\n+\n+        assertEquals(true, a.equals(b));\n+        assertEquals(true, ListUtils.isEqualList(a, b));\n+        a.clear();\n+        assertEquals(false, ListUtils.isEqualList(a, b));\n+        assertEquals(false, ListUtils.isEqualList(a, null));\n+        assertEquals(false, ListUtils.isEqualList(null, b));\n+        assertEquals(true, ListUtils.isEqualList(null, null));\n+    }\n+\n+    public void testHashCode() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        List<String> a = new ArrayList<String>(data);\n+        List<String> b = new ArrayList<String>(data);\n+\n+        assertEquals(true, a.hashCode() == b.hashCode());\n+        assertEquals(true, a.hashCode() == ListUtils.hashCodeForList(a));\n+        assertEquals(true, b.hashCode() == ListUtils.hashCodeForList(b));\n+        assertEquals(true, ListUtils.hashCodeForList(a) == ListUtils.hashCodeForList(b));\n+        a.clear();\n+        assertEquals(false, ListUtils.hashCodeForList(a) == ListUtils.hashCodeForList(b));\n+        assertEquals(0, ListUtils.hashCodeForList(null));\n+    }\n+\n+    public void testRetainAll() {\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        List<String> retained = ListUtils.retainAll(fullList, sub);\n+        assertTrue(retained.size() == 2);\n+        sub.remove(x);\n+        assertTrue(retained.equals(sub));\n+        fullList.retainAll(sub);\n+        assertTrue(retained.equals(fullList));\n+\n+        try {\n+            ListUtils.retainAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(NullPointerException npe){} // this is what we want\n+    }\n+\n+    public void testRemoveAll() {\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        List<String> remainder = ListUtils.removeAll(fullList, sub);\n+        assertTrue(remainder.size() == 3);\n+        fullList.removeAll(sub);\n+        assertTrue(remainder.equals(fullList));\n+\n+        try {\n+            ListUtils.removeAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(NullPointerException npe) {} // this is what we want\n+    }\n+\n+    public void testSubtract() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(a);\n+        list.add(b);\n+        list.add(a);\n+        list.add(x);\n+\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+\n+        List<String> result = ListUtils.subtract(list, sub);\n+        assertTrue(result.size() == 3);\n+        \n+        List<String> expected = new ArrayList<String>();\n+        expected.add(b);\n+        expected.add(a);\n+        expected.add(x);\n+\n+        assertEquals(expected, result);\n+        \n+        try {\n+            ListUtils.subtract(list, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(NullPointerException npe) {} // this is what we want\n+    }\n+\n+    public void testSubtractNullElement() {\n+        List<String> list = new ArrayList<String>();\n+        list.add(a);\n+        list.add(null);\n+        list.add(null);\n+        list.add(x);\n+\n+        List<String> sub = new ArrayList<String>();\n+        sub.add(null);\n+\n+        List<String> result = ListUtils.subtract(list, sub);\n+        assertTrue(result.size() == 3);\n+        \n+        List<String> expected = new ArrayList<String>();\n+        expected.add(a);\n+        expected.add(null);\n+        expected.add(x);\n+\n+        assertEquals(expected, result);\n+    }\n+\n+    /**\n+     * Tests the <code>indexOf</code> method in <code>ListUtils</code> class..\n+     */\n+    public void testIndexOf() {\n+        Predicate<String> testPredicate = EqualPredicate.equalPredicate(\"d\");\n+        int index = ListUtils.indexOf(fullList, testPredicate);\n+        assertEquals(d, fullList.get(index));\n+\n+        testPredicate = EqualPredicate.equalPredicate(\"de\");\n+        index = ListUtils.indexOf(fullList, testPredicate);\n+        assertEquals(index, -1);\n+        \n+        assertEquals(ListUtils.indexOf(null,testPredicate), -1);\n+        assertEquals(ListUtils.indexOf(fullList, null), -1);\n+    }\n+    \n+    public void testPartition() {\n+        List<Integer> strings = new ArrayList<Integer>();\n+        for (int i = 0; i <= 6; i++) {\n+            strings.add(i);\n+        }\n+        \n+        final List<List<Integer>> partition = ListUtils.partition(strings, 3);\n+\n+        assertNotNull(partition);\n+        assertEquals(3, partition.size());\n+        assertEquals(1, partition.get(2).size());\n+        \n+        try {\n+            ListUtils.partition(null, 3);\n+            Assert.fail(\"failed to check for null argument\");\n+        } catch (IllegalArgumentException e) {}\n+        \n+        try {\n+            ListUtils.partition(strings, 0);\n+            Assert.fail(\"failed to check for size argument\");\n+        } catch (IllegalArgumentException e) {}\n+        \n+        try {\n+            ListUtils.partition(strings, -10);\n+            Assert.fail(\"failed to check for size argument\");\n+        } catch (IllegalArgumentException e) {}\n+        \n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/MapUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.ListResourceBundle;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.keyvalue.DefaultKeyValue;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n+import org.apache.commons.collections.map.HashedMap;\n+import org.apache.commons.collections.map.LazyMap;\n+import org.apache.commons.collections.map.PredicatedMap;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n+\n+/**\n+ * Tests for MapUtils.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Arun Mammen Thomas\n+ * @author Max Rydahl Andersen\n+ * @author Janek Bogucki\n+ * @author Neil O'Toole\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class MapUtilsTest extends BulkTest {\n+\n+    public MapUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(MapUtilsTest.class);\n+    }\n+\n+    public Predicate<Object> getPredicate() {\n+        return new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+    public void testPredicatedMap() {\n+        Predicate<Object> p = getPredicate();\n+        Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<Object, Object>(), p, p);\n+        assertTrue(\"returned object should be a PredicatedMap\", map instanceof PredicatedMap);\n+        try {\n+            map = MapUtils.predicatedMap(null, p, p);\n+            fail(\"Expecting IllegalArgumentException for null map.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyMapFactory() {\n+        Factory<Integer> factory = FactoryUtils.constantFactory(new Integer(5));\n+        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), factory);\n+        assertTrue(map instanceof LazyMap);\n+        try {\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Factory<Object>) null);\n+            fail(\"Expecting IllegalArgumentException for null factory\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, factory);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n+        map = MapUtils.lazyMap(new HashMap<Object, Object>(), transformer);\n+        assertTrue(map instanceof LazyMap);\n+        try {\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Transformer<Object, Object>) null);\n+            fail(\"Expecting IllegalArgumentException for null transformer\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyMapTransformer() {\n+        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), new Transformer<Object, Object>() {\n+            public Object transform(Object mapKey) {\n+                if (mapKey instanceof String) {\n+                    return new Integer((String) mapKey);\n+                }\n+                return null;\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        Integer i1 = (Integer) map.get(\"5\");\n+        assertEquals(new Integer(5), i1);\n+        assertEquals(1, map.size());\n+        Integer i2 = (Integer) map.get(new String(new char[] {'5'}));\n+        assertEquals(new Integer(5), i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+    }\n+\n+    public void testInvertMap() {\n+        final Map<String, String> in = new HashMap<String, String>(5, 1);\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n+\n+        final Set<String> inKeySet = new HashSet<String>(in.keySet());\n+        final Set<String> inValSet = new HashSet<String>(in.values());\n+\n+        final Map<String, String> out =  MapUtils.invertMap(in);\n+\n+        final Set<String> outKeySet = new HashSet<String>(out.keySet());\n+        final Set<String> outValSet = new HashSet<String>(out.values());\n+\n+        assertTrue( inKeySet.equals( outValSet ));\n+        assertTrue( inValSet.equals( outKeySet ));\n+\n+        assertEquals( \"1\", out.get(\"A\"));\n+        assertEquals( \"2\", out.get(\"B\"));\n+        assertEquals( \"3\", out.get(\"C\"));\n+        assertEquals( \"4\", out.get(\"D\"));\n+        assertEquals( \"5\", out.get(\"E\"));\n+    }\n+\n+    public void testPutAll_Map_array() {\n+        try {\n+            MapUtils.putAll(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            MapUtils.putAll(null, new Object[0]);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+\n+        Map<String, String> test = MapUtils.putAll(new HashMap<String, String>(), new String[0]);\n+        assertEquals(0, test.size());\n+\n+        // sub array\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+            {\"RED\", \"#FF0000\"},\n+            {\"GREEN\", \"#00FF00\"},\n+            {\"BLUE\", \"#0000FF\"}\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                null,\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                {\"GREEN\"},\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                {},\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        // flat array\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n+            \"RED\", \"#FF0000\",\n+            \"GREEN\", \"#00FF00\",\n+            \"BLUE\", \"#0000FF\"\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n+            \"RED\", \"#FF0000\",\n+            \"GREEN\", \"#00FF00\",\n+            \"BLUE\", \"#0000FF\",\n+            \"PURPLE\" // ignored\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        // map entry\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultMapEntry<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultMapEntry<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultMapEntry<String, String>(\"BLUE\", \"#0000FF\")\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        // key value\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultKeyValue<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultKeyValue<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultKeyValue<String, String>(\"BLUE\", \"#0000FF\")\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+    }\n+\n+    public void testConvertResourceBundle() {\n+        final Map<String, String> in = new HashMap<String, String>( 5 , 1 );\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n+\n+        ResourceBundle b = new ListResourceBundle() {\n+            @Override\n+            public Object[][] getContents() {\n+                final Object[][] contents = new Object[ in.size() ][2];\n+                final Iterator<String> i = in.keySet().iterator();\n+                int n = 0;\n+                while ( i.hasNext() ) {\n+                    final Object key = i.next();\n+                    final Object val = in.get( key );\n+                    contents[ n ][ 0 ] = key;\n+                    contents[ n ][ 1 ] = val;\n+                    ++n;\n+                }\n+                return contents;\n+            }\n+        };\n+\n+        final Map<String, Object> out = MapUtils.toMap(b);\n+\n+        assertTrue( in.equals(out));\n+    }\n+\n+    public void testDebugAndVerbosePrintCasting() {\n+        final Map<Integer, String> inner = new HashMap<Integer, String>(2, 1);\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new HashMap<Integer, Object>(2, 1);\n+        outer.put(0, inner);\n+        outer.put(1, \"A\");\n+\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        try {\n+            MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n+        } catch (final ClassCastException e) {\n+            fail(\"No Casting should be occurring!\");\n+        }\n+    }\n+\n+    public void testDebugAndVerbosePrintNullMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        outPrint.println(LABEL + \" = \" + String.valueOf((Object) null));\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"3 = C\");\n+        outPrint.println(INDENT + \"4 = null\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"4 = null\");\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        outPrint.println(\"null\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        outPrint.println(\"null\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullStream() {\n+        try {\n+            MapUtils.verbosePrint(null, \"Map\", new HashMap<Object, Object>());\n+            fail(\"Should generate NullPointerException\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    public void testDebugPrintNullStream() {\n+        try {\n+            MapUtils.debugPrint(null, \"Map\", new HashMap<Object, Object>());\n+            fail(\"Should generate NullPointerException\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    public void testDebugPrintNullKey() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = A \" + String.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKey() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = A\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullKeyToMap1() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = (this Map) \" + HashMap.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKeyToMap1() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = (this Map)\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullKeyToMap2() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + \"} \" + HashMap.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKeyToMap2() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = C\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(INDENT + \"7 = (this Map)\");\n+        outPrint.println(\"}\");\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n+\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"7 = (this Map) \" + TreeMap.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n+\n+        MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map)\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"}\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", grandfather);\n+\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+        MapUtils.debugPrint(outPrint, \"Print Map\", grandfather);\n+\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIsEmptyWithEmptyMap() {\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        assertEquals(true, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNonEmptyMap() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertEquals(false, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNull() {\n+        Map<Object, Object> map = null;\n+        assertEquals(true, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithEmptyMap() {\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        assertEquals(false, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithNonEmptyMap() {\n+        Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertEquals(true, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithNull() {\n+        Map<Object, Object> map = null;\n+        assertEquals(false, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testPopulateMap() {\n+        // Setup Test Data\n+        List<String> list = new ArrayList<String>();\n+        list.add(\"1\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+        list.add(\"7\");\n+        list.add(\"2\");\n+        list.add(\"4\");\n+        list.add(\"6\");\n+\n+        // Now test key transform population\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(list.size(), map.size());\n+\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(true, map.containsKey(new Integer(list.get(i))));\n+            assertEquals(false, map.containsKey(list.get(i)));\n+            assertEquals(true, map.containsValue(list.get(i)));\n+            assertEquals(list.get(i), map.get(new Integer(list.get(i))));\n+        }\n+\n+        // Now test both Key-Value transform population\n+        map = new HashMap<Object, Object>();\n+        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+\n+        assertEquals(list.size(), map.size());\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(true, map.containsKey(new Integer(list.get(i))));\n+            assertEquals(false, map.containsKey(list.get(i)));\n+            assertEquals(true, map.containsValue(new Integer(list.get(i))));\n+            assertEquals(new Integer(list.get(i)), map.get(new Integer(list.get(i))));\n+        }\n+    }\n+\n+    public void testIterableMap() {\n+        try {\n+            MapUtils.iterableMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        HashMap<String, String> map = new HashMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        IterableMap<String, String> iMap = MapUtils.iterableMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        HashedMap<String, String> hMap = new HashedMap<String, String>(map);\n+        assertSame(hMap, MapUtils.iterableMap(hMap));\n+    }\n+\n+    public void testIterableSortedMap() {\n+        try {\n+            MapUtils.iterableSortedMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+        }\n+        TreeMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        assertSame(iMap, MapUtils.iterableMap(iMap));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/PredicateUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import static org.apache.commons.collections.functors.NullPredicate.nullPredicate;\n+import static org.apache.commons.collections.functors.TruePredicate.truePredicate;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.functors.AllPredicate;\n+import org.apache.commons.collections.functors.AbstractPredicateTest;\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionPredicate;\n+import org.apache.commons.collections.functors.FalsePredicate;\n+import org.apache.commons.collections.functors.NotNullPredicate;\n+import org.apache.commons.collections.functors.NullPredicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the org.apache.commons.collections.PredicateUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class PredicateUtilsTest extends AbstractPredicateTest {\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown() {\n+    }\n+\n+    // exceptionPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testExceptionPredicate() {\n+        assertNotNull(PredicateUtils.exceptionPredicate());\n+        assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());\n+        try {\n+            PredicateUtils.exceptionPredicate().evaluate(null);\n+        } catch (FunctorException ex) {\n+            try {\n+                PredicateUtils.exceptionPredicate().evaluate(cString);\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // notNullPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testIsNotNullPredicate() {\n+        assertNotNull(PredicateUtils.notNullPredicate());\n+        assertSame(PredicateUtils.notNullPredicate(), PredicateUtils.notNullPredicate());\n+        assertEquals(false, PredicateUtils.notNullPredicate().evaluate(null));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cObject));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cString));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cInteger));\n+    }\n+\n+    // identityPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testIdentityPredicate() {\n+        assertSame(nullPredicate(), PredicateUtils.identityPredicate(null));\n+        assertNotNull(PredicateUtils.identityPredicate(new Integer(6)));\n+        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(null));\n+        assertEquals(false, PredicateUtils.<Object>identityPredicate(new Integer(6)).evaluate(cObject));\n+        assertEquals(false, PredicateUtils.<Object>identityPredicate(new Integer(6)).evaluate(cString));\n+        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(cInteger));\n+        assertEquals(true, PredicateUtils.identityPredicate(cInteger).evaluate(cInteger));\n+    }\n+\n+    // truePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testTruePredicate() {\n+        assertNotNull(TruePredicate.truePredicate());\n+        assertSame(TruePredicate.truePredicate(), TruePredicate.truePredicate());\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(null));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cObject));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cString));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cInteger));\n+    }\n+\n+    // falsePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testFalsePredicate() {\n+        assertNotNull(FalsePredicate.falsePredicate());\n+        assertSame(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate());\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(null));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cObject));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cString));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cInteger));\n+    }\n+\n+    // notPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNotPredicate() {\n+        assertNotNull(PredicateUtils.notPredicate(TruePredicate.truePredicate()));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cObject));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cString));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cInteger));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testNotPredicateEx() {\n+        PredicateUtils.notPredicate(null);\n+    }\n+\n+    // andPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testAndPredicate() {\n+        assertEquals(true, PredicateUtils.andPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAndPredicateEx() {\n+        PredicateUtils.andPredicate(null, null);\n+    }\n+\n+    // allPredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testAllPredicate() {\n+        assertTrue(AllPredicate.allPredicate(new Predicate[] {}), null);\n+        assertEquals(true, AllPredicate.allPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(AllPredicate.allPredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(AllPredicate.allPredicate(coll), null);\n+        coll.clear();\n+        assertTrue(AllPredicate.allPredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx1() {\n+        AllPredicate.allPredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx2() {\n+        AllPredicate.<Object>allPredicate(new Predicate[] { null });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx3() {\n+        AllPredicate.allPredicate(new Predicate[] { null, null });\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx4() {\n+        AllPredicate.allPredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testAllPredicateEx5() {\n+        AllPredicate.allPredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        AllPredicate.allPredicate(coll);\n+    }\n+\n+    // orPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testOrPredicate() {\n+        assertEquals(true, PredicateUtils.orPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.orPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testOrPredicateEx() {\n+        PredicateUtils.orPredicate(null, null);\n+    }\n+\n+    // anyPredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testAnyPredicate() {\n+        assertFalse(PredicateUtils.anyPredicate(new Predicate[] {}), null);\n+\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.anyPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(PredicateUtils.anyPredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(PredicateUtils.anyPredicate(coll), null);\n+        coll.clear();\n+        assertFalse(PredicateUtils.anyPredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx1() {\n+        PredicateUtils.anyPredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx2() {\n+        PredicateUtils.anyPredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx3() {\n+        PredicateUtils.anyPredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx4() {\n+        PredicateUtils.anyPredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testAnyPredicateEx5() {\n+        PredicateUtils.anyPredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.anyPredicate(coll);\n+    }\n+\n+    // eitherPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testEitherPredicate() {\n+        assertEquals(false, PredicateUtils.eitherPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.eitherPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testEitherPredicateEx() {\n+        PredicateUtils.eitherPredicate(null, null);\n+    }\n+\n+    // onePredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testOnePredicate() {\n+        assertFalse(PredicateUtils.onePredicate((Predicate<Object>[]) new Predicate[] {}), null);\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+            TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), TruePredicate.truePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(PredicateUtils.onePredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(PredicateUtils.onePredicate(coll), null);\n+        coll.clear();\n+        assertFalse(PredicateUtils.onePredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testOnePredicateEx1() {\n+        PredicateUtils.onePredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx2() {\n+        PredicateUtils.onePredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx3() {\n+        PredicateUtils.onePredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx4() {\n+        PredicateUtils.onePredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testOnePredicateEx5() {\n+        PredicateUtils.onePredicate(Collections.EMPTY_LIST);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.onePredicate(coll);\n+    }\n+\n+    // neitherPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNeitherPredicate() {\n+        assertEquals(false, PredicateUtils.neitherPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.neitherPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNeitherPredicateEx() {\n+        PredicateUtils.neitherPredicate(null, null);\n+    }\n+\n+    // nonePredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testNonePredicate() {\n+        assertTrue(PredicateUtils.nonePredicate(new Predicate[] {}), null);\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(true, PredicateUtils.nonePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate() }).evaluate(null));\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(true, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertTrue(PredicateUtils.nonePredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertFalse(PredicateUtils.nonePredicate(coll), null);\n+        coll.clear();\n+        assertTrue(PredicateUtils.nonePredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx1() {\n+        PredicateUtils.nonePredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx2() {\n+        PredicateUtils.nonePredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx3() {\n+        PredicateUtils.nonePredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx4() {\n+        PredicateUtils.nonePredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testNonePredicateEx5() {\n+        PredicateUtils.nonePredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx6() {\n+        Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.nonePredicate(coll);\n+    }\n+\n+    // instanceofPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInstanceOfPredicate() {\n+        assertNotNull(PredicateUtils.instanceofPredicate(String.class));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(null));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cObject));\n+        assertEquals(true, PredicateUtils.instanceofPredicate(String.class).evaluate(cString));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cInteger));\n+    }\n+\n+    // uniquePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testUniquePredicate() {\n+        Predicate<Object> p = PredicateUtils.uniquePredicate();\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(cString));\n+        assertEquals(false, p.evaluate(cString));\n+        assertEquals(false, p.evaluate(cString));\n+    }\n+\n+    // asPredicate(Transformer)\n+    //------------------------------------------------------------------\n+\n+    @Test public void testAsPredicateTransformer() {\n+        assertEquals(false, PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(false));\n+        assertEquals(true, PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(true));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testAsPredicateTransformerEx1() {\n+        PredicateUtils.asPredicate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testAsPredicateTransformerEx2() {\n+        PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(null);\n+    }\n+\n+    // invokerPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInvokerPredicate() {\n+        List<Object> list = new ArrayList<Object>();\n+        assertEquals(true, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n+        list.add(new Object());\n+        assertEquals(false, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testInvokerPredicateEx1() {\n+        PredicateUtils.invokerPredicate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicateEx2() {\n+        PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicateEx3() {\n+        PredicateUtils.invokerPredicate(\"noSuchMethod\").evaluate(new Object());\n+    }\n+\n+    // invokerPredicate2\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInvokerPredicate2() {\n+        List<String> list = new ArrayList<String>();\n+        assertEquals(false, PredicateUtils.invokerPredicate(\n+            \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n+        list.add(cString);\n+        assertEquals(true, PredicateUtils.invokerPredicate(\n+            \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testInvokerPredicate2Ex1() {\n+        PredicateUtils.invokerPredicate(null, null, null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicate2Ex2() {\n+        PredicateUtils.invokerPredicate(\"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicate2Ex3() {\n+        PredicateUtils.invokerPredicate(\n+                \"noSuchMethod\", new Class[] {Object.class}, new Object[] {cString}).evaluate(new Object());\n+    }\n+\n+    // nullIsException\n+    //------------------------------------------------------------------\n+\n+    @Test(expected=FunctorException.class)\n+    public void testNullIsExceptionPredicate() {\n+        assertEquals(true, PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsExceptionPredicateEx1() {\n+        PredicateUtils.nullIsExceptionPredicate(null);\n+    }\n+\n+    // nullIsTrue\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNullIsTruePredicate() {\n+        assertEquals(true, PredicateUtils.nullIsTruePredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.nullIsTruePredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        assertEquals(false, PredicateUtils.nullIsTruePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsTruePredicateEx1() {\n+        PredicateUtils.nullIsTruePredicate(null);\n+    }\n+\n+    // nullIsFalse\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNullIsFalsePredicate() {\n+        assertEquals(false, PredicateUtils.nullIsFalsePredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.nullIsFalsePredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        assertEquals(false, PredicateUtils.nullIsFalsePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsFalsePredicateEx1() {\n+        PredicateUtils.nullIsFalsePredicate(null);\n+    }\n+\n+    // transformed\n+    //------------------------------------------------------------------\n+\n+    @Test public void testTransformedPredicate() {\n+        assertEquals(true, PredicateUtils.transformedPredicate(\n+                TransformerUtils.nopTransformer(),\n+                TruePredicate.truePredicate()).evaluate(new Object()));\n+\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        map.put(Boolean.TRUE, \"Hello\");\n+        Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);\n+        Predicate<Object> p = EqualPredicate.<Object>equalPredicate(\"Hello\");\n+        assertEquals(false, PredicateUtils.transformedPredicate(t, p).evaluate(null));\n+        assertEquals(true, PredicateUtils.transformedPredicate(t, p).evaluate(Boolean.TRUE));\n+        try {\n+            PredicateUtils.transformedPredicate(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Predicate singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    @Test public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionPredicate.INSTANCE,\n+                FalsePredicate.INSTANCE,\n+                NotNullPredicate.INSTANCE,\n+                NullPredicate.INSTANCE,\n+                TruePredicate.INSTANCE\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return truePredicate();  //Just return something to satisfy super class.\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/SetUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.set.PredicatedSet;\n+\n+/**\n+ * Tests for SetUtils.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Neil O'Toole\n+ * @author Matthew Hawthorne\n+ */\n+public class SetUtilsTest extends BulkTest {\n+\n+    public SetUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(SetUtilsTest.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public void testpredicatedSet() {\n+        Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        Set<Object> set = SetUtils.predicatedSet(new HashSet<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedSet\", set instanceof PredicatedSet);\n+        try {\n+            set = SetUtils.predicatedSet(new HashSet<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            set = SetUtils.predicatedSet(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null set.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testEquals() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        Set<String> a = new HashSet<String>(data);\n+        Set<String> b = new HashSet<String>(data);\n+\n+        assertEquals(true, a.equals(b));\n+        assertEquals(true, SetUtils.isEqualSet(a, b));\n+        a.clear();\n+        assertEquals(false, SetUtils.isEqualSet(a, b));\n+        assertEquals(false, SetUtils.isEqualSet(a, null));\n+        assertEquals(false, SetUtils.isEqualSet(null, b));\n+        assertEquals(true, SetUtils.isEqualSet(null, null));\n+    }\n+\n+    public void testHashCode() {\n+        Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        Set<String> a = new HashSet<String>(data);\n+        Set<String> b = new HashSet<String>(data);\n+\n+        assertEquals(true, a.hashCode() == b.hashCode());\n+        assertEquals(true, a.hashCode() == SetUtils.hashCodeForSet(a));\n+        assertEquals(true, b.hashCode() == SetUtils.hashCodeForSet(b));\n+        assertEquals(true, SetUtils.hashCodeForSet(a) == SetUtils.hashCodeForSet(b));\n+        a.clear();\n+        assertEquals(false, SetUtils.hashCodeForSet(a) == SetUtils.hashCodeForSet(b));\n+        assertEquals(0, SetUtils.hashCodeForSet(null));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/SplitMapUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.functors.NOPTransformer;\n+import org.apache.commons.collections.map.HashedMap;\n+import org.apache.commons.collections.splitmap.TransformedMap;\n+\n+/**\n+ * Tests for {@link TransformedMap}\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class SplitMapUtilsTest extends BulkTest {\n+    private Map<String, Integer> backingMap;\n+    private TransformedMap<String, String, String, Integer> transformedMap;\n+\n+    private Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public SplitMapUtilsTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        backingMap = new HashMap<String, Integer>();\n+        transformedMap = TransformedMap.transformingMap(backingMap, NOPTransformer.<String> nopTransformer(),\n+                stringToInt);\n+        for (int i = 0; i < 10; i++) {\n+            transformedMap.put(String.valueOf(i), String.valueOf(i));\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testReadableMap() {\n+        final IterableMap<String, Integer> map = SplitMapUtils.readableMap(transformedMap);\n+\n+        // basic\n+        for (int i = 0; i < 10; i++) {\n+            assertFalse(map.containsValue(String.valueOf(i)));\n+            assertEquals(i, map.get(String.valueOf(i)).intValue());\n+        }\n+\n+        // mapIterator\n+        MapIterator<String, Integer> it = map.mapIterator();\n+        while (it.hasNext()) {\n+            String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(Integer.valueOf(k), it.getValue());\n+        }\n+\n+        // unmodifiable\n+        assertTrue(map instanceof Unmodifiable);\n+\n+        // check individual operations\n+        int sz = map.size();\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.clear();\n+            }\n+        });\n+\n+        assertEquals(sz, map.size());\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.put(\"foo\", 100);\n+            }\n+        });\n+\n+        final HashMap<String, Integer> m = new HashMap<String, Integer>();\n+        m.put(\"foo\", 100);\n+        m.put(\"bar\", 200);\n+        m.put(\"baz\", 300);\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.putAll(m);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // remove\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(i, map.remove(String.valueOf(i)).intValue());\n+            assertEquals(--sz, map.size());\n+        }\n+        assertTrue(map.isEmpty());\n+        assertSame(map, SplitMapUtils.readableMap(map));\n+    }\n+\n+    public void testAlreadyReadableMap() {\n+        HashedMap<String, Integer> hashedMap = new HashedMap<String, Integer>();\n+        assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testWritableMap() {\n+        final Map<String, String> map = SplitMapUtils.writableMap(transformedMap);\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.get(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.entrySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.keySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.values();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.size();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.isEmpty();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsKey(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsValue(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.remove(null);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        Map<String, String> other = SplitMapUtils.writableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // put\n+        int sz = backingMap.size();\n+        assertFalse(backingMap.containsKey(\"foo\"));\n+        map.put(\"new\", \"66\");\n+        assertEquals(++sz, backingMap.size());\n+\n+        // putall\n+        Map<String, String> more = new HashMap<String, String>();\n+        more.put(\"foo\", \"77\");\n+        more.put(\"bar\", \"88\");\n+        more.put(\"baz\", \"99\");\n+        map.putAll(more);\n+        assertEquals(sz + more.size(), backingMap.size());\n+\n+        // clear\n+        map.clear();\n+        assertTrue(backingMap.isEmpty());\n+        assertSame(map, SplitMapUtils.writableMap((Put<String, String>) map));\n+    }\n+\n+    public void testAlreadyWritableMap() {\n+        HashedMap<String, String> hashedMap = new HashedMap<String, String>();\n+        assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));\n+    }\n+\n+    private void attemptGetOperation(Runnable r) {\n+        attemptMapOperation(\"Put exposed as writable Map must not allow Get operations\", r);\n+    }\n+\n+    private void attemptPutOperation(Runnable r) {\n+        attemptMapOperation(\"Get exposed as writable Map must not allow Put operations\", r);\n+    }\n+\n+    private void attemptMapOperation(String s, Runnable r) {\n+        try {\n+            r.run();\n+            fail(s);\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TransformerUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.functors.CloneTransformer;\n+import org.apache.commons.collections.functors.ConstantTransformer;\n+import org.apache.commons.collections.functors.EqualPredicate;\n+import org.apache.commons.collections.functors.ExceptionTransformer;\n+import org.apache.commons.collections.functors.FalsePredicate;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+import org.apache.commons.collections.functors.StringValueTransformer;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Tests the org.apache.commons.collections.TransformerUtils class.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ * @author James Carman\n+ */\n+public class TransformerUtilsTest extends junit.framework.TestCase {\n+\n+    private static final Object cObject = new Object();\n+    private static final Object cString = \"Hello\";\n+    private static final Object cInteger = new Integer(6);\n+\n+    /**\n+     * Construct\n+     */\n+    public TransformerUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() {\n+    }\n+\n+    // exceptionTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionTransformer() {\n+        assertNotNull(TransformerUtils.exceptionTransformer());\n+        assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer());\n+        try {\n+            TransformerUtils.exceptionTransformer().transform(null);\n+        } catch (FunctorException ex) {\n+            try {\n+                TransformerUtils.exceptionTransformer().transform(cString);\n+            } catch (FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nullTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testNullTransformer() {\n+        assertNotNull(TransformerUtils.nullTransformer());\n+        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(null));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cObject));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cString));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cInteger));\n+    }\n+\n+    // nopTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testNopTransformer() {\n+        assertNotNull(TransformerUtils.nullTransformer());\n+        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n+        assertEquals(null, TransformerUtils.nopTransformer().transform(null));\n+        assertEquals(cObject, TransformerUtils.nopTransformer().transform(cObject));\n+        assertEquals(cString, TransformerUtils.nopTransformer().transform(cString));\n+        assertEquals(cInteger, TransformerUtils.nopTransformer().transform(cInteger));\n+    }\n+\n+    // constantTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testConstantTransformer() {\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(null));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cObject));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cString));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cInteger));\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.constantTransformer(null));\n+    }\n+\n+    // cloneTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testCloneTransformer() {\n+        assertEquals(null, TransformerUtils.cloneTransformer().transform(null));\n+        assertEquals(cString, TransformerUtils.cloneTransformer().transform(cString));\n+        assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));\n+        try {\n+            assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject));\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // mapTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testMapTransformer() {\n+        Map<Object, Integer> map = new HashMap<Object, Integer>();\n+        map.put(null, 0);\n+        map.put(cObject, 1);\n+        map.put(cString, 2);\n+        assertEquals(new Integer(0), TransformerUtils.mapTransformer(map).transform(null));\n+        assertEquals(new Integer(1), TransformerUtils.mapTransformer(map).transform(cObject));\n+        assertEquals(new Integer(2), TransformerUtils.mapTransformer(map).transform(cString));\n+        assertEquals(null, TransformerUtils.mapTransformer(map).transform(cInteger));\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.mapTransformer(null));\n+    }\n+\n+    // commandTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testExecutorTransformer() {\n+        assertEquals(null, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));\n+        assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));\n+        assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));\n+        assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Closure<Object>) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // predicateTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testPredicateTransformer() {\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(null));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cObject));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cString));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Predicate<Object>) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // factoryTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testFactoryTransformer() {\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(null));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cObject));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cString));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Factory<Object>) null);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // chainedTransformer\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testChainedTransformer() {\n+        Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer(\"A\");\n+        Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) \"B\");\n+\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).transform(null));\n+        assertEquals(\"B\", TransformerUtils.chainedTransformer(a, b).transform(null));\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(new Transformer[] { b, a }).transform(null));\n+        Collection<Transformer<Object, Object>> coll = new ArrayList<Transformer<Object, Object>>();\n+        coll.add(b);\n+        coll.add(a);\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(coll).transform(null));\n+\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(new Transformer[0]));\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(Collections.<Transformer<Object, Object>>emptyList()));\n+\n+        try {\n+            TransformerUtils.chainedTransformer(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer((Transformer[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer(new Transformer[] {null, null});\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList<Transformer<Object, Object>>();\n+            coll.add(null);\n+            coll.add(null);\n+            TransformerUtils.chainedTransformer(coll);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // switchTransformer\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSwitchTransformer() {\n+        Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n+\n+        assertEquals(null, TransformerUtils.<Object, String>switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"THERE\"));\n+\n+        assertEquals(\"C\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }, c).transform(\"WELL\"));\n+\n+        Map<Predicate<String>, Transformer<String, String>> map = new HashMap<Predicate<String>, Transformer<String,String>>();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        assertEquals(null, TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(map).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(map).transform(\"THERE\"));\n+        map.put(null, c);\n+        assertEquals(\"C\", TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n+\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]));\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new HashMap<Predicate<Object>, Transformer<Object, Object>>()));\n+        map = new HashMap<Predicate<String>, Transformer<String, String>>();\n+        map.put(null, null);\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(map));\n+\n+        try {\n+            TransformerUtils.switchTransformer(null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer((Predicate[]) null, (Transformer[]) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer((Map<Predicate<Object>, Transformer<Object, Object>>) null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer(\n+                    new Predicate[] { TruePredicate.truePredicate() },\n+                    new Transformer[] { a, b });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // switchMapTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchMapTransformer() {\n+        Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+\n+        Map<String, Transformer<String, String>> map = new HashMap<String, Transformer<String,String>>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        assertEquals(null, TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchMapTransformer(map).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchMapTransformer(map).transform(\"THERE\"));\n+        map.put(null, c);\n+        assertEquals(\"C\", TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n+\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(new HashMap<Object, Transformer<Object, Object>>()));\n+        map = new HashMap<String, Transformer<String, String>>();\n+        map.put(null, null);\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(map));\n+\n+        try {\n+            TransformerUtils.switchMapTransformer(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // invokerTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testInvokerTransformer() {\n+        List<Object> list = new ArrayList<Object>();\n+        assertEquals(new Integer(0), TransformerUtils.invokerTransformer(\"size\").transform(list));\n+        list.add(new Object());\n+        assertEquals(new Integer(1), TransformerUtils.invokerTransformer(\"size\").transform(list));\n+        assertEquals(null, TransformerUtils.invokerTransformer(\"size\").transform(null));\n+\n+        try {\n+            TransformerUtils.invokerTransformer(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"noSuchMethod\").transform(new Object());\n+            fail();\n+        } catch (FunctorException ex) {}\n+    }\n+\n+    // invokerTransformer2\n+    //------------------------------------------------------------------\n+\n+    public void testInvokerTransformer2() {\n+        List<Object> list = new ArrayList<Object>();\n+        assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n+        list.add(cString);\n+        assertEquals(Boolean.TRUE, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n+        assertEquals(null, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(null));\n+\n+        try {\n+            TransformerUtils.invokerTransformer(null, null, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"noSuchMethod\", new Class[] { Object.class },\n+                    new Object[] { cString }).transform(new Object());\n+            fail();\n+        } catch (FunctorException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", null, new Object[] { cString });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", new Class[] { Object.class }, null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", new Class[] {}, new Object[] { cString });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    // stringValueTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testStringValueTransformer() {\n+        assertNotNull( \"StringValueTransformer should NEVER return a null value.\",\n+           TransformerUtils.stringValueTransformer().transform(null));\n+        assertEquals( \"StringValueTransformer should return \\\"null\\\" when given a null argument.\", \"null\",\n+            TransformerUtils.stringValueTransformer().transform(null));\n+        assertEquals( \"StringValueTransformer should return toString value\", \"6\",\n+            TransformerUtils.stringValueTransformer().transform(new Integer(6)));\n+    }\n+\n+    // instantiateFactory\n+    //------------------------------------------------------------------\n+\n+    public void testInstantiateTransformerNull() {\n+        try {\n+            TransformerUtils.instantiateTransformer(null, new Object[] { \"str\" });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.instantiateTransformer(new Class[] {}, new Object[] { \"str\" });\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+\n+        Transformer<Class<?>, Object> trans = TransformerUtils.instantiateTransformer(new Class[] { Long.class }, new Object[] { null });\n+        try {\n+            trans.transform(String.class);\n+            fail();\n+        } catch (FunctorException ex) {}\n+\n+        trans = TransformerUtils.instantiateTransformer();\n+        assertEquals(\"\", trans.transform(String.class));\n+\n+        trans = TransformerUtils.instantiateTransformer(new Class[] { Long.TYPE }, new Object[] { new Long(1000L) });\n+        assertEquals(new Date(1000L), trans.transform(Date.class));\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Transformer singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                CloneTransformer.INSTANCE,\n+                ExceptionTransformer.INSTANCE,\n+                NOPTransformer.INSTANCE,\n+                StringValueTransformer.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/collections/bag/AbstractBagTest.java\n+++ b/src/test/java/org/apache/commons/collections/bag/AbstractBagTest.java\n import java.util.List;\n import java.util.NoSuchElementException;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n import org.apache.commons.collections.Bag;\n \n /**\n  *\n  * @version $Id$\n  */\n-public abstract class AbstractBagTest<T> extends AbstractTestObject {\n+public abstract class AbstractBagTest<T> extends AbstractObjectTest {\n //  TODO: this class should really extend from TestCollection, but the bag\n //  implementations currently do not conform to the Collection interface.  Once\n //  those are fixed or at least a strategy is made for resolving the issue, this\n--- a/src/test/java/org/apache/commons/collections/buffer/BlockingBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/BlockingBufferTest.java\n  */\n package org.apache.commons.collections.buffer;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n import org.apache.commons.collections.Buffer;\n import org.apache.commons.collections.BufferUnderflowException;\n \n import java.util.Set;\n \n /**\n- * Extension of {@link AbstractTestObject} for exercising the\n+ * Extension of {@link AbstractObjectTest} for exercising the\n  * {@link BlockingBuffer} implementation.\n  *\n  * @since 3.0\n  * @version $Id$\n  */\n-public class BlockingBufferTest<E> extends AbstractTestObject {\n+public class BlockingBufferTest<E> extends AbstractObjectTest {\n \n     public BlockingBufferTest(String testName) {\n         super(testName);\n--- a/src/test/java/org/apache/commons/collections/buffer/BoundedBufferTest.java\n+++ b/src/test/java/org/apache/commons/collections/buffer/BoundedBufferTest.java\n  */\n package org.apache.commons.collections.buffer;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n import org.apache.commons.collections.BoundedCollection;\n import org.apache.commons.collections.Buffer;\n import org.apache.commons.collections.BufferOverflowException;\n import java.util.Collections;\n import java.util.Arrays;\n \n-public class BoundedBufferTest<E> extends AbstractTestObject {\n+public class BoundedBufferTest<E> extends AbstractObjectTest {\n \n     public BoundedBufferTest(String testName) {\n         super(testName);\n--- a/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n import java.util.Map;\n import java.util.NoSuchElementException;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n \n /**\n  * Abstract test class for {@link java.util.Collection} methods and contracts.\n  * @author Neil O'Toole\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractCollectionTest<E> extends AbstractTestObject {\n+public abstract class AbstractCollectionTest<E> extends AbstractObjectTest {\n \n     //\n     // NOTE:\n--- a/src/test/java/org/apache/commons/collections/comparators/AbstractComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections/comparators/AbstractComparatorTest.java\n import java.util.LinkedList;\n import java.util.List;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n import org.junit.Test;\n \n /**\n  * Concrete subclasses declare the comparator to be tested.\n  * They also declare certain aspects of the tests.\n  */\n-public abstract class AbstractComparatorTest<T> extends AbstractTestObject {\n+public abstract class AbstractComparatorTest<T> extends AbstractObjectTest {\n \n     /**\n      * JUnit constructor.\n--- a/src/test/java/org/apache/commons/collections/iterators/AbstractTestIterator.java\n+++ b/src/test/java/org/apache/commons/collections/iterators/AbstractTestIterator.java\n import java.util.Iterator;\n import java.util.NoSuchElementException;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n \n /**\n  * Abstract class for testing the Iterator interface.\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractTestIterator<E> extends AbstractTestObject {\n+public abstract class AbstractTestIterator<E> extends AbstractObjectTest {\n \n     /**\n      * JUnit constructor.\n--- a/src/test/java/org/apache/commons/collections/map/AbstractTestMap.java\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractTestMap.java\n import java.util.Map.Entry;\n import java.util.Set;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.CollectionUtils;\n import org.apache.commons.collections.collection.AbstractCollectionTest;\n  * @author Stephen Colebourne\n  * @version $Revision$\n  */\n-public abstract class AbstractTestMap<K, V> extends AbstractTestObject {\n+public abstract class AbstractTestMap<K, V> extends AbstractObjectTest {\n \n     /**\n      * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString\n--- a/src/test/java/org/apache/commons/collections/map/TestIdentityMap.java\n+++ b/src/test/java/org/apache/commons/collections/map/TestIdentityMap.java\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n import org.apache.commons.collections.IterableMap;\n \n /**\n  *\n  * @author Stephen Colebourne\n  */\n-public class TestIdentityMap<K, V> extends AbstractTestObject {\n+public class TestIdentityMap<K, V> extends AbstractObjectTest {\n \n     private static final Integer I1A = new Integer(1);\n     private static final Integer I1B = new Integer(1);\n--- a/src/test/java/org/apache/commons/collections/map/TestMultiValueMap.java\n+++ b/src/test/java/org/apache/commons/collections/map/TestMultiValueMap.java\n import org.apache.commons.collections.IteratorUtils;\n import org.apache.commons.collections.MultiMap;\n \n-import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.AbstractObjectTest;\n \n /**\n  * TestMultiValueMap.\n  * @author Stephen Colebourne\n  * @since Commons Collections 3.2\n  */\n-public class TestMultiValueMap<K, V> extends AbstractTestObject {\n+public class TestMultiValueMap<K, V> extends AbstractObjectTest {\n \n     public TestMultiValueMap(String testName) {\n         super(testName);", "timestamp": 1345836982, "metainfo": ""}