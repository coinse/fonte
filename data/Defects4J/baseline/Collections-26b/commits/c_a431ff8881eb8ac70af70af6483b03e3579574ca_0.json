{"sha": "a431ff8881eb8ac70af70af6483b03e3579574ca", "log": "[COLLECTIONS-508] javadoc cleanup, interface review.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n      * @return <tt>true</tt> if this map contains a mapping for the specified key\n      * @throws ClassCastException if the key is of an inappropriate type for this map (optional)\n      * @throws NullPointerException if the specified key is null and this map\n-     *         does not permit null keys (optional)\n+     *        does not permit null keys (optional)\n      */\n     boolean containsKey(Object key);\n \n      *\n      * @param value the value to search for\n      * @return true if the map contains the value\n-     * @throws ClassCastException if the value is of an invalid type\n-     * @throws NullPointerException if the value is null and null value are invalid\n+     * @throws ClassCastException if the type of the specified value is not compatible\n+     *        with the used collection (optional)\n+     * @throws NullPointerException if the value is null and null values are not supported\n+     *        by the used collection types (optional)\n      */\n     boolean containsValue(Object value);\n \n     boolean containsMapping(Object key, Object value);\n \n     /**\n-     * Gets the collection of values associated with the specified key.\n-     * <p>\n-     * Implementations are free to declare that they return\n-     * <code>Collection</code> subclasses such as <code>List</code> or\n-     * <code>Set</code>.\n-     * <p>\n-     * Implementations typically return <code>null</code> if no values have been\n-     * mapped to the key, however the implementation may choose to return an\n-     * empty collection.\n-     * <p>\n-     * Implementations may choose to return a clone of the internal collection.\n+     * Returns a view collection of the values associated with the specified key.\n+     * <p>\n+     * This method will return an <b>empty</b> collection if {@link #containsKey(Object)}\n+     * returns {@code false}. Changes to the returned collection will update the\n+     * underlying {@code MultiValuedMap} and vice-versa.\n      *\n      * @param key the key to retrieve\n      * @return the <code>Collection</code> of values, implementations should\n      *         return <code>null</code> for no mapping, but may return an empty collection\n-     * @throws ClassCastException if the key is of an invalid type\n-     * @throws NullPointerException if the key is null and null keys are invalid\n+     * @throws ClassCastException if the key is of an invalid type (optional)\n+     * @throws NullPointerException if the key is null and null keys are invalid (optional)\n      */\n     Collection<V> get(Object key);\n \n     // Modification operations\n \n     /**\n-     * Adds the value to the collection associated with the specified key.\n+     * Adds a key-value mapping to this multi-valued map.\n      * <p>\n      * Unlike a normal <code>Map</code> the previous value is not replaced.\n      * Instead the new value is added to the collection stored against the key.\n-     * The collection may be a <code>List</code>, <code>Set</code> or other\n-     * collection dependent on implementation.\n+     * Depending on the collection type used, duplicate key-value mappings may\n+     * be allowed.\n+     * <p>\n+     * The method will return {@code true} if the size of the multi-valued map\n+     * has been increased because of this operation.\n      *\n      * @param key the key to store against\n      * @param value the value to add to the collection at the key\n-     * @return typically the value added if the map changed and null if the map\n-     *         did not change\n-     * @throws UnsupportedOperationException if the map is unmodifiable\n-     * @throws ClassCastException if the key or value is of an invalid type\n-     * @throws NullPointerException if the key or value is null and null is invalid\n-     * @throws IllegalArgumentException if the key or value is invalid\n-     */\n-    V put(K key, V value);\n-\n-    /**\n-     * Adds Iterable values to the collection associated with the specified key.\n+     * @return {@code true} if the map changed as a result of this put operation, or\n+     *        {@code false} if the map already contained the key-value mapping and the\n+     *        collection type does not allow duplicate values, e.g. when using a Set\n+     * @throws UnsupportedOperationException if the put operation is not supported by\n+     *        this multi-valued map, e.g. if it is unmodifiable\n+     * @throws ClassCastException if the key or value is of an invalid type (optional)\n+     * @throws NullPointerException if the key or value is null and null is invalid (optional)\n+     * @throws IllegalArgumentException if some aspect of the specified key or value prevents\n+     *        it from being stored in this multi-valued map\n+     */\n+    boolean put(K key, V value);\n+\n+    /**\n+     * Adds a mapping to the specified key for all values contained in the given Iterable.\n      *\n      * @param key the key to store against\n      * @param values the values to add to the collection at the key, null ignored\n-     * @return true if this map changed\n+     * @return {@code true} if the map changed as a result of this operation\n      */\n     boolean putAll(K key, Iterable<? extends V> values);\n \n     /**\n-     * Copies all of the mappings from the specified map to this map (optional\n-     * operation). The effect of this call is equivalent to that of calling\n+     * Copies all mappings from the specified map to this multi-valued map (optional operation).\n+     * <p>\n+     * The effect of this call is equivalent to that of calling\n      * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n-     * from key <tt>k</tt> to value <tt>v</tt> in the specified map. The\n-     * behavior of this operation is undefined if the specified map is modified\n+     * from key <tt>k</tt> to value <tt>v</tt> in the specified map.\n+     * <p>\n+     * The behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n      * @param m mappings to be stored in this map\n      * @throws UnsupportedOperationException if the <tt>putAll</tt> operation is\n-     *         not supported by this map\n+     *        not supported by this map\n      * @throws ClassCastException if the class of a key or value in the\n-     *         specified map prevents it from being stored in this map\n+     *        specified map prevents it from being stored in this map (optional)\n      * @throws NullPointerException if the specified map is null, or if this map\n-     *         does not permit null keys or values, and the specified map\n-     *         contains null keys or values\n+     *        does not permit null keys or values, and the specified map\n+     *        contains null keys or values (optional)\n      * @throws IllegalArgumentException if some property of a key or value in\n-     *         the specified map prevents it from being stored in this map\n+     *        the specified map prevents it from being stored in this map\n      */\n     void putAll(Map<? extends K, ? extends V> m);\n \n     /**\n-     * Copies all of the mappings from the specified MultiValuedMap to this map\n-     * (optional operation). The effect of this call is equivalent to that of\n+     * Copies all mappings from the specified map to this multi-valued map (optional operation).\n+     * <p>\n+     * The effect of this call is equivalent to that of\n      * calling {@link #put(Object,Object) put(k, v)} on this map once for each\n-     * mapping from key <tt>k</tt> to value <tt>v</tt> in the specified map. The\n-     * behavior of this operation is undefined if the specified map is modified\n+     * mapping from key <tt>k</tt> to value <tt>v</tt> in the specified map.\n+     * <p>\n+     * The behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n      * @param m mappings to be stored in this map\n      * @throws UnsupportedOperationException if the <tt>putAll</tt> operation is\n-     *         not supported by this map\n+     *        not supported by this map\n      * @throws ClassCastException if the class of a key or value in the\n-     *         specified map prevents it from being stored in this map\n+     *        specified map prevents it from being stored in this map (optional)\n      * @throws NullPointerException if the specified map is null, or if this map\n-     *         does not permit null keys or values, and the specified map\n-     *         contains null keys or values\n+     *        does not permit null keys or values, and the specified map\n+     *        contains null keys or values (optional)\n      * @throws IllegalArgumentException if some property of a key or value in\n-     *         the specified map prevents it from being stored in this map\n+     *        the specified map prevents it from being stored in this map\n      */\n     void putAll(MultiValuedMap<? extends K, ? extends V> m);\n \n     /**\n      * Removes all values associated with the specified key.\n      * <p>\n-     * Implementations typically return <code>null</code> from a subsequent\n-     * <code>get(Object)</code>, however they may choose to return an empty\n-     * collection.\n+     * The returned collection <i>may</i> be modifiable, but updates will not be propagated\n+     * to this multi-valued map. In case no mapping was stored for the specified\n+     * key, an empty, unmodifiable collection will be returned.\n      *\n      * @param key the key to remove values from\n-     * @return the <code>Collection</code> of values removed, implementations\n-     *         should return <code>null</code> for no mapping found, but may\n-     *         return an empty collection\n+     * @return the values that were removed\n      * @throws UnsupportedOperationException if the map is unmodifiable\n-     * @throws ClassCastException if the key is of an invalid type\n-     * @throws NullPointerException if the key is null and null keys are invalid\n+     * @throws ClassCastException if the key is of an invalid type (optional)\n+     * @throws NullPointerException if the key is null and null keys are invalid (optional)\n      */\n     Collection<V> remove(Object key);\n \n      * @param item the item to remove\n      * @return {@code true} if the mapping was removed, {@code false} otherwise\n      * @throws UnsupportedOperationException if the map is unmodifiable\n-     * @throws ClassCastException if the key or value is of an invalid type\n-     * @throws NullPointerException if the key or value is null and null is\n-     *         invalid\n+     * @throws ClassCastException if the key or value is of an invalid type (optional)\n+     * @throws NullPointerException if the key or value is null and null is invalid (optional)\n      */\n     boolean removeMapping(K key, V item);\n \n     /**\n      * Removes all of the mappings from this map (optional operation).\n+     * <p>\n      * The map will be empty after this call returns.\n      *\n      * @throws UnsupportedOperationException if the map is unmodifiable\n     // Views\n \n     /**\n-     * Returns a {@link Collection} view of the mappings contained in this map.\n+     * Returns a {@link Collection} view of the mappings contained in this multi-valued map.\n+     * <p>\n      * The collection is backed by the map, so changes to the map are reflected\n-     * in this, and vice-versa.\n+     * in the collection, and vice-versa.\n      *\n      * @return a set view of the mappings contained in this map\n      */\n     Collection<Entry<K, V>> entries();\n \n     /**\n-     * Returns a {@link Bag} view of the key mapping contained in this map.\n-     * <p>\n-     * Implementations typically return a Bag of keys with its values count as\n-     * the count of the Bag. This bag is backed by the map, so any changes in\n-     * the map is reflected here.\n-     *\n-     * @return a bag view of the key mapping contained in this map\n+     * Returns a {@link Bag} view of the keys contained in this multi-valued map.\n+     * <p>\n+     * The {@link Bag#getCount(Object)} method of the returned bag will give the\n+     * same result a calling {@code get(Object).size()} for the same key.\n+     * <p>\n+     * This bag is backed by the map, so any changes in the map are reflected in the bag.\n+     *\n+     * @return a bag view of the keys contained in this map\n      */\n     Bag<K> keys();\n \n     /**\n-     * Returns a {@link Set} view of the keys contained in this map. The set is\n-     * backed by the map, so changes to the map are reflected in the set, and\n-     * vice-versa. If the map is modified while an iteration over the set is in\n+     * Returns a {@link Set} view of the keys contained in this multi-valued map.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected\n+     * in the set, and vice-versa.\n+     * <p>\n+     * If the map is modified while an iteration over the set is in\n      * progress (except through the iterator's own <tt>remove</tt> operation),\n-     * the results of the iteration are undefined. The set supports element\n+     * the result of the iteration is undefined. The set supports element\n      * removal, which removes the corresponding mapping from the map, via the\n      * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n      * <tt>retainAll</tt>, and <tt>clear</tt> operations. It does not support\n     Set<K> keySet();\n \n     /**\n-     * Gets a collection containing all the values in the map.\n+     * Gets a {@link Collection} view of all values contained in this multi-valued map.\n      * <p>\n      * Implementations typically return a collection containing the combination\n      * of values from all keys.\n     // Iterators\n \n     /**\n-     * Obtains a <code>MapIterator</code> over the map.\n+     * Obtains a <code>MapIterator</code> over this multi-valued map.\n      * <p>\n      * A map iterator is an efficient way of iterating over maps. There is no\n-     * need to access the entries collection or use Map Entry objects.\n+     * need to access the entries collection or use {@code Map.Entry} objects.\n      *\n      * @return a map iterator\n      */\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n import java.util.AbstractCollection;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Map.Entry;\n      * @throws ClassCastException if the key is of an invalid type\n      */\n     public Collection<V> remove(Object key) {\n-        return getMap().remove(key);\n+        Collection<V> coll = getMap().remove(key);\n+        return coll == null ? Collections.<V>emptyList() : coll;\n     }\n \n     /**\n      *\n      * @param key the key to store against\n      * @param value the value to add to the collection at the key\n-     * @return the value added if the map changed and null if the map did not\n-     *         change\n-     */\n-    public V put(K key, V value) {\n+     * @return the value added if the map changed and null if the map did not change\n+     */\n+    public boolean put(K key, V value) {\n         boolean result = false;\n         Collection<V> coll = getMap().get(key);\n         if (coll == null) {\n         } else {\n             result = coll.add(value);\n         }\n-        return result ? value : null;\n+        return result;\n     }\n \n     /**\n         public boolean add(V value) {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n-                V addedVal = AbstractMultiValuedMap.this.put((K) key, value);\n-                return addedVal != null ? true : false;\n+                return AbstractMultiValuedMap.this.put((K) key, value);\n             }\n             return col.add(value);\n         }\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n         decorated().clear();\n     }\n \n-    public V put(K key, V value) {\n+    public boolean put(K key, V value) {\n         return decorated().put(key, value);\n     }\n \n--- a/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java\n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public boolean put(K key, V value) {\n         K transformedKey = transformKey(key);\n         V transformedValue = transformValue(value);\n         return decorated().put(transformedKey, transformedValue);\n--- a/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n     }\n \n     @Override\n-    public V put(K key, V value) {\n+    public boolean put(K key, V value) {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n         assertFalse(map.containsValue(\"uno\"));\n         assertFalse(map.containsValue(\"un\"));\n         assertEquals(4, map.size());\n-        assertNull(map.remove(\"one\"));\n+        col = map.remove(\"one\");\n+        assertNotNull(col);\n+        assertEquals(0, col.size());\n     }\n \n     public void testRemoveMappingThroughGetIterator() {\n         assertFalse(map.containsValue(\"uno\"));\n         assertFalse(map.containsValue(\"un\"));\n         assertEquals(4, map.size());\n-        assertNull(map.remove(\"one\"));\n+        Collection<V> coll = map.remove(\"one\");\n+        assertNotNull(coll);\n+        assertEquals(0, coll.size());\n     }\n \n     public void testContainsValue() {\n--- a/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n     public void testPutWithList() {\n         final MultiValuedHashMap<K, V> test =\n                 (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(ArrayList.class);\n-        assertEquals(\"a\", test.put((K) \"A\", (V) \"a\"));\n-        assertEquals(\"b\", test.put((K) \"A\", (V) \"b\"));\n+        assertEquals(true, test.put((K) \"A\", (V) \"a\"));\n+        assertEquals(true, test.put((K) \"A\", (V) \"b\"));\n+        assertEquals(true, test.put((K) \"A\", (V) \"a\"));\n         assertEquals(1, test.keySet().size());\n-        assertEquals(2, test.get(\"A\").size());\n-        assertEquals(2, test.size());\n+        assertEquals(3, test.get(\"A\").size());\n+        assertEquals(3, test.size());\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testPutWithSet() {\n         final MultiValuedHashMap<K, V> test =\n                 (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(HashSet.class);\n-        assertEquals(\"a\", test.put((K) \"A\", (V) \"a\"));\n-        assertEquals(\"b\", test.put((K) \"A\", (V) \"b\"));\n-        assertEquals(null, test.put((K) \"A\", (V) \"a\"));\n+        assertEquals(true, test.put((K) \"A\", (V) \"a\"));\n+        assertEquals(true, test.put((K) \"A\", (V) \"b\"));\n+        assertEquals(false, test.put((K) \"A\", (V) \"a\"));\n         assertEquals(1, test.keySet().size());\n         assertEquals(2, test.get(\"A\").size());\n         assertEquals(2, test.size());\n--- a/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n  */\n package org.apache.commons.collections4.multimap;\n \n+import java.util.Collection;\n+\n import junit.framework.Test;\n \n import org.apache.commons.collections4.BulkTest;\n import org.apache.commons.collections4.Transformer;\n import org.apache.commons.collections4.TransformerUtils;\n import org.apache.commons.collections4.collection.TransformedCollectionTest;\n-import org.apache.commons.collections4.multimap.TransformedMultiValuedMap;\n \n /**\n  * Tests for TransformedMultiValuedMap\n             assertEquals(true, map.get(Integer.valueOf((String) els[i])).contains(els[i]));\n         }\n \n-        assertEquals(null, map.remove(els[0]));\n+        Collection<V> coll = map.remove(els[0]);\n+        assertNotNull(coll);\n+        assertEquals(0, coll.size());\n         assertEquals(true, map.remove(Integer.valueOf((String) els[0])).contains(els[0]));\n     }\n ", "timestamp": 1396908189, "metainfo": ""}