{"sha": "570ddedd98dc1f5c640eade7048d67a7c1b97eac", "log": "Unify exception messages across map implementations   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/Flat3Map.java\n+++ b/src/java/org/apache/commons/collections/map/Flat3Map.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/Flat3Map.java,v 1.6 2003/12/03 19:03:50 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/Flat3Map.java,v 1.7 2003/12/06 14:02:11 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.6 $ $Date: 2003/12/03 19:03:50 $\n+ * @version $Revision: 1.7 $ $Date: 2003/12/06 14:02:11 $\n  *\n  * @author Stephen Colebourne\n  */\n \n         public Object next() {\n             if (hasNext() == false) {\n-                throw new NoSuchElementException(\"No more elements in the iteration\");\n+                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n             }\n             iCanRemove = true;\n             iIndex++;\n \n         public void remove() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n             }\n             iFlatMap.remove(getKey());\n             iIndex--;\n \n         public Object getKey() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object getValue() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object setValue(Object value) {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Map Entry cannot be changed\");\n+                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n             }\n             Object old = getValue();\n             switch (iIndex) {\n         \n         public String toString() {\n             if (iCanRemove) {\n-                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n             } else {\n-                return \"MapIterator[]\";\n+                return \"Iterator[]\";\n             }\n         }\n     }\n \n         public Object next() {\n             if (hasNext() == false) {\n-                throw new NoSuchElementException(\"No more elements in the iteration\");\n+                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n             }\n             iCanRemove = true;\n             iIndex++;\n \n         public void remove() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n             }\n             iFlatMap.remove(getKey());\n             iIndex--;\n \n         public Object getKey() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object getValue() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object setValue(Object value) {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(\"Map Entry cannot be changed\");\n+                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n             }\n             Object old = getValue();\n             switch (iIndex) {\n--- a/src/java/org/apache/commons/collections/map/HashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/HashedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.6 2003/12/06 13:03:15 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.7 2003/12/06 14:02:11 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.6 $ $Date: 2003/12/06 13:03:15 $\n+ * @version $Revision: 1.7 $ $Date: 2003/12/06 14:02:11 $\n  *\n  * @author java util HashMap\n  * @author Stephen Colebourne\n  */\n public class HashedMap implements IterableMap, Serializable, Cloneable {\n+    \n+    protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";\n+    protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";\n+    protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";\n+    protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";\n+    protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";\n+    protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";\n     \n     /** Serialisation version */\n     static final long serialVersionUID = -1593250834999590599L;\n         public Object getKey() {\n             HashEntry current = currentEntry();\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n             }\n             return current.getKey();\n         }\n         public Object getValue() {\n             HashEntry current = currentEntry();\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n         public Object setValue(Object value) {\n             HashEntry current = currentEntry();\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n             }\n             return current.setValue(value);\n         }\n             }\n             HashEntry newCurrent = next;\n             if (newCurrent == null)  {\n-                throw new NoSuchElementException(\"No more elements in the iteration\");\n+                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n             }\n             HashEntry[] data = map.data;\n             int i = hashIndex;\n         \n         public void remove() {\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n             }\n             if (map.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n--- a/src/java/org/apache/commons/collections/map/LinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/LinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.1 2003/12/03 19:04:41 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.2 2003/12/06 14:02:11 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <code>ResettableIterator</code> and calling <code>reset()</code>.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/12/03 19:04:41 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/06 14:02:11 $\n  *\n  * @author java util LinkedHashMap\n  * @author Stephen Colebourne\n         public Object getKey() {\n             HashEntry current = currentEntry();\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n             }\n             return current.getKey();\n         }\n         public Object getValue() {\n             HashEntry current = currentEntry();\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n             }\n             return current.getValue();\n         }\n         public Object setValue(Object value) {\n             HashEntry current = currentEntry();\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n             }\n             return current.setValue(value);\n         }\n                 throw new ConcurrentModificationException();\n             }\n             if (next == map.header)  {\n-                throw new NoSuchElementException(\"No more elements in the iteration\");\n+                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n             }\n             current = next;\n             next = next.after;\n             }\n             LinkedEntry previous = next.before;\n             if (previous == map.header)  {\n-                throw new NoSuchElementException(\"No more elements in the iteration\");\n+                throw new NoSuchElementException(HashedMap.NO_PREVIOUS_ENTRY);\n             }\n             next = previous;\n             current = previous;\n         \n         public void remove() {\n             if (current == null) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n             }\n             if (map.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n--- a/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.6 2003/12/05 20:23:57 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.7 2003/12/06 14:02:11 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * original position in the iteration.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.6 $ $Date: 2003/12/05 20:23:57 $\n+ * @version $Revision: 1.7 $ $Date: 2003/12/06 14:02:11 $\n  * \n  * @author Henri Yandell\n  * @author Stephen Colebourne\n         \n         public void remove() {\n             if (readable == false) {\n-                throw new IllegalStateException(\"Iterator remove() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n             }\n             iterator.remove();\n             parent.map.remove(last);\n         \n         public Object getKey() {\n             if (readable == false) {\n-                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n             }\n             return last;\n         }\n \n         public Object getValue() {\n             if (readable == false) {\n-                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n             }\n             return parent.get(last);\n         }\n         \n         public Object setValue(Object value) {\n             if (readable == false) {\n-                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n             }\n             return parent.map.put(last, value);\n         }\n         \n         public String toString() {\n             if (readable == true) {\n-                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n             } else {\n-                return \"MapIterator[]\";\n+                return \"Iterator[]\";\n             }\n         }\n     }", "timestamp": 1070719331, "metainfo": ""}