{"sha": "37b1a1287610ae4e92d1ec4b53f3bb0d2a9528a0", "log": "apply Rich Dougherty's patch fixing NodeCachingLinkedList unit tests this also adds CommonsLinkedList and tests   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/CommonsLinkedList.java\n+package org.apache.commons.collections;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.AbstractSequentialList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * An implementation of {@link java.util.List} which duplicates the behaviour\n+ * of {@link java.util.LinkedList}, but which provides a more open interface for\n+ * subclasses to extend.\n+ * \n+ * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n+ */\n+class CommonsLinkedList extends LinkedList\n+    implements List, Serializable {\n+\n+    /*\n+     * Implementation notes:\n+     * - a standard circular doubly-linked list\n+     * - a marker node is stored to mark the start and the end of the list\n+     * - node creation and removal always occurs through createNode() and\n+     *   removeNode().\n+     * - a modification count is kept, with the same semantics as\n+     * {@link java.util.LinkedList}.\n+     * - respects {@link AbstractList#modCount}\n+     */\n+\n+    /**\n+     * A node within the {@link CommonsLinkedList}.\n+     * \n+     * @author <a href=\"mailto:rich@nil.co.nz\">Rich Dougherty</a>\n+     */\n+    protected static class Node {\n+\n+        /**\n+         * A pointer to the node before this node.\n+         */\n+        public Node previous;\n+\n+        /**\n+         * A pointer to the node after this node.\n+         */\n+        public Node next;\n+\n+        /**\n+         * The object contained within this node.\n+         */\n+        public Object element;\n+\n+        public Node() {\n+        }\n+\n+        public Node(Node previous, Node next, Object element) {\n+            this.previous = previous;\n+            this.next = next;\n+            this.element = element;\n+        }\n+\n+        /**\n+         * Checks if a value is equal to this node's element.\n+         *\n+         * @return True if the elements are both null or both equal according\n+         * to {@link Object#equals()}.\n+         */\n+        public boolean elementEquals(Object otherElement) {\n+            if (element == null) {\n+                return otherElement == null;\n+            } else {\n+                return element.equals(otherElement);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A {@link java.util.ListIterator} {@link CommonsLinkedList}. \n+     * \n+     * @author <a href=\"mailto:rich@nil.co.nz\">Rich Dougherty</a>\n+     */\n+    protected class ListIteratorImpl implements ListIterator {\n+\n+        /**\n+         * The node that will be returned by {@link #next()}. If this is equal\n+         * to {@link #marker} then there are no more elements to return.\n+         */\n+        protected Node nextNode;\n+\n+        /**\n+         * The index of {@link #nextNode}.\n+         */\n+        protected int nextIndex;\n+\n+        /**\n+         * The last node that was returned by {@link #next()} or {@link\n+         * #previous()}. Set to <code>null</code> if {@link #next()} or {@link\n+         * #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         * Should be accesed through {@link #getLastNodeReturned()} to enforce\n+         * this behaviour.\n+         */\n+        protected Node lastNodeReturned;\n+\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list, starting at the first element in\n+         * the list.\n+         */\n+        public ListIteratorImpl() throws IndexOutOfBoundsException {\n+            this(0);\n+        }\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         * \n+         * @param startIndex The index to start at.\n+         */\n+        public ListIteratorImpl(int startIndex)\n+                throws IndexOutOfBoundsException {\n+            expectedModCount = modCount;\n+            nextNode = getNode(startIndex, true);\n+            nextIndex = startIndex;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         * \n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount()\n+            throws ConcurrentModificationException {\n+            if (modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        /**\n+         * Gets the last node returned.\n+         * \n+         * @throws IllegalStateException If {@link #next()} or {@link\n+         * #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         */\n+        protected Node getLastNodeReturned() throws IllegalStateException {\n+            if (lastNodeReturned == null) {\n+                throw new IllegalStateException();\n+            }\n+            return lastNodeReturned;\n+        }\n+\n+        public boolean hasNext() {\n+            return nextNode != marker;\n+        }\n+\n+        public Object next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" +\n+                        nextIndex + \".\");\n+            }\n+            Object element = nextNode.element;\n+            lastNodeReturned = nextNode;\n+            nextNode = nextNode.next;\n+            nextIndex++;\n+            return element;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return nextNode.previous != marker;\n+        }\n+\n+        public Object previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            nextNode = nextNode.previous;\n+            Object element = nextNode.element;\n+            lastNodeReturned = nextNode;\n+            nextIndex--;\n+            return element;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            return nextIndex - 1;\n+        }\n+\n+        public void remove() {\n+            checkModCount();\n+            removeNode(getLastNodeReturned());\n+            lastNodeReturned = null;\n+            nextIndex--;\n+            expectedModCount++;\n+        }\n+\n+        public void set(Object o) {\n+            checkModCount();\n+            getLastNodeReturned().element = o;\n+        }\n+\n+        public void add(Object o) {\n+            checkModCount();\n+            addNodeBefore(nextNode, o);\n+            lastNodeReturned = null;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * A {@link Node} which ndicates the start and end of the list and does not\n+     * hold a value. The value of <code>next</code> is the first item in the\n+     * list. The value of of <code>previous</code> is the last item in the list.\n+     */\n+    protected transient Node marker;\n+\n+    /**\n+     * The size of the list.\n+     */\n+    protected transient int size;\n+\n+    public CommonsLinkedList() {\n+        initializeEmptyList();\n+    }\n+\n+    public CommonsLinkedList(Collection c) {\n+        initializeEmptyList();\n+        addAll(c);\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor, broken out so it can be called\n+     * by any constructor and by {@link #readObject(ObjectInputStream)}.\n+     * Subclasses which override this method should make sure they call it so\n+     * the list is initialised properly.\n+     */\n+    protected void initializeEmptyList() {\n+        marker = createNode();\n+        marker.next = marker;\n+        marker.previous = marker;\n+    }\n+\n+    // Operations on nodes\n+\n+    protected Node createNode() {\n+        return new Node();\n+    }\n+\n+    protected Node createNode(Node next, Node previous, Object element) {\n+        return new Node(next, previous, element);\n+    }\n+\n+    private void addNodeBefore(Node node, Object o) {\n+        Node newNode = createNode(node.previous, node, o);\n+        node.previous.next = newNode;\n+        node.previous = newNode;\n+        size++;\n+        modCount++;\n+    }\n+\n+    protected void addNodeAfter(Node node, Object o) {\n+        Node newNode = createNode(node, node.next, o);\n+        node.next.previous = newNode;\n+        node.next = newNode;\n+        size++;\n+        modCount++;\n+    }\n+\n+    protected void removeNode(Node node) {\n+        node.previous.next = node.next;\n+        node.next.previous = node.previous;\n+        size--;\n+        modCount++;\n+    }\n+\n+    protected void removeAllNodes() {\n+        marker.next = marker;\n+        marker.previous = marker;\n+        size = 0;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Gets the node at a particular index.\n+     * \n+     * @param index The index, starting from 0.\n+     * @param endMarkerAllowd Whether or not the end marker can be returned if\n+     * startIndex is set to the list's size.\n+     * @throws IndexOutOfBoundsException If the index is less than 0; equal to\n+     * the size of the list and endMakerAllowed is false; or greater than the\n+     * size of the list.\n+     */\n+    protected Node getNode(int index, boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n+        // Check the index is within the bounds\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") less than zero.\");\n+        }\n+        if (!endMarkerAllowed && index == size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") is the size of the list.\");\n+        }\n+        if (index > size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") greater than the size of the \" +\n+                    \"list (\" + size + \").\");\n+        }\n+        // Search the list and get the node\n+        Node node;\n+        if (index < (size / 2)) {\n+            // Search forwards\n+            node = marker.next;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                node = node.next;\n+            }\n+        } else {\n+            // Search backwards\n+            node = marker;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                node = node.previous;\n+            }\n+        }\n+        return node;\n+    }\n+\n+    // List implementation required by AbstractSequentialList\n+\n+    public ListIterator listIterator() {\n+        return new ListIteratorImpl();\n+    }\n+\n+    public ListIterator listIterator(int startIndex) {\n+        return new ListIteratorImpl(startIndex);\n+    }\n+\n+    public int size() {\n+        return size;\n+    }\n+\n+    // List implementation not required by AbstractSequentialList, but provided\n+    // for efficiency or to override LinkedList's implementation.\n+    \n+    public void clear() {\n+        removeAllNodes();\n+    }\n+    \n+    public boolean add(Object o) {\n+        addLast(o);\n+        return true;\n+    }\n+    \n+    public void add(int index, Object element) {\n+        Node node = getNode(index, true);\n+        addNodeBefore(node, element);\n+    }\n+    \n+    public boolean addAll(Collection c) {\n+        return addAll(size, c);\n+    }\n+\n+    public boolean addAll(int index, Collection c) {\n+        Node node = getNode(index, true);\n+        for (Iterator itr = c.iterator(); itr.hasNext();) {\n+            Object element = itr.next();\n+            addNodeBefore(node, element);\n+        }\n+        return true;\n+    }\n+\n+    public Object get(int index) {\n+        Node node = getNode(index, false);\n+        return node.element;\n+    }\n+\n+    public Object set(int index, Object element) {\n+        Node node = getNode(index, false);\n+        Object oldElement = node.element;\n+        node.element = element;\n+        return oldElement;\n+    }\n+\n+    public Object remove(int index) {\n+        Node node = getNode(index, false);\n+        Object oldElement = node.element;\n+        removeNode(node);\n+        return oldElement;\n+    }\n+\n+    public boolean remove(Object element) {\n+        for (Node node = marker.next; node != marker; node = node.next) {\n+            if (node.elementEquals(element)) {\n+                removeNode(node);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public int indexOf(Object element) {\n+        int i = 0;\n+        for (Node node = marker.next; node != marker; node = node.next) {\n+            if (node.elementEquals(element)) {\n+                return i;\n+            }\n+            i++;\n+        }\n+        return -1;\n+    }\n+\n+    public int lastIndexOf(Object element) {\n+        int i = size - 1;\n+        for (Node node = marker.previous; node != marker; node = node.previous) {\n+            if (node.elementEquals(element)) {\n+                return i;\n+            }\n+            i--;\n+        }\n+        return -1;\n+    }\n+\n+    public boolean contains(Object element) {\n+        return indexOf(element) != -1;\n+    }\n+\n+    public Object[] toArray() {\n+        return toArray(new Object[size]);\n+    }\n+\n+    public Object[] toArray(Object[] array) {\n+        // Extend the array if needed\n+        if (array.length < size) {\n+            Class componentType = array.getClass().getComponentType();\n+            array = (Object[]) Array.newInstance(componentType, size);\n+        }\n+        // Copy the values into the array\n+        Node node = marker.next;\n+        for (int i = 0; i < size; i++) {\n+            array[i] = node.element;\n+            node = node.next;\n+        }\n+        // Set the value after the last element to null\n+        if (array.length > size) {\n+            array[size] = null;\n+        }\n+        return array;\n+    }\n+    // Extra methods compatible with java.util.LinkedList.\n+\n+    public Object getFirst() {\n+        Node node = marker.next;\n+        if (node == marker) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.element;\n+    }\n+\n+    public Object getLast() {\n+        Node node = marker.previous;\n+        if (node == marker) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.element;\n+    }\n+\n+    public void addFirst(Object o) {\n+        addNodeAfter(marker, o);\n+    }\n+\n+    public void addLast(Object o) {\n+        addNodeBefore(marker, o);\n+    }\n+\n+    public Object removeFirst() {\n+        Node node = marker.next;\n+        if (node == marker) {\n+            throw new NoSuchElementException();\n+        }\n+        Object oldElement = node.element;\n+        removeNode(node);\n+        return oldElement;\n+    }\n+\n+    public Object removeLast() {\n+        Node node = marker.previous;\n+        if (node == marker) {\n+            throw new NoSuchElementException();\n+        }\n+        Object oldElement = node.element;\n+        removeNode(node);\n+        return oldElement;\n+    }\n+\n+    // Serialization methods\n+\n+    private void writeObject(ObjectOutputStream outputStream)\n+        throws IOException, ClassNotFoundException {\n+        outputStream.defaultWriteObject();\n+        // Write the size so we know how many nodes to read back\n+        outputStream.writeInt(size());\n+        for (Iterator itr = iterator(); itr.hasNext();) {\n+            outputStream.writeObject(itr.next());\n+        }\n+    }\n+\n+    private void readObject(ObjectInputStream inputStream)\n+        throws IOException, ClassNotFoundException {\n+        inputStream.defaultReadObject();\n+        initializeEmptyList();\n+        int size = inputStream.readInt();\n+        for (int i = 0; i < size; i++) {\n+            add(inputStream.readObject());\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/collections/NodeCachingLinkedList.java\n+++ b/src/java/org/apache/commons/collections/NodeCachingLinkedList.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/NodeCachingLinkedList.java,v 1.1 2002/11/18 23:58:17 scolebourne Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/18 23:58:17 $\n- *\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n-package org.apache.commons.collections;\n-\n-import java.io.Serializable;\n-import java.util.Collection;\n-import java.util.ConcurrentModificationException;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.NoSuchElementException;\n-/**\n- * <code>NodeCachingLinkedList</code> is a linked list implementation that \n- * provides better performance than java.util.LinkedList.\n- * <p>\n- * This class differs from java.util.LinkedList in that internal Node \n- * objects used to hold the elements are not necessarily thrown away when an\n- * entry is removed from the list. Instead, they are cached, which allows this\n- * implementation to give better performance than java.util.LinkedList with a\n- * small space penalty.\n- * <p>\n- * <b>Note that this implementation is not synchronized.</b> If multiple\n- * threads access a list concurrently, and at least one of the threads\n- * modifies the list structurally, it <i>must</i> be synchronized\n- * externally.\n- * <p>\n- * The iterators returned by the this class's <code>iterator</code> and\n- * <code>listIterator</code> methods are <i>fail-fast</i>: if the list is\n- * structurally modified at any time after the iterator is created, in any way\n- * except through the Iterator's own <code>remove</code> or <code>add</code> methods,\n- * the iterator will throw a <code>ConcurrentModificationException</code>.  Thus,\n- * in the face of concurrent modification, the iterator fails quickly and\n- * cleanly, rather than risking arbitrary, non-deterministic behavior at an\n- * undetermined time in the future.\n- * <p>\n- * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n- * as it is, generally speaking, impossible to make any hard guarantees in the\n- * presence of unsynchronized concurrent modification.  Fail-fast iterators\n- * throw <code>ConcurrentModificationException</code> on a best-effort basis. \n- * Therefore, it would be wrong to write a program that depended on this\n- * exception for its correctness:   <i>the fail-fast behavior of iterators\n- * should be used only to detect bugs.</i>\n- *\n- * @author Jeff Varszegi\n- */\n-public final class NodeCachingLinkedList \n-        extends LinkedList \n-        implements List, Cloneable, Serializable {\n-            \n-    private static final int MINIMUM_MAXIMUM_CACHE_SIZE = 100;\n-    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000000;\n-\n-    private Node cacheHeader = new Node(null, null, null);\n-    private int cacheCount = 0;\n-\n-    private int maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n-\n-    private Node header = new Node(null, null, null);\n-    private int size = 0;\n-    \n-    /**\n-     * Constructs an empty list.\n-     */\n-    public NodeCachingLinkedList() {\n-        header.next = header.previous = header;\n-    }\n-\n-    /**\n-     * Constructs a list containing the elements of the specified\n-     * collection, in the order they are returned by the collection's\n-     * iterator.\n-     *\n-     * @param coll the collection whose elements are to be placed into this list.\n-     * @throws NullPointerException if the specified collection is null.\n-     */\n-    public NodeCachingLinkedList(Collection coll) {\n-        this();\n-        addAll(coll);\n-    }\n-    \n-    /**\n-     * Sets the maximum number of elements that may be held in the internal\n-     * reusable node cache.\n-     * \n-     * @return the maximum cache size\n-     */\n-    public int getMaximumCacheSize() {\n-        return maximumCacheSize;\n-    }\n-\n-    /**\n-     * Sets the maximum number of elements that may be held in the internal\n-     * reusable node cache.\n-     * \n-     * @param maximumCacheSize the maximum cache size to set\n-     */\n-    public void setMaximumCacheSize(int maximumCacheSize) {\n-        this.maximumCacheSize = maximumCacheSize;\n-    }\n-    \n-    /**\n-     * Returns the first element in this list.\n-     * \n-     * @return the first object in the list\n-     * @throws NoSuchElementException if this list is empty\n-     */\n-    public Object getFirst() {\n-        if (size == 0) {\n-            throw new NoSuchElementException();\n-        }\n-        else {\n-            return header.next.element;\n-        }\n-    }\n-\n-    /**\n-     * Returns the last element in this list.\n-     * \n-     * @return the last object in the list\n-     * @throws NoSuchElementException if this list is empty\n-     */\n-    public Object getLast() {\n-        if (size == 0) {\n-            throw new NoSuchElementException();\n-        }\n-        return header.previous.element;\n-    }\n-\n-    /**\n-     * Removes and returns the first element from this list.\n-     *\n-     * @return the first element from this list, now removed\n-     * @throws NoSuchElementException if this list is empty\n-     */\n-    public Object removeFirst() {\n-        if (size == 0) {\n-            throw new NoSuchElementException(); \n-        }\n-        Node firstNode = header.next;\n-        Object first = firstNode.element;\n-        \n-        firstNode.next.previous = header;\n-        header.next = firstNode.next;\n-        size--;\n-        modCount++;\n-\n-        if (cacheCount < maximumCacheSize) {\n-            \n-            firstNode.element = null;\n-            firstNode.next = cacheHeader.next;\n-            cacheHeader.next = firstNode;\n-            cacheCount++;\n-        }\n-                \n-        return first;\n-    }\n-\n-    /**\n-     * Removes and returns the last element from this list.\n-     *\n-     * @return the last element from this list, now removed\n-     * @throws NoSuchElementException if this list is empty\n-     */\n-    public Object removeLast() {\n-        if (size == 0) {\n-            throw new NoSuchElementException(); \n-\n-        }\n-        Node lastNode = header.previous;\n-        Object last = lastNode.element;\n-\n-        lastNode.previous.next = header;\n-        header.previous = lastNode.previous;\n-        size--;\n-        modCount++;\n-\n-        if (cacheCount < maximumCacheSize) {\n-            lastNode.element = null;\n-            lastNode.previous = null;\n-            lastNode.next = cacheHeader.next;\n-            cacheHeader.next = lastNode;\n-            cacheCount++;\n-        }\n-        \n-        return last;\n-    }\n-    \n-    /**\n-     * Inserts the given element at the beginning of this list.\n-     * \n-     * @param obj the element to be inserted at the beginning of this list\n-     */\n-    public void addFirst(Object obj) {\n-        Node newNode;\n-          \n-        if (cacheCount > 0) {\n-            newNode = cacheHeader.next;\n-            cacheHeader.next = newNode.next;\n-            newNode.element = obj;\n-            newNode.next = header.next;\n-            newNode.previous = header;\n-            cacheCount--;\n-        }\n-        else {\n-            newNode = new Node(obj, header.next, header);\n-        }\n-        \n-        newNode.previous.next = newNode;\n-        newNode.next.previous = newNode;\n-        size++;\n-        modCount++;\n-    }\n-    \n-    /**\n-     * Appends the given element to the end of this list.  (Identical in\n-     * function to the <code>add</code> method; included only for consistency.)\n-     * \n-     * @param obj the element to be inserted at the end of this list\n-     */\n-    public void addLast(Object obj) {\n-        Node newNode;\n-\n-        if (cacheCount > 0) {\n-            newNode = cacheHeader.next;\n-            cacheHeader.next = newNode.next;\n-            newNode.element = obj;\n-            newNode.next = header.next;\n-            newNode.previous = header;\n-            cacheCount--;\n-        }\n-        else {\n-            newNode = new Node(obj, header, header.previous);\n-        }\n-\n-\n-  \n-        newNode.previous.next = newNode;\n-        newNode.next.previous = newNode;\n-        size++;\n-        modCount++;\n-    }\n-\n-    /**\n-     * Returns <code>true</code> if this list contains the specified element.\n-     * More formally, returns <code>true</code> if and only if this list contains\n-     * at least one element <code>e</code> such that <code>(o==null ? e==null\n-     * : o.equals(e))</code>.\n-     *\n-     * @param obj element whose presence in this list is to be tested\n-     * @return <code>true</code> if this list contains the specified element\n-     */\n-    public boolean contains(Object obj) {\n-        return indexOf(obj) != -1;\n-    }\n-\n-    /**\n-     * Returns the number of elements in this list.\n-     *\n-     * @return the number of elements in this list\n-     */\n-    public int size() {\n-        return size;\n-    }\n-\n-    /**\n-     * Appends the specified element to the end of this list.\n-     *\n-     * @param obj element to be appended to this list.\n-     * @return <code>true</code> (as per the general contract of\n-     * <code>Collection.add</code>)\n-     */\n-    public boolean add(Object obj) {\n-        addLast(obj);\n-        return true;\n-    }\n-\n-    /**\n-     * Removes the first occurrence of the specified element in this list.  If\n-     * the list does not contain the element, it is unchanged.  More formally,\n-     * removes the element with the lowest index <code>i</code> such that\n-     * <code>(o==null ? get(i)==null : o.equals(get(i)))</code> (if such an\n-     * element exists).\n-     *\n-     * @param obj element to be removed from this list, if present\n-     * @return <code>true</code> if the list contained the specified element\n-     */\n-    public boolean remove(Object obj) {\n-        if (obj == null) {\n-            for (Node e = header.next; e != header; e = e.next) {\n-                if (e.element == null) {\n-                    remove(e);\n-                    return true;\n-                }\n-            }\n-        }\n-        else {\n-            for (Node e = header.next; e != header; e = e.next) {\n-                if (obj.equals(e.element)) {\n-                    remove(e);\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Appends all of the elements in the specified collection to the end of\n-     * this list, in the order that they are returned by the specified\n-     * collection's iterator.  The behavior of this operation is undefined if\n-     * the specified collection is modified while the operation is in\n-     * progress.  (This implies that the behavior of this call is undefined if\n-     * the specified Collection is this list, and this list is nonempty.)\n-     *\n-     * @param coll the elements to be inserted into this list\n-     * @return <code>true</code> if this list changed as a result of the call\n-     * @throws NullPointerException if the specified collection is null\n-     */\n-    public boolean addAll(Collection coll) {\n-        return addAll(size, coll);\n-    }\n-\n-    /**\n-     * Inserts all of the elements in the specified collection into this\n-     * list, starting at the specified position.  Shifts the element\n-     * currently at that position (if any) and any subsequent elements to\n-     * the right (increases their indices).  The new elements will appear\n-     * in the list in the order that they are returned by the\n-     * specified collection's iterator.\n-     *\n-     * @param index index at which to insert first element\n-     *          from the specified collection\n-     * @param coll elements to be inserted into this list\n-     * @return <code>true</code> if this list changed as a result of the call\n-     * @throws IndexOutOfBoundsException if the specified index is out of\n-     *            range (<code>index &lt; 0 || index &gt; size()</code>)\n-     * @throws NullPointerException if the specified collection is null\n-     */\n-    public boolean addAll(int index, Collection coll) {\n-        int numNew = coll.size();\n-        if (numNew == 0)\n-            return false;\n-        modCount++;\n-\n-        Node successor = (index == size ? header : entry(index));\n-        Node predecessor = successor.previous;\n-        Iterator it = coll.iterator();\n-        for (int i = 0; i < numNew; i++) {\n-            Node e; \n-            if (cacheCount > 0) {\n-                e = cacheHeader.next;\n-                cacheHeader.next = e.next;\n-                e.element = it.next();\n-                e.next = successor;\n-                e.previous = predecessor;\n-            }\n-            else {\n-                e = new Node(it.next(), successor, predecessor);\n-            }\n-            \n-            predecessor.next = e;\n-            predecessor = e;\n-        }\n-        successor.previous = predecessor;\n-\n-        size += numNew;\n-        return true;\n-    }\n-\n-    /**\n-     * Removes all of the elements from this list.\n-     */\n-    public void clear() {\n-        modCount++;\n-        header.next = header.previous = header;\n-        size = 0;\n-    }\n-\n-    // Positional Access Operations\n-\n-    /**\n-     * Returns the element at the specified position in this list.\n-     *\n-     * @param index index of element to return\n-     * @return the element at the specified position in this list\n-     * \n-     * @throws IndexOutOfBoundsException if the specified index is is out of\n-     * range (<code>index &lt; 0 || index &gt;= size()</code>)\n-     */\n-    public Object get(int index) {\n-        if (index < 0 || index >= size) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n-        }\n-        Node e = header;\n-        if (index < (size >> 1)) {\n-            for (int i = 0; i <= index; i++) {\n-                e = e.next;\n-            }\n-        }\n-        else {\n-            for (int i = size; i > index; i--) {\n-                e = e.previous;\n-            }\n-        }\n-        return e.element;\n-    }\n-\n-    /**\n-     * Replaces the element at the specified position in this list with the\n-     * specified element.\n-     *\n-     * @param index index of element to replace\n-     * @param element element to be stored at the specified position\n-     * @return the element previously at the specified position\n-     * @throws IndexOutOfBoundsException if the specified index is out of\n-     *        range (<code>index &lt; 0 || index &gt;= size()</code>)\n-     */\n-    public Object set(int index, Object element) {\n-        Node e = entry(index);\n-        Object oldVal = e.element;\n-        e.element = element;\n-        return oldVal;\n-    }\n-\n-    /**\n-     * Inserts the specified element at the specified position in this list.\n-     * Shifts the element currently at that position (if any) and any\n-     * subsequent elements to the right (adds one to their indices).\n-     *\n-     * @param index index at which the specified element is to be inserted\n-     * @param element element to be inserted\n-     * \n-     * @throws IndexOutOfBoundsException if the specified index is out of\n-     *        range (<code>index &lt; 0 || index &gt; size()</code>)\n-     */\n-    public void add(int index, Object element) {\n-        Node e = (index == size ? header : entry(index));\n-        Node newNode; \n-        if (cacheCount > 0) {\n-            newNode = cacheHeader.next;\n-            cacheHeader.next = newNode.next;\n-            newNode.element = element;\n-            newNode.next = e;\n-            newNode.previous = e.previous;\n-        }\n-        else {\n-            newNode = new Node(element, e, e.previous);\n-        }\n-        \n-        newNode.previous.next = newNode;\n-        newNode.next.previous = newNode;\n-        size++;\n-        modCount++;\n-    }\n-\n-    /**\n-     * Removes the element at the specified position in this list.  Shifts any\n-     * subsequent elements to the left (subtracts one from their indices).\n-     * Returns the element that was removed from the list.\n-     *\n-     * @param index the index of the element to removed\n-     * @return the element previously at the specified position\n-     * \n-     * @throws IndexOutOfBoundsException if the specified index is out of\n-     *        range (<code>index &lt; 0 || index &gt;= size()</code>)\n-     */\n-    public Object remove(int index) {\n-        Node e = entry(index);\n-        Object data = e.element;\n-        remove(e);\n-        return data;\n-    }\n-\n-    /**\n-     * Return the indexed entry.\n-     */\n-    private Node entry(int index) {\n-        if (index < 0 || index >= size) {\n-            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n-        }\n-        Node e = header;\n-        if (index < (size >> 1)) {\n-            for (int i = 0; i <= index; i++) {\n-                e = e.next;\n-            }\n-        }\n-        else {\n-            for (int i = size; i > index; i--) {\n-                e = e.previous;\n-            }\n-        }\n-        return e;\n-    }\n-\n-    // Search Operations\n-\n-    /**\n-     * Returns the index in this list of the first occurrence of the\n-     * specified element, or -1 if the List does not contain this\n-     * element.  More formally, returns the lowest index i such that\n-     * <code>(o==null ? get(i)==null : o.equals(get(i)))</code>, or -1 if\n-     * there is no such index.\n-     *\n-     * @param obj element to search for\n-     * @return the index in this list of the first occurrence of the\n-     *         specified element, or -1 if the list does not contain this\n-     *         element\n-     */\n-    public int indexOf(Object obj) {\n-        int index = 0;\n-        if (obj == null) {\n-            for (Node e = header.next; e != header; e = e.next) {\n-                if (e.element == null)\n-                    return index;\n-                index++;\n-            }\n-        }\n-        else {\n-            for (Node e = header.next; e != header; e = e.next) {\n-                if (obj.equals(e.element))\n-                    return index;\n-                index++;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * Returns the index in this list of the last occurrence of the\n-     * specified element, or -1 if the list does not contain this\n-     * element.  More formally, returns the highest index i such that\n-     * <code>(o==null ? get(i)==null : o.equals(get(i)))</code>, or -1 if\n-     * there is no such index.\n-     *\n-     * @param obj element to search for\n-     * @return the index in this list of the last occurrence of the\n-     *         specified element, or -1 if the list does not contain this\n-     *         element\n-     */\n-    public int lastIndexOf(Object obj) {\n-        int index = size;\n-        if (obj == null) {\n-            for (Node e = header.previous; e != header; e = e.previous) {\n-                index--;\n-                if (e.element == null)\n-                    return index;\n-            }\n-        }\n-        else {\n-            for (Node e = header.previous; e != header; e = e.previous) {\n-                index--;\n-                if (obj.equals(e.element))\n-                    return index;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    /**\n-     * Returns a list-iterator of the elements in this list (in proper\n-     * sequence), starting at the specified position in the list.\n-     * Obeys the general contract of <code>List.listIterator(int)</code>.<p>\n-     * <p>\n-     * The list-iterator is <i>fail-fast</i>: if the list is structurally\n-     * modified at any time after the Iterator is created, in any way except\n-     * through the list-iterator's own <code>remove</code> or <code>add</code>\n-     * methods, the list-iterator will throw a\n-     * <code>ConcurrentModificationException</code>.  Thus, in the face of\n-     * concurrent modification, the iterator fails quickly and cleanly, rather\n-     * than risking arbitrary, non-deterministic behavior at an undetermined\n-     * time in the future.\n-     *\n-     * @param index index of first element to be returned from the\n-     *          list-iterator (by a call to <code>next</code>)\n-     * @return a ListIterator of the elements in this list (in proper\n-     *         sequence), starting at the specified position in the list\n-     * @throws    IndexOutOfBoundsException if index is out of range\n-     *        (<code>index &lt; 0 || index &gt; size()</code>)\n-     * @see List#listIterator(int)\n-     */\n-    public ListIterator listIterator(int index) {\n-        return new ListItr(index);\n-    }\n-\n-    private final class ListItr implements ListIterator {\n-        private Node lastReturned = header;\n-        private Node next;\n-        private int nextIndex;\n-        private int expectedModCount = modCount;\n-\n-        ListItr(int index) {\n-            if (index < 0 || index > size)\n-                throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n-            if (index < (size >> 1)) {\n-                next = header.next;\n-                for (nextIndex = 0; nextIndex < index; nextIndex++)\n-                    next = next.next;\n-            }\n-            else {\n-                next = header;\n-                for (nextIndex = size; nextIndex > index; nextIndex--)\n-                    next = next.previous;\n-            }\n-        }\n-\n-        public boolean hasNext() {\n-            return nextIndex != size;\n-        }\n-\n-        public Object next() {\n-            checkForComodification();\n-            if (nextIndex == size)\n-                throw new NoSuchElementException();\n-\n-            lastReturned = next;\n-            next = next.next;\n-            nextIndex++;\n-            return lastReturned.element;\n-        }\n-\n-        public boolean hasPrevious() {\n-            return nextIndex != 0;\n-        }\n-\n-        public Object previous() {\n-            if (nextIndex == 0)\n-                throw new NoSuchElementException();\n-\n-            lastReturned = next = next.previous;\n-            nextIndex--;\n-            checkForComodification();\n-            return lastReturned.element;\n-        }\n-\n-        public int nextIndex() {\n-            return nextIndex;\n-        }\n-\n-        public int previousIndex() {\n-            return nextIndex - 1;\n-        }\n-\n-        public void remove() {\n-            checkForComodification();\n-            try {\n-                NodeCachingLinkedList.this.remove(lastReturned);\n-            }\n-            catch (NoSuchElementException e) {\n-                throw new IllegalStateException();\n-            }\n-            if (next == lastReturned)\n-                next = lastReturned.next;\n-            else\n-                nextIndex--;\n-            lastReturned = header;\n-            expectedModCount++;\n-        }\n-\n-        public void set(Object o) {\n-            if (lastReturned == header)\n-                throw new IllegalStateException();\n-            checkForComodification();\n-            lastReturned.element = o;\n-        }\n-\n-        public void add(Object o) {\n-            checkForComodification();\n-            lastReturned = header;\n-\n-            Node newNode; \n-            if (cacheCount > 0) {\n-                newNode = cacheHeader.next;\n-                cacheHeader.next = newNode.next;\n-                newNode.element = o;\n-                newNode.next = next;\n-                newNode.previous = next.previous;\n-            }\n-            else {\n-                newNode = new Node(o, next, next.previous);\n-            }\n-            \n-            newNode.previous.next = newNode;\n-            newNode.next.previous = newNode;\n-            size++;\n-            modCount++;\n-\n-            nextIndex++;\n-            expectedModCount++;\n-        }\n-\n-        private void checkForComodification() {\n-            if (modCount != expectedModCount)\n-                throw new ConcurrentModificationException();\n-        }\n-    }\n-\n-    private final static class Node implements Serializable {\n-        Object element;\n-        Node next;\n-        Node previous;\n-\n-        Node(Object element, Node next, Node previous) {\n-            this.element = element;\n-            this.next = next;\n-            this.previous = previous;\n-        }\n-    }\n-\n-\n-    private Node addsBefore(Object o, Node e) {\n-        Node newNode; \n-        if (cacheCount > 0) {\n-            newNode = cacheHeader.next;\n-            cacheHeader.next = newNode.next;\n-            newNode.element = o;\n-            newNode.next = e;\n-            newNode.previous = e.previous;\n-        }\n-        else {\n-            newNode = new Node(o, e, e.previous);\n-        }\n-        \n-        newNode.previous.next = newNode;\n-        newNode.next.previous = newNode;\n-        size++;\n-        modCount++;\n-        return newNode;\n-    }\n-\n-\n-    private void remove(Node e) {\n-        if (e == header) {\n-            throw new NoSuchElementException();\n-        }\n-        e.previous.next = e.next;\n-        e.next.previous = e.previous;\n-        size--;\n-        modCount++;\n-        \n-        if (cacheCount < maximumCacheSize) {\n-            e.element = null;\n-            e.previous = null;\n-            e.next = cacheHeader.next;\n-            cacheHeader.next = e;\n-            cacheCount++;\n-        }\n-    }\n-\n-    /**\n-     * Returns a shallow copy of this <code>NodeCachingLinkedList</code>. (The elements\n-     * themselves are not cloned.)\n-     *\n-     * @return a shallow copy of this <code>NodeCachingLinkedList</code> instance\n-     */\n-    public Object clone() {\n-        NodeCachingLinkedList clone = new NodeCachingLinkedList();\n-        clone.setMaximumCacheSize(maximumCacheSize);\n-        \n-        // Initialize clone with our elements\n-        for (Node e = header.next; e != header; e = e.next) {\n-            clone.add(e.element);\n-        }\n-\n-        return clone;\n-    }\n-\n-    /**\n-     * Returns an array containing all of the elements in this list\n-     * in the correct order.\n-     *\n-     * @return an array containing all of the elements in this list\n-     *         in the correct order\n-     */\n-    public Object[] toArray() {\n-        Object[] result = new Object[size];\n-        int i = 0;\n-        for (Node e = header.next; e != header; e = e.next)\n-            result[i++] = e.element;\n-        return result;\n-    }\n-\n-    /**\n-     * Returns an array containing all of the elements in this list in\n-     * the correct order; the runtime type of the returned array is that of\n-     * the specified array.  If the list fits in the specified array, it\n-     * is returned therein.  Otherwise, a new array is allocated with the\n-     * runtime type of the specified array and the size of this list.<p>\n-     * <p>\n-     * If the list fits in the specified array with room to spare\n-     * (i.e., the array has more elements than the list),\n-     * the element in the array immediately following the end of the\n-     * collection is set to null.  This is useful in determining the length\n-     * of the list <i>only</i> if the caller knows that the list\n-     * does not contain any null elements.\n-     *\n-     * @param a the array into which the elements of the list are to\n-     *      be stored, if it is big enough; otherwise, a new array of the\n-     *      same runtime type is allocated for this purpose\n-     * @return an array containing the elements of the list\n-     * @throws ArrayStoreException if the runtime type of a is not a\n-     *         supertype of the runtime type of every element in this list\n-     * @throws NullPointerException if the specified array is null\n-     */\n-    public Object[] toArray(Object a[]) {\n-        if (a.length < size)\n-            a = (Object[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);\n-        int i = 0;\n-        for (Node e = header.next; e != header; e = e.next)\n-            a[i++] = e.element;\n-\n-        if (a.length > size)\n-            a[size] = null;\n-\n-        return a;\n-    }\n-    \n-}\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A linked list implementation that caches the nodes used internally to prevent\n+ * unnecessary object creates and deletion. This should result in a performance\n+ * improvement.\n+ * \n+ * @author Jeff Varszegi\n+ * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n+ */\n+public class NodeCachingLinkedList extends CommonsLinkedList {\n+\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * The default value for {@link #maximumCacheSize}.\n+     */\n+    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;\n+\n+    /**\n+     * The first cached node, or <code>null</code> if no nodes are cached.\n+     * Cached nodes are stored in a singly-linked list with {@link Node#next}\n+     * pointing to the next element.\n+     */\n+    private transient Node firstCachedNode;\n+    \n+    /**\n+     * The size of the cache.\n+     */\n+    private transient int cacheSize = 0;\n+\n+    /**\n+     * The maximum size of the cache.\n+     */\n+    private int maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n+\n+    public NodeCachingLinkedList() {\n+        super();\n+    }\n+\n+    public NodeCachingLinkedList(Collection c) {\n+        super(c);\n+    }\n+    \n+    public NodeCachingLinkedList(int maximumCacheSize) {\n+        super();\n+        this.maximumCacheSize = maximumCacheSize;\n+    }\n+\n+    // Cache operations\n+\n+    /**\n+     * Gets the maximum size of the cache.\n+     */\n+    public int getMaximumCacheSize() {\n+        return maximumCacheSize;\n+    }\n+\n+    /**\n+     * Sets the maximum size of the cache.\n+     */\n+    public void setMaximumCacheSize(int maximumCacheSize) {\n+        this.maximumCacheSize = maximumCacheSize;\n+        shrinkCacheToMaximumSize();\n+    }\n+\n+    /**\n+     * Reduce the size of the cache to the maximum, if necessary.\n+     */\n+    private void shrinkCacheToMaximumSize() {\n+        // Rich Dougherty: This could be more efficient.\n+        while (cacheSize > maximumCacheSize) {\n+            getNodeFromCache();\n+        }\n+    }\n+    \n+    /**\n+     * Gets a node from the cache. If a node is returned, then the value of\n+     * {@link #cacheSize} is decreased accordingly. The node that is returned\n+     * will have <code>null</code> values for next, previous and element.\n+     * \n+     * @return A node, or <code>null</code> if there are no nodes in the cache.\n+     */\n+    private Node getNodeFromCache() {\n+        if (cacheSize == 0) {\n+            return null;\n+        }\n+        Node cachedNode = firstCachedNode;\n+        firstCachedNode = cachedNode.next;\n+        cachedNode.next = null; // This should be changed anyway, but defensively\n+                                             // set it to null.\n+        cacheSize--;\n+        return cachedNode;\n+    }\n+    \n+    private boolean cacheFull() {\n+        return cacheSize >= maximumCacheSize;\n+    }\n+    \n+    /**\n+     * Adds a node to the cache, if the cache isn't full. The node's contents\n+     * are cleared to so they can be garbage collected.\n+     */\n+    private void addNodeToCache(Node node) {\n+        if (cacheFull()) {\n+            // Don't cache the node.\n+            return;\n+        }\n+        // Clear the node's contents and add it to the cache.\n+        Node nextCachedNode = firstCachedNode;\n+        node.previous = null;\n+        node.next = nextCachedNode;\n+        node.element = null;\n+        firstCachedNode = node;\n+        cacheSize++;\n+    }\n+    \n+    // Node operations\n+\n+    /**\n+     * Create a node, getting it from the cache if possible.\n+     */\n+    protected Node createNode() {\n+        Node cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createNode();\n+        } else {\n+            return cachedNode;\n+        }\n+    }\n+    \n+    /**\n+     * Create a node, getting it from the cache if possible.\n+     */\n+    protected Node createNode(Node next, Node previous, Object element) {\n+        Node cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createNode(next, previous, element);\n+        } else {\n+            cachedNode.next = next;\n+            cachedNode.previous = previous;\n+            cachedNode.element = element;\n+            return cachedNode;\n+        }\n+    }\n+\n+    /**\n+     * Calls the superclass' implementation then calls\n+     * {@link #addNodeToCache(Node)} on the node which has been removed.\n+     * \n+     * @see org.apache.commons.collections.CommonsLinkedList#removeNode(Node)\n+     */\n+    protected void removeNode(Node node) {\n+        super.removeNode(node);\n+        addNodeToCache(node);\n+    }\n+    \n+    protected void removeAllNodes() {\n+        // Add the removed nodes to the cache, then remove the rest.\n+        // We can add them to the cache before removing them, since\n+        // {@link CommonsLinkedList.removeAllNodes()} removes the\n+        // nodes by removing references directly from {@link #marker}.\n+        int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n+        Node node = marker.next;\n+        for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n+            Node oldNode = node;\n+            node = node.next;\n+            addNodeToCache(oldNode);\n+        }\n+        super.removeAllNodes();        \n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.38 2003/01/07 13:24:52 rwaldhoff Exp $\n- * $Revision: 1.38 $\n- * $Date: 2003/01/07 13:24:52 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.39 2003/01/07 15:18:14 rwaldhoff Exp $\n+ * $Revision: 1.39 $\n+ * $Date: 2003/01/07 15:18:14 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.38 2003/01/07 13:24:52 rwaldhoff Exp $\n+ * @version $Id: TestAll.java,v 1.39 2003/01/07 15:18:14 rwaldhoff Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestBoundedFifoBuffer.suite());\n         suite.addTest(TestBoundedFifoBuffer2.suite());\n         suite.addTest(TestCollectionUtils.suite());\n+        suite.addTest(TestCommonsLinkedList.suite());\n         suite.addTest(TestBufferUtils.suite());\n         suite.addTest(TestSetUtils.suite());\n         suite.addTest(TestListUtils.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestCommonsLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestCommonsLinkedList.java,v 1.1 2003/01/07 15:18:14 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/01/07 15:18:14 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.*;\n+\n+import junit.framework.Test;\n+\n+/**\n+ * Test case for {@link CommonsLinkedList}.\n+ * \n+ * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n+ */\n+public class TestCommonsLinkedList extends TestLinkedList {\n+\n+    public TestCommonsLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public LinkedList makeEmptyLinkedList() {\n+        return new CommonsLinkedList();\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestCommonsLinkedList.class);\n+    }\n+    \n+    public String getCompatibilityVersion() {\n+        return \"2.2\";\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLinkedList.java,v 1.1 2003/01/07 15:18:14 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2003/01/07 15:18:14 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * Tests base {@link java.util.LinkedList} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeLinkedList} method.\n+ * <p>\n+ * If your {@link LinkedList} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link List} fails.\n+ *\n+ * @author <a href=\"mailto:rich@rd.gen.nz\">Rich Dougherty</a>\n+ * @version $Id: TestLinkedList.java,v 1.1 2003/01/07 15:18:14 rwaldhoff Exp $\n+ */\n+public abstract class TestLinkedList extends TestList {\n+\n+    public TestLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    protected List makeEmptyList() {\n+        return makeEmptyLinkedList();\n+    }\n+\n+    protected List makeFullList() {\n+        return makeFullLinkedList();\n+    }\n+\n+    /**\n+     *  Return a new, empty {@link LinkedList} to be used for testing.\n+     *\n+     *  @return an empty list for testing.\n+     */\n+    protected abstract LinkedList makeEmptyLinkedList();\n+\n+    /**\n+     *  Return a new, full {@link List} to be used for testing.\n+     *\n+     *  @return a full list for testing\n+     */\n+    protected LinkedList makeFullLinkedList() {\n+        // only works if list supports optional \"addAll(Collection)\" \n+        LinkedList list = makeEmptyLinkedList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     *  Returns the {@link #collection} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the collection field as a List\n+     */\n+    protected LinkedList getLinkedList() {\n+        return (LinkedList)collection;\n+    }\n+\n+    /**\n+     *  Returns the {@link #confirmed} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the confirmed field as a List\n+     */\n+    protected LinkedList getConfirmedLinkedList() {\n+        return (LinkedList)confirmed;\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addFirst(Object)}.\n+     */\n+    public void testLinkedListAddFirst() {\n+        if (!isAddSupported()) return;\n+        Object o = \"hello\";\n+\n+        resetEmpty();\n+        getLinkedList().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+\n+        resetFull();\n+        getLinkedList().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addLast(Object)}.\n+     */\n+    public void testLinkedListAddLast() {\n+        if (!isAddSupported()) return;\n+        Object o = \"hello\";\n+\n+        resetEmpty();\n+        getLinkedList().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+\n+        resetFull();\n+        getLinkedList().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getFirst(Object)}.\n+     */\n+    public void testLinkedListGetFirst() {\n+        resetEmpty();\n+        try {\n+            getLinkedList().getFirst();\n+            fail(\"getFirst() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        Object first = getLinkedList().getFirst();\n+        Object confirmedFirst = getConfirmedLinkedList().getFirst();\n+        assertEquals(\"Result returned by getFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getLast(Object)}.\n+     */\n+    public void testLinkedListGetLast() {\n+        resetEmpty();\n+        try {\n+            getLinkedList().getLast();\n+            fail(\"getLast() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        Object last = getLinkedList().getLast();\n+        Object confirmedLast = getConfirmedLinkedList().getLast();\n+        assertEquals(\"Result returned by getLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeFirst(Object)}.\n+     */\n+    public void testLinkedListRemoveFirst() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getLinkedList().removeFirst();\n+            fail(\"removeFirst() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        Object first = getLinkedList().removeFirst();\n+        Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n+        assertEquals(\"Result returned by removeFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeLast(Object)}.\n+     */\n+    public void testLinkedListRemoveLast() {\n+        if (!isRemoveSupported()) return;\n+\n+        resetEmpty();\n+        try {\n+            getLinkedList().removeLast();\n+            fail(\"removeLast() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        Object last = getLinkedList().removeLast();\n+        Object confirmedLast = getConfirmedLinkedList().removeLast();\n+        assertEquals(\"Result returned by removeLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Returns an empty {@link ArrayList}.\n+     */\n+    protected Collection makeConfirmedCollection() {\n+        return new LinkedList();\n+    }\n+\n+    /**\n+     *  Returns a full {@link ArrayList}.\n+     */\n+    protected Collection makeConfirmedFullCollection() {\n+        List list = new LinkedList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+}\n--- a/src/test/org/apache/commons/collections/TestMultiHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestMultiHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.9 2002/11/24 20:24:49 scolebourne Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/11/24 20:24:49 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.10 2003/01/07 15:18:14 rwaldhoff Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2003/01/07 15:18:14 $\n  *\n  * ====================================================================\n  *\n     }\n \n     // MutltiHashMap was introduced in Collections 2.x\n-    public int getCompatibilityVersion() {\n-        return 2;\n+    public String getCompatibilityVersion() {\n+        return \"2\";\n     }\n \n     public Map makeEmptyMap() {\n--- a/src/test/org/apache/commons/collections/TestNodeCachingLinkedList.java\n+++ b/src/test/org/apache/commons/collections/TestNodeCachingLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestNodeCachingLinkedList.java,v 1.1 2002/11/18 23:58:46 scolebourne Exp $\n- * $Revision: 1.1 $\n- * $Date: 2002/11/18 23:58:46 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestNodeCachingLinkedList.java,v 1.2 2003/01/07 15:18:15 rwaldhoff Exp $\n+ * $Revision: 1.2 $\n+ * $Date: 2003/01/07 15:18:15 $\n  *\n  * ====================================================================\n  *\n  * \n  * @author Jeff Varszegi\n  */\n-public class TestNodeCachingLinkedList extends TestList {\n+public class TestNodeCachingLinkedList extends TestLinkedList {\n     protected NodeCachingLinkedList list = null;\n \n     public TestNodeCachingLinkedList(String _testName) {\n         super(_testName);\n     }\n \n-    public List makeEmptyList() {\n+    public LinkedList makeEmptyLinkedList() {\n         return new NodeCachingLinkedList();\n     }\n \n \n     public static Test suite() {\n         return BulkTest.makeSuite(TestNodeCachingLinkedList.class);\n+    }\n+    \n+    public String getCompatibilityVersion() {\n+        return \"2.2\";\n     }\n     \n     public static void compareSpeed() {\n     \n \n     public static void main(String args[]) {\n+        compareSpeed();\n         String[] testCaseName = { TestNodeCachingLinkedList.class.getName()};\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-}\n+}\n--- a/src/test/org/apache/commons/collections/TestObject.java\n+++ b/src/test/org/apache/commons/collections/TestObject.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestObject.java,v 1.15 2003/01/04 13:43:10 rwaldhoff Exp $\n- * $Revision: 1.15 $\n- * $Date: 2003/01/04 13:43:10 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestObject.java,v 1.16 2003/01/07 15:18:15 rwaldhoff Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2003/01/07 15:18:15 $\n  *\n  * ====================================================================\n  *\n  * test case (method) your {@link Object} fails.\n  *\n  * @author Rodney Waldhoff\n- * @version $Id: TestObject.java,v 1.15 2003/01/04 13:43:10 rwaldhoff Exp $\n+ * @version $Id: TestObject.java,v 1.16 2003/01/07 15:18:15 rwaldhoff Exp $\n  */\n public abstract class TestObject extends BulkTest {\n     public TestObject(String testName) {\n     public static final int COLLECTIONS_MAJOR_VERSION = 2;\n \n     /**\n+     * Get the version of Collections that this object tries to\n+     * maintain serialization compatibility with. Defaults to 1, the\n+     * earliest Collections version. (Note: some collections did not\n+     * even exist in this version).\n+     * \n      * This constant makes it possible for TestMap (and other subclasses,\n      * if necessary) to automatically check CVS for a versionX copy of a\n      * Serialized object, so we can make sure that compatibility is maintained.\n      * See, for example, TestMap.getCanonicalFullMapName(Map map).\n      * Subclasses can override this variable, indicating compatibility\n      * with earlier Collections versions.\n-     * Defaults to 1, the earliest Collections version.  (Note: some\n-     * collections did not even exist in this version).\n-     * \n-     * @return 1\n-     */\n-    public int getCompatibilityVersion() {\n-        return 1;\n+     * \n+     * @return The version, or <code>null</code> if this object shouldn't be\n+     * tested for compatibility with previous versions.\n+     */\n+    public String getCompatibilityVersion() {\n+        return \"1\";\n     }\n \n     /**\n--- a/src/test/org/apache/commons/collections/TestReferenceMap.java\n+++ b/src/test/org/apache/commons/collections/TestReferenceMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestReferenceMap.java,v 1.3 2002/11/07 21:43:36 bayard Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/11/07 21:43:36 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestReferenceMap.java,v 1.4 2003/01/07 15:18:15 rwaldhoff Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2003/01/07 15:18:15 $\n  *\n  * ====================================================================\n  *\n  * Tests for ReferenceMap. \n  *\n  * @author Paul Jack\n- * @version $Id: TestReferenceMap.java,v 1.3 2002/11/07 21:43:36 bayard Exp $\n+ * @version $Id: TestReferenceMap.java,v 1.4 2003/01/07 15:18:15 rwaldhoff Exp $\n  */\n public class TestReferenceMap extends TestMap {\n \n */\n \n \n-    public int getCompatibilityVersion() {\n-        return 2; // actually 2.1, but can't represent that as an int\n+    public String getCompatibilityVersion() {\n+        return \"2.1\";\n     }\n \n \n--- a/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n \n     // current versions of SequencedHashMap and subclasses are not\n     // compatible with Collections 1.x\n-    public int getCompatibilityVersion() {\n-        return 2;\n+    public String getCompatibilityVersion() {\n+        return \"2\";\n     }\n \n     public static void main(String[] args) {\n--- a/src/test/org/apache/commons/collections/comparators/TestComparator.java\n+++ b/src/test/org/apache/commons/collections/comparators/TestComparator.java\n      * \n      * @return 2\n      */\n-    public int getCompatibilityVersion() {\n-        return 2;\n+    public String getCompatibilityVersion() {\n+        return \"2\";\n     }\n \n     public void reverseObjects(List list) {", "timestamp": 1041952695, "metainfo": ""}