{"sha": "74d94493870f192cce2ef7b8b7c1ad00b1ef43fd", "log": "Renamed ignoredSimpleTests to ignoredTests in AbstractTestMap Additional tests   ", "commit": "\n--- a/src/test/org/apache/commons/collections/AbstractTestMap.java\n+++ b/src/test/org/apache/commons/collections/AbstractTestMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestMap.java,v 1.2 2003/10/05 12:34:46 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestMap.java,v 1.3 2003/10/05 20:47:37 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  * @author Stephen Colebourne\n- * @version $Revision: 1.2 $ $Date: 2003/10/05 12:34:46 $\n+ * @version $Revision: 1.3 $ $Date: 2003/10/05 20:47:37 $\n  */\n public abstract class AbstractTestMap extends AbstractTestObject {\n \n      */\n     protected Object[] getNewSampleValues() {\n         Object[] result = new Object[] {\n-            (useNullValue()) ? null : \"newnonnullvalue\",\n+            (useNullValue() && useDuplicateValues()) ? null : \"newnonnullvalue\",\n             \"newvalue\",\n             (useDuplicateValues()) ? \"newvalue\" : \"newvalue2\",\n             \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\", \n         verify();\n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testValuesClearChangesMap() {\n+        if (!isAddRemoveModifiable()) return;\n+        \n+        // clear values, reflected in map\n+        resetFull();\n+        Collection values = map.values();\n+        assertTrue(map.size() > 0);\n+        assertTrue(values.size() > 0);\n+        values.clear();\n+        assertTrue(map.size() == 0);\n+        assertTrue(values.size() == 0);\n+        \n+        // clear map, reflected in values\n+        resetFull();\n+        values = map.values();\n+        assertTrue(map.size() > 0);\n+        assertTrue(values.size() > 0);\n+        map.clear();\n+        assertTrue(map.size() == 0);\n+        assertTrue(values.size() == 0);\n+    }\n+    \n+    /**\n+     * Tests that the {@link Map#keySet} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testKeySetClearChangesMap() {\n+        if (!isAddRemoveModifiable()) return;\n+        \n+        // clear values, reflected in map\n+        resetFull();\n+        Set keySet = map.keySet();\n+        assertTrue(map.size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        keySet.clear();\n+        assertTrue(map.size() == 0);\n+        assertTrue(keySet.size() == 0);\n+        \n+        // clear map, reflected in values\n+        resetFull();\n+        keySet = map.keySet();\n+        assertTrue(map.size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        map.clear();\n+        assertTrue(map.size() == 0);\n+        assertTrue(keySet.size() == 0);\n+    }\n+    \n+    /**\n+     * Tests that the {@link Map#entrySet()} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testEntrySetClearChangesMap() {\n+        if (!isAddRemoveModifiable()) return;\n+        \n+        // clear values, reflected in map\n+        resetFull();\n+        Set entrySet = map.entrySet();\n+        assertTrue(map.size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        entrySet.clear();\n+        assertTrue(map.size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+        \n+        // clear map, reflected in values\n+        resetFull();\n+        entrySet = map.entrySet();\n+        assertTrue(map.size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        map.clear();\n+        assertTrue(map.size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n     /**\n      * Tests that the {@link Map#values} collection is backed by\n      * the underlying map by removing from the values collection\n      * and testing if the value was removed from the map.\n-     * <p/>\n+     * <p>\n      * We should really test the \"vice versa\" case--that values removed\n      * from the map are removed from the values collection--also,\n      * but that's a more difficult test to construct (lacking a\n      * \n      * @see http://issues.apache.org/bugzilla/show_bug.cgi?id=9573\n      */\n-    public void testValuesRemovedFromValuesCollectionAreRemovedFromMap() {\n+    public void testValuesRemoveChangesMap() {\n         resetFull();\n         Object[] sampleValues = getSampleValues();\n         Collection values = map.values();\n-        for(int i=0;i<sampleValues.length;i++) {\n-            if(map.containsValue(sampleValues[i])) {\n-                while(values.contains(sampleValues[i])) {\n+        for (int i = 0; i < sampleValues.length; i++) {\n+            if (map.containsValue(sampleValues[i])) {\n+                while (values.contains(sampleValues[i])) {\n                     try {\n                         values.remove(sampleValues[i]);\n-                    } catch(UnsupportedOperationException e) {\n+                    } catch (UnsupportedOperationException e) {\n                         // if values.remove is unsupported, just skip this test\n                         return;\n                     }\n                 }\n-                assertTrue(\"Value should have been removed from the underlying map.\",!map.containsValue(sampleValues[i]));\n+                assertTrue(\n+                    \"Value should have been removed from the underlying map.\",\n+                    !map.containsValue(sampleValues[i]));\n             }\n         }\n     }\n      * the underlying map by removing from the keySet set\n      * and testing if the key was removed from the map.\n      */\n-    public void testValuesRemovedFromKeySetAreRemovedFromMap() {\n+    public void testKeySetRemoveChangesMap() {\n         resetFull();\n         Object[] sampleKeys = getSampleKeys();\n         Set keys = map.keySet();\n-        for(int i=0;i<sampleKeys.length;i++) {\n+        for (int i = 0; i < sampleKeys.length; i++) {\n             try {\n                 keys.remove(sampleKeys[i]);\n-            } catch(UnsupportedOperationException e) {\n+            } catch (UnsupportedOperationException e) {\n                 // if key.remove is unsupported, just skip this test\n                 return;\n             }\n-            assertTrue(\"Key should have been removed from the underlying map.\",!map.containsKey(sampleKeys[i]));\n+            assertTrue(\n+                \"Key should have been removed from the underlying map.\",\n+                !map.containsKey(sampleKeys[i]));\n         }\n     }\n \n     // TODO: Need:\n     //    testValuesRemovedFromEntrySetAreRemovedFromMap\n     //    same for EntrySet/KeySet/values's\n-    //      Iterator.remove, removeAll, retainAll, clear\n-    // TODO: Also need:\n-    //    Test that EntrySet/KeySet/values all do not allow add/addAll\n+    //      Iterator.remove, removeAll, retainAll\n \n \n     /**", "timestamp": 1065386857, "metainfo": ""}