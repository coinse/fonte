{"sha": "256420016e2321dfd266f9a2ebf672516cc936ac", "log": "adding CollectionUtils and tests for it   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.1 2001/04/24 18:48:36 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/24 18:48:36 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * A set of {@link Collection} related utility methods.\n+ *\n+ * @author Rodney Waldhoff\n+ *\n+ * @version $Id: CollectionUtils.java,v 1.1 2001/04/24 18:48:36 rwaldhoff Exp $\n+ */\n+public class CollectionUtils {\n+    /**\n+     * Returns a {@link Collection} containing the union\n+     * of the given {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection}\n+     * will be equal to the maximum of the cardinality of that element\n+     * in the two given {@link Collection}s.\n+     *\n+     * @see Collection#addAll\n+     */\n+    public static Collection union(final Collection a, final Collection b) {\n+        ArrayList list = new ArrayList();\n+        Map mapa = getCardinalityMap(a);\n+        Map mapb = getCardinalityMap(b);\n+        Set elts = new HashSet(a);\n+        elts.addAll(b);\n+        Iterator it = elts.iterator();\n+        while(it.hasNext()) {\n+            Object obj = it.next();\n+            for(int i=0,m=Math.max(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the intersection\n+     * of the given {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection}\n+     * will be equal to the minimum of the cardinality of that element\n+     * in the two given {@link Collection}s.\n+     *\n+     * @see Collection#retainAll\n+     */\n+    public static Collection intersection(final Collection a, final Collection b) {\n+        ArrayList list = new ArrayList();\n+        Map mapa = getCardinalityMap(a);\n+        Map mapb = getCardinalityMap(b);\n+        Set elts = new HashSet(a);\n+        elts.addAll(b);\n+        Iterator it = elts.iterator();\n+        while(it.hasNext()) {\n+            Object obj = it.next();\n+            for(int i=0,m=Math.min(getFreq(obj,mapa),getFreq(obj,mapb));i<m;i++) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the exclusive disjunction\n+     * (symmetric difference) of the given {@link Collection}.\n+     * <p>\n+     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n+     * will be equal to\n+     * <tt>Math.max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - Math.min(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>))</tt>.\n+     * <p>\n+     * This is equivalent to\n+     * <tt>{@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})</tt>\n+     * or\n+     * <tt>{@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})</tt>.\n+     */\n+    public static Collection disjunction(final Collection a, final Collection b) {\n+        ArrayList list = new ArrayList();\n+        Map mapa = getCardinalityMap(a);\n+        Map mapb = getCardinalityMap(b);\n+        Set elts = new HashSet(a);\n+        elts.addAll(b);\n+        Iterator it = elts.iterator();\n+        while(it.hasNext()) {\n+            Object obj = it.next();\n+            for(int i=0,m=((Math.max(getFreq(obj,mapa),getFreq(obj,mapb)))-(Math.min(getFreq(obj,mapa),getFreq(obj,mapb))));i<m;i++) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n+     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n+     * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n+     * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n+     *\n+     * @see Collection#removeAll\n+     */\n+    public static Collection subtract(final Collection a, final Collection b) {\n+        ArrayList list = new ArrayList( a );\n+        Iterator it =  b.iterator();\n+        while(it.hasNext()) {\n+            list.remove(it.next());\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns a {@link Map} mapping each unique element in\n+     * the given {@link Collection} to an {@link Integer}\n+     * representing the number of occurances of that element\n+     * in the {@link Collection}.\n+     * An entry that maps to <tt>null</tt> indicates that the\n+     * element does not appear in the given {@link Collection}.\n+     */\n+    public static Map getCardinalityMap(final Collection col) {\n+        HashMap count = new HashMap();\n+        Iterator it = col.iterator();\n+        while(it.hasNext()) {\n+            Object obj = it.next();\n+            Integer c = (Integer)(count.get(obj));\n+            if(null == c) {\n+                count.put(obj,new Integer(1));\n+            } else {\n+                count.put(obj,new Integer(c.intValue() + 1));\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff <i>a</i> is a sub-collection of <i>b</i>,\n+     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n+     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i>.\n+     *\n+     * @see #isProperSubCollection\n+     * @see Collection#containsAll\n+     */\n+    public static boolean isSubCollection(final Collection a, final Collection b) {\n+        ArrayList list = new ArrayList();\n+        Map mapa = getCardinalityMap(a);\n+        Map mapb = getCardinalityMap(b);\n+        Iterator it = a.iterator();\n+        while(it.hasNext()) {\n+            Object obj = it.next();\n+            if(getFreq(obj,mapa) > getFreq(obj,mapb)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n+     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n+     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i>, and there is at least one\n+     * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n+     * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n+     *\n+     * @see #isSubCollection\n+     * @see Collection#containsAll\n+     */\n+    public static boolean isProperSubCollection(final Collection a, final Collection b) {\n+        // XXX optimize me!\n+        return CollectionUtils.isSubCollection(a,b) && (!(CollectionUtils.isEqualCollection(a,b)));\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n+     * exactly the same elements with exactly the same cardinality.\n+     * <p>\n+     * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n+     * equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n+     */\n+    public static boolean isEqualCollection(final Collection a, final Collection b) {\n+        if(a.size() != b.size()) {\n+            return false;\n+        } else {\n+            Map mapa = getCardinalityMap(a);\n+            Map mapb = getCardinalityMap(b);\n+            if(mapa.size() != mapb.size()) {\n+                return false;\n+            } else {\n+                Iterator it = mapa.keySet().iterator();\n+                while(it.hasNext()) {\n+                    Object obj = it.next();\n+                    if(getFreq(obj,mapa) != getFreq(obj,mapb)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the number of occurrences of <i>obj</i>\n+     * in <i>col</i>.\n+     */\n+    public static int cardinality(Object obj, final Collection col) {\n+        int count = 0;\n+        Iterator it = col.iterator();\n+        while(it.hasNext()) {\n+            Object elt = it.next();\n+            if((null == obj && null == elt) || obj.equals(elt)) {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    private static final int getFreq(final Object obj, final Map freqMap) {\n+        try {\n+            return ((Integer)(freqMap.get(obj))).intValue();\n+        } catch(NullPointerException e) {\n+            // ignored\n+        } catch(NoSuchElementException e) {\n+            // ignored\n+        }\n+        return 0;\n+    }\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.5 2001/04/21 12:22:30 craigmcc Exp $\n- * $Revision: 1.5 $\n- * $Date: 2001/04/21 12:22:30 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.6 2001/04/24 18:48:38 rwaldhoff Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2001/04/24 18:48:38 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.5 2001/04/21 12:22:30 craigmcc Exp $\n+ * @version $Id: TestAll.java,v 1.6 2001/04/24 18:48:38 rwaldhoff Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestFastTreeMap1.suite());\n         suite.addTest(TestHashMap.suite());\n         suite.addTest(TestTreeMap.suite());\n+        suite.addTest(TestCollectionUtils.suite());\n         return suite;\n     }\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestCollectionUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestCollectionUtils.java,v 1.1 2001/04/24 18:48:38 rwaldhoff Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2001/04/24 18:48:38 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections;\n+\n+import junit.framework.*;\n+import java.util.*;\n+\n+/**\n+ * @author Rodney Waldhoff\n+ * @version $Id: TestCollectionUtils.java,v 1.1 2001/04/24 18:48:38 rwaldhoff Exp $\n+ */\n+public class TestCollectionUtils extends TestCase {\n+    public TestCollectionUtils(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestCollectionUtils.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestCollectionUtils.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    private Collection _a = null;\n+    private Collection _b = null;\n+\n+    public void setUp() {\n+        _a = new ArrayList();\n+        _a.add(\"a\");\n+        _a.add(\"b\");\n+        _a.add(\"b\");\n+        _a.add(\"c\");\n+        _a.add(\"c\");\n+        _a.add(\"c\");\n+        _a.add(\"d\");\n+        _a.add(\"d\");\n+        _a.add(\"d\");\n+        _a.add(\"d\");\n+        _b = new LinkedList();\n+        _b.add(\"e\");\n+        _b.add(\"d\");\n+        _b.add(\"d\");\n+        _b.add(\"c\");\n+        _b.add(\"c\");\n+        _b.add(\"c\");\n+        _b.add(\"b\");\n+        _b.add(\"b\");\n+        _b.add(\"b\");\n+        _b.add(\"b\");\n+\n+    }\n+\n+    public void testGetCardinalityMap() {\n+        Map freq = CollectionUtils.getCardinalityMap(_a);\n+        assertEquals(new Integer(1),freq.get(\"a\"));\n+        assertEquals(new Integer(2),freq.get(\"b\"));\n+        assertEquals(new Integer(3),freq.get(\"c\"));\n+        assertEquals(new Integer(4),freq.get(\"d\"));\n+        assert(null == freq.get(\"e\"));\n+\n+        freq = CollectionUtils.getCardinalityMap(_b);\n+        assert(null == freq.get(\"a\"));\n+        assertEquals(new Integer(4),freq.get(\"b\"));\n+        assertEquals(new Integer(3),freq.get(\"c\"));\n+        assertEquals(new Integer(2),freq.get(\"d\"));\n+        assertEquals(new Integer(1),freq.get(\"e\"));\n+    }\n+\n+    public void testCardinality() {\n+        assertEquals(1,CollectionUtils.cardinality(\"a\",_a));\n+        assertEquals(2,CollectionUtils.cardinality(\"b\",_a));\n+        assertEquals(3,CollectionUtils.cardinality(\"c\",_a));\n+        assertEquals(4,CollectionUtils.cardinality(\"d\",_a));\n+        assertEquals(0,CollectionUtils.cardinality(\"e\",_a));\n+\n+        assertEquals(0,CollectionUtils.cardinality(\"a\",_b));\n+        assertEquals(4,CollectionUtils.cardinality(\"b\",_b));\n+        assertEquals(3,CollectionUtils.cardinality(\"c\",_b));\n+        assertEquals(2,CollectionUtils.cardinality(\"d\",_b));\n+        assertEquals(1,CollectionUtils.cardinality(\"e\",_b));\n+    }\n+\n+    public void testUnion() {\n+        Collection col = CollectionUtils.union(_a,_b);\n+        Map freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(new Integer(1),freq.get(\"a\"));\n+        assertEquals(new Integer(4),freq.get(\"b\"));\n+        assertEquals(new Integer(3),freq.get(\"c\"));\n+        assertEquals(new Integer(4),freq.get(\"d\"));\n+        assertEquals(new Integer(1),freq.get(\"e\"));\n+\n+        Collection col2 = CollectionUtils.union(_b,_a);\n+        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(new Integer(1),freq2.get(\"a\"));\n+        assertEquals(new Integer(4),freq2.get(\"b\"));\n+        assertEquals(new Integer(3),freq2.get(\"c\"));\n+        assertEquals(new Integer(4),freq2.get(\"d\"));\n+        assertEquals(new Integer(1),freq2.get(\"e\"));\n+    }\n+\n+    public void testIntersection() {\n+        Collection col = CollectionUtils.intersection(_a,_b);\n+        Map freq = CollectionUtils.getCardinalityMap(col);\n+        assert(null == freq.get(\"a\"));\n+        assertEquals(new Integer(2),freq.get(\"b\"));\n+        assertEquals(new Integer(3),freq.get(\"c\"));\n+        assertEquals(new Integer(2),freq.get(\"d\"));\n+        assert(null == freq.get(\"e\"));\n+\n+        Collection col2 = CollectionUtils.intersection(_b,_a);\n+        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assert(null == freq2.get(\"a\"));\n+        assertEquals(new Integer(2),freq2.get(\"b\"));\n+        assertEquals(new Integer(3),freq2.get(\"c\"));\n+        assertEquals(new Integer(2),freq2.get(\"d\"));\n+        assert(null == freq2.get(\"e\"));\n+    }\n+\n+    public void testDisjunction() {\n+        Collection col = CollectionUtils.disjunction(_a,_b);\n+        Map freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(new Integer(1),freq.get(\"a\"));\n+        assertEquals(new Integer(2),freq.get(\"b\"));\n+        assert(null == freq.get(\"c\"));\n+        assertEquals(new Integer(2),freq.get(\"d\"));\n+        assertEquals(new Integer(1),freq.get(\"e\"));\n+\n+        Collection col2 = CollectionUtils.disjunction(_b,_a);\n+        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(new Integer(1),freq2.get(\"a\"));\n+        assertEquals(new Integer(2),freq2.get(\"b\"));\n+        assert(null == freq2.get(\"c\"));\n+        assertEquals(new Integer(2),freq2.get(\"d\"));\n+        assertEquals(new Integer(1),freq2.get(\"e\"));\n+    }\n+\n+    public void testDisjunctionAsUnionMinusIntersection() {\n+        Collection dis = CollectionUtils.disjunction(_a,_b);\n+        Collection un = CollectionUtils.union(_a,_b);\n+        Collection inter = CollectionUtils.intersection(_a,_b);\n+        assert(CollectionUtils.isEqualCollection(dis,CollectionUtils.subtract(un,inter)));\n+    }\n+\n+    public void testDisjunctionAsSymmetricDifference() {\n+        Collection dis = CollectionUtils.disjunction(_a,_b);\n+        Collection amb = CollectionUtils.subtract(_a,_b);\n+        Collection bma = CollectionUtils.subtract(_b,_a);\n+        assert(CollectionUtils.isEqualCollection(dis,CollectionUtils.union(amb,bma)));\n+    }\n+\n+    public void testSubtract() {\n+        Collection col = CollectionUtils.subtract(_a,_b);\n+        Map freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(new Integer(1),freq.get(\"a\"));\n+        assert(null == freq.get(\"b\"));\n+        assert(null == freq.get(\"c\"));\n+        assertEquals(new Integer(2),freq.get(\"d\"));\n+        assert(null == freq.get(\"e\"));\n+\n+        Collection col2 = CollectionUtils.subtract(_b,_a);\n+        Map freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(new Integer(1),freq2.get(\"e\"));\n+        assert(null == freq2.get(\"d\"));\n+        assert(null == freq2.get(\"c\"));\n+        assertEquals(new Integer(2),freq2.get(\"b\"));\n+        assert(null == freq2.get(\"a\"));\n+    }\n+\n+    public void testIsSubCollectionOfSelf() {\n+        assert(CollectionUtils.isSubCollection(_a,_a));\n+        assert(CollectionUtils.isSubCollection(_b,_b));\n+    }\n+\n+    public void testIsSubCollection() {\n+        assert(!CollectionUtils.isSubCollection(_a,_b));\n+        assert(!CollectionUtils.isSubCollection(_b,_a));\n+    }\n+\n+    public void testIsSubCollection2() {\n+        Collection c = new ArrayList();\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"a\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"b\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"b\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"c\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"c\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"c\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"d\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"d\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"d\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(!CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"d\");\n+        assert(CollectionUtils.isSubCollection(c,_a));\n+        assert(CollectionUtils.isSubCollection(_a,c));\n+        c.add(\"e\");\n+        assert(!CollectionUtils.isSubCollection(c,_a));\n+        assert(CollectionUtils.isSubCollection(_a,c));\n+    }\n+\n+    public void testIsEqualCollectionToSelf() {\n+        assert(CollectionUtils.isEqualCollection(_a,_a));\n+        assert(CollectionUtils.isEqualCollection(_b,_b));\n+    }\n+\n+    public void testIsEqualCollection() {\n+        assert(!CollectionUtils.isEqualCollection(_a,_b));\n+        assert(!CollectionUtils.isEqualCollection(_b,_a));\n+    }\n+\n+    public void testIsEqualCollection2() {\n+        Collection a = new ArrayList();\n+        Collection b = new ArrayList();\n+        assert(CollectionUtils.isEqualCollection(a,b));\n+        assert(CollectionUtils.isEqualCollection(b,a));\n+        a.add(\"1\");\n+        assert(!CollectionUtils.isEqualCollection(a,b));\n+        assert(!CollectionUtils.isEqualCollection(b,a));\n+        b.add(\"1\");\n+        assert(CollectionUtils.isEqualCollection(a,b));\n+        assert(CollectionUtils.isEqualCollection(b,a));\n+        a.add(\"2\");\n+        assert(!CollectionUtils.isEqualCollection(a,b));\n+        assert(!CollectionUtils.isEqualCollection(b,a));\n+        b.add(\"2\");\n+        assert(CollectionUtils.isEqualCollection(a,b));\n+        assert(CollectionUtils.isEqualCollection(b,a));\n+        a.add(\"1\");\n+        assert(!CollectionUtils.isEqualCollection(a,b));\n+        assert(!CollectionUtils.isEqualCollection(b,a));\n+        b.add(\"1\");\n+        assert(CollectionUtils.isEqualCollection(a,b));\n+        assert(CollectionUtils.isEqualCollection(b,a));\n+    }\n+}", "timestamp": 988138118, "metainfo": ""}