{"sha": "2e2ac4ba937e08effb258a3ff61fa3c1abac2f5d", "log": "Fix formatting   ", "commit": "\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n  * Provides utility methods and decorators for {@link Collection} instances.\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.63 $ $Date: 2004/12/11 06:30:38 $\n+ * @version $Revision: 1.64 $ $Date: 2004/12/19 16:56:30 $\n  * \n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  */\n public class CollectionUtils {\n \n-\t/** Constant to avoid repeated object creation */\n+    /** Constant to avoid repeated object creation */\n     private static Integer INTEGER_ONE = new Integer(1);\n \n     /**\n         return UnmodifiableCollection.decorate(collection);\n     }\n \n-\t/**\n-\t * Returns an unmodifiable copy of the collection.\n-\t * <p>\n+    /**\n+     * Returns an unmodifiable copy of the collection.\n+     * <p>\n      * This method uses the implementation in the decorators subpackage.\n      * \n-\t * @param collection the <code>Collection</code> to copy.\n-\t * @return an unmodifiable <code>Collection</code>.\n-\t * @throws IllegalArgumentException if collection is null\n-\t */\n-\tpublic static Collection unmodifiableCollectionCopy(final Collection collection){\n-\t\tif (collection == null) throw new IllegalArgumentException(\"null not permitted.\");\n-\t\t\n-\t\tfinal Collection copy = new ArrayList(collection.size());\n-\t\tcopy.addAll(collection);\n-\t\treturn UnmodifiableCollection.decorate(copy);\n-\t}\n+     * @param collection the <code>Collection</code> to copy.\n+     * @return an unmodifiable <code>Collection</code>.\n+     * @throws IllegalArgumentException if collection is null\n+     */\n+    public static Collection unmodifiableCollectionCopy(final Collection collection){\n+        if (collection == null) throw new IllegalArgumentException(\"null not permitted.\");\n+        \n+        final Collection copy = new ArrayList(collection.size());\n+        copy.addAll(collection);\n+        return UnmodifiableCollection.decorate(copy);\n+    }\n+\n     /**\n      * Returns a predicated (validating) collection backed by the given collection.\n      * <p>\n         return TransformedCollection.decorate(collection, transformer);\n     }\n    \n-\t/**\n-\t * Returns a collection containing all the elements in <code>collection</code>\n-\t * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n-\t * in the returned collection is the same as the cardinality of <code>e</code>\n-\t * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n-\t * case the cardinality is zero. This method is useful if you do not wish to modify\n-\t * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n-\t * \n-\t * @param collection the collection whose contents are the target of the #retailAll operation\n-\t * @param retain the collection containing the elements to be retained in the returned collection\n-\t * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n-\t * that occur at least once in <code>retain</code>.\n-\t * @throws NullPointerException if either parameter is null\n-\t */\n-\tpublic static Collection retainAll(final Collection collection, final Collection retain) {\n-\t\treturn ListUtils.retainAll(collection, retain);\n-\t}\n-\n-\t/**\n-\t * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n-\t * method returns a collection containing all the elements in <code>c</code>\n-\t * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n-\t * in the returned collection is the same as the cardinality of <code>e</code>\n-\t * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n-\t * case the cardinality is zero. This method is useful if you do not wish to modify\n-\t * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n-\t * \n-\t * @param collection the collection from which items are removed (in the returned collection)\n-\t * @param remove the items to be removed from the returned <code>collection</code>\n-\t * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n-\t * any elements that also occur in <code>remove</code>.\n-\t * @throws NullPointerException if either parameter is null\n-\t */\n-\tpublic static Collection removeAll(final Collection collection, final Collection remove) {\n-\t\treturn ListUtils.retainAll(collection, remove);\n-\t}\n-\t\n+    /**\n+     * Returns a collection containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n+     * \n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static Collection retainAll(Collection collection, Collection retain) {\n+        return ListUtils.retainAll(collection, retain);\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a collection containing all the elements in <code>c</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     * \n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static Collection removeAll(Collection collection, Collection remove) {\n+        return ListUtils.retainAll(collection, remove);\n+    }\n \n }\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n  * Provides utility methods and decorators for {@link List} instances.\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.29 $ $Date: 2004/12/11 06:22:58 $\n+ * @version $Revision: 1.30 $ $Date: 2004/12/19 16:56:30 $\n  * \n  * @author Federico Barbieri\n  * @author Peter Donald\n     }\n \n     \n-\t/**\n-\t * Returns an unmodifiable list copy of the collection.\n-\t * <p>\n-\t * This method uses the unmodifiable list implementation in the decorators subpackage.\n-\t * @param collection the <code>Collection</code> to copy.\n-\t * @return an unmodifiable <code>List</code>.\n-\t * @throws IllegalArgumentException if collection is null.\n-\t */\n-\tpublic static List unmodifiableListCopy(final Collection collection) {\n-\t\tif (collection == null) throw new IllegalArgumentException(\"null not permitted.\");\n-\t\t\n-\t\tfinal List copy = new ArrayList(collection.size());\n-\t\tcopy.addAll(collection);\n-\t\treturn UnmodifiableList.decorate(copy);\n-\t}\n+    /**\n+     * Returns an unmodifiable list copy of the collection.\n+     * <p>\n+     * This method uses the unmodifiable list implementation in the decorators subpackage.\n+     * @param collection the <code>Collection</code> to copy.\n+     * @return an unmodifiable <code>List</code>.\n+     * @throws IllegalArgumentException if collection is null.\n+     */\n+    public static List unmodifiableListCopy(final Collection collection) {\n+        if (collection == null) throw new IllegalArgumentException(\"null not permitted.\");\n+        \n+        final List copy = new ArrayList(collection.size());\n+        copy.addAll(collection);\n+        return UnmodifiableList.decorate(copy);\n+    }\n     \n     /**\n      * Returns a predicated (validating) list backed by the given list.\n     }\n \n     /**\n-\t * Returns a List containing all the elements in <code>collection</code>\n-\t * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n-\t * in the returned list is the same as the cardinality of <code>e</code>\n-\t * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n-\t * case the cardinality is zero. This method is useful if you do not wish to modify\n-\t * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n-\t * \n-\t * @param collection the collection whose contents are the target of the #retailAll operation\n-\t * @param retain the collection containing the elements to be retained in the returned collection\n-\t * @return a <code>List</code> containing all the elements of <code>c</code>\n-\t * that occur at least once in <code>retain</code>.\n-\t * @throws NullPointerException if either parameter is null\n-\t */\n-\tpublic static List retainAll(final Collection collection, final Collection retain) {\n-\t\tfinal List list = new ArrayList(Math.min(collection.size(), retain.size()));\n-\n-\t\tObject item = null;\n-\t\tfor (final Iterator iter = collection.iterator(); iter.hasNext();)\n-\t\t{\n-\t\t\titem = iter.next();\n-\n-\t\t\tif (retain.contains(item))\n-\t\t\t{\n-\t\t\t\tlist.add(item);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn list;\n-\t}\n-\t\n-\t/**\n-\t * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n-\t * method returns a list containing all the elements in <code>c</code>\n-\t * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n-\t * in the returned collection is the same as the cardinality of <code>e</code>\n-\t * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n-\t * case the cardinality is zero. This method is useful if you do not wish to modify\n-\t * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n-\t * \n-\t * @param collection the collection from which items are removed (in the returned collection)\n-\t * @param remove the items to be removed from the returned <code>collection</code>\n-\t * @return a <code>List</code> containing all the elements of <code>c</code> except\n-\t * any elements that also occur in <code>remove</code>.\n-\t * @throws NullPointerException if either parameter is null\n-\t */\n-\tpublic static List removeAll(final Collection collection, final Collection remove) {\n-\t\tfinal List list = new ArrayList();\n-\n-\t\tObject o = null;\n-\t\tfor (final Iterator iter = collection.iterator(); iter.hasNext();)\n-\t\t{\n-\t\t\to = iter.next();\n-\t\t\tif (remove.contains(o) == false)\n-\t\t\t{\n-\t\t\t\tlist.add(o);\n-\t\t\t}\n-\t\t}\n-\n-\t\treturn list;\n-\t}\n-    \n+     * Returns a List containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned list is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n+     * \n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>List</code> containing all the elements of <code>c</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static List retainAll(Collection collection, Collection retain) {\n+        List list = new ArrayList(Math.min(collection.size(), retain.size()));\n+\n+        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n+            Object obj = iter.next();\n+            if (retain.contains(obj)) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a list containing all the elements in <code>c</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     * \n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>List</code> containing all the elements of <code>c</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static List removeAll(Collection collection, Collection remove) {\n+        List list = new ArrayList();\n+        for (Iterator iter = collection.iterator(); iter.hasNext();) {\n+            Object obj = iter.next();\n+            if (remove.contains(obj) == false) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n }\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n  *  </ul>\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.50 $ $Date: 2004/12/11 06:26:13 $\n+ * @version $Revision: 1.51 $ $Date: 2004/12/19 16:56:30 $\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n         return UnmodifiableMap.decorate(map);\n     }\n     \n-\t/**\n-\t * Returns an unmodifiable copy of the map.\n+    /**\n+     * Returns an unmodifiable copy of the map.\n      * @param map  the map to make an unmodifiable copy of, must not be null\n      * @return an unmodifiable map backed by the given map\n      * @throws IllegalArgumentException  if the map is null\n-\t */\n-\tpublic static Map unmodifiableMapCopy(final Map map) {\n-\t\tif (map == null) throw new IllegalArgumentException(\"null not permitted.\");\n-\t\t\n-\t\tfinal Map copy = new HashMap(map.size(), 1.0f);\n-\t\tcopy.putAll(map);\n-\t\treturn MapUtils.unmodifiableMap(copy);\n-\t}\n+     */\n+    public static Map unmodifiableMapCopy(Map map) {\n+        if (map == null) throw new IllegalArgumentException(\"null not permitted.\");\n+        \n+        Map copy = new HashMap(map.size(), 1.0f);\n+        copy.putAll(map);\n+        return MapUtils.unmodifiableMap(copy);\n+    }\n \n     /**\n      * Returns a predicated (validating) map backed by the given map.\n--- a/src/test/org/apache/commons/collections/TestCollectionUtils.java\n+++ b/src/test/org/apache/commons/collections/TestCollectionUtils.java\n \n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.HashSet;\n  * @author Steven Melzer\n  * @author Neil O'Toole\n  * \n- * @version $Revision: 1.42 $ $Date: 2004/12/11 06:30:38 $\n+ * @version $Revision: 1.43 $ $Date: 2004/12/19 16:56:31 $\n  */\n public class TestCollectionUtils extends TestCase {\n     \n     }\n     \n     public void testUnmodifiableCollectionCopy() {\n-\t\tCollection collection = new ArrayList();\n-\t\tcollection.add(\"a\");\n-    \tCollection copy = CollectionUtils.unmodifiableCollectionCopy(collection);\n-\n-\t\tassertTrue(copy instanceof Unmodifiable);\n-\t\tassertTrue(CollectionUtils.isEqualCollection(collection, copy));\n-\t\tcollection.clear();\n-\t\tassertTrue(copy.isEmpty() == false);\n-\n-\t\ttry\n-\t\t{\n+        Collection collection = new ArrayList();\n+        collection.add(\"a\");\n+        Collection copy = CollectionUtils.unmodifiableCollectionCopy(collection);\n+\n+        assertTrue(copy instanceof Unmodifiable);\n+        assertTrue(CollectionUtils.isEqualCollection(collection, copy));\n+        collection.clear();\n+        assertTrue(copy.isEmpty() == false);\n+\n+        try {\n \t\t\tcopy.clear();\n \t\t\tfail(\"should be unmodifiable.\");\n-\t\t}\n-\t\tcatch (UnsupportedOperationException uoe)\n-\t\t{} // this is what we want\n-\t\t\n-\t\ttry\n-\t\t{\n+\t\t} catch (UnsupportedOperationException uoe) {\n+\t\t} // this is what we want\n+\n+\t\ttry {\n \t\t\tcopy = CollectionUtils.unmodifiableCollectionCopy(null);\n \t\t\tfail(\"should throw IllegalArgumentException\");\n+\t\t} catch (IllegalArgumentException iae) {\n \t\t}\n-\t\tcatch(IllegalArgumentException iae)\n-\t\t{}\n-\t}\n+    }\n     \n }\n--- a/src/test/org/apache/commons/collections/TestListUtils.java\n+++ b/src/test/org/apache/commons/collections/TestListUtils.java\n /**\n  * Tests for ListUtils.\n  * \n- * @version $Revision: 1.20 $ $Date: 2004/12/11 06:24:10 $\n+ * @version $Revision: 1.21 $ $Date: 2004/12/19 16:56:31 $\n  * \n  * @author Stephen Colebourne\n  * @author Neil O'Toole\n  */\n public class TestListUtils extends BulkTest {\n \n-\tprivate static final String a = \"a\";\n-\tprivate static final String b = \"b\";\n-\tprivate static final String c = \"c\";\n-\tprivate static final String d = \"d\";\n-\tprivate static final String e = \"e\";\n-\tprivate static final String x = \"x\";\n-\n-\tprivate String[] fullArray;\n-\tprivate List fullList;\n-\t\n-\tpublic TestListUtils(String name) {\n+    private static final String a = \"a\";\n+    private static final String b = \"b\";\n+    private static final String c = \"c\";\n+    private static final String d = \"d\";\n+    private static final String e = \"e\";\n+    private static final String x = \"x\";\n+\n+    private String[] fullArray;\n+    private List fullList;\n+    \n+    public TestListUtils(String name) {\n         super(name);\n     }\n \n         return BulkTest.makeSuite(TestListUtils.class);\n     }\n \n-\tpublic void setUp() {\n-\t\tfullArray = new String[]{a, b, c, d, e};\n-\t\tfullList = new ArrayList(Arrays.asList(fullArray));\n-\t}\n+    public void setUp() {\n+        fullArray = new String[]{a, b, c, d, e};\n+        fullList = new ArrayList(Arrays.asList(fullArray));\n+    }\n     \n     \n     public void testNothing() {\n         assertEquals(6, list.size());\n     }\n \n-\tpublic void testEquals() {\n-\t\tCollection data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n-\t\t\n-\t\tList a = new ArrayList( data );\n-\t\tList b = new ArrayList( data );\n-\t\t\n+    public void testEquals() {\n+        Collection data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+        \n+        List a = new ArrayList( data );\n+        List b = new ArrayList( data );\n+        \n         assertEquals(true, a.equals(b));\n         assertEquals(true, ListUtils.isEqualList(a, b));\n         a.clear();\n         assertEquals(false, ListUtils.isEqualList(a, null));\n         assertEquals(false, ListUtils.isEqualList(null, b));\n         assertEquals(true, ListUtils.isEqualList(null, null));\n-\t}\n-\t\n-\tpublic void testHashCode() {\n-\t\tCollection data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n-\t\t\t\n-\t\tList a = new ArrayList( data );\n-\t\tList b = new ArrayList( data );\n-\t\t\n+    }\n+    \n+    public void testHashCode() {\n+        Collection data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+            \n+        List a = new ArrayList( data );\n+        List b = new ArrayList( data );\n+        \n         assertEquals(true, a.hashCode() == b.hashCode());\n         assertEquals(true, a.hashCode() == ListUtils.hashCodeForList(a));\n         assertEquals(true, b.hashCode() == ListUtils.hashCodeForList(b));\n         a.clear();\n         assertEquals(false, ListUtils.hashCodeForList(a) == ListUtils.hashCodeForList(b));\n         assertEquals(0, ListUtils.hashCodeForList(null));\n-\t}\n-\t\n-\tpublic void testUnmodifiableListCopy() {\n-\t\tList list = new ArrayList();\n-\t\tlist.add(\"a\");\n-\t\tList copy = ListUtils.unmodifiableListCopy(list);\n-\n-\t\tassertTrue(copy instanceof Unmodifiable);\n-\t\tassertTrue(list.equals(copy));\n-\t\tlist.clear();\n-\t\tassertTrue(copy.isEmpty() == false);\n-\n-\t\ttry\n-\t\t{\n-\t\t\tcopy.clear();\n-\t\t\tfail(\"should be unmodifiable.\");\n-\t\t}\n-\t\tcatch (UnsupportedOperationException uoe)\n-\t\t{\n-\t\t\t// this is what we want\n-\t\t}\n-\t\t\n-\t\ttry\n-\t\t{\n-\t\t\tlist = ListUtils.unmodifiableListCopy(null);\n-\t\t\tfail(\"expecting IllegalArgumentException\");\n-\t\t}\n-\t\tcatch (IllegalArgumentException iae)\n-\t\t{\n-\t\t\t// this is what we want\n-\t\t}\n-\t}\n-\t\n-\tpublic void testRetainAll() {\n-\t\tList sub = new ArrayList();\n-\t\tsub.add(a);\n-\t\tsub.add(b);\n-\t\tsub.add(x);\n-\n-\t\tList retained = ListUtils.retainAll(fullList, sub);\n-\t\tassertTrue(retained.size() == 2);\n-\t\tsub.remove(x);\n-\t\tassertTrue(retained.equals(sub));\n-\t\tfullList.retainAll(sub);\n-\t\tassertTrue(retained.equals(fullList));\n-\t\t\n-\t\ttry\n-\t\t{\n-\t\t\tList list = ListUtils.retainAll(null, null);\n-\t\t\tfail(\"expecting NullPointerException\");\n-\t\t}\n-\t\tcatch(NullPointerException npe)\n-\t\t{} // this is what we want\n-\t}\n-\n-\tpublic void testRemoveAll() {\n-\t\tList sub = new ArrayList();\n-\t\tsub.add(a);\n-\t\tsub.add(b);\n-\t\tsub.add(x);\n-\n-\t\tList remainder = ListUtils.removeAll(fullList, sub);\n-\t\tassertTrue(remainder.size() == 3);\n-\t\tfullList.removeAll(sub);\n-\t\tassertTrue(remainder.equals(fullList));\n-\t\t\n-\t\ttry\n-\t\t{\n-\t\t\tList list = ListUtils.removeAll(null, null);\n-\t\t\tfail(\"expecting NullPointerException\");\n-\t\t}\n-\t\tcatch(NullPointerException npe)\n-\t\t{} // this is what we want\n-\t}\n-\t\n+    }\n+    \n+    public void testUnmodifiableListCopy() {\n+        List list = new ArrayList();\n+        list.add(\"a\");\n+        List copy = ListUtils.unmodifiableListCopy(list);\n+\n+        assertTrue(copy instanceof Unmodifiable);\n+        assertTrue(list.equals(copy));\n+        list.clear();\n+        assertTrue(copy.isEmpty() == false);\n+\n+        try {\n+            copy.clear();\n+            fail(\"should be unmodifiable.\");\n+        } catch (UnsupportedOperationException uoe) {\n+            // this is what we want\n+        }\n+        \n+        try {\n+            list = ListUtils.unmodifiableListCopy(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // this is what we want\n+        }\n+    }\n+    \n+    public void testRetainAll() {\n+        List sub = new ArrayList();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        List retained = ListUtils.retainAll(fullList, sub);\n+        assertTrue(retained.size() == 2);\n+        sub.remove(x);\n+        assertTrue(retained.equals(sub));\n+        fullList.retainAll(sub);\n+        assertTrue(retained.equals(fullList));\n+        \n+        try {\n+            List list = ListUtils.retainAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(NullPointerException npe){} // this is what we want\n+    }\n+\n+    public void testRemoveAll() {\n+        List sub = new ArrayList();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        List remainder = ListUtils.removeAll(fullList, sub);\n+        assertTrue(remainder.size() == 3);\n+        fullList.removeAll(sub);\n+        assertTrue(remainder.equals(fullList));\n+        \n+        try {\n+            List list = ListUtils.removeAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(NullPointerException npe) {} // this is what we want\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/collections/TestMapUtils.java\n+++ b/src/test/org/apache/commons/collections/TestMapUtils.java\n /**\n  * Tests for MapUtils.\n  * \n- * @version $Revision: 1.25 $ $Date: 2004/12/11 06:26:13 $\n+ * @version $Revision: 1.26 $ $Date: 2004/12/19 16:56:31 $\n  * \n  * @author Stephen Colebourne\n  * @author Arun Mammen Thomas\n         assertEquals(EXPECTED_OUT, out.toString());\n     }\n     \n-\tpublic void testUnmodifiableMapCopy() {\n-\t\tMap map = new HashMap();\n-\t\tmap.put(\"key\", \"value\");\n-\n-\t\tMap copy = MapUtils.unmodifiableMapCopy(map);\n-\t\tassertTrue(copy instanceof Unmodifiable);\n-\t\tassertEquals(map, copy);\n-\t\tmap.clear();\n-\t\tassertFalse(map.equals(copy));\n-\n-\t\ttry\n-\t\t{\n-\t\t\tcopy.clear();\n-\t\t\tfail(\"should be unmodifiable.\");\n-\t\t}\n-\t\tcatch (UnsupportedOperationException uoe)\n-\t\t{\n-\t\t\t// this is what we want\n-\t\t}\n-\t\t\n-\t\ttry\n-\t\t{\n-\t\t\tmap = MapUtils.unmodifiableMapCopy(null);\n-\t\t\tfail(\"expecting IllegalArgumentException\");\n-\t\t}\n-\t\tcatch (IllegalArgumentException iae)\n-\t\t{\n-\t\t\t// this is what we want\n-\t\t}\n-\n-\t}\n-    \n+    public void testUnmodifiableMapCopy() {\n+        Map map = new HashMap();\n+        map.put(\"key\", \"value\");\n+\n+        Map copy = MapUtils.unmodifiableMapCopy(map);\n+        assertTrue(copy instanceof Unmodifiable);\n+        assertEquals(map, copy);\n+        map.clear();\n+        assertFalse(map.equals(copy));\n+\n+        try {\n+            copy.clear();\n+            fail(\"should be unmodifiable.\");\n+        } catch (UnsupportedOperationException uoe) {\n+            // this is what we want\n+        }\n+        \n+        try {\n+            map = MapUtils.unmodifiableMapCopy(null);\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // this is what we want\n+        }\n+\n+    }\n+\n }", "timestamp": 1103475391, "metainfo": ""}