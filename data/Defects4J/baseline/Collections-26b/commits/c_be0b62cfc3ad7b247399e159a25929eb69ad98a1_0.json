{"sha": "be0b62cfc3ad7b247399e159a25929eb69ad98a1", "log": "Enhanced TestMap to more completely test the Map contract.  Submitted by: Paul Jack ( pjack at sfaf dot org ).  Needed to change Paul's implementation slightly to get things compile properly using JDK 1.2.  The 1.2 compiler thought that the \"confirmed\" field was ambiguous in the anonymous inner class and thus needed to be qualified with a ClassName.this.  In order to do that, the anonymous inner classes needed to be made named inner classes.  This change exposes one test failure for MultiHashMap that appears to be caused by its values() method not being backed by the map (bug 9573).   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestMap.java\n+++ b/src/test/org/apache/commons/collections/TestMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.16 2002/05/28 06:51:03 mas Exp $\n- * $Revision: 1.16 $\n- * $Date: 2002/05/28 06:51:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.17 2002/06/18 03:17:34 mas Exp $\n+ * $Revision: 1.17 $\n+ * $Date: 2002/06/18 03:17:34 $\n  *\n  * ====================================================================\n  *\n /**\n  * Tests base {@link java.util.Map} methods and contracts.\n  * <p>\n+ * The forces at work here are similar to those in {@link TestCollection}.\n  * If your class implements the full Map interface, including optional\n  * operations, simply extend this class, and implement the {@link\n  * #makeEmptyMap()} method.\n  * <p>\n+ * On the other hand, if your map implemenation is wierd, you may have to\n+ * override one or more of the other protected methods.  They're described\n+ * below.<P>\n+ *\n+ * <B>Entry Population Methods</B><P>\n+ *\n+ * Override these methods if your map requires special entries:\n+ *\n+ * <UL>\n+ * <LI>{@link #getSampleKeys}\n+ * <LI>{@link #getSampleValues}\n+ * <LI>{@link #getNewSampleValues}\n+ * <LI>{@link #getOtherKeys}\n+ * <LI>{@link #getOtherValues}\n+ * </UL>\n+ *\n+ * <B>Supported Operation Methods</B><P>\n+ *\n+ * Override these methods if your map doesn't support certain operations:\n+ *\n+ * <UL>\n+ * <LI> {@link #useDuplicateValues}\n+ * <LI> {@link #useNullKey}\n+ * <LI> {@link #useNullValue}\n+ * <LI> {@link #isAddRemoveModifiable}\n+ * <LI> {@link #isChangeable}\n+ * </UL>\n+ *\n+ * <B>Fixture Methods</B><P>\n+ *\n+ * For tests on modification operations (puts and removes), fixtures are used\n+ * to verify that that operation results in correct state for the map and its\n+ * collection views.  Basically, the modification is performed against your\n+ * map implementation, and an identical modification is performed against\n+ * a <I>confirmed</I> map implementation.  A confirmed map implementation is\n+ * something like <Code>java.util.HashMap</Code>, which is known to conform\n+ * exactly to the {@link Map} contract.  After the modification takes place\n+ * on both your map implementation and the confirmed map implementation, the\n+ * two maps are compared to see if their state is identical.  The comparison\n+ * also compares the collection views to make sure they're still the same.<P>\n+ *\n+ * The upshot of all that is that <I>any</I> test that modifies the map in\n+ * <I>any</I> way will verify that <I>all</I> of the map's state is still\n+ * correct, including the state of its collection views.  So for instance\n+ * if a key is removed by the map's key set's iterator, then the entry set \n+ * is checked to make sure the key/value pair no longer appears.<P>\n+ *\n+ * The {@link #map} field holds an instance of your collection implementation.\n+ * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n+ * that map's collection views.  And the {@link #confirmed} field holds\n+ * an instance of the confirmed collection implementation.  The \n+ * {@link #resetEmpty} and {@link #resetFull} methods set these fields to \n+ * empty or full maps, so that tests can proceed from a known state.<P>\n+ *\n+ * After a modification operation to both {@link #map} and \n+ * {@link #confirmed}, the {@link #verify} method is invoked to compare the\n+ * results.  You may want to override {@link #verify} to perform additional\n+ * verifications.  For instance, {@link TestDoubleOrderedMap} would want \n+ * override its {@link #verify} method to verify that the values are unique\n+ * and in ascending order.<P>\n+ *  \n+ * <B>Other Notes</B><P>\n+ *\n  * If your {@link Map} fails one of these tests by design, you may still use\n  * this base set of cases.  Simply override the test case (method) your {@link\n  * Map} fails and/or the methods that define the assumptions used by the test\n  * cases.  For example, if your map does not allow duplicate values, override\n- * {@link useDuplicateValues()} and have it return <code>false</code>\n+ * {@link #useDuplicateValues()} and have it return <code>false</code>\n  *\n  * @author Michael Smith\n  * @author Rodney Waldhoff\n- * @version $Id: TestMap.java,v 1.16 2002/05/28 06:51:03 mas Exp $\n+ * @author Paul Jack\n+ * @version $Id: TestMap.java,v 1.17 2002/06/18 03:17:34 mas Exp $\n  */\n public abstract class TestMap extends TestObject {\n \n+    // These instance variables are initialized with the reset method.\n+    // Tests for map methods that alter the map (put, putAll, remove) \n+    // first call reset() to create the map and its views; then perform\n+    // the modification on the map; perform the same modification on the\n+    // confirmed; and then call verify() to ensure that the map is equal\n+    // to the confirmed, that the already-constructed collection views\n+    // are still equal to the confirmed's collection views.\n+\n+\n+    /** Map created by reset(). */\n+    protected Map map;\n+\n+    /** Entry set of map created by reset(). */\n+    protected Set entrySet;\n+\n+    /** Key set of map created by reset(). */\n+    protected Set keySet;\n+\n+    /** Values collection of map created by reset(). */\n+    protected Collection values;\n+\n+    /** HashMap created by reset(). */\n+    protected HashMap confirmed;\n+\n+\n     public TestMap(String testName) {\n         super(testName);\n     }\n+\n+\n     /**\n      *  Override if your map does not allow a <code>null</code> key.  The\n      *  default implementation returns <code>true</code>\n      **/\n-    public boolean useNullKey() {\n+    protected boolean useNullKey() {\n         return true;\n     }\n \n      *  Override if your map does not allow <code>null</code> values.  The\n      *  default implementation returns <code>true</code>.\n      **/\n-    public boolean useNullValue() {\n+    protected boolean useNullValue() {\n         return true;\n     }\n \n      *  Override if your map does not allow duplicate values.  The default\n      *  implementation returns <code>true</code>.\n      **/\n-    public boolean useDuplicateValues() {\n+    protected boolean useDuplicateValues() {\n         return true;\n     }\n \n      *  Override if your map allows its mappings to be changed to new values.\n      *  The default implementation returns <code>true</code>.\n      **/\n-    public boolean isChangeable() {\n+    protected boolean isChangeable() {\n         return true;\n     }\n \n      *  Override if your map does not allow add/remove modifications.  The\n      *  default implementation returns <code>true</code>.\n      **/\n-    public boolean isAddRemoveModifiable() {\n+    protected boolean isAddRemoveModifiable() {\n         return true;\n     }\n \n      *  default implementation constructs a set of String keys, and includes a\n      *  single null key if {@link #useNullKey()} returns <code>true</code>.\n      **/\n-    public Object[] getSampleKeys() {\n+    protected Object[] getSampleKeys() {\n         Object[] result = new Object[] {\n             \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\", \n             \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n         return result;\n     }\n \n+\n+    protected Object[] getOtherKeys() {\n+        return TestCollection.getOtherNonNullStringElements();\n+    }\n+\n+    protected Object[] getOtherValues() {\n+        return TestCollection.getOtherNonNullStringElements();\n+    }\n+\n     /**\n      *  Returns the set of values in the mappings used to test the map.  This\n      *  method must return an array with the same length as {@link\n      *  that are the same if {@link #useDuplicateValues()} returns\n      *  <code>true</code>.\n      **/\n-    public Object[] getSampleValues() {\n+    protected Object[] getSampleValues() {\n         Object[] result = new Object[] {\n             \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n             \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n      *  that are the same if {@link #useDuplicateValues()} returns\n      *  <code>true</code>.  \n      **/\n-    public Object[] getNewSampleValues() {\n+    protected Object[] getNewSampleValues() {\n         Object[] result = new Object[] {\n             (useNullValue()) ? null : \"newnonnullvalue\",\n             \"newvalue\",\n      *  Helper method to add all the mappings described by {@link\n      *  #getSampleKeys()} and {@link #getSampleValues()}.\n      **/\n-    public void addSampleMappings(Map m) {\n+    protected void addSampleMappings(Map m) {\n \n         Object[] keys = getSampleKeys();\n         Object[] values = getSampleValues();\n     /**\n      * Return a new, empty {@link Map} to be used for testing. \n      */\n-    public abstract Map makeEmptyMap();\n+    protected abstract Map makeEmptyMap();\n \n     /**\n      *  Return a new, populated map.  The mappings in the map should match the\n      *  and calls {@link #addSampleMappings()} to add all the mappings to the\n      *  map.\n      **/\n-    public Map makeFullMap() {\n+    protected Map makeFullMap() {\n         Map m = makeEmptyMap();\n         addSampleMappings(m);\n         return m;\n     /**\n      *  Tests Map.isEmpty()\n      **/\n-    public void testIsEmpty() {\n+    public void testMapIsEmpty() {\n         Map em = makeEmptyMap();\n         assertEquals(\"Map.isEmpty() should return true with an empty map\", \n                      true, em.isEmpty());\n     /**\n      *  Tests Map.size()\n      **/\n-    public void testSize() {\n+    public void testMapSize() {\n         Map em = makeEmptyMap();\n         assertEquals(\"Map.size() should be 0 with an empty map\",\n                      0, em.size());\n      *  UnsupportedOperationException.  This method checks that the both maps\n      *  returned by makeEmptyMap and makeFullMap have correct behavior.\n      **/\n-    public void testClear() {\n-        Map em = makeEmptyMap();\n-        try {\n-            em.clear();\n-            assertTrue(\"Map must throw UnsupportedOperationException if the \" +\n-                       \"map does not support removing elements\", \n-                       isAddRemoveModifiable());\n-            assertEquals(\"size() must return zero after clear.\", \n-                         0, em.size());\n-            assertEquals(\"isEmpty() must return true after clear.\", \n-                         true, em.isEmpty());\n-        } catch (UnsupportedOperationException exception) {\n-            assertTrue(\"Map must not throw UnsupportedOperationException if the \" +\n-                       \"map supports removing elements\", !isAddRemoveModifiable());\n-        }\n-\n-        Map fm = makeFullMap();\n-        try {\n-            fm.clear();\n-            assertTrue(\"Map must throw UnsupportedOperationException if the \" +\n-                       \"map does not support removing elements\", \n-                       isAddRemoveModifiable());\n-            assertEquals(\"size() must return zero after clear.\", \n-                         0, fm.size());\n-            assertEquals(\"isEmpty() must return true after clear.\", \n-                         true, fm.isEmpty());\n-        } catch (UnsupportedOperationException exception) {\n-            assertTrue(\"Map must not throw UnsupportedOperationException if the \" +\n-                       \"map supports removing elements\", !isAddRemoveModifiable());\n-        }\n-    }\n-\n-    public void testFailFastIterator() {\n-        Map fm = makeFullMap();\n-\n-        Iterator iterator = fm.keySet().iterator();\n-        try {\n-            fm.remove(getSampleKeys()[0]);\n-        } catch (UnsupportedOperationException e) {\n-            return;\n-        }\n-\n-        try {\n-            iterator.next();\n-            fail(\"Iterators typically throw ConcurrentModificationExceptions when underlying collection is modified.\");\n-        } catch (ConcurrentModificationException e) {\n-\n-        }\n-    }\n-\n-    /**\n-     *  Tests:\n-     *  <ul>\n-     *  <li> Map.entrySet().isEmpty()\n-     *  <li> Map.entrySet().size()\n-     *  </ul>\n-     **/\n-    public void testEntrySetIsEmpty() {\n-        Map em = makeEmptyMap();\n-        Set es = em.entrySet();\n-        \n-        assertEquals(\"entrySet() must return an empty set when map is empty.\", \n-                     em.isEmpty(), es.isEmpty());\n-        assertEquals(\"entrySet() must return a set with the same size as \" +\n-                     \"the map.\", em.size(), es.size());\n-\n-        Map fm = makeEmptyMap();\n-        Set fs = fm.entrySet();\n-        \n-        assertEquals(\"entrySet() must return a non-empty set when map is not empty.\", \n-                     fm.isEmpty(), fs.isEmpty());\n-        assertEquals(\"entrySet() must return a set with the same size as \" +\n-                     \"the map.\", fm.size(), fs.size());\n-    }\n+    public void testMapClear() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        resetEmpty();\n+        map.clear();\n+        confirmed.clear();\n+        verify();\n+        \n+        resetFull();\n+        map.clear();\n+        confirmed.clear();\n+        verify();\n+    }\n+\n \n     /**\n      *  Tests Map.containsKey(Object) by verifying it returns false for all\n      *  sample keys on a map created using makeEmptyMap() and returns true for\n      *  all sample keys returned on a map created using makeFullMap()\n      **/\n-    public void testContainsKey() {\n+    public void testMapContainsKey() {\n         Object[] keys = getSampleKeys();\n \n         Map em = makeEmptyMap();\n      *  sample alues on a map created using makeEmptyMap() and returns true for\n      *  all sample values returned on a map created using makeFullMap.\n      **/\n-    public void testContainsValue() {\n+    public void testMapContainsValue() {\n         Object[] values = getSampleValues();\n \n         Map em = makeEmptyMap();\n         }\n     }\n \n-    /**\n-     *  Test to ensure that Map.entrySet() returns a non-null set.\n-     **/\n-    public void testEntrySet() {\n-        Map em = makeEmptyMap();\n-        Set es = em.entrySet();\n-        \n-        assertTrue(\"entrySet() must return a non-null set.\", es != null);\n-\n-        Map fm = makeEmptyMap();\n-        Set fs = fm.entrySet();\n-        \n-        assertTrue(\"entrySet() must return a non-null set.\", fs != null);\n-    }\n-    \n-    /**\n-     *  Tests:\n-     *  <ul>\n-     *  <li> Map.entrySet().contains(Object)\n-     *  <li> Map.entrySet().containsAll(Collection)\n-     *  </ul>\n-     *\n-     *  Note:  This test relies on a working commons.collections.DefaultMapEntry class.\n-     **/\n-    public void testEntrySetContainsProperMappings() {\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        Map.Entry[] entries = new Map.Entry[keys.length];\n-        HashSet mappings = new HashSet();\n-\n-        for(int i = 0; i < keys.length; i++) {\n-            entries[i] = new DefaultMapEntry(keys[i], values[i]);\n-            mappings.add(entries[i]);\n-        }\n-\n-        // test an empty map\n-        Map em = makeEmptyMap();\n-        Set es = em.entrySet();\n-\n-        for(int i = 0; i < keys.length; i++) {\n-            assertEquals(\"entrySet().contains(Object) must return false when map \" +\n-                         \"is empty\", false, es.contains(entries[i]));\n-        }\n-\n-        assertEquals(\"entrySet().containsAll(Collection) must return false when the \" +\n-                     \"map is empty\", false, es.containsAll(mappings));\n-\n-\n-        Map fm = makeFullMap();\n-        Set fs = fm.entrySet();\n-\n-        for(int i = 0; i < keys.length; i++) {\n-            assertEquals(\"entrySet().contains(Object) must return true when map \" +\n-                         \"contains the mapping\", true, fs.contains(entries[i]));\n-        }\n-        assertEquals(\"entrySet().containsAll(Collection) must return true when the \" +\n-                     \"map contains the mapping\", true, fs.containsAll(mappings));\n-\n-        try {\n-            es.containsAll((Collection)null);\n-            fail(\"entrySet().containsAll(null) should \" +\n-                 \"throw a NullPointerException\");\n-        } catch (NullPointerException exception) {\n-            // expected\n-        }\n-        try {\n-            fs.containsAll((Collection)null);\n-            fail(\"entrySet().containsAll(null) should \" +\n-                 \"throw a NullPointerException\");\n-        } catch (NullPointerException exception) {\n-            // expected\n-        }\n-    }\n-\n-    /**\n-     *  Tests Map.entrySet().clear() using Map.isEmpty() and\n-     *  Map.entrySet().isEmpty().  \n-     **/\n-    public void testEntrySetClear() {\n-        if (!isAddRemoveModifiable()) return;\n-        Map m = makeFullMap();\n-        Set set = m.entrySet();\n-        set.clear();\n-        assertTrue(\"entrySet should be empty after clear\", set.isEmpty());\n-        assertTrue(\"map should be empty after entrySet.clear()\", m.isEmpty());\n-    }\n-\n-\n-    /**\n-     *  Tests Map.entrySet().add(Object);\n-     **/\n-    public void testEntrySetAdd() {\n-        Map m = makeFullMap();\n-        Set set = m.entrySet();\n-        try {\n-            set.add(new Object());\n-            fail(\"entrySet().add should raise UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n-            // expected\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests Map.entrySet().addAll(Collection);\n-     **/\n-    public void testEntrySetAddAll() {\n-        Map m = makeFullMap();\n-        Set set = m.entrySet();\n-        try {\n-            set.addAll(java.util.Collections.singleton(new Object()));\n-            fail(\"entrySet().addAll(Collection) should raise \" +\n-\t\t \"UnsupportedOperationException\");\n-        } catch (UnsupportedOperationException e) {\n-            // expected\n-        }\n-    }\n-\n-    /**\n-     *  Tests Map.entrySetContainsAll(Collection)\n-     **/\n-    public void testEntrySetContainsAll() {\n-        Map m = makeFullMap();\n-        Set set = m.entrySet();\n-\n-        java.util.ArrayList list = new java.util.ArrayList();\n-        Iterator iterator = set.iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry entry = (Map.Entry)iterator.next();\n-            list.add(new DefaultMapEntry(entry.getKey(), entry.getValue()));\n-\n-\t    assertTrue(\"entrySet().containsAll failed\", set.containsAll(list));\n-        }\n-\n-        list.add(new Object());\n-        assertTrue(\"entrySet().containsAll failed\", !set.containsAll(list));\n-    }\n-\n-\n-    /**\n-     *  Tests entrySet().equals(Object)\n-     **/\n-    public void testEntrySetEquals() {\n-        Map m = makeFullMap();\n-        Map m2 = new HashMap(m);\n-        assertTrue(\"Equal maps should have equal entrySets\", \n-\t\t   m.entrySet().equals(m2.entrySet()));\n-\n-        assertTrue(\"entrySet.equals(null) returned true\", \n-\t\t   !m.entrySet().equals(null));\n-        assertTrue(\"Unequal maps should have unequal entrySets\", \n-\t\t   !m.entrySet().equals(Collections.EMPTY_SET));\n-    }\n-\n-\n-    /**\n-     *  Test entrySet().hashCde()\n-     **/\n-    public void testEntrySetHashCode() {\n-        Map m = makeFullMap();\n-        Map m2 = new HashMap(m);\n-        Set set = m.entrySet();\n-        Set set2 = m2.entrySet();\n-        assertTrue(\"hashCode of equal entrySets should be same\", \n-\t\t   set.hashCode() == set2.hashCode());\n-    }\n-\n-\n-    /**\n-     *  Test entrySet().toArray() and entrySet().toArray(Object[])\n-     **/\n-    public void testEntrySetToArray() {\n-        Map m = makeFullMap();\n-        Set set = m.entrySet();\n-        Object[] a = set.toArray();\n-        assertTrue(\"entrySet.toArray() should be same size as map\", \n-\t\t   a.length == m.size());\n-\n-        a = set.toArray(new Object[0]);\n-        assertTrue(\"entrySet.toArray(new Object[0]) should be same size \" +\n-\t\t   \"as map\", a.length == m.size());\n-\n-        a = new Object[m.size() * 2];\n-        a[m.size()] = new Object();\n-        a = set.toArray(a);\n-        assertTrue(\"entrySet.toArray(new Object[m.size * 2]) should set \" +\n-\t\t   \"last element to null\", a[m.size()] == null);\n-\n-        a = set.toArray(new Map.Entry[0]);\n-        assertTrue(\"entrySet.toArray(new Map.Entry[0]) should return \" +\n-\t\t   \"instanceof Map.Entry[]\", a instanceof Map.Entry[]);\n-\n-        try {\n-            a = set.toArray(new String[0]);\n-            fail(\"entrySet.toArray(new String[]) should raise \" +\n-\t\t \"ArrayStoreException.\");\n-        } catch (ArrayStoreException e) {\n-            // expected\n-        }\n-        \n-    }\n-\n-    /**\n-     *  Tests entrySet().remove(Object)\n-     **/\n-    public void testEntrySetRemove2() {\n-        if (!isAddRemoveModifiable()) return;\n-\n-        Map m = makeFullMap();\n-        Set set = m.entrySet();\n-\n-        boolean r = set.remove(null);\n-        assertTrue(\"entrySet.remove(null) should return false\", !r);\n-\n-        r = set.remove(\"Not a Map.Entry\");\n-        assertTrue(\"entrySet.remove should return false for non-Map.Entry\", \n-\t\t   !r);\n-\n-\tm = makeEmptyMap();\n-\tset = m.entrySet();\n-\n-\tObject[] keys = getSampleKeys();\n-\tObject[] values = getSampleValues();\n-\n-\tfor(int i = 0; i < keys.length; i++) {\n-\t    // remove on all elements should return false because the map is\n-\t    // empty.\n-\t    r = set.remove(new DefaultMapEntry(keys[i], values[i]));\n-\t    assertTrue(\"entrySet.remove for nonexistent entry should \" +\n-\t\t       \"return false\", !r);\n-\t}\n-\n-\t// reset to full map to check actual removes\n-\tm = makeFullMap();\n-\tset = m.entrySet();\n-\n-        int size = m.size();\n-        Map.Entry entry = (Map.Entry)set.iterator().next();\n-        r = set.remove(entry);\n-        assertTrue(\"entrySet.remove for internal entry should return true\", r);\n-        assertTrue(\"entrySet.size should shrink after successful remove\", \n-\t\t   set.size() == size - 1);\n-        assertTrue(\"map size should shrink after succuessful entrySet.remove\", \n-\t\t   m.size() == size - 1);\n-        entrySetEqualsMap(set, m);\n-\n-        size--;\n-        entry = (Map.Entry)set.iterator().next();\n-        entry = new DefaultMapEntry(entry.getKey(), entry.getValue());\n-        r = set.remove(entry);\n-        assertTrue(\"entrySet.remove for external entry should return true\", r);\n-        assertTrue(\"entrySet.size should shrink after successful remove\", \n-\t\t   set.size() == size - 1);\n-        assertTrue(\"map size should shrink after succuessful entrySet.remove\",\n-\t\t   m.size() == size - 1);\n-        assertTrue(\"After remove, entrySet should not contain element\", \n-\t\t   !set.contains(entry));\n-        entrySetEqualsMap(set, m);\n-        r = set.remove(entry);\n-        assertTrue(\"second entrySet.remove should return false\", !r);\n-    }\n-\n-\n-    /**\n-     *  Tests entrySet().removeAll() and entrySet().retainAll()\n-     **/\n-    public void testEntrySetBulkRemoveOperations() {\n-\tif (!isAddRemoveModifiable()) return;\n-\n-        Map m = makeFullMap();\n-        Set set = m.entrySet();\n-        Map m2 = new HashMap(m);\n-        Set set2 = m2.entrySet();\n-\n-        Object[] entries = set2.toArray();\n-        Collection c = Arrays.asList(entries).subList(2, 5);\n-        boolean r = set.removeAll(c);\n-        set2.removeAll(c);\n-        assertTrue(\"entrySet().removeAll() returned false\", r);\n-        assertTrue(\"entrySet().removeAll() failed\", m2.equals(m));\n-        assertTrue(\"entrySet().removeAll() returned true\", !set.removeAll(c));\n-\n-        m = makeFullMap();\n-        set = m.entrySet();\n-        m2 = new HashMap(m);\n-        set2 = m2.entrySet();\n-        entries = set2.toArray();\n-        c = Arrays.asList(entries).subList(2, 5);\n-        r = set.retainAll(c);\n-        set2.retainAll(c);\n-        assertTrue(\"entrySet().retainAll returned false\", r);\n-        assertTrue(\"entrySet().retainAll() failed\", m2.equals(m));\n-        assertTrue(\"entrySet().retainAll returned true\", !set.retainAll(c));\n-    }\n-\n-\n-    /**\n-     *  Tests:\n-     *  <ul>\n-     *  <li> Map.entrySet().iterator()\n-     *  <li> Map.entrySet().iterator().hasNext()\n-     *  <li> Map.entrySet().iterator().next()\n-     *  </ul>\n-     **/\n-    public void testEntrySetIterator() {\n-        Map em = makeEmptyMap();\n-        Set es = em.entrySet();\n-        Iterator eiter = es.iterator();\n-\n-        assertEquals(\"entrySet().iterator().hasNext() must return false \" +\n-                     \"when then the map is empty.\", \n-                     false, eiter.hasNext());\n-\n-        // note: we make a new map to test for this because some impls in the\n-        // past have required a call to hasMoreElements before a call to next\n-        // for it to work properly.  By using a new map, we make sure this test\n-        // will catch those broken impls.\n-        em = makeEmptyMap();\n-        es = em.entrySet();\n-        eiter = es.iterator();\n-        \n-        try {\n-            eiter.next();\n-            fail(\"entrySet().iterator().next() must throw a NoSuchElementException \" +\n-                 \"when the map is empty\");\n-        } catch (NoSuchElementException exception) {\n-            // expected\n-        }\n-\n-\n-        Map fm = makeFullMap();\n-\n-        Set fs = fm.entrySet();\n-\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-        boolean[] found = new boolean[keys.length];\n-\n-        Iterator iter = fs.iterator();\n-\n-        assertTrue(\"entrySet().iterator() must return a non-null \" +\n-                   \"iterator.\", iter != null);\n-\n-        while(iter.hasNext()) {\n-            Object obj = iter.next();\n-            assertTrue(\"Null is not allowed to be returned from the \" +\n-                       \"entrySet().iterator()'s next().\", obj != null);\n-            assertTrue(\"Objects returned from entrySet().iterator() must be \" +\n-                       \"instances of Map.Entry.\", obj instanceof Map.Entry);\n-                \n-            Map.Entry entry = (Map.Entry)obj;\n-            Object key = entry.getKey();\n-            Object value = entry.getValue();\n-\n-            assertTrue(\"the key for an entry returned from the entry \" +\n-                       \"set's iterator can only be null if useNullKey \" +\n-                       \"is true.\",\n-                       key != null || (key == null && useNullKey()));\n-            \n-            assertTrue(\"the value for an entry returned from the entry \" +\n-                       \"set's iterator can only be null if useNullValue \" +\n-                       \"is true.\",\n-                       value != null || (value == null && useNullValue()));\n-\n-            for(int i = 0; i < keys.length; i++) {\n-                if((key == null && keys[i] == null) ||\n-                   (key != null && key.equals(keys[i]))) {\n-                    assertTrue(\"entrySet().iterator() must not return \" +\n-                               \"multiple entries with the same key.\", \n-                               !found[i]);\n-                        \n-                    found[i] = true;\n-\n-                    assertTrue\n-                        (\"value of entry returned from iterator \" +\n-                         \"must be the value for the added mapping.\",\n-                         (value == null && values[i] == null) ||\n-                         (value != null && value.equals(values[i])));\n-                }\n-            }\n-        }\n-        for(int i = 0; i < found.length; i++) {\n-            assertTrue(\"must find all added elements through entrySet's \" +\n-                       \"iterator().\", found[i]);\n-        }\n-    }\n-  \n-    /**\n-     *  Tests Map.entrySet().iterator().remove()\n-     **/\n-    public void testEntrySetIteratorRemove() {\n-        Map m = makeFullMap();\n-        Set s = m.entrySet();\n-        Iterator iter = s.iterator();\n-\n-        try {\n-            iter.remove();\n-            fail(\"Entry set iterator must not allow a call to remove \" +\n-                 \"before any calls to next\");\n-        } catch (IllegalStateException exception) {\n-            // expected exception provided add/remove modifiable\n-            assertTrue(\"iterator should throw UnsupportedOperationException \" +\n-                       \"if remove is not allowed from the entrySet().iterator()\",\n-                       isAddRemoveModifiable());\n-        } catch (UnsupportedOperationException exception) {\n-            assertTrue(\"iterator should not throw UnsupportedOperationException \" +\n-                       \"if the map supports adding and removing elements\",\n-                       !isAddRemoveModifiable());\n-        }\n-\n-        while(iter.hasNext()) {\n-            Map.Entry entry = (Map.Entry)iter.next();\n-\n-            assertTrue(\"Entry key from entry set iterator must exist in map: \" +\n-\t\t       entry, m.containsKey(entry.getKey()));\n-            try {\n-                iter.remove();\n-                // note: we do not check that the mapping was actually removed\n-                // from the map because some classes do not have their\n-                // entrySet().iterator() backed by the map.  That test occurs\n-                // below in testEntrySetIteratorRemoveCausesMapModification\n-            } catch (UnsupportedOperationException exception) {\n-                assertTrue(\"iterator should not throw UnsupportedOperationException \" +\n-                           \"if the map supports adding and removing elements\",\n-                           !isAddRemoveModifiable());\n-            }\n-\n-            try {\n-                iter.remove();\n-                fail(\"Entry set iterator must not allow two calls to \" +\n-                     \"remove without a call to next.\");\n-            } catch (IllegalStateException exception) {\n-                // expected exception provided add/remove modifiable\n-                assertTrue(\"iterator should throw UnsupportedOperationException \" +\n-                           \"if remove is not allowed from the entrySet().iterator()\",\n-                           isAddRemoveModifiable());\n-            } catch (UnsupportedOperationException exception) {\n-                assertTrue(\"iterator should not throw UnsupportedOperationException \" +\n-                           \"if the map supports adding and removing elements\",\n-                           !isAddRemoveModifiable());\n-            }\n-        }\n-    }\n-\n-    /**\n-     *  utility method to ensure that a set of Map.Entry objects matches those\n-     *  found in the specified map.\n-     **/\n-    protected void entrySetEqualsMap(Set set, Map m) {\n-        Iterator iterator = set.iterator();\n-        while (iterator.hasNext()) {\n-            Map.Entry entry = (Map.Entry)iterator.next();\n-            Object key = entry.getKey();\n-            Object value = entry.getValue();\n-            assertTrue(\"map should contain key found in entrySet\", \n-\t\t       m.containsKey(key));\n-            Object v2 = m.get(key);\n-            assertTrue(\"map should contain entry found in entrySet\", \n-\t\t       (value == null) ? v2 == null : value.equals(v2));\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests whether the map's entrySet() is backed by the map by making sure\n-     *  a put in the map is reflected in the entrySet.  This test does nothing\n-     *  if add/remove modifications are not supported.\n-     **/\n-    public void testEntrySetChangesWithMapPut() {\n-        if(!isAddRemoveModifiable()) return;\n-\n-        Map m = makeEmptyMap();\n-\n-        // test insert reflected in entry set\n-        Set s = m.entrySet();\n-        addSampleMappings(m);\n-        assertEquals(\"entrySet() must only be empty if map is empty.\",\n-                     m.isEmpty(), s.isEmpty());\n-        assertEquals(\"entrySet() must adjust size when map changes.\",\n-                     m.size(), s.size());\n-\n-        entrySetEqualsMap(s, m);\n-    }\n-\n-    /**\n-     *  Tests whether the map's entrySet() is backed by the map by making sure\n-     *  a remove from the map is reflected in the entrySet.  This test does\n-     *  nothing if add/remove modifications are not supported.\n-     **/\n-    public void testEntrySetChangesWithMapRemove() {\n-        if(!isAddRemoveModifiable()) return;\n-\n-        Map m = makeFullMap();\n-        Set s = m.entrySet();\n-\n-        Object[] keys = getSampleKeys();\n-        Object[] values = getSampleValues();\n-\n-        for(int i = 0; i < keys.length; i++) {\n-            m.remove(keys[i]);\n-            assertEquals(\"entrySet() must only be empty if map is empty.\",\n-                         m.isEmpty(), s.isEmpty());\n-            assertEquals(\"entrySet() must adjust size when map changes.\",\n-                         m.size(), s.size());\n-            entrySetEqualsMap(s, m);\n-        }\n-    }\n-\n-\n-    /**\n-     *  Tests whether the map's entrySet() is backed by the map by making sure\n-     *  a clear on the map is reflected in the entrySet.  This test does\n-     *  nothing if add/remove modifications are not supported.\n-     **/\n-    public void testEntrySetChangesWithMapClear() {\n-        if (!isAddRemoveModifiable()) return;\n-\n-        Map m = makeFullMap();\n-        Set s = m.entrySet();\n-        m.clear();\n-        assertTrue(\"entrySet() must be empty after map.clear()\", s.isEmpty());\n-    }\n-\n-\n-    /**\n-     *  Tests whether the map's entrySet() is backed by the map by making sure\n-     *  a putAll on the map is reflected in the entrySet.  This test does\n-     *  nothing if add/remove modifications are not supported.\n-     **/\n-    public void testEntrySetChangesWithMapPutAll() {\n-        if (!isAddRemoveModifiable()) return;\n-\n-        Map m = makeFullMap();\n-        Set s = m.entrySet();\n-\n-        Map m2 = new HashMap();\n-        m2.put(\"1\", \"One\");\n-        m2.put(\"2\", \"Two\");\n-        m2.put(\"3\", \"Three\");\n-\n-        m.putAll(m2);\n-        entrySetEqualsMap(s, m);\n-    }\n-\n-\n-    /**\n-     *  Tests whether the map's entrySet() is backed by the map by making sure\n-     *  a remove from the entrySet's iterator is reflected in the map. This\n-     *  test does nothing if add/remove modifications are not supported.\n-     **/\n-    public void testEntrySetIteratorRemoveCausesMapModification() {\n-        if(!isAddRemoveModifiable()) return;\n-        \n-        Map m = makeFullMap();\n-        Set s = m.entrySet();\n-        Iterator iter = s.iterator();\n-        \n-        while(iter.hasNext()) {\n-            Map.Entry entry = (Map.Entry)iter.next();\n-            \n-            try {\n-                iter.remove();\n-                assertTrue(\"Entry key from entry set iterator must \" +\n-                           \"no longer exist in map\",\n-                           !m.containsKey(entry.getKey()));\n-            } catch (UnsupportedOperationException exception) {\n-                // isAddRemoveModifiable is true -- we've checked that above\n-                fail(\"iterator should not throw UnsupportedOperationException \" +\n-                     \"if the map supports adding and removing elements\");\n-            }\n-        }\n-    }\n \n     /**\n      *  Tests Map.equals(Object)\n         assertTrue(\"equals(new Object()) returned true.\", \n \t\t   !m.equals(new Object()));\n     }\n+\n \n     /**\n      *  Tests Map.get(Object)\n         assertTrue(\"Empty map toString() should not return null\", s != null);\n     }\n \n-    /**\n-     *  Tests Map.keySet()\n-     **/\n-    public void testMapKeySet() {\n-        Map m = makeFullMap();\n-        Map m2 = new HashMap(m);\n-        assertTrue(\"Equal maps have unequal keySets.\", \n-\t\t   m.keySet().equals(m2.keySet()));\n-    }\n-    \n-    //-------TEST AGAINST OPTIONAL OPERATIONS, ENABLE IN TEST SUBCLASSES\n \n     public void testMapSupportsNullValues() {\n \n         assertTrue(\"size of Map should be 3, but was \" + map.size(), map.size() == 3);\n     }\n \n-    public void testEntrySetRemove() {\n-\n-        if ((this instanceof TestMap.EntrySetSupportsRemove) == false ||\n-            (this instanceof TestMap.SupportsPut) == false) {\n-            return;\n-        }\n-\n-        Map map = makeEmptyMap();\n-        map.put(\"1\",\"1\");\n-        map.put(\"2\",\"2\");\n-        map.put(\"3\",\"3\");\n-\n-        Object o = map.entrySet().iterator().next();\n-        // remove one of the key/value pairs\n-        Set set = map.entrySet();\n-        set.remove(o);\n-        assertTrue(set.size() == 2);\n-        // try to remove it again, to make sure \n-        // the Set is not confused by missing entries\n-        set.remove(o);\n-\n-        assertTrue(\"size of Map should be 2, but was \" + map.size(), map.size() == 2);\n-\n-    }\n-\n-    public void testEntrySetContains() {\n-\n-        if ((this instanceof TestMap.SupportsPut) == false) {\n-            return;\n-        }\n-\n-        Map map = makeEmptyMap();\n-        map.put(\"1\",\"1\");\n-        map.put(\"2\",\"2\");\n-        map.put(\"3\",\"3\");\n-\n-        Set set = map.entrySet();\n-        Object o = set.iterator().next();\n-        assertTrue(\"entry set should contain valid element\",set.contains(o));\n-\n-        // create a fresh entry mapped to existing values\n-        DefaultMapEntry goodEntry  = new DefaultMapEntry(\"2\",\"2\");\n-        assertTrue(\"entry set should recognize externally constructed MapEntry objects\",\n-                   set.contains(goodEntry));\n-\n-        // make a bogus entry\n-        DefaultMapEntry badEntry = new DefaultMapEntry(\"4\",\"4\");\n-        assertTrue(\"entry set should not contain a bogus element\",\n-                   set.contains(badEntry) == false);\n-        \n-\n-    }\n \n     public void testEmptyMapSerialization() \n     throws IOException, ClassNotFoundException {\n     public void testMapPut() {\n         if (!isAddRemoveModifiable()) return;\n \n-        Map m = makeEmptyMap();\n+        resetEmpty();\n \n \tObject[] keys = getSampleKeys();\n \tObject[] values = getSampleValues();\n \tObject[] newValues = getNewSampleValues();\n \n-\tfor(int i = 0; i < keys.length; i++) {\n-\t    Object o = m.put(keys[i], values[i]);\n+        for(int i = 0; i < keys.length; i++) {\n+            Object o = map.put(keys[i], values[i]);\n+            confirmed.put(keys[i], values[i]);\n+            verify();\n \t    assertTrue(\"First map.put should return null\", o == null);\n \t    assertTrue(\"Map should contain key after put\", \n-\t\t       m.containsKey(keys[i]));\n+\t\t       map.containsKey(keys[i]));\n \t    assertTrue(\"Map should contain value after put\", \n-\t\t       m.containsValue(values[i]));\n+\t\t       map.containsValue(values[i]));\n \t}\n \t\n \tfor(int i = 0; i < keys.length; i++) {\n-\t    Object o = m.put(keys[i], newValues[i]);\n+\t    Object o = map.put(keys[i], newValues[i]);\n+            confirmed.put(keys[i], newValues[i]);\n+            verify();\n \t    assertEquals(\"Second map.put should return previous value\",\n \t\t\t values[i], o);\n \t    assertTrue(\"Map should still contain key after put\",\n-\t\t       m.containsKey(keys[i]));\n+\t\t       map.containsKey(keys[i]));\n \t    assertTrue(\"Map should contain new value after put\",\n-\t\t       m.containsValue(newValues[i]));\n+\t\t       map.containsValue(newValues[i]));\n \n \t    // if duplicates are allowed, we're not guarunteed that the value\n \t    // no longer exists, so don't try checking that.\n \t    if(!useDuplicateValues()) {\n \t\tassertTrue(\"Map should not contain old value after second put\",\n-\t\t\t   !m.containsValue(values[i]));\n+\t\t\t   !map.containsValue(values[i]));\n \t    }\n \t}\n     }\n     public void testMapPutAll() {\n         if (!isAddRemoveModifiable()) return;\n \n-        Map m = makeEmptyMap();\n-\tMap m2 = makeFullMap();\n-\n-\tm.putAll(m2);\n-\n-        assertTrue(\"Maps should be equal after putAll\", m.equals(m2));\n-\n-\t// repeat test with a different map implementation\n+        resetEmpty();\n+\n+        Map m2 = makeFullMap();\n+\n+        map.putAll(m2);\n+        confirmed.putAll(m2);\n+        verify();\n+\n+        resetEmpty();\n \n \tm2 = new HashMap();\n \tObject[] keys = getSampleKeys();\n \tfor(int i = 0; i < keys.length; i++) {\n \t    m2.put(keys[i], values[i]);\n \t}\n-\t\n-\tm = makeEmptyMap();\n-\tm.putAll(m2);\n-\t\n-\tassertTrue(\"Maps should be equal after putAll\", m.equals(m2));\n+\n+\tmap.putAll(m2);\n+        confirmed.putAll(m2);\n+        verify();\n     }\n \n     /**\n \n         Map m = makeEmptyMap();\n \tObject[] keys = getSampleKeys();\n+\tObject[] values = getSampleValues();\n \tfor(int i = 0; i < keys.length; i++) {\n \t    Object o = m.remove(keys[i]);\n \t    assertTrue(\"First map.remove should return null\", o == null);\n \t}\n \n-\tm = makeFullMap();\n-\tint startSize = m.size();\n-\n-\tObject[] values = getSampleValues();\n+        resetFull();\n \n \tfor(int i = 0; i < keys.length; i++) {\n-\t    Object o = m.remove(keys[i]);\n+\t    Object o = map.remove(keys[i]);\n+            confirmed.remove(keys[i]);\n+            verify();\n \n \t    assertEquals(\"map.remove with valid key should return value\",\n \t\t\t values[i], o);\n-\t    assertEquals(\"map.remove should reduce size by one\",\n-\t\t\t (startSize - i) - 1, m.size());\n \t}\n-    }\n-\n-    /**\n-     *  Tests Map.values()\n-     **/\n-    public void testMapValues() {\n-        Map m = makeFullMap();\n-\n-        // since Collection.equals is reference-based, have to do\n-        // this the long way...\n-\n-\tObject[] values = getSampleValues();\n-\n-\tCollection c = m.values();\n-\t\n-\tassertEquals(\"values() should have same size as map\", \n-\t\t     m.size(), c.size());\n-\n-\tassertEquals(\"values() should have same number of sample values\",\n-\t\t     values.length, c.size());\n-\n-\tboolean[] matched = new boolean[values.length];\n-\n-\tIterator iter = c.iterator();\n-\twhile(iter.hasNext()) {\n-\t    Object o = iter.next();\n-\t    boolean found = false;\n-\n-\t    for(int i = 0; i < values.length; i++) {\n-\t\t// skip values already matched\n-\t\tif(matched[i]) continue;\n-\t\t\n-\t\tif((o == null && values[i] == null) ||\n-\t\t   (o != null && o.equals(values[i]))) {\n-\t\t    matched[i] = true;\n-\t\t    found = true;\n-\t\t    break;\n-\t\t}\n-\t    }\n-\n-\t    if(!found) {\n-\t\t// no match for this element\n-\t\tfail(\"values() returned an unexpected value\");\n-\t    }\n-\t}\n-\n-\tfor(int i = 0; i < matched.length; i++) {\n-\t    if(!matched[i]) {\n-\t\tfail(\"values() did not return all values from map\");\n-\t    }\n-\t}\n-    }\n+\n+        Object[] other = getOtherKeys();\n+        m = makeFullMap();\n+        int size = m.size();\n+        for (int i = 0; i < other.length; i++) {\n+            Object o = m.remove(other[i]);\n+            assertEquals(\"map.remove for nonexistent key should return null\",\n+                         o, null);\n+            assertEquals(\"map.remove for nonexistent key should not \" +\n+                         \"shrink map\", size, m.size());\n+        }\n+    }\n+\n \n     /**\n      * Marker interface, indicating that a TestMap subclass\n \n     }\n \n-    public interface EntrySetSupportsRemove {\n-\n+\n+    /**\n+     *  Utility methods to create an array of Map.Entry objects\n+     *  out of the given key and value arrays.<P>\n+     *\n+     *  @param keys    the array of keys\n+     *  @param values  the array of values\n+     *  @return an array of Map.Entry of those keys to those values\n+     */\n+    private Map.Entry[] makeEntryArray(Object[] keys, Object[] values) {\n+        Map.Entry[] result = new Map.Entry[keys.length];\n+        for (int i = 0; i < keys.length; i++) {\n+            result[i] = new DefaultMapEntry(keys[i], values[i]);\n+        }\n+        return result;\n+    }\n+\n+\n+    /**\n+     *  Bulk test {@link Map#entrySet}.  This method runs through all of\n+     *  the tests in {@link TestSet}.  \n+     *  After modification operations, {@link #verify} is invoked to ensure\n+     *  that the map and the other collection views are still valid.\n+     *\n+     *  @return a {@link TestSet} instance for testing the map's entry set\n+     */\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestMapEntrySet();\n+    }\n+\n+    class TestMapEntrySet extends TestSet {\n+        public TestMapEntrySet() {\n+            super(\"\");\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        protected Object[] getFullElements() {\n+            Object[] k = getSampleKeys();\n+            Object[] v = getSampleValues();\n+            return makeEntryArray(k, v);\n+        }\n+        \n+        // Have to implement manually; entrySet doesn't support addAll\n+        protected Object[] getOtherElements() {\n+            Object[] k = getOtherKeys();\n+            Object[] v = getOtherValues();\n+            return makeEntryArray(k, v);\n+        }\n+        \n+        protected Set makeEmptySet() {\n+            return makeEmptyMap().entrySet();\n+        }\n+        \n+        protected Set makeFullSet() {\n+            return makeFullMap().entrySet();\n+        }\n+        \n+        protected boolean supportsAdd() {\n+            // Collection views don't support add operations.\n+            return false;\n+        }\n+        \n+        protected boolean supportsRemove() {\n+            // Entry set should only support remove if map does\n+            return isAddRemoveModifiable();\n+        }\n+        \n+        protected void resetFull() {\n+            TestMap.this.resetFull();\n+            collection = map.entrySet();\n+            TestMapEntrySet.this.confirmed = \n+                TestMap.this.confirmed.entrySet();\n+        }\n+        \n+        protected void resetEmpty() {\n+            TestMap.this.resetEmpty();\n+            collection = map.entrySet();\n+            TestMapEntrySet.this.confirmed = \n+                TestMap.this.confirmed.entrySet();\n+        }\n+        \n+        protected void verify() {\n+            super.verify();\n+            TestMap.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Bulk test {@link Map#keySet}.  This method runs through all of\n+     *  the tests in {@link TestSet}.  \n+     *  After modification operations, {@link #verify} is invoked to ensure\n+     *  that the map and the other collection views are still valid.\n+     *\n+     *  @return a {@link TestSet} instance for testing the map's key set\n+     */\n+    public BulkTest bulkTestMapKeySet() {\n+        return new TestMapKeySet();\n+    }\n+\n+    class TestMapKeySet extends TestSet {\n+        public TestMapKeySet() {\n+            super(\"\");\n+        }\n+        protected Object[] getFullElements() {\n+            return getSampleKeys();\n+        }\n+        \n+        protected Object[] getOtherElements() {\n+            return getOtherKeys();\n+        }\n+        \n+        protected Set makeEmptySet() {\n+            return makeEmptyMap().keySet();\n+        }\n+        \n+        protected Set makeFullSet() {\n+            return makeFullMap().keySet();\n+        }\n+        \n+        protected boolean supportsAdd() {\n+            return false;\n+        }\n+        \n+        protected boolean supportsRemove() {\n+            return isAddRemoveModifiable();\n+        }\n+        \n+        protected void resetEmpty() {\n+            TestMap.this.resetEmpty();\n+            collection = map.keySet();\n+            TestMapKeySet.this.confirmed = TestMap.this.confirmed.keySet();\n+        }\n+        \n+        protected void resetFull() {\n+            TestMap.this.resetFull();\n+            collection = map.keySet();\n+            TestMapKeySet.this.confirmed = TestMap.this.confirmed.keySet();\n+        }\n+        \n+        protected void verify() {\n+            super.verify();\n+            TestMap.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Bulk test {@link Map#values}.  This method runs through all of\n+     *  the tests in {@link TestCollection}.  \n+     *  After modification operations, {@link #verify} is invoked to ensure\n+     *  that the map and the other collection views are still valid.\n+     *\n+     *  @return a {@link TestCollection} instance for testing the map's \n+     *    values collection\n+     */\n+    public BulkTest bulkTestMapValues() {\n+        return new TestMapValues();\n+    }\n+\n+    class TestMapValues extends TestCollection {\n+        public TestMapValues() {\n+            super(\"\");\n+        }\n+\n+        protected Object[] getFullElements() {\n+            return getSampleValues();\n+        }\n+        \n+        protected Object[] getOtherElements() {\n+            return getOtherValues();\n+        }\n+        \n+        protected Collection makeCollection() {\n+            return makeEmptyMap().values();\n+        }\n+        \n+        protected Collection makeFullCollection() {\n+            return makeFullMap().values();\n+        }\n+        \n+        protected boolean supportsAdd() {\n+            return false;\n+        }\n+        \n+        protected boolean supportsRemove() {\n+            return isAddRemoveModifiable();\n+        }\n+        \n+        protected Collection makeConfirmedCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+        \n+        protected Collection makeConfirmedFullCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+        \n+        protected void resetFull() {\n+            TestMap.this.resetFull();\n+            collection = map.values();\n+            TestMapValues.this.confirmed = TestMap.this.confirmed.values();\n+        }\n+        \n+        protected void resetEmpty() {\n+            TestMap.this.resetEmpty();\n+            collection = map.values();\n+            TestMapValues.this.confirmed = TestMap.this.confirmed.values();\n+        }\n+        \n+        protected void verify() {\n+            super.verify();\n+            TestMap.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     *  {@link #values} and {@link #confirmed} fields to empty.\n+     */\n+    protected void resetEmpty() {\n+        this.map = makeEmptyMap();\n+        views();\n+        this.confirmed = new HashMap();\n+    }\n+\n+\n+    /**\n+     *  Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     *  {@link #values} and {@link #confirmed} fields to full.\n+     */\n+    protected void resetFull() {\n+        this.map = makeFullMap();\n+        views();\n+        this.confirmed = new HashMap();\n+        Object[] k = getSampleKeys();\n+        Object[] v = getSampleValues();\n+        for (int i = 0; i < k.length; i++) {\n+            confirmed.put(k[i], v[i]);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Resets the collection view fields.\n+     */\n+    private void views() {\n+        this.keySet = map.keySet();\n+        this.values = map.values();\n+        this.entrySet = map.entrySet();\n+    }\n+\n+\n+    /**\n+     *  Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     *  This method checks that the map is equal to the HashMap, \n+     *  <I>and</I> that the map's collection views are still equal to\n+     *  the HashMap's collection views.  An <Code>equals</Code> test\n+     *  is done on the maps and their collection views; their size and\n+     *  <Code>isEmpty</Code> results are compared; their hashCodes are\n+     *  compared; and <Code>containsAll</Code> tests are run on the \n+     *  collection views.\n+     */\n+    protected void verify() {\n+        Bag bag1 = new HashBag(confirmed.values());\n+        Bag bag2 = new HashBag(values);\n+\n+        assertEquals(\"Map should still equal HashMap\", confirmed, map);\n+        assertEquals(\"Map's entry set should still equal HashMap's\", \n+                     confirmed.entrySet(), entrySet);\n+        assertEquals(\"Map's key set should still equal HashMap's\",\n+                     confirmed.keySet(), keySet);\n+        assertEquals(\"Map's values should still equal HashMap's\",\n+                     bag1, bag2);\n+        \n+        int size = confirmed.size();\n+        assertEquals(\"Map should be same size as HashMap\", \n+                     size, map.size());\n+        assertEquals(\"keySet should be same size as HashMap's\",\n+                     size, keySet.size());\n+        assertEquals(\"entrySet should be same size as HashMap's\",\n+                     size, entrySet.size());\n+        assertEquals(\"values should be same size as HashMap's\",\n+                     size, values.size());\n+        \n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"Map should be empty if HashMap is\", \n+                     empty, map.isEmpty());\n+        assertEquals(\"keySet should be empty if HashMap is\", \n+                     empty, keySet.isEmpty());\n+        assertEquals(\"entrySet should be empty if HashMap is\", \n+                     empty, entrySet.isEmpty());\n+        assertEquals(\"values should be empty if HashMap is\", \n+                     empty, values.isEmpty());\n+        \n+        assertTrue(\"entrySet should contain all HashMap's elements\",\n+                   entrySet.containsAll(confirmed.entrySet()));\n+        assertTrue(\"keySet should contain all HashMap's elements\",\n+                   keySet.containsAll(confirmed.keySet()));\n+        assertTrue(\"values should contain all HashMap's elements\",\n+                   values.containsAll(confirmed.values()));\n+        \n+        assertEquals(\"hashCodes should be the same\",\n+                     confirmed.hashCode(), map.hashCode());\n+        assertEquals(\"entrySet hashCodes should be the same\", \n+                     confirmed.entrySet().hashCode(), entrySet.hashCode());\n+        assertEquals(\"keySet hashCodes should be the same\", \n+                     confirmed.keySet().hashCode(), keySet.hashCode());\n+        assertEquals(\"values hashCodes should be the same\", \n+                     bag1.hashCode(), bag2.hashCode());\n+    }\n+\n+\n+    /**\n+     *  Erases any leftover instance variables by setting them to null.\n+     */\n+    protected void tearDown() {\n+        map = null;\n+        keySet = null;\n+        entrySet = null;\n+        values = null;\n+        confirmed = null;\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  */\n public class TestSequencedHashMap extends TestMap \n-implements TestMap.SupportsPut, TestMap.EntrySetSupportsRemove\n+implements TestMap.SupportsPut\n {\n     /**\n      * The instance to experiment on.", "timestamp": 1024370254, "metainfo": ""}