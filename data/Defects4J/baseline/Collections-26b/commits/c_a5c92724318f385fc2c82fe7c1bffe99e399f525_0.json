{"sha": "a5c92724318f385fc2c82fe7c1bffe99e399f525", "log": "Improved javadoc of Trie interface.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/Trie.java\n+++ b/src/main/java/org/apache/commons/collections/Trie.java\n      * return 'L', because the XOR distance between D &amp; L is smaller \n      * than the XOR distance between D &amp; H. \n      * \n-     * @return The {@link Entry} whose key is closest in a bitwise XOR metric\n-     * to the provided key.\n+     * @param key  the key to use in the search\n+     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n+     *   to the provided key\n      */\n     public Map.Entry<K, V> select(K key);\n     \n      * return 'L', because the XOR distance between D &amp; L is smaller \n      * than the XOR distance between D &amp; H. \n      * \n-     * @return The key that is closest in a bitwise XOR metric to the provided key.\n+     * @param key  the key to use in the search\n+     * @return the key that is closest in a bitwise XOR metric to the provided key\n      */\n     public K selectKey(K key);\n     \n      * return 'L', because the XOR distance between D &amp; L is smaller \n      * than the XOR distance between D &amp; H. \n      * \n-     * @return The value whose key is closest in a bitwise XOR metric\n-     * to the provided key.\n+     * @param key  the key to use in the search\n+     * @return the value whose key is closest in a bitwise XOR metric\n+     * to the provided key\n      */\n     public V selectValue(K key);\n     \n      * entry is found, the {@link Trie} will call select on that entry and continue\n      * calling select for each entry (traversing in order of XOR closeness,\n      * NOT lexicographically) until the cursor returns {@link Decision#EXIT}.\n-     * \n-     * <p>The cursor can return {@link Decision#CONTINUE} to continue traversing.\n-     * \n-     * <p>{@link Decision#REMOVE_AND_EXIT} is used to remove the current element\n+     * <p>\n+     * The cursor can return {@link Decision#CONTINUE} to continue traversing.\n+     * <p>\n+     * {@link Decision#REMOVE_AND_EXIT} is used to remove the current element\n      * and stop traversing.\n-     * \n-     * <p>Note: The {@link Decision#REMOVE} operation is not supported.\n-     * \n-     * @return The entry the cursor returned {@link Decision#EXIT} on, or null \n-     * if it continued till the end.\n+     * <p>\n+     * Note: The {@link Decision#REMOVE} operation is not supported.\n+     * \n+     * @param key  the key to use in the search\n+     * @param cursor  the cursor used throughout the search\n+     * @return the entry the cursor returned {@link Decision#EXIT} on, or null \n+     * if it continued till the end\n      */\n     public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor);\n     \n     /**\n      * Traverses the {@link Trie} in lexicographical order. \n      * {@link Cursor#select(java.util.Map.Entry)} will be called on each entry.\n-     * \n-     * <p>The traversal will stop when the cursor returns {@link Decision#EXIT}, \n+     * <p>\n+     * The traversal will stop when the cursor returns {@link Decision#EXIT}, \n      * {@link Decision#CONTINUE} is used to continue traversing and \n      * {@link Decision#REMOVE} is used to remove the element that was selected \n      * and continue traversing.\n-     * \n-     * <p>{@link Decision#REMOVE_AND_EXIT} is used to remove the current element\n+     * <p>\n+     * {@link Decision#REMOVE_AND_EXIT} is used to remove the current element\n      * and stop traversing.\n      *   \n-     * @return The entry the cursor returned {@link Decision#EXIT} on, or null \n-     * if it continued till the end.\n+     * @param cursor  the cursor used while traversing the {@link Trie}\n+     * @return the entry the cursor returned {@link Decision#EXIT} on, or null \n+     * if it continued till the end\n      */\n     public Map.Entry<K,V> traverse(Cursor<? super K, ? super V> cursor);\n     \n     /**\n-     * Returns a view of this {@link SortedTrie} of all elements that are prefixed \n+     * Returns a view of this {@link Trie} of all elements that are prefixed \n      * by the given key.\n-     * \n-     * <p>In a {@link SortedTrie} with fixed size keys, this is essentially a \n+     * <p>\n+     * In a {@link Trie} with fixed size keys, this is essentially a \n      * {@link #get(Object)} operation.\n-     * \n-     * <p>For example, if the {@link SortedTrie} contains 'Anna', 'Anael', \n+     * <p>\n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', \n      * 'Analu', 'Andreas', 'Andrea', 'Andres', and 'Anatole', then\n      * a lookup of 'And' would return 'Andreas', 'Andrea', and 'Andres'.\n+     * \n+     * @param key  the key used in the search\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedBy(K key);\n     \n     /**\n-     * Returns a view of this {@link SortedTrie} of all elements that are prefixed \n+     * Returns a view of this {@link Trie} of all elements that are prefixed \n      * by the length of the key.\n-     * \n-     * <p>{@link SortedTrie}s with fixed size keys will not support this operation \n+     * <p>\n+     * {@link Trie}s with fixed size keys will not support this operation \n      * (because all keys are the same length).\n-     * \n-     * <p>For example, if the {@link SortedTrie} contains 'Anna', 'Anael', 'Analu', \n+     * <p>\n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu', \n      * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for 'Andrey' \n      * and a length of 4 would return 'Andreas', 'Andrea', and 'Andres'.\n+     * \n+     * @param key  the key used in the search\n+     * @param length  the length of the prefix\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedBy(K key, int length);\n     \n     /**\n-     * Returns a view of this {@link SortedTrie} of all elements that are prefixed\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the key, starting at the given offset and for the given length.\n-     * \n-     * <p>{@link SortedTrie}s with fixed size keys will not support this operation \n+     * <p>\n+     * {@link Trie}s with fixed size keys will not support this operation \n      * (because all keys are the same length).\n-     * \n-     * <p>For example, if the {@link SortedTrie} contains 'Anna', 'Anael', 'Analu', \n+     * <p>\n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu', \n      * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for \n      * 'Hello Andrey Smith', an offset of 6 and a length of 4 would return \n      * 'Andreas', 'Andrea', and 'Andres'.\n+     * \n+     * @param key  the key used in the search\n+     * @param offset  the prefix start\n+     * @param length  the length of the prefix\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedBy(K key, int offset, int length);\n     \n     /**\n-     * Returns a view of this {@link SortedTrie} of all elements that are prefixed\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the number of bits in the given Key.\n-     * \n-     * <p>In {@link SortedTrie}s with fixed size keys like IP addresses this method\n+     * <p>\n+     * In {@link Trie}s with fixed size keys like IP addresses this method\n      * can be used to lookup partial keys. That is you can lookup all addresses\n      * that begin with '192.168' by providing the key '192.168.X.X' and a \n      * length of 16.\n+     * \n+     * @param key  the key to use in the search\n+     * @param lengthInBits  the number of significant key bits\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits);\n     \n     /**\n-     * Returns a view of this {@link SortedTrie} of all elements that are prefixed\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n      * by the number of bits in the given Key.\n+     * \n+     * @param key  the key to use in the search\n+     * @param offsetInBits  the prefix offset\n+     * @param lengthInBits  the number of significant prefix bits\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n      */\n     public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits);\n     \n          * {@link Decision#REMOVE} to remove the {@link Entry} and\n          * continue iterating or {@link Decision#REMOVE_AND_EXIT} to\n          * remove the {@link Entry} and stop iterating.\n+         * <p>\n+         * Note: Not all operations support {@link Decision#REMOVE}.\n          * \n-         * Note: Not all operations support {@link Decision#REMOVE}.\n+         * @param entry  the current entry\n+         * @return the {@link Decision} based on the current entry\n          */\n         public Decision select(Map.Entry<? extends K, ? extends V> entry);\n     }", "timestamp": 1344694043, "metainfo": ""}