{"sha": "e76bffaf9634b2f69c1c85fe39b3c26c68cee461", "log": "Catch errors that may occur if LRUMap is used incorrectly These can be used for debugging if LRUMap has a bug bug 32573  ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/java/org/apache/commons/collections/map/LRUMap.java\n             entry.before = header.before;\n             header.before.after = entry;\n             header.before = entry;\n+        } else if (entry == header) {\n+            throw new IllegalStateException(\"Can't move header to MRU\" +\n+                \" (please report this to commons-dev@jakarta.apache.org)\");\n         }\n     }\n     \n             LinkEntry reuse = header.after;\n             boolean removeLRUEntry = false;\n             if (scanUntilRemovable) {\n-                while (reuse != header) {\n+                while (reuse != header && reuse != null) {\n                     if (removeLRU(reuse)) {\n                         removeLRUEntry = true;\n                         break;\n                     }\n                     reuse = reuse.after;\n                 }\n+                if (reuse == null) {\n+                    throw new IllegalStateException(\n+                        \"Entry.after=null, header.after\" + header.after + \" header.before\" + header.before +\n+                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                        \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                        \" If so, then please report this to commons-dev@jakarta.apache.org as a bug.\");\n+                }\n             } else {\n                 removeLRUEntry = removeLRU(reuse);\n             }\n             \n             if (removeLRUEntry) {\n+                if (reuse == null) {\n+                    throw new IllegalStateException(\n+                        \"reuse=null, header.after=\" + header.after + \" header.before\" + header.before +\n+                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                        \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                        \" If so, then please report this to commons-dev@jakarta.apache.org as a bug.\");\n+                }\n                 reuseMapping(reuse, hashIndex, hashCode, key, value);\n             } else {\n                 super.addMapping(hashIndex, hashCode, key, value);\n         // find the entry before the entry specified in the hash table\n         // remember that the parameters (except the first) refer to the new entry,\n         // not the old one\n-        int removeIndex = hashIndex(entry.hashCode, data.length);\n-        HashEntry loop = data[removeIndex];\n-        HashEntry previous = null;\n-        while (loop != entry) {\n-            previous = loop;\n-            loop = loop.next;\n+        try {\n+            int removeIndex = hashIndex(entry.hashCode, data.length);\n+            HashEntry[] tmp = data;  // may protect against some sync issues\n+            HashEntry loop = tmp[removeIndex];\n+            HashEntry previous = null;\n+            while (loop != entry && loop != null) {\n+                previous = loop;\n+                loop = loop.next;\n+            }\n+            if (loop == null) {\n+                throw new IllegalStateException(\n+                    \"Entry.next=null, data[removeIndex]=\" + data[removeIndex] + \" previous=\" + previous +\n+                    \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to commons-dev@jakarta.apache.org as a bug.\");\n+            }\n+            \n+            // reuse the entry\n+            modCount++;\n+            removeEntry(entry, removeIndex, previous);\n+            reuseEntry(entry, hashIndex, hashCode, key, value);\n+            addEntry(entry, hashIndex);\n+        } catch (NullPointerException ex) {\n+            throw new IllegalStateException(\n+                    \"NPE, entry=\" + entry + \" entryIsHeader=\" + (entry==header) +\n+                    \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to commons-dev@jakarta.apache.org as a bug.\");\n         }\n-        \n-        // reuse the entry\n-        modCount++;\n-        removeEntry(entry, removeIndex, previous);\n-        reuseEntry(entry, hashIndex, hashCode, key, value);\n-        addEntry(entry, hashIndex);\n     }\n     \n     /**", "timestamp": 1131895314, "metainfo": ""}