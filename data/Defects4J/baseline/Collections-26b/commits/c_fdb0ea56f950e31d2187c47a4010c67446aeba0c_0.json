{"sha": "fdb0ea56f950e31d2187c47a4010c67446aeba0c", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r740155 | mbenson | 2009-02-02 15:42:27 -0800 (Mon, 02 Feb 2009) | 1 line          remove unnecessarily overridden method     ------------------------------------------------------------------------     r740150 | mbenson | 2009-02-02 15:24:00 -0800 (Mon, 02 Feb 2009) | 1 line          make all [collections] maps implement IterableMap     ------------------------------------------------------------------------     r471189 | scolebourne | 2006-11-04 05:57:57 -0800 (Sat, 04 Nov 2006) | 1 line          Remove getMap(), getOrderedMap() and getSortedMap() - use decorated()     ------------------------------------------------------------------------     r471180 | scolebourne | 2006-11-04 05:27:44 -0800 (Sat, 04 Nov 2006) | 1 line          Abstract*Decorator - Generify and use covariant return types     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/AbstractMapDecorator.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractMapDecorator.java\n  * implementation it would provide a loophole around the validation.\n  * But, you might want that loophole, so this class is kept simple.\n  *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Daniel Rall\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractMapDecorator implements Map {\n+public abstract class AbstractMapDecorator<K, V> extends AbstractIterableMap<K, V> {\n \n     /** The map to decorate */\n-    protected transient Map map;\n+    protected transient Map<K, V> map;\n \n     /**\n      * Constructor only used in deserialization, do not use otherwise.\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractMapDecorator(Map map) {\n+    protected AbstractMapDecorator(Map<K, V> map) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n      * \n      * @return the decorated map\n      */\n-    protected Map getMap() {\n+    protected Map<K, V> decorated() {\n         return map;\n     }\n \n     //-----------------------------------------------------------------------\n     public void clear() {\n-        map.clear();\n+        decorated().clear();\n     }\n \n     public boolean containsKey(Object key) {\n-        return map.containsKey(key);\n+        return decorated().containsKey(key);\n     }\n \n     public boolean containsValue(Object value) {\n-        return map.containsValue(value);\n+        return decorated().containsValue(value);\n     }\n \n-    public Set entrySet() {\n-        return map.entrySet();\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return decorated().entrySet();\n     }\n \n-    public Object get(Object key) {\n-        return map.get(key);\n+    public V get(Object key) {\n+        return decorated().get(key);\n     }\n \n     public boolean isEmpty() {\n-        return map.isEmpty();\n+        return decorated().isEmpty();\n     }\n \n-    public Set keySet() {\n-        return map.keySet();\n+    public Set<K> keySet() {\n+        return decorated().keySet();\n     }\n \n-    public Object put(Object key, Object value) {\n-        return map.put(key, value);\n+    public V put(K key, V value) {\n+        return decorated().put(key, value);\n     }\n \n-    public void putAll(Map mapToCopy) {\n-        map.putAll(mapToCopy);\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        decorated().putAll(mapToCopy);\n     }\n \n-    public Object remove(Object key) {\n-        return map.remove(key);\n+    public V remove(Object key) {\n+        return decorated().remove(key);\n     }\n \n     public int size() {\n-        return map.size();\n+        return decorated().size();\n     }\n \n-    public Collection values() {\n-        return map.values();\n+    public Collection<V> values() {\n+        return decorated().values();\n     }\n    \n     public boolean equals(Object object) {\n         if (object == this) {\n             return true;\n         }\n-        return map.equals(object);\n+        return decorated().equals(object);\n     }\n \n     public int hashCode() {\n-        return map.hashCode();\n+        return decorated().hashCode();\n     }\n \n     public String toString() {\n-        return map.toString();\n+        return decorated().toString();\n     }\n \n }", "timestamp": 1252994153, "metainfo": ""}