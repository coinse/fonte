{"sha": "10af29350dc0b3f79ce6f05fb062827d7eaef415", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r555925 | skestle | 2007-07-13 03:39:24 -0700 (Fri, 13 Jul 2007) | 2 lines          Added Edwin Tellman's patch for COLLECTIONS-243.       It all seems pretty reasonable, and it should all be checked again as the project is worked through     ------------------------------------------------------------------------     r471575 | scolebourne | 2006-11-05 15:58:08 -0800 (Sun, 05 Nov 2006) | 1 line          Generify and remove AbstractSerializableCollectionDecorator     ------------------------------------------------------------------------     r471202 | scolebourne | 2006-11-04 06:21:44 -0800 (Sat, 04 Nov 2006) | 1 line          Remove getCollection() - use covariant decorated()     ------------------------------------------------------------------------     r471173 | scolebourne | 2006-11-04 04:07:39 -0800 (Sat, 04 Nov 2006) | 1 line          Abstract*Decorator - Generify and use covariant return types     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/collection/AbstractCollectionDecorator.java\n+++ b/src/java/org/apache/commons/collections/collection/AbstractCollectionDecorator.java\n  */\n package org.apache.commons.collections.collection;\n \n+import java.io.Serializable;\n import java.util.Collection;\n import java.util.Iterator;\n \n  * wrapped collection. This may be undesirable, for example if you are trying\n  * to write an unmodifiable implementation it might provide a loophole.\n  *\n+ * @param <E> the type of the elements in the collection\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  * @author Paul Jack\n  */\n-public abstract class AbstractCollectionDecorator implements Collection {\n+public abstract class AbstractCollectionDecorator<E>\n+        implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6249888059822088500L;\n \n     /** The collection being decorated */\n-    protected Collection collection;\n+    protected Collection<E> collection;\n \n     /**\n      * Constructor only used in deserialization, do not use otherwise.\n      * @param coll  the collection to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    protected AbstractCollectionDecorator(Collection coll) {\n+    protected AbstractCollectionDecorator(Collection<E> coll) {\n         if (coll == null) {\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n \n     /**\n      * Gets the collection being decorated.\n+     * All access to the decorated collection goes via this method.\n      * \n      * @return the decorated collection\n      */\n-    protected Collection getCollection() {\n+    protected Collection<E> decorated() {\n         return collection;\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean add(Object object) {\n-        return collection.add(object);\n+    public boolean add(E object) {\n+        return decorated().add(object);\n     }\n \n-    public boolean addAll(Collection coll) {\n-        return collection.addAll(coll);\n+    public boolean addAll(Collection<? extends E> coll) {\n+        return decorated().addAll(coll);\n     }\n \n     public void clear() {\n-        collection.clear();\n+        decorated().clear();\n     }\n \n     public boolean contains(Object object) {\n-        return collection.contains(object);\n+        return decorated().contains(object);\n     }\n \n     public boolean isEmpty() {\n-        return collection.isEmpty();\n+        return decorated().isEmpty();\n     }\n \n-    public Iterator iterator() {\n-        return collection.iterator();\n+    public Iterator<E> iterator() {\n+        return decorated().iterator();\n     }\n \n     public boolean remove(Object object) {\n-        return collection.remove(object);\n+        return decorated().remove(object);\n     }\n \n     public int size() {\n-        return collection.size();\n+        return decorated().size();\n     }\n \n     public Object[] toArray() {\n-        return collection.toArray();\n+        return decorated().toArray();\n     }\n \n-    public Object[] toArray(Object[] object) {\n-        return collection.toArray(object);\n+    public <T> T[] toArray(T[] object) {\n+        return decorated().toArray(object);\n     }\n \n-    public boolean containsAll(Collection coll) {\n-        return collection.containsAll(coll);\n+    public boolean containsAll(Collection<?> coll) {\n+        return decorated().containsAll(coll);\n     }\n \n-    public boolean removeAll(Collection coll) {\n-        return collection.removeAll(coll);\n+    public boolean removeAll(Collection<?> coll) {\n+        return decorated().removeAll(coll);\n     }\n \n-    public boolean retainAll(Collection coll) {\n-        return collection.retainAll(coll);\n+    public boolean retainAll(Collection<?> coll) {\n+        return decorated().retainAll(coll);\n     }\n \n     public boolean equals(Object object) {\n-        if (object == this) {\n-            return true;\n-        }\n-        return collection.equals(object);\n+        return object == this || decorated().equals(object);\n     }\n \n     public int hashCode() {\n-        return collection.hashCode();\n+        return decorated().hashCode();\n     }\n \n     public String toString() {\n-        return collection.toString();\n+        return decorated().toString();\n     }\n \n }", "timestamp": 1252994081, "metainfo": ""}